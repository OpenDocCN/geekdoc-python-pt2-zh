- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**Working with Numbers**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**与数字的操作**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: Let’s take our first steps toward using Python to explore the world of math
    and science. We’ll keep it simple now so you can get a handle on using Python
    itself. We’ll start by performing basic mathematical operations, and then we’ll
    write simple programs for manipulating and understanding numbers. Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们迈出第一步，利用 Python 探索数学和科学的世界。现在我们保持简单，帮助你掌握如何使用 Python。本节我们将从执行基本的数学运算开始，然后编写简单的程序来处理和理解数字。让我们开始吧！
- en: '**Basic Mathematical Operations**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本数学运算**'
- en: The *Python interactive shell* is going to be our friend in this book. Start
    the Python 3 IDLE shell and say “hello” (see [Figure 1-1](ch01.html#ch1fig1))
    by typing print('Hello IDLE') and then pressing ENTER. (For instructions on how
    to install Python and start IDLE, see [Appendix A](app01.html#app01).) IDLE obeys
    your command and prints the words back to the screen. Congratulations—you just
    wrote a program!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 交互式 shell* 将是我们在本书中的好伙伴。启动 Python 3 IDLE shell，并通过输入 print(''Hello
    IDLE'') 然后按下 ENTER 来打个“招呼”（见 [图 1-1](ch01.html#ch1fig1)）。(有关如何安装 Python 和启动 IDLE
    的说明，请参见 [附录 A](app01.html#app01)。) IDLE 会按照你的命令操作，并将文字输出到屏幕上。恭喜你——你刚刚写了一个程序！'
- en: When you see the >>> prompt again, IDLE is ready for more instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次看到 >>> 提示符时，IDLE 已准备好接收更多指令。
- en: '![image](images/f01-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f01-01.jpg)'
- en: '*Figure 1-1: Python 3 IDLE shell*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：Python 3 IDLE shell*'
- en: Python can act like a glorified calculator, doing simple computations. Just
    type an expression and Python will evaluate it. After you press ENTER, the result
    appears immediately.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以像一个增强版的计算器一样进行简单的计算。只需输入表达式，Python 会对其进行求值。按下 ENTER 后，结果会立即显示出来。
- en: 'Give it a try. You can add and subtract numbers using the addition (+) and
    subtraction (–) operators. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看。你可以使用加法（+）和减法（–）运算符来加减数字。例如：
- en: '>>> 1 + 2'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1 + 2'
- en: '3'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> 1 + 3.5'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1 + 3.5'
- en: '4.5'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '4.5'
- en: '>>> -1 + 2.5'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -1 + 2.5'
- en: '1.5'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '1.5'
- en: '>>> 100 – 45'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 100 – 45'
- en: '55'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: '>>> -1.1 + 5'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -1.1 + 5'
- en: '3.9'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '3.9'
- en: 'To multiply, use the multiplication (*) operator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行乘法运算，请使用乘法（*）运算符：
- en: '>>> 3 * 2'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 3 * 2'
- en: '6'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '>>> 3.5 * 1.5'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 3.5 * 1.5'
- en: '5.25'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '5.25'
- en: 'To divide, use the division (/) operator:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行除法运算，请使用除法（/）运算符：
- en: '>>> 3 / 2'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 3 / 2'
- en: '1.5'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '1.5'
- en: '>>> 4 / 2'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 / 2'
- en: '2.0'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0'
- en: 'As you can see, when you ask Python to perform a division operation, it returns
    the fractional part of the number as well. If you want the result in the form
    of an integer, with any decimal values removed, you should use the floor division
    (//) operator:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你让 Python 执行除法运算时，它会返回数字的分数部分。如果你希望结果是整数形式，去除任何小数值，你应该使用地板除法（//）运算符：
- en: '>>> 3 // 2'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 3 // 2'
- en: '1'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'The floor division operator divides the first number by the second number and
    then rounds down the result to the next lowest integer. This becomes interesting
    when one of the numbers is negative. For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 地板除法运算符将第一个数字除以第二个数字，然后将结果向下舍入到最接近的整数。当其中一个数字是负数时，这个操作就变得有趣。例如：
- en: '>>> -3 // 2'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -3 // 2'
- en: '-2'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '-2'
- en: The final result is the integer lower than the result of the division operation
    (-3/2 = -1.5, so the final result is -2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是小于除法运算结果的整数（-3/2 = -1.5，因此最终结果为 -2）。
- en: 'On the other hand, if you want just the remainder, you should use the modulo
    (%) operator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你只想要余数，你应该使用取模（%）运算符：
- en: '>>> 9 % 2'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 % 2'
- en: '1'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'You can calculate the power of numbers using the exponential (**) operator.
    The examples below illustrate this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用指数（**）运算符来计算数字的幂。下面的例子说明了这一点：
- en: '>>> 2 ** 2'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2 ** 2'
- en: '4'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> 2 ** 10'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2 ** 10'
- en: '1024'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '1024'
- en: '>>> 1 ** 10'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1 ** 10'
- en: '1'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'We can also use the exponential symbol to calculate powers less than 1\. For
    example, the square root of a number *n* can be expressed as *n*^(1/2) and the
    cube root as *n*^(1/3):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用指数符号来计算小于 1 的幂。例如，一个数字 *n* 的平方根可以表示为 *n*^(1/2)，立方根可以表示为 *n*^(1/3)：
- en: '>>> 8 ** (1/3)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 ** (1/3)'
- en: '2.0'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0'
- en: 'As this example shows, you can use parentheses to combine mathematical operations
    into more complicated expressions. Python will evaluate the expression following
    the standard *PEMDAS* rule for the order of calculations—parentheses, exponents,
    multiplication, division, addition, and subtraction. Consider the following two
    expressions—one without parentheses and one with:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如这个例子所示，你可以使用括号将多个数学运算结合成更复杂的表达式。Python 会按照标准的 *PEMDAS* 规则评估表达式中的计算顺序——括号、指数、乘法、除法、加法和减法。请看以下两个表达式——一个没有括号，另一个有括号：
- en: '>>> 5 + 5 * 5'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 + 5 * 5'
- en: '30'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '>>> (5 + 5) * 5'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (5 + 5) * 5'
- en: '50'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: 'In the first example, Python calculates the multiplication first: 5 times 5
    is 25; 25 plus 5 is 30\. In the second example, the expression within the parentheses
    is evaluated first, just as we’d expect: 5 plus 5 is 10; 10 times 5 is 50.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，Python 首先计算乘法：5 乘以 5 得到 25；25 加上 5 得到 30。在第二个例子中，括号内的表达式首先被计算，正如我们预期的那样：5
    加上 5 得到 10；10 乘以 5 得到 50。
- en: These are the absolute basics of manipulating numbers in Python. Let’s now learn
    how we can assign names to numbers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Python 中操作数字的基本知识。接下来我们来学习如何为数字赋予名称。
- en: '**Labels: Attaching Names to Numbers**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**标签：为数字附加名称**'
- en: 'As we start designing more complex Python programs, we’ll assign names to numbers—at
    times for convenience, but mostly out of necessity. Here’s a simple example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始设计更复杂的 Python 程序时，我们会为数字赋予名称——有时是为了方便，但更多的是出于必要。这里有一个简单的例子：
- en: ➊ >>> a = 3
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> a = 3
- en: '>>> a + 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a + 1'
- en: '4'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: ➋ >>> a = 5
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> a = 5
- en: '>>> a + 1'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a + 1'
- en: '6'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: At ➊, we assign the name a to the number 3\. When we ask Python to evaluate
    the result of the expression a + 1, it sees that the number that a refers to is
    3, and then it adds 1 and displays the output (4). At ➋, we change the value of
    a to 5, and this is reflected in the second addition operation. Using the name
    a is convenient because you can simply change the number that a points to and
    Python uses this new value when a is referred to anywhere after that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将数字 3 赋予名称 a。当我们要求 Python 计算表达式 a + 1 的结果时，它看到 a 所指向的数字是 3，然后它加上 1 并显示输出（4）。在
    ➋ 处，我们将 a 的值改为 5，这个变化反映在第二次加法操作中。使用名称 a 很方便，因为你可以简单地改变 a 所指向的数字，之后在任何地方引用 a 时，Python
    会使用这个新值。
- en: This kind of name is called a *label*. You may have been introduced to the term
    *variable* to describe the same idea elsewhere. However, considering that *variable*
    is also a mathematical term (used to refer to something like *x* in the equation
    *x* + 2 = 3), in this book I use the term *variable* only in the context of mathematical
    equations and expressions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种名称叫做*标签*。你可能在其他地方接触过术语*变量*来描述这个概念。然而，考虑到*变量*也是一个数学术语（用来指代像方程式 *x* + 2 = 3
    中的 *x* 这样的东西），在本书中我只在数学方程和表达式的上下文中使用“变量”一词。
- en: '**Different Kinds of Numbers**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同种类的数字**'
- en: You may have noticed that I’ve used two kinds of numbers to demonstrate the
    mathematical operations—numbers without a decimal point, which you already know
    as *integers*, and numbers with a decimal point, which programmers call *floating
    point numbers*. We humans have no trouble recognizing and working with numbers
    whether they’re written as integers, floating point decimals, fractions, or roman
    numerals. But in some of the programs that we write in this book, it will only
    make sense to perform a task on a particular type of number, so we’ll often have
    to write a bit of code to have the programs check whether the numbers we input
    are of the right type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我使用了两种不同的数字来演示数学运算——没有小数点的数字，你已经知道它们是*整数*，以及带有小数点的数字，程序员称之为*浮动点数*。我们人类在识别和操作数字时没有任何问题，无论它们是以整数、浮动小数、分数还是罗马数字的形式出现。但在我们编写的某些程序中，只有对特定类型的数字执行任务才有意义，因此我们经常需要写一些代码，检查输入的数字是否属于正确的类型。
- en: 'Python considers integers and floating point numbers to be different *types*.
    If you use the function type(), Python will tell you what kind of number you’ve
    just input. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将整数和浮动点数视为不同的*类型*。如果你使用 type() 函数，Python 会告诉你你刚刚输入的是什么类型的数字。例如：
- en: '>>> type(3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(3)'
- en: <class 'int'>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'int'>
- en: '>>> type(3.5)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(3.5)'
- en: <class 'float'>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: '>>> type(3.0)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(3.0)'
- en: <class 'float'>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: Here, you can see that Python classifies the number 3 as an integer (type 'int')
    but classifies 3.0 as a floating point number (type 'float'). We all know that
    3 and 3.0 are mathematically equivalent, but in many situations, Python will treat
    these two numbers differently because they are two different types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Python 将数字 3 分类为整数（类型为 'int'），但将 3.0 分类为浮动点数（类型为 'float'）。我们都知道 3
    和 3.0 在数学上是等价的，但在许多情况下，Python 会将这两个数字视为不同的类型，因此它们会被不同对待。
- en: 'Some of the programs we write in this chapter will work properly only with
    an integer as an input. As we just saw, Python won’t recognize a number like 1.0
    or 4.0 as an integer, so if we want to accept numbers like that as valid input
    in these programs, we’ll have to convert them from floating point numbers to integers.
    Luckily, there’s a function built in to Python that does just that:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们编写的一些程序只有在输入为整数时才能正常工作。正如我们刚才看到的，Python 不会将像 1.0 或 4.0 这样的数字识别为整数，因此如果我们希望在这些程序中接受这样的数字作为有效输入，我们就需要将它们从浮点数转换为整数。幸运的是，Python
    内置了一个函数可以做到这一点：
- en: '>>> int(3.8)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> int(3.8)'
- en: '3'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> int(3.0)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> int(3.0)'
- en: '3'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'The function int() takes the input floating point number, gets rid of anything
    that comes after the decimal point, and returns the resulting integer. The float()
    function works similarly to perform the reverse conversion:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: int() 函数将输入的浮点数去除小数点后的部分，并返回结果整数。float() 函数类似，执行反向转换：
- en: '>>> float(3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> float(3)'
- en: '3.0'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '3.0'
- en: float() takes the integer that was input and adds a decimal point to turn it
    into a floating point number.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: float() 函数接收输入的整数并加上小数点，将其转换为浮点数。
- en: '***Working with Fractions***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理分数***'
- en: Python can also handle fractions, but to do that, we’ll need to use Python’s
    fractions module. You can think of a *module* as a program written by someone
    else that you can use in your own programs. A module can include classes, functions,
    and even label definitions. It can be part of Python’s standard library or distributed
    from a third-party location. In the latter case, you would have to install the
    module before you could use it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也能处理分数，但为此我们需要使用 Python 的 fractions 模块。你可以把 *模块* 想象成一个由其他人编写的程序，能够在你自己的程序中使用。模块可以包含类、函数，甚至标签定义。它可以是
    Python 标准库的一部分，也可以是从第三方位置分发的。在后一种情况下，你需要在使用之前先安装这个模块。
- en: 'The fractions module is part of the standard library, meaning that it’s already
    installed. It defines a class Fraction, which is what we’ll use to enter fractions
    into our programs. Before we can use it, we’ll need to *import* it, which is a
    way of telling Python that we want to use the class from this module. Let’s see
    a quick example—we’ll create a new label, f, which refers to the fraction 3/4:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: fractions 模块是 Python 标准库的一部分，这意味着它已经安装好。它定义了一个 Fraction 类，我们将用它来将分数输入到我们的程序中。在使用之前，我们需要
    *导入* 它，这是告诉 Python 我们想使用这个模块中的类。我们来看一个快速示例——我们将创建一个新的标签 f，它代表分数 3/4：
- en: ➊ >>> from fractions import Fraction
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> from fractions import Fraction
- en: ➋ >>> f = Fraction(3, 4)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> f = Fraction(3, 4)
- en: ➌ >>> f
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> f
- en: Fraction(3, 4)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction(3, 4)
- en: We first import the Fraction class from the fractions module ➊. Next, we create
    an object of this class by passing the numerator and denominator as parameters
    ➋. This creates a Fraction object for the fraction 3/4\. When we print the object
    ➌, Python displays the fraction in the form Fraction(numerator, denominator).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 fractions 模块导入 Fraction 类 ➊。接下来，我们通过传入分子和分母作为参数 ➋ 来创建该类的对象。这将创建一个表示分数
    3/4 的 Fraction 对象。当我们打印该对象 ➌ 时，Python 以 Fraction(分子, 分母) 的形式显示该分数。
- en: 'The basic mathematical operations, including the comparison operations, are
    all valid for fractions. You can also combine a fraction, an integer, and a floating
    point number in a single expression:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的数学运算，包括比较运算，都适用于分数。你也可以在一个表达式中结合分数、整数和浮点数：
- en: '>>> Fraction(3, 4) + 1 + 1.5'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Fraction(3, 4) + 1 + 1.5'
- en: '3.25'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '3.25'
- en: When you have a floating point number in an expression, the result of the expression
    is returned as a floating point number.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式中有浮点数时，表达式的结果将以浮点数形式返回。
- en: On the other hand, when you have only a fraction and an integer in the expression,
    the result is a fraction, even if the result has a denominator of 1.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当表达式中只有分数和整数时，结果将是分数，即使结果的分母为 1。
- en: '>>> Fraction(3, 4) + 1 + Fraction(1/4)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Fraction(3, 4) + 1 + Fraction(1/4)'
- en: Fraction(2, 1)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction(2, 1)
- en: Now you know the basics of working with fractions in Python. Let’s move on to
    a different kind of number.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在 Python 中处理分数的基本知识。接下来，我们将转向另一种类型的数字。
- en: '***Complex Numbers***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复数***'
- en: 'The numbers we’ve seen so far are the so-called *real numbers*. Python also
    supports *complex numbers* with the imaginary part identified by the letter *j*
    or *J* (as opposed to the letter *i* used in mathematical notation). For example,
    the complex number 2 + 3*i* would be written in Python as 2 + 3*j*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的数字是所谓的*实数*。Python 还支持*复数*，其中虚部由字母*j*或*J*表示（与数学符号中使用的字母*i*不同）。例如，复数
    2 + 3*i* 在 Python 中写作 2 + 3*j*：
- en: '>>> a = 2 + 3j'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = 2 + 3j'
- en: '>>> type(a)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(a)'
- en: <class 'complex'>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'complex'>
- en: As you can see, when we use the type() function on a complex number, Python
    tells us that this is an object of type complex.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们对一个复数使用 type() 函数时，Python 告诉我们这是一个 complex 类型的对象。
- en: 'You can also define complex numbers using the complex() function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 complex() 函数定义复数：
- en: '>>> a = complex(2, 3)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = complex(2, 3)'
- en: '>>> a'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: (2 + 3j)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (2 + 3j)
- en: Here we pass the real and imaginary parts of the complex number as two arguments
    to the complex() function, and it returns a complex number.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将复数的实部和虚部作为两个参数传递给 complex() 函数，函数返回一个复数。
- en: 'You can add and subtract complex numbers in the same way as real numbers:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像对待实数一样加减复数：
- en: '>>> b = 3 + 3j'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = 3 + 3j'
- en: '>>> a + b'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a + b'
- en: (5 + 6j)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (5 + 6j)
- en: '>>> a - b'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a - b'
- en: (-1 + 0j)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (-1 + 0j)
- en: 'Multiplication and division of complex numbers are also carried out similarly:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的乘法和除法也是类似进行的：
- en: '>>> a * b'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a * b'
- en: (-3 + 15j)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (-3 + 15j)
- en: '>>> a / b'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a / b'
- en: (0.8333333333333334 + 0.16666666666666666j)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (0.8333333333333334 + 0.16666666666666666j)
- en: The modulus (%) and the floor division (//) operations are not valid for complex
    numbers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对复数而言，取余（%）和整除（//）操作无效。
- en: 'The real and imaginary parts of a complex number can be retrieved using its
    real and imag attributes, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过复数的 real 和 imag 属性获取复数的实部和虚部，如下所示：
- en: '>>> z = 2 + 3j'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = 2 + 3j'
- en: '>>> z.real'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z.real'
- en: '2.0'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0'
- en: '>>> z.imag'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z.imag'
- en: '3.0'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '3.0'
- en: 'The *conjugate* of a complex number has the same real part but an imaginary
    part with an equal magnitude and an opposite sign. It can be obtained using the
    conjugate() method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的*共轭*具有相同的实部，但虚部的大小相同且符号相反。可以使用 conjugate() 方法获得共轭复数：
- en: '>>> z.conjugate()'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z.conjugate()'
- en: (2 - 3j)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (2 - 3j)
- en: 'Both the real and imaginary parts are floating point numbers. Using the real
    and imaginary parts, you can then calculate the *magnitude* of a complex number
    with the following formula, where *x* and *y* are the real and imaginary parts
    of the number, respectively: ![image](images/e0007-01.jpg). In Python, this would
    look like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实部和虚部都是浮动小数。使用实部和虚部，你可以使用以下公式计算复数的*模*，其中*x*和*y*分别是复数的实部和虚部：![image](images/e0007-01.jpg)。在
    Python 中，写法如下：
- en: '>>> (z.real ** 2 + z.imag ** 2) ** 0.5'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (z.real ** 2 + z.imag ** 2) ** 0.5'
- en: '3.605551275463989'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '3.605551275463989'
- en: 'A simpler way to find the magnitude of a complex number is with the abs() function.
    The abs() function returns the absolute value when called with a real number as
    its argument. For example, abs(5) and abs(-5) both return 5\. However, for complex
    numbers, it returns the magnitude:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复数的大小更简单的一种方法是使用 abs() 函数。调用 abs() 函数时，如果参数是实数，它返回绝对值。例如，abs(5) 和 abs(-5)
    都返回 5。对于复数，它返回的是模长：
- en: '>>> abs(z)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> abs(z)'
- en: '3.605551275463989'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '3.605551275463989'
- en: The standard library’s cmath module (cmath for *complex math*) provides access
    to a number of other specialized functions to work with complex numbers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 cmath 模块（cmath 为*复数数学*的缩写）提供了访问许多其他专门用于处理复数的函数。
- en: '**Getting User Input**'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取用户输入**'
- en: 'As we start to write programs, it will help to have a nice, simple way to accept
    user input via the input() function. That way, we can write programs that ask
    a user to input a number, perform specific operations on that number, and then
    display the results of the operations. Let’s see it in action:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写程序时，使用 input() 函数接收用户输入会非常有帮助。通过这种方式，我们可以编写让用户输入数字、对其执行特定操作并显示结果的程序。让我们看看实际应用：
- en: ➊ >>> a = input()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> a = input()
- en: ➋ 1
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 1
- en: 'At ➊, we call the input() function, which waits for you to type something,
    as shown at ➋, and press ENTER. The input provided is stored in a:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们调用了 input() 函数，它等待你输入内容，如 ➋ 所示，然后按 ENTER 键。输入的内容会存储在 a 变量中：
- en: '>>> a'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: ➌ '1'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ '1'
- en: 'Notice the single quotes around 1 at ➌. The input() function returns the input
    as a *string*. In Python, a string is any set of characters between two quotes.
    When you want to create a string, either single quotes or double quotes can be
    used:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意➌处1周围的单引号。input()函数将输入作为*字符串*返回。在Python中，字符串是任何位于两个引号之间的字符集。当你想创建一个字符串时，可以使用单引号或双引号：
- en: '>>> s1 = ''a string'''
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s1 = ''a string'''
- en: '>>> s2 = "a string"'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s2 = "a string"'
- en: Here, both s1 and s2 refer to the same string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，s1和s2都指向相同的字符串。
- en: 'Even if the only characters in a string are numbers, Python won’t treat that
    string as a number unless we get rid of those quotation marks. So before we can
    perform any mathematical operations with the input, we’ll have to convert it into
    the correct number type. A string can be converted to an integer or floating point
    number using the int() or float() function, respectively:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 即使字符串中的唯一字符是数字，Python也不会将该字符串当作数字，除非我们去掉那些引号。因此，在我们执行任何数学运算之前，必须将其转换为正确的数字类型。可以使用int()或float()函数分别将字符串转换为整数或浮动点数：
- en: '>>> a = ''1'''
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = ''1'''
- en: '>>> int(a) + 1'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> int(a) + 1'
- en: '2'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> float(a) + 1'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> float(a) + 1'
- en: '2.0'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0'
- en: 'These are the same int() and float() functions we saw earlier, but this time
    instead of converting the input from one kind of number to another, they take
    a string as input (''1'') and return a number (2 or 2.0). It’s important to note,
    however, that the int() function cannot convert a string containing a floating
    point decimal into an integer. If you take a string that has a floating point
    number (like ''2.5'' or even ''2.0'') and input that string into the int() function,
    you’ll get an error message:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们之前看到的相同的int()和float()函数，但这次它们不是将一种类型的数字转换为另一种类型，而是将字符串作为输入（'1'），并返回一个数字（2或2.0）。然而，需要注意的是，int()函数无法将包含浮动点数的字符串转换为整数。如果你输入一个包含浮动点数的字符串（如'2.5'甚至'2.0'）并将该字符串传递给int()函数，你会得到一条错误消息：
- en: '>>> int(''2.0'')'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> int(''2.0'')'
- en: 'Traceback (most recent call last):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (最近的调用最后):'
- en: File "<pyshell#26>", line 1, in <module>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#26>"，第1行，在<module>中
- en: int('2.0')
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: int('2.0')
- en: ValueError: invalid literal for int() with base 10: '2.0'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ValueError: int()的无效文字：'2.0'
- en: This is an example of an *exception*—Python’s way of telling you that it cannot
    continue executing your program because of an error. In this case, the exception
    is of the type ValueError. (For a quick refresher on exceptions, see [Appendix
    B](app02.html#app02).)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个*异常*的示例——Python告诉你，它由于错误无法继续执行程序。在这种情况下，异常类型是ValueError。（关于异常的快速复习，请参见[附录B](app02.html#app02)。）
- en: 'Similarly, when you supply a fractional number such as 3/4 as an input, Python
    cannot convert it into an equivalent floating point number or integer. Once again,
    a ValueError exception is raised:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你输入一个分数数字（例如3/4）时，Python无法将其转换为等效的浮动点数或整数。再次，抛出一个ValueError异常：
- en: '>>> a = float(input())'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = float(input())'
- en: 3/4
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 3/4
- en: 'Traceback (most recent call last):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (最近的调用最后):'
- en: File "<pyshell#25>", line 1, in <module>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#25>"，第1行，在<module>中
- en: a=float(input())
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: a=float(input())
- en: ValueError: could not convert string to float: '3/4'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ValueError: 无法将字符串转换为浮动数：'3/4'
- en: You may find it useful to perform the conversion in a try...except block so
    that you can *handle* this exception and alert the user that the program has encountered
    an invalid input. We’ll look at try...except blocks next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得在try...except块中执行转换很有用，这样你就可以*处理*这个异常，并提醒用户程序遇到了无效的输入。接下来，我们将看看try...except块。
- en: '***Handling Exceptions and Invalid Input***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理异常和无效输入***'
- en: 'If you’re not familiar with try...except, the basic idea is this: if you execute
    one or more statements in a try...except block and there’s an error while executing,
    your program will not crash and print a Traceback. Instead, the execution is transferred
    to the except block, where you can perform an appropriate operation, for instance,
    printing a helpful error message or trying something else.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉try...except，基本的思路是这样的：如果你在try...except块中执行一个或多个语句，并且在执行过程中出现错误，你的程序不会崩溃并打印Traceback。相反，执行会转移到except块，你可以在其中执行适当的操作，例如打印一条有用的错误消息或尝试其他操作。
- en: 'This is how you would perform the above conversion in a try...except block
    and print a helpful error message on invalid input:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在try...except块中执行上述转换，并在遇到无效输入时打印有用错误消息的方式：
- en: '>>> try:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: a = float(input('Enter a number: '))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input('请输入一个数字：'))
- en: 'except ValueError:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('You entered an invalid number')
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: print('你输入了无效的数字')
- en: Note that we need to specify the type of exception we want to handle. Here,
    we want to handle the ValueError exception, so we specify it as except ValueError.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要指定我们希望处理的异常类型。在这里，我们希望处理ValueError异常，因此我们将其指定为except ValueError。
- en: 'Now, when you give an invalid input, such as 3/4, it prints a helpful error
    message, as shown at ➊:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你输入一个无效的内容，比如3/4时，它会显示一条有帮助的错误信息，如➊所示：
- en: Enter a number: 3/4
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字：3/4
- en: ➊ You entered an invalid number
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 你输入了一个无效的数字
- en: 'You can also specify a prompt with the input() function to tell the user what
    kind of input is expected. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用input()函数指定一个提示，告诉用户期望输入什么类型的内容。例如：
- en: '>>> a = input(''Input an integer: '')'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = input(''输入一个整数: '')'
- en: 'The user will now see the message hinting to enter an integer as input:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在会看到提示信息，提示输入一个整数：
- en: Input an integer: 1
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个整数：1
- en: 'In many programs in this book, we’ll ask the user to enter a number as input,
    so we’ll have to make sure we take care of conversion before we attempt to perform
    any operations on these numbers. You can combine the input and conversion in a
    single statement, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多程序中，我们会要求用户输入一个数字作为输入，因此我们必须确保在对这些数字进行任何操作之前先进行转换。你可以将输入和转换结合在一个语句中，如下所示：
- en: '>>> a = int(input())'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = int(input())'
- en: '1'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> a + 1'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a + 1'
- en: '2'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'This works great if the user inputs an integer. But as we saw earlier, if the
    input is a floating point number (even one that’s equivalent to an integer, like
    1.0), this will produce an error:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入一个整数，这个方法效果很好。但正如我们之前所看到的，如果输入是浮点数（即使它等同于整数，如1.0），也会产生错误：
- en: '>>> a = int(input())'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = int(input())'
- en: '1.0'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '1.0'
- en: 'Traceback (most recent call last):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<pyshell#42>", line 1, in <module>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#42>"，第1行，在<module>中
- en: a=int(input())
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: ValueError: invalid literal for int() with base 10: '1.0'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: int()的无效字面量，基数为10：''1.0'''
- en: In order to avoid this error, we could set up a ValueError catch like the one
    we saw earlier for fractions. That way the program would catch floating point
    numbers, which won’t work in a program meant for integers. However, it would also
    flag numbers like 1.0 and 2.0, which Python *sees* as floating point numbers but
    that are equivalent to integers and would work just fine if they were entered
    as the right Python type.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个错误，我们可以设置一个类似我们之前看到的ValueError捕获机制。这样程序就能捕获浮点数，这些数字在专为整数设计的程序中无法使用。然而，这也会标记像1.0和2.0这样的数字，尽管Python*看作*浮点数，但它们实际上等同于整数，如果它们作为正确的Python类型输入，应该没有问题。
- en: To get around all this, we will use the is_integer() method to filter out any
    numbers with a significant digit after the decimal point. (This method is only
    defined for float type numbers in Python; it won’t work with numbers that are
    already entered in integer form.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这一切，我们将使用is_integer()方法来过滤掉任何小数点后有有效数字的数字。（这个方法仅对Python中的float类型数字有效；它无法用于已经输入的整数形式的数字。）
- en: 'Here’s an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '>>> 1.1.is_integer()'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1.1.is_integer()'
- en: 'False'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Here, we call the method is_integer() to check if 1.1 is an integer, and the
    result is False because 1.1 really is a floating point number. On the other hand,
    when the method is called with 1.0 as the floating point number, the result is
    True:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用is_integer()方法来检查1.1是否是一个整数，结果是False，因为1.1确实是一个浮点数。另一方面，当调用该方法时，如果浮点数是1.0，结果是True：
- en: '>>> 1.0.is_integer()'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1.0.is_integer()'
- en: 'True'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: We can use is_integer() to filter out noninteger input while keeping inputs
    like 1.0, which is expressed as a floating point number but is equivalent to an
    integer. We’ll see how the method would fit into a larger program a bit later.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用is_integer()来过滤掉非整数输入，同时保留像1.0这样的输入，尽管它是以浮点数形式表示，但等同于整数。稍后我们会看到该方法如何适应更大的程序。
- en: '***Fractions and Complex Numbers as Input***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分数和复数作为输入***'
- en: 'The Fraction class we learned about earlier is also capable of converting a
    string such as ''3/4'' to a Fraction object. In fact, this is how we can accept
    a fraction as an input:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学习过的Fraction类也能够将字符串如'3/4'转换为一个Fraction对象。事实上，这就是我们如何接受一个分数作为输入的方法：
- en: '>>> a = Fraction(input(''Enter a fraction: ''))'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = Fraction(input(''请输入一个分数: ''))'
- en: Enter a fraction: 3/4
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个分数：3/4
- en: '>>> a'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: Fraction(3, 4)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction(3, 4)
- en: 'Try entering a fraction such as 3/0 as input:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入一个像3/0这样的分数作为输入：
- en: '>>> a = Fraction(input(''Enter a fraction: ''))'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = Fraction(input(''请输入一个分数: ''))'
- en: Enter a fraction: 3/0
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个分数：3/0
- en: 'Traceback (most recent call last):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<pyshell#2>", line 1, in <module>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#2>"，第1行，在<module>中
- en: a = Fraction(input('Enter a fraction: '))
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: a = Fraction(input('输入一个分数: '))
- en: File "/usr/lib64/python3.3/fractions.py", line 167, in __new__
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib64/python3.3/fractions.py"，第 167 行，在 __new__ 中
- en: raise ZeroDivisionError('Fraction(%s, 0)' % numerator)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: raise ZeroDivisionError('Fraction(%s, 0)' % numerator)
- en: ZeroDivisionError: Fraction(3, 0)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroDivisionError: Fraction(3, 0)
- en: 'The ZeroDivisionError exception message tells you (as you already know) that
    a fraction with a denominator of 0 is invalid. If you’re planning on having users
    enter fractions as input in one of your programs, it’s a good idea to always catch
    such exceptions. Here is how you can do something like that:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroDivisionError 异常信息告诉你（正如你已经知道的那样），分母为 0 的分数是无效的。如果你计划让程序用户输入分数，最好总是捕获这些异常。以下是如何处理的示例：
- en: '>>> try:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: a = Fraction(input('Enter a fraction: '))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a = Fraction(input('输入一个分数: '))
- en: 'except ZeroDivisionError:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ZeroDivisionError:'
- en: print('Invalid fraction')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print('无效的分数')
- en: Enter a fraction: 3/0
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个分数: 3/0
- en: Invalid fraction
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的分数
- en: Now, whenever your program’s user enters a fraction with 0 in the denominator,
    it’ll print the message Invalid fraction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当程序用户输入一个分母为 0 的分数时，它会打印出“无效的分数”信息。
- en: 'Similarly, the complex() function can convert a string such as ''2+3j'' into
    a complex number:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，complex() 函数可以将字符串 '2+3j' 转换为复数：
- en: '>>> z = complex(input(''Enter a complex number: ''))'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = complex(input(''输入一个复数: ''))'
- en: Enter a complex number: 2+3j
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个复数: 2+3j
- en: '>>> z'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z'
- en: (2+3j)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (2+3j)
- en: 'If you enter the string as ''2 + 3j'' (with spaces), it will result in a ValueError
    error message:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入字符串 '2 + 3j'（带有空格），会导致 ValueError 错误信息：
- en: '>>> z = complex(input(''Enter a complex number: ''))'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = complex(input(''输入一个复数: ''))'
- en: Enter a complex number: 2 + 3j
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个复数: 2 + 3j
- en: 'Traceback (most recent call last):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '回溯 (最近的调用最后):'
- en: File "<pyshell#43>", line 1, in <module>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#43>"，第 1 行，在 <module> 中
- en: z = complex(input('Enter a complex number: '))
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: z = complex(input('输入一个复数: '))
- en: ValueError: complex() arg is a malformed string
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ValueError: complex() 参数是一个格式错误的字符串
- en: It’s a good idea to catch the ValueError exception when converting a string
    to a complex number, as we’ve done for other number types.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字符串转换为复数时，捕获 ValueError 异常是个好主意，正如我们在处理其他数字类型时所做的那样。
- en: '**Writing Programs That Do the Math for You**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写为你做数学运算的程序**'
- en: Now that we have learned some of the basic concepts, we can combine them with
    Python’s conditional and looping statements to make some programs that are a little
    more advanced and useful.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学习了一些基本概念，可以将它们与 Python 的条件语句和循环语句结合起来，编写一些更先进且有用的程序。
- en: '***Calculating the Factors of an Integer***'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算整数的因子***'
- en: 'When a nonzero integer, a, divides another integer, b, leaving a remainder
    0, a is said to be a *factor* of b. As an example, 2 is a factor of all even integers.
    We can write a function such as the one below to find whether a nonzero integer,
    a, is a factor of another integer, b:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个非零整数 a 除以另一个整数 b，且余数为 0 时，称 a 为 b 的 *因子*。例如，2 是所有偶数的因子。我们可以编写一个如下的函数，来判断一个非零整数
    a 是否是另一个整数 b 的因子：
- en: '>>> def is_factor(a, b):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def is_factor(a, b):'
- en: 'if b % a == 0:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'if b % a == 0:'
- en: return True
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'else:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return False
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'We use the % operator introduced earlier in this chapter to calculate the remainder.
    If you ever find yourself asking a question like “Is 4 a factor of 1024?”, you
    can use the is_factor() function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用本章前面介绍的 % 运算符来计算余数。如果你曾经问过类似“4 是 1024 的因子吗？”这样的问题，你可以使用 is_factor() 函数：
- en: '>>> is_factor(4, 1024)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> is_factor(4, 1024)'
- en: 'True'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: For any positive integer *n*, how do we find all its positive factors? For each
    of the integers between 1 and *n*, we check the remainder after dividing *n* by
    this integer. If it leaves a remainder of 0, it’s a factor. We’ll use the range()
    function to write a program that will go through each of those numbers between
    1 and *n*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何正整数 *n*，我们如何找到它的所有正因子？对于从 1 到 *n* 之间的每个整数，我们检查将 *n* 除以该整数后的余数。如果余数为 0，那么它就是一个因子。我们将使用
    range() 函数编写一个程序，遍历 1 到 *n* 之间的每个数字。
- en: 'Before we write the full program, let’s take a look at how range() works. A
    typical use of the range() function looks like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完整程序之前，我们先来看看 range() 是如何工作的。range() 函数的典型用法如下：
- en: '>>> for i in range(1, 4):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(1, 4):'
- en: print(i)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: '1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: Here, we set up a for loop and gave the range function two arguments. The range()
    function starts from the integer stated as the first argument (the *start value*)
    and continues up to the integer just *before* the one stated by the second argument
    (the *stop value*). In this case, we told Python to print out the numbers in that
    range, beginning with 1 and stopping at 4\. Note that this means Python doesn’t
    print 4, so the last number it prints is the number before the stop value (3).
    It’s also important to note that the range() function accepts only integers as
    its arguments.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个 for 循环，并给 range 函数传递了两个参数。range() 函数从第一个参数指定的整数（*起始值*）开始，一直到第二个参数指定的整数之前（*停止值*）。在本例中，我们告诉
    Python 打印出这个范围内的数字，从 1 开始，到 4 停止。注意，这意味着 Python 不会打印 4，所以它打印的最后一个数字是停止值之前的数字（3）。还需要注意的是，range()
    函数只接受整数作为参数。
- en: 'You can also use the range() function without specifying the start value, in
    which case it’s assumed to be 0\. For example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在不指定起始值的情况下使用 range() 函数，此时默认起始值为 0。例如：
- en: '>>> for i in range(5):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(5):'
- en: print(i)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: '0'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'The difference between two consecutive integers produced by the range() function
    is known as the *step value*. By default, the step value is 1\. To specify a different
    step value, specify it as the third argument (the start value is *not* optional
    when you specify a step value). For example, the following program prints the
    odd numbers *below* 10:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: range() 函数生成的两个连续整数之间的差值称为 *步长*。默认情况下，步长为 1。要指定不同的步长值，可以将其作为第三个参数来指定（当指定步长时，起始值
    *不是* 可选的）。例如，下面的程序会打印出 *小于* 10 的奇数：
- en: '>>> for i in range(1,10,2):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(1,10,2):'
- en: print(i)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: '1'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '5'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '7'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '9'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: Okay, now that we see how the range() function works, we’re ready to look at
    a factor-calculating program. Because I’m writing a fairly long program, instead
    of writing this program in the interactive IDLE prompt, I write it in the IDLE
    editor. You can start the editor by selecting **File**▸**New Window** in IDLE.
    Notice that we start out by commenting our code with three straight single quotes
    ('). The text in between those quotes won’t be executed by Python as part of the
    program; it’s just commentary for us humans.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们了解了 range() 函数的工作原理，接下来我们可以来看一个因子计算程序。因为我要编写一个相对较长的程序，所以我不在交互式 IDLE 提示符中编写这个程序，而是使用
    IDLE 编辑器。你可以通过在 IDLE 中选择 **文件** ▸ **新建窗口** 来启动编辑器。注意，我们首先通过三个单引号 (') 来注释代码。引号之间的文字不会被
    Python 执行，它只是给我们人类看的注释。
- en: ''''''''
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Find the factors of an integer
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 查找整数的因子
- en: ''''''''
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def factors(b):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'def factors(b):'
- en: '➊     for i in range(1, b+1):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     对于 i 在 range(1, b+1) 中：
- en: 'if b % i == 0:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 b % i == 0:'
- en: print(i)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: 'if __name__ == ''__main__'':'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: b = input('Your Number Please: ')
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: b = input('请输入您的数字：')
- en: b = float(b)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: b = float(b)
- en: '➋     if b > 0 and b.is_integer():'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     如果 b > 0 且 b 是整数：
- en: factors(int(b))
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: factors(int(b))
- en: 'else:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('Please enter a positive integer')
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: print('请输入一个正整数')
- en: The factors() function defines a for loop that iterates once for every integer
    between 1 and the input integer at ➊ using the range() function. Here, we want
    to iterate up to the integer entered by the user, b, so the stop value is stated
    as b+1. For each of these integers, i, the program checks whether it divides the
    input number with no remainder and prints it if so.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: factors() 函数定义了一个 for 循环，对于从 1 到输入整数之间的每个整数，使用 range() 函数进行迭代。在这里，我们希望迭代到用户输入的整数
    b，所以停止值设置为 b+1。对于这些整数 i，程序检查它是否能整除输入的数字且没有余数，如果能就打印出来。
- en: 'When you run this program (by selecting **Run**▸**Run Module**), it asks you
    to input a number. If your number is a positive integer, its factors are printed.
    For example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序（通过选择 **运行** ▸ **运行模块**），它会要求你输入一个数字。如果你的数字是正整数，它的因子将被打印出来。例如：
- en: Your Number Please: 25
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入您的数字：25
- en: '1'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '5'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '25'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: 'If you enter a non-integer or a negative integer as an input, the program prints
    an error message asking you to input a positive integer:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一个非整数或负整数，程序会打印出错误信息，提示你输入一个正整数：
- en: Your Number Please: 15.5
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入您的数字：15.5
- en: Please enter a positive integer
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入一个正整数
- en: This is an example of how we can make programs more user friendly by always
    checking for invalid input in the program itself. Because our program works only
    for finding the factors of a positive integer, we check whether the input number
    is greater than 0 and is an integer using the is_integer() method ➋ to make sure
    the input is valid. If the input isn’t a positive integer, the program prints
    a user-friendly instruction instead of just a big error message.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示了我们如何通过始终检查程序中的无效输入，使程序更具用户友好性。因为我们的程序仅适用于查找正整数的因子，我们通过 is_integer()
    方法 ➋ 检查输入的数字是否大于 0 且是整数，以确保输入有效。如果输入不是正整数，程序会打印出用户友好的提示，而不是简单地显示一个错误信息。
- en: '***Generating Multiplication Tables***'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成乘法表***'
- en: Consider three numbers, *a*, *b*, and *n*, where *n* is an integer, such that
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑三个数字，*a*、*b* 和 *n*，其中 *n* 是一个整数，满足以下条件：
- en: '*a* × *n* = *b*.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* × *n* = *b*。'
- en: We can say here that *b* is the *n*th *multiple* of *a*. For example, 4 is the
    2nd multiple of 2, and 1024 is the 512nd multiple of 2.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里说 *b* 是 *a* 的第 *n* 个 *倍数*。例如，4 是 2 的第 2 个倍数，1024 是 2 的第 512 个倍数。
- en: 'A multiplication table for a number lists all of that number’s multiples. For
    example, the multiplication table of 2 looks like this (first three multiples
    shown here):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的乘法表列出了该数字的所有倍数。例如，2 的乘法表如下所示（这里展示的是前几个倍数）：
- en: 2 × 1 = 2
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 2 × 1 = 2
- en: 2 × 2 = 4
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 2 × 2 = 4
- en: 2 × 3 = 6
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 2 × 3 = 6
- en: Our next program generates the multiplication number up to 10 for any number
    input by the user. In this program, we’ll use the format() method with the print()
    function to help make the program’s output look nicer and more readable. In case
    you haven’t seen it before, I’ll now briefly explain how it works.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序会生成用户输入的任意数字的乘法表，最多到 10。在这个程序中，我们将结合 format() 方法和 print() 函数，以帮助程序输出看起来更漂亮和易读。如果你之前没有见过，我将简要解释它是如何工作的。
- en: 'The format() method lets you plug in labels and set it up so that they get
    printed out in a nice, readable string with extra formatting around it. For example,
    if I had the names of all the fruits I bought at the grocery store with separate
    labels created for each and wanted to print them out to make a coherent sentence,
    I could use the format() method as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: format() 方法允许你插入标签并进行设置，以便它们可以以漂亮且易读的字符串格式输出，周围还带有额外的格式化。例如，如果我有所有我在杂货店购买的水果的名称，并为每个名称创建了单独的标签，想要把它们打印出来形成一个连贯的句子，我可以使用
    format() 方法，代码如下：
- en: '>>> item1 = ''apples'''
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> item1 = ''苹果'''
- en: '>>> item2 = ''bananas'''
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> item2 = ''香蕉'''
- en: '>>> item3 = ''grapes'''
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> item3 = ''葡萄'''
- en: '>>> print(''At the grocery store, I bought some {0} and {1} and {2}''.format(item1, item2, item3))'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''在杂货店，我买了些{0}、{1}和{2}''.format(item1, item2, item3))'
- en: At the grocery store, I bought some apples and bananas and grapes
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在杂货店，我买了些苹果、香蕉和葡萄
- en: 'First, we created three labels (item1, item2, and item3), each referring to
    a different string (apples, bananas, and grapes). Then, in the print() function,
    we typed a string with three placeholders in curly brackets: {0}, {1}, and {2}.
    We followed this with .format(), which holds the three labels we created. This
    tells Python to fill those three placeholders with the values stored in those
    labels in the order listed, so Python prints the text with {0} replaced by the
    first label, {1} replaced by the second label, and so on.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了三个标签（item1、item2 和 item3），每个标签分别对应一个不同的字符串（苹果、香蕉和葡萄）。然后，在 print() 函数中，我们输入了一个带有三个占位符的大括号字符串：{0}、{1}
    和 {2}。接着我们调用 .format()，并传入我们创建的这三个标签。这告诉 Python 按照指定的顺序将这些标签的值填充到占位符中，因此 Python
    会打印出文本，其中 {0} 被第一个标签的值替换，{1} 被第二个标签的值替换，依此类推。
- en: 'It’s not necessary to have labels pointing to the values we want to print.
    We can also just type values into .format(), as in the following example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 并不一定需要标签来指向我们想要打印的值。我们也可以直接将值输入到 .format() 中，如以下示例所示：
- en: '>>> print(''Number 1: {0} Number 2: {1} ''.format(1, 3.578))'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''数字 1: {0} 数字 2: {1} ''.format(1, 3.578))'
- en: Number 1: 1 Number 2: 3.578
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '数字 1: 1 数字 2: 3.578'
- en: Note that the number of placeholders and the number of labels or values must
    be equal.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，占位符的数量和标签或值的数量必须相等。
- en: 'Now that we’ve seen how format() works, we’re ready to take a look at the program
    for our multiplication table printer:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 format() 的工作原理，我们可以查看用于打印乘法表的程序：
- en: ''''''''
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Multiplication table printer
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法表打印机
- en: ''''''''
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def multi_table(a):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'def multi_table(a):'
- en: '➊     for i in range(1, 11):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for i in range(1, 11):'
- en: print('{0} x {1} = {2}'.format(a, i, a*i))
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: print('{0} x {1} = {2}'.format(a, i, a*i))
- en: 'if __name__ == ''__main__'':'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: a = input('Enter a number: ')
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = input(''输入一个数字: '')'
- en: multi_table(float(a))
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: multi_table(float(a))
- en: The function multi_table() implements the main functionality of the program.
    It takes the number for which the multiplication table will be printed as a parameter,
    a. Because we want to print the multiplication table from 1 to 10, we have a for
    loop at ➊ that iterates over each of these numbers, printing the product of itself
    and the number, a.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`multi_table()`实现了程序的主要功能。它以需要打印乘法表的数字a为参数。因为我们希望打印从1到10的乘法表，所以在➊处有一个for循环，遍历这些数字，打印每个数字与a的乘积。
- en: 'When you execute the program, it asks you to input a number, and the program
    prints its multiplication table:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，它会要求你输入一个数字，然后程序会打印出该数字的乘法表：
- en: Enter a number : 5
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字：5
- en: 5.0 x 1 = 5.0
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 1 = 5.0
- en: 5.0 x 2 = 10.0
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 2 = 10.0
- en: 5.0 x 3 = 15.0
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 3 = 15.0
- en: 5.0 x 4 = 20.0
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 4 = 20.0
- en: 5.0 x 5 = 25.0
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 5 = 25.0
- en: 5.0 x 6 = 30.0
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 6 = 30.0
- en: 5.0 x 7 = 35.0
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 7 = 35.0
- en: 5.0 x 8 = 40.0
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 8 = 40.0
- en: 5.0 x 9 = 45.0
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 9 = 45.0
- en: 5.0 x 10 = 50.0
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0 x 10 = 50.0
- en: See how nice and orderly that table looks? That’s because we used the .format()
    method to print the output according to a readable, uniform template.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 看看那张表格多么整齐有序？那是因为我们使用了`.format()`方法按可读的统一模板打印输出。
- en: 'You can use the format() method to further control how numbers are printed.
    For example, if you want numbers with only two decimal places, you can specify
    that with the format() method. Here is an example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`format()`方法进一步控制数字的打印方式。例如，如果你只想要保留两位小数，可以使用`format()`方法进行指定。以下是一个例子：
- en: '>>> ''{0}''.format(1.25456)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''{0}''.format(1.25456)'
- en: '''1.25456'''
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.25456'''
- en: '>>> ''{0:.2f}''.format(1.25456)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''{0:.2f}''.format(1.25456)'
- en: '''1.25'''
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.25'''
- en: 'The first format statement above simply prints the number exactly as we entered
    it. In the second statement, we modify the place holder to {0:.2f}, meaning that
    we want only two numbers after the decimal point, with the f indicating a floating
    point number. As you can see, there are only two numbers after the decimal point
    in the next output. Note that the number is rounded if there are more numbers
    after the decimal point than you specified. For example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第一个格式化语句仅仅是按我们输入的方式打印数字。第二个语句中，我们修改了占位符为{0:.2f}，意味着我们只希望小数点后保留两位数字，f表示浮动小数点数字。如你所见，下一次输出中，小数点后只有两位数字。注意，如果小数点后的数字超过了你指定的位数，数字会被四舍五入。例如：
- en: '>>> ''{0:.2f}''.format(1.25556)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''{0:.2f}''.format(1.25556)'
- en: '''1.26'''
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.26'''
- en: 'Here, 1.25556 is rounded up to the nearest hundredth and printed as 1.26\.
    If you use .2f and the number you are printing is an integer, zeros are added
    at the end:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，1.25556四舍五入到最接近的百分位，并打印为1.26。如果你使用`.2f`格式，且打印的数字是整数，末尾会添加零：
- en: '>>> ''{0:.2f}''.format(1)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''{0:.2f}''.format(1)'
- en: '''1.00'''
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.00'''
- en: Two zeros are added because we specified that we should print exactly two numbers
    after the decimal point.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个零是因为我们指定了要打印小数点后恰好两位数字。
- en: '***Converting Units of Measurement***'
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单位转换***'
- en: 'The International System of Units defines seven *base quantities*. These are
    then used to derive other quantities, referred to as *derived quantities*. Length
    (including width, height, and depth), time, mass, and temperature are four of
    the seven base quantities. Each of these quantities has a standard unit of measurement:
    meter, second, kilogram, and kelvin, respectively.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 国际单位制定义了七个*基本量*。这些基本量可以用来推导其他量，称为*导出量*。长度（包括宽度、高度和深度）、时间、质量和温度是这七个基本量中的四个。每个基本量都有一个标准的计量单位：米、秒、千克和开尔文，分别对应。
- en: But each of these standard measurement units also has multiple nonstandard measurement
    units. You are more familiar with the temperature being reported as 30 degrees
    Celsius or 86 degrees Fahrenheit than as 303.15 kelvin. Does that mean 303.15
    kelvin feels three times hotter than 86 degrees Fahrenheit? No way! We can’t compare
    86 degrees Fahrenheit to 303.15 kelvin only by their numerical values because
    they’re expressed in different measurement units, even though they measure the
    same physical quantity—temperature. You can compare two measurements of a physical
    quantity only when they’re expressed in the same unit of measurement.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 但是每个标准测量单位也都有多个非标准测量单位。你可能更习惯于看到温度以30摄氏度或86华氏度来表示，而不是303.15开尔文。这是否意味着303.15开尔文比86华氏度热三倍？当然不！我们不能仅通过数值大小将86华氏度与303.15开尔文进行比较，因为它们是用不同的测量单位表示的，尽管它们衡量的是相同的物理量——温度。只有当两种物理量的测量使用相同的计量单位时，我们才能进行比较。
- en: Conversions between different units of measurement can be tricky, and that’s
    why you’re often asked to solve problems that involve conversion between different
    units of measurement in high school. It’s a good way to test your basic mathematical
    skills. But Python has plenty of math skills, too, and, unlike some high school
    students, it doesn’t get tired of crunching numbers over and over again in a loop!
    Next, we’ll explore writing programs to perform those unit conversions for you.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 不同单位之间的转换可能比较棘手，这也是为什么你经常在高中被要求解决涉及不同单位转换的问题。这是一个测试你基本数学技能的好方法。但Python也有很多数学技能，而且不同于某些高中生，Python不会在循环中反复计算时感到疲倦！接下来，我们将探索编写程序来为你执行这些单位转换。
- en: We’ll start with length. In the United States and United Kingdom, inches and
    miles are often used for measuring length, while most other countries use centimeters
    and kilometers.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从长度开始。在美国和英国，通常使用英寸和英里来测量长度，而大多数其他国家使用厘米和公里。
- en: 'An inch is equal to 2.54 centimeters, and you can use the multiplication operation
    to convert a measurement in inches to centimeters. You can then divide the measurement
    in centimeters by 100 to obtain the measurement in meters. For example, here’s
    how you can convert 25.5 inches to meters:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一英寸等于2.54厘米，你可以使用乘法操作将英寸转换为厘米。然后，你可以将厘米数除以100得到以米为单位的长度。例如，以下是如何将25.5英寸转换为米：
- en: '>>> (25.5 * 2.54) / 100'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (25.5 * 2.54) / 100'
- en: '0.6476999999999999'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '0.6476999999999999'
- en: 'On the other hand, a mile is roughly equivalent to 1.609 kilometers. So if
    you see that your destination is 650 miles away, you’re 650 × 1.609 kilometers
    away:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一英里大约等于1.609公里。因此，如果你看到目的地距离是650英里，那么你距离目的地的公里数是：650 × 1.609公里。
- en: '>>> 650 * 1.609'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 650 * 1.609'
- en: '1045.85'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '1045.85'
- en: Now let’s take a look at *temperature* conversion—converting temperature from
    Fahrenheit to Celsius and vice versa. Temperature expressed in Fahrenheit is converted
    into its equivalent value in Celsius using the formula
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下*温度*转换——将温度从华氏度转换为摄氏度，反之亦然。以华氏度表示的温度，通过以下公式转换为相应的摄氏度：
- en: '![image](images/e0018-01.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0018-01.jpg)'
- en: '*F* is the temperature in Fahrenheit, and *C* is its equivalent in Celsius.
    You know that 98.6 degrees Fahrenheit is said to be the normal human body temperature.
    To find the corresponding temperature in degrees Celsius, we evaluate the above
    formula in Python:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*F* 是华氏温度，*C* 是相应的摄氏温度。你知道98.6华氏度被认为是正常人体体温。要找到相应的摄氏温度，我们在Python中评估上述公式：'
- en: '>>> F = 98.6'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> F = 98.6'
- en: '>>> (F - 32) * (5 / 9)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (F - 32) * (5 / 9)'
- en: '37.0'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '37.0'
- en: First, we create a label, F, with the temperature in Fahrenheit, 98.6\. Next,
    we evaluate the formula for converting this temperature to its equivalent in Celsius,
    which turns out be 37.0 degrees Celsius.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个标签F，值为华氏温度98.6。接下来，我们计算将这个温度转换为其对应摄氏度的公式，结果是37.0摄氏度。
- en: To convert temperature from Celsius to Fahrenheit, you would use the formula
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要将温度从摄氏度转换为华氏度，可以使用以下公式：
- en: '![image](images/e0018-02.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0018-02.jpg)'
- en: 'You can evaluate this formula in a similar manner:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以类似的方式评估这个公式：
- en: '>>> C = 37'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> C = 37'
- en: '>>> C * (9 / 5) + 32'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> C * (9 / 5) + 32'
- en: '98.60000000000001'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '98.60000000000001'
- en: We create a label, C, with the value 37 (the normal human body temperature in
    Celsius). Then, we convert it into Fahrenheit using the formula, and the result
    is 98.6 degrees.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个标签C，值为37（正常人体体温，单位摄氏度）。然后，我们使用公式将其转换为华氏温度，结果是98.6度。
- en: 'It’s a chore to have to write these conversion formulas over and over again.
    Let’s write a unit conversion program that will do the conversions for us. This
    program will present a menu to allow users to select the conversion they want
    to perform, ask for relevant input, and then print the calculated result. The
    program is shown below:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一遍又一遍地编写这些转换公式是件麻烦事。让我们编写一个单位转换程序，来为我们完成这些转换。这个程序会显示一个菜单，允许用户选择他们想执行的转换，要求输入相关的数值，然后打印计算结果。以下是程序的展示：
- en: ''''''''
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Unit converter: Miles and Kilometers
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 单位转换器：英里和公里
- en: ''''''''
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def print_menu():'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 'def print_menu():'
- en: print('1. Kilometers to Miles')
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: print('1. 公里转换为英里')
- en: print('2. Miles to Kilometers')
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: print('2. 英里转换为公里')
- en: 'def km_miles():'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'def km_miles():'
- en: km = float(input('Enter distance in kilometers: '))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: km = float(input('输入距离（公里）：'))
- en: miles = km / 1.609
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: miles = km / 1.609
- en: print('Distance in miles: {0}'.format(miles))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: print('距离（英里）: {0}'.format(miles))
- en: 'def miles_km():'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'def miles_km():'
- en: miles = float(input('Enter distance in miles: '))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: miles = float(input('输入距离（英里）：'))
- en: km = miles * 1.609
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: km = miles * 1.609
- en: print('Distance in kilometers: {0}'.format(km))
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: print('公里数: {0}'.format(km))
- en: 'if __name__ == ''__main__'':'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: ➊     print_menu()
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     print_menu()
- en: ➋     choice = input('Which conversion would you like to do?: ')
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '➋     choice = input(''你想进行哪种转换？: '')'
- en: 'if choice == ''1'':'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'if choice == ''1'':'
- en: km_miles()
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: km_miles()
- en: 'if choice == ''2'':'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'if choice == ''2'':'
- en: miles_km()
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: miles_km()
- en: This is a slightly longer program than the others, but not to worry. It’s actually
    simple. Let’s start from ➊. The print_menu() function is called, which prints
    a menu with two unit conversion choices. At ➋, the user is asked to select one
    of the two conversions. If the choice is entered as 1 (kilometers to miles), the
    function km_miles() is called. If the choice is entered as 2 (miles to kilometers),
    the function miles_km() is called. In both of these functions, the user is first
    asked to enter a distance in the unit chosen for conversion (kilometers for km_miles()
    and miles for miles_km()). The program then performs the conversion using the
    corresponding formula and displays the result.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比其他程序稍长的程序，但别担心。它其实很简单。我们从 ➊ 开始。调用了 print_menu() 函数，该函数打印出包含两种单位转换选择的菜单。在
    ➋，程序要求用户选择其中一种转换。如果输入选择为 1（公里转英里），则调用 km_miles() 函数。如果选择输入为 2（英里转公里），则调用 miles_km()
    函数。在这两个函数中，用户首先被要求输入转换所选单位的距离（对于 km_miles() 为公里， 对于 miles_km() 为英里）。然后程序使用相应的公式进行转换并显示结果。
- en: 'Here is a sample run of the program:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该程序的一个示例运行：
- en: 1. Kilometers to Miles
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 公里转英里
- en: 2. Miles to Kilometers
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 英里转公里
- en: ➊ Which conversion would you like to do?: 2
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ 你想进行哪种转换？: 2'
- en: Enter distance in miles: 100
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '输入英里数: 100'
- en: Distance in kilometers: 160.900000
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '公里数: 160.900000'
- en: The user is asked to enter a choice at ➊. The choice is entered as 2 (miles
    to kilometers). The program then asks the user to enter the distance in miles
    to be converted to kilometers and prints the conversion.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在 ➊ 处被要求输入选择。选择被输入为 2（英里转公里）。程序随后要求用户输入需要转换为公里的英里数，并输出转换结果。
- en: This program just converts between miles and kilometers, but in a programming
    challenge later, you’ll extend this program so that it can perform conversions
    of other units.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序只是进行英里和公里之间的转换，但在后续的编程挑战中，你将扩展该程序，使其可以执行其他单位的转换。
- en: '***Finding the Roots of a Quadratic Equation***'
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解二次方程的根***'
- en: 'What do you do when you have an equation such as *x* + 500 – 79 = 10 and you
    need to find the value of the unknown variable, *x*? You rearrange the terms such
    that you have only the constants (500, –79, and 10) on one side of the equation
    and the variable (*x*) on the other side. This results in the following equation:
    *x* = 10 – 500 + 79.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个方程式，如 *x* + 500 – 79 = 10，而你需要求解未知数 *x* 的值时，该怎么办？你需要将方程式重新排列，使常数（500，–79
    和 10）都在方程的一侧，而变量 (*x*) 在另一侧。这就得到以下方程式：*x* = 10 – 500 + 79。
- en: 'Finding the value of the expression on the right gives you the value of *x*,
    your solution, which is also called the *root* of this equation. In Python, you
    can do this as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 求解右侧表达式的值，就能得到 *x* 的值，这就是你的解，也叫做方程的 *根*。在 Python 中，你可以这样做：
- en: '>>> x = 10 - 500 + 79'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 10 - 500 + 79'
- en: '>>> x'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '-411'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '-411'
- en: 'This is an example of a *linear equation*. Once you have rearranged the terms
    on both sides, the expression is simple enough to evaluate. On the other hand,
    for equations such as *x*² + 2*x* + 1 = 0, finding the roots of *x* usually involves
    evaluating a complex expression known as the *quadratic formula*. Such equations
    are known as *quadratic equations*, generally expressed as *ax*² + *bx* + *c*
    = 0, where *a*, *b*, and *c* are constants. The quadratic formula for calculating
    the roots is given as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 *线性方程* 的例子。一旦你将两边的项重新排列，表达式就足够简单，可以进行求解。另一方面，对于像 *x*² + 2*x* + 1 = 0 这样的方程，求解
    *x* 的根通常需要计算一个复杂的表达式，称为 *二次公式*。这种方程被称为 *二次方程*，通常表示为 *ax*² + *bx* + *c* = 0，其中
    *a*、*b* 和 *c* 是常数。计算根的二次公式如下所示：
- en: '![image](images/e0020-01.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0020-01.jpg)'
- en: A quadratic equation has two roots—two values of *x* for which the two sides
    of the quadratic equation are equal (although sometimes these two values may turn
    out to be the same). This is indicated here by the *x*[1] and *x*[2] in the quadratic
    formula.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一元二次方程有两个根——两个使二次方程两边相等的 *x* 值（虽然有时这两个值可能是相同的）。这在二次公式中由 *x*[1] 和 *x*[2] 表示。
- en: 'Comparing the equation *x*² + 2*x* + 1 = 0 to the generic quadratic equation,
    we see that *a* = 1, *b* = 2, and *c* = 1\. We can substitute these values directly
    into the quadratic formula to calculate the value of *x*[1] and *x*[2]. In Python,
    we first store the values of *a*, *b*, and *c* as the labels a, b, and c with
    the appropriate values:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 比较方程 *x*² + 2*x* + 1 = 0 与通用的二次方程，我们看到 *a* = 1，*b* = 2，*c* = 1。我们可以将这些值直接代入二次公式中计算
    *x*[1] 和 *x*[2] 的值。在 Python 中，我们首先将 *a*、*b* 和 *c* 的值存储为标签 a、b 和 c，并赋予相应的值：
- en: '>>> a = 1'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = 1'
- en: '>>> b = 2'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = 2'
- en: '>>> c = 1'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = 1'
- en: 'Then, considering that both the formulas have the term *b*² – 4*ac*, we’ll
    define a new label with *D*, such that ![image](images/e0021-01.jpg):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，考虑到两个公式都有项 *b*² – 4*ac*，我们定义一个新的标签 *D*，如下图所示：![image](images/e0021-01.jpg):'
- en: '>>> D = (b**2 – 4*a*c)**0.5'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> D = (b ** 2 – 4 * a * c) ** 0.5'
- en: 'As you can see, we evaluate the square root of *b*² – 4*ac* by raising it to
    the 0.5th power. Now, we can write the expressions for evaluating *x*[1] and *x*[2]:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过将 *b*² – 4*ac* 提升到 0.5 次方来计算平方根。现在，我们可以写出计算 *x*[1] 和 *x*[2] 的表达式：
- en: '>>> x_1 = (-b + D)/(2*a)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_1 = (-b + D) / (2 * a)'
- en: '>>> x_1'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_1'
- en: '-1.0'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '-1.0'
- en: '>>> x_2 = (-b - D)/(2*a)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_2 = (-b - D) / (2 * a)'
- en: '>>> x_2'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_2'
- en: '-1.0'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '-1.0'
- en: In this case, the values of both the roots are the same, and if you substitute
    that value into the equation *x*² + 2*x* + 1, the equation will evaluate to 0.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个根的值相同，如果将该值代入方程 *x*² + 2*x* + 1，方程将计算出 0。
- en: 'Our next program combines all these steps in a function roots(), which takes
    the values of *a*, *b*, and *c* as parameters, calculates the roots, and prints
    them:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序将这些步骤结合到一个名为 roots() 的函数中，该函数将 *a*、*b* 和 *c* 作为参数，计算并打印根：
- en: ''''''''
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Quadratic equation root calculator
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 二次方程根计算器
- en: ''''''''
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def roots(a, b, c):'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roots(a, b, c):'
- en: D = (b*b - 4*a*c)**0.5
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: D = (b * b - 4 * a * c) ** 0.5
- en: x_1 = (-b + D)/(2*a)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: x_1 = (-b + D) / (2 * a)
- en: x_2 = (-b - D)/(2*a)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: x_2 = (-b - D) / (2 * a)
- en: print('x1: {0}'.format(x_1))
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''x1: {0}''.format(x_1))'
- en: print('x2: {0}'.format(x_2))
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''x2: {0}''.format(x_2))'
- en: 'if __name__ == ''__main__'':'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: a = input('Enter a: ')
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = input(''输入 a: '')'
- en: b = input('Enter b: ')
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 'b = input(''输入 b: '')'
- en: c = input('Enter c: ')
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 'c = input(''输入 c: '')'
- en: roots(float(a), float(b), float(c))
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: roots(float(a), float(b), float(c))
- en: At first, we use the labels a, b, and c to reference the values of the three
    constants of a quadratic equation. Then, we call the roots() function with these
    three values as arguments (after converting them to floating point numbers). This
    function plugs a, b, and c into the quadratic formula, finds the roots for that
    equation, and prints them.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们使用标签 a、b 和 c 来引用二次方程三个常数的值。然后，我们调用 roots() 函数，并将这三个值作为参数传入（在传入之前将它们转换为浮动点数）。这个函数将
    *a*、*b* 和 *c* 代入二次公式，计算方程的根，并打印出来。
- en: When you execute the program, it will ask the user to input values of *a*, *b*,
    and *c* corresponding to a quadratic equation they want to find the roots for.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，它会要求用户输入对应于他们想要寻找根的二次方程的 *a*、*b* 和 *c* 的值。
- en: Enter a: 1
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 a: 1'
- en: Enter b: 2
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 b: 2'
- en: Enter c: 1
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 c: 1'
- en: x1: -1.000000
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'x1: -1.000000'
- en: x2: -1.000000
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 'x2: -1.000000'
- en: Try solving a few more quadratic equations with different values for the constants,
    and the program will find the roots correctly.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同常数值解决更多的二次方程，程序会正确地找到根。
- en: 'You most likely know that quadratic equations can have complex numbers as roots,
    too. For example, the roots of the equation *x*² + *x* + 1 = 0 are both complex
    numbers. The above program can find those for you as well. Let’s give it a shot
    by executing the program again (the constants are *a* = 1, *b* = 1, and *c* =
    1):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，二次方程的根也可以是复数。例如，方程 *x*² + *x* + 1 = 0 的根都是复数。上述程序也可以为你找到这些根。让我们通过再次执行程序来试试（常数为
    *a* = 1，*b* = 1，*c* = 1）：
- en: Enter a: 1
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 a: 1'
- en: Enter b: 1
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 b: 1'
- en: Enter c: 1
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 c: 1'
- en: x1: (-0.49999999999999994+0.8660254037844386j)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 'x1: (-0.49999999999999994+0.8660254037844386j)'
- en: x2: (-0.5-0.8660254037844386j)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 'x2: (-0.5 - 0.8660254037844386j)'
- en: The roots printed above are complex numbers (indicated by j), and the program
    has no problem calculating or displaying them.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 上面打印出的根是复数（由 j 表示），程序可以正确计算并显示它们。
- en: '**What You Learned**'
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: Great work on finishing the first chapter! You learned to write programs that
    recognize integers, floating point numbers, fractional numbers (expressed as a
    fraction or a floating point number), and complex numbers. You wrote programs
    that generate multiplication tables, perform unit conversions, and find the roots
    of a quadratic equation. I’m sure you’re already excited about having taken the
    first steps toward writing programs that will do mathematical calculations for
    you. Before we move on, here are some programming challenges that will give you
    a chance to further apply what you’ve learned.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，完成了第一章！你学会了编写能够识别整数、浮点数、分数（以分数或浮点数形式表示）和复数的程序。你编写了生成乘法表、执行单位转换和求解二次方程根的程序。我相信你已经很兴奋，迈出了编写能为你进行数学计算的程序的第一步。在我们继续之前，这里有一些编程挑战，可以让你进一步应用你所学的知识。
- en: '**Programming Challenges**'
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Here are a few challenges that will give you a chance to practice the concepts
    from this chapter. Each problem can be solved in multiple ways, but you can find
    sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些挑战题，能够让你有机会练习本章的概念。每个问题可以用多种方法解决，但你可以在*[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*找到示例解答。
- en: '***#1: Even-Odd Vending Machine***'
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 奇偶自动售货机***'
- en: 'Try writing an “even-odd vending machine,” which will take a number as input
    and do two things:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个“奇偶自动售货机”，它将接受一个数字作为输入，并执行两件事：
- en: 1\. Print whether the number is even or odd.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 打印数字是偶数还是奇数。
- en: 2\. Display the number followed by the next 9 even or odd numbers.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 显示数字后跟随接下来的9个偶数或奇数。
- en: If the input is 2, the program should print even and then print 2, 4, 6, 8,
    10, 12, 14, 16, 18, 20. Similarly, if the input is 1, the program should print
    odd and then print 1, 3, 5, 7, 9, 11, 13, 15, 17, 19.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是2，程序应该打印“偶数”，然后打印 2, 4, 6, 8, 10, 12, 14, 16, 18, 20。类似地，如果输入是1，程序应该打印“奇数”，然后打印
    1, 3, 5, 7, 9, 11, 13, 15, 17, 19。
- en: Your program should use the is_integer() method to display an error message
    if the input is a number with significant digits beyond the decimal point.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是一个小数，程序应该使用is_integer()方法显示错误信息，表示输入是一个有有效数字的小数。
- en: '***#2: Enhanced Multiplication Table Generator***'
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 强化版乘法表生成器***'
- en: Our multiplication table generator is cool, but it prints only the first 10
    multiples. Enhance the generator so that the user can specify both the number
    and up to *which* multiple. For example, I should be able to input that I want
    to see a table listing the first 15 multiples of 9.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的乘法表生成器很酷，但它只打印前10个倍数。加强这个生成器，让用户可以指定数字和要显示的倍数个数。例如，我应该能够输入我想查看9的前15个倍数的表格。
- en: '***#3: Enhanced Unit Converter***'
  id: totrans-484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 强化版单位转换器***'
- en: The unit conversion program we wrote in this chapter is limited to conversions
    between kilometers and miles. Try extending the program to convert between units
    of mass (such as kilograms and pounds) and between units of temperature (such
    as Celsius and Fahrenheit).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中编写的单位转换程序只限于千米和英里的转换。尝试扩展该程序，实现质量单位（如千克和磅）以及温度单位（如摄氏度和华氏度）之间的转换。
- en: '***#4: Fraction Calculator***'
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 分数计算器***'
- en: 'Write a calculator that can perform the basic mathematical operations on two
    fractions. It should ask the user for two fractions and the operation the user
    wants to carry out. As a head start, here’s how you can write the program with
    only the addition operation:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个可以对两个分数执行基本数学运算的计算器。它应该询问用户两个分数和用户希望执行的运算。作为起步，这里有一个只执行加法运算的程序示例：
- en: ''''''''
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Fraction operations
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 分数运算
- en: ''''''''
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from fractions import Fraction
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: from fractions import Fraction
- en: 'def add(a, b):'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add(a, b):'
- en: print('Result of Addition: {0}'.format(a+b))
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: print('加法结果：{0}'.format(a+b))
- en: 'if __name__ == ''__main__'':'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: ➊     a = Fraction(input('Enter first fraction: '))
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     a = Fraction(input('请输入第一个分数：'))
- en: ➋     b = Fraction(input('Enter second fraction: '))
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     b = Fraction(input('请输入第二个分数：'))
- en: op = input('Operation to perform - Add, Subtract, Divide, Multiply: ')
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: op = input('请选择要执行的操作 - 加法、减法、除法、乘法：')
- en: 'if op == ''Add'':'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'if op == ''加法'':'
- en: add(a,b)
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: add(a,b)
- en: 'You’ve already seen most of the elements in this program. At ➊ and ➋, we ask
    the user to input the two fractions. Then, we ask the user which operation is
    to be performed on the two fractions. If the user enters ''Add'' as input, we
    call the function add(), which we’ve defined to find the sum of the two fractions
    passed as arguments. The add() function performs the operation and prints the
    result. For example:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过这个程序中的大部分元素。在➊和➋的位置，我们要求用户输入两个分数。然后，我们询问用户要对这两个分数执行哪个操作。如果用户输入 'Add'，则调用我们定义的
    add() 函数，该函数用于计算传入的两个分数的和。add() 函数执行该操作并打印结果。例如：
- en: Enter first fraction: 3/4
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第一个分数：3/4
- en: Enter second fraction: 1/4
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第二个分数：1/4
- en: Operation to perform - Add, Subtract, Divide, Multiply: Add
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的操作 - 加法、减法、除法、乘法：加法
- en: Result of Addition: 1
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 加法结果：1
- en: 'Try adding support for other operations such as subtraction, division, and
    multiplication. For example, here’s how your program should be able to calculate
    the difference of two fractions:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加对其他操作的支持，如减法、除法和乘法。例如，下面是如何让你的程序计算两个分数的差：
- en: Enter first fraction: 3/4
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第一个分数：3/4
- en: Enter second fraction: 1/4
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第二个分数：1/4
- en: Operation to perform - Add, Subtract, Divide, Multiply: Subtract
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的操作 - 加法、减法、除法、乘法：减法
- en: Result of Subtraction: 2/4
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 减法结果：2/4
- en: In the case of division, you should let the user know whether the first fraction
    is divided by the second fraction or vice versa.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在除法的情况下，你应该让用户知道是第一个分数除以第二个分数，还是反过来。
- en: '***#5: Give Exit Power to the User***'
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5: 给用户退出的权力***'
- en: 'All the programs we have written so far work only for one iteration of input
    and output. For example, consider the program to print the multiplication table:
    the user executes the program and enters a number; then the program prints the
    multiplication table and exits. If the user wanted to print the multiplication
    table of another number, the program would have to be rerun.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有程序都仅适用于一次输入输出。例如，考虑一个打印乘法表的程序：用户执行程序并输入一个数字，然后程序打印乘法表并退出。如果用户想打印另一个数字的乘法表，则必须重新运行程序。
- en: 'It would be more convenient if the user could choose whether to exit or continue
    using the program. The key to writing such programs is to set up an *infinite
    loop*, or a loop that doesn’t exit unless explicitly asked to do so. Below, you
    can see an example of the layout for such a program:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户能够选择是否退出或继续使用程序，那会更加方便。编写此类程序的关键是设置一个 *无限循环*，或者一个只有在明确要求退出时才会停止的循环。下面，你可以看到一个此类程序布局的示例：
- en: ''''''''
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Run until exit layout
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 直到退出布局
- en: ''''''''
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def fun():'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fun():'
- en: print('I am in an endless loop')
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: print('我在一个无限循环中')
- en: 'if __name__ == ''__main__'':'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: '➊     while True:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     while True:'
- en: fun()
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: fun()
- en: ➋         answer = input('Do you want to exit? (y) for yes ')
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ➋         answer = input('你想退出吗？（y）是，其他键为否')
- en: 'if answer == ''y'':'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == ''y'':'
- en: break
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'We define an infinite loop using while True at ➊. A while loop continues to
    execute unless the condition evaluates to False. Because we chose the loop’s condition
    to be the constant value True, it will keep running forever unless we interrupt
    it somehow. Inside the loop, we call the function fun(), which prints the string
    I am in an endless loop. At ➋, the user is asked “Do you want to exit?” If the
    user enters y as the input, the program exits out of the loop using the break
    statement (break exits out of the innermost loop without executing any other statement
    in that loop). If the user enters any other input (or none at all, just pressing
    ENTER), the while loop continues execution—that is, it prints the string again
    and continues doing so until the user wishes to exit. Here is a sample run of
    the program:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➊处使用 `while True` 定义了一个无限循环。`while` 循环会一直执行，除非条件评估为 False。由于我们将循环条件设置为常量值
    True，因此它将一直运行，除非我们以某种方式中断它。在循环内部，我们调用 `fun()` 函数，打印出字符串“我在一个无限循环中”。在➋处，询问用户“你想退出吗？”
    如果用户输入 y 作为输入，程序会通过 `break` 语句退出循环（`break` 语句会退出最内层的循环，而不执行该循环中的其他任何语句）。如果用户输入其他内容（或者什么都不输入，仅按回车键），则
    `while` 循环会继续执行——也就是说，它会再次打印该字符串，并继续这样做，直到用户希望退出。以下是该程序的一次示例运行：
- en: I am in an endless loop
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个无限循环中
- en: Do you want to exit? (y) for yes n
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你想退出吗？（y）是，其他键为否 n
- en: I am in an endless loop
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个无限循环中
- en: Do you want to exit? (y) for yes n
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 你想退出吗？（y）是，其他键为否 n
- en: I am in an endless loop
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个无限循环中
- en: Do you want to exit? (y) for yes n
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你想退出吗？（y）是，其他键为否 n
- en: I am in an endless loop
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个无限循环中
- en: Do you want to exit? (y) for yes y
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 你想退出吗？（y）是，其他键为否 y
- en: 'Based on this example, let’s rewrite the multiplication table generator so
    that it keeps going until the user wants to exit. The new version of the program
    is shown below:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个例子，让我们重写乘法表生成器，使其继续运行，直到用户想要退出。新版本的程序如下所示：
- en: ''''''''
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Multiplication table printer with
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 带有乘法表打印器的
- en: exit power to the user
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 退出权限授予用户
- en: ''''''''
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def multi_table(a):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 'def multi_table(a):'
- en: 'for i in range(1, 11):'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 11):'
- en: print('{0} x {1} = {2}'.format(a, i, a*i))
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: print('{0} x {1} = {2}'.format(a, i, a*i))
- en: 'if __name__ == ''__main__'':'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: 'while True:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: a = input('Enter a number: ')
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = input(''请输入一个数字: '')'
- en: multi_table(float(a))
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: multi_table(float(a))
- en: answer = input('Do you want to exit? (y) for yes ')
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: answer = input('你想退出吗？(y) 代表是 ')
- en: 'if answer == ''y'':'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == ''y'':'
- en: break
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: If you compare this program to the one we wrote earlier, you’ll see that the
    only change is the addition of the while loop, which includes the prompt asking
    the user to input a number and the call to the multi_table() function.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个程序与我们之前写的程序进行比较，你会发现唯一的变化就是添加了 while 循环，其中包括提示用户输入数字的部分和调用 multi_table()
    函数的部分。
- en: 'When you run the program, the program will ask for a number and print its multiplication
    table, as before. However, it will also subsequently ask whether the user wants
    to exit the program. If the user doesn’t want to exit, the program will be ready
    to print the table for another number. Here is a sample run:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，程序会要求输入一个数字并打印该数字的乘法表，如之前所示。然而，程序还会随后询问用户是否希望退出程序。如果用户不想退出，程序将准备好打印另一个数字的乘法表。以下是一个示例运行：
- en: Enter a number: 2
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '请输入一个数字: 2'
- en: 2.000000 x 1.000000 = 2.000000
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 1.000000 = 2.000000
- en: 2.000000 x 2.000000 = 4.000000
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 2.000000 = 4.000000
- en: 2.000000 x 3.000000 = 6.000000
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 3.000000 = 6.000000
- en: 2.000000 x 4.000000 = 8.000000
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 4.000000 = 8.000000
- en: 2.000000 x 5.000000 = 10.000000
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 5.000000 = 10.000000
- en: 2.000000 x 6.000000 = 12.000000
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 6.000000 = 12.000000
- en: 2.000000 x 7.000000 = 14.000000
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 7.000000 = 14.000000
- en: 2.000000 x 8.000000 = 16.000000
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 8.000000 = 16.000000
- en: 2.000000 x 9.000000 = 18.000000
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 9.000000 = 18.000000
- en: 2.000000 x 10.000000 = 20.000000
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 2.000000 x 10.000000 = 20.000000
- en: Do you want to exit? (y) for yes n
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你想退出吗？(y) 代表是，n 代表否
- en: 'Enter a number:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入一个数字：
- en: Try rewriting some of the other programs in this chapter so that they continue
    executing until asked by the user to exit.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重写本章中的其他一些程序，使它们在用户要求退出之前持续执行。
