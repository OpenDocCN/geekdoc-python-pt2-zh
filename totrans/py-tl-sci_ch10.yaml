- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FLOW CONTROL**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve been focusing on the components of programs, such as expressions,
    variables, and data types. We’ve strung a few of these together into simple executable
    instructions, but these have been mostly linear in nature; in other words, they
    were executed in the order in which they were written. More complex programs will
    include branching instructions that skip whole sections of code, jump back to
    the beginning, or decide among multiple options. To handle these situations, you’ll
    need a way to control the flow of your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The *flow of execution* refers to the order in which statements are run in a
    program. Execution starts at the top of the code, with the first statement, after
    which point the statements are read in order. But this order doesn’t have to be
    from top to bottom. In fact, the flow in most programs changes directions like
    cars in a busy intersection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '*Flow control statements* give Python the ability to make decisions about which
    instructions to execute next. You can think of these statements as the diamond
    shapes in flowcharts that indicate a decision is required to move forward ([Figure
    10-1](ch10.xhtml#ch010fig1)).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: The diamond shape represents a decision in a flowchart.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This flowchart evaluates whether the `number` variable is greater than or equal
    to `3`. The resulting decision causes the code to choose one path or another,
    a process called *branching*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss the `if`, `else`, `elif`, `while`, `for`, `break`,
    and `continue` flow control statements and clauses. We’ll also look at ways to
    monitor the execution of flow and handle any exceptions that might occur.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**The if Statement**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `if` statement is a conditional, or relational, statement. All control statements,
    including `if` statements, end with a colon (`:`) and are followed by an indented
    block of code. This indented clause executes only if the `if` statement’s condition
    is `True`. Otherwise, the clause is skipped.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this snippet checks whether 42 is less than 2\. Only if the condition
    tests `True` will it print a message:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All `if` statements must express a *condition*, which is an expression that
    is either true or false. This example used a comparison operator (`<`) to express
    a condition. Another option is to use Boolean values (covered in [Chapter 8](ch08.xhtml)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: If you run this code, you should notice that nothing happens. This is because
    the statement evaluated to `False`. That’s okay, but in most cases, you’ll want
    to explicitly handle `False` outcomes, if only to make it clear that there’s no
    missing code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do that by adding an `else` clause, which executes if the `if` statement
    does not. The diamond in [Figure 10-1](ch10.xhtml#ch010fig1) represents an `if-else`
    statement that works as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `else` clause represents the `False` branch in [Figure 10-1](ch10.xhtml#ch010fig1).
    If the condition in the `if` statement is not met, it prints the string `′``Out
    of range.``′`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Code Blocks***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lines of code immediately underneath `if` statements and `else` clauses are
    indented. Indenting code tells the Python interpreter that a group of statements
    belongs to a specific *block* of code. These blocks execute as a single unit and
    end when the indentation level decreases back to zero or to the same level as
    a containing block.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages make use of specific syntax to structure their code,
    such as braces (`{}`) for marking blocks, and semicolons (`;`) for ending lines.
    Python uses whitespace, because it is easier to understand visually, as demonstrated
    in [Figure 10-2](ch10.xhtml#ch010fig2), which diagrams the previous `if` statement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Example code blocks*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The colon at the end of the first line lets Python know that a new code block
    is coming up. Each line in this block must be indented by the same amount. In
    the figure, Block 1 is the code that runs if the `if` statement’s condition is
    `True`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The following `else` clause returns to the previous indentation level. The colon
    after `else` denotes the start of another block (the block that runs if the `if`
    statement’s condition is `False`, or Block 2), and this, too, must be indented.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve been dealing with a single level of indentation, but blocks can contain
    more deeply indented, or *nested*, blocks. In the following example, each input
    line after line `In [7]` represents a new block of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you make a mistake indenting code, don’t worry, Python will let you know.
    Depending on where the mistake occurred (such as outside or inside a function),
    it will raise either a `SyntaxError` or an `IndentationError`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '*According to the PEP8 Style Guide ([https://pep8.org/#indentation/](https://pep8.org/#indentation/)),
    you should use four spaces per indentation level, and spaces are preferred to
    using tabs. By default, the Spyder text editor converts a tab into four spaces,
    so you can reduce your repetitive strain injury exposure. You can find this option
    under Tools *▸* Preferences *▸* Editor *▸* Source Code *▸* Indentation characters.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the else and elif Clauses***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `if` statement comes with another optional clause, called `elif` (short
    for “else-if”), which tests another condition when the `if` statement evaluates
    to `False`. The `elif` clause lets you check multiple expressions for `True` and
    execute a block of code as soon as one of the conditions evaluates to `True`.
    You then can use the `else` clause as a final “catch all” that runs if none of
    the previous conditions are met.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `elif` and `else` to compare a single variable, representing the
    core temperature of a nuclear reactor in degrees Celsius, to several possible
    responses:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code starts by assigning an optimum operating temperature of 300^° Celsius
    to the `core` variable. Next, an `if` statement tests whether the temperature
    is below 200^°. If so, the core should be shut down, so a message to that effect
    is printed. Next, a series of `elif` clauses look at other outcomes, such as a
    core temperature of exactly 300^°, and print appropriate responses. Finally, an
    `else` clause executes if all the proceeding conditions evaluate to `False`. This
    will catch a `core` value greater than or equal to `1800`. Closing an `if` statement
    block with an `else` clause ensures that at least one clause is executed, and
    you won’t be left with an empty response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an `else` clause, you’ll want to be very careful that your code
    properly handles the full range of possible values. For example, the following
    code prints the meltdown warning, even though the core temperature is only 200^°.
    See if you can figure out what went wrong:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because this code failed to explicitly handle a `core` value of exactly `200`,
    it was evaluated in the `else` clause, resulting in an incorrect message and a
    lot of unnecessary excitement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Also make sure that *only one* condition evaluates to `True`. An advantage of
    using `elif` is that if a condition evaluates to `True`, the program will execute
    its corresponding block and exit the statement immediately. This is efficient,
    but if more than one `elif` condition evaluates to `True`, only the block associated
    with the *first* `True` condition will execute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, here’s a poorly written piece of code that uses `elif` to increment
    multiple count variables whose conditions overlap:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code starts by assigning tuples of dog breeds, cat breeds, and combined
    popular breeds. It then assigns count variables for each category, after which
    a poodle breed is assigned to the `animal` variable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Next, a series of conditional statements evaluates the `animal` variable. If
    it’s in the `dogs` tuple, the `dog_count` variable is incremented by 1\. Otherwise,
    if it’s in the `cats` tuple, the `cat_count` variable is incremented, and then,
    if it’s only in the `popular_breeds` tuple, the `popular_breeds_count` is incremented.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: When you run the code and check the counts, they’re incorrect. Despite “poodle”
    being present in both the `dogs` and `popular_breeds` tuples, only the `dog_count`
    variable was updated. Because the first `elif` clause evaluated to `True`, the
    `if` statement terminated immediately, and the popular breeds evaluation was never
    performed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Ternary Expressions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For convenience, Python lets you combine an `if-else` block into a single expression
    called a *ternary expression* whose syntax is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ternary expressions let you write pithy code at the cost of readability. They
    should be used with only simple and straightforward conditions and expressions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Boolean Operators***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To further aid you in making comparisons, Python provides the `and`, `or`, and
    `not` operators. These three operators compare Boolean values and evaluate to
    a Boolean value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The possible outcomes for Boolean operators can be shown in a truth table, which
    we present in [Table 10-1](ch10.xhtml#ch010tab1).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** Truth Table for `and`/`or` Operators'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Evaluation** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| True `and` True | True |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| True `and` False | False |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| False `and` True | False |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| False `and` False | False |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| True `or` True | True |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| True `or` False | True |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| False `or` True | True |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| False `or` False | False |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: As you can see, the `and` operator evaluates an expression to `True` only if
    *both* Boolean values are `True`. The `or` operator evaluates to `True` if *either*
    of the Boolean values is `True`. For example, you could say you had “cereal” for
    breakfast if you had either corn flakes *or* raison bran, but you can’t say you
    had “bacon and eggs” unless you had both bacon *and* eggs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The `not` operator operates on only *one* expression or Boolean and evaluates
    to the *opposite* Boolean value. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With `and`, `or`, and `not`, you can build more complex comparisons for directing
    your code’s flow of execution. Try out a few examples in the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Python will evaluate each expression, from left to right, until it has a single
    Boolean value. It then evaluates these Booleans down to a single value, either
    `True` or `False`. The order of operations is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: math operators → comparison operators → `not` operator → `and` operator → `or`
    operator
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'With Boolean operators, you can compare multiple variables within `if` statements.
    Here’s an example in which you discriminate animals using the number of legs and
    the sound produced:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous example, both conditions had to be `True` for the `if` statement
    to execute. In the following example, only one of the conditions needs to be `True`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `today` is either `Saturday` or `Sunday`, you’re in the weekend, and the
    `print()` function is called.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it’s easy to slip-up when using `if` statement syntax. The following
    code looks logical, but it will evaluate to `True` no matter the value of the
    `today` variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Loops**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops permit the repetition of certain steps indented under a keyword. The repetition
    continues until some condition is met, making loops much like `if` statements,
    but they can run more than once.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Python uses the `while` and `for` keywords for loops. These correspond to *condition-controlled*
    loops and *collection-controlled* loops, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` keyword, plus a condition, forms a `while` statement. These are
    used to execute a block of code repeatedly until the given condition evaluates
    to `False`. At this point, the line immediately after the loop in the program
    is executed. Here’s the syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `for` keyword is used to repeat a block of code a fixed number of times
    or to iterate over a sequence of items. Here’s the basic syntax:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the `for` loop runs out of items, its underlying condition becomes `False`,
    and the loop ends and returns control to the first line of code under the `for`
    loop’s block.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `for` 循环耗尽所有项目时，它的底层条件变为 `False`，循环结束并将控制权返回到 `for` 循环块下的第一行代码。
- en: '***The while Statement***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***while 语句***'
- en: The `while` statement tests a condition and executes the block over and over
    until the condition is `False` ([Figure 10-3](ch10.xhtml#ch010fig3)) or you explicitly
    end the loop with a `break` statement (more on these later). In fact, a `while`
    loop can go on forever.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句会测试一个条件，并不断执行代码块，直到条件变为 `False`（[图 10-3](ch10.xhtml#ch010fig3)），或者你显式地使用
    `break` 语句结束循环（后面会详细讲解）。事实上，`while` 循环可能会永远运行下去。'
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Flowchart for a generic while loop*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：通用 `while` 循环的流程图*'
- en: A `while` loop is useful for performing some action until a target is reached.
    For instance, you can simulate the population growth of a herd of deer until the
    population reaches a target value, at which time the simulation loop could stop
    and log details, such as the time it took to reach the target or the average weight
    of an adult deer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环用于在达到目标之前执行某个操作。例如，你可以模拟一群鹿的种群增长，直到种群达到目标值，这时模拟循环可以停止并记录相关细节，如达到目标所花费的时间或成年鹿的平均体重。'
- en: A much simpler example is testing for a password. In the code that follows,
    we give a user a set number of times to enter the correct value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的例子是测试密码。在下面的代码中，我们给用户设定了一个输入正确密码的次数限制。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we first create an empty `password` variable and set a `count`
    variable to `0`. We then start a loop using the `while` keyword ➊. If `password`
    does not equal “Python,” the indented `while` clause will prompt the user to enter
    a password. It then increments the `count` variable by `1` and uses an `if` statement
    to check if the number of allowable counts has been exceeded ➋. If this evaluates
    to `True`, the user is informed that they have exceeded the allowed number of
    attempts, and the `break` keyword ends the loop. If `count` is less than or equal
    to `3`, the loop will continue prompting the user for a password. If the user
    enters the correct password, the loop ends without fanfare.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个空的 `password` 变量，并将 `count` 变量设置为 `0`。然后我们使用 `while` 关键字开始一个循环
    ➊。如果 `password` 不等于“Python”，缩进的 `while` 子句将提示用户输入密码。接着它将 `count` 变量增加 `1`，并使用
    `if` 语句检查是否超过了允许的次数 ➋。如果这个条件为 `True`，用户将被告知已超出允许的尝试次数，并且 `break` 关键字将结束循环。如果 `count`
    小于或等于 `3`，循环将继续提示用户输入密码。如果用户输入正确密码，循环将在没有任何提示的情况下结束。
- en: '[Figure 10-4](ch10.xhtml#ch010fig4) documents this loop in a flowchart. Note
    how both the `while` and `if` conditions are marked by diamonds. This is because
    they represent decision points.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.xhtml#ch010fig4) 用流程图记录了这个循环。注意 `while` 和 `if` 条件都被标记为菱形。这是因为它们代表了决策点。'
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: The flowchart for the password while loop*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：密码 `while` 循环的流程图*'
- en: Each execution of a loop is called an *iteration*. The `while` loop can iterate
    *indefinitely* because the number of loops isn’t explicitly specified at the start.
    A `while` loop can run a million times or end after the first iteration depending
    on whether its condition is met.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行循环都称为一次 *迭代*。`while` 循环可以 *无限次* 迭代，因为循环的次数在开始时没有明确指定。`while` 循环可以执行一百万次，或者在第一次迭代后结束，这取决于其条件是否满足。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your program is ever caught in an infinite loop, you can use CTRL-C to
    stop the program and escape.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的程序进入了无限循环，可以使用 CTRL-C 停止程序并退出。*'
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 1.  Each new code block should be indented _____ spaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 每个新的代码块应该缩进 _____ 个空格。
- en: '2.  True or false: The `or` operator evaluates an expression to `True` only
    if *both* Boolean values are `True`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 判断对错：`or` 操作符仅在 *两个* 布尔值都为 `True` 时，才会使表达式的结果为 `True`。
- en: 3.  Write a `while` loop that never ends, and then stop it using CTRL-C.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 编写一个永不结束的 `while` 循环，然后使用 CTRL-C 停止它。
- en: 4.  Which values can be used to represent `False`?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 哪些值可以用来表示 `False`？
- en: a.  `0`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: a. `0`
- en: b.  0.0
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: b. `0.0`
- en: c.  F
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: c. F
- en: d.  All the above
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: d. 上述所有
- en: 5.  To form Pig Latin, one takes an English word that begins with a consonant,
    moves the consonant to the end, and adds “ay” after it. If the word begins with
    a vowel, one simply adds “way” to the end. Use the Spyder text editor to write
    a program that takes a word as input and uses indexing and slicing to return its
    Pig Latin equivalent. Keep the program running until the user decides to quit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  形成猪拉丁语的方法是：将一个以辅音开头的英语单词将辅音移到末尾，并在其后添加“ay”。如果单词以元音开头，则直接在末尾添加“way”。使用 Spyder
    文本编辑器编写一个程序，接受一个单词作为输入，利用索引和切片返回其对应的猪拉丁语形式。保持程序运行，直到用户决定退出。
- en: '***The for Statement***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 语句***'
- en: 'The `for` statement lets you execute a loop a set number of times. This number
    is often specified using the built-in `range()` function. This memory-efficient
    function returns a sequence of evenly spaced numbers starting from 0 (by default)
    and ending before a specified endpoint. Here’s what the `range()` function’s syntax
    looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句让你能够执行固定次数的循环。这个次数通常通过内建的 `range()` 函数来指定。这个内存高效的函数返回一个从 0（默认值）开始，直到指定结束点之前的等距数字序列。以下是
    `range()` 函数的语法：'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `start` and `step` parameters are optional. If omitted, the `start` parameter
    defaults to `0`, and the `step` defaults to `1`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 和 `step` 参数是可选的。如果省略，`start` 参数默认值为 `0`，`step` 默认值为 `1`。'
- en: 'Here’s an example where a `for` loop uses `range()` to print five numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了如何使用 `for` 循环和 `range()` 打印五个数字：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `5` is not included in the output. This is because the function reads
    *up to* the stop value but doesn’t include it. The block beneath the `for` statement
    is indented, just as in a `while` loop.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`5` 没有包含在输出中。这是因为该函数读取*直到*停止值，但不包括它。`for` 语句下面的代码块是缩进的，就像在 `while` 循环中一样。
- en: 'Here’s an example using all three arguments (`start`, `stop`, `step`) in `range()`
    to print every other number from 1 to 6:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示如何使用 `range()` 中的所有三个参数（`start`、`stop`、`step`），以打印从 1 到 6 之间的每个其他数字：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `i` in the previous code is used by convention when iterating
    over a range of numbers. Any legal variable name (such as `num` or `number`) will
    work. An underscore (`_`) is preferred if you’re using a linter to check your
    code; other names can sometimes trigger an `unused variable` warning.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在之前的代码中，`i` 是按照惯例在遍历数字范围时使用的变量名。任何合法的变量名（如 `num` 或 `number`）都可以使用。如果你使用
    linter 工具检查代码，建议使用下划线（`_`）；否则，其他变量名有时会触发“未使用的变量”警告。
- en: 'You can use `range()`in conjunction with the `len()` function to obtain the
    endpoint for an arbitrarily sized sequence. Here’s an example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `range()` 与 `len()` 函数结合使用，来获取任意大小序列的结束点。以下是一个示例：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code starts by assigning a list of letters to the `my_list` variable. In
    the following `if` statement, passing the `range()` function the length of this
    list, as determined by the `len()` function, sets the number of iterations. With
    each iteration, the current value of `i` is used as an index for the list, and
    the corresponding letter is printed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先将字母列表赋值给 `my_list` 变量。在随后的 `if` 语句中，通过将 `range()` 函数与 `len()` 函数结合使用，设置了循环的迭代次数。每次迭代时，当前的
    `i` 值被用作列表的索引，并打印出相应的字母。
- en: 'Although it works, this code isn’t very Pythonic. Fortunately, you can use
    iterables directly in the `for` statement. Remember, iterables are objects that
    can return their items one at a time. These include sequence types like range,
    list, tuple, string, set, and more. As a result, you don’t need to keep track
    of the iterable’s size or use a running index. Here’s the previous snippet in
    this format:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它能工作，但这段代码并不算非常 Pythonic。幸运的是，你可以直接在 `for` 语句中使用可迭代对象。记住，可迭代对象是那些可以一次返回一个元素的对象，包括像
    `range`、`list`、`tuple`、`string`、`set` 等序列类型。因此，你不需要跟踪可迭代对象的大小或使用一个递增的索引值。以下是使用这种格式的之前代码片段：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the code reads almost like English. You can’t get more Pythonic than
    that!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码几乎像英语一样可读。没有比这更“Pythonic”的写法了！
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Never add or delete items to a list while looping over it. If you want to
    change a list during a loop, append the changes to a new list.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*在遍历列表时，绝对不要添加或删除列表中的项。如果你想在循环过程中更改列表，应该将更改追加到一个新的列表中。*'
- en: 'You can even loop over a string and print its characters without using an intermediate
    variable to hold the string:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以遍历一个字符串并打印其字符，而无需使用中间变量来保存字符串：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the event that you need an item’s index during looping, the best solution
    is to use the built-in `enumerate()` function. This function adds a counter to
    each item of an iterable object and returns an *enumerate* object, allowing you
    to loop over an iterable and keep track of the number of iterations. The first
    index value starts from 0 by default, but you can override that by specifying
    a starting index. The following example produces a numbered list of items (starting
    at 1) from a `list` datatype:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在循环过程中需要获取项的索引，最佳的解决方案是使用内置的`enumerate()`函数。该函数为可迭代对象中的每个项添加计数器，并返回一个*enumerate*对象，允许你在循环过程中追踪迭代次数。默认情况下，第一个索引值从0开始，但你可以通过指定起始索引来覆盖这一行为。下面的示例生成一个编号的项列表（从1开始），数据类型为`list`：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some other uses for `enumerate()` include selecting every *n* items from a list,
    ending a loop after *n* items, and using the indexes for line weights or symbol
    sizes when plotting.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`的其他用法包括从列表中选择每隔*n*项，循环*n*项后结束循环，以及在绘图时使用索引作为线条权重或符号大小。'
- en: '***Loop Control Statements***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环控制语句***'
- en: '*Loop control statements* are used inside loops to change the normal sequence
    of execution. Earlier, you used a `break` statement to interrupt and end a `while`
    loop. Python also uses `continue` and `pass` statements to control loops.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环控制语句*用于循环内部，改变正常的执行顺序。之前，你使用了`break`语句来中断并结束`while`循环。Python还使用`continue`和`pass`语句来控制循环。'
- en: '**The break Statement**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**break语句**'
- en: The `break` keyword lets you exit a loop’s code block at any time. A common
    usage is to set `while` to `True` (`while True:`) and then “manually” break out
    of the loop when a condition is met. Because `True` always evaluates to true,
    no condition can stop the loop, so you must force the issue using `break`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`关键字允许你随时退出循环的代码块。一种常见的用法是将`while`设置为`True`（`while True:`），然后在满足某个条件时“手动”退出循环。由于`True`始终为真，无法通过条件停止循环，因此必须使用`break`强制退出。'
- en: 'In nested loops, `break` terminates only the block it’s in, along with any
    inner blocks. Outer loops will continue to run. For example, the following example
    contains two nested loops:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套循环中，`break`只终止其所在的代码块及其中的任何内部代码块。外部循环将继续执行。例如，下面的示例包含了两个嵌套循环：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even though the `break` statement interrupted the inner `for` loop and prevented
    “Jamie” from printing, the outer loop ran to completion.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`break`语句中断了内部的`for`循环并且阻止了“Jamie”的打印，外部循环仍然会继续执行直到完成。
- en: '**The continue Statement**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**continue语句**'
- en: 'The `continue` keyword immediately returns control to the beginning of a loop,
    skipping any loop clauses beneath it. For instance, the following example uses
    a `while` loop to evaluate a user’s name and password. Enter the code in the Jupyter
    Qt console and then run it using SHIFT-ENTER:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`关键字会立即将控制权返回到循环的起始位置，跳过其下方的任何循环语句。例如，下面的示例使用`while`循环来验证用户的用户名和密码。将代码输入到Jupyter
    Qt控制台中，然后按SHIFT-ENTER运行：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first step, of course, is to get the correct username. If the condition
    for the first `if` statement evaluates to `True` (the name is *not* “Alice”),
    a `continue` statement interrupts the loop and restarts the sequence ➊. If the
    name passes the test, the `continue` statement is skipped, and the user is prompted
    for a password ➋. If they enter the correct value, a `break` statement ends the
    loop ➌. Otherwise, they’re alerted to the error, and the loop begins again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当然是获取正确的用户名。如果第一个`if`语句的条件为`True`（用户名*不是*“Alice”），则`continue`语句会中断循环并重新开始序列
    ➊。如果用户名通过测试，`continue`语句会被跳过，接下来会提示用户输入密码 ➋。如果输入正确，`break`语句会结束循环 ➌。否则，用户会收到错误提示，循环重新开始。
- en: '**The pass Statement**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**pass语句**'
- en: 'You can use the `pass` keyword to build “empty” loops, or blocks that take
    no action. These keywords serve as placeholders for future code or flag places
    where you intentionally omitted something. Take this snippet, for example, in
    which we choose to not print the `h` in `Python`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pass`关键字来构建“空”循环，或者不执行任何操作的代码块。这些关键字作为占位符，预留将来填写的代码，或者标记你故意省略某些内容的位置。例如，在这个片段中，我们选择不打印`Python`中的`h`：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code assigns “Python” to the `word` variable, and 0 to the `count` variable.
    While the `count` value is less than the length of `word`, the loop prints each
    character in `word` indexed at the current `count` value. If `count` is equal
    to `3`, however, it uses the `pass` keyword to continue the loop with no action.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: You could have accomplished the same thing by only printing `count < 3` and
    `count > 3`, but this could be viewed in retrospect as an indexing mistake (see
    the earlier core temperature example at lines `In [10]-[11]`). By including the
    reference to `h` and using `pass` ➊, it’s clear that you knew what you were doing.
    You basically said, “I know there’s a letter at this index and I’m not printing
    it on purpose.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '***Replacing Loops with Comprehensions***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Python, a *comprehension* is a way to construct a new sequence such as a
    list, set, or dictionary from an existing sequence. For example, you might want
    to create a new list containing the logarithms of the numbers in another list.
    As a replacement for standard `for` loops, comprehensions are faster, more elegant,
    and more concise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'A downside to comprehensions is that you can’t embed a `print()` function in
    the loop to help you track what’s happening. They can also be quite difficult
    to read when using complicated expressions, but for simple expressions, they can’t
    be beat. Python supports comprehensions for lists, dictionaries, sets, and something
    we’ll talk about in the next chapter: generators.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To make a new list using *list comprehension*, encase the comprehension expression
    in square brackets. To use a condition to choose items from an existing iterable,
    use this syntax:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use this syntax if you want to alter these items, or generate new items, before
    adding them to the new list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For instance, here’s an example that takes a string, loops through it, capitalizes
    each letter, and appends the capital letter to a new list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we assigned a string to the `word` variable, and then we created the `letters`
    list using the list comprehension `[letter.upper() for letter in word]`. Notice
    how the syntax is a little backward, as the loop variable (`letter`) appears before
    it’s defined.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example extracts the capital “P” from “Python.” Notice how you
    can use an `if` statement within the comprehension:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The single-line list comprehension in line `In [57]` is equivalent to the following
    code using a standard `for` loop:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, list comprehension saved you three lines of code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can create list comprehensions using nested `for` loops, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see more examples of list comprehensions at *[https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html)*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary Comprehensions**'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Dictionary comprehensions* are like list comprehensions, except they use key-value
    (k, v) pairs in place of items, are enclosed in curly brackets, and return a dictionary
    rather than a list.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use dictionary comprehensions on existing dictionaries, in which case
    you either choose key-value (k, v) pairs from the existing dictionary based on
    some condition, or you use an expression on the keys and/or values based on a
    condition. The general syntax is:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'or:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When using dictionary comprehension on another type of iterable, like a list,
    you choose and/or change existing items in the iterable to serve as key-value
    pairs in the new dictionary. The syntax is varied, but looks something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the expression can alter the item used for the key, for the value
    or for both.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example in which we extract even numbers from a list and map them
    to their square:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here we zip two tuples (the `mineral` and `hardness` variables) together
    to create part of Moh’s famous mineral hardness scale:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that you also can generate the `mohs` dictionary by calling the built-in
    `dict()` function, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Set Comprehensions**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Set comprehensions* are enclosed in curly brackets and return unsorted sets.
    You can *choose* existing items from an iterable using the following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you can alter the items or derive new items by applying a condition-based
    expression before adding the item to the new set:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here’s an example that returns all the unique characters in a string, given
    that sets don’t allow duplicate values (this is the same as the `set()` function):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And here we use an expression to calculate word lengths:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Handling Exceptions**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *exception* occurs when Python encounters an error during execution. This
    causes it to “raise an exception” and produce a Python object that represents
    an error. If not dealt with immediately, exceptions cause a program to terminate
    and display an error message.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, exceptions can be “caught” and handled through flow control. This
    gives you the opportunity to fix the problem, try again, supply a more helpful
    error message, or suppress the error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '***Using try and except***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python provides a `try` statement with an `except` clause to help you handle
    exceptions. The `try` statement lets you isolate code that could potentially contain
    an error and crash your program. If the code contains an error, the `except` clause
    will deal with it by providing code that executes only when an exception is raised.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest exception handling merely prevents your program from crashing
    unceremoniously. It presents an alert and (hopefully) a helpful message. Here
    is an example that’s designed to handle incorrect input from a user:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, the `age` value is converted to an integer, as we want `age`
    to be a whole number in years. But the user entered letters instead (`Harry`),
    which raised a `ValueError` exception because letters can’t be converted into
    integers. You don’t see this error message, however, as we caught the exception
    using the `try` statement, which does just what it says. It tries the code in
    isolation, giving us the opportunity to do something before the program crashes.
    Here, we printed a message to the user so that the program ends somewhat gracefully.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you want to specify the type of exception to handle rather than
    catch all of the built-in exceptions, as we did in the previous snippet. You can
    find a list of exception types on [Table 7-4](ch07.xhtml#ch07tab4) on [page 183](ch07.xhtml#ch07tab4).
    You can also create the error you’re looking for in the console and read off the
    exception name from the resulting `Traceback` message.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the previous snippet to catch a `ValueError`. Just place the
    proper exception name after `except`, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also trap for multiple exception types by placing them after `except`
    as a tuple with parentheses:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you want to use a different message or take a different action with each
    error type, simply use multiple stacked `except` clauses within a `try` statement,
    in this format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also incorporate Python’s error messages into your own customized versions.
    Exceptions have *arguments*, which are official messages from Python describing
    what happened. You can use an argument by specifying a variable after the exception
    type, preceded by the keyword `as`. Here’s an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now you have the best of both worlds: Python’s precise but technical explanation
    combined with friendlier instructions for non-programmers.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can add an `else` clause at the end of all the `except` clauses.
    This lets you do something, like confirm a successful operation, if no exceptions
    are raised elsewhere in the `try` block:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***Forcing Exceptions with the raise Keyword***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python’s `raise` keyword allows you to force a specified exception if a condition
    occurs. You can use it to raise built-in error types or your own custom errors.
    It’s especially useful for validating inputs such as enforcing the use of maximum
    values, or handling the input of a negative number when you’re working with positive
    numbers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to create your own custom error, enter the following in Spyder’s
    text editor and save it with any name you please:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, you accept a name from the user, convert it to lowercase, and compare
    it to “potter.” If the name doesn’t match, you use the `raise` keyword and call
    the `Exception` class, passing it a custom message.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the file and input “Houdini” when prompted. You should see this general
    output in the console (truncated for brevity):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To force Python to raise one of its built-in exceptions, substitute the name
    of the built-in exception class (see [Table 7-4](ch07.xhtml#ch07tab4)) for the
    `Exception` class you used previously. In this example, we raise Python’s built-in
    `TypeError` exception:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can read more about `raise` at *[https://docs.python.org/3/tutorial/errors.html](https://docs.python.org/3/tutorial/errors.html)*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '***Ignoring Errors***'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if you want to ignore errors while looping? For example, suppose that
    you’ve used Python’s `None` keyword to define missing or null sample values in
    your dataset (`data`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You don’t want to strip this placeholder out of the dataset, because it contains
    valuable information. It lets you know that the dataset is incomplete as well
    as the location of the missing data. But if you try to iterate over the data and
    do something to it such as divide each value by 2, the `None` value will raise
    a `TypeError` and crash the program:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can combine multiple flow control elements to handle this missing data.
    Here, we use a `try` statement with an `except` clause within the `for` loop:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, the loop runs to completion and flags where data is missing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if you want to completely skip over the missing data? For example,
    you want to pass the output to some other mathematical operation where the “missing
    data” values would interfere? In this case, use the `continue` statement, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The loop now treats the missing value as if it doesn’t exist because it continues
    the loop when it encounters the value. Remember, `continue` immediately returns
    control to the beginning of a loop.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracing Execution with Logging**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To control the flow of your program, you need to know what it’s returning at
    key locations. One way to keep track of this is to use the `print()` function.
    This lets you print the output, the data type of a variable, or some other useful
    information about an important step.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` function works well for small programs, but if you’re using it
    only to quality-control your code, it can come with a price. To unclutter your
    code and output, you might need to go back later and either delete all the lines
    containing `print()` or comment them out (by placing a `#` at the start of the
    line) so that they don’t run.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: For large programs, a better choice is to use the `logging` module. This module
    is part of the standard library that ships with Python, and it can provide a customized
    report on what your program is doing at any location you choose. Five *logging
    levels* let you categorize messages by importance. These are listed in [Table
    10-3](ch10.xhtml#ch010tab3).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-3:** Python’s Logging Levels'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Function** | **Description** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| DEBUG | `logging.debug()` | Detailed information for diagnosing problems
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| INFO | `logging.info()` | Confirmation that things are working as expected
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| WARNING | `logging.warning()` | Unexpected event or potential future problem
    in working code |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| ERROR | `logging.error()` | An error prevented the code from functioning
    as intended |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| CRITICAL | `logging.critical()` | A serious error that may halt the program
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: 'Large programs that require logged messages are difficult to write in a console,
    so enter the following example in Spyder’s text editor and save it with a name
    like *logging.py*. This code uses `logging` to check that a vowel-counting program
    is working correctly:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Save the file and press F5 (or click the **Run** button) to execute the code.
    You should see this general output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let’s look at what you did. After importing the module, you used the `basicConfig()`
    method to set up and format the debugging information you wanted to see ➊. The
    `DEBUG` level is the lowest level of information and is used for diagnosing details.
    Adding a timestamp (`%(asctime)s`) is not necessary here, but it can become important
    when debugging long-running programs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the word to count, a constant for vowels, and a count variable,
    you started a `for` loop through the letters in the word and compared each to
    the contents of `VOWELS`. If the letter matched, you incremented the `num_vowels`
    counter by `1`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: For each letter evaluated, you used `logging.debug()` to enter the custom text
    message to display along with the current count ➋. The `logging` output displayed
    in the console. You can see the timestamp, the logging level, and the cumulative
    vowel count, along with which letters changed the count. In this case, only vowels
    change the count, so the program appears to be working as intended.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'You can redirect the logged messages to a permanent *text file* rather than
    displaying them on the screen. Just use the `filename` keyword in the `logging.basicConfig()`
    function, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As written, this code will save the log file to the same folder as your Python
    file. To save it elsewhere, you’ll need to specify a path.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `print()` function and `logging` can slow down your program. It’s
    easier to disable the `logging` messages, however. With the `logging.disable()`
    function, you can turn off all the messages for a certain level with one line
    of code, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Placing `logging.disable()` near the top of the program, just below the import
    statement, allows you to find it easily and toggle messages on and off by commenting
    them out with a hash mark, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `logging.disable()` method will suppress all messages at the designated
    level and lower. Because `CRITICAL` is the highest level, you can use it to disable
    messages at every level. This is much easier than finding and deleting (or commenting-out)
    multiple calls to `print()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the `logging` module, check out the documentation at *[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)*.
    For a basic tutorial, visit *[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Write a code snippet that asks a user for a username and password. If the
    username is incorrect, keep asking until the user gets it right. If only the password
    is incorrect, keep asking for the correct password but don’t repeat the username
    request.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 7.  The `for` loop is just a concise version of a `while` loop. Write a `while`
    loop that behaves like a `for` loop and prints the word “Python” five times.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Use list comprehension to make a list of all the *even* numbers between
    1 and 10.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Use a `for` loop with the `range()` function to print a NASA-style countdown
    from 10 to 0.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '10.  A secret message is hidden at the center of each of the following words:
    “age,” “moody,” “knock,” “adder,” “project,” “stoop,” “blubber.” Use a `for` loop
    to find and print the message.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Use the text editor to write a “guess my number” game that randomly chooses
    an integer between 1 and 100 (using `random.randint()`) and tells the player whether
    their answer is too high or too low until they guess correctly. Inform the player
    when they win and show them how many tries it took.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '12.  Use the text editor to write a “fortune cookie” program that presents
    the user with a menu of three options: Quit, Open a Fortune Cookie, or Open a
    Misfortune Cookie. Make a list of positive fortunes and a list of funny “misfortunes”
    and use the `random` module’s `choice()` function to randomly choose from each
    list. Print the results to the screen.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The magic of programming lies in the ability of programs to make decisions during
    execution. These decisions are facilitated by conditions that evaluate to `True`
    or `False`. Using comparison and Boolean operators with *conditional statements*
    like `if`, `elif`, and `else`, you can control what your code does and when it
    does it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Indentation* (whitespace) is used to segregate code into functionally similar
    segments, called *blocks*. Indentation levels let Python know when blocks start
    and end. This, in turn, helps you control the flow of execution through a program.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop causes code to execute over and over until a certain condition
    is met. The `for` loop, on the other hand, runs for a designated number of times
    or until it exhausts the items in a container data type, such as a list. Both
    types of loops can be manually interrupted with the `break` statement or forced
    to jump back to the start using the `continue` statement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop can be simplified into a single line of code using *comprehensions*.
    You can use these with lists, sets, and dictionaries. For simple expressions,
    comprehensions are not only more concise than `for` loops, they’re faster, as
    well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Because errors can affect the flow of your code, Python provides `try` statements
    with `except` clauses to help you handle errors by suppressing them, fixing them,
    creating customized error messages, or getting a user to try again. To help you
    find and debug errors and other issues, Python provides the `logging` module.
    Compared to the `print()` function, `logging` is a more sophisticated and manageable
    way to monitor the flow of execution of large programs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Another way to control flow is to write functions. We’ll look at these important
    “mini-programs” in the next chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
