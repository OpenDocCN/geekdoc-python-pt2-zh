- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FLOW CONTROL**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve been focusing on the components of programs, such as expressions,
    variables, and data types. We’ve strung a few of these together into simple executable
    instructions, but these have been mostly linear in nature; in other words, they
    were executed in the order in which they were written. More complex programs will
    include branching instructions that skip whole sections of code, jump back to
    the beginning, or decide among multiple options. To handle these situations, you’ll
    need a way to control the flow of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The *flow of execution* refers to the order in which statements are run in a
    program. Execution starts at the top of the code, with the first statement, after
    which point the statements are read in order. But this order doesn’t have to be
    from top to bottom. In fact, the flow in most programs changes directions like
    cars in a busy intersection.
  prefs: []
  type: TYPE_NORMAL
- en: '*Flow control statements* give Python the ability to make decisions about which
    instructions to execute next. You can think of these statements as the diamond
    shapes in flowcharts that indicate a decision is required to move forward ([Figure
    10-1](ch10.xhtml#ch010fig1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: The diamond shape represents a decision in a flowchart.*'
  prefs: []
  type: TYPE_NORMAL
- en: This flowchart evaluates whether the `number` variable is greater than or equal
    to `3`. The resulting decision causes the code to choose one path or another,
    a process called *branching*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss the `if`, `else`, `elif`, `while`, `for`, `break`,
    and `continue` flow control statements and clauses. We’ll also look at ways to
    monitor the execution of flow and handle any exceptions that might occur.
  prefs: []
  type: TYPE_NORMAL
- en: '**The if Statement**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `if` statement is a conditional, or relational, statement. All control statements,
    including `if` statements, end with a colon (`:`) and are followed by an indented
    block of code. This indented clause executes only if the `if` statement’s condition
    is `True`. Otherwise, the clause is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this snippet checks whether 42 is less than 2\. Only if the condition
    tests `True` will it print a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All `if` statements must express a *condition*, which is an expression that
    is either true or false. This example used a comparison operator (`<`) to express
    a condition. Another option is to use Boolean values (covered in [Chapter 8](ch08.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: If you run this code, you should notice that nothing happens. This is because
    the statement evaluated to `False`. That’s okay, but in most cases, you’ll want
    to explicitly handle `False` outcomes, if only to make it clear that there’s no
    missing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do that by adding an `else` clause, which executes if the `if` statement
    does not. The diamond in [Figure 10-1](ch10.xhtml#ch010fig1) represents an `if-else`
    statement that works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `else` clause represents the `False` branch in [Figure 10-1](ch10.xhtml#ch010fig1).
    If the condition in the `if` statement is not met, it prints the string `′``Out
    of range.``′`
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Code Blocks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lines of code immediately underneath `if` statements and `else` clauses are
    indented. Indenting code tells the Python interpreter that a group of statements
    belongs to a specific *block* of code. These blocks execute as a single unit and
    end when the indentation level decreases back to zero or to the same level as
    a containing block.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages make use of specific syntax to structure their code,
    such as braces (`{}`) for marking blocks, and semicolons (`;`) for ending lines.
    Python uses whitespace, because it is easier to understand visually, as demonstrated
    in [Figure 10-2](ch10.xhtml#ch010fig2), which diagrams the previous `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Example code blocks*'
  prefs: []
  type: TYPE_NORMAL
- en: The colon at the end of the first line lets Python know that a new code block
    is coming up. Each line in this block must be indented by the same amount. In
    the figure, Block 1 is the code that runs if the `if` statement’s condition is
    `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The following `else` clause returns to the previous indentation level. The colon
    after `else` denotes the start of another block (the block that runs if the `if`
    statement’s condition is `False`, or Block 2), and this, too, must be indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve been dealing with a single level of indentation, but blocks can contain
    more deeply indented, or *nested*, blocks. In the following example, each input
    line after line `In [7]` represents a new block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you make a mistake indenting code, don’t worry, Python will let you know.
    Depending on where the mistake occurred (such as outside or inside a function),
    it will raise either a `SyntaxError` or an `IndentationError`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*According to the PEP8 Style Guide ([https://pep8.org/#indentation/](https://pep8.org/#indentation/)),
    you should use four spaces per indentation level, and spaces are preferred to
    using tabs. By default, the Spyder text editor converts a tab into four spaces,
    so you can reduce your repetitive strain injury exposure. You can find this option
    under Tools *▸* Preferences *▸* Editor *▸* Source Code *▸* Indentation characters.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the else and elif Clauses***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `if` statement comes with another optional clause, called `elif` (short
    for “else-if”), which tests another condition when the `if` statement evaluates
    to `False`. The `elif` clause lets you check multiple expressions for `True` and
    execute a block of code as soon as one of the conditions evaluates to `True`.
    You then can use the `else` clause as a final “catch all” that runs if none of
    the previous conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `elif` and `else` to compare a single variable, representing the
    core temperature of a nuclear reactor in degrees Celsius, to several possible
    responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by assigning an optimum operating temperature of 300^° Celsius
    to the `core` variable. Next, an `if` statement tests whether the temperature
    is below 200^°. If so, the core should be shut down, so a message to that effect
    is printed. Next, a series of `elif` clauses look at other outcomes, such as a
    core temperature of exactly 300^°, and print appropriate responses. Finally, an
    `else` clause executes if all the proceeding conditions evaluate to `False`. This
    will catch a `core` value greater than or equal to `1800`. Closing an `if` statement
    block with an `else` clause ensures that at least one clause is executed, and
    you won’t be left with an empty response.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an `else` clause, you’ll want to be very careful that your code
    properly handles the full range of possible values. For example, the following
    code prints the meltdown warning, even though the core temperature is only 200^°.
    See if you can figure out what went wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because this code failed to explicitly handle a `core` value of exactly `200`,
    it was evaluated in the `else` clause, resulting in an incorrect message and a
    lot of unnecessary excitement.
  prefs: []
  type: TYPE_NORMAL
- en: Also make sure that *only one* condition evaluates to `True`. An advantage of
    using `elif` is that if a condition evaluates to `True`, the program will execute
    its corresponding block and exit the statement immediately. This is efficient,
    but if more than one `elif` condition evaluates to `True`, only the block associated
    with the *first* `True` condition will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, here’s a poorly written piece of code that uses `elif` to increment
    multiple count variables whose conditions overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code starts by assigning tuples of dog breeds, cat breeds, and combined
    popular breeds. It then assigns count variables for each category, after which
    a poodle breed is assigned to the `animal` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a series of conditional statements evaluates the `animal` variable. If
    it’s in the `dogs` tuple, the `dog_count` variable is incremented by 1\. Otherwise,
    if it’s in the `cats` tuple, the `cat_count` variable is incremented, and then,
    if it’s only in the `popular_breeds` tuple, the `popular_breeds_count` is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the code and check the counts, they’re incorrect. Despite “poodle”
    being present in both the `dogs` and `popular_breeds` tuples, only the `dog_count`
    variable was updated. Because the first `elif` clause evaluated to `True`, the
    `if` statement terminated immediately, and the popular breeds evaluation was never
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Ternary Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For convenience, Python lets you combine an `if-else` block into a single expression
    called a *ternary expression* whose syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ternary expressions let you write pithy code at the cost of readability. They
    should be used with only simple and straightforward conditions and expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Boolean Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To further aid you in making comparisons, Python provides the `and`, `or`, and
    `not` operators. These three operators compare Boolean values and evaluate to
    a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: The possible outcomes for Boolean operators can be shown in a truth table, which
    we present in [Table 10-1](ch10.xhtml#ch010tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** Truth Table for `and`/`or` Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Evaluation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| True `and` True | True |'
  prefs: []
  type: TYPE_TB
- en: '| True `and` False | False |'
  prefs: []
  type: TYPE_TB
- en: '| False `and` True | False |'
  prefs: []
  type: TYPE_TB
- en: '| False `and` False | False |'
  prefs: []
  type: TYPE_TB
- en: '| True `or` True | True |'
  prefs: []
  type: TYPE_TB
- en: '| True `or` False | True |'
  prefs: []
  type: TYPE_TB
- en: '| False `or` True | True |'
  prefs: []
  type: TYPE_TB
- en: '| False `or` False | False |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the `and` operator evaluates an expression to `True` only if
    *both* Boolean values are `True`. The `or` operator evaluates to `True` if *either*
    of the Boolean values is `True`. For example, you could say you had “cereal” for
    breakfast if you had either corn flakes *or* raison bran, but you can’t say you
    had “bacon and eggs” unless you had both bacon *and* eggs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `not` operator operates on only *one* expression or Boolean and evaluates
    to the *opposite* Boolean value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With `and`, `or`, and `not`, you can build more complex comparisons for directing
    your code’s flow of execution. Try out a few examples in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Python will evaluate each expression, from left to right, until it has a single
    Boolean value. It then evaluates these Booleans down to a single value, either
    `True` or `False`. The order of operations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: math operators → comparison operators → `not` operator → `and` operator → `or`
    operator
  prefs: []
  type: TYPE_NORMAL
- en: 'With Boolean operators, you can compare multiple variables within `if` statements.
    Here’s an example in which you discriminate animals using the number of legs and
    the sound produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, both conditions had to be `True` for the `if` statement
    to execute. In the following example, only one of the conditions needs to be `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `today` is either `Saturday` or `Sunday`, you’re in the weekend, and the
    `print()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it’s easy to slip-up when using `if` statement syntax. The following
    code looks logical, but it will evaluate to `True` no matter the value of the
    `today` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Loops**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops permit the repetition of certain steps indented under a keyword. The repetition
    continues until some condition is met, making loops much like `if` statements,
    but they can run more than once.
  prefs: []
  type: TYPE_NORMAL
- en: Python uses the `while` and `for` keywords for loops. These correspond to *condition-controlled*
    loops and *collection-controlled* loops, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` keyword, plus a condition, forms a `while` statement. These are
    used to execute a block of code repeatedly until the given condition evaluates
    to `False`. At this point, the line immediately after the loop in the program
    is executed. Here’s the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` keyword is used to repeat a block of code a fixed number of times
    or to iterate over a sequence of items. Here’s the basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the `for` loop runs out of items, its underlying condition becomes `False`,
    and the loop ends and returns control to the first line of code under the `for`
    loop’s block.
  prefs: []
  type: TYPE_NORMAL
- en: '***The while Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `while` statement tests a condition and executes the block over and over
    until the condition is `False` ([Figure 10-3](ch10.xhtml#ch010fig3)) or you explicitly
    end the loop with a `break` statement (more on these later). In fact, a `while`
    loop can go on forever.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Flowchart for a generic while loop*'
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop is useful for performing some action until a target is reached.
    For instance, you can simulate the population growth of a herd of deer until the
    population reaches a target value, at which time the simulation loop could stop
    and log details, such as the time it took to reach the target or the average weight
    of an adult deer.
  prefs: []
  type: TYPE_NORMAL
- en: A much simpler example is testing for a password. In the code that follows,
    we give a user a set number of times to enter the correct value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create an empty `password` variable and set a `count`
    variable to `0`. We then start a loop using the `while` keyword ➊. If `password`
    does not equal “Python,” the indented `while` clause will prompt the user to enter
    a password. It then increments the `count` variable by `1` and uses an `if` statement
    to check if the number of allowable counts has been exceeded ➋. If this evaluates
    to `True`, the user is informed that they have exceeded the allowed number of
    attempts, and the `break` keyword ends the loop. If `count` is less than or equal
    to `3`, the loop will continue prompting the user for a password. If the user
    enters the correct password, the loop ends without fanfare.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-4](ch10.xhtml#ch010fig4) documents this loop in a flowchart. Note
    how both the `while` and `if` conditions are marked by diamonds. This is because
    they represent decision points.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: The flowchart for the password while loop*'
  prefs: []
  type: TYPE_NORMAL
- en: Each execution of a loop is called an *iteration*. The `while` loop can iterate
    *indefinitely* because the number of loops isn’t explicitly specified at the start.
    A `while` loop can run a million times or end after the first iteration depending
    on whether its condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your program is ever caught in an infinite loop, you can use CTRL-C to
    stop the program and escape.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Each new code block should be indented _____ spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '2.  True or false: The `or` operator evaluates an expression to `True` only
    if *both* Boolean values are `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Write a `while` loop that never ends, and then stop it using CTRL-C.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Which values can be used to represent `False`?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `0`
  prefs: []
  type: TYPE_NORMAL
- en: b.  0.0
  prefs: []
  type: TYPE_NORMAL
- en: c.  F
  prefs: []
  type: TYPE_NORMAL
- en: d.  All the above
  prefs: []
  type: TYPE_NORMAL
- en: 5.  To form Pig Latin, one takes an English word that begins with a consonant,
    moves the consonant to the end, and adds “ay” after it. If the word begins with
    a vowel, one simply adds “way” to the end. Use the Spyder text editor to write
    a program that takes a word as input and uses indexing and slicing to return its
    Pig Latin equivalent. Keep the program running until the user decides to quit.
  prefs: []
  type: TYPE_NORMAL
- en: '***The for Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for` statement lets you execute a loop a set number of times. This number
    is often specified using the built-in `range()` function. This memory-efficient
    function returns a sequence of evenly spaced numbers starting from 0 (by default)
    and ending before a specified endpoint. Here’s what the `range()` function’s syntax
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `start` and `step` parameters are optional. If omitted, the `start` parameter
    defaults to `0`, and the `step` defaults to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example where a `for` loop uses `range()` to print five numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that `5` is not included in the output. This is because the function reads
    *up to* the stop value but doesn’t include it. The block beneath the `for` statement
    is indented, just as in a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example using all three arguments (`start`, `stop`, `step`) in `range()`
    to print every other number from 1 to 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `i` in the previous code is used by convention when iterating
    over a range of numbers. Any legal variable name (such as `num` or `number`) will
    work. An underscore (`_`) is preferred if you’re using a linter to check your
    code; other names can sometimes trigger an `unused variable` warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `range()`in conjunction with the `len()` function to obtain the
    endpoint for an arbitrarily sized sequence. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code starts by assigning a list of letters to the `my_list` variable. In
    the following `if` statement, passing the `range()` function the length of this
    list, as determined by the `len()` function, sets the number of iterations. With
    each iteration, the current value of `i` is used as an index for the list, and
    the corresponding letter is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it works, this code isn’t very Pythonic. Fortunately, you can use
    iterables directly in the `for` statement. Remember, iterables are objects that
    can return their items one at a time. These include sequence types like range,
    list, tuple, string, set, and more. As a result, you don’t need to keep track
    of the iterable’s size or use a running index. Here’s the previous snippet in
    this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the code reads almost like English. You can’t get more Pythonic than
    that!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Never add or delete items to a list while looping over it. If you want to
    change a list during a loop, append the changes to a new list.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even loop over a string and print its characters without using an intermediate
    variable to hold the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event that you need an item’s index during looping, the best solution
    is to use the built-in `enumerate()` function. This function adds a counter to
    each item of an iterable object and returns an *enumerate* object, allowing you
    to loop over an iterable and keep track of the number of iterations. The first
    index value starts from 0 by default, but you can override that by specifying
    a starting index. The following example produces a numbered list of items (starting
    at 1) from a `list` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Some other uses for `enumerate()` include selecting every *n* items from a list,
    ending a loop after *n* items, and using the indexes for line weights or symbol
    sizes when plotting.
  prefs: []
  type: TYPE_NORMAL
- en: '***Loop Control Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Loop control statements* are used inside loops to change the normal sequence
    of execution. Earlier, you used a `break` statement to interrupt and end a `while`
    loop. Python also uses `continue` and `pass` statements to control loops.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The break Statement**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `break` keyword lets you exit a loop’s code block at any time. A common
    usage is to set `while` to `True` (`while True:`) and then “manually” break out
    of the loop when a condition is met. Because `True` always evaluates to true,
    no condition can stop the loop, so you must force the issue using `break`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In nested loops, `break` terminates only the block it’s in, along with any
    inner blocks. Outer loops will continue to run. For example, the following example
    contains two nested loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `break` statement interrupted the inner `for` loop and prevented
    “Jamie” from printing, the outer loop ran to completion.
  prefs: []
  type: TYPE_NORMAL
- en: '**The continue Statement**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `continue` keyword immediately returns control to the beginning of a loop,
    skipping any loop clauses beneath it. For instance, the following example uses
    a `while` loop to evaluate a user’s name and password. Enter the code in the Jupyter
    Qt console and then run it using SHIFT-ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first step, of course, is to get the correct username. If the condition
    for the first `if` statement evaluates to `True` (the name is *not* “Alice”),
    a `continue` statement interrupts the loop and restarts the sequence ➊. If the
    name passes the test, the `continue` statement is skipped, and the user is prompted
    for a password ➋. If they enter the correct value, a `break` statement ends the
    loop ➌. Otherwise, they’re alerted to the error, and the loop begins again.
  prefs: []
  type: TYPE_NORMAL
- en: '**The pass Statement**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use the `pass` keyword to build “empty” loops, or blocks that take
    no action. These keywords serve as placeholders for future code or flag places
    where you intentionally omitted something. Take this snippet, for example, in
    which we choose to not print the `h` in `Python`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code assigns “Python” to the `word` variable, and 0 to the `count` variable.
    While the `count` value is less than the length of `word`, the loop prints each
    character in `word` indexed at the current `count` value. If `count` is equal
    to `3`, however, it uses the `pass` keyword to continue the loop with no action.
  prefs: []
  type: TYPE_NORMAL
- en: You could have accomplished the same thing by only printing `count < 3` and
    `count > 3`, but this could be viewed in retrospect as an indexing mistake (see
    the earlier core temperature example at lines `In [10]-[11]`). By including the
    reference to `h` and using `pass` ➊, it’s clear that you knew what you were doing.
    You basically said, “I know there’s a letter at this index and I’m not printing
    it on purpose.”
  prefs: []
  type: TYPE_NORMAL
- en: '***Replacing Loops with Comprehensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Python, a *comprehension* is a way to construct a new sequence such as a
    list, set, or dictionary from an existing sequence. For example, you might want
    to create a new list containing the logarithms of the numbers in another list.
    As a replacement for standard `for` loops, comprehensions are faster, more elegant,
    and more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'A downside to comprehensions is that you can’t embed a `print()` function in
    the loop to help you track what’s happening. They can also be quite difficult
    to read when using complicated expressions, but for simple expressions, they can’t
    be beat. Python supports comprehensions for lists, dictionaries, sets, and something
    we’ll talk about in the next chapter: generators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To make a new list using *list comprehension*, encase the comprehension expression
    in square brackets. To use a condition to choose items from an existing iterable,
    use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this syntax if you want to alter these items, or generate new items, before
    adding them to the new list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, here’s an example that takes a string, loops through it, capitalizes
    each letter, and appends the capital letter to a new list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assigned a string to the `word` variable, and then we created the `letters`
    list using the list comprehension `[letter.upper() for letter in word]`. Notice
    how the syntax is a little backward, as the loop variable (`letter`) appears before
    it’s defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example extracts the capital “P” from “Python.” Notice how you
    can use an `if` statement within the comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The single-line list comprehension in line `In [57]` is equivalent to the following
    code using a standard `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this case, list comprehension saved you three lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can create list comprehensions using nested `for` loops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see more examples of list comprehensions at *[https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary Comprehensions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Dictionary comprehensions* are like list comprehensions, except they use key-value
    (k, v) pairs in place of items, are enclosed in curly brackets, and return a dictionary
    rather than a list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use dictionary comprehensions on existing dictionaries, in which case
    you either choose key-value (k, v) pairs from the existing dictionary based on
    some condition, or you use an expression on the keys and/or values based on a
    condition. The general syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When using dictionary comprehension on another type of iterable, like a list,
    you choose and/or change existing items in the iterable to serve as key-value
    pairs in the new dictionary. The syntax is varied, but looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that the expression can alter the item used for the key, for the value
    or for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example in which we extract even numbers from a list and map them
    to their square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we zip two tuples (the `mineral` and `hardness` variables) together
    to create part of Moh’s famous mineral hardness scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you also can generate the `mohs` dictionary by calling the built-in
    `dict()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Set Comprehensions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Set comprehensions* are enclosed in curly brackets and return unsorted sets.
    You can *choose* existing items from an iterable using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can alter the items or derive new items by applying a condition-based
    expression before adding the item to the new set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example that returns all the unique characters in a string, given
    that sets don’t allow duplicate values (this is the same as the `set()` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we use an expression to calculate word lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Handling Exceptions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *exception* occurs when Python encounters an error during execution. This
    causes it to “raise an exception” and produce a Python object that represents
    an error. If not dealt with immediately, exceptions cause a program to terminate
    and display an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, exceptions can be “caught” and handled through flow control. This
    gives you the opportunity to fix the problem, try again, supply a more helpful
    error message, or suppress the error.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using try and except***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python provides a `try` statement with an `except` clause to help you handle
    exceptions. The `try` statement lets you isolate code that could potentially contain
    an error and crash your program. If the code contains an error, the `except` clause
    will deal with it by providing code that executes only when an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest exception handling merely prevents your program from crashing
    unceremoniously. It presents an alert and (hopefully) a helpful message. Here
    is an example that’s designed to handle incorrect input from a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `age` value is converted to an integer, as we want `age`
    to be a whole number in years. But the user entered letters instead (`Harry`),
    which raised a `ValueError` exception because letters can’t be converted into
    integers. You don’t see this error message, however, as we caught the exception
    using the `try` statement, which does just what it says. It tries the code in
    isolation, giving us the opportunity to do something before the program crashes.
    Here, we printed a message to the user so that the program ends somewhat gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you want to specify the type of exception to handle rather than
    catch all of the built-in exceptions, as we did in the previous snippet. You can
    find a list of exception types on [Table 7-4](ch07.xhtml#ch07tab4) on [page 183](ch07.xhtml#ch07tab4).
    You can also create the error you’re looking for in the console and read off the
    exception name from the resulting `Traceback` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the previous snippet to catch a `ValueError`. Just place the
    proper exception name after `except`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also trap for multiple exception types by placing them after `except`
    as a tuple with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use a different message or take a different action with each
    error type, simply use multiple stacked `except` clauses within a `try` statement,
    in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also incorporate Python’s error messages into your own customized versions.
    Exceptions have *arguments*, which are official messages from Python describing
    what happened. You can use an argument by specifying a variable after the exception
    type, preceded by the keyword `as`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have the best of both worlds: Python’s precise but technical explanation
    combined with friendlier instructions for non-programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can add an `else` clause at the end of all the `except` clauses.
    This lets you do something, like confirm a successful operation, if no exceptions
    are raised elsewhere in the `try` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '***Forcing Exceptions with the raise Keyword***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python’s `raise` keyword allows you to force a specified exception if a condition
    occurs. You can use it to raise built-in error types or your own custom errors.
    It’s especially useful for validating inputs such as enforcing the use of maximum
    values, or handling the input of a negative number when you’re working with positive
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to create your own custom error, enter the following in Spyder’s
    text editor and save it with any name you please:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, you accept a name from the user, convert it to lowercase, and compare
    it to “potter.” If the name doesn’t match, you use the `raise` keyword and call
    the `Exception` class, passing it a custom message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the file and input “Houdini” when prompted. You should see this general
    output in the console (truncated for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To force Python to raise one of its built-in exceptions, substitute the name
    of the built-in exception class (see [Table 7-4](ch07.xhtml#ch07tab4)) for the
    `Exception` class you used previously. In this example, we raise Python’s built-in
    `TypeError` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about `raise` at *[https://docs.python.org/3/tutorial/errors.html](https://docs.python.org/3/tutorial/errors.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ignoring Errors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if you want to ignore errors while looping? For example, suppose that
    you’ve used Python’s `None` keyword to define missing or null sample values in
    your dataset (`data`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t want to strip this placeholder out of the dataset, because it contains
    valuable information. It lets you know that the dataset is incomplete as well
    as the location of the missing data. But if you try to iterate over the data and
    do something to it such as divide each value by 2, the `None` value will raise
    a `TypeError` and crash the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine multiple flow control elements to handle this missing data.
    Here, we use a `try` statement with an `except` clause within the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, the loop runs to completion and flags where data is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if you want to completely skip over the missing data? For example,
    you want to pass the output to some other mathematical operation where the “missing
    data” values would interfere? In this case, use the `continue` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The loop now treats the missing value as if it doesn’t exist because it continues
    the loop when it encounters the value. Remember, `continue` immediately returns
    control to the beginning of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracing Execution with Logging**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To control the flow of your program, you need to know what it’s returning at
    key locations. One way to keep track of this is to use the `print()` function.
    This lets you print the output, the data type of a variable, or some other useful
    information about an important step.
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` function works well for small programs, but if you’re using it
    only to quality-control your code, it can come with a price. To unclutter your
    code and output, you might need to go back later and either delete all the lines
    containing `print()` or comment them out (by placing a `#` at the start of the
    line) so that they don’t run.
  prefs: []
  type: TYPE_NORMAL
- en: For large programs, a better choice is to use the `logging` module. This module
    is part of the standard library that ships with Python, and it can provide a customized
    report on what your program is doing at any location you choose. Five *logging
    levels* let you categorize messages by importance. These are listed in [Table
    10-3](ch10.xhtml#ch010tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-3:** Python’s Logging Levels'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| DEBUG | `logging.debug()` | Detailed information for diagnosing problems
    |'
  prefs: []
  type: TYPE_TB
- en: '| INFO | `logging.info()` | Confirmation that things are working as expected
    |'
  prefs: []
  type: TYPE_TB
- en: '| WARNING | `logging.warning()` | Unexpected event or potential future problem
    in working code |'
  prefs: []
  type: TYPE_TB
- en: '| ERROR | `logging.error()` | An error prevented the code from functioning
    as intended |'
  prefs: []
  type: TYPE_TB
- en: '| CRITICAL | `logging.critical()` | A serious error that may halt the program
    |'
  prefs: []
  type: TYPE_TB
- en: 'Large programs that require logged messages are difficult to write in a console,
    so enter the following example in Spyder’s text editor and save it with a name
    like *logging.py*. This code uses `logging` to check that a vowel-counting program
    is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and press F5 (or click the **Run** button) to execute the code.
    You should see this general output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at what you did. After importing the module, you used the `basicConfig()`
    method to set up and format the debugging information you wanted to see ➊. The
    `DEBUG` level is the lowest level of information and is used for diagnosing details.
    Adding a timestamp (`%(asctime)s`) is not necessary here, but it can become important
    when debugging long-running programs.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the word to count, a constant for vowels, and a count variable,
    you started a `for` loop through the letters in the word and compared each to
    the contents of `VOWELS`. If the letter matched, you incremented the `num_vowels`
    counter by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: For each letter evaluated, you used `logging.debug()` to enter the custom text
    message to display along with the current count ➋. The `logging` output displayed
    in the console. You can see the timestamp, the logging level, and the cumulative
    vowel count, along with which letters changed the count. In this case, only vowels
    change the count, so the program appears to be working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can redirect the logged messages to a permanent *text file* rather than
    displaying them on the screen. Just use the `filename` keyword in the `logging.basicConfig()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As written, this code will save the log file to the same folder as your Python
    file. To save it elsewhere, you’ll need to specify a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `print()` function and `logging` can slow down your program. It’s
    easier to disable the `logging` messages, however. With the `logging.disable()`
    function, you can turn off all the messages for a certain level with one line
    of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Placing `logging.disable()` near the top of the program, just below the import
    statement, allows you to find it easily and toggle messages on and off by commenting
    them out with a hash mark, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `logging.disable()` method will suppress all messages at the designated
    level and lower. Because `CRITICAL` is the highest level, you can use it to disable
    messages at every level. This is much easier than finding and deleting (or commenting-out)
    multiple calls to `print()`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the `logging` module, check out the documentation at *[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)*.
    For a basic tutorial, visit *[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Write a code snippet that asks a user for a username and password. If the
    username is incorrect, keep asking until the user gets it right. If only the password
    is incorrect, keep asking for the correct password but don’t repeat the username
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  The `for` loop is just a concise version of a `while` loop. Write a `while`
    loop that behaves like a `for` loop and prints the word “Python” five times.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Use list comprehension to make a list of all the *even* numbers between
    1 and 10.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Use a `for` loop with the `range()` function to print a NASA-style countdown
    from 10 to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '10.  A secret message is hidden at the center of each of the following words:
    “age,” “moody,” “knock,” “adder,” “project,” “stoop,” “blubber.” Use a `for` loop
    to find and print the message.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Use the text editor to write a “guess my number” game that randomly chooses
    an integer between 1 and 100 (using `random.randint()`) and tells the player whether
    their answer is too high or too low until they guess correctly. Inform the player
    when they win and show them how many tries it took.
  prefs: []
  type: TYPE_NORMAL
- en: '12.  Use the text editor to write a “fortune cookie” program that presents
    the user with a menu of three options: Quit, Open a Fortune Cookie, or Open a
    Misfortune Cookie. Make a list of positive fortunes and a list of funny “misfortunes”
    and use the `random` module’s `choice()` function to randomly choose from each
    list. Print the results to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The magic of programming lies in the ability of programs to make decisions during
    execution. These decisions are facilitated by conditions that evaluate to `True`
    or `False`. Using comparison and Boolean operators with *conditional statements*
    like `if`, `elif`, and `else`, you can control what your code does and when it
    does it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Indentation* (whitespace) is used to segregate code into functionally similar
    segments, called *blocks*. Indentation levels let Python know when blocks start
    and end. This, in turn, helps you control the flow of execution through a program.'
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop causes code to execute over and over until a certain condition
    is met. The `for` loop, on the other hand, runs for a designated number of times
    or until it exhausts the items in a container data type, such as a list. Both
    types of loops can be manually interrupted with the `break` statement or forced
    to jump back to the start using the `continue` statement.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop can be simplified into a single line of code using *comprehensions*.
    You can use these with lists, sets, and dictionaries. For simple expressions,
    comprehensions are not only more concise than `for` loops, they’re faster, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Because errors can affect the flow of your code, Python provides `try` statements
    with `except` clauses to help you handle errors by suppressing them, fixing them,
    creating customized error messages, or getting a user to try again. To help you
    find and debug errors and other issues, Python provides the `logging` module.
    Compared to the `print()` function, `logging` is a more sophisticated and manageable
    way to monitor the flow of execution of large programs.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to control flow is to write functions. We’ll look at these important
    “mini-programs” in the next chapter.
  prefs: []
  type: TYPE_NORMAL
