- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Object-Oriented Programming and PVector
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程与PVector
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Object-oriented programming* *(OOP)* deals with data structures known as *objects*.
    You create new objects from a class, and you can think of a class as an object
    template, composed of a collection of related functions and variables. You define
    a class for each category of objects you want to work with, and each new object
    will automatically adopt the features you define in its class. OOP combines everything
    you’ve learned so far, including variables, conditional statements, lists, dictionaries,
    and functions. OOP adds a remarkably effective way to organize your programs by
    modeling real-world objects.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程*（*OOP*）处理的数据结构被称为*对象*。你从类中创建新的对象，可以把类看作是一个对象模板，包含了一组相关的函数和变量。你为每一类想要处理的对象定义一个类，每个新对象都会自动采用你在类中定义的特性。OOP结合了你迄今为止学到的所有内容，包括变量、条件语句、列表、字典和函数。OOP提供了一种非常有效的方式，通过模拟现实世界的物体来组织你的程序。'
- en: You can use classes to model tangible objects, like buildings, people, cats,
    and cars. Or, you can use them to model more abstract things, like bank accounts,
    personalities, and physical forces. Although a class will define the general features
    of a category of objects, you can assign unique attributes to differentiate each
    object you create. In this chapter, you’ll apply OOP techniques to program an
    amoeba simulation. You’ll learn how to define an amoeba class, and how to “spawn”
    varied amoeba from it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类来建模有形物体，如建筑物、人物、猫和汽车。或者，你可以用它们来建模更抽象的事物，如银行账户、个性和物理力量。虽然类定义了某类对象的通用特征，但你可以为每个创建的对象分配独特的属性以加以区分。在本章中，你将应用面向对象编程（OOP）技术来编写变形虫模拟程序。你将学习如何定义变形虫类，以及如何从中“生成”不同的变形虫。
- en: You’ll program amoeba movement by simulating physical forces. For this, you’ll
    use a built-in Processing class named `PVector`. The `PVector` class is an implementation
    of *Euclidean vectors* that includes a suite of methods for performing mathematical
    operations, which you’ll use to calculate the position and movement of each amoeba.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过模拟物理力量来编程变形虫的运动。为此，你将使用一个名为`PVector`的内置Processing类。`PVector`类是*欧几里得向量*的实现，包括一套用于执行数学运算的方法，你将使用这些方法来计算每个变形虫的位置和运动。
- en: To better manage your code, you’ll learn how to split your program into multiple
    files. You can then switch between the files that make up your sketch by using
    tabs in the Processing editor.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地管理代码，你将学习如何将程序拆分成多个文件。然后，你可以通过在Processing编辑器中使用标签在构成草图的文件之间切换。
- en: Working with Classes
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类
- en: A *class* is like a blueprint for an object. As an example, consider a `Car`
    class that might specify, by default, that all cars have four wheels, a windshield,
    and so on. Certain features, like the paint color, can vary among individual cars,
    so when you create a new car object by using the `Car` class, you get to select
    a color. Such features are called *attributes*. In Python, attributes are variables
    that belong to a class. You can decide which attributes have predefined values
    (the four wheels and windshield) and which are assigned when you create a new
    car (the paint color).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*就像是对象的蓝图。例如，考虑一个`Car`类，它可能默认指定所有汽车都有四个轮子、一个挡风玻璃，等等。某些特征，比如油漆颜色，在不同的汽车之间是可以变化的，所以当你使用`Car`类创建一个新的汽车对象时，你可以选择一个颜色。这些特征被称为*属性*。在Python中，属性是属于类的变量。你可以决定哪些属性有预定义的值（如四个轮子和挡风玻璃），哪些是在创建新车时分配的（如油漆颜色）。'
- en: In this way, you can create multiple cars, each a different color, using a single
    class. [Figure 10-1](#figure10-1) illustrates this concept. The `Car` class includes
    attributes to describe the paint color, engine type, and model of each car.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以使用单一类创建多辆不同颜色的汽车。[图10-1](#figure10-1)说明了这一概念。`Car`类包括描述每辆车的油漆颜色、引擎类型和型号的属性。
- en: '![f10001](image_fi/500969c10/f10001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](image_fi/500969c10/f10001.png)'
- en: 'Figure 10-1: The `Car` class serves as a blueprint for car objects.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：`Car`类作为汽车对象的蓝图。
- en: Drivers control a vehicle by steering, accelerating, and braking. So in addition
    to attributes, your `Car` class can include definitions for performing those actions,
    referred to as *methods*. In Python, methods are functions that belong to a class
    that define the operations or activities it can perform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶员通过转向、加速和刹车来控制车辆。因此，除了属性外，你的`Car`类还可以包含执行这些操作的定义，称为*方法*。在Python中，方法是属于某个类的函数，定义了该类可以执行的操作或活动。
- en: Now, let’s define an `Amoeba` class that includes a set of attributes and methods
    for controlling the appearance and behavior of amoeba objects. You’ll use that
    class to create many amoebas. [Figure 10-2](#figure10-2) depicts the final result
    of the amoeba simulation that you’re working toward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个包含一组属性和方法的`Amoeba`类，用于控制变形虫对象的外观和行为。你将使用该类创建许多变形虫。[图 10-2](#figure10-2)展示了你正在努力实现的变形虫模拟的最终结果。
- en: '![f10002](image_fi/500969c10/f10002.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![f10002](image_fi/500969c10/f10002.png)'
- en: 'Figure 10-2: A screenshot of the complete amoeba simulation'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：完整变形虫模拟的截图
- en: The amoebas will wobble and distort as they move about the display window. This
    is not a scientifically correct representation of amoebas, but it should look
    pretty cool. As an extra challenge, you’ll add collision-detection code to prevent
    them from passing over or through one another. You’ll begin with a basic `Amoeba`
    class definition, and then add attributes and methods as you progress through
    the task.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 变形虫在显示窗口中移动时会摇摆和扭曲。这并不是科学上正确的变形虫表现形式，但它应该看起来非常酷。作为额外的挑战，你将添加碰撞检测代码，防止变形虫互相穿越或重叠。你将从一个基本的`Amoeba`类定义开始，然后随着任务的进展添加属性和方法。
- en: Defining a New Class
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个新类
- en: In Python, you define a class by using the `class` keyword. You may name a class
    whatever you like, but as with variable and function names, you’re limited to
    alphanumeric and underscore characters. Because you cannot use space characters,
    the recommended naming convention for classes is *UpperCamelCase*, in which the
    first letter of each word begins with a capital letter, starting with the first
    word.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你通过使用`class`关键字来定义一个类。你可以随意给类命名，但和变量和函数名一样，类名只能使用字母数字和下划线字符。由于不能使用空格字符，推荐的类命名约定是*UpperCamelCase*，即每个单词的首字母都大写，从第一个单词开始。
- en: 'To begin, your `Amoeba` class won’t do much else than print a line to the console.
    Start a new sketch and save it as *microscopic*. Define a new `Amoeba` class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，你的`Amoeba`类除了在控制台打印一行外，什么也不会做。开始一个新草图并将其保存为*microscopic*。定义一个新的`Amoeba`类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `class` keyword defines a new class. Here the class name is `Amoeba`, and
    it’s followed by `object` in parentheses, and a colon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`关键字定义了一个新类。这里类名是`Amoeba`，后面跟着`object`，并用括号括起来，最后是冒号。'
- en: If you run the sketch, nothing interesting should happen, and the console will
    be empty.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个草图，什么有趣的事情都不会发生，控制台将是空的。
- en: Functions that you define within the body of a class are referred to as *methods*.
    The `Amoeba` class includes a definition for a special method named `__init__`
    (with two underscores at either end). This method is one of a selection of *magic
    methods* that start and end with two underscores that you won’t invoke directly.
    I’ll get into more detail about the `__init__()` method (and the `self` parameter)
    soon. For now, all you need to know is that Python runs the `__init__()` method
    automatically for each new amoeba you create. You use this method to set up your
    attributes and execute code at the time of object creation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你在类体内定义的函数称为*方法*。`Amoeba`类包括一个特殊方法的定义，名为`__init__`（前后都有两个下划线）。这个方法是一些*魔法方法*中的一个，它们前后都有两个下划线，你不会直接调用它们。我稍后会详细讲解`__init__()`方法（以及`self`参数）。目前，你只需要知道的是，Python会在每次创建新变形虫时自动运行`__init__()`方法。你使用这个方法在对象创建时设置属性并执行代码。
- en: Creating an Instance from a Class
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从类中创建实例
- en: To *instantiate* an amoeba, you call the `Amoeba` class by name and assign it
    to a variable—as you would a function that returns a value. *Instantiate* is a
    fancy way of saying *create a new instance*, and an *instance* is synonymous with
    *object*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要*实例化*一个变形虫，你需要按名称调用`Amoeba`类，并将其赋值给一个变量——就像你调用返回值的函数一样。*实例化*是一个高级词汇，意思是*创建一个新实例*，而*实例*和*对象*是同义词。
- en: 'Add a line to create a new instance from your `Amoeba` class and assign it
    to a variable named `a1`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一行代码来从你的`Amoeba`类创建一个新实例，并将其赋值给名为`a1`的变量：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the sketch, Python creates a new `Amoeba()` instance. This will
    automatically invoke the `__init__()` method. You can use the `__init__()` method
    to define attributes and assign values to them, which you’ll do shortly. This
    method can also include other instructions to initialize the amoeba, as in this
    case, a `print()` function. When you run the sketch, the console should display
    a single `amoeba initialized` message.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，Python 会创建一个新的 `Amoeba()` 实例。这将自动调用 `__init__()` 方法。你可以使用 `__init__()`
    方法来定义属性并为其赋值，稍后你会这样做。这个方法也可以包含其他指令来初始化变形虫，例如在这个例子中使用 `print()` 函数。当你运行草图时，控制台应该显示一条
    `amoeba initialized` 消息。
- en: Adding Attributes to a Class
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向类添加属性
- en: You can think of attributes as variables that belong to an object. And just
    like a variable, an attribute can contain any data you like, including numbers,
    strings, lists, dictionaries, and even other objects. For example, a `Car` class
    might have a string attribute for the model name and an integer attribute for
    top speed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把属性看作是属于对象的变量。就像一个变量一样，属性可以包含你喜欢的任何数据，包括数字、字符串、列表、字典，甚至其他对象。例如，`Car` 类可能有一个字符串属性来表示车型名称，还有一个整数属性来表示最高车速。
- en: 'In your `Amoeba` class, you’ll add three attributes to hold numbers for an
    x-coordinate, y-coordinate, and diameter; you’ll assign values to those attributes
    when you instantiate the new amoeba. The syntax resembles that used to pass arguments
    to a function: the parentheses of the `__init__()` method contain your list of
    corresponding parameters.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `Amoeba` 类中，你将添加三个属性来存储 x 坐标、y 坐标和直径的数值；当你实例化新的变形虫时，你将为这些属性赋值。语法类似于传递参数给函数：`__init__()`
    方法的括号中包含了你对应的参数列表。
- en: 'Make the following changes to your code to accommodate an `x`, `y`, and `diameter`
    value for each new amoeba:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码做出以下更改，以便为每个新变形虫添加 `x`、`y` 和 `diameter` 值：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `__init__()` method already includes a parameter, `self`; this is required,
    and it’s always the first parameter. The `self` parameter provides access to instance-specific
    values, like an `x` value of `400` for amoeba `a1` (but more on how that works
    shortly). The `x`, `y`, and `diameter` are added as the second, third, and fourth
    parameters. I’ve added corresponding arguments to the `a1` line. Notice, however,
    that I provide only three arguments and nothing for the `self` parameter. [Figure
    10-3](#figure10-3) depicts how these positional arguments match up, starting from
    the second parameter in the `__init__()` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法已经包含一个参数 `self`；这是必须的，并且总是第一个参数。`self` 参数提供对特定实例值的访问，例如变形虫 `a1`
    的 `x` 值为 `400`（但如何工作稍后再讲）。`x`、`y` 和 `diameter` 被作为第二、第三和第四个参数添加。我在 `a1` 行中添加了相应的实参。然而，请注意，我只提供了三个实参，`self`
    参数没有提供任何值。[图 10-3](#figure10-3) 描述了这些位置参数如何匹配，从 `__init__()` 方法中的第二个参数开始。'
- en: '![f10003](image_fi/500969c10/f10003.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![f10003](image_fi/500969c10/f10003.png)'
- en: 'Figure 10-3: Don’t provide an argument for the `self` parameter.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：不要为 `self` 参数提供实参。
- en: You can also use keyword arguments (and specify default values for parameters),
    but I’ll stick to positional arguments throughout this task.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用关键字参数（并为参数指定默认值），但在这个任务中我将坚持使用位置参数。
- en: 'When you pass values to your `__init__()` method, it won’t automatically store
    them for you. For this, you need attributes, which are like variables for objects.
    Assign the `x`, `y`, and `diameter` parameters to new attributes. Each attribute
    begins with a prefix of `self`, followed by a dot, then the attribute name:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将值传递给 `__init__()` 方法时，它不会自动为你存储这些值。为此，你需要属性，它们就像是对象的变量。将 `x`、`y` 和 `diameter`
    参数分配给新的属性。每个属性都以 `self` 为前缀，后跟一个点，再加上属性名：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that you assign `diameter` to `self.d`. Your attribute names need not
    match your parameter names.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你将 `diameter` 分配给了 `self.d`。你的属性名称不必与参数名称相匹配。
- en: 'At this point, I can explain more about the `self` parameter. I’ve mentioned
    that `self` is an instance-specific reference. In other words, the `self.d` value
    of `100` belongs to amoeba `a1`. Each amoeba instance will possess its own set
    of `self.x`, `self.y`, and `self.d` values. For example, I might add another amoeba,
    `a3`, with different values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我可以更详细地解释 `self` 参数。我提到过，`self` 是一个特定实例的引用。换句话说，`self.d` 值为 `100` 属于变形虫
    `a1`。每个变形虫实例将拥有自己的一组 `self.x`、`self.y` 和 `self.d` 值。例如，我可能会添加另一个变形虫 `a3`，并赋予不同的值：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will come in handy later when you add multiple amoebas to the simulation.
    [Figure 10-4](#figure10-4) provides a conceptual diagram of your `Amoeba` class
    and three possible instances.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在稍后你向模拟中添加多个变形虫时派上用场。[图 10-4](#figure10-4) 提供了你的 `Amoeba` 类及其三个可能实例的概念图。
- en: Next, you’ll learn how to access the `x`, `y`, and `d` values for amoeba `a1`
    via the `a1` instance. You’ll use those values to draw the amoeba in the display
    window, resembling the one depicted in the upper right corner of [Figure 10-4](#figure10-4).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何通过 `a1` 实例访问变形虫 `a1` 的 `x`、`y` 和 `d` 值。你将使用这些值在显示窗口中绘制变形虫，类似于[图 10-4](#figure10-4)右上角所示的变形虫。
- en: '![f10004](image_fi/500969c10/f10004.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![f10004](image_fi/500969c10/f10004.png)'
- en: 'Figure 10-4: Your `A``moeba` class and three instances'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：你的 `Amoeba` 类及其三个实例
- en: Accessing Attributes
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问属性
- en: To access attributes, you use *dot notation*. For the `a1` instance, you can
    access the `x`, `y`, and `d` attributes as `a1.x`, `a1.y`, and `a1.d`, respectively.
    This is the instance name (`a1`) followed by a dot, followed by the name of the
    attribute you want to access.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问属性，你使用 *点表示法*。对于 `a1` 实例，你可以通过 `a1.x`、`a1.y` 和 `a1.d` 分别访问 `x`、`y` 和 `d`
    属性。这是实例名（`a1`）后跟一个点，再跟你想访问的属性名称。
- en: 'To get started, add this code to the end of your sketch, which draws a circle
    to represent amoeba `a1`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，向你的草图末尾添加以下代码，它绘制了一个圆形，表示变形虫 `a1`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The display window is now 800 pixels wide by 400 pixels high. The high frame
    rate of 120 will help smooth the wobble animation you’ll add to your amoeba later.
    A *cell membrane* separates an amoeba’s interior from its outside environment,
    and here, I’ve given this a white stroke. The fill is a semi-opaque pale blue.
    For the x-coordinate (first argument) in the `circle()` function, Python checks
    the `a1` instance for the attribute `self.x`—in this case, it’s equal to 400;
    the y-coordinate argument is equal to `200`, and the diameter argument is equal
    to `100`. The result ([Figure 10-5](#figure10-5)) is a circle with a diameter
    of 100 pixels positioned in the center of the display window.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显示窗口的宽度为 800 像素，高度为 400 像素。120 的高帧率将有助于平滑你稍后添加到变形虫中的抖动动画。*细胞膜*将变形虫的内部与外部环境分隔开，我在这里为它设置了一个白色的描边。填充颜色是半透明的浅蓝色。在
    `circle()` 函数中的 x 坐标（第一个参数），Python 会检查 `a1` 实例的属性 `self.x` —— 在这个例子中，它的值为 400；y
    坐标的参数值为 `200`，直径参数的值为 `100`。结果（[图 10-5](#figure10-5)）是一个直径为 100 像素的圆形，位于显示窗口的中心。
- en: '![f10005](image_fi/500969c10/f10005.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![f10005](image_fi/500969c10/f10005.png)'
- en: 'Figure 10-5: A circle (rudimentary amoeba) with a diameter of 100 pixels'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：直径为 100 像素的圆形（基础变形虫）
- en: So far, you’ve learned how to add arguments to your `Amoeba` class, which you
    assign to attributes when you instantiate an amoeba. In addition to those, your
    class can include attributes with predefined values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何为 `Amoeba` 类添加参数，当你实例化变形虫时将其赋值给属性。除了这些参数外，你的类还可以包含具有预定义值的属性。
- en: Adding an Attribute with a Default Value
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个具有默认值的属性
- en: Think back to the car analogy. Every car rolls off the production line with
    an empty gas tank. The manufacturer may fill it before it’s sold, but the tank
    always starts empty. For this, you decide to add an attribute to the `Car` class—let’s
    call it `self.fuel`. It has a predefined value of 0 for each new car object, but
    it’ll fluctuate over the lifetime of the vehicle. It’s redundant to specify by
    way of an argument that this should start at 0; instead, the `Car` class should
    automatically initialize the `fuel` attribute for you, setting it to 0 by default.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想想汽车的类比。每辆车从生产线下来时油箱是空的。制造商可能在出售前加油，但油箱总是从空开始。为此，你决定为 `Car` 类添加一个属性——我们称之为 `self.fuel`。每个新车对象的默认值为
    0，但它将在车辆的使用过程中变化。通过参数指定从 0 开始是多余的；相反，`Car` 类应该自动为你初始化 `fuel` 属性，默认为 0。
- en: 'Let’s return to the amoeba task. Every amoeba will include a nucleus with a
    predefined fill of red. To program this, assign a hexadecimal value (`#FF0000`)
    to an attribute named `nucleus` within the body of your `__init__()` method. There’s
    no need to add another parameter to your `__init__()` definition, because you
    don’t require the additional argument to specify the red fill:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到变形虫的任务。每个变形虫都会包含一个预定义的红色填充的细胞核。要实现这一点，在 `__init__()` 方法的函数体内为一个名为 `nucleus`
    的属性分配一个十六进制值（`#FF0000`）。你不需要在 `__init__()` 定义中添加另一个参数，因为你不需要额外的参数来指定红色填充：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, every amoeba you create has a `nucleus` attribute assigned a value of `#FF0000`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你创建的每个变形虫都有一个`nucleus`属性，值为`#FF0000`。
- en: 'Insert three new lines in your `draw()` function to render the nucleus beneath
    the cell membrane:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`draw()`函数中插入三行新代码，以便在细胞膜下渲染细胞核：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new lines set the fill and stroke, and then draw the nucleus by using a
    `circle()` function with a diameter that’s 2.5 times smaller (`a1.d/2.5`) than
    that of the cell membrane, placing it in the center of the amoeba. Run the sketch
    to confirm that you see a mauve nucleus; it is technically red, but you see it
    through the pale blue, semi-opaque membrane.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行设置了填充色和描边，并通过使用`circle()`函数绘制细胞核，直径是细胞膜的2.5倍小（`a1.d/2.5`），并将其置于变形虫的中心。运行草图确认你看到的是紫褐色的细胞核；它实际上是红色的，但你透过淡蓝色的半透明膜看到它。
- en: You don’t set the nucleus fill when you instantiate the amoeba, but that doesn’t
    mean you’re stuck with a red nucleus. You can modify the attribute values after
    you’ve created an amoeba.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化变形虫时，并不设置细胞核的填充色，但这并不意味着你只能使用红色细胞核。你可以在创建变形虫后修改属性值。
- en: Modifying an Attribute Value
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改属性值
- en: Many attributes hold values that change as your program runs. To return to the
    car analogy, consider the `fuel` attribute mentioned previously with a value that’s
    continually shifting as the gas tank fluctuates between full and empty. You can
    modify the value of any attribute directly via the instance by using the same
    dot syntax for accessing values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 许多属性保存的值会随着程序的运行而改变。为了回到汽车的比喻，考虑前面提到的`fuel`属性，它的值会随着油箱在满与空之间的波动不断变化。你可以通过实例使用相同的点语法直接修改任何属性的值。
- en: 'Insert a line to change the nucleus fill for amoeba instance `a1`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一行代码来改变变形虫实例`a1`的细胞核填充色：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sets the `nucleus` attribute to green, overwriting the default value of
    red. Run the sketch to confirm that you see a green nucleus showing through the
    semi-opaque membrane.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`nucleus`属性设置为绿色，覆盖了默认的红色值。运行草图确认你能看到一个绿色的细胞核穿透半透明膜。
- en: You can also modify an attribute by using a method, which I cover in “Adding
    Methods to a Class” on page 216.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用方法来修改属性，这部分我将在《为类添加方法》（第216页）中介绍。
- en: Using a Dictionary for an Attribute
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用字典来表示属性
- en: Recall that attributes can contain anything you like—numbers, strings, lists,
    dictionaries, objects, and so on. You’ll use a dictionary attribute that holds
    a mix of string (hexadecimal) and floating-point values to group the nucleus properties.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，属性可以包含任何你喜欢的内容——数字、字符串、列表、字典、对象等等。你将使用一个字典属性，该字典包含字符串（十六进制）和浮点值的混合，用于组织细胞核的属性。
- en: 'Change your `nucleus` attribute to a dictionary that holds key-value pairs
    for a nucleus fill, x-coordinate, y-coordinate, and diameter. To vary the appearance
    of each amoeba, randomize those values:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的`nucleus`属性更改为一个字典，该字典包含细胞核填充色、x坐标、y坐标和直径的键值对。为了使每个变形虫的外观有所不同，可以随机化这些值：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fill` key is paired with a hexadecimal value arbitrarily selected from
    a list of five colors. The nucleus color of each new amoeba is now chosen at random
    (although you may explicitly overwrite it afterward). The `x` and `y` keys are
    assigned randomized values proportional to the diameter of the cell membrane;
    you’ll use those to position the nucleus somewhere within the boundary of the
    cell membrane, but not necessarily in the center. The diameter of the nucleus
    (`d`) is also proportional to the cell membrane and randomly varies for each instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill`键与一个从五种颜色中随机选取的十六进制值配对。现在每个新变形虫的细胞核颜色是随机选择的（尽管你之后可能会明确地覆盖它）。`x`和`y`键被赋予与细胞膜直径成比例的随机值；你将用这些值来定位细胞核在细胞膜的边界内，但不一定是中心位置。细胞核的直径（`d`）也与细胞膜成比例，并且每个实例的值是随机变化的。'
- en: 'Update your `draw()` code to work with these changes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的`draw()`代码，以便处理这些更改：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `fill()` and `circle()` arguments reference the relevant dictionary keys
    to style and position the nucleus.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()`和`circle()`参数引用相关字典键，以样式和定位细胞核。'
- en: Each time you run the sketch, Processing will generate a unique amoeba. [Figure
    10-6](#figure10-6) depicts four results from four runs. Of course, it’s possible
    (but unlikely) that Processing will produce the same or a similar selection of
    randomized values, and consecutive results might appear identical.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行草图时，Processing都会生成一个独特的变形虫。[图 10-6](#figure10-6)展示了四次运行的四个结果。当然，Processing生成相同或相似的随机值组合是可能的（尽管不太可能），连续的结果可能看起来是一样的。
- en: '![f10006](image_fi/500969c10/f10006.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![f10006](image_fi/500969c10/f10006.png)'
- en: 'Figure 10-6: Each amoeba is generated using randomized nucleus values.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：每个变形虫都是通过随机化的细胞核值生成的。
- en: Now that you’ve set up the attributes to control the visual appearance of your
    amoeba, the next step is to add methods to animate it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了控制变形虫视觉外观的属性，下一步是添加方法来动画化它。
- en: Adding Methods to a Class
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向类添加方法
- en: Functions that you define within the body of a class are referred to as *methods*.
    To return to the car analogy, drivers can control a vehicle by using methods,
    such as steering, accelerating, and braking. You could also include a method for
    refueling. Methods typically perform operations by using an object’s attributes.
    For example, an `accelerate()` and `refuel()` method will subtract from and add
    to a `fuel` attribute.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你在类体内定义的函数被称为*方法*。用车的比喻来说，驾驶员可以通过使用方法来控制车辆，例如转向、加速和刹车。你还可以添加一个加油的方法。方法通常通过使用对象的属性来执行操作。例如，`accelerate()`
    和 `refuel()` 方法会分别减少或增加 `fuel` 属性的值。
- en: You can name methods whatever you like, as long as you apply the same naming
    rules and conventions for functions. In other words, use only alphanumeric and
    underscore characters, camelCase or underscores instead of spaces, and so forth.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以任意命名方法，只要遵循与函数相同的命名规则和约定。换句话说，只使用字母数字和下划线字符，使用驼峰命名法或下划线替代空格，等等。
- en: 'You’ll create a new method to draw your amoeba for each frame. Currently, several
    lines in the `draw()` section of your code handle this operation. Move the nucleus
    and cell membrane code from the `draw()` function into the body of a new `display()`
    method, ensuring that your indentation is correct. Replace every `a1` prefix with
    `self` in the `display()` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为每一帧创建一个新方法来绘制变形虫。目前，代码中 `draw()` 部分的几行代码正在处理此操作。将细胞核和细胞膜的代码从 `draw()` 函数移到新创建的
    `display()` 方法的主体中，确保你的缩进正确。在 `display()` 方法中，将每个 `a1` 前缀替换为 `self`：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `self` parameter in the definition 1 provides the body of your `display()`
    method with access to your attributes, such as `self.nucleus` and `self.x`. The
    `display()` method accepts zero arguments, so the definition includes no further
    parameters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的 `self` 参数为你的 `display()` 方法提供了访问属性的能力，例如 `self.nucleus` 和 `self.x`。`display()`
    方法不接受任何参数，因此定义中没有其他参数。
- en: Calling a Method
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用方法
- en: Once you’ve defined a method, you can use the same dot notation as for attributes
    to call the method and execute the code in that method’s body—that is, the instance
    name followed by the method, separated by a dot. Of course, methods, like functions,
    include parentheses, and sometimes arguments too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了一个方法，就可以像访问属性一样，使用相同的点符号调用该方法并执行方法体中的代码——也就是说，实例名称后跟方法名，并用点分隔。当然，方法像函数一样包含括号，有时也需要传递参数。
- en: 'Add an `a1.display()` call to your `draw()` function to render amoeba `a1`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `draw()` 函数中添加一个 `a1.display()` 调用来渲染变形虫 `a1`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You have no parameters (other than `self`) in your `display()` definition, so
    the method call takes no arguments. Run the sketch to confirm that it produces
    the same result as before ([Figure 10-6](#figure10-6)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `display()` 定义中没有参数（除了 `self`），所以方法调用不需要任何参数。运行草图以确认它产生与之前相同的结果（[图 10-6](#figure10-6)）。
- en: To get your amoeba wobbling, you’ll define a new method that you call from within
    the `Amoeba` class. Additionally, this method will accept a few arguments.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让变形虫摇晃，你将定义一个新方法，并在 `Amoeba` 类中调用它。此外，这个方法将接受一些参数。
- en: Creating a Wobbly Amoeba
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个摇晃的变形虫
- en: Amoebas distort and ripple, like balloons full of water. To replicate this not-quite-circular
    shape, you’ll replace the cell membrane’s `circle()` function with a shape formed
    using `bezierVertex()` functions. This is the same code that you used to draw
    the Chinese coin in Chapter 2, except here the control points are a bit wonky.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 变形虫像充满水的气球一样发生变形和波动。为了复制这种不完全圆形的形状，你将用 `bezierVertex()` 函数代替细胞膜的 `circle()`
    函数。这与第2章绘制中国硬币时使用的代码相同，只是这里的控制点有些不规则。
- en: '[Figure 10-7](#figure10-7) depicts the amoeba outline with the vertex and control
    points visualized. The shape isn’t perfectly round, but it is smooth with no discernible
    angles. For a smooth curve, the vertex and its two control points must form a
    straight line.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-7](#figure10-7) 展示了具有可视化顶点和控制点的变形虫轮廓。该形状并不完全圆形，但它是平滑的，没有明显的角度。对于平滑的曲线，顶点和两个控制点必须形成一条直线。'
- en: '![f10007](image_fi/500969c10/f10007.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![f10007](image_fi/500969c10/f10007.png)'
- en: 'Figure 10-7: Drawing the amoeba with Bézier curves'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-7：使用贝塞尔曲线绘制变形虫
- en: To animate the wobble effect, you need to tweak the position of the control
    points for each frame. To avoid discernible angles and maintain the rounded appearance
    of the curves, you’ll move your control points along circular paths. [Figure 10-8](#figure10-8)
    depicts (from left to right) two control points completing one rotation; each
    control point ends at the position it started, ready to repeat the motion seamlessly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现摆动效果的动画，你需要调整每一帧中控制点的位置。为了避免可察觉的角度并保持曲线的圆滑外观，你将沿圆形路径移动控制点。[图10-8](#figure10-8)展示了（从左到右）两个控制点完成一次旋转；每个控制点最终回到它开始的位置，准备无缝地重复运动。
- en: Notice that the opposite control point is always 180 degrees ahead of or behind
    its counterpart. As the control points near the vertex, the curve grows tighter
    but remains rounded. The circular trajectories maintain the (virtual) straight
    line that runs from one control point to the other, through the vertex.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，相对的控制点总是领先或落后于其对应点180度。当控制点接近顶点时，曲线变得更紧凑，但保持圆形。圆形轨迹保持从一个控制点到另一个控制点通过顶点的（虚拟）直线。
- en: '![f10008](image_fi/500969c10/f10008.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![f10008](image_fi/500969c10/f10008.png)'
- en: 'Figure 10-8: Moving the control-point coordinates along circular paths'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-8：沿圆形路径移动控制点坐标
- en: 'To program this effect, add a `circlePoint()` method for calculating points
    along the perimeter of each circular path (this method is an adaption of the `circlePoint()`
    function you defined in Chapter 9):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写这个效果，添加一个`circlePoint()`方法，用于计算每个圆形路径的周长上的点（这个方法是你在第9章定义的`circlePoint()`函数的改编）：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `circlePoint()` method accepts two arguments, a theta (`t`) value and radius
    (`r`). The rules of function scope apply to methods too, so the variables `x`
    and `y` are local to the `circlePoint()` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`circlePoint()`方法接受两个参数，一个是theta（`t`）值，另一个是半径（`r`）。函数作用域的规则同样适用于方法，因此`x`和`y`变量是`circlePoint()`方法的局部变量。'
- en: You can call methods via the class instance—the `circlePoint()` method using
    `a1.circlePoint()`, for example. Of course, you’ll need to include the two arguments
    (for `t` and `r`). You can also call a method from within its class by using a
    `self` prefix—for example, `self.circlePoint()`. In this way, you can call the
    `circlePoint()` method from within the `display()` function, using the returned
    values to draw wobbly amoeba.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过类实例调用方法——例如，使用`a1.circlePoint()`调用`circlePoint()`方法。当然，你需要包含两个参数（用于`t`和`r`）。你也可以通过在类内使用`self`前缀来调用方法——例如，`self.circlePoint()`。通过这种方式，你可以在`display()`函数内部调用`circlePoint()`方法，并使用返回的值来绘制摆动的变形虫。
- en: 'Add a `circlePoint()` method call to the `display()` block, and replace the
    `circle()` function (for the cell membrane) with code for drawing a shape composed
    of `bezierVertex()` functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`display()`块中添加一个`circlePoint()`方法调用，并用由`bezierVertex()`函数组成的代码替换`circle()`函数（用于细胞膜），绘制出一个由贝塞尔曲线组成的形状：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `r` variable represents the radius of the amoeba. The `cpl` value is the
    distance from each control point to its vertex; recall that this is roughly 55
    percent of the circle radius for perfectly round circles (see Chapter 2, Figure
    2-22). The `circlePoint()` method calculates the coordinates for variables `cpx`
    and `cpy` by using a theta value based on the advancing `frameCount`; the `frameCount`
    is divided by half the amoeba radius, so that larger amoeba wobble more slowly
    than smaller ones. The second `circlePoint()` argument, for the radius of the
    circular path, is also proportional to the amoeba radius. The rest of the code
    uses the `cpl`, `cpx`, and `cpy` variables to plot the vertices and curves that
    compose the wobbly amoeba.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`r`变量表示变形虫的半径。`cpl`值是每个控制点到其顶点的距离；请记住，对于完全圆形的圆，这大约是圆半径的55%（参见第2章，第2-22图）。`circlePoint()`方法通过使用基于递增的`frameCount`的theta值，计算`cpx`和`cpy`变量的坐标；`frameCount`被除以变形虫半径的一半，以便较大的变形虫比小的变形虫摆动得更慢。第二个`circlePoint()`参数，即圆形路径的半径，也与变形虫半径成正比。其余的代码使用`cpl`、`cpx`和`cpy`变量来绘制组成摆动变形虫的顶点和曲线。'
- en: Run the sketch to confirm that you have a wobbling amoeba.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图以确认你有一个摆动的变形虫。
- en: Modifying an Attribute by Using a Method
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过使用方法修改属性
- en: You can use a method to modify one or many attributes as an alternative to changing
    values directly via dot notation. Here’s a brief example; there’s no need to add
    this code to your sketch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一种方法来修改一个或多个属性，作为直接通过点符号修改值的替代方案。以下是一个简短的示例；不需要将这段代码添加到你的草图中。
- en: 'When you instantiate your `a1` amoeba, your `__init__()` method randomly selects
    a nucleus fill from a predefined list of five colors. You can change this by assigning
    another value via `a1.nucleus[''fill'']`. Alternatively, you might define a new
    method to do this for you:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化变形虫 `a1` 时，你的 `__init__()` 方法会从一个预定义的五种颜色的列表中随机选择一个核填充色。你可以通过将另一个值赋给 `a1.nucleus['fill']`
    来改变这一点。或者，你可以定义一个新的方法来实现这一点：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `styleNulceus()` definition includes a parameter for a fill value. After
    you’ve instantiated amoeba `a1`, you can set the nucleus fill to black by using
    `a1.styleNucleus(''#000000'')` instead of `a1.nucleus[''fill''] = ''#000000''`.
    This might not seem very useful, but consider that you could add additional arguments
    for the nucleus dictionary’s `x`, `y`, and `d` values to change them all at once.
    You might even add additional logic, like an `if` statement to check the size
    of a diameter value before applying it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`styleNucleus()` 定义包含一个填充值的参数。在你实例化变形虫 `a1` 之后，你可以通过使用 `a1.styleNucleus(''#000000'')`
    来设置核的填充色为黑色，而不是 `a1.nucleus[''fill''] = ''#000000''`。这看起来可能没什么用处，但考虑到你可以为核字典的
    `x`、`y` 和 `d` 值添加额外的参数，一次性更改它们。你甚至可以添加额外的逻辑，例如 `if` 语句来检查直径值的大小，确保在应用之前它的大小是合适的：'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `styleNucleus()` definition now includes an additional parameter for the
    nucleus diameter. But the new diameter value applies only if it’s appropriately
    sized. The `if` statement will ensure that the method ignores any value too small
    or too large so that you don’t end up with a tiny nucleus or an oversize one that
    extends beyond the cell membrane.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`styleNucleus()` 定义现在包含一个额外的参数，用于表示核的直径。但新的直径值仅在其大小合适时才会生效。`if` 语句将确保该方法忽略任何过小或过大的值，从而避免得到一个小核或一个超大、超出细胞膜的核。'
- en: Before moving on, here’s a brief recap of where you’re at in your amoeba simulation.
    You’ve defined an `Amoeba` class, complete with attributes to vary the appearance
    of each instance. You created a single amoeba, `a1`, but you’ll add other instances
    soon. You defined an `__init__()` method to initialize the attributes. Additionally,
    you defined a `display()` method to draw the amoeba that calls another method,
    `circlePoint()`, to make the cell membrane wobble. Later, you’ll make your amoebas
    move about the display window. First, though, you’ll split your *microscopic*
    sketch into two files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，简要回顾一下你在变形虫模拟中所处的阶段。你已经定义了一个 `Amoeba` 类，包含了改变每个实例外观的属性。你创建了一个变形虫 `a1`，但很快你将添加更多实例。你定义了一个
    `__init__()` 方法来初始化属性。此外，你还定义了一个 `display()` 方法来绘制变形虫，并调用了另一个方法 `circlePoint()`
    来使细胞膜产生波动。稍后，你会让变形虫在显示窗口中移动。不过，在此之前，你需要将你的*显微镜*草图拆分成两个文件。
- en: Splitting Your Python Code into Multiple Files
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的 Python 代码拆分成多个文件
- en: In this book, you’ve worked through a series of relatively small programming
    tasks. Handling each sketch in a single file has been manageable enough, but your
    line counts will increase as you begin to work on more complex programs. You might
    squeeze a *Tetris* game into several hundred lines of Processing code, but the
    open source Minecraft-like game *Minetest* is almost 600,000 lines of (mostly)
    C++ code, and Windows XP comprises about 45 million lines of source code!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你完成了一系列相对较小的编程任务。将每个草图放在一个文件中处理还算可行，但随着你开始处理更复杂的程序，行数将会增加。你可能会将一个 *俄罗斯方块*
    游戏压缩成几百行 Processing 代码，但开源的 Minecraft 类似游戏 *Minetest* 几乎有 60 万行（主要是）C++ 代码，而 Windows
    XP 包含大约 4500 万行源代码！
- en: Programming languages have various mechanisms for structuring projects across
    multiple files. In Python, you can import code from files. Each Python file you
    import is referred to as a *module*. In this section, you’ll create a separate
    amoeba module for your `Amoeba` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有多种机制来组织跨多个文件的项目。在 Python 中，你可以从文件中导入代码。每个被导入的 Python 文件被称为*模块*。在本节中，你将为
    `Amoeba` 类创建一个单独的变形虫模块。
- en: You’ll need to consider the most sensible ways to divide any program into modules.
    For example, you might group a collection of related functions into a single module.
    Sometimes it’s useful to add variables to a dedicated *configuration* module,
    providing a single location to set program-wide values. Grouping one or many related
    classes in a module is another great way to organize your code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑将程序合理划分为模块的最佳方式。例如，你可以将一组相关的函数归为一个模块。有时，将变量添加到一个专用的*配置*模块中也是很有用的，这样可以提供一个单独的位置来设置程序全局值。将一个或多个相关的类分组到一个模块中是组织代码的另一种有效方式。
- en: In the Processing editor, each tab represents a module. Create a new tab/module
    by using the arrow to the right of your *microscopic* tab, highlighted in magenta
    in [Figure 10-9](#figure10-9). From the menu that appears, select **New Tab**;
    name the new file *amoeba*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing编辑器中，每个标签代表一个模块。通过使用位于*microscopic*标签右侧的箭头（如[图 10-9](#figure10-9)所示）创建一个新的标签/模块。从弹出的菜单中选择**New
    Tab**，并将新文件命名为*amoeba*。
- en: '![f10009](image_fi/500969c10/f10009.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f10009](image_fi/500969c10/f10009.png)'
- en: 'Figure 10-9: Click the arrow tab, highlighted in magenta, for various tab operations.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-9：点击用品红色高亮显示的箭头标签进行各种标签操作。
- en: This new file/module is created in the *microscopic* folder, alongside your
    main sketch file. Processing adds *.py* to the *amoeba* filename, the standard
    file extension for Python modules. The *amoeba.py* module should now appear as
    a tab alongside the microscopic one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新文件/模块被创建在*microscopic*文件夹中，与主草图文件并列。Processing会在*amoeba*文件名后添加*.py*，这是Python模块的标准文件扩展名。现在，*amoeba.py*模块应该会出现在*microscopic*标签旁边。
- en: You can switch between your main sketch and modules by using the tabs. Switch
    to the *microscopic* tab and select all the code for your `Amoeba` class, cut
    it, and then switch to the *amoeba.py* tab and paste the code there ([Figure 10-10](#figure10-10)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过标签切换在主草图和模块之间进行切换。切换到*microscopic*标签，选择所有关于`Amoeba`类的代码，剪切它，然后切换到*amoeba.py*标签并粘贴到那里（见[图
    10-10](#figure10-10)）。
- en: '![f10010](image_fi/500969c10/f10010.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![f10010](image_fi/500969c10/f10010.png)'
- en: 'Figure 10-10: The *amoeba.py* tab contains the code for your `Amoeba` class.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-10：*amoeba.py*标签包含了你的`Amoeba`类的代码。
- en: Now switch back to the *microscopic* tab. What’s left is everything from `a1
    = Amoeba(400, 200, 100)` down.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回*microscopic*标签。剩下的就是从`a1 = Amoeba(400, 200, 100)`开始的所有内容。
- en: 'To import modules, use the `import` keyword. Your `import` line must precede
    any code that instantiates an amoeba. Typically, `import` lines go at the top
    of files to avoid getting this sequence wrong. Here’s the complete code for your
    *microscopic* tab:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入模块，使用`import`关键字。你的`import`行必须在任何实例化变形虫的代码之前。通常，`import`行放在文件的顶部，以避免顺序错误。下面是你*microscopic*标签中的完整代码：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `from` keyword instructs Python to open the *amoeba* module. The module
    takes its name from the filename, *amoeba.py*, but omits the *.py* extension.
    This is followed by `import` to specify the class(es) you want to import—in this
    case, `Amoeba`. This syntax allows you to be selective about which classes you
    import from modules that contain several class definitions. You can now use the
    `Amoeba` class as if it were defined in the *microscopic* tab.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`关键字指示Python打开*amoeba*模块。该模块的名称来自文件名*amoeba.py*，但省略了*.py*扩展名。接着是`import`，用来指定你想导入的类，这里是`Amoeba`。这种语法允许你根据需要从包含多个类定义的模块中选择性地导入类。现在，你可以像使用*microscopic*标签中的定义一样使用`Amoeba`类。'
- en: Run the sketch. It should run as usual and display a single wobbling amoeba
    in the center of the display window.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。它应该像往常一样运行，并在显示窗口的中心显示一个摇晃的变形虫。
- en: You can use modules to share code among projects. For example, you can copy
    your amoeba module into any Processing project folder. Then, you simply import
    it to start creating amoebas. You can also store a collection of modules in a
    folder-type structure known as a *library* or *package*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模块在项目之间共享代码。例如，你可以将变形虫模块复制到任何Processing项目文件夹中。然后，你只需导入它即可开始创建变形虫。你还可以将多个模块存储在一种被称为*库*或*包*的文件夹结构中。
- en: This modular system makes programming more efficient. In addition to reducing
    the line count of the main sketch, you conceal the inner workings of each module,
    leaving the programmer to focus on higher-level logic. For example, if you document
    your *amoeba* module, providing guidelines to instantiate amoebas and work the
    methods, any programmer can import and use it—creating amoebas without ever viewing
    the *amoeba.py* code. Additionally, modules make it easier for another programmer
    to browse your project code and understand your program because it’s divided into
    named files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块化系统使得编程更高效。除了减少主草图的行数外，你还隐藏了每个模块的内部工作原理，让程序员可以专注于更高层次的逻辑。例如，如果你为*amoeba*模块提供文档，说明如何实例化变形虫并使用方法，那么任何程序员都可以导入并使用它——在不查看*amoeba.py*代码的情况下创建变形虫。此外，模块化使得另一个程序员可以更容易地浏览你的项目代码并理解你的程序，因为它已经被划分为命名文件。
- en: Your `a1` amoeba remains in a fixed position, wobbling as time passes. The next
    step is to get it moving about the display window.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`a1`变形虫保持在固定位置，并随着时间推移而摇晃。下一步是让它在显示窗口中移动。
- en: Programming Movement with Vectors
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用向量编程运动
- en: You’ll program your amoeba movement by using vectors. These are not the vectors
    for scalable graphics, though, but Euclidean vectors. A *Euclidean vector* (also
    known as a *geometric* or *spatial vector*) represents a quantity that has both
    magnitude and direction. You’ll use vectors to model forces that propel your amoeba.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用向量来编程变形虫的运动。然而，这些向量不是用于可缩放图形的向量，而是欧几里得向量。*欧几里得向量*（也称为*几何向量*或*空间向量*）表示一个既有大小又有方向的量。你将使用向量来模拟推动变形虫的力。
- en: In [Figure 10-11](#figure10-11), the amoeba moves from position A to B; it’s
    propelled a total distance of 4 units. This distance represents a magnitude; a
    *magnitude* describes how powerful a force is. A force with a greater magnitude
    might thrust the same amoeba 20 units. Here’s the thing, though—the magnitude
    gives no indication of the direction in which the force is applied; you just know,
    from what you can glean visually, that the movement is 4 units to the right.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-11](#figure10-11)中，变形虫从A点移动到B点，总共推动了4个单位的距离。这个距离代表了一个大小；*大小*描述了一个力的强度。一个更大大小的力可能会将同样的变形虫推移20个单位。然而，问题在于——大小并没有指示力应用的方向；你只能通过视觉上获得的信息知道，运动是向右移动了4个单位。
- en: '![f10011](image_fi/500969c10/f10011.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f10011](image_fi/500969c10/f10011.png)'
- en: 'Figure 10-11: A magnitude of 4 units'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-11：4个单位的大小
- en: A magnitude is a *scalar* value. It’s a single quantity you can describe by
    using a single value, like a floating-point number or integer. For instance, the
    numbers 4, 1.5, 42, and one million are all scalar.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 量值是一个*标量*值。它是一个可以用单一数值（如浮点数或整数）描述的单一量。例如，数字4、1.5、42和一百万都是标量。
- en: A *vector* is described by multiple scalars. In other words, it can hold multiple
    floating-point or integer values. [Figure 10-12](#figure10-12) presents a vector
    labeled *v* as a line with an arrowhead at one end. The length of *v* is its magnitude;
    the slope and arrowhead indicate its specific direction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量*由多个标量描述。换句话说，它可以包含多个浮点数或整数值。[图 10-12](#figure10-12)展示了一个标记为*v*的向量，它是带箭头的直线。*v*的长度是它的大小；斜率和箭头指示它的特定方向。'
- en: '![f10012](image_fi/500969c10/f10012.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![f10012](image_fi/500969c10/f10012.png)'
- en: 'Figure 10-12: The vector *v* extends 4 units right and 3 units up.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-12：向量*v*向右延伸4个单位，向上延伸3个单位。
- en: Each vector has an x and y component, so you can express this vector as **v**
    = (4, 3). It describes a force to move the amoeba to a new location 4 units to
    the right and 3 units up from its previous location. You denote vectors in boldface
    type, but it’s also common to draw a small arrow above the **v** in situations
    where bold is impractical (for example, for handwritten formulas).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个向量都有一个x和一个y分量，因此你可以将这个向量表示为**v** = (4, 3)。它描述了一个将变形虫移动到一个新位置的力，这个新位置比原位置向右4个单位，向上3个单位。你用粗体字表示向量，但在某些粗体不方便使用的情况下（例如，手写公式），也常常在**v**上方画一个小箭头。
- en: The horizontal and vertical measurement lines in [Figure 10-12](#figure10-12)
    form a right triangle with *v* as its hypotenuse. From this triangle, you can
    calculate the magnitude of the vector by using the *Pythagorean theorem*. The
    theorem states that the square of the hypotenuse is equal to the sum of the squares
    of the other two sides.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-12](#figure10-12)中的水平和垂直测量线与*v*形成一个直角三角形，*v*是其中的斜边。通过这个三角形，你可以使用*勾股定理*来计算向量的大小。该定理指出，斜边的平方等于另外两边的平方和。'
- en: If you add 4 squared (the adjacent side) to 3 squared (the opposite side), you
    get 25, the length of the hypotenuse squared. The square root of 25 is 5, the
    length of the hypotenuse and the magnitude of *v*. But you don’t need to worry
    about performing such calculations. Processing provides a built-in `PVector` class
    especially for working with vectors that includes, among other methods, a `mag()`
    for calculating magnitude.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将4的平方（邻边）加上3的平方（对边），你会得到25，这是斜边的平方。25的平方根是5，即斜边的长度，也是*v*的大小。但你不需要担心进行这样的计算。Processing提供了一个内建的`PVector`类，专门用于处理向量，其中包括一个`mag()`方法来计算大小。
- en: You’ll adapt your amoeba sketch to work with the `PVector` class. While showing
    how to make your amoeba move with vectors, I’ll also outline how the various `PVector`
    methods work, revealing what’s happening on a mathematical level.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将调整你的变形虫草图，使其能够使用`PVector`类进行运动。在展示如何使用向量让变形虫移动的同时，我还会概述各种`PVector`方法的工作原理，揭示其背后的数学原理。
- en: The PVector Class
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PVector`类'
- en: '`PVector` is a built-in Processing class for working with Euclidean vectors.
    You can use it anywhere in your sketch—no `import` line required. `PVector` can
    handle two- and three-dimensional vectors, but we’ll stick to the 2D variety here.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`PVector`是Processing中的一个内建类，用于处理欧几里得向量。你可以在任何草图中使用它——无需`import`语句。`PVector`可以处理二维和三维向量，但我们这里仅使用二维向量。'
- en: 'To create a new 2D vector, the `PVector()` class requires an x and y argument.
    For example, this line defines the vector depicted previously in [Figure 10-12](#figure10-12):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的二维向量，`PVector()`类需要提供x和y参数。例如，这行代码定义了在[图10-12](#figure10-12)中所示的向量：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `v` instance is a new vector that extends 4 units across and 3 units up.
    You should, however, switch the `3` to `-3` to match Processing’s coordinate system
    (where the y values decrease as you move up).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`v`实例是一个新的向量，水平延伸4个单位，垂直延伸3个单位。不过，你应该将`3`改为`-3`，以适应Processing的坐标系统（在这个系统中，y值随着向上移动而减少）。'
- en: 'A vector can point in any direction, negative or positive, but the magnitude
    is always a positive value. Use the `mag()` method to calculate the magnitude
    of any `PVector` instance; for example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以指向任何方向，无论是负方向还是正方向，但其大小始终是一个正值。使用`mag()`方法来计算任何`PVector`实例的大小；例如：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You know that the `mag()` method must invoke prewritten code based on the Pythagorean
    theorem. It returns a floating-point value of 5.0, confirming our calculations
    from the previous section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道`mag()`方法必须调用基于毕达哥拉斯定理的预写代码。它返回一个浮动值5.0，确认了我们在上一节中的计算结果。
- en: Moving an Amoeba with PVector
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PVector移动阿米巴
- en: You’ll create a `PVector` instance to animate amoeba `a1` moving across the
    display window. In Chapter 6, you programmed something similar—a DVD screensaver—as
    you instructed Processing to move a DVD logo a set number of pixels horizontally
    and vertically in each frame for smooth, diagonal movements. The approach is similar
    here, but you’ll use the `PVector` class instead. You’ll find that the vector-based
    approach is more efficient for simulating movement and forces.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个`PVector`实例来让阿米巴`a1`在显示窗口中移动。在第6章中，你编写了类似的程序——一个DVD屏保——通过指示Processing在每一帧水平和垂直地移动DVD
    logo，达成平滑的对角线运动。这里的方法类似，但你将使用`PVector`类。你会发现，基于向量的方法在模拟运动和力方面更为高效。
- en: 'Switch to the *amoeba.py* tab and add a new `propulsion` vector to the `__init__()`
    method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到*amoeba.py*标签，并在`__init__()`方法中添加一个新的`propulsion`向量：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The propulsion vector is initialized using two additional arguments for `xspeed`
    and `yspeed` that’ll determine how many pixels your amoeba is propelled horizontally
    and vertically in each frame. In comparison to the DVD screensaver task, here
    you’re combining the `xspeed` and `yspeed` variables into a single vector named
    `propulsion`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: propulsion向量通过额外的`xspeed`和`yspeed`两个参数初始化，这将决定每一帧中阿米巴水平和垂直推进的像素数。与DVD屏保任务相比，这里你将`xspeed`和`yspeed`变量合并为一个名为`propulsion`的单一向量。
- en: 'Now switch to the *microscopic* tab. Use a fourth and fifth `Amoeba()` argument
    to set the x and y components of the propulsion vector to `3` and `-1`, respectively.
    Use the `draw()` function to increment your amoeba’s x and y attributes by those
    values:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到*microscopic*标签。使用第四个和第五个`Amoeba()`参数将推进向量的x和y分量分别设置为`3`和`-1`。使用`draw()`函数根据这些值递增阿米巴的x和y属性：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each frame, amoeba `a1`’s x value increases by 3 pixels; at the same time, its
    y value decreases by 1\. In the default Processing coordinate system, reducing
    y moves the amoeba up. If you run the sketch, the amoeba should move (quite rapidly)
    along a diagonal trajectory, starting in the center of the display window and
    soon exiting just below the upper right corner.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，阿米巴`a1`的x值增加3个像素；与此同时，它的y值减少1。在默认的Processing坐标系统中，y值减小表示阿米巴向上移动。如果运行该草图，阿米巴应沿对角线快速移动，起始于显示窗口的中心，并很快从右上角下方退出。
- en: 'You can also use a `PVector` instance to store your amoeba’s x- and y-coordinates.
    In fact, you can use `PVector` to store any x-y coordinate pair; after all, it’s
    an object used to store two (or three) numbers, which also includes a bunch of
    handy methods for performing vector operations. Switch to the *amoeba.py* tab;
    replace the `self.x` and `self.y` attributes with a new vector named `self.location`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`PVector`实例来存储阿米巴的x和y坐标。实际上，你可以使用`PVector`来存储任何x-y坐标对；毕竟，它是一个用于存储两个（或三个）数字的对象，同时还包括许多方便的向量运算方法。切换到*amoeba.py*标签；将`self.x`和`self.y`属性替换为一个名为`self.location`的新向量：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The amoeba’s location is now a `PVector` instance too, albeit one that describes
    a point in the display window rather than a velocity or force. But you can’t rerun
    the sketch yet. First, you need to update the rest of the *amoeba.py* file to
    work with the new location attribute.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 变形虫的位置现在也成为一个 `PVector` 实例，尽管它描述的是显示窗口中的一个点，而不是速度或力。但你还不能重新运行草图。首先，你需要更新其余的
    *amoeba.py* 文件，使其与新的位置属性兼容。
- en: Your `Amoeba` class has multiple references to `self.x` and `self.y`, and you’ll
    need to ensure that you replace them all with `self.location.x` and `self.location.y`,
    respectively. The easiest way to do this is by using a find-and-replace operation.
    From the Processing menu bar, select **Edit**▶**Find** to access the **Find**
    tool ([Figure 10-13](#figure10-13)). Enter `self.x` into the **Find** field, and
    `self.location.x` into the **Replace with** field. Click the **Replace All** button
    to apply the changes. The checkbox settings shouldn’t make any difference here.
    Once you’re done, do the same for `self.y`, replacing it with `self.location.y`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `Amoeba` 类中有多个 `self.x` 和 `self.y` 的引用，你需要确保将它们全部替换为 `self.location.x` 和
    `self.location.y`。最简单的方法是使用查找和替换操作。在 Processing 菜单栏中，选择 **编辑** ▶ **查找** 来访问 **查找**
    工具（[图 10-13](#figure10-13)）。在 **查找** 字段中输入 `self.x`，在 **替换为** 字段中输入 `self.location.x`。点击
    **全部替换** 按钮应用更改。这里的复选框设置不会影响结果。完成后，对 `self.y` 做同样的操作，替换为 `self.location.y`。
- en: '![f10013](image_fi/500969c10/f10013.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![f10013](image_fi/500969c10/f10013.png)'
- en: 'Figure 10-13: The Processing Find (and Replace) tool'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-13：处理查找（和替换）工具
- en: 'Now, change `a1.x` and `a1.y` in your *microscopic* tab to `a1.location.x`
    and `a1.location.y`, respectively:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将你在 *microscopic* 标签页中的 `a1.x` 和 `a1.y` 分别更改为 `a1.location.x` 和 `a1.location.y`：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You add the x components on one line and the y components on another. However,
    there’s a more efficient way to do this, using `PVector` addition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 x 分量和 y 分量分别添加到不同的行中。然而，有一种更高效的方法来实现这一点，即使用 `PVector` 加法。
- en: Adding Vectors
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量加法
- en: The `+` operator is used to add floating-point numbers or integers. Additionally,
    it serves as a concatenation operator for string operands. The `PVector` class
    is programmed to work with the `+` operator too. You can add one `PVector` instance
    to another to get a vector that’s the sum of the two. By extension, `+=` works
    as an augmented assignment operator, stating that the vector operand to the left
    of the operator is equal to itself plus the right operand.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符用于添加浮点数或整数。此外，它还作为字符串操作数的连接运算符。`PVector` 类也被编程为与 `+` 运算符一起使用。你可以将一个
    `PVector` 实例添加到另一个实例中，从而得到一个表示两个向量和的新向量。通过扩展，`+=` 作为一个增量赋值运算符，表示运算符左侧的向量操作数等于它自身加上右侧的操作数。'
- en: 'Replace your `a1.x += propulsion.x` and `a1.y += propulsion.y` lines with a
    single line to add the propulsion and location, adding `PVector` instances rather
    than individual components:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用一行代码替换你的 `a1.x += propulsion.x` 和 `a1.y += propulsion.y`，通过添加 `PVector` 实例来代替单独的分量：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With each call of the `draw()` function (every frame), the amoeba location is
    incremented by the propulsion vector. If you run the sketch, the amoeba moves
    along the same trajectory as before, 3 pixels across and 1 up each frame, exiting
    just below the upper right corner of the display window.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `draw()` 函数（每一帧）时，变形虫的位置都会根据推进力向量递增。如果你运行草图，变形虫会沿着和之前相同的轨迹移动，每一帧水平移动 3
    像素，垂直向上移动 1 像素，最终从显示窗口的右上角下方退出。
- en: Let’s add a new force to the simulation. You’ll model a current flowing diagonally
    across the display window; it assists the amoeba’s prevailing motion, flowing
    toward northeast. As Wikipedia ([https://en.wikipedia.org/wiki/Current_(fluid)](https://en.wikipedia.org/wiki/Current_(fluid)))
    defines it, “A current in a fluid is the magnitude and direction of flow within
    that fluid.” Evidently, this is something to model using a vector.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为模拟添加一个新力。你将模拟一个斜向流动的水流；它辅助变形虫的主要运动，朝东北方向流动。正如维基百科（[https://en.wikipedia.org/wiki/Current_(fluid)](https://en.wikipedia.org/wiki/Current_(fluid))）定义的那样，“流体中的水流是该流体中流动的大小和方向。”显然，这需要通过向量来模拟。
- en: 'Add a new `PVector` named `current` to your *microscopic* tab. Add that vector
    to your location each frame by using the `draw()` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *microscopic* 标签页中添加一个名为 `current` 的新 `PVector`。在每一帧中，通过 `draw()` 函数将该向量添加到你的当前位置：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The propulsion vector is angled at roughly 18 degrees, pushing more rightward
    than upward. The current vector is angled at approximately 63 degrees, pushing
    more upward than rightward ([Figure 10-14](#figure10-14)). This combination makes
    the amoeba move faster, at an angle somewhere between the two vectors (~36 degrees).
    If you run the sketch, the amoeba should exit the top edge of the display window
    (before, it exited at the right edge).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 推进向量大约与水平线成 18 度角，推力主要向右而非向上。当前向量大约与水平线成 63 度角，推力主要向上而非向右（见 [图 10-14](#figure10-14)）。这种组合使变形虫以一个大约
    36 度的角度向前移动，比之前的方式快。如果你运行草图，变形虫应该会从显示窗口的顶部边缘退出（之前它是从右边缘退出的）。
- en: '![f10014](image_fi/500969c10/f10014.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![f10014](image_fi/500969c10/f10014.png)'
- en: 'Figure 10-14: The amoeba moves a total of 4 pixels across and 3 up each frame.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-14：变形虫每帧移动 4 像素的水平距离和 3 像素的垂直距离。
- en: Vector addition works by adding the x component of one vector to the x component
    of another, and likewise for the y components. In this case, adding the x components
    (3 + 1) equals 4, and adding the y components (–1 + –2) equals –3 . Regardless
    of the order in which you add vectors, the result is always the same. For example,
    (3, –1) + (1, –2) is the same as (1, –2) + (3, –1), and the resultant vector is
    (4, –3) in both instances. This makes vector addition a *commutative* operation,
    because changing the order of your operands doesn’t change the result.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 向量加法通过将一个向量的 x 分量与另一个向量的 x 分量相加，y 分量也同样如此。在这个例子中，x 分量相加 (3 + 1) 等于 4，y 分量相加
    (–1 + –2) 等于 –3。无论加法的顺序如何，结果总是相同的。例如，(3, –1) + (1, –2) 和 (1, –2) + (3, –1) 的结果都是相同的，结果向量在两种情况下都是
    (4, –3)。这使得向量加法成为一个 *交换* 操作，因为改变操作数的顺序不会改变结果。
- en: You can experiment with different current values to see what happens. A current
    vector of (–3, 1) cancels out the propulsion vector exactly, and the amoeba won’t
    move from the center of the display window. A current vector of (–3.5, 1) will
    overpower the propulsion’s x component and exactly match the y component, moving
    the amoeba slowly and directly leftward.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试不同的电流值，看看会发生什么。一个电流向量 (–3, 1) 完全抵消了推进向量，变形虫将停留在显示窗口的中心。而电流向量 (–3.5, 1)
    将压倒推进向量的 x 分量，并与 y 分量完全匹配，导致变形虫缓慢而直接地向左移动。
- en: The neat thing about this system is that you can add as many forces to the object’s
    location as you like. For instance, you might include a vector for wind, one for
    gravity, and so on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的妙处在于你可以根据需要将任意数量的力作用于物体的位置。例如，你可能会包括一个风的向量，一个重力的向量，等等。
- en: Subtracting Vectors
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量相减
- en: In mathematics, the result of a subtraction operation is called the *difference*.
    For example, when you subtract 4 from 6, you’re left with a difference of 2\.
    Likewise, when you subtract one vector from another, the resultant vector is the
    difference between the two.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，减法运算的结果称为 *差*。例如，当你从 6 中减去 4 时，剩下的差是 2。同样，当你从一个向量中减去另一个向量时，结果向量是两者之间的差。
- en: 'You can picture vector subtraction like this: begin by placing the two vectors
    tail to tail; between the head of each vector, draw a line; this new line is the
    difference vector. In [Figure 10-15](#figure10-15), you subtract *b* from *a*;
    the difference (dark blue vector *c*) is (–2, –1).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将向量相减想象成这样：首先将两个向量的尾部对齐；在每个向量的头部之间画一条线；这条新线就是差向量。在 [图 10-15](#figure10-15)
    中，你从 *a* 中减去了 *b*；其差向量（深蓝色向量 *c*）是 (–2, –1)。
- en: '![f10015](image_fi/500969c10/f10015.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![f10015](image_fi/500969c10/f10015.png)'
- en: 'Figure 10-15: Vector *c* is equal to (–2, –1).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-15：向量 *c* 等于 (–2, –1)。
- en: The process of vector subtraction is similar to vector addition, but rather
    than adding the x (with x) and y (with y) components of each vector, you’re subtracting
    them. Note, however, that subtraction is *noncommutative*. That means, changing
    the order of the operands changes the result. For example, if you subtract *a*
    from *b*, you get (2, 1) instead of (–2, –1). This makes vector *c* point the
    opposite way, switching its head and tail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 向量相减的过程与向量加法类似，但你不再是将每个向量的 x 分量（x 分量）和 y 分量（y 分量）相加，而是进行相减。然而，注意减法是 *非交换* 的。这意味着，改变操作数的顺序会改变结果。例如，如果你从
    *b* 中减去 *a*，你会得到 (2, 1) 而不是 (–2, –1)。这使得向量 *c* 指向相反的方向，交换了它的头和尾。
- en: 'You can subtract `PVector` instances by using the `–` operator. Here’s an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `–` 运算符来减去 `PVector` 实例。以下是一个示例：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If your current vector is equal to (1, –2), this will print `[-2.0, -1.0, 0.0]`
    to the console. Processing prints a `PVector` instance as a list of three floating-point
    values, which represent the vector’s x, y, and z components, respectively. The
    z value is always a 0, unless you’re working with three-dimensional vectors.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的当前向量为 (1, –2)，这将在控制台打印 `[-2.0, -1.0, 0.0]`。Processing 将一个 `PVector` 实例打印为三个浮动点数值的列表，分别表示向量的
    x、y 和 z 分量。z 值始终为 0，除非你在处理三维向量。
- en: You’ve added a propulsion and current vector to the amoeba’s location to get
    it moving across the display window. You’ll now apply what you’ve learned about
    vector subtraction to get the amoeba moving toward your mouse pointer. You’ll
    create a new `PVector` instance called `pointer` to store the x-y coordinates
    of your mouse pointer. You’ll subtract `location` (which holds the amoeba’s x-y
    coordinates) from `pointer` to find the difference vector ([Figure 10-16](#figure10-16)),
    which you’ll use to redirect the amoeba.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将推进向量和当前向量加到变形虫的位置上，以使其在显示窗口中移动。现在，你将应用向量减法的知识，使变形虫朝鼠标指针移动。你将创建一个新的 `PVector`
    实例，名为 `pointer`，用来存储鼠标指针的 x-y 坐标。你将从 `pointer` 中减去 `location`（它包含变形虫的 x-y 坐标）来找到差异向量（[图
    10-16](#figure10-16)），你将使用这个向量来重新定向变形虫。
- en: '![f10016](image_fi/500969c10/f10016.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![f10016](image_fi/500969c10/f10016.png)'
- en: 'Figure 10-16: The difference vector is equal to `pointer` – `location`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-16：差异向量等于 `pointer` – `location`。
- en: Ensure that your current vector is set to (1, –2). Add a new `PVector` named
    pointer and a difference variable that’s equal to the pointer minus the amoeba
    location (the difference vector depicted in [Figure 10-16](#figure10-16)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的当前向量设置为 (1, –2)。添加一个新的 `PVector`，命名为 pointer，并创建一个差异变量，它等于指针减去变形虫的位置（[图
    10-16](#figure10-16) 中所示的差异向量）。
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `mouseX` and `mouseY` are Processing system variables that hold the x- and
    y-coordinates of your mouse pointer. Note, however, that Processing can begin
    tracking the mouse position only after you move the pointer in front of the display
    window; until that time, `mouseX` and `mouseY` both return a default value of
    0.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseX` 和 `mouseY` 是 Processing 系统变量，保存着鼠标指针的 x 和 y 坐标。但需要注意的是，Processing
    只有在鼠标指针移动到显示窗口前后，才会开始跟踪鼠标位置；在此之前，`mouseX` 和 `mouseY` 都会返回默认值 0。'
- en: If you run the sketch, the amoeba will attach to the mouse pointer. This happens
    because the amoeba reaches the pointer position in a single “leap.” Instead, you
    want the amoeba to “swim” toward the pointer, advancing in small increments over
    multiple frames.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个草图，变形虫将附着在鼠标指针上。这是因为变形虫会在一次“跳跃”中到达指针位置。相反，你希望变形虫朝着指针“游泳”，在多个帧中逐步前进。
- en: Limiting Vector Magnitude
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制向量大小
- en: The `PVector` class provides the `limit()` method to limit the magnitude of
    any vector, which does not affect the direction. It requires a scalar (integer
    or floating-point) argument that represents a maximum magnitude.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`PVector` 类提供了 `limit()` 方法来限制任何向量的大小，这不会影响方向。它需要一个标量（整数或浮动点数）作为参数，表示最大大小。'
- en: You’ll use the difference vector to steer the amoeba toward the mouse pointer
    by adding it to the propulsion vector. You’ll limit the propulsion vector to a
    magnitude of 3 ([Figure 10-17](#figure10-17)), enough to overpower the current
    marginally (which has a magnitude of 2.24) when the amoeba is swimming directly
    into it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用差异向量通过将其添加到推进向量中来引导变形虫朝向鼠标指针。你将限制推进向量的大小为 3（[图 10-17](#figure10-17)），足以在变形虫直接游向当前方向时，稍微克服其大小为
    2.24 的作用力。
- en: '![f10017](image_fi/500969c10/f10017.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![f10017](image_fi/500969c10/f10017.png)'
- en: 'Figure 10-17: The propulsion vector’s magnitude is limited to 3.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-17：推进向量的大小限制为 3。
- en: 'Make the following insertions/changes to the `draw()` function to steer and
    propel the amoeba toward the mouse pointer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw()` 函数中做以下插入/修改，以引导和推进变形虫朝着鼠标指针前进：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, comment out or delete the existing `a1.location += difference` line 1.
    The `limit()` method restricts the `difference` vector to a magnitude of 0.03
    2. This tiny value is added to the propulsion vector each frame—the effect rapidly
    accumulating—steering the amoeba progressively toward the mouse pointer. But even
    when the amoeba is heading directly at the pointer, the propulsion vector’s magnitude
    will not exceed 3 3.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将现有的 `a1.location += difference` 行 1 注释掉或删除。`limit()` 方法将 `difference` 向量限制为大小为
    0.03。这个微小的值将在每一帧中被添加到推进向量中——这种效果迅速累积——将变形虫逐步引导朝向鼠标指针。但即使变形虫直接朝指针前进，推进向量的大小也不会超过
    3。
- en: Run the sketch and position your mouse pointer over the display window somewhere
    near the lower left corner. The amoeba will have drifted out of view. But wait
    for a while, and it’ll slowly make its way toward the corner; when it reaches
    the pointer, it will overshoot it slightly, then turn around and overshoot it
    on the way back. It continues to overshoot the pointer, because it’s trying to
    reach its target as quickly as possible. Now move your pointer to the lower right
    corner. Assisted by the current, the amoeba is quick to reach the opposite side
    of the screen, but its higher velocity leads it to overshoot the target dramatically.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图，将鼠标指针移动到显示窗口的左下角附近。变形虫将会漂移到视野之外。但稍等一会儿，它会慢慢朝着那个角落移动；当它到达指针时，会稍微超越它，然后转身返回时再超越一次。它会不断超越指针，因为它试图尽快到达目标。现在将指针移到右下角。在水流的帮助下，变形虫迅速到达屏幕的另一侧，但由于其较高的速度，它会剧烈地超越目标。
- en: 'Soon, you’ll add multiple amoebas to the simulation. To prepare them for moving
    at different speeds, add an attribute for maximum propulsion to the `Amoeba` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你将会向模拟中添加多个变形虫。为了让它们以不同的速度移动，向`Amoeba`类中添加一个最大推进力的属性：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This attribute will limit the magnitude/power of the amoeba’s propulsion vector
    based on the `xspeed` and `yspeed` arguments you provide. Adapt the code in your
    *microscopic* tab to work with the `maxpropulsion` attribute, switching out the
    arguments of both `limit()` methods. Additionally, adjust the values for the `xspeed`,
    `yspeed`, and the current vector, reducing them by a factor of 10:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将根据你提供的`xspeed`和`yspeed`参数来限制变形虫推进向量的大小/力度。修改你在*微观*标签中的代码，使其能够使用`maxpropulsion`属性，替换两个`limit()`方法的参数。另外，调整`xspeed`、`yspeed`和当前向量的值，将它们缩小一个因子10：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The reduced propulsion and current values slow down the simulation, so the amoeba
    movement is more steady and controlled. The amoeba won’t wildly overshoot its
    target anymore, but it still makes small orbits around the pointer. The limit
    for the difference vector is now proportional to the amoeba’s maximum propulsion,
    so a faster amoeba has some extra steering power to handle its higher velocity.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 减少的推进力和当前值使得模拟变得更慢，因此变形虫的移动更加平稳和可控。变形虫不再猛烈超越目标，但它仍然会在指针周围做小的轨道运动。差值向量的限制现在与变形虫的最大推进力成比例，因此较快的变形虫具有额外的操控力来应对其更高的速度。
- en: Performing Other Vector Operations
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行其他向量操作
- en: There’s more to vectors and the `PVector` class, but that’s all I cover in this
    book. Consider what you’ve learned as an elementary introduction to the topic.
    The `PVector` class can additionally handle vector multiplication, division, normalization,
    3D vectors, and more. Vectors are useful for programming anything that requires
    physics, like video games, and you’re likely to reencounter them in your creative
    coding adventures.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和`PVector`类还有更多内容，但这些内容是本书中涉及的所有内容。可以将你所学的视为该主题的初步入门。`PVector`类还可以处理向量乘法、除法、归一化、三维向量等操作。向量对于编程涉及物理的任何内容都非常有用，比如视频游戏，而且你很可能会在你的创意编程冒险中再次遇到它们。
- en: Adding Many Amoebas to the Simulation
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向模拟中添加多个变形虫
- en: You have a working amoeba module, but you’re still dealing with a single amoeba
    instance, `a1`, so the next step is to create a colony. You can create as many
    instances as you like from a single class. In this section, you’ll spawn eight
    amoebas in the same display window by using the `Amoeba` class. Each amoeba will
    vary in size, and you’ll start them at different x-y coordinates. Recall that
    each amoeba instance includes a dictionary of randomized nucleus values, so the
    nuclei will vary too.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了一个工作的变形虫模块，但你目前只在处理一个变形虫实例`a1`，因此下一步是创建一个变形虫群落。你可以从同一个类创建任意数量的实例。在这一部分中，你将使用`Amoeba`类在同一个显示窗口中生成八个变形虫。每个变形虫的大小都不同，且它们将从不同的x-y坐标开始。回想一下，每个变形虫实例包含一个随机化的细胞核值字典，因此细胞核也会有所不同。
- en: 'One (rather manual) approach for adding amoebas is to define additional instances
    with personalized variable names, with explicitly differentiated parameters. Consider
    these three new amoeba:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加变形虫的一种（相当手动）方法是定义额外的实例，并使用个性化的变量名和明确区分的参数。考虑以下三个新的变形虫：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can keep adding amoebas in this manner, but the approach has its downsides.
    For one, you need to remember to call every `display()` method in the body of
    the `draw()` function to render each amoeba:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这种方式不断添加变形虫，但这种方法也有其缺点。首先，你需要记得在`draw()`函数的主体中调用每个`display()`方法来渲染每个变形虫：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will display `sam`, `bob`, and `lee` standing still; to get those amoebas
    moving, the `draw()` function requires even more code. That isn’t especially efficient
    if you’re dealing with 5 or so amoebas, never mind 100.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Personalized amoeba names are cute and all, but not important for this program.
    Instead, you’ll store the amoebas in a list. You can conveniently use a loop to
    generate a list of as many amoebas as you like. Then you can call each amoeba’s
    `display()` method (along with the code to move it) by using another loop.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `a1` line at the top of your *microscopic* code with an empty `amoebas`
    list and a loop to populate it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With each iteration of the `for` loop, Python creates a new `Amoeba()` instance.
    The `Amoeba()` arguments are randomized to vary the x-coordinate, y-coordinate,
    and diameter of each instance. The `speed` value is based on the `diameter`—so
    bigger amoebas move slower (recall that the `propulsion` and `maxpropulsion` attribute
    is derived from the `xspeed` and `yspeed` arguments). The `append()` method adds
    the new amoeba instance to the `amoebas` list. The amoebas don’t have names like
    `sam`, `bob`, and `lee`, but you can address them by index as `amoebas[0]`, `amoebas[1]`,
    and so forth.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'You must add a `for` loop to the `draw()` function to render the full list
    of amoebas. Here’s your amended code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `for` loop iterates the entire `amoebas` list. For each amoeba, it calculates
    an updated location, and then renders that amoeba by using its `display()` method.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The larger, slower amoebas might drift out of the display window, overwhelmed
    by the current, never to be seen again. To avoid this problem, add code for *wraparound*
    edges—so that if an amoeba exits the display window, it reappears on the opposite
    side, maintaining its speed and trajectory:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The four `if` statements check each edge of the display window. It’s necessary
    to incorporate the radius (variable `r`) in the conditions to ensure that the
    amoeba has fully left the display window before it reappears on the opposite side.
    Likewise, each corresponding destination is offset by `r` to prevent the amoeba
    from reappearing halfway over the opposite edge. You can set `r` to 0 if you’d
    like to see what happens otherwise.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Each time you run the sketch, you get a different selection of amoebas. They
    all swarm toward your mouse pointer (although the current overpowers some of the
    large, slow ones), overlapping one another in the process. [Figure 10-18](#figure10-18)
    shows an example with eight amoebas.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: To add or remove amoebas, you can adjust the argument in the `range()` function
    of your first loop, and the loop in the `draw()` function will adapt dynamically.
    If your computer seems to be struggling, you can reduce the number of amoebas.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![f10018](image_fi/500969c10/f10018.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-18: A display window with eight amoebas moving toward the mouse pointer'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #10: Collision Detection'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The amoebas can overlap one another. To prevent this from happening, you must
    first detect where overlaps occur. From there, you can apply vector forces to
    push any colliding pairs apart.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 变形虫可能会相互重叠。为了防止这种情况发生，必须先检测重叠发生的位置。然后，你可以应用向量力将任何发生碰撞的变形虫推开。
- en: The amoebas are roughly circular, so a *circle-circle collision detection* algorithm
    will work nicely here. To understand how circle-circle collision detection works,
    refer to [Figure 10-19](#figure10-19). The pair of circles on the left have not
    collided; on the right is a colliding pair. For the non-colliding circles, the
    distance between the centers of each circle is greater than the sum of the two
    radii (r1 and r2). Conversely, where the circles have collided, the distance is
    less than the sum of the two radii.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 变形虫大致是圆形的，所以*圆形-圆形碰撞检测*算法在这里非常适用。要理解圆形-圆形碰撞检测是如何工作的，可以参考[图 10-19](#figure10-19)。左边的一对圆形没有发生碰撞；右边的是发生了碰撞的圆形对。对于没有发生碰撞的圆形，它们的圆心之间的距离大于两圆半径之和（r1
    和 r2）。相反，当圆形发生碰撞时，它们的圆心之间的距离小于两圆半径之和。
- en: '![f10019](image_fi/500969c10/f10019.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![f10019](image_fi/500969c10/f10019.png)'
- en: 'Figure 10-19: Circle-circle collision detection'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-19：圆形碰撞检测
- en: 'To test for collisions in Processing, you’ll need to check each amoeba against
    every other amoeba in the `amoebas` list. For this purpose, add another `for`
    loop within the `a in amoebas` loop:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中测试碰撞时，你需要检查`amoebas`列表中的每一个变形虫与其他所有变形虫之间的碰撞。为此，你需要在`a in amoebas`循环中添加另一个`for`循环：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You don’t want to check whether an amoeba is colliding with itself. At the top
    of the loop, there’s an `if a is b` test. The `is` operator compares the objects
    on either side of itself to determine whether they point to the same instance;
    if `a` is the same instance as `b`, this will evaluate as `True`. The `continue`
    line terminates the current iteration of the loop to start at the beginning of
    the next, so your “solution” code is skipped.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想检查一个变形虫是否与自己发生碰撞。在循环的顶部，有一个`if a is b`的测试。`is`操作符比较其两侧的对象，以确定它们是否指向同一个实例；如果`a`与`b`是同一个实例，这个条件会被评估为`True`。`continue`语句终止当前循环的迭代，并从下一次循环的开始处重新开始，因此你的“解决方案”代码会被跳过。
- en: Think about how you can use the distance vectors shown in [Figure 10-19](#figure10-19)
    to push apart colliding amoebas. Can you add (or subtract) a fraction of the distance
    vector to push an amoeba in the opposite direction to the one it has collided
    with?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 想想如何利用[图 10-19](#figure10-19)中显示的距离向量，将发生碰撞的变形虫推开。你能否添加（或减去）一部分距离向量，将变形虫推向与碰撞方向相反的方向？
- en: If you need help, you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-10-object-oriented_programming_and_pvector/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-10-object-oriented_programming_and_pvector/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助，可以访问解决方案：[https://github.com/tabreturn/processing.py-book/tree/master/chapter-10-object-oriented_programming_and_pvector/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-10-object-oriented_programming_and_pvector/)。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use object-oriented programming to model
    real-world objects in Python. You defined a new `Amoeba` class, to which you added
    attributes and methods. A class serves as an object template, from which you can
    create countless instances. Grouping related variables (attributes) and functions
    (methods) into classes can help you structure code more efficiently. This is especially
    effective for programming larger, more complex projects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用面向对象编程在Python中建模现实世界中的对象。你定义了一个新的`Amoeba`类，并为其添加了属性和方法。类作为对象模板，你可以从中创建无数个实例。将相关的变量（属性）和函数（方法）组织到类中，可以帮助你更高效地组织代码。这对于编写更大、更复杂的项目特别有效。
- en: You also learned how to separate classes (and other code) into different Python
    files, called modules, and how to use those modules to share code between projects
    or as reusable components among files in the same project. Remember that modules
    reduce the line count of the main sketch, allowing you to focus on higher-level
    logic.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何将类（和其他代码）分离到不同的Python文件中，这些文件被称为模块，并且如何使用这些模块在项目之间共享代码，或者在同一项目中的文件间作为可重用的组件。记住，模块可以减少主草图的行数，让你能够专注于更高层次的逻辑。
- en: This chapter also introduced Processing’s built-in `PVector` class for dealing
    with Euclidean vectors. A Euclidean vector describes a quantity that has both
    magnitude and direction, but you can also use a vector to store something’s location
    (as an x-y coordinate). In this chapter, you used vectors to simulate forces and
    control the positions of various objects in the display window.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to handle mouse and keyboard interaction
    in Processing. I’ve already touched on the `mouseX` and `mouseY` system variables
    in this chapter. However, you can do much more with capturing mouse clicks and
    keypresses, unlocking exciting ways to interact with your Processing sketches.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
