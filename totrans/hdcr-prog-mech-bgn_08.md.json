["```py\nfrom geom2d.point import Point\n\nclass Polygon:\n    def __init__(self, vertices: [Point]):\n        if len(vertices) < 3:\n            raise ValueError('Need 3 or more vertices')\n\n        self.vertices = vertices\n```", "```py\ndef make_round_pairs(sequence):\n    length = len(sequence)\n    return [\n     ➊ (sequence[i], sequence[(i + 1) % length])\n     ➋ for i in range(length)\n    ]\n```", "```py\n>>> [n % 4 for n in range(5)]\n[0, 1, 2, 3, 0]\n```", "```py\n>>> [n % 4 for n in range(7)]\n[0, 1, 2, 3, 0, 1, 2]\n```", "```py\nfrom geom2d.segment import Segment\nfrom utils.pairs import make_round_pairs\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.segment import Segment\nfrom utils.pairs import make_round_pairs\n\nclass Polygon:\n    --snip--\n\n    def sides(self):\n        vertex_pairs = make_round_pairs(self.vertices)\n        return [\n            Segment(pair[0], pair[1])\n            for pair in vertex_pairs\n        ]\n```", "```py\nimport unittest\n\nfrom geom2d.point import Point\nfrom geom2d.polygon import Polygon\nfrom geom2d.segment import Segment\n\nclass TestPolygon(unittest.TestCase):\n    vertices = [\n        Point(0, 0),\n        Point(30, 0),\n        Point(0, 30),\n    ]\n    polygon = Polygon(vertices)\n\n    def test_sides(self):\n        expected = [\n            Segment(self.vertices[0], self.vertices[1]),\n            Segment(self.vertices[1], self.vertices[2]),\n            Segment(self.vertices[2], self.vertices[0])\n        ]\n        actual = self.polygon.sides()\n        self.assertEqual(expected, actual)\n```", "```py\n$ python3 -m unittest geom2d/polygon_test.py\n```", "```py\nRan 1 tests in 0.000s\n\nOK\n```", "```py\nimport operator\nfrom functools import reduce\n```", "```py\nimport operator\nfrom functools import reduce\n\nfrom geom2d.point import Point\nfrom geom2d.segment import Segment\nfrom utils.pairs import make_round_pairs\n\nclass Polygon:\n    --snip--\n\n    @property\n    def centroid(self):\n     ➊ vtx_count = len(self.vertices)\n     ➋ vtx_sum = reduce(operator.add, self.vertices)\n     ➌ return Point(\n           vtx_sum.x / vtx_count,\n           vtx_sum.y / vtx_count\n       )\n```", "```py\nclass TestPolygon(unittest.TestCase):\n   --snip--\n\n   def test_centroid(self):\n       expected = Point(10, 10)\n       actual = self.polygon.centroid\n       self.assertEqual(expected, actual)\n```", "```py\n$ python3 -m unittest geom2d/polygon_test.py\n```", "```py\nRan 2 tests in 0.000s\n\nOK\n```", "```py\nvtx_sum = reduce(operator.add, self.vertices)\n```", "```py\nclass Point:\n    --snip--\n\n    # def __add__(self, other):\n    #     return Point(\n    #         self.x + other.x,\n    #         self.y + other.y\n    #     )\n```", "```py\n======================================================\nERROR: test_centroid (geom2d.polygon_test.TestPolygon)\n------------------------------------------------------\nTraceback (most recent call last):\n  --snip--\n    vtx_sum = reduce(operator.add, self.vertices)\nTypeError: unsupported operand type(s) for +: 'Point' and 'Point'\n\n-------------------------------------------------------\nRan 2 tests in 0.020s\n```", "```py\nimport math\nimport operator\nfrom functools import reduce\n\nfrom geom2d.nums import are_close_enough\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between\nfrom geom2d.segment import Segment\nfrom utils.pairs import make_round_pairs\n```", "```py\nimport math\nimport operator\nfrom functools import reduce\n\nfrom geom2d.nums import are_close_enough\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between\nfrom geom2d.segment import Segment\nfrom utils.pairs import make_round_pairs\n\nclass Polygon:\n    --snip--\n\n   def contains_point(self, point: Point):\n    ➊ vecs = [make_vector_between(point, vertex)\n                for vertex in self.vertices]\n    ➋ paired_vecs = make_round_pairs(vecs)\n    ➌ angle_sum = reduce(\n           operator.add,\n        ➍ [v1.angle_to(v2) for v1, v2 in paired_vecs]\n       )\n\n    ➎ return are_close_enough(angle_sum, 2 * math.pi)\n```", "```py\nclass TestPolygon(unittest.TestCase):\n   --snip--\n\n   def test_doesnt_contain_point(self):\n       point = Point(15, 20)\n       self.assertFalse(self.polygon.contains_point(point))\n\n   def test_contains_point(self):\n       point = Point(15, 10)\n       self.assertTrue(self.polygon.contains_point(point))\n```", "```py\n$ python3 -m unittest geom2d/polygon_test.py\n```", "```py\nclass TestPolygon(unittest.TestCase):\n   --snip--\n\n   def test_contains_vertex(self):\n       self.assertTrue(\n           self.polygon.contains_point(self.vertices[0])\n       )\n```", "```py\nError\nTraceback (most recent call last):\n  --snip--\n  File \".../geom2d/polygon.py\", line 36, in <listcomp>\n    [v1.angle_to(v2) for v1, v2 in paired_vecs]\n  File \".../geom2d/vector.py\", line 69, in angle_to\n    value = self.angle_value_to(other)\n  File \".../geom2d/vector.py\", line 66, in angle_value_to\n    return math.acos(dot_product / norm_product)\nZeroDivisionError: float division by zero\n```", "```py\nreturn math.acos(dot_product / norm_product)\n```", "```py\n[v1.angle_to(v2) for v1, v2 in paired_vecs]\n```", "```py\nclass Polygon:\n    --snip--\n\n    def contains_point(self, point: Point):\n        if point in self.vertices:\n            return True\n\n        vecs = [make_vector_between(point, vertex)\n                for vertex in self.vertices]\n        paired_vecs = make_round_pairs(vecs)\n        angle_sum = reduce(\n            operator.add,\n            [v1.angle_to(v2) for v1, v2 in paired_vecs]\n        )\n\n        return are_close_enough(angle_sum, 2 * math.pi)\n```", "```py\n$ python3 -m unittest geom2d/polygon_test.py\n```", "```py\nRan 5 tests in 0.001s\n\nOK\n```", "```py\n[0, 0, 50, 0, 0, 50]\n```", "```py\n[(0, 0), (50, 0), (0, 50)]\n```", "```py\nfrom geom2d import Point, Polygon\n\ndef make_polygon_from_coords(coords: [float]):\n    if len(coords) % 2 != 0:\n        raise ValueError('Need an even number of coordinates')\n\n    indices = range(0, len(coords), 2)\n    return Polygon(\n        [Point(coords[i], coords[i + 1]) for i in indices]\n    )\n```", "```py\n>>> list(range(0, 10, 2))\n[0, 2, 4, 6, 8]\n```", "```py\nclass Polygon:\n    --snip--\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Polygon):\n            return False\n\n        return self.vertices == other.vertices\n```", "```py\n>>> l1 = [1, 2, 3]\n>>> l2 = [3, 2, 1]\n>>> l3 = [3, 2, 1]\n>>> l1 == l2\nFalse\n\n>>> l2 == l3\ntrue\n```", "```py\nimport math\nimport operator\nfrom functools import reduce\n\nfrom geom2d.nums import are_close_enough\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between\nfrom geom2d.segment import Segment\nfrom utils.pairs import make_round_pairs\n\nclass Polygon:\n    def __init__(self, vertices: [Point]):\n        if len(vertices) < 3:\n            raise ValueError('Need 3 or more vertices')\n        self.vertices = vertices\n\n    def sides(self):\n        vertex_pairs = make_round_pairs(self.vertices)\n        return [Segment(pair[0], pair[1]) for pair in vertex_pairs]\n\n    @property\n    def centroid(self):\n        vtx_count = len(self.vertices)\n        vtx_sum = reduce(operator.add, self.vertices)\n        return Point(\n            vtx_sum.x / vtx_count,\n            vtx_sum.y / vtx_count\n        )\n\n    def contains_point(self, point: Point):\n        if point in self.vertices:\n            return True\n\n        vecs = [make_vector_between(point, vertex)\n                for vertex in self.vertices]\n        paired_vecs = make_round_pairs(vecs)\n        angle_sum = reduce(\n            operator.add,\n            [v1.angle_to(v2) for v1, v2 in paired_vecs]\n        )\n\n        return are_close_enough(angle_sum, 2 * math.pi)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Polygon):\n            return False\n\n        return self.vertices == other.vertices\n```", "```py\nimport math\n\nfrom geom2d.point import Point\n\nclass Circle:\n    def __init__(self, center: Point, radius: float):\n        self.center = center\n        self.radius = radius\n\n    @property\n    def area(self):\n        return math.pi * self.radius ** 2\n\n    @property\n    def circumference(self):\n        return 2 * math.pi * self.radius\n```", "```py\nclass Circle:\n   --snip--\n\n   def contains_point(self, point: Point):\n       return point.distance_to(self.center) < self.radius\n```", "```py\nimport math\n\nfrom geom2d.point import Point\nfrom geom2d.polygon import Polygon\n\nclass Circle:\n   --snip--\n\n   def to_polygon(self, divisions: int):\n    ➊ angle_delta = 2 * math.pi / divisions\n      return Polygon(\n       ➋ [self.__point_at_angle(angle_delta * i)\n          for i in range(divisions)]\n    )\n\n   def __point_at_angle(self, angle: float):\n    ➌ return Point(\n          self.center.x + self.radius * math.cos(angle),\n          self.center.y + self.radius * math.sin(angle)\n      )\n```", "```py\nimport math\n\nfrom geom2d.nums import are_close_enough\nfrom geom2d.point import Point\nfrom geom2d.polygon import Polygon\n\nclass Circle:\n   --snip--\n\n   def __eq__(self, other):\n       if self is other:\n            return True\n\n        if not isinstance(other, Circle):\n            return False\n\n       return self.center == other.center \\\n              and are_close_enough(self.radius, other.radius)\n\n   def __str__(self):\n       return f'circle c = {self.center}, r = {self.radius}'\n```", "```py\nimport math\n\nfrom geom2d.nums import are_close_enough\nfrom geom2d.point import Point\nfrom geom2d.polygon import Polygon\n\nclass Circle:\n    def __init__(self, center: Point, radius: float):\n        self.center = center\n        self.radius = radius\n\n    @property\n    def area(self):\n        return math.pi * self.radius ** 2\n\n    @property\n    def circumference(self):\n        return 2 * math.pi * self.radius\n\n    def contains_point(self, point: Point):\n        return point.distance_to(self.center) < self.radius\n\n    def to_polygon(self, divisions: int):\n        angle_delta = 2 * math.pi / divisions\n        return Polygon(\n            [self.__point_at_angle(angle_delta * i)\n             for i in range(divisions)]\n        )\n\n    def __point_at_angle(self, angle: float):\n        return Point(\n            self.center.x + self.radius * math.cos(angle),\n            self.center.y + self.radius * math.sin(angle)\n        )\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Circle):\n            return False\n\n        return self.center == other.center \\\n               and are_close_enough(self.radius, other.radius)\n\n    def __str__(self):\n        return f'circle c = {self.center}, r = {self.radius}'\n```", "```py\nfrom geom2d import Point\nfrom geom2d.circle import Circle\nfrom geom2d.segment import Segment\n\ndef make_circle_from_points(a: Point, b: Point, c: Point):\n    chord_one_bisec = Segment(a, b).bisector\n    chord_two_bisec = Segment(b, c).bisector\n    center = chord_one_bisec.intersection_with(chord_two_bisec)\n    radius = center.distance_to(a)\n\n    return Circle(center, radius)\n```", "```py\nfrom geom2d.nums import are_close_enough\n\nclass Size:\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Size):\n            return False\n\n        return are_close_enough(self.width, other.width) \\\n               and are_close_enough(self.height, other.height)\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.size import Size\n\nclass Rect:\n    def __init__(self, origin: Point, size: Size):\n        self.origin = origin\n        self.size = size\n\n    @property\n    def left(self):\n        return self.origin.x\n\n    @property\n    def right(self):\n        return self.origin.x + self.size.width\n\n    @property\n    def bottom(self):\n        return self.origin.y\n\n    @property\n    def top(self):\n        return self.origin.y + self.size.height\n\n    @property\n    def area(self):\n        return self.size.width * self.size.height\n\n    @property\n    def perimeter(self):\n        return 2 * self.size.width + 2 * self.size.height\n```", "```py\n>>> from geom2d.point import Point\n>>> from geom2d.size import Size\n>>> from geom2d.rect import Rect\n\n>>> origin = Point(10, 20)\n>>> size = Size(100, 150)\n>>> rect = Rect(origin, size)\n```", "```py\n>>> rect.right\n110\n\n>>> rect.area\n15000\n\n>>> rect.perimeter\n500\n```", "```py\nclass Rect:\n   --snip--\n\n   def contains_point(self, point: Point):\n       return self.left < point.x < self.right \\\n              and self.bottom < point.y < self.top\n```", "```py\nleft < point.x < right\n```", "```py\nleft < point.x && point.x < right\n```", "```py\nclass OpenInterval:\n    def __init__(self, start: float, end: float):\n        if start > end:\n            raise ValueError('start should be smaller than end')\n        self.start = start\n        self.end = end\n\n    @property\n    def length(self):\n     ➊ return self.end - self.start\n\n    def contains(self, value):\n     ➋ return self.start < value < self.end\n```", "```py\nfrom geom2d.nums import are_close_enough\n\nclass OpenInterval:\n    --snip--\n\n    def overlaps_interval(self, other):\n     ➊ if are_close_enough(self.start, other.start) and \\\n               are_close_enough(self.end, other.end):\n           return True\n\n     ➋ return self.contains(other.start) \\\n               or self.contains(other.end) \\\n               or other.contains(self.start) \\\n               or other.contains(self.end)\n\n    def compute_overlap_with(self, other):\n     ➌ if not self.overlaps_interval(other):\n            return None\n\n     ➍ return OpenInterval(\n            max(self.start, other.start),\n            min(self.end, other.end)\n        )\n```", "```py\nfrom geom2d.open_interval import OpenInterval\n```", "```py\nfrom geom2d.open_interval import OpenInterval\nfrom geom2d.point import Point\nfrom geom2d.size import Size\n\nclass Rect:\n    --snip--\n\n    def intersection_with(self, other):\n     ➊ h_overlap = self.__horizontal_overlap_with(other)\n        if h_overlap is None:\n            return None\n\n     ➋ v_overlap = self.__vertical_overlap_with(other)\n        if v_overlap is None:\n            return None\n\n     ➌ return Rect(\n            Point(h_overlap.start, v_overlap.start),\n            Size(h_overlap.length, v_overlap.length)\n       )\n```", "```py\nclass Rect:\n   --snip--\n\n   def __horizontal_overlap_with(self, other):\n       self_interval = OpenInterval(self.left, self.right)\n       other_interval = OpenInterval(other.left, other.right)\n\n       return self_interval.compute_overlap_with(other_interval)\n\n   def __vertical_overlap_with(self, other):\n       self_interval = OpenInterval(self.bottom, self.top)\n       other_interval = OpenInterval(other.bottom, other.top)\n\n       return self_interval.compute_overlap_with(other_interval)\n```", "```py\nfrom geom2d.open_interval import OpenInterval\nfrom geom2d.point import Point\nfrom geom2d.polygon import Polygon\nfrom geom2d.size import Size\n\nclass Rect:\n   --snip--\n\n   def to_polygon(self):\n       return Polygon([\n           self.origin,\n           Point(self.right, self.bottom),\n           Point(self.right, self.top),\n           Point(self.left, self.top)\n       ])\n```", "```py\nclass Rect:\n   --snip--\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Rect):\n            return False\n\n        return self.origin == other.origin \\\n               and self.size == other.size\n```", "```py\nfrom geom2d.open_interval import OpenInterval\nfrom geom2d.point import Point\nfrom geom2d.polygon import Polygon\nfrom geom2d.size import Size\n\nclass Rect:\n\n    def __init__(self, origin: Point, size: Size):\n        self.origin = origin\n        self.size = size\n\n    @property\n    def left(self):\n        return self.origin.x\n\n    @property\n    def right(self):\n        return self.origin.x + self.size.width\n\n    @property\n    def bottom(self):\n        return self.origin.y\n\n    @property\n    def top(self):\n        return self.origin.y + self.size.height\n\n    @property\n    def area(self):\n        return self.size.width * self.size.height\n\n    @property\n    def perimeter(self):\n        return 2 * self.size.width + 2 * self.size.height\n\n    def contains_point(self, point: Point):\n        return self.left < point.x < self.right \\\n               and self.bottom < point.y < self.top\n\n    def intersection_with(self, other):\n        h_overlap = self.__horizontal_overlap_with(other)\n        if h_overlap is None:\n            return None\n\n        v_overlap = self.__vertical_overlap_with(other)\n        if v_overlap is None:\n            return None\n\n        return Rect(\n            Point(h_overlap.start, v_overlap.start),\n            Size(h_overlap.length, v_overlap.length)\n        )\n\n    def __horizontal_overlap_with(self, other):\n        self_interval = OpenInterval(self.left, self.right)\n        other_interval = OpenInterval(other.left, other.right)\n\n        return self_interval.compute_overlap_with(other_interval)\n\n    def __vertical_overlap_with(self, other):\n        self_interval = OpenInterval(self.bottom, self.top)\n        other_interval = OpenInterval(other.bottom, other.top)\n\n        return self_interval.compute_overlap_with(other_interval)\n\n    def to_polygon(self):\n        return Polygon([\n            self.origin,\n            Point(self.right, self.bottom),\n            Point(self.right, self.top),\n            Point(self.left, self.top)\n        ])\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Rect):\n            return False\n\n        return self.origin == other.origin \\\n               and self.size == other.size\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.rect import Rect\nfrom geom2d.size import Size\n\ndef make_rect_containing(points: [Point]):\n ➊ if not points:\n        raise ValueError('Expected at least one point')\n\n    first_point = points[0]\n ➋ min_x, max_x = first_point.x, first_point.x\n ➌ min_y, max_y = first_point.y, first_point.y\n\n    for point in points[1:]:\n     ➍ min_x, max_x = min(min_x, point.x), max(max_x, point.x)\n     ➎ min_y, max_y = min(min_y, point.y), max(max_y, point.y)\n\n ➏ return Rect(\n        Point(min_x, min_y),\n        Size(max_x - min_x, max_y - min_x)\n    )\n```", "```py\n--snip--\n\ndef make_rect_containing_with_margin(points: [Point], margin: float):\n ➊ rect = make_rect_containing(points)\n    return Rect(\n     ➋ Point(\n            rect.origin.x - margin,\n            rect.origin.y - margin\n        ),\n     ➌ Size(\n            2 * margin + rect.size.width,\n            2 * margin + rect.size.height\n        )\n    )\n```", "```py\n--snip--\n\ndef make_rect_centered(center: Point, width: float, height: float):\n    origin = Point(\n        center.x - width / 2,\n        center.y - height / 2\n    )\n    return Rect(origin, Size(width, height))\n```"]