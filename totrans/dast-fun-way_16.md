# 结论

![](img/chapterart.png)

在本书中，我们考察了各种不同的数据结构，它们如何影响使用它们的算法，以及它们是否能帮助我们在寻找咖啡的过程中。我们展示了数据的组织方式如何显著降低计算成本或改变算法的行为。我们研究了不同表示方法之间的权衡，以及它们为何重要。在此过程中，我们试图为如何思考数据结构提供直观的基础。

理解每种数据结构的动机、构造、用途和权衡对于在开发高效解决方案时使用它们至关重要。如果你随便选择一个看起来“足够好”的数据结构，你可能会遇到最坏情况并导致性能差。下面我们回顾前几章中的一些核心主题，突出每个计算机科学从业者在选择数据结构时应该提出的一些问题。

## 数据结构的影响是什么？

从第二章的二分查找开始，我们看到即使是对数据稍作结构化也能极大地提高算法的效率。数据中的结构使我们能够高效地访问值、聚合计算或修剪搜索空间的区域。就像在二分查找的例子中，数据的结构可以简单到将数据按顺序排序。这个单一的变化使我们能够将最坏情况的运行时间减少，使其与值的数量的关系从线性变化为对数。类似地，整理我们的咖啡储藏室也可以通过不同方式优化我们的咖啡制作体验——最常见的是减少制作第一杯咖啡所需的时间。

二叉搜索树、字典树、四叉树和 k-d 树向我们展示了如何进一步促进搜索过程中的修剪。基于树的数据结构提供了明确的分支组织，使我们能够通过简单的测试修剪掉搜索空间的大部分区域。我们将数据的边界编码到树的结构和节点中。此外，数据的分支特性使我们能够清楚地可视化每一层我们提出的问题：“在树中，给定位于此节点下方的点的边界，感兴趣的点是否可能位于此子树中？”

即使我们没有主动优化数据的组织方式以适应当前的算法，它的排列也会深刻影响算法的行为和效率，正如栈和队列所示。例如，从栈切换到队列会将搜索从深度优先转换为广度优先。在极端情况下，数据的结构要求我们开发全新的算法方法：图的连接性结构促使了许多新的算法的出现，用于搜索、排序和执行其他计算。

## 我们是否需要动态数据结构？

动态数据结构极大地提高了我们方法的灵活性和适应性。使用这些结构意味着我们不再受限于预先分配的内存块，这些内存块可能对当前任务来说太小。相反，我们可以通过指针将内存中的各个位置链接起来，从而使我们的数据结构根据需要进行扩展和收缩。最重要的是，动态数据结构使我们能够不断扩展我们的咖啡日志，并在我们的地理网格单元中存储多个咖啡店位置。

动态数据结构为计算机科学中一些最令人兴奋、有趣和强大的算法提供了基础。本书中描述的几乎所有数据结构都利用了指针（或相关的链接）来组织跨不同内存块的数据。我们使用指针将二叉搜索树中的节点连接起来，在我们的网格单元和哈希表桶中创建链表，并表示图的结构。

这种强大和灵活性的权衡是访问数据时的额外复杂性。在数组中，我们可以根据索引查找任何项。然而，一旦涉及指针，这种直接的方法就不再适用。我们必须通过内存中的指针链来查找特定的数据，无论是通过链表的节点、树的节点，还是图中的节点。根据这些指针的排列方式（链表与搜索树），我们可能会使操作变得更加高效或低效。我们始终需要理解算法如何使用结构。仅仅购买一台昂贵的咖啡机是不够的；我们需要理解如何使用它。

## 什么是摊销成本？

在考虑是否使用某种数据结构时，重要的是要同时考虑构建数据结构的成本和它将带来的节省。排序一个数组或构建一个二叉搜索树的成本可能比扫描数据以查找单个值更高。几乎总是情况下，逐一搜索每个数据点比构建辅助数据结构更高效。然而，随着我们进行多次搜索，数学模型会发生变化。

排序数组、二叉搜索树和其他数据结构之所以有用，是因为它们减少了*所有*未来搜索的成本。如果我们支付一次性的*N* log2 成本来对整数数组进行排序，那么我们就可以执行尽可能多的 log2 二叉搜索。我们之所以能受益，是因为我们将排序数据的成本摊销到了未来的多次搜索中。同样，通过过期日期排序冰箱中的牛奶盒，也可以在取用时节省宝贵的几秒钟。

## 我们如何将数据结构适应于特定问题？

基本数据结构不仅提供了一套有用的工具，而且为构建更具适应性和专用性的方案奠定了基础。通过前缀树，我们研究了如何将二叉搜索树的分支结构扩展为更高的分支因子，从而实现对字符串的高效搜索。我们还看到，链表为哈希表中的碰撞处理或网格单元中的多个项提供了第二层灵活性。

空间数据结构很好地展示了我们适应、组合和优化数据结构的能力。将网格的空间分区与基于树的结构结合，给我们带来了自适应结构四叉树。然而，网格和四叉树在高维度时会失效。我们看到，k-d 树通过在每个分支上沿单一维度进行分割，适应了空间数据结构，不仅帮助结构扩展到更高维度，还提高了剪枝能力。在我们考虑新的与咖啡相关的问题时，如匹配标志或优化我们的冲泡设备参数，我们应该重新审视并可能将工具箱中的方法适配到问题的具体需求上。

## 什么是内存与运行时间的权衡？

内存与运行时间的权衡是计算机科学中的经典考虑因素。通过预计算和存储额外数据，我们通常可以显著降低算法的成本。堆数据结构让我们能够高效地找到并提取列表中的最小（或最大）元素，无论是在搜索算法中，还是作为辅助数据结构。其权衡在于堆本身的开销。我们在存储数据时，会使用与数据大小呈线性关系的额外内存。类似地，通过使用额外内存构建四叉树或 k-d 树，我们可以大幅减少未来最近邻搜索的运行时间。

即使在数据结构内部，这种权衡依然存在。我们可以通过增加哈希表的大小来降低碰撞率。在链表中存储额外的信息使我们能够实现跳表，从而为搜索提供更好的平均性能。类似地，预计算空间树节点的边界并将其存储在节点中，可能让我们更高效地测试是否可以剪枝某个节点。

理解这些权衡并将其适应于特定项目的环境至关重要。你正在编写的视频游戏是运行在个人计算机、移动设备，还是数据中心的大型服务器上？低内存环境可能需要与高内存环境不同的方法。我们的咖啡储藏室的大小不仅会影响我们可以存储的咖啡总量，还会影响是否值得添加色彩鲜艳的分隔条。在一个大储藏室中——比如一个改造的卧室——分隔条可能帮助我们更快地找到咖啡。在一个小储藏室里，比如厨房柜子，分隔条可能只是浪费了宝贵的架子空间。

## 我们如何调整我们的数据结构？

一些数据结构具有对操作性能影响很大的参数。网格在最近邻搜索中的性能高度依赖于网格单元的数量和粒度。类似地，B 树的大小参数*k*使我们能够将每个节点的大小调整到我们的本地内存。这些参数几乎总是依赖于我们使用数据结构的上下文。没有一种完美的设置。

了解数据结构的参数如何影响性能，以及它们如何依赖于问题的具体情况是很重要的。在某些情况下，我们可以通过分析确定使用什么参数。例如，我们可以使用关于设备上内存块大小的信息来选择 B 树的大小参数*k*，使得一个完整的 B 树节点恰好适合内存块，从而允许我们通过一次访问检索最多的数据。

有时，我们可能需要在真实数据上实证测试不同的参数。一个简单的方法是使用具有一系列参数设置的数据，看看哪一种性能最好。

## 随机化如何影响预期行为？

在检查二叉搜索树和哈希表时，我们注意到这两种数据结构的最坏情况性能可能会降级为线性时间。如果我们将有序项插入二叉搜索树，或为数据选择了一个糟糕的哈希函数，我们最终实际上就得到了链表。在所有情况下，数据结构的性能并不一定能保证最优，而是取决于数据本身。有时我们能做的最好的是提高期望（或平均情况）运行时。

理解极端性能的可能性对于选择和调整适合问题的数据结构至关重要。在选择哈希表的参数时，我们希望选择一个足够大的表大小，以降低碰撞的概率，同时避免浪费内存。更为关键的是哈希函数的选择，对于哈希表来说，这要求我们理解键的分布。如果键本身具有某种结构，比如仅由偶数组成，我们需要选择一个能够抵抗这种结构的哈希函数。同样，如果我们为一群姓氏以*K*开头的咖啡爱好者组织会议，注册表就不应根据姓氏的第一个字母来划分与会者。

我们可以通过对数据结构本身进行随机化来在一定程度上缓解病态数据的影响。如果我们总是按排序顺序将数据添加到二叉搜索树中，最终我们实际上得到的是一个链表。跳表提供了一种技术，通过故意向列表节点的层级中注入随机性，从而平均实现对数级的运行时间。不过，随机化并不是万能的。跳表可能会因偶然原因选择不佳的高度。在最坏的情况下，像链表一样，跳表的性能会退化为与数据大小成线性关系。然而，它们出现这种情况的概率较小，我们可以预期它们在面对病态数据时仍能表现良好。

## 为什么这很重要

在计算机科学中，没有一种完美的数据结构。如果我们能指着某个数据结构说，“永远使用 X”，那该多好，但遗憾的是，这并非那么简单。所有数据结构都有各自的复杂性、性能、内存使用和准确性的权衡。

在本书中，我们探讨了不同数据结构的一些样本，它们的权衡取舍，以及这些结构如何影响算法。我们的覆盖面远未穷尽；还有许多数据结构针对特定算法、问题或领域进行了进一步优化。例如，红黑树提供了二叉搜索树的自平衡扩展，而度量树为高维数据提供了不同的空间划分方法。这两种方法，以及其他数百种令人印象深刻的数据结构，都有各自的权衡和最佳应用场景。我们只是略微触及了数据结构这一丰富而复杂的领域。

本书旨在鼓励你认真思考如何存储和组织数据。与特定的编程语言或巧妙的算法一样，数据结构对程序的性能、准确性和复杂性具有重要影响。对于所有计算机科学从业者来说，理解每个数据结构的具体内容非常重要，但同样重要的是理解这些数据结构如何在它们试图解决的更广泛问题的背景下发挥作用。

尤其是如果涉及到咖啡的话。
