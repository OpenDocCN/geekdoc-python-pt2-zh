- en: 'Lists work in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> myList = [10, 20, 30, 40]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(type(myList))'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'list'>
  prefs: []
  type: TYPE_NORMAL
- en: All lists are instances of the list class, which has many methods includ-
  prefs: []
  type: TYPE_NORMAL
- en: ing myList.append(), myList.count(), myList.index(), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a class, you are defining a new data type. Your code
  prefs: []
  type: TYPE_NORMAL
- en: provides the details by defining what data it maintains and what operations
  prefs: []
  type: TYPE_NORMAL
- en: it can perform. After creating an instance of your class and assigning it to
  prefs: []
  type: TYPE_NORMAL
- en: a variable, you can use the type() built-in function to determine the class
  prefs: []
  type: TYPE_NORMAL
- en: used to create it, just like with a built-in data type. Here we instantiate
    a
  prefs: []
  type: TYPE_NORMAL
- en: 'LightSwitch object and print out its data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> oLightSwitch = LightSwitch()'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(type(oLightSwitch))'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'LightSwitch'>
  prefs: []
  type: TYPE_NORMAL
- en: '**32** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: Just like with Python’s built-in data types, we can then use the variable oLightSwitch
    to call the methods available in the oLightSwitch class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Definition of an Object***'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this section, I’ll give my formal definition of an *object*.
  prefs: []
  type: TYPE_NORMAL
- en: '**object**'
  prefs: []
  type: TYPE_NORMAL
- en: Data, plus code that acts on that data, over time .
  prefs: []
  type: TYPE_NORMAL
- en: A class defines what an object will look like when you instantiate one.
  prefs: []
  type: TYPE_NORMAL
- en: An object is a set of instance variables and the code of the methods in the
  prefs: []
  type: TYPE_NORMAL
- en: class from which the object was instantiated. Any number of objects can
  prefs: []
  type: TYPE_NORMAL
- en: be instantiated from a class, and each has its own set of instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a method of an object, the method runs and uses the set of
  prefs: []
  type: TYPE_NORMAL
- en: instance variables in that object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Slightly More Complicated Class**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build on the concepts introduced so far and work through a second,
  prefs: []
  type: TYPE_NORMAL
- en: slightly more complicated example in which we’ll make a dimmer switch
  prefs: []
  type: TYPE_NORMAL
- en: class. A dimmer switch has an on/off switch, but it also has a multiposition
  prefs: []
  type: TYPE_NORMAL
- en: slider that affects the brightness of the light.
  prefs: []
  type: TYPE_NORMAL
- en: The slider can move through a range of brightness values. To make
  prefs: []
  type: TYPE_NORMAL
- en: things straightforward, our dimmer digital slider has 11 positions, from 0
  prefs: []
  type: TYPE_NORMAL
- en: (completely off) through 10 (completely on). To raise or lower the bright-
  prefs: []
  type: TYPE_NORMAL
- en: ness of the bulb to the maximum extent, you must move the slider through
  prefs: []
  type: TYPE_NORMAL
- en: every possible setting.
  prefs: []
  type: TYPE_NORMAL
- en: This DimmerSwitch class has more functionality than our LightSwitch class
  prefs: []
  type: TYPE_NORMAL
- en: 'and needs to remember more data:'
  prefs: []
  type: TYPE_NORMAL
- en: • The switch state (on or off)
  prefs: []
  type: TYPE_NORMAL
- en: • Brightness level (0 to 10)
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are the behaviors a DimmerSwitch object can perform:'
  prefs: []
  type: TYPE_NORMAL
- en: • Turn on
  prefs: []
  type: TYPE_NORMAL
- en: • Turn off
  prefs: []
  type: TYPE_NORMAL
- en: • Raise level
  prefs: []
  type: TYPE_NORMAL
- en: • Lower level
  prefs: []
  type: TYPE_NORMAL
- en: • Show (for debugging)
  prefs: []
  type: TYPE_NORMAL
- en: The DimmerSwitch class uses the standard template shown earlier in
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 2-2: it starts with a class statement and a first method named'
  prefs: []
  type: TYPE_NORMAL
- en: __init__(), then defines a number of additional methods, one for each of
  prefs: []
  type: TYPE_NORMAL
- en: the behaviors listed. The full code for this class is presented in Listing 2-5\.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **33**
  prefs: []
  type: TYPE_NORMAL
- en: '**File: DimmerSwitch.py**'
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class DimmerSwitch():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.switchIsOn = False
  prefs: []
  type: TYPE_NORMAL
- en: self.brightness = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'def turnOn(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.switchIsOn = True
  prefs: []
  type: TYPE_NORMAL
- en: 'def turnOff(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.switchIsOn = False
  prefs: []
  type: TYPE_NORMAL
- en: 'def raiseLevel(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.brightness < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: self.brightness = self.brightness + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'def lowerLevel(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.brightness > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: self.brightness = self.brightness - 1
  prefs: []
  type: TYPE_NORMAL
- en: Extra method for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def show(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(Switch is on?', self.switchIsOn)
  prefs: []
  type: TYPE_NORMAL
- en: print('Brightness is:', self.brightness)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-5: The slightly more complicated DimmerSwitch class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this __init__() method we have two instance variables: the famil-'
  prefs: []
  type: TYPE_NORMAL
- en: iar self.switchIsOn and a new one, self.brightness, which remembers the
  prefs: []
  type: TYPE_NORMAL
- en: brightness level. We assign starting values to both instance variables. All
  prefs: []
  type: TYPE_NORMAL
- en: other methods can access the current value of each of these. In addition
  prefs: []
  type: TYPE_NORMAL
- en: 'to turnOn() and turnOff(), we include two new methods for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: raiseLevel() and lowerLevel(), which do exactly what their names imply.
  prefs: []
  type: TYPE_NORMAL
- en: The show() method is used during development and debugging and just
  prefs: []
  type: TYPE_NORMAL
- en: prints the current values of the instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: The main code in Listing 2-6 tests our class by creating a DimmerSwitch
  prefs: []
  type: TYPE_NORMAL
- en: object (oDimmer), then calling the various methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_DimmerSwitch_with_Test_Code.py**'
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch class with test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class DimmerSwitch():'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snipped code of DimmerSwitch class, as in Listing 2-5 ---'
  prefs: []
  type: TYPE_NORMAL
- en: Main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer = DimmerSwitch()
  prefs: []
  type: TYPE_NORMAL
- en: Turn switch on, and raise the level 5 times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**34** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.show()
  prefs: []
  type: TYPE_NORMAL
- en: Lower the level 2 times, and turn switch off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer.lowerLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.lowerLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.turnOff()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.show()
  prefs: []
  type: TYPE_NORMAL
- en: Turn switch on, and raise the level 3 times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer.turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer.show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-6: DimmerSwitch class with test code*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this code, the resulting output is:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch is on? True
  prefs: []
  type: TYPE_NORMAL
- en: 'Brightness is: 5'
  prefs: []
  type: TYPE_NORMAL
- en: Switch is on? False
  prefs: []
  type: TYPE_NORMAL
- en: 'Brightness is: 3'
  prefs: []
  type: TYPE_NORMAL
- en: Switch is on? True
  prefs: []
  type: TYPE_NORMAL
- en: 'Brightness is: 6'
  prefs: []
  type: TYPE_NORMAL
- en: The main code creates the oDimmer object, then makes calls to the vari-
  prefs: []
  type: TYPE_NORMAL
- en: ous methods. Each time we call the show() method, the on/off state and the
  prefs: []
  type: TYPE_NORMAL
- en: brightness level are printed. The key thing to remember here is that oDimmer
  prefs: []
  type: TYPE_NORMAL
- en: represents an object. It allows access to all methods in the class from which
  prefs: []
  type: TYPE_NORMAL
- en: it was instantiated (the DimmerSwitch class), *and* it has a set of all instance
    variables defined in the class (self.switchIsOn and self.brightness). Again,
  prefs: []
  type: TYPE_NORMAL
- en: instance variables maintain their values between calls to methods of an
  prefs: []
  type: TYPE_NORMAL
- en: object, so the self.brightness instance variable is incremented by 1 for each
  prefs: []
  type: TYPE_NORMAL
- en: call to oDimmer.raiseLevel().
  prefs: []
  type: TYPE_NORMAL
- en: '**Representing a More Complicated Physical Object as a Class**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a more complicated physical object: a television. With this'
  prefs: []
  type: TYPE_NORMAL
- en: more complicated example, we’ll take a closer look at how arguments work
  prefs: []
  type: TYPE_NORMAL
- en: in classes.
  prefs: []
  type: TYPE_NORMAL
- en: A television requires much more data than a light switch to represent
  prefs: []
  type: TYPE_NORMAL
- en: its state, and it has more behaviors. To create a TV class, we must consider
  prefs: []
  type: TYPE_NORMAL
- en: how a user would typically use a TV and what the TV would have to remem-
  prefs: []
  type: TYPE_NORMAL
- en: ber. Let’s look at some of the important buttons on a typical TV remote
  prefs: []
  type: TYPE_NORMAL
- en: (Figure 2-4).
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **35**
  prefs: []
  type: TYPE_NORMAL
- en: Power
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  prefs: []
  type: TYPE_NORMAL
- en: Channel
  prefs: []
  type: TYPE_NORMAL
- en: Mute
  prefs: []
  type: TYPE_NORMAL
- en: Get Info
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-4: A simplified TV remote*'
  prefs: []
  type: TYPE_NORMAL
- en: From this, we can determine that to keep track of its state, a TV class
  prefs: []
  type: TYPE_NORMAL
- en: 'would have to maintain the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: • Power state (on or off)
  prefs: []
  type: TYPE_NORMAL
- en: • Mute state (is it muted?)
  prefs: []
  type: TYPE_NORMAL
- en: • List of channels available
  prefs: []
  type: TYPE_NORMAL
- en: • Current channel setting
  prefs: []
  type: TYPE_NORMAL
- en: • Current volume setting
  prefs: []
  type: TYPE_NORMAL
- en: • Range of volume levels available
  prefs: []
  type: TYPE_NORMAL
- en: 'And the actions that the TV must provide include:'
  prefs: []
  type: TYPE_NORMAL
- en: • Turn the power on and off
  prefs: []
  type: TYPE_NORMAL
- en: • Raise and lower the volume
  prefs: []
  type: TYPE_NORMAL
- en: • Change the channel up and down
  prefs: []
  type: TYPE_NORMAL
- en: • Mute and unmute the sound
  prefs: []
  type: TYPE_NORMAL
- en: • Get information about the current settings
  prefs: []
  type: TYPE_NORMAL
- en: • Go to a specified channel
  prefs: []
  type: TYPE_NORMAL
- en: '**36** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: The code for our TV class is shown in Listing 2-7\. We include the __init__()
    method for initialization, followed by a method for each of the behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: TV.py**'
  prefs: []
  type: TYPE_NORMAL
- en: TV class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class TV():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self): 1'
  prefs: []
  type: TYPE_NORMAL
- en: self.isOn = False
  prefs: []
  type: TYPE_NORMAL
- en: self.isMuted = False
  prefs: []
  type: TYPE_NORMAL
- en: Some default list of channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.channelList = [2, 4, 5, 7, 9, 11, 20, 36, 44, 54, 65]
  prefs: []
  type: TYPE_NORMAL
- en: self.nChannels = len(self.channelList)
  prefs: []
  type: TYPE_NORMAL
- en: self.channelIndex = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'self.VOLUME_MINIMUM = 0 # constant'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.VOLUME_MAXIMUM = 10 # constant'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.volume = self.VOLUME_MAXIMUM // # integer divide'
  prefs: []
  type: TYPE_NORMAL
- en: 'def power(self): 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.isOn = not self.isOn # toggle'
  prefs: []
  type: TYPE_NORMAL
- en: 'def volumeUp(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.isMuted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.isMuted = False # changing the volume while muted unmutes the sound'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.volume < self.VOLUME_MAXIMUM:'
  prefs: []
  type: TYPE_NORMAL
- en: self.volume = self.volume + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'def volumeDown(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.isMuted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.isMuted = False # changing the volume while muted unmutes the sound'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.volume > self.VOLUME_MINIMUM:'
  prefs: []
  type: TYPE_NORMAL
- en: self.volume = self.volume - 1
  prefs: []
  type: TYPE_NORMAL
- en: 'def channelUp(self): 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: self.channelIndex = self.channelIndex + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.channelIndex > self.nChannels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.channelIndex = 0 # wrap around to the first channel'
  prefs: []
  type: TYPE_NORMAL
- en: 'def channelDown(self): 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: self.channelIndex = self.channelIndex - 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.channelIndex < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.channelIndex = self.nChannels - 1 # wrap around to the top channel'
  prefs: []
  type: TYPE_NORMAL
- en: 'def mute(self): 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **37**
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: self.isMuted = not self.isMuted
  prefs: []
  type: TYPE_NORMAL
- en: 'def setChannel(self, newChannel):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if newChannel in self.channelList:'
  prefs: []
  type: TYPE_NORMAL
- en: self.channelIndex = self.channelList.index(newChannel)
  prefs: []
  type: TYPE_NORMAL
- en: if the newChannel is not in our list of channels, don't do anything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def showInfo(self): 6'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('TV Status:')
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print('' TV is: On'')'
  prefs: []
  type: TYPE_NORMAL
- en: print(' Channel is:', self.channelList[self.channelIndex])
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.isMuted:'
  prefs: []
  type: TYPE_NORMAL
- en: print(' Volume is:', self.volume, '(sound is muted)')
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(' Volume is:', self.volume)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print('' TV is: Off'')'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-7: The TV class with many instance variables and methods*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method 1 creates all the instance variables used in all the
  prefs: []
  type: TYPE_NORMAL
- en: methods and assigns reasonable starting values to each. Technically, you can
  prefs: []
  type: TYPE_NORMAL
- en: create an instance variable inside any method; however, it is a good program-
  prefs: []
  type: TYPE_NORMAL
- en: ming practice to define all instance variables in the __init__() method. This
  prefs: []
  type: TYPE_NORMAL
- en: avoids the risk of an error when attempting to use an instance variable in a
  prefs: []
  type: TYPE_NORMAL
- en: method before it’s been defined.
  prefs: []
  type: TYPE_NORMAL
- en: The power() method 2 represents what happens when you push the
  prefs: []
  type: TYPE_NORMAL
- en: power button on a remote. If the TV is off, pushing the power button turns
  prefs: []
  type: TYPE_NORMAL
- en: it on; if the TV is on, pushing the power button turns it off. To code this
  prefs: []
  type: TYPE_NORMAL
- en: behavior I’ve used a *toggle*, which is a Boolean that’s used to represent one
    of two states and can easily be switched between them. With this toggle, the
  prefs: []
  type: TYPE_NORMAL
- en: not operator switches the self.isOn variable from True to False, or from False
  prefs: []
  type: TYPE_NORMAL
- en: to True. The mute() method code 5 does a similar thing, with the self.muted
  prefs: []
  type: TYPE_NORMAL
- en: variable toggling between muted and not-muted, but first has to check that
  prefs: []
  type: TYPE_NORMAL
- en: the TV is on. If the TV is off, calling the mute() method has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting thing to note is that we don’t really keep track of
  prefs: []
  type: TYPE_NORMAL
- en: the current channel. Instead, we keep track of the *index* of the current
  prefs: []
  type: TYPE_NORMAL
- en: channel, which allows us to get the current channel at any time by using
  prefs: []
  type: TYPE_NORMAL
- en: self.channelList[self.channelIndex].
  prefs: []
  type: TYPE_NORMAL
- en: The channelUp() 3 and channelDown() 4 methods basically increment and
  prefs: []
  type: TYPE_NORMAL
- en: decrement the channel index, but there is also some clever code in them to
  prefs: []
  type: TYPE_NORMAL
- en: allow for wrap-around. If you’re currently at the last index in the channel
    list
  prefs: []
  type: TYPE_NORMAL
- en: and the user asks to go to the next channel up, the TV goes to the first chan-
  prefs: []
  type: TYPE_NORMAL
- en: nel in the list. If you’re at the first index in the channel list and the user
    asks to go the next channel down, the TV goes to the last channel in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The showInfo() method 6 prints out the current status of the TV based
  prefs: []
  type: TYPE_NORMAL
- en: on the values of the instance variables (on/off, current channel, current
  prefs: []
  type: TYPE_NORMAL
- en: volume setting, and mute setting).
  prefs: []
  type: TYPE_NORMAL
- en: '**38** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 2-8, we’ll create a TV object and call methods of that object.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_TV_with_Test_Code.py**'
  prefs: []
  type: TYPE_NORMAL
- en: TV class with test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snipped code of TV class, as in Listing 2-7 ---'
  prefs: []
  type: TYPE_NORMAL
- en: Main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'oTV = TV() # create the TV object'
  prefs: []
  type: TYPE_NORMAL
- en: Turn the TV on and show the status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV.power()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: Change the channel up twice, raise the volume twice, show status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV.channelUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.channelUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: Turn the TV off, show status, turn the TV on, show status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV.power()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.power()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: Lower the volume, mute the sound, show status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV.volumeDown()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.mute()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: Change the channel to 11, mute the sound, show status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV.setChannel(11)
  prefs: []
  type: TYPE_NORMAL
- en: oTV.mute()
  prefs: []
  type: TYPE_NORMAL
- en: oTV.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-8: TV class with test code*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this code, here is what we get as output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV Status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV Status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV Status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: Off'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **39**
  prefs: []
  type: TYPE_NORMAL
- en: 'TV Status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV Status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 6 (sound is muted)'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV Status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 11'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 6'
  prefs: []
  type: TYPE_NORMAL
- en: All of the methods are working correctly, and we get the expected
  prefs: []
  type: TYPE_NORMAL
- en: output.
  prefs: []
  type: TYPE_NORMAL
- en: '***Passing Arguments to a Method***'
  prefs: []
  type: TYPE_NORMAL
- en: When calling any function, the number of arguments must match the num-
  prefs: []
  type: TYPE_NORMAL
- en: 'ber of parameters listed in the matching def statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def myFunction(param1, param2, param3):'
  prefs: []
  type: TYPE_NORMAL
- en: body of function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'call to a function:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: myFunction(argument1, argument2, argument3)
  prefs: []
  type: TYPE_NORMAL
- en: The same rule applies with methods and method calls. However, you
  prefs: []
  type: TYPE_NORMAL
- en: may notice that whenever we make a call to a method, it appears that we are
  prefs: []
  type: TYPE_NORMAL
- en: specifying one less argument than the number of parameters. For example,
  prefs: []
  type: TYPE_NORMAL
- en: 'the definition of the power() method in our TV class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def power(self):'
  prefs: []
  type: TYPE_NORMAL
- en: This implies that the power() method is expecting one value to be
  prefs: []
  type: TYPE_NORMAL
- en: passed in and whatever is passed in will be assigned to the variable self. Yet
  prefs: []
  type: TYPE_NORMAL
- en: 'when we started by turning on the TV in Listing 2-8, we made this call:'
  prefs: []
  type: TYPE_NORMAL
- en: oTV.power()
  prefs: []
  type: TYPE_NORMAL
- en: When we make the call, we don’t explicitly pass anything inside the
  prefs: []
  type: TYPE_NORMAL
- en: parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem even stranger in the case of the setChannel() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method is written to accept two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setchannel(self, newchannel):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if newChannel in self.channelList:'
  prefs: []
  type: TYPE_NORMAL
- en: self.channelIndex = self.channelList.index(newChannel)
  prefs: []
  type: TYPE_NORMAL
- en: '**40** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we called setChannel() like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oTV.setChannel(11)
  prefs: []
  type: TYPE_NORMAL
- en: It appears that only one value is being passed in.
  prefs: []
  type: TYPE_NORMAL
- en: You might expect Python to generate an error here, due to a mismatch
  prefs: []
  type: TYPE_NORMAL
- en: in the number of arguments (one) and the number of parameters (two). In
  prefs: []
  type: TYPE_NORMAL
- en: practice, Python is doing a bit of behind-the-scenes work to make the syntax
  prefs: []
  type: TYPE_NORMAL
- en: easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine this. Earlier, I said that to make a call to a method of an
  prefs: []
  type: TYPE_NORMAL
- en: 'object, you use the following generic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<object>* . *<method>* ( *<any arguments>* )'
  prefs: []
  type: TYPE_NORMAL
- en: Python takes the <object> you specify in the call and rearranges it to
  prefs: []
  type: TYPE_NORMAL
- en: become the first argument. Any values in the parentheses of the method
  prefs: []
  type: TYPE_NORMAL
- en: call are considered the subsequent argument(s). Thus, Python makes it
  prefs: []
  type: TYPE_NORMAL
- en: 'appear that you wrote this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<method of object>* ( *<object>* , *<any arguments>* ) Figure 2-5 shows how
    this works in our example code, again using the'
  prefs: []
  type: TYPE_NORMAL
- en: setChannel() method of the TV class.
  prefs: []
  type: TYPE_NORMAL
- en: Method in the TV class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**def setChannel(self, newChannel):**'
  prefs: []
  type: TYPE_NORMAL
- en: '**…**'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call'
  prefs: []
  type: TYPE_NORMAL
- en: '**oTV.setChannel(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**V**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-5: Cal ing a method*'
  prefs: []
  type: TYPE_NORMAL
- en: Although it looks like we’re only providing one argument here (for
  prefs: []
  type: TYPE_NORMAL
- en: newChannel), there are really two arguments passed in—oTV and 11—and the
  prefs: []
  type: TYPE_NORMAL
- en: method provides two parameters to receive these values (self and newChannel,
  prefs: []
  type: TYPE_NORMAL
- en: respectively). Python rearranges the arguments for us when the call is
  prefs: []
  type: TYPE_NORMAL
- en: made. This may seem odd at first, but it will become second nature very
  prefs: []
  type: TYPE_NORMAL
- en: quickly. Writing the call with the object first makes it much easier for a
  prefs: []
  type: TYPE_NORMAL
- en: programmer to see which object is being acted on.
  prefs: []
  type: TYPE_NORMAL
- en: This is a subtle but important feature. Remember that the object (in
  prefs: []
  type: TYPE_NORMAL
- en: this case, oTV) keeps the current settings of all of its instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the object as the first argument allows the method to run with the
  prefs: []
  type: TYPE_NORMAL
- en: values of the instance variables of that object.
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiple Instances***'
  prefs: []
  type: TYPE_NORMAL
- en: Every method is written with self as the first parameter, so the self variable
  prefs: []
  type: TYPE_NORMAL
- en: 'receives the object used in each call. This has a major implication: it allows'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **41**
  prefs: []
  type: TYPE_NORMAL
- en: any method within a class to work with *different* objects. I’ll explain how
    this works using an example.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 2-9, we’ll create two TV objects and save them in two variables,
  prefs: []
  type: TYPE_NORMAL
- en: oTV1 and oTV2\. Each TV object has a volume setting, a channel list, a channel
  prefs: []
  type: TYPE_NORMAL
- en: setting, and so on. We’ll make calls to a number of different methods of
  prefs: []
  type: TYPE_NORMAL
- en: the different objects. At the end, we’ll call the showInfo() method on each
    TV
  prefs: []
  type: TYPE_NORMAL
- en: object to see the resulting settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_TV_TwoInstances.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Two TV objects with calls to their methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class TV():'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snipped code of TV class, as in Listing 2-7 ---'
  prefs: []
  type: TYPE_NORMAL
- en: Main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'oTV1 = TV() # create one TV object'
  prefs: []
  type: TYPE_NORMAL
- en: 'oTV2 = TV() # create another TV object'
  prefs: []
  type: TYPE_NORMAL
- en: Turn both TVs on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV1.power()
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.power()
  prefs: []
  type: TYPE_NORMAL
- en: Raise the volume of TV1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV1.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV1.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: Raise the volume of TV2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV2.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.volumeUp()
  prefs: []
  type: TYPE_NORMAL
- en: Change TV2's channel, then mute it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV2.setChannel(44)
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.mute()
  prefs: []
  type: TYPE_NORMAL
- en: Now display both TVs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oTV1.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: oTV2.showInfo()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-9: Creating two instances of the TV class and cal ing methods of
    each* If we run this code, it will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status of TV:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status of TV:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 44'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 10 (sound is muted)'
  prefs: []
  type: TYPE_NORMAL
- en: '**42** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: Each TV object maintains its own set of the instance variables defined in the
    class. This way, each TV object’s instance variables can be manipulated
  prefs: []
  type: TYPE_NORMAL
- en: independently of those of any other TV object.
  prefs: []
  type: TYPE_NORMAL
- en: '***Initialization Parameters***'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to pass arguments to method calls also works when instantiat-
  prefs: []
  type: TYPE_NORMAL
- en: ing an object. So far, when we’ve created our objects, we’ve always set their
  prefs: []
  type: TYPE_NORMAL
- en: instance variables to constant values. However, you’ll often want to create
  prefs: []
  type: TYPE_NORMAL
- en: different instances with different starting values. For example, imagine we
  prefs: []
  type: TYPE_NORMAL
- en: want to instantiate different TVs and identify them using their brand name
  prefs: []
  type: TYPE_NORMAL
- en: and location. This way, we can differentiate between a Samsung television
  prefs: []
  type: TYPE_NORMAL
- en: in the family room and a Sony television in the bedroom. Constant values
  prefs: []
  type: TYPE_NORMAL
- en: would not work for us in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize an object with different values, we add parameters to the
  prefs: []
  type: TYPE_NORMAL
- en: 'definition of the __init__() method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: TV class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class TV():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, brand, location): # pass in a brand and location for the
    TV'
  prefs: []
  type: TYPE_NORMAL
- en: self.brand = brand
  prefs: []
  type: TYPE_NORMAL
- en: self.location = location
  prefs: []
  type: TYPE_NORMAL
- en: '--- snipped remaining initialization of TV ---'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: In all methods, parameters are local variables, so they literally go away
  prefs: []
  type: TYPE_NORMAL
- en: when the method ends. For example, in the __init__() method of the TV
  prefs: []
  type: TYPE_NORMAL
- en: class shown here, brand and location are local variables that will disappear
  prefs: []
  type: TYPE_NORMAL
- en: when the method ends. However, we often want to save values that are
  prefs: []
  type: TYPE_NORMAL
- en: passed in via parameters to use them in other methods.
  prefs: []
  type: TYPE_NORMAL
- en: In order to allow an object to remember initial values, the standard
  prefs: []
  type: TYPE_NORMAL
- en: approach is to store any values passed in into instance variables. Since
  prefs: []
  type: TYPE_NORMAL
- en: instance variables have object scope, they can be used in other methods in
  prefs: []
  type: TYPE_NORMAL
- en: the class. The Python convention is that the name of the instance variable
  prefs: []
  type: TYPE_NORMAL
- en: should be the same as the parameter name, but prefixed with self and a
  prefs: []
  type: TYPE_NORMAL
- en: 'period:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, someVariableName):'
  prefs: []
  type: TYPE_NORMAL
- en: self.someVariableName = someVariableName
  prefs: []
  type: TYPE_NORMAL
- en: In the TV class, the line after the def statement tells Python to take the
  prefs: []
  type: TYPE_NORMAL
- en: value of the brand parameter and assign it to an instance variable named
  prefs: []
  type: TYPE_NORMAL
- en: self.brand. The next line does the same thing with the location parameter
  prefs: []
  type: TYPE_NORMAL
- en: and the instance variable self.location. After these assignments, we can use
  prefs: []
  type: TYPE_NORMAL
- en: self.brand and self.location in other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **43**
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, we can create multiple objects from the same class but
    start each off with different data. So, we can create our two TV objects
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oTV1 = TV('Samsung', 'Family room')
  prefs: []
  type: TYPE_NORMAL
- en: oTV2 = TV('Sony', 'Bedroom')
  prefs: []
  type: TYPE_NORMAL
- en: When executing the first line, Python first allocates space for a TV
  prefs: []
  type: TYPE_NORMAL
- en: object. Then it rearranges the arguments as discussed in the previous sec-
  prefs: []
  type: TYPE_NORMAL
- en: 'tion and calls the __init__() method of the TV class with three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: the newly allocated oTV1 object, the brand, and the location.
  prefs: []
  type: TYPE_NORMAL
- en: When initializing the oTV1 object, self.brand is set to the string 'Samsung'
  prefs: []
  type: TYPE_NORMAL
- en: and self.location is set to the string 'Family room'. When initializing oTV2,
  prefs: []
  type: TYPE_NORMAL
- en: its self.brand is set to the string 'Sony', and its self.location gets set to
    the
  prefs: []
  type: TYPE_NORMAL
- en: string 'Bedroom'.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify the showInfo() method to report the name and location
  prefs: []
  type: TYPE_NORMAL
- en: of the TV.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_TV_TwoInstances_with_Init_Params.py**'
  prefs: []
  type: TYPE_NORMAL
- en: 'def showInfo(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('Status of TV:', self.brand)
  prefs: []
  type: TYPE_NORMAL
- en: print(' Location:', self.location)
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.isOn:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we’ll see this as output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status of TV: Sony'
  prefs: []
  type: TYPE_NORMAL
- en: 'Location: Family room'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status of TV: Samsung'
  prefs: []
  type: TYPE_NORMAL
- en: 'Location: Bedroom'
  prefs: []
  type: TYPE_NORMAL
- en: 'TV is: On'
  prefs: []
  type: TYPE_NORMAL
- en: 'Channel is: 44'
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume is: 10 (sound is muted)'
  prefs: []
  type: TYPE_NORMAL
- en: We made the same method calls as in the previous example in
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2-9\. The difference is that each TV object is now initialized with
    a
  prefs: []
  type: TYPE_NORMAL
- en: brand and a location, and you can now see that information printed in
  prefs: []
  type: TYPE_NORMAL
- en: response to each call to the modified showInfo() method.
  prefs: []
  type: TYPE_NORMAL
- en: '**44** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes in Use**'
  prefs: []
  type: TYPE_NORMAL
- en: Using everything we’ve learned in this chapter, we can now create classes
  prefs: []
  type: TYPE_NORMAL
- en: and build multiple independent instances from those classes. Here are a
  prefs: []
  type: TYPE_NORMAL
- en: 'few examples of how we might use this:'
  prefs: []
  type: TYPE_NORMAL
- en: • Say we wanted to model a student in a course. We could have a Student
  prefs: []
  type: TYPE_NORMAL
- en: class that has instance variables for name, emailAddress, currentGrade, and
  prefs: []
  type: TYPE_NORMAL
- en: so on. Each Student object we create from this class would have its own
  prefs: []
  type: TYPE_NORMAL
- en: set of these instance variables, and the values given to the instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: ables would be different for each student.
  prefs: []
  type: TYPE_NORMAL
- en: • Consider a game where we have multiple players. A player could be
  prefs: []
  type: TYPE_NORMAL
- en: modeled by a Player class with instance variables for name, points, health,
  prefs: []
  type: TYPE_NORMAL
- en: location, and so on. Each player would have the same capabilities, but
  prefs: []
  type: TYPE_NORMAL
- en: the methods could work differently based on the different values in the
  prefs: []
  type: TYPE_NORMAL
- en: instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: • Imagine an address book. We could create a Person class with instance
  prefs: []
  type: TYPE_NORMAL
- en: variables for name, address, phoneNumber, and birthday. We could create
  prefs: []
  type: TYPE_NORMAL
- en: as many objects from the Person class as we want, one for each person
  prefs: []
  type: TYPE_NORMAL
- en: we know. The instance variables in each Person object would contain
  prefs: []
  type: TYPE_NORMAL
- en: different values. We could then write code to search through all the
  prefs: []
  type: TYPE_NORMAL
- en: Person objects and retrieve information about the one or ones we are
  prefs: []
  type: TYPE_NORMAL
- en: looking for.
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters, I will explore this concept of instantiating multiple
  prefs: []
  type: TYPE_NORMAL
- en: objects from a single class and give you tools to help manage a collection of
  prefs: []
  type: TYPE_NORMAL
- en: objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**OOP as a Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end o[f Chapter 1, I m](index_split_000.html#p32)entioned three problems
    that are inherent in procedural coding. Hopefully, after working through the examples
  prefs: []
  type: TYPE_NORMAL
- en: in this chapter, you can see how object-oriented programming solves all of
  prefs: []
  type: TYPE_NORMAL
- en: 'those problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A well-written class can be easily reused in many different programs.
  prefs: []
  type: TYPE_NORMAL
- en: Classes do not need to access global data. Instead, objects provide code
  prefs: []
  type: TYPE_NORMAL
- en: and data at the same level.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Object-oriented programming can greatly reduce the number of global
  prefs: []
  type: TYPE_NORMAL
- en: variables required, because a class provides a framework in which data
  prefs: []
  type: TYPE_NORMAL
- en: and code that acts on the data exist in one grouping. This also tends to
  prefs: []
  type: TYPE_NORMAL
- en: make code easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Objects created from a class only have access to their own data—their
  prefs: []
  type: TYPE_NORMAL
- en: set of the instance variables in the class. Even when you have multiple
  prefs: []
  type: TYPE_NORMAL
- en: objects created from the same class, they do not have access to each
  prefs: []
  type: TYPE_NORMAL
- en: other’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Physical Objects with Object-Oriented Programming **45**
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provided an introduction to object-oriented program-
  prefs: []
  type: TYPE_NORMAL
- en: ming by demonstrating the relationship between a class and an object. The
  prefs: []
  type: TYPE_NORMAL
- en: class defines the shape and capabilities of an object. An object is a single
  prefs: []
  type: TYPE_NORMAL
- en: instance of a class that has its own set of all the data defined in the instance
  prefs: []
  type: TYPE_NORMAL
- en: variables of the class. Each piece of data you want an object to contain is
  prefs: []
  type: TYPE_NORMAL
- en: stored in an instance variable, which has object scope, meaning that it is
  prefs: []
  type: TYPE_NORMAL
- en: available within all methods defined in the class. All objects created from
  prefs: []
  type: TYPE_NORMAL
- en: the same class get their own set of all the instance variables, and because
  prefs: []
  type: TYPE_NORMAL
- en: these may contain different values, calling the methods on different objects
  prefs: []
  type: TYPE_NORMAL
- en: can result in different behavior.
  prefs: []
  type: TYPE_NORMAL
- en: I showed how you create an object from a class, typically through an
  prefs: []
  type: TYPE_NORMAL
- en: assignment statement. After instantiating an object, you can use it to make
  prefs: []
  type: TYPE_NORMAL
- en: calls to any method defined in the class of that object. I also showed how
  prefs: []
  type: TYPE_NORMAL
- en: you can instantiate multiple objects from the same class.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the demonstration classes implemented physical objects
  prefs: []
  type: TYPE_NORMAL
- en: (light switches, TVs). This is a good way to start understanding the con-
  prefs: []
  type: TYPE_NORMAL
- en: cepts of a class and an object. However, in future chapters, I will introduce
  prefs: []
  type: TYPE_NORMAL
- en: objects that do not represent physical objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**46** Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: '**3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**M E N T A L M O D E L S O F O B J E C T S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A N D T H E M E A N I N G O F “ S E L F ”**'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully the new concepts and terminol-
  prefs: []
  type: TYPE_NORMAL
- en: ogy I’ve introduced so far are starting to
  prefs: []
  type: TYPE_NORMAL
- en: make sense. Some people new to OOP have
  prefs: []
  type: TYPE_NORMAL
- en: trouble envisioning what an object is and how
  prefs: []
  type: TYPE_NORMAL
- en: the methods of an object work with its instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: ables. The specifics are fairly complex, so it can be
  prefs: []
  type: TYPE_NORMAL
- en: helpful to develop a mental model of how objects and
  prefs: []
  type: TYPE_NORMAL
- en: classes operate.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll present two mental models of OOP. Right up front,
  prefs: []
  type: TYPE_NORMAL
- en: I want to be clear that neither of these models is an exact representation
  prefs: []
  type: TYPE_NORMAL
- en: of how objects work in Python. Instead, these models are intended to give
  prefs: []
  type: TYPE_NORMAL
- en: you a way to think about what an object looks like and what happens when
  prefs: []
  type: TYPE_NORMAL
- en: you call a method. This chapter will also go into more detail about self and
  prefs: []
  type: TYPE_NORMAL
- en: show how it is used to make methods work with multiple objects instanti-
  prefs: []
  type: TYPE_NORMAL
- en: ated from the same class. Throughout the rest of the book, you’ll gain a
  prefs: []
  type: TYPE_NORMAL
- en: much deeper insight into objects and classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Revisiting the DimmerSwitch Class**'
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we’ll continue with the DimmerSwitch class from
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2 (](index_split_000.html#p50)Listing 2-5). The DimmerSwitch class
    already has two instance variables: self.isOn and self.brightness. The only modification
    we’ll make is to'
  prefs: []
  type: TYPE_NORMAL
- en: add a self.label instance variable so each object we create can be identified
  prefs: []
  type: TYPE_NORMAL
- en: easily in the output when we run our program. These variables are created
  prefs: []
  type: TYPE_NORMAL
- en: and assigned initial values in the __init__() method. They are then accessed
  prefs: []
  type: TYPE_NORMAL
- en: or modified in the five other methods of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3-1 provides some test code to create three DimmerSwitch objects
  prefs: []
  type: TYPE_NORMAL
- en: from the DimmerSwitch class, which we’ll use in our mental models. I’ll call
  prefs: []
  type: TYPE_NORMAL
- en: various methods for each of the DimmerSwitch objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_DimmerSwitch_Model1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Create first DimmerSwitch, turn it on, and raise the level twice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer1 = DimmerSwitch('Dimmer1')
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer1.turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer1.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer1.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: Create second DimmerSwitch, turn it on, and raise the level 3 times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer2 = DimmerSwitch('Dimmer2')
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2.turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: Create third DimmerSwitch, using the default settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer3 = DimmerSwitch('Dimmer3')
  prefs: []
  type: TYPE_NORMAL
- en: Ask each switch to show itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer1.show()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2.show()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer3.show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-1: Creating three DimmerSwitch objects and cal ing various methods
    on each* When run with our DimmerSwitch class, this code gives the following'
  prefs: []
  type: TYPE_NORMAL
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Dimmer1'
  prefs: []
  type: TYPE_NORMAL
- en: Light is on? True
  prefs: []
  type: TYPE_NORMAL
- en: 'Brightness is: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Dimmer2'
  prefs: []
  type: TYPE_NORMAL
- en: Light is on? True
  prefs: []
  type: TYPE_NORMAL
- en: 'Brightness is: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Dimmer3'
  prefs: []
  type: TYPE_NORMAL
- en: Light is on? False
  prefs: []
  type: TYPE_NORMAL
- en: 'Brightness is: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '**48** Chapter 3'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what you would expect. Each DimmerSwitch object is independent
    of any other DimmerSwitch objects, and each object contains and
  prefs: []
  type: TYPE_NORMAL
- en: modifies its own instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**High-Level Mental Model #1**'
  prefs: []
  type: TYPE_NORMAL
- en: In this first model, you can think of each object as a self-contained unit that
  prefs: []
  type: TYPE_NORMAL
- en: contains a data type, a set of the instance variables defined in the class,
    and
  prefs: []
  type: TYPE_NORMAL
- en: a copy of all the methods defined in the class (Figure 3-1).
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer1
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer3
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch
  prefs: []
  type: TYPE_NORMAL
- en: 'Data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'label: Dimmer1'
  prefs: []
  type: TYPE_NORMAL
- en: 'label: Dimmer2'
  prefs: []
  type: TYPE_NORMAL
- en: 'label: Dimmer3'
  prefs: []
  type: TYPE_NORMAL
- en: 'isOn: True'
  prefs: []
  type: TYPE_NORMAL
- en: 'isOn: True'
  prefs: []
  type: TYPE_NORMAL
- en: 'isOn: False'
  prefs: []
  type: TYPE_NORMAL
- en: 'brightness: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'brightness: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'brightness: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: _init_()
  prefs: []
  type: TYPE_NORMAL
- en: _init_()
  prefs: []
  type: TYPE_NORMAL
- en: _init_()
  prefs: []
  type: TYPE_NORMAL
- en: turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: turnOn()
  prefs: []
  type: TYPE_NORMAL
- en: turnOff()
  prefs: []
  type: TYPE_NORMAL
- en: turnOff()
  prefs: []
  type: TYPE_NORMAL
- en: turnOff()
  prefs: []
  type: TYPE_NORMAL
- en: raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: lowerLevel()
  prefs: []
  type: TYPE_NORMAL
- en: lowerLevel()
  prefs: []
  type: TYPE_NORMAL
- en: lowerLevel()
  prefs: []
  type: TYPE_NORMAL
- en: show()
  prefs: []
  type: TYPE_NORMAL
- en: show()
  prefs: []
  type: TYPE_NORMAL
- en: show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-1: In mental model #1 each object is a unit that has a type, data,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*and methods.*'
  prefs: []
  type: TYPE_NORMAL
- en: The data and methods of each object are packaged together. The
  prefs: []
  type: TYPE_NORMAL
- en: scope of an instance variable is defined as all the methods in the class,
  prefs: []
  type: TYPE_NORMAL
- en: so all methods have access to the instance variables associated with that
  prefs: []
  type: TYPE_NORMAL
- en: object.
  prefs: []
  type: TYPE_NORMAL
- en: If this mental model makes the concepts clear, then you’re in good
  prefs: []
  type: TYPE_NORMAL
- en: shape. While this is *not* the way objects are actually implemented, it’s a
    perfectly reasonable way to *think about* how an object’s instance variables and
    methods work together.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Deeper Mental Model #2**'
  prefs: []
  type: TYPE_NORMAL
- en: This second model explores objects at a lower level and will explain more
  prefs: []
  type: TYPE_NORMAL
- en: about what an object is.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you instantiate an object, you get back a value from Python.
  prefs: []
  type: TYPE_NORMAL
- en: We typically store the returned value in a variable that refers to the object.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 3-2, we create three DimmerSwitch objects. After creating each one,
  prefs: []
  type: TYPE_NORMAL
- en: we’ll add code to inspect the result by printing out the type and value of
  prefs: []
  type: TYPE_NORMAL
- en: each variable.
  prefs: []
  type: TYPE_NORMAL
- en: Mental Models of Objects and the Meaning of “self” **49**
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_DimmerSwitch_Model2_Instantiation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Create three DimmerSwitch objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer1 = DimmerSwitch('Dimmer1')
  prefs: []
  type: TYPE_NORMAL
- en: print(type(oDimmer1))
  prefs: []
  type: TYPE_NORMAL
- en: print(oDimmer1)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2 = DimmerSwitch('Dimmer2')
  prefs: []
  type: TYPE_NORMAL
- en: print(type(oDimmer2))
  prefs: []
  type: TYPE_NORMAL
- en: print(oDimmer2)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer3 = DimmerSwitch('Dimmer3')
  prefs: []
  type: TYPE_NORMAL
- en: print(type(oDimmer3))
  prefs: []
  type: TYPE_NORMAL
- en: print(oDimmer3)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-2: Creating three DimmerSwitch objects and printing the type and
    value of each* Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <class '__main__.DimmerSwitch'>
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.DimmerSwitch object at 0x7ffe503b32e0>
  prefs: []
  type: TYPE_NORMAL
- en: <class '__main__.DimmerSwitch'>
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.DimmerSwitch object at 0x7ffe503b3970>
  prefs: []
  type: TYPE_NORMAL
- en: <class '__main__.DimmerSwitch'>
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.DimmerSwitch object at 0x7ffe503b39d0>
  prefs: []
  type: TYPE_NORMAL
- en: The first line in each grouping tells us the data type. Instead of a built-in
  prefs: []
  type: TYPE_NORMAL
- en: type like integer or float, we see that all three objects are of the programmer-
  prefs: []
  type: TYPE_NORMAL
- en: defined DimmerSwitch type. (The __main__ indicates that the DimmerSwitch code
  prefs: []
  type: TYPE_NORMAL
- en: was found inside our single Python file, not imported from any other file.)
  prefs: []
  type: TYPE_NORMAL
- en: The second line of each grouping contains a string of characters. Each
  prefs: []
  type: TYPE_NORMAL
- en: string represents a location in the memory of the computer. The memory
  prefs: []
  type: TYPE_NORMAL
- en: location is where all the data associated with each object can be found.
  prefs: []
  type: TYPE_NORMAL
- en: Notice each object is in a different location in memory. If you run this code
  prefs: []
  type: TYPE_NORMAL
- en: on your computer, you will most likely get different values, but the actual
  prefs: []
  type: TYPE_NORMAL
- en: values do not matter to understanding the concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'All DimmerSwitch objects report the same type: class DimmerSwitch. The'
  prefs: []
  type: TYPE_NORMAL
- en: extremely important takeaway is that the objects all refer to the code of the
  prefs: []
  type: TYPE_NORMAL
- en: same class, which really only exists in one place. When your program starts
  prefs: []
  type: TYPE_NORMAL
- en: running, Python reads through all the class definitions and remembers the
  prefs: []
  type: TYPE_NORMAL
- en: locations of all the classes and their methods.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Tutor websit[e ( *http://PythonTutor.com*) p](http://PythonTutor.com)rovides
    some useful tools that can help you to visualize the execution of small programs
    by allowing you to step through each line of your code. Figure 3-2 is a screenshot
    from
  prefs: []
  type: TYPE_NORMAL
- en: running the DimmerSwitch class and test code through the visualization tool,
  prefs: []
  type: TYPE_NORMAL
- en: stopping execution before instantiating the first DimmerSwitch object.
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see that Python remembers the location
  prefs: []
  type: TYPE_NORMAL
- en: of the DimmerSwitch class and all of its methods. While classes can contain
  prefs: []
  type: TYPE_NORMAL
- en: hundreds or even thousands of lines of code, no object actually gets a copy
  prefs: []
  type: TYPE_NORMAL
- en: of the class’s code. Having only one copy of the code is very important, as
  prefs: []
  type: TYPE_NORMAL
- en: it keeps the size of OOP programs small. When you instantiate an object,
  prefs: []
  type: TYPE_NORMAL
- en: '**50** Chapter 3'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 14](index-80_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 15](index-80_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Python allocates enough memory for each object to represent its own set
  prefs: []
  type: TYPE_NORMAL
- en: of the instance variables defined in the class. In general, instantiating an
  prefs: []
  type: TYPE_NORMAL
- en: object from a class is memory-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-2: Python remembers all classes and all methods in each class.*'
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot in Figure 3-3 shows the result of running all the test
  prefs: []
  type: TYPE_NORMAL
- en: code in Listing 3-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-3: Running Listing 3-2 demonstrates that objects do not include code,
    in accordance with mental model #2\.*'
  prefs: []
  type: TYPE_NORMAL
- en: Mental Models of Objects and the Meaning of “self” **51**
  prefs: []
  type: TYPE_NORMAL
- en: This matches our second mental model. On the right side of this
  prefs: []
  type: TYPE_NORMAL
- en: screenshot, the code for the DimmerSwitch class appears only once. Each
  prefs: []
  type: TYPE_NORMAL
- en: object knows the class it was instantiated from and contains its own set of
  prefs: []
  type: TYPE_NORMAL
- en: the instance variables defined in the class.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*While the following is an implementation detail, it may help to further your
    understanding of objects. Internally, all instance variables of an object are
    kept as name/*'
  prefs: []
  type: TYPE_NORMAL
- en: '*value pairs in a Python dictionary. You can inspect all the instance variables
    in an* *object by calling the built-in vars() function on any object. For example,
    in the test* *code from Listing 3-2, if you want to see the internal representation
    of the instance* *variables, you can add this line at the end:*'
  prefs: []
  type: TYPE_NORMAL
- en: print('oDimmer1 variables:', vars(oDimmer1))
  prefs: []
  type: TYPE_NORMAL
- en: '*When you run it, you’ll see this output:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'oDimmer1 variables: {''label'': ''Dimmer1'', ''isOn'': True, ''brightness'':
    2}'
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is the Meaning of “self”?**'
  prefs: []
  type: TYPE_NORMAL
- en: Philosophers have struggled with this question for centuries, so it would be
  prefs: []
  type: TYPE_NORMAL
- en: rather pretentious of me to try to explain it in just a few pages. In Python,
  prefs: []
  type: TYPE_NORMAL
- en: however, the variable named self does have a highly specialized and clear
  prefs: []
  type: TYPE_NORMAL
- en: meaning. In this section, I’ll show how self is given a value and how the
  prefs: []
  type: TYPE_NORMAL
- en: code of the methods in a class work with the instance variables of any object
  prefs: []
  type: TYPE_NORMAL
- en: instantiated from the class.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The variable name self is not a keyword in Python but is used by convention—any*
    *other name could be used and the code would work fine. However, using self is
    a* *universally accepted practice in Python, and I will use it throughout this
    book. If you* *want your code to be understood by other Python programmers, use
    the name self as* *the first parameter in all methods of a class. (Other OOP languages
    have the same* *concept but use other names, such as this or me.)*'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you write a class named SomeClass, then create an object from
  prefs: []
  type: TYPE_NORMAL
- en: 'that class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oSomeObject = SomeClass( *<optional arguments>* )
  prefs: []
  type: TYPE_NORMAL
- en: The object oSomeObject contains a set of all the instance variables
  prefs: []
  type: TYPE_NORMAL
- en: defined in the class. Every method of the SomeClass class has a definition
  prefs: []
  type: TYPE_NORMAL
- en: 'that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def someMethod(self, *<any other parameters>* ):'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the general form of a call to such a method:'
  prefs: []
  type: TYPE_NORMAL
- en: oSomeObject.someMethod( *<any other arguments>* )
  prefs: []
  type: TYPE_NORMAL
- en: '**52** Chapter 3'
  prefs: []
  type: TYPE_NORMAL
- en: As we know, Python rearranges the arguments in a call to a method, so that the
    object is passed in as the first argument. That value is received in the
  prefs: []
  type: TYPE_NORMAL
- en: first parameter of the method and is put into the variable self (Figure 3-4).
  prefs: []
  type: TYPE_NORMAL
- en: 'def someMethod(self, *<any other parameters>* ):'
  prefs: []
  type: TYPE_NORMAL
- en: oSomeObject.someMethod( *<any other arguments>* )
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-4: How Python rearranges arguments in a call to a method*'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, whenever a method is called, self will be set to the object
  prefs: []
  type: TYPE_NORMAL
- en: in the call. This means that the code of a method can operate on the
  prefs: []
  type: TYPE_NORMAL
- en: instance variables of *any* object instantiated from the class. It does so
  prefs: []
  type: TYPE_NORMAL
- en: 'using the form:'
  prefs: []
  type: TYPE_NORMAL
- en: self. *<instanceVariableName>*
  prefs: []
  type: TYPE_NORMAL
- en: This essentially says to use the object referred to by self and access
  prefs: []
  type: TYPE_NORMAL
- en: the instance variable specified by < *instanceVariableName*>. Since every method
    uses self as the first parameter, every method in a class uses this
  prefs: []
  type: TYPE_NORMAL
- en: same approach.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this concept, let’s use the DimmerSwitch class. In the follow-
  prefs: []
  type: TYPE_NORMAL
- en: ing example, we’ll instantiate two DimmerSwitch objects, then walk through
  prefs: []
  type: TYPE_NORMAL
- en: what happens when we raise the brightness level of these objects by calling
  prefs: []
  type: TYPE_NORMAL
- en: the raiseLevel() method with each.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the method we’re calling is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def raiseLevel(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.brightness < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: self.brightness = self.brightness + 1
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3-3 shows some example test code for two DimmerSwitch objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OO_DimmerSwitch_Model2_Method_Cal s.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Create two DimmerSwitch objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer1 = DimmerSwitch('Dimmer1')
  prefs: []
  type: TYPE_NORMAL
- en: oDimmer2 = DimmerSwitch('Dimmer2')
  prefs: []
  type: TYPE_NORMAL
- en: Tell oDimmer1 to raise its level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer1.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: Tell oDimmer2 to raise its level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDimmer2.raiseLevel()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-3: Cal ing the same method on different DimmerSwitch objects*'
  prefs: []
  type: TYPE_NORMAL
- en: Mental Models of Objects and the Meaning of “self” **53**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 16](index-83_1.png)'
  prefs: []
  type: TYPE_IMG
- en: In this listing, we first instantiate two DimmerSwitch objects. Then we have
  prefs: []
  type: TYPE_NORMAL
- en: 'two calls to the raiseLevel() method: first we call it with oDimmer1, then
    we'
  prefs: []
  type: TYPE_NORMAL
- en: call the same method using oDimmer2\.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-5 shows the result of running the test code in Listing 3-3
  prefs: []
  type: TYPE_NORMAL
- en: in Python Tutor, with execution stopped while making the first call to
  prefs: []
  type: TYPE_NORMAL
- en: raiseLevel().
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-5: The program in Listing 3-3 stopped in call to oDimmer1.raiseLevel()*
    Notice that self and oDimmer1 refer to the same object. When the'
  prefs: []
  type: TYPE_NORMAL
- en: method executes and uses any self.< *instanceVariable*>, it will use oDimmer1’s
    instance variables. Therefore, when this method runs, self.brightness refers
  prefs: []
  type: TYPE_NORMAL
- en: to the brightness instance variable in oDimmer1\.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue to execute the test code in Listing 3-3, we get to the sec-
  prefs: []
  type: TYPE_NORMAL
- en: ond call to raiseLevel() with oDimmer2\. In Figure 3-6, I’ve stopped execution
  prefs: []
  type: TYPE_NORMAL
- en: inside this method call.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this time, self refers to the same object as oDimmer2\. Now,
  prefs: []
  type: TYPE_NORMAL
- en: self.brightness refers to the brightness instance variable of oDimmer2\.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what object we use or which method we call, the value of
  prefs: []
  type: TYPE_NORMAL
- en: the object is assigned to the variable self in the called method. You should
  prefs: []
  type: TYPE_NORMAL
- en: think of self as meaning the current object—the object that the method
  prefs: []
  type: TYPE_NORMAL
- en: was called with. Whenever a method executes, it uses the set of instance
  prefs: []
  type: TYPE_NORMAL
- en: variables for the object specified in the call.
  prefs: []
  type: TYPE_NORMAL
- en: '**54** Chapter 3'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 17](index-84_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: The program in Listing 3-3 stopped in call to oDimmer2.raiseLevel()*
    **Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I presented two different ways of thinking about objects.
  prefs: []
  type: TYPE_NORMAL
- en: These mental models should help in developing a basic understanding of
  prefs: []
  type: TYPE_NORMAL
- en: what happens when you instantiate multiple instances of an object from a
  prefs: []
  type: TYPE_NORMAL
- en: class.
  prefs: []
  type: TYPE_NORMAL
- en: The first model showed how you can think of an object as having a set
  prefs: []
  type: TYPE_NORMAL
- en: of all the instance variables and all the methods of a class wrapped up in a
  prefs: []
  type: TYPE_NORMAL
- en: nice bundle.
  prefs: []
  type: TYPE_NORMAL
- en: The second model went into much greater detail about the implementa-
  prefs: []
  type: TYPE_NORMAL
- en: tion, explaining that the code of a class exists only in one place. An impor-
  prefs: []
  type: TYPE_NORMAL
- en: tant takeaway is that creating new objects from a class is space-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new instance of an object, Python allocates memory to
  prefs: []
  type: TYPE_NORMAL
- en: represent the instance variables defined in the class. No duplicates of the
  prefs: []
  type: TYPE_NORMAL
- en: class’s code are made or required.
  prefs: []
  type: TYPE_NORMAL
- en: The key to how methods work with multiple objects is that the first
  prefs: []
  type: TYPE_NORMAL
- en: parameter of all methods, self, is always set to the object used in a call to
  prefs: []
  type: TYPE_NORMAL
- en: that method. With this approach, every method uses the instance variables
  prefs: []
  type: TYPE_NORMAL
- en: for the current object.
  prefs: []
  type: TYPE_NORMAL
- en: Mental Models of Objects and the Meaning of “self” **55**
  prefs: []
  type: TYPE_NORMAL
- en: '**4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**M A N A G I N G M U L T I P L E O B J E C T S**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you techniques for
  prefs: []
  type: TYPE_NORMAL
- en: managing any number of objects instanti-
  prefs: []
  type: TYPE_NORMAL
- en: ated from the same class. I’ll first go through
  prefs: []
  type: TYPE_NORMAL
- en: an OOP implementation of the bank account
  prefs: []
  type: TYPE_NORMAL
- en: example from [Chapter 1\. T](index_split_000.html#p32)he OOP approach allows
  prefs: []
  type: TYPE_NORMAL
- en: the data and code of an account to be at the same
  prefs: []
  type: TYPE_NORMAL
- en: level, eliminating the need to depend on global data.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I’ll split the program into main code that
  prefs: []
  type: TYPE_NORMAL
- en: provides a top-level menu and a separate Bank object
  prefs: []
  type: TYPE_NORMAL
- en: that manages accounts, in addition to any number of
  prefs: []
  type: TYPE_NORMAL
- en: Account objects. We’ll also discuss a better way of han-
  prefs: []
  type: TYPE_NORMAL
- en: dling errors using exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bank Account Class**'
  prefs: []
  type: TYPE_NORMAL
- en: Our bank account class will need, at a minimum, a name, password,
  prefs: []
  type: TYPE_NORMAL
- en: and balance as its data. For behaviors, the user must be able to create an
  prefs: []
  type: TYPE_NORMAL
- en: account, deposit and withdraw money, and check their balance.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll define and initialize the variables for the name, password, and
  prefs: []
  type: TYPE_NORMAL
- en: balance, and build methods to implement each of the operations. We
  prefs: []
  type: TYPE_NORMAL
- en: should then be able to instantiate any number of Account objects. Like the
  prefs: []
  type: TYPE_NORMAL
- en: initial class fro[m Chapter 1, t](index_split_000.html#p32)his is a simplified
    Account class that only uses integers for the balance and keeps the password in
    cleartext. While you
  prefs: []
  type: TYPE_NORMAL
- en: wouldn’t use simplifications like these in a real banking application, they
  prefs: []
  type: TYPE_NORMAL
- en: will allow us to concentrate on the OOP aspects involved.
  prefs: []
  type: TYPE_NORMAL
- en: The new code for the Account class is presented in Listing 4-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Account.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Account class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Account():'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, name, balance, password):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: self.balance = int(balance)
  prefs: []
  type: TYPE_NORMAL
- en: self.password = password
  prefs: []
  type: TYPE_NORMAL
- en: '2 def deposit(self, amountToDeposit, password):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if password != self.password:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, incorrect password')
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: 'if amountToDeposit < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print('You cannot deposit a negative amount')
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: self.balance = self.balance + amountToDeposit
  prefs: []
  type: TYPE_NORMAL
- en: return self.balance
  prefs: []
  type: TYPE_NORMAL
- en: '3 def withdraw(self, amountToWithdraw, password):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if password != self.password:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Incorrect password for this account')
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: 'if amountToWithdraw < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print('You cannot withdraw a negative amount')
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: 'if amountToWithdraw > self.balance:'
  prefs: []
  type: TYPE_NORMAL
- en: print('You cannot withdraw more than you have in your account')
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: self.balance = self.balance - amountToWithdraw
  prefs: []
  type: TYPE_NORMAL
- en: return self.balance
  prefs: []
  type: TYPE_NORMAL
- en: '**58** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: '4 def getBalance(self, password):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if password != self.password:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, incorrect password')
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: return self.balance
  prefs: []
  type: TYPE_NORMAL
- en: Added for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5 def show(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(' Name:', self.name)
  prefs: []
  type: TYPE_NORMAL
- en: print(' Balance:', self.balance)
  prefs: []
  type: TYPE_NORMAL
- en: print(' Password:', self.password)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-1: A minimal Account class*'
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The error handling in Listing 4-1 is very simple. If we find an error condition,
    we* *print an error message and return a special value of None. Later in the chapter,
    I will* *show a better way of handling errors.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how these methods manipulate and remember data. Data is
  prefs: []
  type: TYPE_NORMAL
- en: passed into each method through parameters, which are local variables that
  prefs: []
  type: TYPE_NORMAL
- en: only exist while the method is running. Data is remembered in instance
  prefs: []
  type: TYPE_NORMAL
- en: variables, which have object scope and therefore remember their values
  prefs: []
  type: TYPE_NORMAL
- en: across calls to different methods.
  prefs: []
  type: TYPE_NORMAL
- en: First we have the __init__() method 1, with three parameters. When
  prefs: []
  type: TYPE_NORMAL
- en: 'an object is created from this class, three pieces of data are required: name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'balance, and password. The instantiation might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account('Joe Schmoe', 1000, 'magic')
  prefs: []
  type: TYPE_NORMAL
- en: When we instantiate the object, the values of the three arguments are
  prefs: []
  type: TYPE_NORMAL
- en: passed into the __init__() method, which in turn assigns these values to the
  prefs: []
  type: TYPE_NORMAL
- en: 'similarly named instance variables: self.name, self.balance, and self.password.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll access these instance variables in the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: The deposit() method 2 lets the user make a deposit into an account.
  prefs: []
  type: TYPE_NORMAL
- en: After instantiating an Account object and saving it in oAccount, we could call
  prefs: []
  type: TYPE_NORMAL
- en: 'the deposit() method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: newBalance = oAccount.deposit(500, 'magic')
  prefs: []
  type: TYPE_NORMAL
- en: This call says to deposit $500 and gives the password “magic”. The
  prefs: []
  type: TYPE_NORMAL
- en: method performs two validity checks on the deposit request. The first
  prefs: []
  type: TYPE_NORMAL
- en: ensures that the password is correct by testing the password provided in the
  prefs: []
  type: TYPE_NORMAL
- en: call against the password set when the Account object was created. This is a
  prefs: []
  type: TYPE_NORMAL
- en: good example of how the original password saved in the instance variable
  prefs: []
  type: TYPE_NORMAL
- en: self.password is used. The second validity check makes sure we aren’t depos-
  prefs: []
  type: TYPE_NORMAL
- en: iting a negative amount (which would actually be a withdrawal).
  prefs: []
  type: TYPE_NORMAL
- en: If either of those tests fails, for now we return the special value None
  prefs: []
  type: TYPE_NORMAL
- en: to show that some error occurred. If both tests pass, we increment the
  prefs: []
  type: TYPE_NORMAL
- en: instance variable self.balance by the amount of the deposit. Because the
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **59**
  prefs: []
  type: TYPE_NORMAL
- en: balance is stored in self.balance, it is remembered and is available for future
    calls. Finally, we return the new balance.
  prefs: []
  type: TYPE_NORMAL
- en: The withdraw() method 3 works in a very similar way and would be
  prefs: []
  type: TYPE_NORMAL
- en: 'called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.withdraw(250, 'magic')
  prefs: []
  type: TYPE_NORMAL
- en: The withdraw() method checks that we’ve supplied the proper password
  prefs: []
  type: TYPE_NORMAL
- en: by verifying it against the instance variable self.password. It also checks
    that
  prefs: []
  type: TYPE_NORMAL
- en: we’re not asking to withdraw a negative amount or more than we have in the
  prefs: []
  type: TYPE_NORMAL
- en: account, using the instance variable self.balance. Once those tests pass, the
  prefs: []
  type: TYPE_NORMAL
- en: method decrements self.balance by the amount to withdraw. It returns the
  prefs: []
  type: TYPE_NORMAL
- en: resulting balance.
  prefs: []
  type: TYPE_NORMAL
- en: To check the balance 4, we only need to supply the proper password
  prefs: []
  type: TYPE_NORMAL
- en: 'for the account:'
  prefs: []
  type: TYPE_NORMAL
- en: currentBalance = oAccount.getBalance('magic')
  prefs: []
  type: TYPE_NORMAL
- en: If the password supplied matches the one saved in the instance variable
  prefs: []
  type: TYPE_NORMAL
- en: self.password, the method returns the value in self.balance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for debugging, we added a show() method 5 to display the
  prefs: []
  type: TYPE_NORMAL
- en: current values of self.name, self.balance, and self.password saved for the
  prefs: []
  type: TYPE_NORMAL
- en: account.
  prefs: []
  type: TYPE_NORMAL
- en: The Account class is our first example of representing something that
  prefs: []
  type: TYPE_NORMAL
- en: is not a physical object. A bank account is not something that you can see,
  prefs: []
  type: TYPE_NORMAL
- en: feel, or touch. However, it fits perfectly into the world of computer objects
  prefs: []
  type: TYPE_NORMAL
- en: because it has data (name, balance, password) and actions that work on
  prefs: []
  type: TYPE_NORMAL
- en: that data (create, deposit, withdraw, get balance, show).
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Class Code**'
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to use a class you’ve built in your own code. As we’ve
  prefs: []
  type: TYPE_NORMAL
- en: seen in previous chapters, the simplest way is to place all the code of the
  prefs: []
  type: TYPE_NORMAL
- en: class directly in the main Python source file. But doing so makes it difficult
  prefs: []
  type: TYPE_NORMAL
- en: to reuse a class.
  prefs: []
  type: TYPE_NORMAL
- en: A second approach is to place the code of the class in a file by itself
  prefs: []
  type: TYPE_NORMAL
- en: and import it into a program that uses it. We’ve placed all the code for our
  prefs: []
  type: TYPE_NORMAL
- en: Account class in *Account.py*, but if we try to run *Account.py* by itself,
    nothing happens, because it’s just the definition of a class. To use our class
    code, we
  prefs: []
  type: TYPE_NORMAL
- en: must instantiate one or more objects and make calls to the object’s meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods. As our classes become larger and more complicated, saving each of
  prefs: []
  type: TYPE_NORMAL
- en: them as a separate file is the preferred way to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: To use our Account class, we must build another *.py* file and import the
  prefs: []
  type: TYPE_NORMAL
- en: code from *Account.py*, as we do with other built-in packages like random and
    time. Often, Python programmers name the main program that imports
  prefs: []
  type: TYPE_NORMAL
- en: other class files *main.py* or *Main_<SomeName>.py*. We must then ensure that
    *Account.py* and the main program file are in the same folder. At the
  prefs: []
  type: TYPE_NORMAL
- en: '**60** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'beginning of the main program, we bring in the Account code by starting with
    an import statement (notice that we leave off the **.py* file extension): from
    Account import *'
  prefs: []
  type: TYPE_NORMAL
- en: Using the import statement with an asterisk (*) brings in the entire con-
  prefs: []
  type: TYPE_NORMAL
- en: tents of the imported file. An imported file can contain multiple classes. In
  prefs: []
  type: TYPE_NORMAL
- en: this case, where possible, you should specify the specific class or classes
    that
  prefs: []
  type: TYPE_NORMAL
- en: you want to import, rather than importing the whole file. Here’s the syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'for importing particular classes:'
  prefs: []
  type: TYPE_NORMAL
- en: from *<ExternalFile>* import *<ClassName1>, <ClassName2>, ...*
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two benefits to importing class code:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The module is reusable, so if we want to use *Account.py* in some other
  prefs: []
  type: TYPE_NORMAL
- en: project, we just need to make a copy of the file and place it into that
  prefs: []
  type: TYPE_NORMAL
- en: project’s folder. Reusing code in this way is a staple of object-oriented
  prefs: []
  type: TYPE_NORMAL
- en: programming.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. If your class code is included in the main program, every time you run
  prefs: []
  type: TYPE_NORMAL
- en: the program, Python compiles all the code in your class (translates it
  prefs: []
  type: TYPE_NORMAL
- en: into a lower-level language that is more easily runnable on your com-
  prefs: []
  type: TYPE_NORMAL
- en: puter), even if you have not made any changes to the class.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you run your main program with your class code
  prefs: []
  type: TYPE_NORMAL
- en: imported, Python optimizes the compile step without you having to
  prefs: []
  type: TYPE_NORMAL
- en: do anything. It creates a folder named *__pycache__* in the project folder,
  prefs: []
  type: TYPE_NORMAL
- en: then compiles the code in your class file and saves the compiled code
  prefs: []
  type: TYPE_NORMAL
- en: in the *__pycache__* folder with a variant of the original Python filename.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for the *Account.py* file, Python will create a file using the
  prefs: []
  type: TYPE_NORMAL
- en: name *Account.cpython-39.pyc* (or similar, based on the version of Python
  prefs: []
  type: TYPE_NORMAL
- en: you are using). The *.pyc* extension stands for *Python Compiled*. Python only
    recompiles your class file if the source of the class file changes. If
  prefs: []
  type: TYPE_NORMAL
- en: the source of your *Account.py* has not changed, Python knows it doesn't
  prefs: []
  type: TYPE_NORMAL
- en: need to recompile it and can more efficiently use the *.pyc* version of the
  prefs: []
  type: TYPE_NORMAL
- en: file instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Some Test Code**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll test our new class with four main programs. The first will create Account
  prefs: []
  type: TYPE_NORMAL
- en: objects using separately named variables. The second stores the objects in a
  prefs: []
  type: TYPE_NORMAL
- en: list, while the third stores the account numbers and objects in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fourth version will split the functionality so we have a main pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram that responds to the user and a Bank object that manages the different
  prefs: []
  type: TYPE_NORMAL
- en: accounts.
  prefs: []
  type: TYPE_NORMAL
- en: In each example, the main program imports *Account.py*. Your project
  prefs: []
  type: TYPE_NORMAL
- en: folder should contain the main program and the *Account.py* file. In the
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **61**
  prefs: []
  type: TYPE_NORMAL
- en: following discussion, the different versions of the main program will be named
    *Main_Bank_VersionX.py*, where *X* represents the version number *.*
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Multiple Accounts***'
  prefs: []
  type: TYPE_NORMAL
- en: In this first version, we’ll create two example accounts and populate them
  prefs: []
  type: TYPE_NORMAL
- en: with viable data for testing. We’ll save each account in an explicitly named
  prefs: []
  type: TYPE_NORMAL
- en: variable representing the object.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP1_IndividualVariables/Main_Bank_Version1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Test program using accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version 1, using explicit variables for each Account object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring in all the code from the Account class file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Account import *
  prefs: []
  type: TYPE_NORMAL
- en: Create two accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 oJoesAccount = Account('Joe', 100, 'JoesPassword')
  prefs: []
  type: TYPE_NORMAL
- en: print("Created an account for Joe")
  prefs: []
  type: TYPE_NORMAL
- en: 2 oMarysAccount = Account('Mary', 12345, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: print("Created an account for Mary")
  prefs: []
  type: TYPE_NORMAL
- en: 3 oJoesAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: oMarysAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: Call some methods on the different accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Calling methods of the two accounts ...')
  prefs: []
  type: TYPE_NORMAL
- en: 4 oJoesAccount.deposit(50, 'JoesPassword')
  prefs: []
  type: TYPE_NORMAL
- en: oMarysAccount.withdraw(345, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: oMarysAccount.deposit(100, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: Show the accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oJoesAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: oMarysAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-2: A main program to test the Account class*'
  prefs: []
  type: TYPE_NORMAL
- en: We create an account for Joe 1 and an account for Mary 2, and we
  prefs: []
  type: TYPE_NORMAL
- en: store the results into two Account objects. We then call the show() method for
  prefs: []
  type: TYPE_NORMAL
- en: the accounts to demonstrate that they were created correctly 3\. Joe depos-
  prefs: []
  type: TYPE_NORMAL
- en: its $50\. Mary makes a withdrawal of $345 and then deposits $100 4\. If we
  prefs: []
  type: TYPE_NORMAL
- en: 'run the program now, this will be our output:'
  prefs: []
  type: TYPE_NORMAL
- en: Created an account for Joe
  prefs: []
  type: TYPE_NORMAL
- en: Created an account for Mary
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Joe'
  prefs: []
  type: TYPE_NORMAL
- en: 'Balance: 100'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password: JoesPassword'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Mary'
  prefs: []
  type: TYPE_NORMAL
- en: '**62** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Balance: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password: MarysPassword'
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods of the two accounts ...
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Joe'
  prefs: []
  type: TYPE_NORMAL
- en: 'Balance: 150'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password: JoesPassword'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Mary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Balance: 12100'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password: MarysPassword'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll extend the test program to create a third account interac-
  prefs: []
  type: TYPE_NORMAL
- en: tively by asking for some input from the user. Listing 4-3 shows the code
  prefs: []
  type: TYPE_NORMAL
- en: for this.
  prefs: []
  type: TYPE_NORMAL
- en: Create another account with information from the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: userName = input('What is the name for the new user account? ') 1
  prefs: []
  type: TYPE_NORMAL
- en: userBalance = input('What is the starting balance for this account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userBalance = int(userBalance)
  prefs: []
  type: TYPE_NORMAL
- en: userPassword = input('What is the password you want to use for this account?
    ')
  prefs: []
  type: TYPE_NORMAL
- en: oNewAccount = Account(userName, userBalance, userPassword) 2
  prefs: []
  type: TYPE_NORMAL
- en: Show the newly created user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oNewAccount.show() 3
  prefs: []
  type: TYPE_NORMAL
- en: Let's deposit 100 into the new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oNewAccount.deposit(100, userPassword) 4
  prefs: []
  type: TYPE_NORMAL
- en: usersBalance = oNewAccount.getBalance(userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('After depositing 100, the user's balance is:', usersBalance)
  prefs: []
  type: TYPE_NORMAL
- en: Show the new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oNewAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-3: An extension of the test program to create an account on the
    fly*'
  prefs: []
  type: TYPE_NORMAL
- en: This test code asks the user for a name, a starting balance, and a pass-
  prefs: []
  type: TYPE_NORMAL
- en: word 1\. It uses these values to create a new account, and we store the newly
  prefs: []
  type: TYPE_NORMAL
- en: created object in the variable oNewAccount 2\. We then call the show() method
  prefs: []
  type: TYPE_NORMAL
- en: on the new object 3\. We deposit $100 into the account and retrieve the new
  prefs: []
  type: TYPE_NORMAL
- en: balance by calling the getBalance() method 4\. When we run the full pro-
  prefs: []
  type: TYPE_NORMAL
- en: 'gram, we get the output from Listing 4-2, as well as the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the name for the new user account? Irv
  prefs: []
  type: TYPE_NORMAL
- en: What is the starting balance for this account? 777
  prefs: []
  type: TYPE_NORMAL
- en: What is the password you want to use for this account? IrvsPassword
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Irv'
  prefs: []
  type: TYPE_NORMAL
- en: 'Balance: 777'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password: IrvsPassword'
  prefs: []
  type: TYPE_NORMAL
- en: 'After depositing 100, the user''s balance is: 877'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **63**
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Irv'
  prefs: []
  type: TYPE_NORMAL
- en: 'Balance: 877'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password: IrvsPassword'
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to notice here is that each Account object maintains its
  prefs: []
  type: TYPE_NORMAL
- en: own set of instance variables. Each object (oJoesAccount, oMarysAccount, and
  prefs: []
  type: TYPE_NORMAL
- en: oNewAccount) is a global variable that contains a collection of three instance
  prefs: []
  type: TYPE_NORMAL
- en: variables. If we were to expand our definition of the Account class to include
  prefs: []
  type: TYPE_NORMAL
- en: information such as address, telephone number, and date of birth, each
  prefs: []
  type: TYPE_NORMAL
- en: object would get a set of these additional instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiple Account Objects in a List***'
  prefs: []
  type: TYPE_NORMAL
- en: Representing each account in a separate global variable works, but this is not
  prefs: []
  type: TYPE_NORMAL
- en: a good approach when we need to handle a large number of objects. A bank
  prefs: []
  type: TYPE_NORMAL
- en: would need a way to handle an arbitrary number of accounts. Whenever we
  prefs: []
  type: TYPE_NORMAL
- en: need an arbitrary number of pieces of data, a list is the typical solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this version of the test code, we’ll start with an empty list of Account
  prefs: []
  type: TYPE_NORMAL
- en: objects. Every time a user opens an account, we’ll instantiate an Account
  prefs: []
  type: TYPE_NORMAL
- en: object and append the resulting object onto our list. The account number
  prefs: []
  type: TYPE_NORMAL
- en: for any given account will be the index of the account in the list, starting
  prefs: []
  type: TYPE_NORMAL
- en: with 0\. Again, we’ll start by creating a test account for Joe and one for Mary,
  prefs: []
  type: TYPE_NORMAL
- en: as shown in Listing 4-4\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP2_ListOfAccountObjects/Main_Bank_Version2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Test program using accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version 2, using a list of accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring in all the code from the Account class file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Account import *
  prefs: []
  type: TYPE_NORMAL
- en: Start off with an empty list of accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsList = [ ] 1
  prefs: []
  type: TYPE_NORMAL
- en: Create two accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oAccount = Account('Joe', 100, 'JoesPassword') 2
  prefs: []
  type: TYPE_NORMAL
- en: accountsList.append(oAccount)
  prefs: []
  type: TYPE_NORMAL
- en: print("Joe's account number is 0")
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account('Mary', 12345, 'MarysPassword') 3
  prefs: []
  type: TYPE_NORMAL
- en: accountsList.append(oAccount)
  prefs: []
  type: TYPE_NORMAL
- en: print("Mary's account number is 1")
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[0].show() 4
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[1].show()
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: Call some methods on the different accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Calling methods of the two accounts ...')
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[0].deposit(50, 'JoesPassword') 5
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[1].withdraw(345, 'MarysPassword') 6
  prefs: []
  type: TYPE_NORMAL
- en: '**64** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[1].deposit(100, 'MarysPassword') 7
  prefs: []
  type: TYPE_NORMAL
- en: Show the accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsList[0].show() 8
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[1].show()
  prefs: []
  type: TYPE_NORMAL
- en: Create another account with information from the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: userName = input('What is the name for the new user account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userBalance = input('What is the starting balance for this account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userBalance = int(userBalance)
  prefs: []
  type: TYPE_NORMAL
- en: userPassword = input('What is the password you want to use for this account?
    ')
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account(userName, userBalance, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: 'accountsList.append(oAccount) # append to list of accounts'
  prefs: []
  type: TYPE_NORMAL
- en: Show the newly created user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Created new account, account number is 2')
  prefs: []
  type: TYPE_NORMAL
- en: accountsList[2].show()
  prefs: []
  type: TYPE_NORMAL
- en: Let's deposit 100 into the new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsList[2].deposit(100, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: usersBalance = accountsList[2].getBalance(userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('After depositing 100, the user's balance is:', usersBalance)
  prefs: []
  type: TYPE_NORMAL
- en: Show the new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsList[2].show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-4: Modified test code to store objects in a list*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating an empty list of accounts 1\. We create an account
  prefs: []
  type: TYPE_NORMAL
- en: for Joe, store the returned value into the variable oAccount, and immediately
  prefs: []
  type: TYPE_NORMAL
- en: append that object onto our list of accounts 2\. Since this is the first account
  prefs: []
  type: TYPE_NORMAL
- en: in the list, Joe’s account number is 0\. Like at a real bank, any time that
    Joe
  prefs: []
  type: TYPE_NORMAL
- en: wants to do any transactions with his account, he supplies his account num-
  prefs: []
  type: TYPE_NORMAL
- en: ber. We use his account number to show the balance of his account 4, make
  prefs: []
  type: TYPE_NORMAL
- en: a deposit 5, then show the balance again 8\. We also create an account for
  prefs: []
  type: TYPE_NORMAL
- en: Mary with account number 1 3 and perform some test operations on her
  prefs: []
  type: TYPE_NORMAL
- en: account at 6 and 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The results are identical to the test code from Listing 4-3\. However,
  prefs: []
  type: TYPE_NORMAL
- en: 'there is one highly significant difference between the two test programs:'
  prefs: []
  type: TYPE_NORMAL
- en: now there is only the single global variable accountsList. Each account has
    a
  prefs: []
  type: TYPE_NORMAL
- en: unique account number, which we use to access a specific account. We have
  prefs: []
  type: TYPE_NORMAL
- en: taken an important step in reducing the number of global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to note here is that we made some fairly major
  prefs: []
  type: TYPE_NORMAL
- en: changes to the main program, but we did not touch anything in the Account
  prefs: []
  type: TYPE_NORMAL
- en: class file. OOP often allows you to hide details at different levels. If we
    assume
  prefs: []
  type: TYPE_NORMAL
- en: that the code of the Account class takes care of details related to an individual
  prefs: []
  type: TYPE_NORMAL
- en: account, we can concentrate on ways to make the main code better.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that we’re using the variable oAccount as a *temporary* variable.
  prefs: []
  type: TYPE_NORMAL
- en: That is, whenever we create a new Account object, we are assigning the result
  prefs: []
  type: TYPE_NORMAL
- en: to the variable oAccount. Right after doing that, we append oAccount to our
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **65**
  prefs: []
  type: TYPE_NORMAL
- en: list of accounts. We never use the variable oAccount in calls to any method
    of a specific Account object. That way, we can reuse the variable oAccount to
  prefs: []
  type: TYPE_NORMAL
- en: receive the value of the next account that is created.
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiple Objects with Unique Identifiers***'
  prefs: []
  type: TYPE_NORMAL
- en: The Account objects must be individually identifiable so each user can make
  prefs: []
  type: TYPE_NORMAL
- en: deposits and withdrawals and get the balance of their specific account.
  prefs: []
  type: TYPE_NORMAL
- en: Using a list for our bank accounts works, but there’s a serious flaw. Imagine
  prefs: []
  type: TYPE_NORMAL
- en: we have five accounts, numbered 0, 1, 2, 3, and 4\. If the person who owns
  prefs: []
  type: TYPE_NORMAL
- en: account 2 decides to close their account, we’d likely use a standard pop()
  prefs: []
  type: TYPE_NORMAL
- en: 'operation on the list to delete account 2\. This would cause a domino effect:'
  prefs: []
  type: TYPE_NORMAL
- en: the account that was in position 3 is now in position 2, and the account that
  prefs: []
  type: TYPE_NORMAL
- en: was in position 4 is now in position 3\. However, the users of these accounts
  prefs: []
  type: TYPE_NORMAL
- en: still have their original account numbers, 3 and 4\. As a result, the customer
  prefs: []
  type: TYPE_NORMAL
- en: who owns account 3 will now get the information for the previous account
  prefs: []
  type: TYPE_NORMAL
- en: 4, and account number 4 is now an invalid index.
  prefs: []
  type: TYPE_NORMAL
- en: To handle large numbers of objects with unique identifiers, we generally
  prefs: []
  type: TYPE_NORMAL
- en: use a dictionary. Unlike a list, a dictionary will allow us to delete accounts
  prefs: []
  type: TYPE_NORMAL
- en: without altering the account numbers associated with them. We build each
  prefs: []
  type: TYPE_NORMAL
- en: key/value pair with an account number as the key and an Account object as the
  prefs: []
  type: TYPE_NORMAL
- en: value. That way, if we need to eliminate a given account, no other account is
  prefs: []
  type: TYPE_NORMAL
- en: 'affected. A dictionary of accounts would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '{0 : *<object for account 0>* , 1 : *<object for account 1>* , ... }'
  prefs: []
  type: TYPE_NORMAL
- en: We can then easily get the associated Account object and call a method
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = accountsDict[accountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.someMethodCall()
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could use the accountNumber directly to make a call to a
  prefs: []
  type: TYPE_NORMAL
- en: 'method of an individual Account:'
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[accountNumber].someMethodCall()
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-5 shows the test code using a dictionary of Account objects.
  prefs: []
  type: TYPE_NORMAL
- en: Again, while we’re making many changes to our test code, we’re not chang-
  prefs: []
  type: TYPE_NORMAL
- en: ing a single line in the Account class. In our test code, rather than using
  prefs: []
  type: TYPE_NORMAL
- en: hardcoded account numbers, we add a counter, nextAccountNumber, that we’ll
  prefs: []
  type: TYPE_NORMAL
- en: increment after creating a new Account.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP3_DictionaryOfAccountObjects/Main_Bank_Version3.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Test program using accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version 3, using a dictionary of accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring in all the code from the Account class file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Account import *
  prefs: []
  type: TYPE_NORMAL
- en: '**66** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict = {} 1
  prefs: []
  type: TYPE_NORMAL
- en: nextAccountNumber = 0 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two accounts:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oAccount = Account('Joe', 100, 'JoesPassword')
  prefs: []
  type: TYPE_NORMAL
- en: joesAccountNumber = nextAccountNumber
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[joesAccountNumber] = oAccount 3
  prefs: []
  type: TYPE_NORMAL
- en: print('Account number for Joe is:', joesAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: nextAccountNumber = nextAccountNumber + 1 4
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account('Mary', 12345, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: marysAccountNumber = nextAccountNumber
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[marysAccountNumber] = oAccount 5
  prefs: []
  type: TYPE_NORMAL
- en: print('Account number for Mary is:', marysAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: nextAccountNumber = nextAccountNumber + 1
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[joesAccountNumber].show()
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[marysAccountNumber].show()
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: Call some methods on the different accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Calling methods of the two accounts ...')
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[joesAccountNumber].deposit(50, 'JoesPassword')
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[marysAccountNumber].withdraw(345, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[marysAccountNumber].deposit(100, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: Show the accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsDict[joesAccountNumber].show()
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[marysAccountNumber].show()
  prefs: []
  type: TYPE_NORMAL
- en: Create another account with information from the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: userName = input('What is the name for the new user account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userBalance = input('What is the starting balance for this account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userBalance = int(userBalance)
  prefs: []
  type: TYPE_NORMAL
- en: userPassword = input('What is the password you want to use for this account?
    ')
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account(userName, userBalance, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: newAccountNumber = nextAccountNumber
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[newAccountNumber] = oAccount
  prefs: []
  type: TYPE_NORMAL
- en: print('Account number for new account is:', newAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: nextAccountNumber = nextAccountNumber + 1
  prefs: []
  type: TYPE_NORMAL
- en: Show the newly created user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsDict[newAccountNumber].show()
  prefs: []
  type: TYPE_NORMAL
- en: Let's deposit 100 into the new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsDict[newAccountNumber].deposit(100, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: usersBalance = accountsDict[newAccountNumber].getBalance(userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('After depositing 100, the user's balance is:', usersBalance)
  prefs: []
  type: TYPE_NORMAL
- en: Show the new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: accountsDict[newAccountNumber].show()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-5: Modified test code to store account numbers and objects in a
    dictionary* Managing Multiple Objects **67**'
  prefs: []
  type: TYPE_NORMAL
- en: Running this code yields results almost identical to those of the previous examples.
    We start with an empty dictionary of accounts 1, and initial-
  prefs: []
  type: TYPE_NORMAL
- en: ize our nextAccountNumber variable to 0 2\. Every time we instantiate a new
  prefs: []
  type: TYPE_NORMAL
- en: account, we add a new entry into the dictionary of accounts using the cur-
  prefs: []
  type: TYPE_NORMAL
- en: rent value of nextAccountNumber as a key and the Account object as the value
    3\.
  prefs: []
  type: TYPE_NORMAL
- en: We do this for each customer, as you can see for Mary 5\. Every time we
  prefs: []
  type: TYPE_NORMAL
- en: create a new account, we increment nextAccountNumber to prepare for the next
  prefs: []
  type: TYPE_NORMAL
- en: account 4\. With account numbers as keys in a dictionary, if a customer
  prefs: []
  type: TYPE_NORMAL
- en: closes their account, we can eliminate that key and value from the diction-
  prefs: []
  type: TYPE_NORMAL
- en: ary without affecting any other accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building an Interactive Menu***'
  prefs: []
  type: TYPE_NORMAL
- en: With our Account class working correctly, we’ll make the main code interac-
  prefs: []
  type: TYPE_NORMAL
- en: 'tive by asking the user to tell us what operation they would like to do: get'
  prefs: []
  type: TYPE_NORMAL
- en: the balance, make a deposit, make a withdrawal, or open a new account. In
  prefs: []
  type: TYPE_NORMAL
- en: response, our main code will gather the needed information from the user,
  prefs: []
  type: TYPE_NORMAL
- en: starting with their account number, and call the appropriate method of the
  prefs: []
  type: TYPE_NORMAL
- en: user’s Account object.
  prefs: []
  type: TYPE_NORMAL
- en: As a shortcut, we will again prepopulate two accounts, one for Joe and
  prefs: []
  type: TYPE_NORMAL
- en: one for Mary. Listing 4-6 shows our expanded main code, which uses a dic-
  prefs: []
  type: TYPE_NORMAL
- en: tionary to keep track of all the accounts. I’ve omitted the code that creates
  prefs: []
  type: TYPE_NORMAL
- en: the accounts for Joe and Mary and adds those to the dictionary of accounts
  prefs: []
  type: TYPE_NORMAL
- en: for brevity, as it’s the same as in Listing 4-5\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP4_InteractiveMenu/Main_Bank_Version4.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Interactive test program creating a dictionary of accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version 4, with an interactive menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Account import *
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict = {}
  prefs: []
  type: TYPE_NORMAL
- en: nextAccountNumber = 0
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip creating accounts, adding them to dictionary ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('Press b to get the balance')
  prefs: []
  type: TYPE_NORMAL
- en: print('Press d to make a deposit')
  prefs: []
  type: TYPE_NORMAL
- en: print('Press o to open a new account')
  prefs: []
  type: TYPE_NORMAL
- en: print('Press w to make a withdrawal')
  prefs: []
  type: TYPE_NORMAL
- en: print('Press s to show all accounts')
  prefs: []
  type: TYPE_NORMAL
- en: print('Press q to quit')
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: action = input('What do you want to do? ') 1
  prefs: []
  type: TYPE_NORMAL
- en: action = action.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'action = action[0] # grab the first letter'
  prefs: []
  type: TYPE_NORMAL
- en: '**68** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'if action == ''b'':'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Get Balance ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountNumber = input(''Please enter your account number: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = int(userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountPassword = input(''Please enter the password: '')'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.getBalance(userAccountPassword)
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Your balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''d'': 2'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Deposit ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountNumber = input(''Please enter the account number: '') 3'
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = int(userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'userDepositAmount = input(''Please enter amount to deposit: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userDepositAmount = int(userDepositAmount)
  prefs: []
  type: TYPE_NORMAL
- en: 'userPassword = input(''Please enter the password: '')'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = accountsDict[userAccountNumber] 4
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.deposit(userDepositAmount, userPassword) 5
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''o'':'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Open Account ***')
  prefs: []
  type: TYPE_NORMAL
- en: userName = input('What is the name for the new user account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userStartingAmount = input('What is the starting balance for this account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userStartingAmount = int(userStartingAmount)
  prefs: []
  type: TYPE_NORMAL
- en: userPassword = input('What is the password you want to use for this account?
    ')
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account(userName, userStartingAmount, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: accountsDict[nextAccountNumber] = oAccount
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new account number is:', nextAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: nextAccountNumber = nextAccountNumber + 1
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''s'':'
  prefs: []
  type: TYPE_NORMAL
- en: print('Show:')
  prefs: []
  type: TYPE_NORMAL
- en: 'for userAccountNumber in accountsDict:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: print(' Account number:', userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''q'':'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''w'':'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Withdraw ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountNumber = input(''Please enter your account number: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = int(userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'userWithdrawalAmount = input(''Please enter the amount to withdraw: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userWithdrawalAmount = int(userWithdrawalAmount)
  prefs: []
  type: TYPE_NORMAL
- en: 'userPassword = input(''Please enter the password: '')'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.withdraw(userWithdrawalAmount, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **69**
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Withdrew:', userWithdrawalAmount)
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, that was not a valid action. Please try again.')
  prefs: []
  type: TYPE_NORMAL
- en: print('Done')
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-6: Adding an interactive menu*'
  prefs: []
  type: TYPE_NORMAL
- en: In this version, we present the user with a menu of options. When the user
  prefs: []
  type: TYPE_NORMAL
- en: selects an action 1, the code asks questions about the intended transaction
  prefs: []
  type: TYPE_NORMAL
- en: to gather all the information we need to make the call to the user’s account.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the user wants to make a deposit 2, the program asks for the
  prefs: []
  type: TYPE_NORMAL
- en: account number, the amount to deposit, and the password for the account 3\.
  prefs: []
  type: TYPE_NORMAL
- en: We use the account number as a key into the dictionary of Account objects
  prefs: []
  type: TYPE_NORMAL
- en: to get the appropriate Account object 4\. With that object, we then call the
  prefs: []
  type: TYPE_NORMAL
- en: deposit() method, passing in the amount to deposit and the user’s password 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we have modified code at the main code level, and left our
  prefs: []
  type: TYPE_NORMAL
- en: Account class untouched.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an Object Manager Object**'
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 4-6 is actually doing two different things. The program
  prefs: []
  type: TYPE_NORMAL
- en: first provides a simple menu interface. Then, when an action is chosen, it
  prefs: []
  type: TYPE_NORMAL
- en: collects data and makes a call to a method of an Account object. Rather than
  prefs: []
  type: TYPE_NORMAL
- en: having one large main program that does two different tasks, we can split
  prefs: []
  type: TYPE_NORMAL
- en: this code into two smaller logical units, each with a clearly defined role.
  prefs: []
  type: TYPE_NORMAL
- en: The menuing system becomes the main code that decides what action to
  prefs: []
  type: TYPE_NORMAL
- en: take, and the rest of the code deals with the things a bank actually does.
  prefs: []
  type: TYPE_NORMAL
- en: The bank can be modeled as an object that manages other (account)
  prefs: []
  type: TYPE_NORMAL
- en: objects, known as an *object manager object*.
  prefs: []
  type: TYPE_NORMAL
- en: '**object manag** **er** An object that maintains a list or dictionary of managed
    objects (typical y of a single **object** class) and cal s methods of those objects
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'This split can be made easily and logically: we take all the code related'
  prefs: []
  type: TYPE_NORMAL
- en: to the bank and put it into a new Bank class. Then, at the beginning of the
  prefs: []
  type: TYPE_NORMAL
- en: main program, we instantiate a single Bank object from the new Bank class.
  prefs: []
  type: TYPE_NORMAL
- en: The Bank class will manage a list or dictionary of Account objects. In this
  prefs: []
  type: TYPE_NORMAL
- en: way, the Bank object will be the only code that communicates directly with
  prefs: []
  type: TYPE_NORMAL
- en: Account objects (Figure 4-1).
  prefs: []
  type: TYPE_NORMAL
- en: To create this hierarchy, we need some main code that handles the
  prefs: []
  type: TYPE_NORMAL
- en: highest-level menuing system. In response to a choice of action, the main code
  prefs: []
  type: TYPE_NORMAL
- en: will call a method of the Bank object (for example, deposit() or withdraw()).
    The
  prefs: []
  type: TYPE_NORMAL
- en: Bank object will gather the information it needs (account number, password,
  prefs: []
  type: TYPE_NORMAL
- en: amount to deposit or withdraw), reach into its dictionary of accounts to find
  prefs: []
  type: TYPE_NORMAL
- en: '**70** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: the matching user account, and call the appropriate method for that user’s account.
  prefs: []
  type: TYPE_NORMAL
- en: Main code
  prefs: []
  type: TYPE_NORMAL
- en: Bank object
  prefs: []
  type: TYPE_NORMAL
- en: Account
  prefs: []
  type: TYPE_NORMAL
- en: Account
  prefs: []
  type: TYPE_NORMAL
- en: Account
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: Account
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-1: The main code manages a Bank object, which manages*'
  prefs: []
  type: TYPE_NORMAL
- en: '*many Account objects.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three layers in this division of labor:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The main code that creates and talks to a single Bank object
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The
  prefs: []
  type: TYPE_NORMAL
- en: Bank object that manages a dictionary of Account objects and calls
  prefs: []
  type: TYPE_NORMAL
- en: methods of those objects
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The
  prefs: []
  type: TYPE_NORMAL
- en: Account objects themselves
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we only have a single global variable, the Bank
  prefs: []
  type: TYPE_NORMAL
- en: object. In fact, the main code has no idea that Account objects even exist.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, each Account object has no clue (and does not care) what the
  prefs: []
  type: TYPE_NORMAL
- en: top-level user interface of the program is. The Bank object receives messages
  prefs: []
  type: TYPE_NORMAL
- en: from the main code and communicates with the appropriate Account object.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of this approach is that we have broken down a
  prefs: []
  type: TYPE_NORMAL
- en: 'much larger program into smaller subprograms: in this case, the main code'
  prefs: []
  type: TYPE_NORMAL
- en: and two classes. This makes it much easier to program each piece, since
  prefs: []
  type: TYPE_NORMAL
- en: the scope of work is smaller and the responsibilities are clearer for each.
  prefs: []
  type: TYPE_NORMAL
- en: Further, having only a single global variable ensures that lower-level code
  prefs: []
  type: TYPE_NORMAL
- en: will not accidentally affect data at the global level.
  prefs: []
  type: TYPE_NORMAL
- en: In computer literature, the construct shown in Figure 4-1 is often
  prefs: []
  type: TYPE_NORMAL
- en: known as *composition* or *object composition*.
  prefs: []
  type: TYPE_NORMAL
- en: '**composition**'
  prefs: []
  type: TYPE_NORMAL
- en: A logical structure in which one object manages one or more other objects
  prefs: []
  type: TYPE_NORMAL
- en: You can think of one object as being made up of other objects. An
  prefs: []
  type: TYPE_NORMAL
- en: example is that a car object is made up of an engine object, a steering wheel
  prefs: []
  type: TYPE_NORMAL
- en: object, some number of door objects, four wheel and tire objects, and so
  prefs: []
  type: TYPE_NORMAL
- en: on. The discussion often centers around the relationships between objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, one would say that a car “has a” steering wheel, an engine,
  prefs: []
  type: TYPE_NORMAL
- en: some number of doors, and so on. Therefore, the car object is a composite
  prefs: []
  type: TYPE_NORMAL
- en: of other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **71**
  prefs: []
  type: TYPE_NORMAL
- en: We’ll have three separate files. The main code lives in its own file.
  prefs: []
  type: TYPE_NORMAL
- en: It imports the code of our new *Bank.py* file that contains the Bank class
  prefs: []
  type: TYPE_NORMAL
- en: (Listing 4-7). The Bank class imports the code of the *Account.py* file and
  prefs: []
  type: TYPE_NORMAL
- en: uses it to instantiate Account objects as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Object Manager Object***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-7 shows the code of the new Bank class, which is an object manager
  prefs: []
  type: TYPE_NORMAL
- en: object.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP5_SeparateBankClass/Bank.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Bank that manages a dictionary of Account objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Account import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class Bank():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.accountsDict = {} 1
  prefs: []
  type: TYPE_NORMAL
- en: self.nextAccountNumber = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'def createAccount(self, theName, theStartingAmount, thePassword): 2'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = Account(theName, theStartingAmount, thePassword)
  prefs: []
  type: TYPE_NORMAL
- en: newAccountNumber = self.nextAccountNumber
  prefs: []
  type: TYPE_NORMAL
- en: self.accountsDict[newAccountNumber] = oAccount
  prefs: []
  type: TYPE_NORMAL
- en: Increment to prepare for next account to be created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.nextAccountNumber = self.nextAccountNumber + 1
  prefs: []
  type: TYPE_NORMAL
- en: return newAccountNumber
  prefs: []
  type: TYPE_NORMAL
- en: 'def openAccount(self): 3'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Open Account ***')
  prefs: []
  type: TYPE_NORMAL
- en: userName = input('What is the name for the new user account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userStartingAmount = input('What is the starting balance for this account? ')
  prefs: []
  type: TYPE_NORMAL
- en: userStartingAmount = int(userStartingAmount)
  prefs: []
  type: TYPE_NORMAL
- en: userPassword = input('What is the password you want to use for this account?
    ')
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = self.createAccount(userName, userStartingAmount, userPassword)
    4
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new account number is:', userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'def closeAccount(self): 5'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Close Account ***')
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = input('What is your account number? ')
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = int(userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: userPassword = input('What is your password? ')
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.getBalance(userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('You had', theBalance, 'in your account, which is being returned to you.')
  prefs: []
  type: TYPE_NORMAL
- en: Remove user's account from the dictionary of accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: del self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: print('Your account is now closed.')
  prefs: []
  type: TYPE_NORMAL
- en: '**72** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'def balance(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Get Balance ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountNumber = input(''Please enter your account number: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = int(userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountPassword = input(''Please enter the password: '')'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.getBalance(userAccountPassword)
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Your balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'def deposit(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Deposit ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'accountNum = input(''Please enter the account number: '')'
  prefs: []
  type: TYPE_NORMAL
- en: accountNum = int(accountNum)
  prefs: []
  type: TYPE_NORMAL
- en: 'depositAmount = input(''Please enter amount to deposit: '')'
  prefs: []
  type: TYPE_NORMAL
- en: depositAmount = int(depositAmount)
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountPassword = input(''Please enter the password: '')'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[accountNum]
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.deposit(depositAmount, userAccountPassword)
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'def show(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Show ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'for userAccountNumber in self.accountsDict:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: print(' Account:', userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'def withdraw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Withdraw ***')
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountNumber = input(''Please enter your account number: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = int(userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'userAmount = input(''Please enter the amount to withdraw: '')'
  prefs: []
  type: TYPE_NORMAL
- en: userAmount = int(userAmount)
  prefs: []
  type: TYPE_NORMAL
- en: 'userAccountPassword = input(''Please enter the password: '')'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.withdraw(userAmount, userAccountPassword)
  prefs: []
  type: TYPE_NORMAL
- en: 'if theBalance is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Withdrew:', userAmount)
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-7: The Bank class with separate methods for different bank operations*
    I’ll focus on the most important things to notice in the Bank class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in its __init__() method, Bank initializes two variables: self.accountsDict'
  prefs: []
  type: TYPE_NORMAL
- en: and self.nextAccountNumber 1\. The prefix self. designates these as instance
    vari-
  prefs: []
  type: TYPE_NORMAL
- en: ables, meaning the Bank class can refer to these variables in any of its methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, there are two methods for creating an account: createAccount()'
  prefs: []
  type: TYPE_NORMAL
- en: and openAccount(). The createAccount() method instantiates a new account 2
  prefs: []
  type: TYPE_NORMAL
- en: with the user’s name, a starting amount, and a password passed in for the
  prefs: []
  type: TYPE_NORMAL
- en: new account. The openAccount() method asks the user questions to obtain
  prefs: []
  type: TYPE_NORMAL
- en: these three pieces of information 3 and calls the createAccount() method
  prefs: []
  type: TYPE_NORMAL
- en: within the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **73**
  prefs: []
  type: TYPE_NORMAL
- en: Having one method call another method in the same class is common.
  prefs: []
  type: TYPE_NORMAL
- en: But the called method doesn’t know whether it was called from inside or
  prefs: []
  type: TYPE_NORMAL
- en: outside the class; it only knows that the first argument is the object on
  prefs: []
  type: TYPE_NORMAL
- en: which it should run. Therefore, the call to the method must start with self.,
  prefs: []
  type: TYPE_NORMAL
- en: because self always refers to the current object. Generically, to call from
  prefs: []
  type: TYPE_NORMAL
- en: 'one method to another method in the same class we need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def myMethod(self, *<other optional parameters>* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: self.methodInSameClass( *<any needed arguments>* )
  prefs: []
  type: TYPE_NORMAL
- en: After collecting information from the user for openAccount(), we have
  prefs: []
  type: TYPE_NORMAL
- en: 'this line 4:'
  prefs: []
  type: TYPE_NORMAL
- en: userAccountNumber = self.createAccount(userName, userStartingAmount, userPassword)
  prefs: []
  type: TYPE_NORMAL
- en: Here, openAccount() calls createAccount() from the same class to cre-
  prefs: []
  type: TYPE_NORMAL
- en: ate the account. The createAccount() method runs, instantiates an Account
  prefs: []
  type: TYPE_NORMAL
- en: object, and returns an account number to openAccount(), which returns that
  prefs: []
  type: TYPE_NORMAL
- en: account number back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the new method closeAccount() allows the user to close an
  prefs: []
  type: TYPE_NORMAL
- en: existing account 5\. This is an extra piece of functionality we’ll offer from
  prefs: []
  type: TYPE_NORMAL
- en: our main code.
  prefs: []
  type: TYPE_NORMAL
- en: Our Bank class represents an abstract view of a bank rather than the
  prefs: []
  type: TYPE_NORMAL
- en: physical brick-and-mortar object. This is another good example of a class
  prefs: []
  type: TYPE_NORMAL
- en: that does not represent a physical structure.
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Code That Creates an Object Manager Object***'
  prefs: []
  type: TYPE_NORMAL
- en: The main code that creates and makes calls to the Bank object is shown in
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-8\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP5_SeparateBankClass/Main_Bank_Version5.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Main program for controlling a Bank made up of Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring in all the code of the Bank class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Bank import *
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the Bank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oBank = Bank()
  prefs: []
  type: TYPE_NORMAL
- en: Main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create two test accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: joesAccountNumber = oBank.createAccount('Joe', 100, 'JoesPassword')
  prefs: []
  type: TYPE_NORMAL
- en: print("Joe's account number is:", joesAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: marysAccountNumber = oBank.createAccount('Mary', 12345, 'MarysPassword')
  prefs: []
  type: TYPE_NORMAL
- en: print("Mary's account number is:", marysAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '**74** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: print('To get an account balance, press b')
  prefs: []
  type: TYPE_NORMAL
- en: print('To close an account, press c')
  prefs: []
  type: TYPE_NORMAL
- en: print('To make a deposit, press d')
  prefs: []
  type: TYPE_NORMAL
- en: print('To open a new account, press o')
  prefs: []
  type: TYPE_NORMAL
- en: print('To quit, press q')
  prefs: []
  type: TYPE_NORMAL
- en: print('To show all accounts, press s')
  prefs: []
  type: TYPE_NORMAL
- en: print('To make a withdrawal, press w ')
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 1 action = input('What do you want to do? ')
  prefs: []
  type: TYPE_NORMAL
- en: action = action.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'action = action[0] # grab the first letter'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '2 if action == ''b'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.balance()
  prefs: []
  type: TYPE_NORMAL
- en: '3 elif action == ''c'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.closeAccount()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''d'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.deposit()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''o'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.openAccount()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''s'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''q'':'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''w'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.withdraw()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, that was not a valid action. Please try again.')
  prefs: []
  type: TYPE_NORMAL
- en: print('Done')
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-8: The main code that creates a Bank object and makes cal s to it*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the code in Listing 4-8 presents the top-level menuing sys-
  prefs: []
  type: TYPE_NORMAL
- en: tem. It asks the user for an action 1, then calls an appropriate method in
  prefs: []
  type: TYPE_NORMAL
- en: the Bank object to do the work 2\. You could easily extend the Bank object
  prefs: []
  type: TYPE_NORMAL
- en: to handle some additional queries, like asking for the bank’s hours, or
  prefs: []
  type: TYPE_NORMAL
- en: address, or phone number. That data could simply be kept as additional
  prefs: []
  type: TYPE_NORMAL
- en: instance variables inside the Bank object. The Bank would answer those ques-
  prefs: []
  type: TYPE_NORMAL
- en: tions without needing to communicate with any Account object.
  prefs: []
  type: TYPE_NORMAL
- en: When a close request is made 3, the main code calls the closeAccount()
  prefs: []
  type: TYPE_NORMAL
- en: method of the Bank object to close the account. The Bank object removes the
  prefs: []
  type: TYPE_NORMAL
- en: 'specific account from its dictionary of accounts using a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: del self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **75**
  prefs: []
  type: TYPE_NORMAL
- en: Recall that our definition of an object is data, plus code that acts on that
    data, over time. The ability to delete an object demonstrates the third
  prefs: []
  type: TYPE_NORMAL
- en: part of our definition of an object. We can create an object (in this case an
  prefs: []
  type: TYPE_NORMAL
- en: Account object) whenever we want, not just when a program starts. In this
  prefs: []
  type: TYPE_NORMAL
- en: program, we create a new Account object whenever a user decides to open an
  prefs: []
  type: TYPE_NORMAL
- en: account. Our code can use that object by calling its methods. We can also
  prefs: []
  type: TYPE_NORMAL
- en: delete an object at any time, in this case, when a user chooses to close their
  prefs: []
  type: TYPE_NORMAL
- en: account. This is an example of how an object (like an Account object) has a
  prefs: []
  type: TYPE_NORMAL
- en: life span, from whenever it is created it to whenever it is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Error Handling with Exceptions**'
  prefs: []
  type: TYPE_NORMAL
- en: So far in our Account class, if a method detects an error (for example, if the
  prefs: []
  type: TYPE_NORMAL
- en: user deposits a negative amount, enters an incorrect password, withdraws a
  prefs: []
  type: TYPE_NORMAL
- en: negative amount, and so on) our placeholder solution is to return None as a
  prefs: []
  type: TYPE_NORMAL
- en: signal that something went wrong. In this section, we’ll discuss a better way
  prefs: []
  type: TYPE_NORMAL
- en: of handling errors by using try/except blocks and raising exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '***try and except***'
  prefs: []
  type: TYPE_NORMAL
- en: When a runtime error or abnormal condition occurs in a function or
  prefs: []
  type: TYPE_NORMAL
- en: method from the Python Standard Library, that function or method sig-
  prefs: []
  type: TYPE_NORMAL
- en: nals the error by raising an exception (sometimes referred to as *throwing*
    or *generating* an exception). We can detect and react to exceptions using the
  prefs: []
  type: TYPE_NORMAL
- en: 'try/except construct. Here is the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: some code that may cause an error (raise an exception)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'except *<some exception name>* : # if an exception happens'
  prefs: []
  type: TYPE_NORMAL
- en: some code to handle the exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the code inside the try block works correctly and does not generate
  prefs: []
  type: TYPE_NORMAL
- en: an exception, the except clause is skipped, and execution continues after
  prefs: []
  type: TYPE_NORMAL
- en: the except block. However, if the code in the try block results in an excep-
  prefs: []
  type: TYPE_NORMAL
- en: tion, control is passed to the except statement. If the exception matches the
  prefs: []
  type: TYPE_NORMAL
- en: exception (or one of multiple exceptions) listed in the except statement,
  prefs: []
  type: TYPE_NORMAL
- en: control is transferred to the code of the except clause. This is often referred
  prefs: []
  type: TYPE_NORMAL
- en: to as *catching* the exception. That indented block typically contains code
    to report and/or recover from the error.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple example where we ask for a number from the user and
  prefs: []
  type: TYPE_NORMAL
- en: 'attempt to convert it to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'age = input(''Please enter your age: '')'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: # attempt to convert to integer'
  prefs: []
  type: TYPE_NORMAL
- en: age = int(age)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError: # if an exception is raised trying to convert'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, that was not a valid number')
  prefs: []
  type: TYPE_NORMAL
- en: '**76** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the Python Standard Library can generate standard exceptions such as
    TypeError, ValueError, NameError, ZeroDivisionError, and so on. In this
  prefs: []
  type: TYPE_NORMAL
- en: example, if the user enters letters or a floating-point number, the built-in
  prefs: []
  type: TYPE_NORMAL
- en: int() function raises a ValueError exception, and control is transferred to
    the
  prefs: []
  type: TYPE_NORMAL
- en: code in the except block.
  prefs: []
  type: TYPE_NORMAL
- en: '***The raise Statement and Custom Exceptions***'
  prefs: []
  type: TYPE_NORMAL
- en: If your code detects a runtime error condition, you can use the raise state-
  prefs: []
  type: TYPE_NORMAL
- en: ment to signal an exception. There are many forms of the raise statement,
  prefs: []
  type: TYPE_NORMAL
- en: 'but the standard approach is to use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: raise *<ExceptionName>* (' *<Any string to describe the error>* ') For the *<ExceptionName>*
    , you have three options. First, if there is a standard exception that matches
    the error you have detected (TypeError,
  prefs: []
  type: TYPE_NORMAL
- en: ValueError, NameError, ZeroDivisionError, and so on), it’s fine to use that.
    You
  prefs: []
  type: TYPE_NORMAL
- en: 'can also add your own description string:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError('You need to specify an integer')
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you can use the generic Exception exception:'
  prefs: []
  type: TYPE_NORMAL
- en: raise Exception('The amount cannot be a floating-point number')
  prefs: []
  type: TYPE_NORMAL
- en: However, this is generally frowned upon because the standard practice
  prefs: []
  type: TYPE_NORMAL
- en: is to write except statements to look for exceptions by name, and this does
  prefs: []
  type: TYPE_NORMAL
- en: not provide a specific name.
  prefs: []
  type: TYPE_NORMAL
- en: A third choice, and perhaps the best, is to create your own custom
  prefs: []
  type: TYPE_NORMAL
- en: exception. This is easy to do, but involves a technique called inheritance
  prefs: []
  type: TYPE_NORMAL
- en: '(which we will discuss at length i[n Chapter 10)](index_split_004.html#p240).
    Here is all you need to create your own exception:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a custom exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class *<CustomExceptionName>* (Exception):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: You supply a unique name for your exception. You can then raise your
  prefs: []
  type: TYPE_NORMAL
- en: custom exception in your code. Creating your own exceptions means you
  prefs: []
  type: TYPE_NORMAL
- en: can explicitly check for these exceptions by name in a higher level of your
  prefs: []
  type: TYPE_NORMAL
- en: code. In the next section, we’ll rewrite the code of our bank example so
  prefs: []
  type: TYPE_NORMAL
- en: that we raise a custom exception in our Bank and Account classes and check
  prefs: []
  type: TYPE_NORMAL
- en: for and report the error in the main code. The main code will report the
  prefs: []
  type: TYPE_NORMAL
- en: error but allow the program to continue running.
  prefs: []
  type: TYPE_NORMAL
- en: In the typical case, the raise statement causes the current function or
  prefs: []
  type: TYPE_NORMAL
- en: method to exit and transfers control back to the caller. If the caller contains
  prefs: []
  type: TYPE_NORMAL
- en: an except clause that catches the exception, execution continues inside that
  prefs: []
  type: TYPE_NORMAL
- en: except clause. Otherwise, that function or method exits. This process is
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **77**
  prefs: []
  type: TYPE_NORMAL
- en: repeated until an except clause catches the exception. Control is transferred
    back through the sequence of calls, and if no except clause catches the
  prefs: []
  type: TYPE_NORMAL
- en: exception, the program quits and Python displays the error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Exceptions in Our Bank Program**'
  prefs: []
  type: TYPE_NORMAL
- en: We can now rewrite all three levels of our program (main, Bank, and Account)
  prefs: []
  type: TYPE_NORMAL
- en: to signal errors with raise statements and to handle errors using try/except
  prefs: []
  type: TYPE_NORMAL
- en: blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Account Class with Exceptions***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-9 is a new version of the Account class rewritten to use exceptions
  prefs: []
  type: TYPE_NORMAL
- en: and optimized so that no code is repeated. We start by defining a custom
  prefs: []
  type: TYPE_NORMAL
- en: AbortTransaction exception, which will be raised if we discover some error
  prefs: []
  type: TYPE_NORMAL
- en: while a user is attempting to do a transaction in our bank.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP6_UsingExceptions/Account.py (modified to work with upcoming
    Bank.py)**'
  prefs: []
  type: TYPE_NORMAL
- en: Account class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors indicated by "raise" statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define a custom exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class AbortTransaction(Exception): 1'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''raise this exception to abort a bank transaction'''''''
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'class Account():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, balance, password):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: self.balance = self.validateAmount(balance) 2
  prefs: []
  type: TYPE_NORMAL
- en: self.password = password
  prefs: []
  type: TYPE_NORMAL
- en: 'def validateAmount(self, amount):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: amount = int(amount)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: raise AbortTransaction('Amount must be an integer') 3
  prefs: []
  type: TYPE_NORMAL
- en: 'if amount <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: raise AbortTransaction('Amount must be positive') 4
  prefs: []
  type: TYPE_NORMAL
- en: return amount
  prefs: []
  type: TYPE_NORMAL
- en: 'def checkPasswordMatch(self, password): 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'if password != self.password:'
  prefs: []
  type: TYPE_NORMAL
- en: raise AbortTransaction('Incorrect password for this account')
  prefs: []
  type: TYPE_NORMAL
- en: 'def deposit(self, amountToDeposit): 6'
  prefs: []
  type: TYPE_NORMAL
- en: amountToDeposit = self.validateAmount(amountToDeposit)
  prefs: []
  type: TYPE_NORMAL
- en: self.balance = self.balance + amountToDeposit
  prefs: []
  type: TYPE_NORMAL
- en: return self.balance
  prefs: []
  type: TYPE_NORMAL
- en: 'def getBalance(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '**78** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: return self.balance
  prefs: []
  type: TYPE_NORMAL
- en: 'def withdraw(self, amountToWithdraw): 7'
  prefs: []
  type: TYPE_NORMAL
- en: amountToWithdraw = self.validateAmount(amountToWithdraw)
  prefs: []
  type: TYPE_NORMAL
- en: 'if amountToWithdraw > self.balance:'
  prefs: []
  type: TYPE_NORMAL
- en: raise AbortTransaction('You cannot withdraw more than you have in your account')
  prefs: []
  type: TYPE_NORMAL
- en: self.balance = self.balance - amountToWithdraw
  prefs: []
  type: TYPE_NORMAL
- en: return self.balance
  prefs: []
  type: TYPE_NORMAL
- en: Added for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def show(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(' Name:', self.name)
  prefs: []
  type: TYPE_NORMAL
- en: print(' Balance:', self.balance)
  prefs: []
  type: TYPE_NORMAL
- en: print(' Password:', self.password)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-9: A modified Account class that raises exceptions*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining our custom AbortTransaction exception 1 so we can
  prefs: []
  type: TYPE_NORMAL
- en: use it in this class and in other code that imports this class.
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method of the Account class, we ensure that the amount
  prefs: []
  type: TYPE_NORMAL
- en: provided as the starting balance is valid by calling validateAmount() 2\. This
  prefs: []
  type: TYPE_NORMAL
- en: method uses a try/except block to ensure that the starting amount can
  prefs: []
  type: TYPE_NORMAL
- en: successfully be converted to an integer. If the call to int() fails, it raises
    a
  prefs: []
  type: TYPE_NORMAL
- en: ValueError exception, which is caught in the except clause. Rather than just
  prefs: []
  type: TYPE_NORMAL
- en: allowing the generic ValueError to be returned to the caller, the code of
  prefs: []
  type: TYPE_NORMAL
- en: this except block 3 executes a raise statement, raising our AbortTransaction
  prefs: []
  type: TYPE_NORMAL
- en: exception, and includes a more meaningful error message string. If the con-
  prefs: []
  type: TYPE_NORMAL
- en: version to an integer succeeds, we perform another test. If the user gave a
  prefs: []
  type: TYPE_NORMAL
- en: negative amount, we also raise the AbortTransaction exception 4, but with a
  prefs: []
  type: TYPE_NORMAL
- en: different error message string.
  prefs: []
  type: TYPE_NORMAL
- en: The checkPasswordMatch() method 5 is called by methods in the Bank
  prefs: []
  type: TYPE_NORMAL
- en: object to check if the password supplied by the user matches the password
  prefs: []
  type: TYPE_NORMAL
- en: saved in the Account. If not, we execute another raise statement with the
  prefs: []
  type: TYPE_NORMAL
- en: same exception, but we supply a more descriptive error message string.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the code of deposit() 6 and withdraw() 7 to be simplified,
  prefs: []
  type: TYPE_NORMAL
- en: because these methods assume that the amount has been validated and
  prefs: []
  type: TYPE_NORMAL
- en: the password verified before they are invoked. There is an additional check
  prefs: []
  type: TYPE_NORMAL
- en: in withdraw() to ensure that the user is not trying to withdraw more money
  prefs: []
  type: TYPE_NORMAL
- en: than is in the account; if so, we raise the AbortTransaction exception with
    an
  prefs: []
  type: TYPE_NORMAL
- en: appropriate description.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no code in this class to handle an AbortTransaction excep-
  prefs: []
  type: TYPE_NORMAL
- en: tion, any time one is raised, control is passed back to the caller. If the caller
  prefs: []
  type: TYPE_NORMAL
- en: has no code to handle the exception, then control is passed back to the pre-
  prefs: []
  type: TYPE_NORMAL
- en: vious caller, and so on up the stack of calls. As we’ll see, our main code will
  prefs: []
  type: TYPE_NORMAL
- en: handle this exception.
  prefs: []
  type: TYPE_NORMAL
- en: '***Optimized Bank Class***'
  prefs: []
  type: TYPE_NORMAL
- en: The full Bank class code is available for download. In Listing 4-10 I show
  prefs: []
  type: TYPE_NORMAL
- en: some sample methods that demonstrate try/except techniques with calls to
  prefs: []
  type: TYPE_NORMAL
- en: methods in the previously updated Account class.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **79**
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP6_UsingExceptions/Bank.py (modified to work with previous Account.py)**'
  prefs: []
  type: TYPE_NORMAL
- en: Bank that manages a dictionary of Account objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Account import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class Bank():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, hours, address, phone): 1'
  prefs: []
  type: TYPE_NORMAL
- en: self.accountsDict = {}
  prefs: []
  type: TYPE_NORMAL
- en: self.nextAccountNumber = 0
  prefs: []
  type: TYPE_NORMAL
- en: self.hours = hours
  prefs: []
  type: TYPE_NORMAL
- en: self.address = address
  prefs: []
  type: TYPE_NORMAL
- en: self.phone = phone
  prefs: []
  type: TYPE_NORMAL
- en: 'def askForValidAccountNumber(self): 2'
  prefs: []
  type: TYPE_NORMAL
- en: accountNumber = input('What is your account number? ')
  prefs: []
  type: TYPE_NORMAL
- en: 'try: 3'
  prefs: []
  type: TYPE_NORMAL
- en: accountNumber = int(accountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: raise AbortTransaction('The account number must be an integer')
  prefs: []
  type: TYPE_NORMAL
- en: 'if accountNumber not in self.accountsDict:'
  prefs: []
  type: TYPE_NORMAL
- en: raise AbortTransaction('There is no account ' + str(accountNumber))
  prefs: []
  type: TYPE_NORMAL
- en: return accountNumber
  prefs: []
  type: TYPE_NORMAL
- en: 'def getUsersAccount(self): 4'
  prefs: []
  type: TYPE_NORMAL
- en: accountNumber = self.askForValidAccountNumber()
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[accountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: self.askForValidPassword(oAccount)
  prefs: []
  type: TYPE_NORMAL
- en: return oAccount
  prefs: []
  type: TYPE_NORMAL
- en: '--- snipped additional methods ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'def deposit(self): 5'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Deposit ***')
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.getUsersAccount()
  prefs: []
  type: TYPE_NORMAL
- en: 'depositAmount = input(''Please enter amount to deposit: '')'
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.deposit(depositAmount)
  prefs: []
  type: TYPE_NORMAL
- en: print('Deposited:', depositAmount)
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'def withdraw(self): 6'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Withdraw ***')
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.getUsersAccount()
  prefs: []
  type: TYPE_NORMAL
- en: 'userAmount = input(''Please enter the amount to withdraw: '')'
  prefs: []
  type: TYPE_NORMAL
- en: theBalance = oAccount.withdraw(userAmount)
  prefs: []
  type: TYPE_NORMAL
- en: print('Withdrew:', userAmount)
  prefs: []
  type: TYPE_NORMAL
- en: print('Your new balance is:', theBalance)
  prefs: []
  type: TYPE_NORMAL
- en: 'def getInfo(self): 7'
  prefs: []
  type: TYPE_NORMAL
- en: print('Hours:', self.hours)
  prefs: []
  type: TYPE_NORMAL
- en: print('Address:', self.address)
  prefs: []
  type: TYPE_NORMAL
- en: print('Phone:', self.phone)
  prefs: []
  type: TYPE_NORMAL
- en: print('We currently have', len(self.accountsDict), 'account(s) open.')
  prefs: []
  type: TYPE_NORMAL
- en: '**80** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: Special method for Bank administrator only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def show(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print('*** Show ***')
  prefs: []
  type: TYPE_NORMAL
- en: print('(This would typically require an admin password)')
  prefs: []
  type: TYPE_NORMAL
- en: 'for userAccountNumber in self.accountsDict:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount = self.accountsDict[userAccountNumber]
  prefs: []
  type: TYPE_NORMAL
- en: print('Account:', userAccountNumber)
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.show()
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-10: The modified Bank class*'
  prefs: []
  type: TYPE_NORMAL
- en: The Bank class starts with the __init__() method 1 that saves all relevant
  prefs: []
  type: TYPE_NORMAL
- en: information in instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: The new askForValidAccountNumber()2 method is called from a number
  prefs: []
  type: TYPE_NORMAL
- en: of other methods to ask the user for an account number and attempts to
  prefs: []
  type: TYPE_NORMAL
- en: verify the given number. First it has a try/except block 3 to ensure that
  prefs: []
  type: TYPE_NORMAL
- en: the number is an integer. If it isn’t, the except block detects the error as
    a
  prefs: []
  type: TYPE_NORMAL
- en: ValueError exception but reports the error more clearly by raising a custom
  prefs: []
  type: TYPE_NORMAL
- en: AbortTransaction exception with a descriptive message. Next, it checks to
  prefs: []
  type: TYPE_NORMAL
- en: ensure that the given account number is one that the bank knows about. If
  prefs: []
  type: TYPE_NORMAL
- en: not, it also raises an AbortTransaction exception, but it gives a different
    error
  prefs: []
  type: TYPE_NORMAL
- en: message string.
  prefs: []
  type: TYPE_NORMAL
- en: The new getUsersAccount() method 4 first calls the previous askForValid
  prefs: []
  type: TYPE_NORMAL
- en: AccountNumber(), then uses the account number to find the appropriate Account
  prefs: []
  type: TYPE_NORMAL
- en: object. Notice that there is no try/except in this method. If an exception
  prefs: []
  type: TYPE_NORMAL
- en: is raised in askForValidAccountNumber() (or in a lower level), this method will
  prefs: []
  type: TYPE_NORMAL
- en: immediately return to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: The deposit() 5 and withdraw() 6 methods call getUsersAccount() in the
  prefs: []
  type: TYPE_NORMAL
- en: same class. Similarly, if their call to getUsersAccount() raises an exception,
  prefs: []
  type: TYPE_NORMAL
- en: the method will exit and pass the exception up the chain to the caller. If all
  prefs: []
  type: TYPE_NORMAL
- en: tests pass, the code of deposit() and withdraw() calls similarly named meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods in the specified Account object to perform the actual transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The getInfo() 7 method reports information about the bank (hours,
  prefs: []
  type: TYPE_NORMAL
- en: address, phone) and doesn’t access any individual account.
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Code That Handles Exceptions***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-11 shows the updated main code, rewritten to handle a custom
  prefs: []
  type: TYPE_NORMAL
- en: exception. This is where any errors that occur are reported to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: BankOOP6_UsingException/Main_Bank_Version6.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Main program for controlling a Bank made up of Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Bank import *
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the Bank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 oBank = Bank('9 to 5', '123 Main Street, Anytown, USA', '(650) 555-1212')
  prefs: []
  type: TYPE_NORMAL
- en: Main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Multiple Objects **81**
  prefs: []
  type: TYPE_NORMAL
- en: '2 while True:'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('To get an account balance, press b')
  prefs: []
  type: TYPE_NORMAL
- en: print('To close an account, press c')
  prefs: []
  type: TYPE_NORMAL
- en: print('To make a deposit, press d')
  prefs: []
  type: TYPE_NORMAL
- en: print('To get bank information, press i')
  prefs: []
  type: TYPE_NORMAL
- en: print('To open a new account, press o')
  prefs: []
  type: TYPE_NORMAL
- en: print('To quit, press q')
  prefs: []
  type: TYPE_NORMAL
- en: print('To show all accounts, press s')
  prefs: []
  type: TYPE_NORMAL
- en: print('To make a withdrawal, press w')
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: action = input('What do you want to do? ')
  prefs: []
  type: TYPE_NORMAL
- en: action = action.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'action = action[0] # grab the first letter'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '3 try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if action == ''b'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.balance()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''c'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.closeAccount()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''d'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.deposit()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''i'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.getInfo()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''o'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.openAccount()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''q'':'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''s'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif action == ''w'':'
  prefs: []
  type: TYPE_NORMAL
- en: oBank.withdraw()
  prefs: []
  type: TYPE_NORMAL
- en: '4 except AbortTransaction as error:'
  prefs: []
  type: TYPE_NORMAL
- en: Print out the text of the error message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print(error)
  prefs: []
  type: TYPE_NORMAL
- en: print('Done')
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-11: The main code that handles errors with try/except*'
  prefs: []
  type: TYPE_NORMAL
- en: The main code starts by creating a single Bank object 1\. Then, in a loop,
  prefs: []
  type: TYPE_NORMAL
- en: it presents a top-level menu to the user and asks them what action they wish
  prefs: []
  type: TYPE_NORMAL
- en: to perform 2\. It calls an appropriate method for each command.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing in this listing is that we have added a try block
  prefs: []
  type: TYPE_NORMAL
- en: around all the calls to methods with the oBank object 3\. That way, if any
  prefs: []
  type: TYPE_NORMAL
