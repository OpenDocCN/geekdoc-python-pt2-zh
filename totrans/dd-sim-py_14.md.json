["```py\nprint(\"Normal message\")\nprint(\"Scary error occurred\")\n```", "```py\n$ **python3 print_error.py > output.txt 2> error.txt**\n$ **cat output.txt**\nA normal message.\nA scary error occurred.\n$ **cat error.txt**\n$\n```", "```py\n**import sys**\nprint(\"Normal message\")\nprint(\"Scary error occurred\"**, file=sys.stderr**)\n```", "```py\n$ **python3 print_error.py > output.txt 2> error.txt**\n$ **cat output.txt**\nA normal message.\n$ **cat error.txt**\nA scary error occurred.\n```", "```py\nimport time\n\nprint(\"Downloading\", end='')\nfor n in range(20):\n    print('.', end='', flush=True)\n    time.sleep(0.1)\nprint(\"\\nDownload completed!\")\n```", "```py\nnumber = 245\nstreet = \"8th Street\"\ncity = \"San Francisco\"\nstate = \"CA\"\nzip_code = 94103\n```", "```py\nprint(f\"{number} {street} {city} {state} {zip_code}\")\n```", "```py\nprint(number, street, city, state, zip_code)\n```", "```py\n245 8th Street San Francisco CA 94103\n```", "```py\nnearby_properties = {\n    \"N. Anywhere Ave.\":\n    {\n        123: 156_852,\n        124: 157_923,\n        126: 163_812,\n        127: 144_121,\n        128: 166_356,\n    },\n    \"N. Everywhere St.\":\n    {\n        4567: 175_753,\n        4568: 166_212,\n        4569: 185_123,\n    }\n}\n```", "```py\nfor street, properties in nearby_properties.items():\n    for address, value in properties.items():\n        print(f\"{street}\\t{address}\\t${value:,}\")\n```", "```py\nfor street, properties in nearby_properties.items():\n    for address, value in properties.items():\n        print(**street, address, f\"${value:,}\", sep='\\t'**)\n```", "```py\n`# --snip--`\nN. Anywhere Ave.        127     $144,121\nN. Anywhere Ave.        128     $166,356\nN. Everywhere St.       4567    $175,753\n`# --snip--`\n```", "```py\nfor street, properties in nearby_properties.items():\n    for address, value in properties.items():\n        print(street, address, f\"${value:,}\", **sep='  |  '**)\n```", "```py\n`# --snip--`\nN. Anywhere Ave.  |  127  |  $144,121\nN. Anywhere Ave.  |  128  |  $166,356\nN. Everywhere St.  |  4567  |  $175,753\n`# --snip--`\n```", "```py\nmls = input(\"Search: MLS#\")\nprint(f\"Searching for property with MLS#{mls}...\")\n```", "```py\nSearch: MLS#`2092412`\nSearching for property with MLS#2092412...\n```", "```py\nhouse = open(\"213AnywhereAve.txt\")\nprint(house.read())\nhouse.close()\n```", "```py\nBeautiful 3 bed, 2.5 bath on 2 acres.\nFinished basement, covered porch.\nKitchen features granite countertops and new appliances.\nLarge fenced yard with mature trees and garden space.\n$856,752 \n```", "```py\nhouse = open(\"213AnywhereAve.txt\")\n**try:**\n    print(house.read())\n**finally:**\n    house.close()\n```", "```py\n**with** open(\"213AnywhereAve.txt\") **as house:**\n    print(house.read())\n```", "```py\nwith open(\"213AnywhereAve.txt\", 'r') as file:\n    print(file.readable())  # prints 'True'\n    print(file.writable())  # prints 'False'\n    print(file.seekable())  # prints 'True'\n```", "```py\n78 Somewhere Road, Anytown PA\n\nTiny 2-bed, 1-bath bungalow. Needs repairs.\nBuilt in 1981; original kitchen and appliances.\nSmall backyard with old storage shed.\nBuilt on ancient burial ground.\n$431,998 \n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    contents = house.read()\n    print(type(contents))  # prints <class 'str'>\n    print(contents)\n```", "```py\n print(repr(contents))\n```", "```py\n'78 Somewhere Road, Anytown PA\\nTiny 2 bed, 1 bath `#` `--snip--`'\n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    **print(house.read(20))**\n```", "```py\n78 Somewhere Road, A\n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    line1 = house.readline()\n    line2 = house.readline()\n    print(repr(line1))\n    print(repr(line2))\n```", "```py\n'78 Somewhere Road, Anytown PA\\n'\n'Tiny 2 bed, 1 bath bungalow.\\n'\n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    lines = house.readlines()\n    for line in lines:\n        print(line.strip())\n```", "```py\n78 Somewhere Road, Anytown PA\nTiny 2-bed, 1-bath bungalow. Needs repairs.\nBuilt in 1981; original kitchen and appliances.\nSmall backyard with old storage shed.\nBuilt on ancient burial ground.\n$431,998\n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    for line in house:\n        print(line.strip())\n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    for _ in range(3):\n        print(house.readline().strip())\n        house.seek(0)\n```", "```py\n78 Somewhere Road, Anytown PA\n78 Somewhere Road, Anytown PA\n78 Somewhere Road, Anytown PA\n```", "```py\nwith open('78SomewhereRd.txt', 'r') as house:\n    for **n** in range(**10**):\n        **house.seek(n)**\n        print(house.readline().strip())\n```", "```py\n78 Somewhere Road, Anytown PA\n8 Somewhere Road, Anytown PA\nSomewhere Road, Anytown PA\nSomewhere Road, Anytown PA\nomewhere Road, Anytown PA\nmewhere Road, Anytown PA\newhere Road, Anytown PA\nwhere Road, Anytown PA\nhere Road, Anytown PA\nere Road, Anytown PA\n```", "```py\nwith open('78SomewhereRd.txt', 'r+') as real_estate_listing:\n    contents = real_estate_listing.read()\n```", "```py\n contents = contents.replace('Tiny', 'Cozy')\n    contents = contents.replace('Needs repairs', 'Full of potential')\n    contents = contents.replace('Small', 'Compact')\n    contents = contents.replace('old storage shed', 'detached workshop')\n    contents = contents.replace('Built on ancient burial ground.',\n                                'Unique atmosphere.')\n```", "```py\n real_estate_listing.seek(0)\n    real_estate_listing.write(contents)\n```", "```py\n real_estate_listing.truncate()\n```", "```py\n78 Somewhere Road, Anytown PA\nCozy 2-bed, 1-bath bungalow. Full of potential.\nBuilt in 1981; original kitchen and appliances.\nCompact backyard with detached workshop.\nUnique atmosphere.\n$431,998 \n```", "```py\nwith open('78SomewhereRd.txt', 'r+') as real_estate_listing:\n    contents = real_estate_listing.**readlines()**\n```", "```py\n **new_contents = []**\n **for line in contents:**\n **line = line.**replace('Tiny', 'Cozy')\n **line = line.**replace('Needs repairs', 'Full of potential')\n **line = line.**replace('Small', 'Compact')\n **line = line.**replace('old storage shed', 'detached workshop')\n **line = line.**replace('Built on ancient burial ground',\n                            'Unique atmosphere')\n        **new_contents.append(line)**\n```", "```py\n real_estate_listing.seek(0)\n    real_estate_listing.**writelines(new_contents)**\n    real_estate_listing.truncate()\n```", "```py\nnearby_properties = {\n    \"N. Anywhere Ave.\":\n    {\n        123: 156_852,\n        124: 157_923,\n        126: 163_812,\n        127: 144_121,\n        128: 166_356\n    },\n    \"N. Everywhere St.\":\n    {\n        4567: 175_753,\n        4568: 166_212,\n        4569: 185_123\n    }\n}\n```", "```py\n**with open('listings.txt', 'w') as real_estate_listings:**\n    for street, properties in nearby_properties.items():\n        for address, value in properties.items():\n            print(street, address, f\"${value:,}\",\n                  sep='  |  ',\n                  **file=real_estate_listings**)\n```", "```py\n`# --snip--`\nN. Anywhere Ave.  |  127  |  $144,121\nN. Anywhere Ave.  |  128  |  $166,356\nN. Everywhere St. |  4567 |  $175,753\n`# --snip--`\n```", "```py`### How Context Managers Work    For an object to be a context manager, it must implement two special methods: `__enter__()` and `__exit__()`.    Streams implement both of these methods. The `__exit__()` method closes the stream, eliminating the need to remember to manually close the stream.    The `__enter__()` method is responsible for any setup before the context manager is used. This method doesn’t do anything interesting in the case of a stream, although some context manager classes make more use of `__enter__()`, as you’ll see in the custom context manager example later.    According to PEP 343, which defined context managers, the `with` compound statement is roughly equivalent to this:    ```", "```py    The expression passed to the `with` statement is used to initialize an object. The `__enter__()` method is called on that object to perform whatever tasks should be completed before the object is used. (Again, in the case of streams, this method does nothing.) Next, the suite of the `with` statement is called within the context of a `try` clause. Whether it succeeds or fails, the `__exit__()` method will be called, usually to perform any necessary cleanup tasks on the object.    Recalling the example from [Listing 11-17](#listing11-17), if Python didn’t have `with` statements, I’d need to use the following code to ensure a file was closed, whether there was an error or not:    ```", "```py    Listing 11-33: *read_real_estate_listing_file.py:1a*    Because streams like `real_estate_listing` are context managers, I can instead represent that same logic as follows:    ```", "```py    Listing 11-34: *read_real_estate_listing_file.py:1b*    Once again, `__enter__()` does nothing, but it is called as a matter of convention on context managers. The `__exit__()` method closes the stream when I’m done. This version feels more verbose, but as it uses the special methods of the context manager, the logic can be handled entirely in a single `with` statement:    ```", "```py    Listing 11-35: *read_real_estate_listing_file.py:1c*    This is much easier to remember and type. It’s all made possible by context managers.    ### Using Multiple Context Managers    You can use multiple context managers in a `with` statement, which can open up all sorts of possibilities. For example, say I want to be able to read from two files at once, perhaps to combine them into one or to look for differences between them. (In the interest of expediency, I won’t actually do anything with these files in this example; I’ll just open them.)    To open multiple streams in a single `with` statement, I separate the `open()` expressions in the header with a comma, like this:    ```", "```py    Listing 11-36: *multiple_streams.py*    I can use the streams `left` and `right` in the usual manner. When the `with` statement ends, both streams are closed automatically.    ### Implementing the Context Management Protocol    The *context management protocol* is the fancy, official term for the `__enter__()` and `__exit__()` special methods. Any object that implements these two special methods can be managed by the `with` statement. They’re not limited to working with streams; you can use them to automate doing anything that needs to be done before or after usage of an object.    Remember that these methods need only be implemented. If you don’t need one or the other to actually do anything, don’t write any functionality into the unneeded method.    To demonstrate this, I’ll work with the example of a house showing. Before you can show a prospective buyer a home, you have to unlock the front door. When you leave, you lock the door again. This sort of pattern is precisely what a context manager is for.    First, I define the entire `House` class:    ```", "```py    Listing 11-37: *house_showing.py:1*    This class relies entirely on concepts from prior chapters, so I won’t detail implementation here. In short, a `House` object is initialized with an address, a value to use as the house key, and a keyword argument describing each room. You’ll notice that my initializer converts underscores in the keyword argument names to spaces before storing the room name in the `self._rooms` dictionary. It changes both the room name and the description to lowercase. This will make the usage of the class feel more obvious and less error-prone.    The important part of this example is the `HouseShowing` class, which I’ll ultimately write as a context manager by defining the `__enter__()` and `__exit__()` special methods in the upcoming [Listing 11-39](#listing11-39) and [Listing 11-41](#listing11-41), respectively. First, I’ll define the class and its initializer:    ```", "```py    Listing 11-38: *house_showing.py:2*    In the initializer, I accept two arguments: a `House` instance and the key value with which to unlock the house. In the next two sections, I’ll add the `__enter__()` and `__exit__()` special instance methods, to make `HouseShowing` a context manager.    ### The __enter__() Method    Before I can show any room in the `House`, I must always unlock the house first. If the key is wrong, I can’t get in, so there’s no point in continuing with the showing. Since this behavior should always occur before any other use of a `House` instance, it is handled by the `__enter__()` special instance method:    ```", "```py    Listing 11-39: *house_showing.py:3*    I attempt to unlock the house using the key with which I initialized `HouseShowing`. Notice that I don’t perform any error handling here. Always allow errors originating from the usage of your class to bubble up through this method, so the developer using your class can fix their code.    Importantly, I *must* return the instance from `__enter__()` for the `with` statement to be able to work with it!    The user should be able to work with this object directly, instead of having to drill down into an attribute. The main purpose of a house showing is to see the different rooms, so I write a method for that:    ```", "```py    Listing 11-40: *house_showing.py:4*    Once again, you’ll notice that I don’t handle any of the possible exceptions from `house.explore()` here, as they all relate to the usage of the class. If the error stems from how the class is used, the exception should be handled in the usage as well.    ### The __exit__() Method    When I leave the house, either because the tour is over or I couldn’t find a sunroom, I always want to lock up. That behavior is handled by the special instance method `__exit__()`:    ```", "```py    Listing 11-41: *house_showing.py:5*    This method must accept three arguments besides `self`. If an exception is raised anywhere in the suite of the `with` statement, these three parameters will describe the exception’s type (`exc_type`), message (`exc_val`), and traceback (`exc_tb`). If there is no exception, all three of these parameters will have the value `None`. The parameter names I’m using here are conventional. You can call them whatever you like, but I recommend sticking with these names unless you have a good reason to change them.    Although `__exit__()` must accept these arguments, you’re not required to do anything with them. They’re useful if you need to take different close or cleanup actions when certain exceptions occur. In my case, if there was any exception ❶, I apologize to the client while locking up the house ❷. In my particular code, I make no use of the message (`exc_val`) and traceback (`exc_tb`) arguments. If there was no exception, I only lock the house.    Importantly, `__exit__()` *does not have any role in raising or handling the error*! It acts as a listener, eavesdropping on any exceptions that occur in the `with` suite. Within `__exit__()`, I use conditional statements to work with the exceptions passed as arguments. I cannot use `try` for this, because any exceptions never bubble up through `__exit__()` directly, as you’ll notice in [Listing 11-34](#listing11-34). I should never re-raise the exceptions passed in either, because any exception that occurs in the suite of the `with` will be raised by the responsible statement and should be handled by the caller. Once again: `__exit__()` has no role in handling these exceptions. The only exceptions that an `__exit__()` method should ever handle are those its own suite directly caused.    ### Using the Custom Class    Now that my class is a context manager, I can write my usage. I start by creating a `House` object:    ```", "```py    Listing 11-42: *house_showing.py:6*    In creating the `House` instance, I’m defining a `house_key` value of `1803`, which is the value I’ll have to provide later when defining the `HouseShowing`.    I create a new `HouseShowing` in the context of a `with` statement, passing the `House` instance I created (`house`) to it. For the sake of example, I’m using the wrong `house_key` value (`9999`), so I should get an exception:    ```", "```py    Listing 11-43: *house_showing.py:7a*    In the header, I create a new instance of `HouseShowing`. Its `__enter__()` method is called by the `with` statement. The value returned from `__enter__()` is bound to `showing`. If I had forgotten to return anything from `__enter__()` in [Listing 11-39](#listing11-39), `showing` would have been bound to `None`, and this code wouldn’t have worked.    Since `house_key` is wrong and I cannot unlock the house, here’s the output from running the program as it is right now:    ```", "```py    Because the `house_key` value was wrong, `showing.__enter__()` encountered an exception, which I allowed to remain unhandled. This is important, because my code in [Listing 11-43](#listing11-43) is wrong. I need to pass the correct value for `house_key`. The `with` statement didn’t even try to run its suite. It encountered an exception and gave up.    I’ll correct the value I’m passing to `house_key`:    ```", "```py    Listing 11-44: *house_showing.py:7b*    Now, I’ll be able to unlock the house. In the suite of the `with` statement, I make three calls to the `show()` method. The first two will work, because the `House` instance bound to `house` has those rooms defined (see [Listing 11-42](#listing11-42)), but the third will fail with an exception. Take a look at the output:    ```", "```py    The `with` statement calls `showing.__enter__()` on `HouseShowing`, which in turn calls `house.unlock_house()`, as indicated by the message `House unlocked`. Then, with each call to `showing.show()` in the suite of the `with` statement, a description of the requested room is printed out.    The third call to `showing.show()` in [Listing 11-44](#listing11-44), requesting to see the porch, fails with an exception because the house doesn’t have a porch. Instead, `showing.__exit__()` is called, and the exception is passed to it. The apology is printed, and then `house.lock_house()` is called.    After all this, the traceback of the exception is printed.    To fix the problem with the code, I’d need to drop the request to see the porch and replace it with a room that does exist. Perhaps I’ll look at the kitchen instead.    ```", "```py    Listing 11-45: *house_showing.py:7c*    Running this version outputs the following:    ```", "```py    No errors here. The house is unlocked, the requested rooms are shown, and then the house is locked again. Because there were no exceptions raised in the suite, `house.__exit__()` does not print the apology from before.    ## Paths    So far, I’ve used files located in the same directory as the module opening them. In real programs, a file may be anywhere on the system. This is far from trivial, which is probably why most tutorials skim over this topic. I’ll dive deep into file paths here.    First, file paths are not the same on all operating systems. UNIX-style systems, such as macOS and Linux, use the POSIX file path conventions, while Windows uses an entirely different scheme. Second, you can’t always be sure what directory your code is being run in, so relative paths only get you so far. Third, you can’t make assumptions about the name or location of important directories, such as the user’s home directory. In short, file paths are tricky to generalize.    To get around all of these issues, Python offers two modules: `os` and `pathlib`. Up until Python 3.6, using the `os` package and its submodule (`os.path`) was the standard way of working with file paths. Even now, this remains a common approach. The `os` package allows you to work portably with whatever operating system your code is running on, yet the package as a whole is plagued with complexity, verbosity, and some pretty snarly legacy code. It’s also considered something of a “junk drawer,” since it contains all the functions and classes designed for working with the operating system. Thus, it can be hard to know what to use from the `os` module or even how to use it.    The `pathlib` module was introduced in Python 3.4 and became fully supported by `open()` in Python 3.6\\. It offers a cleaner, better organized, and more predictable way of handling paths. More importantly, it replaces most of `os.path` and cleanly incorporates much of the filesystem functionality offered by `os` and another useful module: `glob`, which allows you to find multiple paths fitting a particular pattern, following UNIX rules.    I recommend preferring `pathlib` for the sake of maintainability, readability, and performance, so that’s what I’ll focus on here. If you find yourself working with legacy code, or if you need a few of the advanced functions in `os.path`, refer to the official documentation for the `os.path` module: [https://docs.python.org/3/library/os.path.xhtml](https://docs.python.org/3/library/os.path.xhtml).    ### Path Objects    The `pathlib` module provides several related classes that represent filesystem paths. These are called *path-like* classes—as of Python 3.6, they all inherit from the `os.Pathlike` abstract class—and they are immutable representations of a filesystem path. Importantly, path-like objects are *not* based on strings; they’re unique objects with their own behaviors, based on the parts of a path and how those parts fit together, so they abstract out a lot of the logic.    One of the nice things about `pathlib` path objects is that they handle all the different filesystem conventions quietly, behind the scenes, as appropriate to the system: current directory (`.`), parent directory (`..`), slashes (`/` or `\\`), and so forth.    There are two types of path-like objects: *pure paths* and *concrete paths*.    #### Pure Paths    A *pure path* represents a path and allows you to work with it, without accessing the underlying filesystem. Instantiating an object from the `PurePath` class will automatically create a `PurePosixPath` or `PureWindowsPath` object behind the scenes, depending on the operating system. You can usually entrust this to Python to figure out, although you can instantiate the specific type of path if you need it for your code.    ```", "```py    Listing 11-46: *relative_path.py:1a*    I can pass the `PurePath` object to the `open()` function to open *../some_file.txt*. However, I cannot interact with the filesystem through the `path` object itself, as I attempt to do with `path.touch()`, which fails.    If you only intend to use the path in a call to `open()`, or if you otherwise don’t plan to interact with the system directly through the path object’s methods, then you should use a pure path, which will help prevent you from accidentally modifying the filesystem.    #### Concrete Paths    A *concrete path* provides methods for interacting with the filesystem. Instantiating an object from the `Path` class will create either a `PosixPath` or a `WindowsPath` object:    ```", "```py    Listing 11-47: *relative_path.py:1b*    This code is exactly the same as in [Listing 11-46](#listing11-46), except that I’m defining a `Path` object instead of a `PurePath`. As a result, I can still open the path, but I can also use methods on the `path` object to interact directly with the filesystem. For example, I can use `path.touch()` to create an empty file at *../some_file.txt*, if that file doesn’t already exist.    If you are explicitly coupling your implementation to a particular operating system, use either the `Windows` or the `Posix` form of the class; otherwise, use the `PurePath` or `Path` class.    ### Parts of a Path    A path-like object is made up of parts that the path class joins together behind the scenes, based on the operating system. There are two ways of writing a path: *absolute* and *relative*. Both ways of writing paths work in all the `PurePath` and `Path` objects.    An *absolute* path is one that starts from the root of the filesystem. The absolute path to a file always starts with an *anchor* and ends with the *name—the full filename. The name consists of a *stem* (that is, the filename) before the first nonleading dot and, typically, one or more *suffixes* after the dot. For example, consider the following fictional path:*   *```", "```py    The anchor here is the leading forward slash (`/`). The name is `file.txt`, with a stem of `file` and a suffix of `.txt`. I’ll break down a couple of more complex examples shortly.    These parts can be retrieved from the path-like object. You can use the `PurePath.parts()` method, which returns a tuple of parts. Otherwise, you can access specific components as properties.    Here’s a function that prints out each part of a path passed to it. I’ll discuss the function, then employ it in the next couple of sections to dissect a Windows path and a POSIX path, respectively.    ```", "```py    Listing 11-48: *path_parts.py:1*    The `path.parents` property is an iterable collection. The first item, `parents[0]`, is the immediate parent and is the same as `path.parent`. The next item, `parents[1]`, is the parent of `parents[0]`, and so on.    The `path.suffixes` property is a list of the suffixes, as some files can have more than one, especially on POSIX. These will be listed left to right, so `path.suffixes[-1]` is always the last suffix.    Now that I have this function, I can run a couple of paths through it to see the parts, which I’ll do in Listings 11-49 and 11-50.    #### Parts of a Windows Path    I’ll start by breaking down an absolute path on Windows. (It doesn’t matter here whether you’re working with a pure path or a concrete path; the paths *themselves* are structured the same in both.)    I break down the parts of an example path on Windows in [Figure 11-1](#figure11-1).  ![](image_fi/500920c11/f11001.png)    Figure 11-1: Parts of a Windows absolute path      In a Windows path, the anchor consists of the *drive*, which is `C:` in [Figure 11-1](#figure11-1), and a *root*, which is `\\`. The *parent* is the path to the containing directory—in this case, `C:\\Windows\\System\\`. That can be further broken down into three subparents: `C:\\` (also the anchor), `Windows\\`, and `System\\`.    The *name* consists of the *stem*, which is usually the filename (`python37`) before the first nonleading dot; and the *suffix* or *suffixes*, which is the file extension (`.dll`) after the dot.    I’ll break that down again, using my function from [Listing 11-48](#listing11-48):    ```", "```py    Listing 11-49: *path_parts.py:2a*    You’ll notice that I used forward slashes as the directory separator, which are not typically employed in Windows paths. The `pathlib` module allows me to use either forward slashes (`/`) or escaped backslashes (`\\\\`) for paths on any system, and it handles the switch behind the scenes. (Remember that single backslashes are escape characters in Python.) Forward slashes are less prone to typos, and using them eliminates the risk of accidentally omitting one of the pair of backslashes. I therefore recommend sticking with forward slashes when you can.    Running that code outputs all the parts of the path:    ```", "```py    This is consistent with the parts I outlined in [Figure 11-1](#figure11-1). I have the absolute path to each parent in ascending order, starting from the immediate parent of the file, `C:\\Windows\\System`.    The name is `python37.dll`, which is broken into the stem (`python37`) and one suffix (`.dll`).    #### Parts of a POSIX Path    Filesystem paths on UNIX-like systems, like Linux or macOS, are a little different. They follow the path conventions laid out by the POSIX standard.  ![](image_fi/500920c11/f11002.png)    Figure 11-2: Parts of a POSIX absolute path      In a POSIX absolute path, the *root* only contains the *anchor* (`/`). The *drive* part is always empty on POSIX paths, but the property itself exists for compatibility. The *name* part at the end consists of a *stem* (which again is generally the filename) before the first nonleading dot, plus one or more *suffixes* (which usually make up the file extension).    Passing that path to my `path_parts()` function from [Listing 11-48](#listing11-48) shows all these parts:    ```", "```py    Listing 11-50: *path_parts.py:2b*    The output is as follows:    ```", "```py    This example demonstrates a unique issue you may encounter with file extensions. While there are valid file extensions that consist of multiple suffixes, such as *.tar.gz* (for a GZ-compressed tarball), not every suffix is part of the file extension. This is a perfect example: the intended filename is `libpython3.7m`, but `pathlib` incorrectly interprets the `.7m` as one of the suffixes because of its leading dot. Meanwhile, because the intended file extension (`.so.1`) is actually composed of two suffixes, the stem is incorrectly detected as `libpython3.7m.so` and the suffix as just `.1`. You’ll need to keep this in mind when looking for the file extension on a path. There’s no simple or obvious way to resolve this; you have to take it case by case, as needed for your code. In short, don’t rely too much on `pathlib`’s ability to discern the stem and suffix; it can fail you in quite annoying ways.    ### Creating a Path    You can define a path using the desired class initializer, such as `PureWindowsPath` or `PosixPath`, by passing the path as a string. From there, you can use the path with `open()` or any other file operation. For example, on my own UNIX system, I can access my bash history like this:    ```", "```py    Listing 11-51: *read_from_path.py:1a*    Because I’m specifying a POSIX-format path and I plan to access the underlying filesystem using the methods on my `path` object, I use `PosixPath` class. If I wanted this to work on Windows as well, I’d use `Path`, but since `.bash_history` isn’t necessarily a file that appears on Windows, I’ll stick with `PosixPath` here.    After initializing the path-like object and binding it to `path`, I can open it. There are two ways to do this; either pass it to `open()` or use the functionally identical `open()` method on the `Path` object(not available on `PurePath`). I’ll use the latter:    ```", "```py    Listing 11-52: *read_from_path.py:2*    In this example, I only want the last line of the file, so I have to iterate over the whole thing. By time the loop finishes, the name `line` will have been bound to the string of the last line read. There’s no easier way to seek the end of a text file for reading.    Finally, I print out this line, stripping off the trailing line break by using the `strip()` method.    Running that code shows me the last line I ran in my shell:    ```", "```py    This works well on my machine, but it certainly won’t work on yours, unless your username is *also* `jason`. It also won’t work if your system structures home directories differently than mine. I need a more portable approach, and this is where `pathlib` really shines.    ```", "```py    Listing 11-53: *read_from_path.py:1b*    The `joinpath()` method combines two or more paths together and is available on all six `pathlib` classes. `PosixPath.home()` returns the absolute path to the current user’s home directory. (The same method exists on `WindowsPath` and refers to the user directory.)    I join `.bash_history` to this home directory path.    I can use this new path in the exact same way as in [Listing 11-51](#listing11-51). Running the revised code produces the same output:    ```", "```py    Yet, there’s an even shorter way: `pathlib` classes implement the forward-slash operator (`/`) to make it easier to join path-like objects to each other, or even to strings:    ```", "```py    Listing 11-54: *read_from_path.py:1c*    I’ll leave it to you to decide whether that reads cleaner than `PosixPath.joinpath()`, but I certainly prefer it. They’re functionally identical, so use whichever one feels more readable in your particular situation.    There’s one other shortcut I can use in this code. On UNIX-like systems, the tilde character (`~`) refers to the user’s home folder, so I could just write my entire path using this convention and then have `pathlib` expand to the full absolute path:    ```", "```py    Listing 11-55: *read_from_path.py:1d*    This is the most readable approach by far, and it behaves the same as before.    ### Relative Paths    A *relative* path is one that starts from the current position, instead of the root of the filesystem. Path-like objects can handle relative paths just as easily as absolute ones. Relative paths are based on the *current working directory*, which is the directory the user (or system) is currently running commands from.    This is useful, for example, if I have a Python program, `magic_program`, that I invoke from the command line and to which I can pass a path. The path will be received by the program as a string and will be interpreted as a `Path` object. If my current working directory were something long or difficult to type, it would be quite inconvenient to have to type an absolute path to a file contained in (or below) that directory, like this:    ```", "```py    This invocation is painful! If I’m already in that *DeadSimplePython/* directory, I should be able to pass a relative path:    ```", "```py    Whew! That’s much easier to use. Because of relative paths, it would be possible to write this program.    You can get the current working directory with the `Path.cwd()` command, like this:    ```", "```py    That code would print out the absolute path to the current working directory, in the appropriate path format for your system.    Any path that does not lead with an anchor (typically `/`) is considered a relative path. Additionally, a single dot (`.`) represents the current directory, and a double dot (`..`) represents the previous, or parent, directory. In this way, you can construct a relative path in the same manner as an absolute path. For example, if I wanted to look for a `settings.ini` file in the parent of the current working directory, I could do so with the following:    ```", "```py    This path can be converted to an absolute path using the `Path.resolve()` method. It resolves the dot operators (`.` and `..`) in paths and any symbolic links. Other redundant path elements, such as extra slashes or unnecessary dot operators (such as `.//dir1/../dir1///dir2`), are cleaned up.    Although I could resolve the path in a subsequent line of code, I prefer to modify that line to resolve the path right on the spot.    ```", "```py    `path` is now an absolute path to *settings.ini*.    ### Paths Relative to Package    Sooner or later, you’ll want to package noncode resources (like images or sounds) alongside your Python project and then access them from your code. You won’t know for certain where the user has placed your Python project directory on his or her filesystem; even if you knew where it *should* be, the user or system might have moved it. You need a way to create the absolute path to the noncode resources you shipped with your package. “Aha!” you may think. “This is a perfect situation for a relative path!” You would be wrong.    A common trap to fall into is to assume that the current working directory is the location of the current or main Python module. *That is not necessarily the case!* When you set up your project correctly, as I described in Chapter 4, you can run a Python module from anywhere on the system. Your current location is the current working directory, and all paths will be relative to that location. You need a way to find the resources that does *not* depend on the current working directory; in other words, relative paths are out.    I’ll use my *omission* project from Chapter 4 as an example. Here’s the project structure:    ```", "```py    Listing 11-56: File structure for *omission* project    With my module *omission/game/contentloader.py*, I want to load the text file containing the game content, which is stored at *omission/resources/content/content.txt*.    In my initial attempt, I incorrectly assumed the current working directory would be the location of *content_loader.py*. Thus, I tried to open the *content.txt* file with a relative path something like this:    ```", "```py    Listing 11-57: *content_loader.py:1a*    Because I was starting my *omission* program by running *omission.py* from the root of my repository, *omission-git* was incidentally my working directory, so this code appeared to work.    Temporarily sticking the following line of code into my *content_loader.py* module confirmed that, by printing out the absolute path to that directory:    ```", "```py    “That’s easy,” I thought to myself. “I just write all my paths relative to `omission-git`.” (This is where things went really wrong!) I changed my code to use paths relative to that *omission-git/* directory like this:    ```", "```py    Listing 11-58: *content_loader.py:1b*    The program appeared to work now—I could pass `path` to `open()` and read the contents without any problems. All my tests passed, and I happily moved on. It wasn’t until I started packaging that I discovered something was still wrong. If I executed the *omission.py* module from any directory other than the one it was stored in, the program would crash with a `FileNotFoundError`.    After checking the current working directory again, as before, I realized what I mentioned earlier: the current working directory is wherever the module is invoked *from*, not where it lives, and all paths are relative to that current working directory.    The solution was to base my relative paths off of the special `__file__` attribute of modules, which contains the absolute path to the module on the current system. I utilize that special attribute like this:    ```", "```py    Listing 11-59: *content_loader.py:1c*    I convert the `__file__` attribute to a `Path` object. Since this attribute may return a relative path, I use `resolve()` to convert it to an absolute path, so I don’t have to bother with the current working directory. `path` is now an absolute path to the current module. I need to work with an absolute path for the rest of this code to work.    Next, now that I have an absolute path to this *content_loader.py* module, I can craft a path to the file I want *relative to this module*. Knowing my project’s directory structure, I need to start from the top-level package, `omission`, instead of in the `game` subpackage this module is in. I get this part of the path with `path.parents[1]`, for the parent path, one level removed.    Finally, I combine the absolute path of the `omission` package with the relative path to the file I want. The result is an absolute path to my *content.txt* file that will work, no matter where the `omission` package lives on the filesystem or where it’s executed from.    This approach works for most practical cases, but beware that `__file__` is an *optional* attribute. It’s not defined for built-in modules, C modules that are statically linked to the interpreter, and anything run in the REPL. To get around these problems, you can use the rather robust `pkg_resources` module to achieve the same end as you would with `__file__`. You can learn more about this from [https://setuptools.readthedocs.io/en/latest/pkg_resources.xhtml](http://setuptools.readthedocs.io/en/latest/pkg_resources.xhtml).    Unfortunately, both `__file__` and libraries like `pkg_resources` are incompatible with some packaging tools. This is really more of problem with the tools than with the pattern, since no one has any alternatives! There’s no more elegant solution here. Just be aware of this limitation when selecting packaging tools.    ### Path Operations    The `pathlib` concrete path objects provide methods of performing many common file operations in a platform-agnostic fashion. Two of the most convenient of these methods are `Path.read_text()` and `Path.write_text()`, which provide a quick way to read and write entire text files without having to define a separate stream object or `with` statement. In this usage, the stream object is created and managed internally, within the `Path` object. The former reads in and returns the entire contents of the file as a string; the latter writes a string out as a file, overwriting the existing file if there is one.    [Table 11-2](#table11-2) outlines several more of the file operation methods on `Path`. Each of these would be run directly on a `Path`, `WindowsPath`, or `PosixPath` object, referred to as `path` below.      Table 11-2: Filesystem Operations on Path       | **File operation methods** | **Functionalities** | | --- | --- | | `path.mkdir()` | Creates a directory at `path`. If the optional `parents=` argument is `True`, it will create any missing parent directories. | | `path.rename(``name``)` | Renames the item (file or directory) at `path` to `name`. On Unix, if the file `name` exists at the path and the user has the correct permissions, it will be replaced. | | `path.replace(``name``)` | Renames the item (file or directory) at `path` to `name`, replacing any existing file by that name. Unlike `rename`, this will *always* replace any existing file by the same name, assuming the correct file permissions. | | `path.rmdir()` | Removes the directory at `path`. It must be empty; otherwise, an `OSError` will be raised. | | `path.unlink()` | Removes the file or symbolic link (filesystem shortcut) at `path`. Cannot be used to remove directories. In Python 3.8 and later, if the optional `missing_ok=` argument is `True`, attempting to remove a file that does not exist will *not* raise `FileNotFoundError`. | | `path.glob()` | Returns a generator of path-like objects for all items at `path` that match the specified `pattern`, according to the syntax of a Unix-style `glob` search. | | `path.iterdir()` | Returns a generator of path-like objects for all items at `path`. | | `path.touch()` | Creates an empty file at `path`. Normally, nothing happens if it already exists. If the optional `exist_ok=` argument is `False` and the file exists, a `FileExistsError` is raised. | | `path.symlink_to(``target``)` | Creates a symbolic link at `path` to `target`. | | `path.link_to(``target``)` | Creates a hard link at `path` to `target` (Python 3.8 and later only). |    In addition, you get information about the file or directory a `Path` object points to, as shown in [Table 11-3](#table11-3).      Table 11-3: File Information Methods on Path       | **File information methods** | **Functionalities** | | --- | --- | | `path.exists()` | Returns `True` if `path` points to an existing file or symbolic link. | | `path.is_file()` | Returns `True` if `path` points to a file or symbolic link to a file. | | `path.is_dir()` | Returns `True` if `path` points to a directory or symbolic link to a directory. | | `path.is_symlink()` | Returns `True` if `path` points to a symbolic link. | | `path.is_absolute()` | Returns `True` if `path` is absolute. |    I’ve only covered a portion of `pathlib`’s functionality. I strongly recommend you browse through the official module documentation, which has a complete list of methods and their usages: [https://docs.python.org/3/library/pathlib.xhtml](https://docs.python.org/3/library/pathlib.xhtml).    ### Out-of-Place File Writes    As I mentioned earlier in the chapter, `path.replace()` is particularly useful as part of a technique for preventing file corruption if there’s a computer or program crash during writing. Instead of directly modifying a file in place, you can write to a new file and then replace the old file with the new version.    To demonstrate this, I’ll rewrite one of my earlier examples (Listings 11-37 through 11-39) to employ `pathlib` and use this technique:    ```", "```py    Listing 11-60: *rewrite_using_tmp.py:1*    I read in the file from *78SomewhereRd.txt* as before, except that this time, I only open the file in read mode, instead of read-write. Once I’ve finished with it, I can safely close the file. My revised data is waiting in the string `contents`.    Now, I create a new temporary file path and write my data out to that new file:    ```", "```py    Listing 11-61: *rewrite_using_tmp.py:2*    I use `path.with_name()` to create a new `Path`, with the name provided as an argument. In this case, the new name is the same as the old name, but with `.tmp` appended to the end. I open that new path in write mode and write the string `contents` out to it.    At this point, my original *78SomewhereRd.txt* and my new *78SomewhereRd.txt.tmp* files exist side by side. I conclude by moving the temporary file into the place of the original, overwriting it.    ```", "```py    Listing 11-62: *rewrite_using_tmp.py:3*    That `replace()` method has the operating system perform the replacement, instead of doing it itself. This is a virtually instantaneous operation, in contrast to writing to the file, which may take a bit of time, depending on the size. Now, I only have the revised *78SomewhereRd.txt*, and the temporary file is gone.    The benefit of this technique is that, had my computer crashed while I was writing to the file, the worst outcome would be that I’d have a corrupt *78SomewhereRd.txt.tmp* file. My original *78SomewhereRd.txt* would be unchanged and unharmed.    ### The os Module    Python’s `os` module allows you to interface with the operating system in a relatively platform-agnostic fashion. Most code written before Python 3.6, and even a lot of modern code, still uses the `os.path` and `os` modules for handling paths. As I’ve mentioned, `pathlib` is going to be the better tool for working with the filesystem in most cases, but `os` still has many uses. For some longtime Python developers, using `os` is also just a habit.    As of Python 3.8, `os.path` has 12 functions, with no existing equivalent in `pathlib`. One example is `os.path.getsize(``pathlike``)`, which returns the size of the item at `pathlike` in bytes. Meanwhile, `os` itself has dozens of functions for interacting with the filesystem in a much more low-level, technical fashion than `pathlib`.    Thankfully, since Python 3.6, `pathlib` and `os` play well together. I recommend using `pathlib` as much as you can—it will fully satisfy the majority of use cases—and bring in the `os` or `os.path` modules anytime you need one of their unique functionalities. The documentation will be helpful if you want to learn more about these modules: [https://docs.python.org/3/library/os.xhtml](https://docs.python.org/3/library/os.xhtml).    The `os` module is not limited to working with the filesystem, so it will come up again in later chapters.    ## File Formats    Up to this point, I’ve worked entirely with plaintext files. This works for storing plain strings, but it’s not usually sufficient for more structured data. Here, I’ll discuss working with other file formats.    In many cases, you’ll get more reliable results by using an existing standard file format. However, it’s always possible to design your own format and write custom parser logic for it, so long as you’re willing to put the effort into designing, testing, and maintaining it.    Python offers tools for a few of the most common formats in the standard library, and many other formats are supported through third-party libraries. Here, I’ll cover usage of the popular JSON format and then give an overview of a few other common formats.    The process of converting Python data to a format for storage is called *serialization*, and the reverse is *deserialization*.    ### JSON    *JSON*, or *JavaScript Object Notation*, is one of the most popular text-based file formats among Python developers. JSON data can be structured in a variety of ways, the most common being storing the contents of a Python dictionary in a file.    The built-in `json` module allows you to easily convert data between JSON data and many built-in Python data types and collections. In the case of JSON, serialization and deserialization are not perfect inverses of one another, as seen in [Table 11-4](#table11-4).      Table 11-4: JSON Serialization and Deserialization Types       | **Python (to serialize)** | **JSON (serialized)** | **Python (deserialized)** | | --- | --- | --- | | `dict` | object (All keys are strings!) | `dict` | | `list` `tuple` | array  | `list`  | | `bool` | boolean | `bool` | | `str` | string | `str` | | `int` `int-derived enums` | number (int)  | `int`  | | `float` `float-derived enums` | number (real)  | `float`  | | `None` | null | `None` |    Anything directly derived from these Python types can also be JSON-serialized, but all other objects *cannot* be serialized to JSON on their own and must be converted to a type that can be.    To make a custom class JSON-serializable, you would need to define a new object that subclasses `json.JSONEncoder` and overrides its `default()` method. See the documentation for more information about this: [https://docs.python.org/3/library/json.xhtml#json.JSONEncoder](https://docs.python.org/3/library/json.xhtml#json.JSONEncoder).    #### Writing to JSON    Writing to JSON is refreshingly simple, in comparison to working with many other file formats. You use the `json.dump()` function to convert data to JSON format and write it to a file. Alternatively, you use `json.dumps()` to create and write JSON code to a string if you want to wait and write it to a stream later. I’ll demonstrate the former technique in this example.    I’ll work with my `nearby_properties` nested dictionary from [Listing 11-7](#listing11-7), which I want to write out to a file I’ll call *nearby.json*:    ```", "```py    Listing 11-63: *write_house_json.py:1*    The only change from the prior example ([Listing 11-7](#listing11-7)) is that I’m now importing the `json` module.    I’m converting a dictionary containing only serializable types (see [Table 11-4](#table11-4)) directly to a stream using `json.dump()`:    ```", "```py    Listing 11-64: *write_house_json.py:2*    First, I use `open()` to create a writable stream for the *nearby.json* file. The `json.dump()` function requires two arguments. The first is the object being written out, which can be *any* serializable object. In this case, I’m writing out the dictionary `nearby_properties`.    The second argument is the stream I want to write to, which must be a writable text-based stream. Here, I pass `jsonfile`, which is the text-based stream opened in write mode in the `with` statement.    That’s all it takes to write a Python dictionary to a JSON file!    The `json.dumps()` function works in exactly the same manner, except that it returns a Python string containing the JSON code, rather than requiring you to pass a stream to it.    After running my code, I can open up the newly created *nearby.json* and see the contents, which are in JSON format:    ```", "```py    Listing 11-65: *nearby.json*    #### Reading from JSON    You can directly deserialize a JSON file into the corresponding Python object using the `json.load()` function, which accepts the source stream object as an argument. If I have JSON code in a Python string, I can also deserialize it directly with `json.loads()`, passing the string as an argument.    I’ll use `json.load()` to deserialize my nested dictionary from my *nearby.json* file:    ```", "```py    Listing 11-66: *read_house_json.py:1*    I open the JSON file in read mode, and then I pass the stream to `json.load()`. That will return the deserialized object, which in this case is a dictionary I bind to `nearby_from_file`.    There is one important difference between this dictionary and the one I started with in [Listing 11-65](#listing11-65). I’ll demonstrate this difference by printing out the literal representation of each key and value:    ```", "```py    Listing 11-67: *read_house_json.py:2*    The f-string here embeds the values of `k2` and `v2` in the string, and the `!r` formats them as if they had been run through `repr()`.    Can you spot the difference with this dictionary in the output?    ```", "```py    The key values for the inner dictionaries are strings now—instead of integers, as in the original dictionary ([Listing 11-63](#listing11-63))—because the key in a JSON object is always a string. This is a perfect example of serialization and deseralization not being inverse operations. If I wanted to get back to using integers for my keys, I’d need to rewrite this code to handle that conversion iteratively. That’s beyond the scope of this chapter, so I’ll leave this example as is.    ### Other Formats    I could devote an entire book just to working with file formats in Python (although I don’t think my editor would go for it). Instead, I’ll breeze through several of the most common formats. For each of these, you can pair the concepts from this chapter with the documentation for the particular modules or libraries you’re using.    #### CSV    One of the most common structured text formats is *CSV*, which stands for *comma-separated values*. As its name suggests, it separates individual values with commas. Sets of values are separated by newline characters (`\\n`).    CSV format is used by nearly all spreadsheets and databases, although seldom in a standardized manner. A CSV file exported by Excel may not be the same as one exported by a UNIX program. These subtle differences, known as *dialects*, ordinarily make working with CSV a bit tricky.    Python’s standard library includes a `csv` module that not only handles serializing to and deserializing from CSV files, but also abstracts out the differences between CSV dialects.    To learn more about the `csv` module, see the Python documentation: [https://docs.python.org/3/library/csv.xhtml#module-csv](https://docs.python.org/3/library/csv.xhtml#module-csv).    #### INI    The *INI* format is excellent for storing configuration files, especially settings. It’s an informal standard that is designed to be human-readable and easy to parse. You’ll find INI files on Windows and Unix systems alike. You’ve almost certainly encountered files like *php.ini* and *Desktop.ini*—and perhaps, you’ve even encountered *tox.ini*, which is used by many Python tools, including `flake8` and `pytest`. It’s also common to find *.conf*, *.cfg,* and even *.txt* files that use this INI format.    Python’s standard library includes the `configparser` module for working with INI-style files, although this module invented its own format for multiline strings. This makes the module’s output potentially incompatible with anything other than Python’s `configparser`, and it has no support for nested sections. It also can’t work with the value-type prefixes used by Windows Registry-style INI files.    See the official documentation for `configparser` to learn how to use it: [https://docs.python.org/3/library/configparser.xhtml#module-configparser](https://docs.python.org/3/library/configparser.xhtml#module-configparser).    Alternatively, the third-party library *configobj* supports nested sections and the standard multiline strings, along with many other features lacking in `configparser`. Files created by this module are compatible with other INI parsers, especially those in other languages. The official documentation for this library is available at [https://configobj.readthedocs.io/en/latest/](https://configobj.readthedocs.io/en/latest/).    #### XML    *XML* is a structured markup language based upon the idea of tags, elements, and attributes. Many other file formats use the XML syntax, including *XHTML*, *SVG*, *RSS*, and most office document formats (*DOCX* and *ODT*). You can use XML to devise your own text-based file formats.    Python developers often shun XML in favor of JSON, for two reasons: *simplicity of usage* and *security*. The same structures can be represented in both JSON and XML, but working with XML in Python involves eight different modules. These are all covered in detail at [https://docs.python.org/3/library/xml.xhtml](https://docs.python.org/3/library/xml.xhtml). Given a choice between XML and JSON, you’ll always find it easier to work with the latter.    XML also has a number of security vulnerabilities, which must be taken into account whenever you’re deserializing untrusted or unauthenticated data. The built-in Python modules specifically are vulnerable to some of these attacks, so when security is a factor, the documentation advises use of the *defusedxml* and *defusedexpat* third-party libraries.    Alternatively, you can use the third-party library *lxml*, which addresses many of these issues. More information about this library is available at [https://lxml.de/](https://lxml.de/).    #### HTML    I doubt I need to tell you what *HTML* is, since it is ubiquitous on the internet. Python allows you to work with HTML files via the built-in `html` module and its two submodules: `html.parser` and `html.entities`. This is a very deep rabbit hole (unsurprisingly), so I’ll leave you to explore it on your own if you’re interested. The documentation is a good place to start: [https://docs.python.org/3/library/html.xhtml](https://docs.python.org/3/library/html.xhtml).    There are also some excellent third-party libraries for working with HTML, including *lxml.xhtml* (part of *lxml*) and *beautifulsoup4*. You can learn more about the latter at [https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/).    #### YAML    *YAML* is a popular alternative to markup languages like XML; its name is a recursive acronym for *YAML Ain’t Markup Language*. YAML covers many of the same use cases as XML, but with a simpler syntax.    The latest version of this language—YAML 1.2—implements all the features of JSON, in addition to its own syntax. This means all JSON is also valid YAML 1.2\\. Besides this, all JSON output by Python using default settings is compatible with YAML 1.0 and 1.1\\. Thus, at least in Python, YAML is always a superset of JSON. One particular advantage of YAML over JSON is its support for comments.    The third-party *PyYAML* library is listed on the Python wiki as being the only YAML parser that has attempted compliance with the YAML standard. More information about this library can be found at [https://pyyaml.org/](https://pyyaml.org/).    YAML does have potential security concerns—namely, it can be used to execute arbitrary Python code. The PyYAML library has a `yaml.safe_load()` function that mitigates this risk, so that should be used instead of `yaml.load()`.    #### TOML    Another option for configuration files is *TOML*, an acronym for *Tom’s Obvious, Minimal Language*. It’s an open format created by Tom Preston-Werner. It draws inspiration from INI, but it implements a formal specification.    The most popular third-party library for working with TOML is appropriately called *toml*. You can learn more about it at [https://github.com/uiri/toml/](https://github.com/uiri/toml/).    #### ODF    The *Open Document Format* (ODF) is an XML-based document format developed and maintained by the Organization for the Advancement of Structured Information Standards (OASIS). It is being widely adopted and is increasingly becoming a ubiquitous document standard. It is used by nearly all modern word processors, including LibreOffice, Microsoft Word, and Google Docs.    The primary use for ODF is when working with data ordinarily handled by an office suite. Perhaps you’re writing a grammar checker, a spreadsheet validator, a word processor, or a slide deck organizer.    One of the most popular Python libraries for working with the Open Document Format is *odfpy*, which is developed and maintained by the European Environmental Agency. More information and documentation for this library is available at [https://github.com/eea/odfpy/wiki/](https://github.com/eea/odfpy/wiki/).    #### RTF    The *Rich Text Format* (RTF) is a popular document format that supports basic text formatting. Although it’s a proprietary format originally developed by Microsoft for Word, it’s relatively common for basic documents because of its simplicity and portability. Although the format is no longer in active development and has lost ground to the Open Document Format, it is still just as usable as ever.    There are a few third-party packages for working with Rich Text Format. The most popular library for Python 2 was *PyRTF*. Two forks of that library exist for Python 3: *PyRTF3* and *rtfx*. (As of this writing, the *PyRTF3* library is unmaintained, although it is still available in pip.) *RTFMaker* is a newer alternative, presently under active development. Unfortunately, documentation for all four libraries is sparse, so plan on sailing into uncharted waters if you use any of these libraries.    Alternatively, if none of these libraries do what you need or you don’t want to work without documentation, the Rich Text Format is simple enough that you can write your own basic parser with a little research. It’s a closed specification, so it can be hard to find the official documents, but version 1.5 of the Rich Text Format Specification is archived here: [http://www.biblioscape.com/rtf15_spec.htm](http://www.biblioscape.com/rtf15_spec.htm).    ## Wrapping Up    Who would have guessed how much was involved in working with text files in Python? I’ve only scratched the surface of this topic, the complexity of which is belied by the existence of so many five-minute beginner’s tutorials.    Opening a file is easy enough, using a `with` statement and the `open()` function. The `pathlib` module handles paths in a platform-agnostic fashion, so you can stop worrying about which way your slash is supposed to lean. Dozens of modules (from the standard library and third-party developers) exist for handling the countless text-based file formats out there, often via a few method calls. When you put all these pieces together, you ultimately get delightfully simple, yet robust, patterns for handling text files.    In the next chapter, I’ll introduce the techniques necessary to work with binary data in Python, especially in the context of reading and writing binary files.    It feels good to move beyond the boundaries of the program execution and create real files on the user’s computer, doesn’t it?*```"]