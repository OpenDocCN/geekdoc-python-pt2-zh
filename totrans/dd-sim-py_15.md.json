["```py\nchapter = 0xc\nprint(chapter)  # prints '12'\n```", "```py\nchapter = 0xc\nprint(bin(chapter))  # prints '0b1100'\nprint(hex(chapter))  # prints '0xc'\nprint(oct(chapter))  # prints '0o14'\n```", "```py\nprint(bin(42))   # prints  '0b101010'\nprint(bin(-42))  # prints '-0b101010'\n```", "```py\nprint(bin(-42 & 0b11111111))  # prints '0b11010110'\n```", "```py\n 0b**1**101\n& 0b**1**010\n= 0b**1**000\n```", "```py\n 0b**11**0**1**\n| 0b**1**0**1**0\n= 0b**1111**\n```", "```py\n 0b1**101**\n^ 0b1**010**\n= 0b0**111**\n```", "```py\n~ 0b0101\n= 0b1010\n```", "```py\n~ 0b000...0101\n= 0b111...1010\n```", "```py\nprint(bin(~0b0101))           # prints '-0b110' (that is, -0b0101 - 0b1)\nprint(bin(~0b0101 & 0b1111))  # prints '0b1010' (much better)\n```", "```py `<<`) and *Right Shift* (`` `>>`) operators. In binary arithmetic, there are two types of shifts, of which a programming language can only use one on its shift operators. The *logical shift* allows bits to “drop off” the end of the number, shifting in zeros at the other end to replace discarded bits. The *arithmetic shift* does the same as the logical shift, but it will also shift in the *sign bit* (`1` in negative numbers) where necessary to preserve the sign. `` ```", "```py`` ```", "```py print(bin(0b1100 << 4))   # prints '0b11000000' ```", "```py print(bin(0b1100 >> 4))   # prints  '0b0' (0b0...0000) print(bin(-0b1100 >> 4))  # prints '-0b1' (0b1...1111) ```", "```py bits = b\"HELLO\" ```", "```py bits = b\"**\\x48\\x45\\x4C\\x4C\\x4F**\" ```", "```py bits_escaped = b\"\\\\A\\\\B\\\\C\\\\D\\\\E\" bits_raw = br\"\\A\\B\\C\\D\\E\" print(bits_raw)                  # prints b'\\\\A\\\\B\\\\C\\\\D\\\\E' print(bits_escaped == bits_raw)  # prints 'True' ```", "```py bits = bytes(0b110) print(bits)  # prints '\\x00\\x00\\x00\\x00\\x00\\x00' ```", "```py bits = bytes(**(**0b110**,)**) print(bits)  # prints \"b'\\x06'\" ```", "```py bits = b'\\x06' print(bits)  # prints \"b'\\x06'\" ```", "```py bits = **bytearray(**b'\\x06'**)** print(bits)  # prints \"b'\\x06'\" ```", "```py bits = bytes('☺', encoding='utf-8') print(bits)  # prints \"b'\\xe2\\x98\\xba'\" ```", "```py import sys  print(sys.byteorder)  # prints 'little' ```", "```py answer = 42 bits = answer.to_bytes( ❶ 4, byteorder=sys.byteorder) print(bits.hex( ❷ sep=' '))  # prints '2a 00 00 00' ```", "```py answer = -42 bits = answer.to_bytes(4, byteorder=sys.byteorder) print(bits.hex(sep=' ')) ```", "```py Traceback (most recent call last):   File \"tofrombytes.py\", line 10, in <module>     bits = answer.to_bytes(4, byteorder=sys.byteorder) OverflowError: can't convert negative int to unsigned ```", "```py answer = -42 bits = answer.to_bytes(4, byteorder=sys.byteorder**, signed=True**) print(bits.hex(sep=' '))  # prints 'd6 ff ff ff' ```", "```py answer = 42 bits = answer.to_bytes(4, byteorder=sys.byteorder, **signed=True**) print(bits.hex(sep=' '))  # prints '2a 00 00 00' ```", "```py bits = b'\\xaa\\xbb\\xcc\\xdd\\xee\\xff' print(b'\\xcc\\xdd' in bits)  # prints 'True' ```", "```py import sys  bits = ❶ (-42).to_bytes(4, byteorder=sys.byteorder, signed=True) ```", "```py answer = int.from_bytes(bits, byteorder=sys.byteorder, signed=True) print(answer)  # prints '-42' ```", "```py import struct  bits = struct.pack('>ii?', 4, 2, True) print(bits)  # prints '\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x02\\x01' ```", "```py import struct  bits = struct.pack(**'>2i?'**, 4, 2, True) print(bits)  # prints '\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x02\\x01' ```", "```py import struct  bits = struct.pack('>i3xi', -4, -2) print(bits)  # prints '\\xff\\xff\\xff\\xfc\\x00\\x00\\x00\\xff\\xff\\xff\\xfe' ```", "```py import struct  bits = struct.pack('>4s', b\"Hi!\") print(bits)  # prints 'Hi!\\x00' ```", "```py bits = struct.pack('>4p', b\"Hi!\") print(bits)  # prints '\\x03Hi!' ```", "```py struct.calcsize('@llh')    # prints '18' (wrong) struct.calcsize('@llh0l')  # prints '24' (correct, what C expects) ```", "```py import struct  answer = -360 bits = struct.pack('i', answer) ```", "```py new_answer, = struct.unpack('i', bits) print(new_answer)  # prints '-360' ```", "```py first, second = struct.unpack('>i3xi', bits) print(first, second)  # prints '-4 -2' ```", "```py wrong = struct.unpack('<i3xi', bits)   # wrong byte order print(*wrong)                          # prints '-50331649 -16777217'  wrong = struct.unpack('>f3xf', bits)   # wrong types print(*wrong)                          # prints 'nan nan'  wrong = struct.unpack('>hh3xhh', bits) # wrong integer type print(*wrong)                          # prints '-1 -4 -1 -2'  wrong = struct.unpack('>q3xq', bits)   # data sizes too large print(*wrong)                          # throws struct.error ```", "```py import struct  packer = struct.Struct('iif') ```", "```py def number_grinder(n):     for right in range(1, 100):         left = right % n         result = left / right         yield packer.pack(left, right, result) ```", "```py for bits in number_grinder(5):     print(*packer.unpack(bits)) ```", "```py def bitwise_and(left, right, *, byteorder):     size = max(len(left), len(right)) ```", "```py  left = int.from_bytes(left, byteorder=byteorder)     right = int.from_bytes(right, byteorder=byteorder) ```", "```py  result = left & right     return result.to_bytes(size, byteorder, signed=True) ```", "```py bits = b'\\xcc\\xcc\\xcc'   # 0b110011001100110011001100 bitfilter = b'\\xaa\\xaa'  # 0b1010101010101010  result = bitwise_and(bits, bitfilter, byteorder='big') print(result)            # prints \"b'\\x00\\x88\\x88'\" ```", "```py def bitwise_and(left, right):     return bytes(l & r for l, r in zip(left, right)) ```", "```py bits = b'\\xcc\\xcc\\xcc'   # 0b110011001100110011001100 bitfilter = b'\\xaa\\xaa'  # 0b1010101010101010  result = bitwise_and(bits, bitfilter) print(result)            # prints \"b'\\x88\\x88'\" ```", "```py import itertools   def bitwise_and(left, right, ***, byteorder**):  **pad_left = itertools.repeat(0, max(len(right) - len(left), 0))**  **pad_right = itertools.repeat(0, max(len(left) - len(right), 0))**  ****if byteorder == 'big':**  **left_iter = itertools.chain(pad_left, left)**  **right_iter = itertools.chain(pad_right, right)**  **elif byteorder == 'little':**  **left_iter = itertools.chain(left, pad_left)**  **right_iter = itertools.chain(right, pad_right)**  **else:**  **raise ValueError(\"byteorder must be either 'little' or 'big'\")**          return bytes(l & r for l, r in zip(**left_iter, right_iter**))** ```", "```py bits = b'\\xcc\\xcc\\xcc'   # 0b110011001100110011001100 bitfilter = b'\\xaa\\xaa'  # 0b1010101010101010  result = bitwise_and(bits, bitfilter**, byteorder='big'**) print(result)            # prints \"b'\\x00\\x88\\x88'\" ```", "```py def verify(bits):     for i in range(3, len(bits), 5):         if bits[i:i+2] != b'\\xff\\xff':             return False     return True ```", "```py good = b'\\x11\\x22\\x33\\xff\\xff\\x44\\x55\\x66\\xff\\xff\\x77\\x88' print(verify(good))  # prints 'True'  nope = b'\\x11\\x22\\x33\\xff\\x44\\x55\\x66\\x77\\xff\\x88\\x99\\xAA' print(verify(nope))  # prints 'False' ```", "```py def verify(bits):     **is_good = True**  **view = memoryview(bits)**     for i in range(3, len(**view**), 5):         if **view**[i:i+2] != b'\\xff\\xff':             **is_good = False**             **break**     **view.release()**     return **is_good** ```", "```py def verify(bits):     **with memoryview(bits) as view:**         for i in range(3, len(view), 5):             if view[i:i+2] != b'\\xff\\xff':                 **return False**  **return True** ```", "```py rw_binary_example/ ├── book.py ├── bookshelf.py ├── __init__.py ├── __main__.py ```", "```py import struct   class Book:      packer = ❶ struct.Struct(\">64sx64sx2h\")      def __init__(self, title=\"\", author=\"\", pages=0, pages_read=0):         self.title = title         self.author = author         self.pages = pages         self.pages_read = pages_read              def update_progress(self, pages_read):         self.pages_read = min(pages_read, self.pages) ```", "```py  def serialize(self):         return self.packer.pack(             self.title.encode(),             self.author.encode(),             self.pages,             self.pages_read         ) ```", "```py import struct from .book import Book  class Bookshelf:     fileinfo = ❶ struct.Struct('>h')     version = 1      def __init__(self, *books):         self.shelf = [*books]              def __iter__(self):         return iter(self.shelf)              def add_books(self, *books):         self.shelf.extend(books) ```", "```py  def write_to_stream(self, stream):         stream.write(self.fileinfo.pack(self.version))         for book in self.shelf:             stream.write(book.serialize()) ```", "```py from .bookshelf import Bookshelf from .book import Book   def write_demo_file():     # Write to file      cheuk_ting_bookshelf = Bookshelf(         Book(\"Automate the Boring Stuff with Python\", \"Al Sweigart\", 592, 592),         Book(\"Doing Math with Python\", \"Amit Saha\", 264, 100),         Book(\"Black Hat Python\", \"Justin Seitz\", 192, 0),         Book(\"Serious Python\", \"Julien Danjou\", 240, 200),         Book(\"Real-World Python\", \"Lee Vaughan\", 370, 370),     ) ```", "```py  with open('mybookshelf.shlf', 'bw') as file:         cheuk_ting_bookshelf.write_to_stream(file) ```", "```py def read_demo_file():     \"\"\"TODO: Write me.\"\"\" ```", "```py if __name__ == \"__main__\":     write_demo_file() ```", "```py  @classmethod     def deserialize(cls, bits):         title, author, pages, pages_read = cls.packer.unpack(bits)         title = title.decode()         author = author.decode() ```", "```py  return cls(title, author, pages, pages_read) ```", "```py  @classmethod     def from_stream(cls, stream):         size = cls.fileinfo.size         version, = cls.fileinfo.unpack(stream.read(size))         if version != 1:             raise ValueError(f\"Cannot open .shlf v{version}; expect v1.\") ```", "```py  size = Book.packer.size         shelf = Bookshelf() ```", "```py  while bits := stream.read(size):             shelf.add_books(Book.deserialize(bits))                      return shelf ```", "```py def read_demo_file():     with open('mybookshelf.shlf', 'br') as file:         lais_bookshelf = Bookshelf.from_stream(file)              for book in lais_bookshelf:         print(book.title) ```", "```py if __name__ == \"__main__\":     write_demo_file()     read_demo_file() ```", "```py Automate the Boring Stuff with Python Doing Math with Python Black Hat Python Serious Python Real-World Python ```", "```py from pathlib import Path Path('binarybits.dat').write_bytes(b'ABCDEFGHIJKLMNOPQRSTUVWXYZ')   with open('binarybits.dat', 'br') as file:     file.seek(-6, 2) ```", "```py  file.seek(2, 1) ```", "```py from pathlib import Path Path('readfrom.dat').write_bytes(b'\\xaa\\xbb\\xcc') ```", "```py from io import BufferedRWPair with BufferedRWPair(Path('readfrom.dat').open('rb'), Path('writeto.dat').open('wb')) as buffer:     data = buffer.read()     print(data)  # prints \"b'\\xaa\\xbb\\xcc'\"     buffer.write(data) ```", "```py Path('writeto.dat').read_bytes()  # prints \"b'\\xaa\\xbb\\xcc'\" ```", "```py` ```"]