<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_203"/><span class="big">8</span><br/>ORGANIZING VALUES USING SETS AND DICTIONARIES</h2>&#13;&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="150" height="150"/></div>&#13;&#13;
<p class="noindents">A Python list is useful whenever we need to store a sequence of values, such as the heights of action figures or the words in an essay. Lists make it easy for us to keep values in order and access a value given its index. As we’ll see in this chapter, though, there are operations that lists are not optimized for, including identifying whether a specific value is in a collection and making associations between pairs of values.</p>&#13;&#13;
<p class="indent">In this chapter, we’ll learn about Python sets and dictionaries, two alternatives to lists for storing collections of values. We’ll see that a set can be the tool of choice when we need to search for specific values and don’t care about their order and that a dictionary can be the tool of choice whenever we need to work with pairs of values.</p>&#13;&#13;
<p class="indent">We’ll solve three problems using these new collections: determining the number of unique email addresses, finding common words in a list of words, and determining the number of special pairs of cities and states.</p>&#13;&#13;
<h3 class="h3a" id="ch08lev1sec1"><span epub:type="pagebreak" id="page_204"/><span class="h3aa">Problem #18: Email Addresses</span></h3>&#13;&#13;
<p class="noindent">In this problem, we’ll store a collection of email addresses. We won’t care about the number of times that each email address shows up, and we won’t care about maintaining the order of the email addresses. These lax storage requirements mean that we can forgo a list for a set—a Python type whose speed leaves lists in the dust. We’re going to learn all about sets.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <code>ecoo19r2p1</code>.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec1">The Challenge</h4>&#13;&#13;
<p class="noindent">Did you know that there are many ways to write someone’s Gmail email address?</p>&#13;&#13;
<p class="indent">We can take someone’s Gmail address and add a plus (<code>+</code>) symbol and a string before the <code>@</code> symbol, and they’ll get any email we send to that new address. That is, as far as Gmail addresses are concerned, all characters from a <code>+</code> symbol to just before the <code>@</code> symbol are ignored. For example, I tell people that my Gmail address is <em><a href="mailto:daniel.zingaro@gmail.com">daniel.zingaro@gmail.com</a></em>, but that’s only one way to write it. If you send email to <em><a href="mailto:daniel.zingaro+book@gmail.com">daniel.zingaro+book@gmail.com</a></em> or <em><a href="mailto:daniel.zingaro+hi.there@gmail.com">daniel.zingaro+hi.there@gmail.com</a></em>, I’ll get it. (Choose your favorite. Say hi!)</p>&#13;&#13;
<p class="indent">Dots before the <code>@</code> symbol are also ignored in Gmail addresses. For example, if you send email to <em><a href="mailto:danielzingaro@gmail.com">danielzingaro@gmail.com</a></em> (no dot at all), <em><a href="mailto:daniel..zingaro@gmail.com">daniel..zingaro@gmail.com</a></em> (two dots in a row), <em><a href="mailto:da.nielz.in.gar.o..@gmail.com">da.nielz.in.gar.o..@gmail.com</a></em> (chaotic dots), <em><a href="mailto:daniel.zin.garo+blah@gmail.com">daniel.zin.garo+blah@gmail.com</a></em>, and so on, I’ll get it.</p>&#13;&#13;
<p class="indent">Last thing: uppercase and lowercase differences throughout the address are ignored. I hope you’re not firing a flurry at me by this point, but I’d get anything you send to <em><a href="mailto:Daniel.Zingaro@gmail.com">Daniel.Zingaro@gmail.com</a></em>, <em><a href="mailto:DAnIELZIngARO+Flurry@gmAIL.COM">DAnIELZIngARO+Flurry@gmAIL.COM</a></em>, and so on.</p>&#13;&#13;
<p class="indent">In this problem, we’re provided with email addresses, and we’re asked to determine the number of them that are unique. The rules for email addresses in this problem are the same as those discussed for Gmail: characters from a <code>+</code> symbol to just before the <code>@</code> symbol are ignored, dots before the <code>@</code> symbol are ignored, and case throughout the entire address is ignored.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec2">Input</h4>&#13;&#13;
<p class="noindent">The input consists of 10 test cases. Each test case contains the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing integer <em>n</em>, the number of email addresses. <em>n</em> is between 1 and 100,000.</li>&#13;&#13;
<li class="noindent"><em>n</em> lines, each of which gives an email address. Each email address consists of at least one character before the <code>@</code> symbol, followed by the <code>@</code> symbol itself, followed by at least one character after the <code>@</code> symbol. Characters before the <code>@</code> symbol consist of letters, numbers, dots, and pluses. Characters after the <code>@</code> symbol consist of letters, numbers, and dots.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch08lev2sec3"><span epub:type="pagebreak" id="page_205"/>Output</h4>&#13;&#13;
<p class="noindent">For each test case, output the number of unique email addresses.</p>&#13;&#13;
<p class="indent">The time limit for solving the test cases is 30 seconds.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec2">Using a List</h3>&#13;&#13;
<p class="noindent">You’ve worked through seven chapters of this book. In each one, I posed a problem and then taught you new Python features so that you could solve that problem. You might therefore expect me to teach you some new Python before solving Email Addresses.</p>&#13;&#13;
<p class="indent">And you might object to that: don’t we already have what we need? After all, we can write a function to take an email address and return a clean version, with no <code>+</code> stuff, no dots before the <code>@</code> symbol, and all in lowercase. We can also maintain a list of clean email addresses. For each email address that we see, we can clean it up and check whether it’s in the list of clean email addresses. If it isn’t, then we can add it; if it is, then we do nothing (since it’s already being counted). Once we’ve gone through all of the email addresses, the length of the list will give us the number of unique email addresses.</p>&#13;&#13;
<p class="indent">Yes. We may already have what we need. Let’s try solving this thing.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec4">Cleaning an Email Address</h4>&#13;&#13;
<p class="noindent">Consider the email address <em><a href="mailto:DAnIELZIngARO+Flurry@gmAIL.COM">DAnIELZIngARO+Flurry@gmAIL.COM</a></em>. We’re going to clean this email address so that it becomes <em><a href="mailto:danielzingaro@gmail.com">danielzingaro@gmail.com</a></em>. No <span class="codeitalic">+Flurry</span>, no dots before the @ symbol, and all lowercase. We can think of the clean version as the true email address. Any other email address that represents the same true email address will also match <em><a href="mailto:danielzingaro@gmail.com">danielzingaro@gmail.com</a></em> once it’s been cleaned.</p>&#13;&#13;
<p class="indent">Cleaning an email address is a small, self-contained task, so let’s write a function for it. This <code>clean</code> function will take a string representing an email address, clean it up, and return the cleaned email address. We’ll carry out three cleaning steps: removing characters from a <code>+</code> symbol to just before the <code>@</code> symbol, removing dots before the <code>@</code> symbol, and converting to lowercase. The code for this function is in <a href="ch08.xhtml#ch08ex01">Listing 8-1</a>.</p>&#13;&#13;
<pre>def clean(address):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    address is a string email address.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return cleaned address.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    # Remove from '+' up to but not including '@'<br/>&#13;&#13;
 <span class="ent">❶</span> plus_index = address.find('+')<br/>&#13;&#13;
    if plus_index != -1:<br/>&#13;&#13;
     <span class="ent">❷</span> at_index = address.find('@')<br/>&#13;&#13;
        address = address[:plus_index] + address[at_index:]<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_206"/>    # Remove dots before @ symbol<br/>&#13;&#13;
    at_index = address.find('@')<br/>&#13;&#13;
    before_at = ''<br/>&#13;&#13;
    i = 0<br/>&#13;&#13;
    while i &lt; at_index:<br/>&#13;&#13;
     <span class="ent">❸</span> if address[i] != '.':<br/>&#13;&#13;
            before_at = before_at + address[i]<br/>&#13;&#13;
        i = i + 1<br/>&#13;&#13;
<br/>&#13;&#13;
 <span class="ent">❹</span> cleaned = before_at + address[at_index:]<br/>&#13;&#13;
<br/>&#13;&#13;
    # Convert to lowercase<br/>&#13;&#13;
 <span class="ent">❺</span> cleaned = cleaned.lower()<br/>&#13;&#13;
<br/>&#13;&#13;
    return cleaned</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex01"><em>Listing 8-1: Cleaning an email address</em></p>&#13;&#13;
<p class="indent">The first step is to remove characters from a <code>+</code> symbol to just before the <code>@</code> symbol. The string <code>find</code> method is useful here. It returns the index of the leftmost occurrence of its argument, or <code>-1</code> if the argument isn’t found:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'abc+def'.find('+')</span><br/>&#13;&#13;
3<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">'abcdef'.find('+')</span><br/>&#13;&#13;
-1</pre>&#13;&#13;
<p class="indent">I use <code>find</code> to determine the index of the leftmost <code>+</code> symbol <span class="ent">❶</span>. If there is no <code>+</code> symbol at all, then there’s nothing to do for this step. If there is one, however, then we find the index of the <code>@</code> symbol <span class="ent">❷</span> and remove characters from the <code>+</code> symbol up to but not including the <code>@</code> symbol.</p>&#13;&#13;
<p class="indent">The second step is to remove any dots before the <code>@</code> symbol. To do that, I use a new string, <code>before_at</code>, to accumulate the part of the address before the <code>@</code> symbol. Each character before the <code>@</code> symbol that is not a <code>.</code> is added to <code>before_at</code> <span class="ent">❸</span>.</p>&#13;&#13;
<p class="indent">The <code>before_at</code> string doesn’t include the <code>@</code> symbol or any characters following it. We don’t want to lose that part of the email address, so I use a new variable, <code>cleaned</code>, to refer to the whole email address <span class="ent">❹</span>.</p>&#13;&#13;
<p class="indent">The third step is to convert the entire email address to lowercase <span class="ent">❺</span>. After that, the email address is clean, so we can return it.</p>&#13;&#13;
<p class="indent">Let’s test this a little. Enter the code for our <code>clean</code> function into the Python shell. Here’s the function cleaning a few email addresses:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">clean('daniel.zingaro+book@gmail.com')</span><br/>&#13;&#13;
'danielzingaro@gmail.com'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">clean('da.nielz.in.gar.o..@gmail.com')</span><br/>&#13;&#13;
'danielzingaro@gmail.com'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">clean('DAnIELZIngARO+Flurry@gmAIL.COM')</span><br/>&#13;&#13;
<span epub:type="pagebreak" id="page_207"/>'danielzingaro@gmail.com'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">clean('a.b.c@d.e.f')</span><br/>&#13;&#13;
'abc@d.e.f'</pre>&#13;&#13;
<p class="indent">If the email address is already clean, <code>clean</code> returns it as is:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">clean('danielzingaro@gmail.com')</span><br/>&#13;&#13;
'danielzingaro@gmail.com'</pre>&#13;&#13;
<h4 class="h4" id="ch08lev2sec5">The Main Program</h4>&#13;&#13;
<p class="noindent">We can use our <code>clean</code> function to clean any email address. The strategy now is to maintain a list of clean email addresses. We will add a cleaned email address to this list only if it hasn’t been added already. In that way, we’ll avoid adding duplicates of the same clean email address.</p>&#13;&#13;
<p class="indent">The main part of our program is in <a href="ch08.xhtml#ch08ex02">Listing 8-2</a>. Be sure to enter our <code>clean</code> function (<a href="ch08.xhtml#ch08ex01">Listing 8-1</a>) before this code for a complete solution to the problem.</p>&#13;&#13;
<pre># Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
for dataset in range(10):<br/>&#13;&#13;
    n = int(input())<br/>&#13;&#13;
 <span class="ent">❶</span> addresses = []<br/>&#13;&#13;
    for i in range(n):<br/>&#13;&#13;
        address = input()<br/>&#13;&#13;
        address = clean(address)<br/>&#13;&#13;
     <span class="ent">❷</span> if not address in addresses:<br/>&#13;&#13;
            addresses.append(address)<br/>&#13;&#13;
<br/>&#13;&#13;
 <span class="ent">❸</span> print(len(addresses))</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex02"><em>Listing 8-2: Main program, using a list</em></p>&#13;&#13;
<p class="indent">We have 10 test cases to process, so we surround the rest of the program with a range <code>for</code> loop that loops 10 times.</p>&#13;&#13;
<p class="indent">For each test case, we read the number of email addresses and start with an empty list of clean email addresses <span class="ent">❶</span>.</p>&#13;&#13;
<p class="indent">We then use an inner range <code>for</code> loop to loop through each email address. We read each email address and clean it. Then, if we haven’t seen this clean email address before <span class="ent">❷</span>, we add it to our list of clean email addresses.</p>&#13;&#13;
<p class="indent">When the inner loop finishes, we’ll have built up a list of all clean email addresses. There are no duplicates in that list. The number of unique email addresses, then, is the length of this list, so that’s what we output <span class="ent">❸</span>.</p>&#13;&#13;
<p class="indent">Not bad, eh? Almost like we could have solved this problem after we learned functions in <a href="ch06.xhtml#ch06">Chapter 6</a>. Or, really, after we learned lists in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;&#13;
<p class="indent">Almost, but not quite. Because if you submit to the judge, you should notice that things don’t go according to plan.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>The first sign of trouble is that the judge takes a while to show us our results. For example, I just waited one minute here for my results to show up. Compare that to the other problems we solved earlier, where we received feedback very quickly.</p>&#13;&#13;
<p class="indent">The second sign of trouble is that when our results do show up, we’re not awarded full points for this problem! I’m being given 3.25 points out of 5. You may receive a little more or a little less, but you shouldn’t receive the full 5 points.</p>&#13;&#13;
<p class="indent">The reason we’re losing points is not because our program is wrong. Our program is fine. No matter the test case, it will output the correct number of unique email addresses.</p>&#13;&#13;
<p class="indent">So if our program is correct, what’s the problem?</p>&#13;&#13;
<p class="indent">The problem is that our program is too slow. The judge lets us know this by putting <code>TLE</code> at the start of each test case. TLE stands for time limit exceeded. For this problem, the judge has allocated 30 seconds to each batch of 10 test cases. If our program takes longer than 30 seconds, the judge terminates our program, and the remaining test cases in the batch are not allowed to run.</p>&#13;&#13;
<p class="indent">This may be the first time limit exceeded error you’ve received, though it’s possible you’ve seen them as you completed exercises from previous chapters.</p>&#13;&#13;
<p class="indent">The first thing to check when you receive this error is whether your program is getting stuck in an infinite loop. If it is, then it’ll never finish, no matter the time limit. The judge terminates the program when the allotted time expires.</p>&#13;&#13;
<p class="indent">If there’s no infinite loop, then the likely culprit is the <em>efficiency</em> of our program itself. When programmers talk about efficiency, they’re referring to how long it takes the program to run. A program that runs faster (takes less time) is more efficient than a program that runs slower (takes more time). To solve the test cases within the time limit, we’re going to make our program more efficient.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec3">Efficiency of Searching a List</h3>&#13;&#13;
<p class="noindent">Appending to a Python list is extremely fast. It doesn’t matter whether the list has only a few values or many thousands; appending takes the same small amount of time.</p>&#13;&#13;
<p class="indent">Using the <code>in</code> operator, however, is a different story. Our program uses the <code>in</code> operator to determine whether a clean email address is already in our list of clean email addresses. A test case might have as many as 100,000 email addresses. In the worst case, then, our program could use <code>in</code> 100,000 times. It turns out that <code>in</code> is very slow when used on a list with many values, and this ends up hurting our program’s efficiency. To determine whether a value is in the list, <code>in</code> searches the list from beginning to end, list value by list value. It does that until it finds the value it’s looking for, or it runs out of list values to check. The more values that <code>in</code> has to look through, the slower it is.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_209"/>Let’s get a feel for the way that <code>in</code> slows down as the length of a list increases. We’ll use a function that takes a list and a value and uses <code>in</code> to search the list for the value. It searches for the value 50,000 times; if we searched only once, it would be too fast for us to be able to see what’s going on.</p>&#13;&#13;
<p class="indent">The function is in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a>. Enter its code into the Python shell.</p>&#13;&#13;
<pre>def search(collection, value):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    search many times for value in collection.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    for i in range(50000):<br/>&#13;&#13;
        found = value in collection</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex03"><em>Listing 8-3: Searching a collection many times</em></p>&#13;&#13;
<p class="indent">Let’s create a list of the integers from 1 to 5,000 and search for <code>5000</code>. By searching for the rightmost value in the list, we make <code>in</code> take as much time as possible on that list. Don’t worry that we’re exploring this using a list of integers rather than a list of email addresses. The efficiency will be similar, and numbers are so much easier to generate than email addresses!</p>&#13;&#13;
<p class="indent">Here goes:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">search(list(range(1, 5001)), 5000)</span></pre>&#13;&#13;
<p class="indent">On my laptop, this takes about three seconds to run. We don’t need precise timing here; we’re just looking for a general picture of what happens as we increase the length of the list.</p>&#13;&#13;
<p class="indent">Now let’s create a list of the integers from 1 to 10,000 and search for <code>10000</code>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">search(list(range(1, 10001)), 10000)</span></pre>&#13;&#13;
<p class="indent">On my laptop, that takes about six seconds. As a summary so far, for a list of length <code>5000</code>, it takes three seconds; double the list length to <code>10000</code>, and the time doubles, too, to six seconds.</p>&#13;&#13;
<p class="indent">A list of length <code>20000</code>? Give it a try:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">search(list(range(1, 20001)), 20000)</span></pre>&#13;&#13;
<p class="indent">This takes about 12 seconds on my laptop.</p>&#13;&#13;
<p class="indent">The time has doubled again. Try it on a list of length <code>50000</code>. You’ll be waiting a while. I just ran this on my laptop:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">search(list(range(1, 50001)), 50000)</span></pre>&#13;&#13;
<p class="noindent">It took just over 30 seconds. Remember that our <code>search</code> function is searching the list 50,000 times. So, it’s taking 30 seconds to search a list of length <code>50000</code> a total of 50,000 times.</p>&#13;&#13;
<p class="indent">We could have a test case that requires this much searching. For example, suppose we add 100,000 unique email addresses to our list, one at a <span epub:type="pagebreak" id="page_210"/>time. Halfway through, we’ll have a list of 50,000 values; from then on, the remaining 50,000 uses of <code>in</code> will be on a list of at least 50,000 values.</p>&#13;&#13;
<p class="indent">And that’s only for one of the 10 test cases! We need to get through all 10 test cases within a total of 30 seconds. If one test case can take about 30 seconds on its own, we have no chance.</p>&#13;&#13;
<p class="indent">Searching a list is just too slow. The Python list is the wrong type to use. We need a type better suited to the job. We need a Python set. You’re not going to believe how fast it is to search a set.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec4">Sets</h3>&#13;&#13;
<p class="noindent">A <em>set</em> is a Python type that stores a collection of values, where repeated values are not allowed. We use opening and closing curly brackets to delimit the set.</p>&#13;&#13;
<p class="indent">Unlike a list, a set might not maintain the values in the order you specify. Here’s a set of integers:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{13, 15, 30, 45, 61}</span><br/>&#13;&#13;
{45, 13, 15, 61, 30}</pre>&#13;&#13;
<p class="indent">Notice that Python jumbled the order of the values. You may see the values in a different order on your computer. The important point is that you cannot rely on any particular order of the values. If order matters to you, a set is not the type to use.</p>&#13;&#13;
<p class="indent">If we try to include multiple occurrences of a value, only one occurrence is retained:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{1, 1, 3, 2, 3, 1, 3, 3, 3}</span><br/>&#13;&#13;
{1, 2, 3}</pre>&#13;&#13;
<p class="indent">Sets are equal if they contain exactly the same values, even if we write them in different orders:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{1, 2, 3} == {1, 2, 3}</span><br/>&#13;&#13;
True<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{1, 1, 3, 2, 3, 1, 3, 3, 3} == {1, 2, 3}</span><br/>&#13;&#13;
True<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{1, 2} == {1, 2, 3}</span><br/>&#13;&#13;
False</pre>&#13;&#13;
<p class="indent">We can create a set of strings, like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{'abc@d.e.f', 'danielzingaro@gmail.com'}</span><br/>&#13;&#13;
{'abc@d.e.f', 'danielzingaro@gmail.com'}</pre>&#13;&#13;
<p class="indent">We cannot create a set of lists:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{[1, 2], [3, 4]}</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_211"/>TypeError: unhashable type: 'list'</pre>&#13;&#13;
<p class="indent">Values in a set must be immutable, which explains why we can’t put lists inside a set. The restriction has to do with how Python searches a set for a value. When Python adds a value to a set, it uses the value itself to determine where exactly it gets stored. Later, Python can find this value by looking in the place where it should be located. If a value in the set could change, then Python might look in the wrong place, failing to find the value.</p>&#13;&#13;
<p class="indent">While we can’t create a set of lists, there’s no problem with a list of sets:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">lst = [{1, 2, 3}, {4, 5, 6}]</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">lst</span><br/>&#13;&#13;
[{1, 2, 3}, {4, 5, 6}]<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">len(lst)</span><br/>&#13;&#13;
2<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">lst[0]</span><br/>&#13;&#13;
{1, 2, 3}</pre>&#13;&#13;
<p class="indent">You can use the <code>len</code> function to determine the number of values in a set:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">len({2, 4, 6, 8})</span><br/>&#13;&#13;
4</pre>&#13;&#13;
<p class="indent">You can also loop over the values in a set:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for value in {2, 4, 6, 8}:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('I found', value)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
I found 8<br/>&#13;&#13;
I found 2<br/>&#13;&#13;
I found 4<br/>&#13;&#13;
I found 6</pre>&#13;&#13;
<p class="indent">You can’t index or slice a set, though. Values in a set don’t have indices.</p>&#13;&#13;
<p class="indent">To create an empty set, you might expect to use an empty pair of curly brackets, <code>{}</code>. In an inconsistency of Python syntax, that doesn’t work:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">type({2, 4, 6, 8})</span><br/>&#13;&#13;
&lt;class 'set'&gt;<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{}</span><br/>&#13;&#13;
{}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">type({})</span><br/>&#13;&#13;
&lt;class 'dict'&gt;</pre>&#13;&#13;
<p class="indent">Using <code>{}</code> gives us the wrong type: a <code>dict</code> (dictionary) instead of a <code>set</code>. We’ll talk about dictionaries later in this chapter.</p>&#13;&#13;
<p class="indent">To make an empty set, we use <code>set()</code>, like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">set()</span><br/>&#13;&#13;
set()<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_212"/>&gt;&gt;&gt; <span class="codestrong1">type(set())</span><br/>&#13;&#13;
&lt;class 'set'&gt;</pre>&#13;&#13;
<h3 class="h3" id="ch08lev1sec5">Set Methods</h3>&#13;&#13;
<p class="noindent">Sets are mutable, so we can add and remove values. We can perform these tasks by using methods.</p>&#13;&#13;
<p class="indent">You can get a list of set methods by using <code>dir(set())</code>. And you can get help on a specific set method by using <code>help</code>, similar to how we use <code>help</code> to learn about string or list methods. For example, to learn about the <code>add</code> method, type <code>help(set().add)</code>.</p>&#13;&#13;
<p class="indent">The <code>add</code> method is what we use to add a value to a set. It’s the analog of <code>append</code> on lists:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s = set()</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
set()<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.add(2)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{2}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.add(4)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{2, 4}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.add(6)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{2, 4, 6}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.add(8)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{8, 2, 4, 6}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.add(8)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{8, 2, 4, 6}</pre>&#13;&#13;
<p class="indent">To remove a value, we use the <code>remove</code> method:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s.remove(4)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{8, 2, 6}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.remove(8)</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s</span><br/>&#13;&#13;
{2, 6}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s = {2, 6}</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">s.remove(8)</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
KeyError: 8</pre>&#13;&#13;
<span epub:type="pagebreak" id="page_213"/>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Use <code>help</code> to learn about the set <code>update</code> and <code>intersection</code> methods.</p>&#13;&#13;
<p class="sidebarp">What is output by the call of <code>print</code> in the following code?</p>&#13;&#13;
<pre>s1 = {1, 3, 5, 7, 9}<br/>&#13;&#13;
s2 = {1, 2, 4, 6, 8, 10}<br/>&#13;&#13;
s3 = {1, 4, 9, 16, 25}<br/>&#13;&#13;
s1.update(s2)<br/>&#13;&#13;
s1.intersection(s3)<br/>&#13;&#13;
print(s1)</pre>&#13;&#13;
<p class="alphat">A. <code>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</code></p>&#13;&#13;
<p class="alpha">B. <code>{1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</code></p>&#13;&#13;
<p class="alpha">C. <code>{1, 4, 9}</code></p>&#13;&#13;
<p class="alpha">D. <code>{1, 4, 9, 16, 25}</code></p>&#13;&#13;
<p class="alpha">E. <code>{1}</code></p>&#13;&#13;
<p class="sb-noindent1">Answer: A. The <code>update</code> method adds whatever is in set <code>s2</code> but is missing from set <code>s1</code> to set <code>s1</code>. After the call of <code>update</code>, <code>s1</code> is the set <code>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</code>.</p>&#13;&#13;
<p class="sidebarp">Now for the call of <code>intersection</code>. The intersection of two sets is the set consisting of the values that are in both sets. Here, the intersection of <code>s1</code> and <code>s3</code> is <code>{1, 4, 9}</code>. However, the <code>intersection</code> method <em>does not</em> modify a set; rather, it produces a new set! For that reason, it has no effect on <code>s1</code>.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch08lev1sec6">Efficiency of Searching a Set</h3>&#13;&#13;
<p class="noindent">Back to solving Email Addresses.</p>&#13;&#13;
<p class="indent">Do we care about the order of our cleaned email addresses? No! All we care about is whether an email address is already in there or not.</p>&#13;&#13;
<p class="indent">Do we need to allow duplicates in our cleaned email addresses? No again! In fact, we want to explicitly avoid storing duplicate email addresses.</p>&#13;&#13;
<p class="indent">Order doesn’t matter, and duplicates are not allowed. These are the two ingredients that suggest that a set may be the right type to use.</p>&#13;&#13;
<p class="indent">We were foiled in our attempt to use a list because searching a list is too slow. A set is going to be an improvement for us because we can search a set faster than we can search a list.</p>&#13;&#13;
<p class="indent">We’ve already used the <code>search</code> function in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> to search a list. But that function doesn’t do anything that specifically requires a list! It uses the <code>in</code> operator, and <code>in</code> works on both lists and sets. So we can use that function, unchanged, to search a set, too.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_214"/>Enter the <code>search</code> function from <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> into the Python shell. Follow along on your computer to get a sense of the difference between searching a long list and a big set:</p>&#13;&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">search(list(range(1, 50001)), 50000)</span><br/>&#13;&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">search(set(range(1, 50001)), 50000)</span></pre>&#13;&#13;
<p class="noindent">At <span class="ent">❶</span>, I’ve used <code>set</code> to produce a set, not a list, of the integers from the range.</p>&#13;&#13;
<p class="indent">On my laptop, searching the list takes about 30 seconds. Searching the set, by comparison, is bullet fast, almost instantaneous.</p>&#13;&#13;
<p class="indent">Sets are unstoppable. Don’t try this on a list, but here we go, searching for something in a set of 500,000 values:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">search(set(range(1, 500001)), 500000)</span></pre>&#13;&#13;
<p class="indent">Boom! Piece of cake.</p>&#13;&#13;
<p class="indent">Python manages a list in such a way as to allow us to use any index at any time. Python has no flexibility to mess around with the order of values: the first value has to be at index 0, the second at index 1, and so on. But for a set, Python can store it in whatever way it wants, because it makes no promises of keeping things in order for us. And it’s that increased latitude that allows Python to optimize searches in a set for speed.</p>&#13;&#13;
<p class="indent">For similar reasons, there are other operations that are extremely slow on large lists but extremely fast on large sets. For example, removing a value from a list is very slow, because Python must decrease the index of each value that’s to the right of that value. By contrast, removing a value from a set is very fast: there are no indices to update!</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec7">Solving the Problem</h3>&#13;&#13;
<p class="noindent">We already have a function to clean an email address (<a href="ch08.xhtml#ch08ex01">Listing 8-1</a>), and we’ll use it in our set-based solution. As for the main program, <a href="ch08.xhtml#ch08ex02">Listing 8-2</a> gets us most of the way there. We just need to use a set instead of a list.</p>&#13;&#13;
<p class="indent">The new main program is in <a href="ch08.xhtml#ch08ex04">Listing 8-4</a>. Include <a href="ch08.xhtml#ch08ex01">Listing 8-1</a> before this code for a complete solution to the problem.</p>&#13;&#13;
<pre># Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
for dataset in range(10):<br/>&#13;&#13;
    n = int(input())<br/>&#13;&#13;
 <span class="ent">❶</span> addresses = set()<br/>&#13;&#13;
    for i in range(n):<br/>&#13;&#13;
        address = input()<br/>&#13;&#13;
        address = clean(address)<br/>&#13;&#13;
     <span class="ent">❷</span> addresses.add(address)<br/>&#13;&#13;
<br/>&#13;&#13;
    print(len(addresses))</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex04"><em>Listing 8-4: Main program, using a set</em></p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>Notice that we’re now using a set <span class="ent">❶</span> of email addresses rather than a list. After cleaning each email address, we add it to the set using the set <code>add</code> method <span class="ent">❷</span>.</p>&#13;&#13;
<p class="indent">In <a href="ch08.xhtml#ch08ex02">Listing 8-2</a>, we used the <code>in</code> operator to check whether an email address is already in the list so that we didn’t add duplicates. There’s no corresponding <code>in</code> check in our set-based solution. Where did it go? It seems that we’re adding each email address to the set without even making sure that it’s not already there.</p>&#13;&#13;
<p class="indent">We can get away without the <code>in</code> check when using a set because a set never contains duplicates. The <code>add</code> method handles the <code>in</code> check for us, ensuring that a duplicate doesn’t get added. You can think of <code>add</code> carrying out its own <code>in</code> check. There’s no timing concern there, because searching a set is so fast.</p>&#13;&#13;
<p class="indent">If you submit this solution to the judge, you should pass all of the test cases well within the time limit.</p>&#13;&#13;
<p class="indent">As you’ve seen here, choosing the appropriate Python type can mean the difference between an unsatisfactory solution and a satisfactory one. Before you start writing code, ask yourself which operations you’ll be frequently performing and which Python type is ideally suited to those operations.</p>&#13;&#13;
<p class="indent">Before continuing, you might like to try solving exercises 1 and 2 from “Chapter Exercises” on <a href="ch08.xhtml#ch08lev1sec19">page 236</a>.</p>&#13;&#13;
<h3 class="h3a" id="ch08lev1sec8"><span class="h3aa">Problem #19: Common Words</span></h3>&#13;&#13;
<p class="noindent">In this problem, we’ll need to associate words with their number of occurrences. This is beyond what we can do with sets, so we won’t use sets here. Instead, we’ll learn about and use Python dictionaries.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <code>cco99p2</code>.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec6">The Challenge</h4>&#13;&#13;
<p class="noindent">We are given <em>m</em> words. The words are not necessarily distinct; for example, the word <code>brook</code> could appear multiple times. We are also given an integer <em>k</em>.</p>&#13;&#13;
<p class="indent">Our task is to find the <em>k</em>th most common words. A word <em>w</em> is a <em>k</em>th most common word if exactly <em>k</em> – 1 distinct words occur more often than does <em>w</em>. Depending on the dataset, the <em>k</em>th most common words could be no words, one word, or more than one word.</p>&#13;&#13;
<p class="indent">Let’s make sure we’re clear on this definition of the <em>k</em>th most common words. If <em>k</em> = 1, then we’re being asked for the words for which exactly 0 words occur more often; that is, we’re being asked for the words that occur most often. If <em>k</em> = 2, then we’re being asked for the words for which exactly 1 word occurs more often. If <em>k</em> = 3, then we’re being asked for the words for which exactly two distinct words occur more often, and so on.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec7"><span epub:type="pagebreak" id="page_216"/>Input</h4>&#13;&#13;
<p class="noindent">The input contains a line giving the number of test cases, followed by the lines of the test cases themselves. Each test case contains the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing the integers <em>m</em> (the number of words in the test case) and <em>k</em> separated by a space. <em>m</em> is between 0 and 1,000; <em>k</em> is at least 1.</li>&#13;&#13;
<li class="noindent"><em>m</em> lines, each of which gives a word. Each word consists of at most 20 characters, and all characters are lowercase.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch08lev2sec8">Output</h4>&#13;&#13;
<p class="noindent">For each test case, output the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing the following:&#13;&#13;
<pre><span class="codeitalic1">p</span> most common word(s):</pre>&#13;&#13;
<p class="noindent">where <span class="codeitalic">p</span> is <code>1st</code> if <em>k</em> is 1, <code>2nd</code> if <em>k</em> is 2, <code>3rd</code> if <em>k</em> is 3, <code>4th</code> if <em>k</em> is 4, and so on.</p></li>&#13;&#13;
<li class="noindent">One line for each of the <em>k</em>th most common words. If there are no such words, there are no lines of output here.</li>&#13;&#13;
<li class="noindent">A blank line.</li>&#13;&#13;
</ul>&#13;&#13;
<p class="indent">The time limit for solving the test cases is one second.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec9">Exploring a Test Case</h3>&#13;&#13;
<p class="noindent">Let’s start by exploring a test case. It’ll boost our understanding of the problem and motivate the use of a new Python type.</p>&#13;&#13;
<p class="indent">Suppose that we’re interested in the most common words of all. This means that <em>k</em> is 1. Here’s the test case:</p>&#13;&#13;
<pre>1<br/>&#13;&#13;
14 1<br/>&#13;&#13;
storm<br/>&#13;&#13;
cut<br/>&#13;&#13;
magma<br/>&#13;&#13;
cut<br/>&#13;&#13;
brook<br/>&#13;&#13;
gully<br/>&#13;&#13;
gully<br/>&#13;&#13;
storm<br/>&#13;&#13;
cliff<br/>&#13;&#13;
cut<br/>&#13;&#13;
blast<br/>&#13;&#13;
brook<br/>&#13;&#13;
cut<br/>&#13;&#13;
gully</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>The word that shows up most often is <code>cut</code>. There are four occurrences of <code>cut</code>, and no other word has that many occurrences. The correct output is therefore:</p>&#13;&#13;
<pre>   1st most common word(s):<br/>&#13;&#13;
   cut<br/>&#13;&#13;
<span class="ent">❶</span></pre>&#13;&#13;
<p class="indent">Notice the required blank line at the end <span class="ent">❶</span>.</p>&#13;&#13;
<p class="indent">Now, what do we do if <em>k</em> were 2? We could answer this by scanning through the words again and counting occurrences, but there’s a different way to organize the words that would make our task considerably easier. Rather than a list of words, let’s look at each word associated with its number of occurrences. See <a href="ch08.xhtml#ch08tab01">Table 8-1</a>.</p>&#13;&#13;
<p class="tabcap" id="ch08tab01"><strong>Table 8-1:</strong> Words and Number of Occurrences</p>&#13;&#13;
<table class="bordertb1">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Word</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Number of occurrences</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">cut</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr class="bg-g">&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">gully</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">storm</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr class="bg-g">&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">brook</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">magma</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr class="bg-g">&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">cliff</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab"><span class="codeitalic">blast</span></p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">I’ve sorted the words based on their number of occurrences. Looking at the top row, we can reaffirm that <code>cut</code> is the word to output for <em>k</em> = 1. Looking at the second row, we see that <code>gully</code> is the word to output for <em>k</em> = 2. The word <code>gully</code> is the only word that has exactly one word with more occurrences.</p>&#13;&#13;
<p class="indent">Now for <em>k</em> = 3. This time, there are <em>two</em> words to output, <code>storm</code> and <code>brook</code>, because they both have the same number of occurrences. Each of these words has exactly two words with more occurrences. This shows that we sometimes need to output more than one word.</p>&#13;&#13;
<p class="indent">It’s also possible that we need to output zero words! For example, consider <em>k</em> = 4. There are <em>no</em> words that have exactly three words with more occurrences. Looking down the table, you might wonder why we don’t output <code>magma</code> for <em>k</em> = 4. We don’t output <code>magma</code>, because <code>magma</code> has exactly four words (not exactly three words) with more occurrences.</p>&#13;&#13;
<p class="indent">When <em>k</em> = 5, we have three words to output: <code>magma</code>, <code>cliff</code>, and <code>blast</code>. Before continuing, verify for yourself that there are no words to output for any other value of <em>k</em>—no words for <em>k</em> = 6, <em>k</em> = 7, <em>k</em> = 8, <em>k</em> = 9, <em>k</em> = 100, and so on.</p>&#13;&#13;
<p class="indent"><a href="ch08.xhtml#ch08tab01">Table 8-1</a> simplifies the problem quite a bit for us. We’re now going to learn how to organize information like this in Python.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec10"><span epub:type="pagebreak" id="page_218"/>Dictionaries</h3>&#13;&#13;
<p class="noindent">A <em>dictionary</em> is a Python type that stores a mapping from one group of elements, called <em>keys</em>, to another group of elements, called <em>values</em>.</p>&#13;&#13;
<p class="indent">We use opening and closing curly brackets to delimit the dictionary. Those are the same symbols that we use for a set, but Python can tell the difference between a set and a dictionary because of what we put inside the curly brackets. For a set, we list values; for a dictionary, we list <code>key:value</code> pairs.</p>&#13;&#13;
<p class="indent">Here’s a dictionary mapping some strings to numbers:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{'cut':4, 'gully':3}</span><br/>&#13;&#13;
{'cut': 4, 'gully': 3}</pre>&#13;&#13;
<p class="indent">In this dictionary, the keys are <code>'cut'</code> and <code>'gully'</code>, and the values are <code>4</code> and <code>3</code>. The key <code>'cut'</code> is mapped to the value <code>4</code>, and the key <code>'gully'</code> is mapped to the value <code>3</code>.</p>&#13;&#13;
<p class="indent">Based on our encounters with sets, you might wonder whether dictionaries maintain the pairs in the order we enter them. For example, you might wonder whether this could happen:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{'cut':4, 'gully':3}</span><br/>&#13;&#13;
{'gully': 3, 'cut': 4}</pre>&#13;&#13;
<p class="indent">As of Python 3.7, the answer is no: dictionaries retain the order in which you added pairs. In earlier versions of Python, dictionaries did not maintain this order, so you could add pairs in one order but get them back in another. It’s still a good idea to write code that doesn’t rely on the Python 3.7 behavior, though, because older versions of Python are likely to be in use for the foreseeable future.</p>&#13;&#13;
<p class="indent">Dictionaries are equal if they contain the same <code>key:value</code> pairs, even if we write them in different orders:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{'cut':4, 'gully':3} == {'cut':4, 'gully':3}</span><br/>&#13;&#13;
True<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{'cut':4, 'gully':3} == {'gully': 3, 'cut': 4}</span><br/>&#13;&#13;
True<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{'cut':4, 'gully':3} == {'gully': 3, 'cut': 10}</span><br/>&#13;&#13;
False<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{'cut':4, 'gully':3} == {'cut': 4}</span><br/>&#13;&#13;
False</pre>&#13;&#13;
<p class="indent">Dictionary keys must be unique. If you try to include the same key multiple times, only one pair involving that key is retained:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{'storm': 1, 'storm': 2}</span><br/>&#13;&#13;
{'storm': 2}</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_219"/>Repeated values, by contrast, are fine:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{'storm': 2, 'brook': 2}</span><br/>&#13;&#13;
{'storm': 2, 'brook': 2}</pre>&#13;&#13;
<p class="indent">Keys are required to be immutable values, such as numbers and strings. Values can be immutable or mutable. This means that we can’t use a list as a key, but we can use a list as a value:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{['storm', 'brook']: 2}</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
TypeError: unhashable type: 'list'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">{2: ['storm', 'brook']}</span><br/>&#13;&#13;
{2: ['storm', 'brook']}</pre>&#13;&#13;
<p class="indent">The <code>len</code> function gives us the number of <code>key:value</code> pairs in a dictionary:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">len({'cut':4, 'gully':3})</span><br/>&#13;&#13;
2<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">len({2: ['storm', 'brook']})</span><br/>&#13;&#13;
1</pre>&#13;&#13;
<p class="indent">To create an empty dictionary, we use <code>{}</code>. That’s why we’re stuck with that second-rate <code>set()</code> syntax to create a set—dictionaries got the nice syntax:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">{}</span><br/>&#13;&#13;
{}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">type({})</span><br/>&#13;&#13;
&lt;class 'dict'&gt;</pre>&#13;&#13;
<p class="indent">The type is called <code>dict</code>, not <code>dictionary</code>.</p>&#13;&#13;
<p class="indent">You’ll see “dictionary” and “dict” used interchangeably in Python resources and code, but I’ll stick with “dictionary” in this book.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Which of the following is best suited for a dictionary rather than a list or set?</p>&#13;&#13;
<p class="alphat">A. The order in which people finish a race</p>&#13;&#13;
<p class="alpha">B. The ingredients necessary for a recipe</p>&#13;&#13;
<p class="alpha">C. The names of countries and their capital cities</p>&#13;&#13;
<p class="alpha">D. 50 random integers</p>&#13;&#13;
<p class="sb-noindent1"><span epub:type="pagebreak" id="page_220"/>Answer: C. This is the only option that includes a mapping between keys and values. Here, the keys could be the countries, and the values could be their capital cities.</p>&#13;&#13;
</div>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the type of the values (ignoring the keys) in the following dictionary?</p>&#13;&#13;
<pre>{'MLB': {'Bluejays': [1992, 1993],<br/>&#13;&#13;
         'Orioles': [1966, 1970, 1983]},<br/>&#13;&#13;
 'NFL': {'Patriots': ['too many']}}</pre>&#13;&#13;
<p class="alphat">A. Integer</p>&#13;&#13;
<p class="alpha">B. String</p>&#13;&#13;
<p class="alpha">C. List</p>&#13;&#13;
<p class="alpha">D. Dictionary</p>&#13;&#13;
<p class="alpha">E. More than one of the above</p>&#13;&#13;
<p class="sb-noindent1">Answer: D. The value for each key in the dictionary is itself a dictionary. For example, the key <code>'MLB'</code> is mapped to a dictionary; that dictionary has two <code>key:value</code> pairs of its own.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch08lev1sec11">Indexing Dictionaries</h3>&#13;&#13;
<p class="noindent">We can use square brackets to look up the value that a key maps to. It’s similar to how we index a list, but with the keys serving as the valid “indices”:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = {'cut':4, 'gully':3}</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'cut': 4, 'gully': 3}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['cut']</span><br/>&#13;&#13;
4<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['gully']</span><br/>&#13;&#13;
3</pre>&#13;&#13;
<p class="indent">It’s an error to use a key that doesn’t exist:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d['storm']</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
KeyError: 'storm'</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_221"/>We can protect against that error by first using <code>in</code> to check whether a key is in the dictionary. When used on a dictionary, the <code>in</code> operator checks only the keys, not the values. Here’s how we can check that a key exists before trying to find its value:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">if 'cut' in d:</span><br/>&#13;&#13;
...     <span class="codestrong1">print(d['cut'])</span><br/>&#13;&#13;
...<br/>&#13;&#13;
4<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">if 'storm' in d:</span><br/>&#13;&#13;
...     <span class="codestrong1">print(d['storm'])</span><br/>&#13;&#13;
...</pre>&#13;&#13;
<p class="indent">Indexing and using <code>in</code> on a dictionary are extremely fast operations. They don’t require searching any kind of list, no matter how many keys are in the dictionary.</p>&#13;&#13;
<p class="indent">It’s sometimes more convenient to use the <code>get</code> method rather than indexing to look up the value for a key. The <code>get</code> method never produces an error, even if the key doesn’t exist:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">print(d.get('cut'))</span><br/>&#13;&#13;
4<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">print(d.get('storm'))</span><br/>&#13;&#13;
None</pre>&#13;&#13;
<p class="indent">If the key exists, <code>get</code> returns its value. Otherwise, it returns <code>None</code> to signify that the key does not exist.</p>&#13;&#13;
<p class="indent">In addition to looking up the value for a key, we can use square brackets to add keys to a dictionary or change the value that a key maps to. Here’s some code that shows how to do each of these, starting with an empty dictionary:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = {}</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['gully'] = 1</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'gully': 1}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['cut'] = 1</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'gully': 1, 'cut': 1}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['cut'] = 4</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'gully': 1, 'cut': 4}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['gully'] = d['gully'] + 1</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'gully': 2, 'cut': 4}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d['gully'] = d['gully'] + 1</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'gully': 3, 'cut': 4}</pre>&#13;&#13;
<span epub:type="pagebreak" id="page_222"/>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Use <code>help({}.get)</code> to learn more about the dictionary <code>get</code> method.</p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<pre>d = {3: 4}<br/>&#13;&#13;
d[5] = d.get(4, 8)<br/>&#13;&#13;
d[4] = d.get(3, 9)<br/>&#13;&#13;
print(d)</pre>&#13;&#13;
<p class="alphat">A. <code>{3: 4, 5: 8, 4: 9}</code></p>&#13;&#13;
<p class="alpha">B. <code>{3: 4, 5: 8, 4: 4}</code></p>&#13;&#13;
<p class="alpha">C. <code>{3: 4, 5: 4, 4: 3}</code></p>&#13;&#13;
<p class="alpha">D. Error caused by <code>get</code></p>&#13;&#13;
<p class="sb-noindent1">Answer: B. The first call of <code>get</code> returns <code>8</code>, because key <code>4</code> does not exist in the dictionary. That line therefore adds key <code>5</code> with value <code>8</code>.</p>&#13;&#13;
<p class="sidebarp">The second call of <code>get</code> returns <code>4</code>: key <code>3</code> is in the dictionary already, so the second parameter, <code>9</code>, is ignored. That line therefore adds key <code>4</code> with value <code>4</code>.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch08lev1sec12">Looping Through Dictionaries</h3>&#13;&#13;
<p class="noindent">If we use a <code>for</code> loop on a dictionary, we get the dictionary’s keys:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = {'cut': 4, 'gully': 3, 'storm': 2, 'brook': 2}</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for word in d:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('a key is', word)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
a key is cut<br/>&#13;&#13;
a key is gully<br/>&#13;&#13;
a key is storm<br/>&#13;&#13;
a key is brook</pre>&#13;&#13;
<p class="indent">We might also want to access the value associated with each key, and we can do that by using each key as an index in the dictionary. Here’s a loop that accesses both the key and its value:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for word in d:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('key', word, 'has value', d[word])</span><br/>&#13;&#13;
...<br/>&#13;&#13;
key cut has value 4<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_223"/>key gully has value 3<br/>&#13;&#13;
key storm has value 2<br/>&#13;&#13;
key brook has value 2</pre>&#13;&#13;
<p class="indent">Dictionaries have methods that let us access the keys, values, or both.</p>&#13;&#13;
<p class="indent">The <code>keys</code> method gives us the keys, and the <code>values</code> method gives us the values:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d.keys()</span><br/>&#13;&#13;
dict_keys(['cut', 'gully', 'storm', 'brook'])<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d.values()</span><br/>&#13;&#13;
dict_values([4, 3, 2, 2])</pre>&#13;&#13;
<p class="indent">These aren’t lists, but we can pass them to <code>list</code> to convert them:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">keys = list(d.keys())</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">keys</span><br/>&#13;&#13;
['cut', 'gully', 'storm', 'brook']<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">values = list(d.values())</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">values</span><br/>&#13;&#13;
[4, 3, 2, 2]</pre>&#13;&#13;
<p class="indent">With the keys available as a list, we can sort the keys and then loop through them in sorted order:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">keys.sort()</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">keys</span><br/>&#13;&#13;
['brook', 'cut', 'gully', 'storm']<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for word in keys:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('key', word, 'has value', d[word])</span><br/>&#13;&#13;
...<br/>&#13;&#13;
key brook has value 2<br/>&#13;&#13;
key cut has value 4<br/>&#13;&#13;
key gully has value 3<br/>&#13;&#13;
key storm has value 2</pre>&#13;&#13;
<p class="indent">We can also loop through the values:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in d.values():</span><br/>&#13;&#13;
...     <span class="codestrong1">print('number', num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
number 4<br/>&#13;&#13;
number 3<br/>&#13;&#13;
number 2<br/>&#13;&#13;
number 2</pre>&#13;&#13;
<p class="indent">Looping through keys is often preferred over looping through values. It’s easy to go from a key to its value. As we’ll see in the next subsection, though, it’s not as easy to go from a value back to its key.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/>One final method that’s relevant here is <code>items</code>. It gives us access to both the keys and values:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">pairs = list(d.items())</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">pairs</span><br/>&#13;&#13;
[('cut', 4), ('gully', 3), ('storm', 2), ('brook', 2)]</pre>&#13;&#13;
<p class="indent">This gives us another way to loop through the <code>key:value</code> pairs of a dictionary:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for pair in pairs:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('key', pair[0], 'has value', pair[1])</span><br/>&#13;&#13;
...<br/>&#13;&#13;
key cut has value 4<br/>&#13;&#13;
key gully has value 3<br/>&#13;&#13;
key storm has value 2<br/>&#13;&#13;
key brook has value 2</pre>&#13;&#13;
<p class="indent">Look carefully at the <code>pairs</code> value:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">pairs</span><br/>&#13;&#13;
[('cut', 4), ('gully', 3), ('storm', 2), ('brook', 2)]</pre>&#13;&#13;
<p class="indent">There’s something fishy here: there are parentheses around each inner value, not square brackets. It turns out that this is <em>not</em> a list of lists, but a list of <em>tuples</em>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">type(pairs[0])</span><br/>&#13;&#13;
&lt;class 'tuple'&gt;</pre>&#13;&#13;
<p class="indent">Tuples are similar to lists in that they store a sequence of values. The most important difference between tuples and lists is that tuples are immutable. You can loop over them, index them, and slice them, but you can’t modify them. If you try to modify a tuple, you get an error:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">pairs[0][0] = 'river'</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
TypeError: 'tuple' object does not support item assignment</pre>&#13;&#13;
<p class="indent">You can create your own tuples using parentheses. For a tuple with a single value, we need a trailing comma. For a tuple with multiple values, we don’t:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">(4,)</span><br/>&#13;&#13;
(4,)<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">(4, 5)</span><br/>&#13;&#13;
(4, 5)<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">(4, 5, 6)</span><br/>&#13;&#13;
(4, 5, 6)</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>Tuples have methods—but only a few, because methods that would change a tuple are not allowed. I encourage you to learn more about tuples if you’re interested, but we won’t use tuples any further in this book.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec13">Inverting a Dictionary</h3>&#13;&#13;
<p class="noindent">We’re close to being able to solve Common Words using dictionaries. Here’s the plan. We maintain a dictionary that maps from words to their number of occurrences. Whenever we process a word, we check whether that word is already in the dictionary. If it isn’t, then we add it with a value of 1. If it is, then we increase its value by 1.</p>&#13;&#13;
<p class="indent">Here’s an example of adding two words, one that we have seen before and one that we haven’t:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = {'storm': 1, 'cut': 1, 'magma': 1}</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word = 'cut'  # 'cut' is already in the dictionary</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">if not word in d:</span><br/>&#13;&#13;
...     <span class="codestrong1">d[word] = 1</span><br/>&#13;&#13;
... <span class="codestrong1">else:</span><br/>&#13;&#13;
...     <span class="codestrong1">d[word] = d[word] + 1</span><br/>&#13;&#13;
...<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'storm': 1, 'cut': 2, 'magma': 1}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word = 'brook'  # 'brook' is not in the dictionary</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">if not word in d:</span><br/>&#13;&#13;
...     <span class="codestrong1">d[word] = 1</span><br/>&#13;&#13;
... <span class="codestrong1">else:</span><br/>&#13;&#13;
...     <span class="codestrong1">d[word] = d[word] + 1</span><br/>&#13;&#13;
...<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;&#13;
{'storm': 1, 'cut': 2, 'magma': 1, 'brook': 1}</pre>&#13;&#13;
<p class="indent">Dictionaries make it easy to go from a key to a value. For example, given the key <code>'brook'</code>, we can easily look up the value <code>1</code>:</p>&#13;&#13;
<pre> &gt;&gt;&gt; <span class="codestrong1">d['brook']</span><br/>&#13;&#13;
1</pre>&#13;&#13;
<p class="indent">Referring to <a href="ch08.xhtml#ch08tab01">Table 8-1</a>, that’s like going from a word in the left column to its number of occurrences in the right column. That doesn’t directly tell us the words that have a specified number of occurrences, though. What we really need to be able to do is go from the right column to the left, from number of occurrences to words. Then we’ll be able to sort the numbers of occurrences from most to least to find the words we need.</p>&#13;&#13;
<p class="indent">That is, we need to go from this kind of dictionary:</p>&#13;&#13;
<pre>{'storm': 2, 'cut': 4, 'magma': 1, 'brook': 2,<br/>&#13;&#13;
 'gully': 3, 'cliff': 1, 'blast': 1}</pre>&#13;&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_226"/>to this kind, the <em>inverted dictionary</em>:</p>&#13;&#13;
<pre>{2: ['storm', 'brook'], 4: ['cut'], 1: ['magma', 'cliff', 'blast'],<br/>&#13;&#13;
 3: ['gully']}</pre>&#13;&#13;
<p class="indent">The original dictionary maps from strings to numbers. The inverted dictionary maps from numbers to strings. Well, not quite: the inverted dictionary maps from numbers to <em>lists</em> of strings. Remember that each key is allowed only once in a dictionary. In the inverted dictionary, we need to map each key to multiple values, so we store all of those values in a list.</p>&#13;&#13;
<p class="indent">To invert a dictionary, each key becomes a value, and each value becomes a key. If a key doesn’t exist yet in the inverted dictionary, we create a list for its value. If a key is already in the inverted dictionary, then we add its value to its list.</p>&#13;&#13;
<p class="indent">We can now write a function to return the inverted version of a dictionary. See <a href="ch08.xhtml#ch08ex05">Listing 8-5</a> for the code.</p>&#13;&#13;
<pre>def invert_dictionary(d):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    d is a dictionary mapping strings to numbers.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return the inverted dictionary of d.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    inverted = {}<br/>&#13;&#13;
 <span class="ent">❶</span> for key in d:<br/>&#13;&#13;
     <span class="ent">❷</span> num = d[key]<br/>&#13;&#13;
        if not num in inverted:<br/>&#13;&#13;
         <span class="ent">❸</span> inverted[num] = [key]<br/>&#13;&#13;
        else:<br/>&#13;&#13;
         <span class="ent">❹</span> inverted[num].append(key)<br/>&#13;&#13;
    return inverted</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex05"><em>Listing 8-5: Inverting a dictionary</em></p>&#13;&#13;
<p class="indent">We’re using a <code>for</code> loop over the dictionary <code>d</code> <span class="ent">❶</span>, which gives us each key. We index <code>d</code> to obtain the value mapped to by this key <span class="ent">❷</span>. Then we add this <code>key:value</code> pair to the inverted dictionary. If <code>num</code> is not yet a key in the inverted dictionary, then we add it and make it map to the associated key in <code>d</code> <span class="ent">❸</span>. If <code>num</code> is already a key in the inverted dictionary, then its value is already a list. We can therefore use <code>append</code> to add the key from <code>d</code> as another value <span class="ent">❹</span>.</p>&#13;&#13;
<p class="indent">Enter the code for our <code>invert_dictionary</code> function into the Python shell. Let’s give it a try:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = {'a': 1, 'b': 1, 'c': 1}</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">invert_dictionary(d)</span><br/>&#13;&#13;
{1: ['a', 'b', 'c']}<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">d = {'storm': 2, 'cut': 4, 'magma': 1, 'brook': 2,</span><br/>&#13;&#13;
...      <span class="codestrong1">'gully': 3, 'cliff': 1, 'blast': 1}</span><br/>&#13;&#13;
<span epub:type="pagebreak" id="page_227"/>&gt;&gt;&gt; <span class="codestrong1">invert_dictionary(d)</span><br/>&#13;&#13;
{2: ['storm', 'brook'], 4: ['cut'], 1: ['magma', 'cliff', 'blast'],<br/>&#13;&#13;
 3: ['gully']}</pre>&#13;&#13;
<p class="indent">Now we’re ready to solve Common Words with an inverted dictionary.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec14">Solving the Problem</h3>&#13;&#13;
<p class="noindent">If you’d like more practice with top-down design, you might like to solve the problem on your own before continuing. In the interest of space, I won’t follow the steps of top-down design here. Rather, I’ll present the solution in its entirety, and then we’ll discuss each function and how it is used.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec9">The Code</h4>&#13;&#13;
<p class="noindent">The solution is in <a href="ch08.xhtml#ch08ex06">Listing 8-6</a>.</p>&#13;&#13;
<pre>   def invert_dictionary(d):<br/>&#13;&#13;
       """<br/>&#13;&#13;
       d is a dictionary mapping strings to numbers.<br/>&#13;&#13;
<br/>&#13;&#13;
       Return the inverted dictionary of d.<br/>&#13;&#13;
       """<br/>&#13;&#13;
       inverted = {}<br/>&#13;&#13;
       for key in d:<br/>&#13;&#13;
           num = d[key]<br/>&#13;&#13;
           if not num in inverted:<br/>&#13;&#13;
               inverted[num] = [key]<br/>&#13;&#13;
           else:<br/>&#13;&#13;
               inverted[num].append(key)<br/>&#13;&#13;
       return inverted<br/>&#13;&#13;
<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> def with_suffix(num):<br/>&#13;&#13;
       """<br/>&#13;&#13;
       num is an integer &gt;= 1.<br/>&#13;&#13;
<br/>&#13;&#13;
       Return a string of num with its suffix added; e.g. '5th'.<br/>&#13;&#13;
       """<br/>&#13;&#13;
    <span class="ent">❷</span> s = str(num)<br/>&#13;&#13;
    <span class="ent">❸</span> if s[-1] == '1' and s[-2:] != '11':<br/>&#13;&#13;
           return s + 'st'<br/>&#13;&#13;
       elif s[-1] == '2' and s[-2:] != '12':<br/>&#13;&#13;
           return s + 'nd'<br/>&#13;&#13;
       elif s[-1] == '3' and s[-2:] != '13':<br/>&#13;&#13;
           return s + 'rd'<br/>&#13;&#13;
       else:<br/>&#13;&#13;
           return s + 'th'<br/>&#13;&#13;
           <br/>&#13;&#13;
<span epub:type="pagebreak" id="page_228"/><span class="ent">❹</span> def most_common_words(num_to_words, k):<br/>&#13;&#13;
       """<br/>&#13;&#13;
       num_to_words is a dictionary mapping number of occurrences to<br/>&#13;&#13;
           lists of words.<br/>&#13;&#13;
       k is an integer &gt;= 1.<br/>&#13;&#13;
<br/>&#13;&#13;
       Return a list of the kth most-common words in num_to_words.<br/>&#13;&#13;
       """<br/>&#13;&#13;
       nums = list(num_to_words.keys())<br/>&#13;&#13;
       nums.sort(reverse=True)<br/>&#13;&#13;
<br/>&#13;&#13;
       total = 0<br/>&#13;&#13;
       i = 0<br/>&#13;&#13;
       done = False<br/>&#13;&#13;
    <span class="ent">❺</span> while i &lt; len(nums) and not done:<br/>&#13;&#13;
           num = nums[i]<br/>&#13;&#13;
        <span class="ent">❻</span> if total + len(num_to_words[num]) &gt;= k:<br/>&#13;&#13;
               done = True<br/>&#13;&#13;
           else:<br/>&#13;&#13;
               total = total + len(num_to_words[num])<br/>&#13;&#13;
               i = i + 1<br/>&#13;&#13;
<br/>&#13;&#13;
    <span class="ent">❼</span> if total == k - 1 and i &lt; len(nums):<br/>&#13;&#13;
           return num_to_words[nums[i]]<br/>&#13;&#13;
       else:<br/>&#13;&#13;
           return []<br/>&#13;&#13;
<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❽</span> n = int(input())<br/>&#13;&#13;
<br/>&#13;&#13;
   for dataset in range(n):<br/>&#13;&#13;
       lst = input().split()<br/>&#13;&#13;
       m = int(lst[0])<br/>&#13;&#13;
       k = int(lst[1])<br/>&#13;&#13;
<br/>&#13;&#13;
       word_to_num = {}<br/>&#13;&#13;
<br/>&#13;&#13;
       for i in range(m):<br/>&#13;&#13;
           word = input()<br/>&#13;&#13;
           if not word in word_to_num:<br/>&#13;&#13;
               word_to_num[word] = 1<br/>&#13;&#13;
           else:<br/>&#13;&#13;
               word_to_num[word] = word_to_num[word] + 1<br/>&#13;&#13;
<br/>&#13;&#13;
    <span class="ent">❾</span> num_to_words = invert_dictionary(word_to_num)<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_229"/>       ordinal = with_suffix(k)<br/>&#13;&#13;
       words = most_common_words(num_to_words, k)<br/>&#13;&#13;
<br/>&#13;&#13;
       print(f'{ordinal} most common word(s):')<br/>&#13;&#13;
       for word in words:<br/>&#13;&#13;
           print(word)<br/>&#13;&#13;
<br/>&#13;&#13;
       print()</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex06"><em>Listing 8-6: Solving Common Words</em></p>&#13;&#13;
<p class="indent">The first function is <code>invert_dictionary</code>. We’ve already discussed that, in “Inverting a Dictionary” earlier in this chapter. We’ll now go through each other piece of the program.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec10">Adding the Suffix</h4>&#13;&#13;
<p class="noindent">The <code>with_suffix</code> function <span class="ent">❶</span> takes a number and returns a string with the correct suffix added to the number. We need this function because of the pesky requirement to output <em>k</em> with a suffix. For example, if <em>k</em> = 1, then we’ll have to produce this line as part of the output:</p>&#13;&#13;
<pre>1st most common word(s):</pre>&#13;&#13;
<p class="indent">If <em>k</em> = 2, we’ll have to produce this line as part of the output:</p>&#13;&#13;
<pre>2nd most common word(s):</pre>&#13;&#13;
<p class="noindent">and so on. Our <code>with_suffix</code> function makes sure that we add the correct suffix to the number. We first convert the number to a string <span class="ent">❷</span> so that we can easily access its digits. Then we use a series of tests to determine whether the suffix is <code>st</code>, <code>nd</code>, <code>rd</code>, or <code>th</code>. For example, if the last digit is a <code>1</code> but the last two digits aren’t <code>11</code> <span class="ent">❸</span>, then the correct suffix is <code>st</code>. That gives us <code>1st</code>, <code>21st</code>, and <code>31st</code>, but not <code>11st</code> (which would be incorrect).</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec11">Finding the kth Most Common Words</h4>&#13;&#13;
<p class="noindent">The <code>most_common_words</code> function <span class="ent">❹</span> is the function that actually finds the words that we need. It takes an inverted dictionary (which maps numbers of occurrences to lists of words) and an integer <code>k</code> and returns a list of the <code>k</code>th most common words.</p>&#13;&#13;
<p class="indent">To see how it works, let’s look at a sample inverted dictionary. I’ve organized its keys in order from most occurrences to fewest occurrences, as that’s the order that <code>most_common_words</code> goes through the keys. Here’s the dictionary:</p>&#13;&#13;
<pre>{4: ['cut'],<br/>&#13;&#13;
 3: ['gully'],<br/>&#13;&#13;
 2: ['storm', 'brook'],<br/>&#13;&#13;
 1: ['magma', 'cliff', 'blast']}</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_230"/>Suppose that <code>k</code> is <code>3</code>. Therefore, exactly two words must be more common than the words that we return. The words we need are not provided by the first dictionary key. That key gives us only one word (<code>cut</code>), so it can’t be the third most common word. Similarly, the words we need are not provided by the second dictionary key. That key gives us one more word (<code>gully</code>). We’ve processed a total of two words now but haven’t found the third most common words yet. The words we need, however, <em>are</em> provided by the third dictionary key. That key gives us two more words; each of these words (<code>storm</code> and <code>brook</code>) has exactly two words with more occurrences, so these are the words for when <code>k</code> is <code>3</code>.</p>&#13;&#13;
<p class="indent">What if <code>k</code> were <code>4</code>? This time, exactly three words must be more common than the words that we return. The candidate words are still those from the third key (<code>storm</code> and <code>brook</code>), but there are only two words that occur more often than each of these words. There are therefore <em>no</em> words for when <code>k = 4</code>.</p>&#13;&#13;
<p class="indent">In summary, we need to total up the words we see when going through the keys until we find the key that might contain the words we need. If exactly <code>k - 1</code> words occur more often, then we have words for <code>k</code>; otherwise, we don’t, and there are no words to output.</p>&#13;&#13;
<p class="indent">Now let’s walk through the code itself. We begin by obtaining a list of the dictionary’s keys and sorting them from biggest to smallest. We then loop through the keys in that reverse-sorted order <span class="ent">❺</span>. The <code>done</code> variable tells us whether we’ve looked at <code>k</code> or more words yet. As soon as we have <span class="ent">❻</span>, we exit the loop.</p>&#13;&#13;
<p class="indent">When the loop is done, we check whether there are any words for <code>k</code>. If there are exactly <code>k - 1</code> words that occur more often, and we haven’t gone past the end of our keys <span class="ent">❼</span>, then we indeed have words to return. Otherwise, there are no words to return, so we return the empty list.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec12">The Main Program</h4>&#13;&#13;
<p class="noindent">Now we arrive at the main part of the program <span class="ent">❽</span>. We build dictionary <code>word_to_num</code>, which maps each word to its number of occurrences. We then build the inverted dictionary <code>num_to_words</code> <span class="ent">❾</span>, which maps each number of occurrences to the associated list of words. Notice how the names of these dictionaries convey the direction of mapping: <code>word_to_num</code> goes from words to numbers, and <code>num_to_words</code> goes from numbers to words.</p>&#13;&#13;
<p class="indent">The rest of the code calls our other helper functions and outputs the appropriate words.</p>&#13;&#13;
<p class="indent">With that, you’re ready to submit to the judge. Well done: that’s the first problem that you’ve solved with dictionaries. Whenever you need to map between two types of values, think about whether you can organize the information using a dictionary. If you can, it’s likely that you’ll be well on your way to an efficient solution!</p>&#13;&#13;
<h3 class="h3a" id="ch08lev1sec15"><span epub:type="pagebreak" id="page_231"/><span class="h3aa">Problem #20: Cities and States</span></h3>&#13;&#13;
<p class="noindent">Here’s another problem where we’ll be able to use a dictionary. As you read the problem description, think about what we could use as the keys and what we could use as the values.</p>&#13;&#13;
<p class="indent">This is USACO 2016 December Silver Contest problem Cities and States.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec13">The Challenge</h4>&#13;&#13;
<p class="noindent">The United States is divided into geographical regions called <em>states</em>, each of which contains one or more cities. Each state has been given a two-character abbreviation. For example, the abbreviation for Pennsylvania is PA, and the abbreviation for South Carolina is SC. We’ll write city names and state abbreviations in all uppercase.</p>&#13;&#13;
<p class="indent">Consider the pair of cities <code>SCRANTON PA</code> and <code>PARKER SC</code>. This pair of cities is <em>special</em> because the first two characters of each city give the abbreviation for the other city’s state. That is, the first two characters of SCRANTON give us SC (PARKER’s state), and the first two characters of PARKER give us PA (SCRANTON’s state).</p>&#13;&#13;
<p class="indent">A pair of cities is <em>special</em> if they meet this property and are not in the same state.</p>&#13;&#13;
<p class="indent">Determine the number of special pairs of cities in the provided input.</p>&#13;&#13;
<h4 class="h4" id="ch08lev2sec14">Input</h4>&#13;&#13;
<p class="noindent">Read input from the file named <em>citystate.in</em>.</p>&#13;&#13;
<p class="indent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing <em>n</em>, the number of cities. <em>n</em> is between 1 and 200,000.</li>&#13;&#13;
<li class="noindent"><em>n</em> lines, one per city. Each line gives the name of a city in uppercase, a space, and its state’s abbreviation in uppercase. The name of each city is between 2 and 10 characters; the abbreviation for each state is exactly two characters. The same city name can exist in multiple states but will not appear more than once in the same state. The name of a city or state in this problem is any string that meets these requirements; it might not be the name of an actual US city or state.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch08lev2sec15">Output</h4>&#13;&#13;
<p class="noindent">Write output to the file named <em>citystate.out</em>.</p>&#13;&#13;
<p class="indent">Output the number of special pairs of cities.</p>&#13;&#13;
<p class="indent">The time limit for solving each test case is four seconds.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec16"><span epub:type="pagebreak" id="page_232"/>Exploring a Test Case</h3>&#13;&#13;
<p class="noindent">Perhaps you’re thinking that you could solve this problem with a list. That’s a good thought to have! If you’re interested, I suggest giving that a try before continuing. The strategy would be to use two nested loops to consider each pair of cities and check whether each pair is special. It’s possible to come up with a correct solution using this approach.</p>&#13;&#13;
<p class="indent">A correct solution, yes, but also a slow one. The list of cities can be huge—up to a maximum of 200,000—and any solution involving searching a list for matching cities is doomed to be too slow. Let’s explore a test case and work out how a dictionary can help.</p>&#13;&#13;
<p class="indent">Here’s our test case:</p>&#13;&#13;
<pre>12<br/>&#13;&#13;
SCRANTON PA<br/>&#13;&#13;
MANISTEE MI<br/>&#13;&#13;
NASHUA NH<br/>&#13;&#13;
PARKER SC<br/>&#13;&#13;
LAFAYETTE CO<br/>&#13;&#13;
WASHOUGAL WA<br/>&#13;&#13;
MIDDLEBOROUGH MA<br/>&#13;&#13;
MADISON MI<br/>&#13;&#13;
MILFORD MA<br/>&#13;&#13;
MIDDLETON MA<br/>&#13;&#13;
COVINGTON LA<br/>&#13;&#13;
LAKEWOOD CO</pre>&#13;&#13;
<p class="indent">The first city is <code>SCRANTON PA</code>. To find special pairs involving this city, we need to find other cities whose name starts with <code>PA</code> and whose state is <code>SC</code>. The only other city that meets this description is <code>PARKER SC</code>.</p>&#13;&#13;
<p class="indent">Notice that all we care about for <code>SCRANTON PA</code> is that its name starts with <code>SC</code> and that its state is <code>PA</code>. It could have been called <code>SCMERWIN PA</code> or <code>SCSHOCK PA</code> or <code>SCHRUTE PA</code>; it would still be a special pair with <code>PARKER SC</code>.</p>&#13;&#13;
<p class="indent">Let’s refer to the first two characters of a city name followed by the city’s state as a <em>combo</em>. For example, the combo for <code>SCRANTON PA</code> is <code>SCPA</code>, and the combo for <code>PARKER SC</code> is <code>PASC</code>.</p>&#13;&#13;
<p class="indent">Rather than searching for special pairs of cities, we can now look at special pairs of combos. Let’s try this.</p>&#13;&#13;
<p class="indent">There are two cities with the combo <code>MAMI</code>. They happen to be <code>MANISTEE MI</code> and <code>MADISON MI</code>, but all we care about is that there are two of them. The <code>MAMI</code> cities start with <code>MA</code> and are in state <code>MI</code>. To count up the special pairs involving <code>MAMI</code> cities, we need to know the cities that start with <code>MI</code> and have state <code>MA</code>. That is, we need to know the number of <code>MIMA</code> cities. There are three <code>MIMA</code> cities. They happen to be <code>MIDDLEBOROUGH MA</code>, <code>MILFORD MA</code>, and <code>MIDDLETON MA</code>, but all we care about is that there are three of them. Okay—so we have two <code>MAMI</code> cities and three <code>MIMA</code> cities. The total special pairs for these combos is therefore 2 * 3 = 6, because for each of the two <code>MAMI</code> cities, we have a choice of three <code>MIMA</code> cities.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_233"/>If you’re not convinced, here are the six special pairs for these combos:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent"><code>MANISTEE MI</code> and <code>MIDDLEBOROUGH MA</code></li>&#13;&#13;
<li class="noindent"><code>MANISTEE MI</code> and <code>MILFORD MA</code></li>&#13;&#13;
<li class="noindent"><code>MANISTEE MI</code> and <code>MIDDLETON MA</code></li>&#13;&#13;
<li class="noindent"><code>MADISON MI</code> and <code>MIDDLEBOROUGH MA</code></li>&#13;&#13;
<li class="noindent"><code>MADISON MI</code> and <code>MILFORD MA</code></li>&#13;&#13;
<li class="noindent"><code>MADISON MI</code> and <code>MIDDLETON MA</code></li>&#13;&#13;
</ul>&#13;&#13;
<p class="indent">If we could map combos—<code>SCPA</code>, <code>PASC</code>, <code>MAMI</code>, <code>MIMA</code>, and so on—to the number of occurrences, we could loop through the combos to find the number of special pairs of cities. A dictionary is the perfect tool to store this mapping.</p>&#13;&#13;
<p class="indent">Here’s the dictionary that we’d like to create for our test case:</p>&#13;&#13;
<pre>{'SCPA': 1, 'MAMI': 2, 'NANH': 1, 'PASC': 1, 'LACO': 2,<br/>&#13;&#13;
 'MIMA': 3, 'COLA': 1}</pre>&#13;&#13;
<p class="indent">With this dictionary, we can figure out the number of special pairs of cities. Let’s work through the process.</p>&#13;&#13;
<p class="indent">The first key is <code>'SCPA'</code>; its value is <code>1</code>. To find special pairs of cities involving <code>'SCPA'</code>, we need to look up the value for <code>'PASC'</code>. That value is also <code>1</code>. We multiply the two values together, yielding 1 * 1 = 1 special pair of cities involving these combos. We need to carry out this same procedure for each other key in the dictionary.</p>&#13;&#13;
<p class="indent">The next key is <code>'MAMI'</code>; its value is <code>2</code>. To find special pairs of cities involving <code>'MAMI'</code>, we need to look up the value for <code>'MIMA'</code>. That value is <code>3</code>. We multiply the two values together, yielding 2 * 3 = 6 special pairs of cities involving these combos. With the 1 we found previously, we now have a total of 7.</p>&#13;&#13;
<p class="indent">The next key is <code>'NANH'</code>; its value is <code>1</code>. To find special pairs of cities involving <code>'NANH'</code>, we need to look up the value for <code>'NHNA'</code>. But <code>'NHNA'</code> isn’t a key in the dictionary! There are no special pairs of cities involving these combos. We still have a total of 7.</p>&#13;&#13;
<p class="indent">Pay close attention to this next one. The next key is <code>'PASC'</code>; its value is <code>1</code>. To find special pairs of cities involving <code>'PASC'</code>, we need to look up the value for <code>'SCPA'</code>. That value is also <code>1</code>. We multiply the two values together, yielding 1 * 1 = 1 special pair of cities involving these combos. But wait: we already accounted for this pair when we processed the key <code>'SCPA'</code>. If we add 1 here, then we’ll end up double-counting this pair. In fact, by processing each key we will double-count <em>every</em> special pair of cities. Not to worry, though: we’ll make an adjustment later when we’re ready to print the final answer. Let’s add this 1 in there. With the 7 we found previously, we now have a total of 8.</p>&#13;&#13;
<p class="indent">The next key is <code>'LACO'</code>; its value is <code>2</code>. The value for <code>'COLA'</code> is <code>1</code>, giving 2 * 1 = 2 special pairs of cities involving these combos. With the 8 we found previously, we now have a total of 10.</p>&#13;&#13;
<p class="indent">There are two keys to go, <code>'MIMA'</code> and <code>'COLA'</code>. The first leads us to add 6 to our total; the second leads us to add 2. With the 10 we found previously, we now have a total of 18.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_234"/>Remember that we’ve double-counted every special pair of cities. We don’t have 18 unique special pairs of cities, then. We have only 18 / 2 = 9 special pairs of cities. All we need to do is divide by 2 to undo the double counting.</p>&#13;&#13;
<p class="indent">If you compare the dictionary we just went through to the cities in the test case, you’ll notice that something is missing from the dictionary. It’s that city <code>WASHOUGAL WA</code>! Its combo is <code>WAWA</code>, but there’s no <code>'WAWA'</code> key in our dictionary. We’re not accounting for this city, and we need to understand why.</p>&#13;&#13;
<p class="indent">The first two characters of <code>WASHOUGAL WA</code> are <code>WA</code>. This means that the only way for <code>WASHOUGAL WA</code> to be part of a special pair of cities is to find another city whose state is <code>WA</code>. Notice that <code>WASHOUGAL WA</code> is in state <code>WA</code>, too. However, the problem specifies that the two cities in a special pair of cities must come from different states. There’s therefore no way to find a special pair of cities involving <code>WASHOUGAL WA</code>. To make sure we don’t accidentally count fake special pairs, we don’t even include <code>WASHOUGAL WA</code> in the dictionary.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec17">Solving the Problem</h3>&#13;&#13;
<p class="noindent">We’re ready to go! We can use a dictionary for a concise, rocket-fast solution to Cities and States. The code is in <a href="ch08.xhtml#ch08ex07">Listing 8-7</a>.</p>&#13;&#13;
<pre>   input_file = open('citystate.in', 'r')<br/>&#13;&#13;
   output_file = open('citystate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   n = int(input_file.readline())<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> combo_to_num = {}<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(n):<br/>&#13;&#13;
       lst = input_file.readline().split()<br/>&#13;&#13;
    <span class="ent">❷</span> city = lst[0][:2]<br/>&#13;&#13;
       state = lst[1]<br/>&#13;&#13;
    <span class="ent">❸</span> if city != state:<br/>&#13;&#13;
           combo = city + state<br/>&#13;&#13;
           if not combo in combo_to_num:<br/>&#13;&#13;
               combo_to_num[combo] = 1<br/>&#13;&#13;
           else:<br/>&#13;&#13;
               combo_to_num[combo] = combo_to_num[combo] + 1<br/>&#13;&#13;
<br/>&#13;&#13;
   total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❹</span> for combo in combo_to_num:<br/>&#13;&#13;
    <span class="ent">❺</span> other_combo = combo[2:] + combo[:2]<br/>&#13;&#13;
       if other_combo in combo_to_num:<br/>&#13;&#13;
        <span class="ent">❻</span> total = total + combo_to_num[combo] * combo_to_num[other_combo]<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❼</span> output_file.write(str(total // 2) + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_235"/>   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch08ex07"><em>Listing 8-7: Solving Cities and States</em></p>&#13;&#13;
<p class="indent">This is a USACO problem where we need to use files rather than standard input and standard output.</p>&#13;&#13;
<p class="indent">The dictionary that we’ll build is called <code>combo_to_num</code> <span class="ent">❶</span>. It maps from four-character combos, like <code>'SCPA'</code>, to the number of cities with that combo.</p>&#13;&#13;
<p class="indent">For each city from the input, we use variables to refer to the first two characters of the name of the city <span class="ent">❷</span> and its state. Then, if these values are not the same <span class="ent">❸</span>, we combine them and add the combo to the dictionary. If the combo wasn’t already in the dictionary, we add it with a value of 1; if it was already there, we increase its value by 1.</p>&#13;&#13;
<p class="indent">The dictionary is now built. We loop through its keys <span class="ent">❹</span>. For each key, we construct the other combo that we need to look up to find special pairs of cities involving this key. If the key is <code>'SCPA'</code>, for example, then we want the other combo to be <code>'PASC'</code>. To do that, we take the rightmost two characters of the key and follow those by the leftmost two characters <span class="ent">❺</span>. If that other combo is also in the dictionary, then we multiply the two key’s values and add that to our total <span class="ent">❻</span>.</p>&#13;&#13;
<p class="indent">All we need to do now is output the total number of special pairs of cities to the output file. As explained in the previous section, we need to divide our total by 2 <span class="ent">❼</span> to undo the double-counting that results from processing each key in the dictionary.</p>&#13;&#13;
<p class="indent">There we have it: another example of solving a problem with a suitable deployment of a dictionary. Feel free to submit our code!</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec18">Summary</h3>&#13;&#13;
<p class="noindent">In this chapter, we learned about Python sets and dictionaries. A set is a collection of values with no order and no duplicates. A dictionary is a collection of <code>key:value</code> pairs. As we saw in this chapter’s problems, sometimes these collections are more appropriate than lists. For example, determining whether a value is in a set is ridiculously fast compared to the same operation on a list. If we don’t care about the order of values or want to eliminate duplicates, we should seriously consider using a set.</p>&#13;&#13;
<p class="indent">Similarly, a dictionary makes it easy to determine the value mapped to by a key. If we’re maintaining a mapping from keys to values, then we should seriously consider using a dictionary.</p>&#13;&#13;
<p class="indent">With sets and dictionaries in the mix, you now have more flexibility for how to store your values. This flexibility, however, means that you need to make a choice. Don’t default to using a list anymore! The difference between using one type or another might be the difference between solving the problem or not.</p>&#13;&#13;
<p class="indent">We’ve reached an important milestone, as we’ve now covered most of the Python that I’ll be teaching you in this book. This doesn’t mean that your Python journey is complete. There’s a lot more to know about Python <span epub:type="pagebreak" id="page_236"/>beyond what I’ve included in the book. This does mean, though, that we’ve reached a point where we can solve a wide variety of problems—in competitive programming or otherwise—with our Python skills.</p>&#13;&#13;
<p class="indent">In the next chapter of the book, we shift gears: from learning new Python features to sharpening our problem-solving ability. We’ll focus on one particular type of problem that we can solve by searching through all candidate solutions.</p>&#13;&#13;
<h3 class="h3" id="ch08lev1sec19">Chapter Exercises</h3>&#13;&#13;
<p class="noindent">Here are some exercises for you to try. For each, use a set or dictionary. Sometimes, a set or dictionary will help you write code that runs faster; other times, it will help you write code that’s more organized and easier to read.</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">DMOJ problem <code>crci06p1</code>, Bard</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>dmopc19c5p1</code>, Conspicuous Cryptic Checklist</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci15c2p1</code>, Marko</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>ccc06s2</code>, Attack of the CipherTexts</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>dmopc19c3p1</code>, Mode Finding</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci14c2p2</code>, Utrka (Try solving this one in three different ways: using a dictionary, using a set, and using lists!)</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci17c2p2</code>, ZigZag (Hint: maintain two dictionaries. The first maps each starting letter to its list of words; the second maps each starting letter to the index of its next word that will be output. That way, we can cycle through the words for each letter without having to explicitly update numbers of occurrences or modify lists.)</li>&#13;&#13;
</ol>&#13;&#13;
<h3 class="h3" id="ch08lev1sec20">Notes</h3>&#13;&#13;
<p class="noindent">Email Addresses is originally from the 2019 Educational Computing Organization of Ontario Programming Contest, Round 2. Common Words is originally from the 1999 Canadian Computing Olympiad. Cities and States is originally from the USACO 2016 December Silver Contest.</p>&#13;&#13;
<p class="indent">If you’d like to learn more about Python, I recommend <em>Python Crash Course</em>, 2nd edition by Eric Matthes (No Starch Press, 2019). When you’re ready to take it to the next level, you might like to read <em>Effective Python</em>, 2nd edition by Brett Slatkin (Addison-Wesley Professional, 2020), which offers a collection of tips to help you write better Python code.</p>&#13;&#13;
</div></body></html>