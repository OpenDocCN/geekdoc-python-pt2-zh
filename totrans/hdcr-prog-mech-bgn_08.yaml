- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: POLYGONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: Our next primitive, polygons, builds on points and segments. Polygons can be
    used to describe colliding geometries, portions of the screen that need redrawing,
    body boundaries, and much more. It turns out these primitives are extremely useful
    when it comes to processing images, as you can use them to figure out whether
    different parts of the image overlap. In dynamics simulations, they help determine
    when two bodies collide. In user interfaces for graphic-intensive applications,
    you can use simple polygons to easily figure out whether the user’s mouse is over
    an entity that may be selected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个原始元素，多边形，建立在点和线段的基础上。多边形可以用来描述碰撞的几何图形、需要重新绘制的屏幕部分、物体边界等等。事实证明，这些原始元素在图像处理时非常有用，因为你可以利用它们来判断图像的不同部分是否重叠。在动态仿真中，它们有助于确定两个物体何时碰撞。在图形密集型应用的用户界面中，你可以使用简单的多边形来轻松判断用户的鼠标是否悬停在可能被选中的实体上。
- en: 'In this chapter, we’ll be implementing three primitives: generic polygons,
    described by their vertices; circles, defined by a center point and a radius;
    and rectangles, defined by an origin point, a width, and a height. Because it
    may be more convenient in some applications to work only with generic polygons,
    both the circle and the rectangle will implement a method to convert themselves
    into a generic polygon. We’ll also write a few other algorithms, including one
    that determines whether a polygon overlaps with another of its class and one that
    tests whether a polygon contains a given point.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现三种原始元素：通过顶点定义的通用多边形；通过中心点和半径定义的圆；以及通过原点、宽度和高度定义的矩形。由于在某些应用中仅使用通用多边形可能更为方便，因此圆和矩形都会实现一个方法，将它们转换为通用多边形。我们还将编写一些其他算法，包括一个判断多边形是否与另一个同类多边形重叠的算法，以及一个测试多边形是否包含给定点的算法。
- en: '**Polygon Class**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Polygon 类**'
- en: A *polygon* is a two-dimensional figure defined by a sequence of a minimum of
    three ordered and noncoincident vertices connected to form a closed *polygonal
    chain*. Each connection is a segment going from one vertex to the next one, where
    the last vertex is connected back to the first. Given vertices [*V*[1], *V*[2],
    …, *V*[*n*]], each of the segments defined as [(*V*[1] → *V*[2]),(*V*[2] → *V*[3]),
    …, (*V*[*n*] → *V*[1])] is called a *side* (see [Figure 6-1](ch06.xhtml#ch6fig1)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*多边形*是一个二维图形，通过至少三个有序且不重合的顶点定义，这些顶点连接形成一个闭合的*多边形链条*。每个连接都是一个线段，从一个顶点到下一个顶点，其中最后一个顶点连接回第一个顶点。给定顶点[*V*[1],
    *V*[2], …, *V*[*n*]]，每个线段定义为[(*V*[1] → *V*[2]),(*V*[2] → *V*[3]), …, (*V*[*n*]
    → *V*[1])]，被称为*边*（参见[Figure 6-1](ch06.xhtml#ch6fig1)）。'
- en: '![Image](../images/06fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig01.jpg)'
- en: '*Figure 6-1: A polygon defined by its vertices*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-1: 通过顶点定义的多边形*'
- en: 'At this point, your *geom2d* package should look like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的*geom2d*包应该是这样的：
- en: Mechanics
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 力学
- en: '|- geom2d'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- __init__.py'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- line.py'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- line.py'
- en: '|    |- line_test.py'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- line_test.py'
- en: '|    |- nums.py'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- nums.py'
- en: '|    |- point.py'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point.py'
- en: '|    |- point_test.py'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point_test.py'
- en: '|    |- segment.py'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- segment.py'
- en: '|    |- segment_test.py'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- segment_test.py'
- en: '|    |- vector.py'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector.py'
- en: '|    |- vector_test.py'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector_test.py'
- en: '|    |- vectors.py'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vectors.py'
- en: Let’s create a class to represent polygons defined by their vertices as a sequence
    of points (instances of class Point). Create a new file inside the package *geom2d*,
    name it *polygon.py*, and enter the code from [Listing 6-1](ch06.xhtml#ch6lis1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类来表示通过顶点定义的多边形，顶点作为一系列点（Point类的实例）。在*geom2d*包内创建一个新文件，命名为*polygon.py*，并输入[Listing
    6-1](ch06.xhtml#ch6lis1)中的代码。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: Polygon initialization*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-1: 多边形初始化*'
- en: First we import Point from geom2d.point. Then we define class Polygon with an
    initializer that accepts a sequence of points ordered according to the polygonal
    chain; connected vertices should be adjacent in the sequence. If the list contains
    fewer than three points, we raise an exception of type ValueError. Remember the
    fail fast strategy? We want to fail as soon as we detect something that doesn’t
    make sense and may cause trouble, such as a polygon with fewer than three vertices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们从geom2d.point导入Point类。然后我们定义Polygon类，创建一个初始化函数，接受一个按多边形链条顺序排列的点的序列；相连的顶点应在序列中相邻。如果列表包含少于三个点，我们将抛出一个ValueError类型的异常。还记得快速失败策略吗？我们希望在检测到任何不合逻辑并可能引发问题的情况时尽早失败，例如一个包含少于三个顶点的多边形。
- en: '**NOTE**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*According to Python’s documentation, a* ValueError *should be raised when
    “an operation or function receives an argument that has the right type but an
    inappropriate value, and the situation is not described by a more precise exception.”*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据Python的文档，当“操作或函数接收到一个类型正确但值不合适的参数，并且该情况没有更精确的异常描述”时，应该引发ValueError*。'
- en: '***Sides***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***边***'
- en: A *side* is a segment going from one vertex to the next in a polygon’s sequence
    of vertices. The sides of a polygon together make up its *perimeter*. To close
    the polygonal chain, the last vertex needs to connect with the first. Generating
    the sides of a polygon thus requires pairing up a sequence of vertices. This sounds
    like a generic operation we could use for any sequence of objects, not just vertices,
    so we want to implement it in its own module.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*边*是指在多边形的顶点序列中，从一个顶点到下一个顶点的线段。多边形的边一起构成了它的*周长*。为了闭合多边形链条，最后一个顶点需要与第一个顶点相连。因此，生成多边形的边需要配对顶点序列。这听起来像是一个通用操作，我们可以将其应用于任何对象序列，而不仅仅是顶点，因此我们希望将其实现为一个独立的模块。
- en: For the sections that follow, you’ll need a good understanding of Python’s list
    comprehensions. You can refer to “List Comprehensions” on [page 35](ch02.xhtml#ch00lev2sec23)
    for a refresher.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你需要对Python的列表推导式有较好的理解。你可以参考[第35页](ch02.xhtml#ch00lev2sec23)的“列表推导式”部分以复习相关知识。
- en: '**Pairing Vertices**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配对顶点**'
- en: Given a list of items (of whatever type),
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个项目列表（无论是什么类型），
- en: '[A, B, C]'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[A, B, C]'
- en: 'the pairing algorithm should create a new list where each item is a tuple of
    the original item at that position paired up with the next, including a pair of
    the last element with the first, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 配对算法应该创建一个新的列表，其中每个元素是原始位置的项与下一个项的元组，包括将最后一个元素与第一个元素配对，如下所示：
- en: '[(A, B), (B, C), (C, A)]'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[(A, B), (B, C), (C, A)]'
- en: 'Let’s write this code in a new package inside our Python project. Create a
    new package at the same level as *geom2d* and name it *utils*. In this package
    we’ll keep small pieces of generic logic that are potentially reusable by the
    rest of our project modules. Your project’s folder structure should look like
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python项目中新建一个包来编写这段代码。在*geom2d*同级目录下创建一个新包，命名为*utils*。在这个包中，我们将保存一些可能会被项目其他模块复用的小型通用逻辑。你的项目文件夹结构应该如下所示：
- en: Mechanics
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 机械学
- en: '|- geom2d'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- __init__.py'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- line.py'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- line.py'
- en: '|    | ...'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|    | ...'
- en: '|- utils'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '|- utils'
- en: '|    |- __init__.py'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: Many software projects end up having a *utils* package or module where all kinds
    of unrelated algorithms are bundled together. Although convenient, this practice
    is ultimately doomed and hinders the project’s maintainability. A *utils* package
    is for pieces of code that aren’t big enough to be promoted to their own package
    but are still reused by many other parts inside the project. When related code
    inside *utils* starts to grow, you’re better off moving it to its own dedicated
    package. For example, if our pairing logic started to specialize, covering lots
    of different cases and types of collections, we would move it to a new package
    called *pairs*. That’s not the case here, so we’ll keep it simple.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件项目最终都会有一个*utils*包或模块，里面聚集了各种不相关的算法。虽然这种做法很方便，但最终会导致项目维护困难，且难以持续发展。*utils*包是为那些没有足够大到可以单独成为一个包，但仍然被项目内多个部分复用的代码块所设计的。当*utils*中的相关代码开始增多时，最好将其迁移到专门的包中。例如，如果我们的配对逻辑开始变得更加复杂，涉及到各种不同的情况和集合类型，我们可以将其移动到一个名为*pairs*的新包中。但目前情况并非如此，因此我们将保持简单。
- en: In the package create a new file named *pairs.py* and include the function in
    [Listing 6-2](ch06.xhtml#ch6lis2).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在该包中创建一个新文件，命名为*pairs.py*，并在其中包含[列出 6-2](ch06.xhtml#ch6lis2)中的函数。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: Pairing up list elements*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 6-2：配对列表元素*'
- en: 'The function uses a *list comprehension* to create a new list from a range
    of values, starting from 0 and going all the way to length ➋. For each value it
    creates a tuple with two items ➊: the element at index i from the original list
    and the next one at i + 1. When we reach index i = length, i + 1 would be out
    of bounds in sequence, so we want to wrap around and go back to index 0 so that
    the last and first elements are also paired up. We do this with the modulo operator
    (%), which returns the remainder when you divide one number by another. The neat
    thing is that *n* % *m* returns *n* for every *n* < *m*, and it returns 0 for
    *n* = *m*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用*列表推导式*从一个值的范围内创建一个新列表，起始值为0，直到长度➋。对于每个值，它会创建一个包含两个元素➊的元组：原始列表中索引为i的元素和索引为i
    + 1的下一个元素。当我们达到索引i = length时，i + 1在序列中会越界，所以我们希望通过模运算符将其包裹回到索引0，以便最后一个元素和第一个元素也能配对。我们使用模运算符（%）来实现这一点，它返回将一个数字除以另一个数字的余数。巧妙之处在于，*n*
    % *m*对于每个*n* < *m*都会返回*n*，并且当*n* = *m*时返回0。
- en: 'To better understand modulo, try this in the shell:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解模运算，请在终端中尝试以下操作：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'See how for *n* = 4 the result is 0, but for all other values the result is
    *n* itself? Try to increase the range parameter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当*n* = 4时结果是0，而对于其他所有值，结果是*n*本身？尝试增加范围参数：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Numbers in a modulo 4 operation never go beyond 3\. Once that number is reached,
    the next one wraps around to 0 again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在模4运算中，数字永远不会超过3。一旦达到这个数字，下一个数字就会重新回到0。
- en: '**NOTE**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to know more about this “wrapping around” phenomenon resulting
    from the modulo operator, search for* modular arithmetic*. It’s widely used in
    modern cryptography and has some really interesting properties.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想了解更多关于这种“包裹”现象的知识，请搜索*模算术*。它在现代密码学中被广泛应用，并且具有一些非常有趣的属性。*'
- en: We’re now ready to implement the method that will generate the sides for our
    Polygon class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实现一个方法，用于生成我们的Polygon类的边。
- en: '**Generating Sides**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成边**'
- en: 'Once vertices are properly paired, writing the code to generate the sides is
    simple: we just need to create a Segment instance per pair of vertices. To compute
    them, first add the following imports in your file *polygon.py*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦顶点正确配对，编写生成边的代码就变得简单：我们只需要为每对顶点创建一个Segment实例。为了计算它们，首先在你的文件*polygon.py*中添加以下导入：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, enter the method in [Listing 6-3](ch06.xhtml#ch6lis3).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入[列表 6-3](ch06.xhtml#ch6lis3)中的方法。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-3: Computing polygon sides*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：计算多边形的边*'
- en: Using the make_round_pairs function, we pair vertices up such that each tuple
    in vertex_pairs contains the start and end points of a segment. Then, using a
    list comprehension, each of these tuples is mapped into a segment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用make_round_pairs函数，我们将顶点配对，使得每个顶点对元组都包含一条线段的起始和结束点。然后，使用列表推导式，将这些元组映射为线段。
- en: '**Testing Sides**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试边**'
- en: Let’s create a unit test for the sides attribute. Create a new file named *polygon_test.py*
    inside the package *geom2d* and enter the code for class TestPolygon ([Listing
    6-4](ch06.xhtml#ch6lis4)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为边属性创建一个单元测试。创建一个新的文件*polygon_test.py*，并将其放在*geom2d*包中，然后输入TestPolygon类的代码（见[列表
    6-4](ch06.xhtml#ch6lis4)）。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-4: Testing sides of a polygon*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-4：测试多边形的边*'
- en: 'Inside the test class we create a list of vertices—(0, 0), (30, 0), and (0,
    30)—that make a triangle. We use these points as vertices for the creation of
    the test subject: polygon. [Figure 6-2](ch06.xhtml#ch6fig2) illustrates the polygon.
    To ensure the sides are properly computed, we construct the list of expected sides
    using the original vertices properly paired up.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类中，我们创建了一个顶点列表——(0, 0)、(30, 0)和(0, 30)——它们构成了一个三角形。我们使用这些点作为测试对象polygon的顶点。[图
    6-2](ch06.xhtml#ch6fig2)展示了该多边形。为了确保边正确计算，我们使用原始顶点按正确顺序配对来构建预期边的列表。
- en: '![Image](../images/06fig02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig02.jpg)'
- en: '*Figure 6-2: The polygon used in the test*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：测试中使用的多边形*'
- en: Since we overloaded the *==* operator in the Segment class (by implementing
    the special method __eq__), the equality comparison will work as intended. If
    we hadn’t done so, the equality assertion would consider segments different even
    if bounded by the same end points, and thus the test would fail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在Segment类中重载了*==*运算符（通过实现特殊方法__eq__），所以相等比较会按预期工作。如果我们没有这么做，即使是由相同的端点界定的线段，相等断言也会认为它们不同，从而导致测试失败。
- en: Run the test using the following command to make sure it succeeds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试，确保它成功。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If everything went well, you should get this output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到以下输出：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***Centroid***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***质心***'
- en: A noteworthy point in a polygon is its *centroid*, the arithmetic mean of the
    position of all vertices. Assuming *n* is the number of vertices, the *centroid*
    can be expressed using [Equation 6.1](ch06.xhtml#ch06eqa01).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形中的一个重要点是它的*质心*，即所有顶点位置的算术平均值。假设 *n* 是顶点的数量，*质心* 可以使用[方程 6.1](ch06.xhtml#ch06eqa01)来表示。
- en: '![Image](../images/06eqa01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06eqa01.jpg)'
- en: Here, *x*[*i*] and *y*[*i*] are the coordinates of vertex *i*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*x*[*i*] 和 *y*[*i*] 是顶点 *i* 的坐标。
- en: '**Implementing the Centroid**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现质心**'
- en: 'Let’s implement the centroid property. To do so, we first need to import the
    following at the top of our Polygon class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现质心属性。为此，我们首先需要在多边形类的顶部导入以下内容：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once imported, add the code in [Listing 6-5](ch06.xhtml#ch6lis5) beneath the
    sides method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，将[列表 6-5](ch06.xhtml#ch6lis5)中的代码添加到 `sides` 方法下方。
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-5: Calculating a centroid of a polygon*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-5：计算多边形的质心*'
- en: We first store the length of the list of vertices in the variable vtx_count
    ➊. Then, we reduce the list of vertices by summing them into a resulting point
    called vtx_sum ➋. You may want to read “Filter, Map, and Reduce” on [page 29](ch02.xhtml#ch00lev2sec22)
    to review the reduce function and how we use operator. Note that the operator
    operator.add works for the reduce function because our Point class overloads the
    + operator.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将顶点列表的长度存储在变量 `vtx_count` 中 ➊。然后，我们通过将它们相加来归约顶点列表，得到一个称为 `vtx_sum` 的结果点
    ➋。你可能想阅读[第 29 页](ch02.xhtml#ch00lev2sec22)中的《过滤、映射和归约》部分，以回顾 `reduce` 函数以及我们如何使用操作符。请注意，`operator.add`
    操作符可以在 `reduce` 函数中使用，因为我们的 Point 类重载了 `+` 操作符。
- en: The last thing we do is construct the resulting point by dividing each of the
    projections of vtx_sum by vtx_count ➌.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后做的事是通过将 `vtx_sum` 的每个投影除以 `vtx_count` 来构造结果点 ➌。
- en: '**Testing the Centroid**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试质心**'
- en: Let’s write a unit test to make sure the centroid is properly computed. In your
    file *polygon_test.py* enter the code in [Listing 6-6](ch06.xhtml#ch6lis6).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个单元测试，确保质心被正确计算。在你的文件 *polygon_test.py* 中，输入[列表 6-6](ch06.xhtml#ch6lis6)中的代码。
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-6: Testing the centroid center of a polygon*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：测试多边形的质心中心*'
- en: 'Using [Equation 6.1](ch06.xhtml#ch06eqa01), we can calculate the centroid by
    hand to see where the projections in (10, 10) come from. Knowing that the vertices
    of our polygon test subject are (0, 0), (30, 0), and (0, 30), we have this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[方程 6.1](ch06.xhtml#ch06eqa01)，我们可以手动计算质心，以查看 (10, 10) 中的投影是如何得到的。知道我们的测试多边形的顶点是
    (0, 0)，(30, 0) 和 (0, 30)，我们得到：
- en: '![Image](../images/f0138-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0138-01.jpg)'
- en: You can inspect this visually in [Figure 6-3](ch06.xhtml#ch6fig3).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 6-3](ch06.xhtml#ch6fig3)中直观地查看这个内容。
- en: '![Image](../images/06fig03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig03.jpg)'
- en: '*Figure 6-3: The test polygon’s centroid*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：测试多边形的质心*'
- en: 'Run all tests in file *polygon_test.py* to make sure everything is working
    as expected. To run them from the shell, you can use the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件 *polygon_test.py* 中的所有测试，确保一切按预期工作。你可以在终端中使用以下命令来运行它们：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If both tests pass, you should get the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个测试都通过，你应该会看到以下输出：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s try one thing before moving on. Remember that to compute the centroid
    we reduced the list of vertices like so,
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们先做一件事。记住，为了计算质心，我们将顶点列表简化成如下形式，
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We said that this reduction using the operator.add works because our Point
    class overloads the + operator? Let’s see what would have happened if we hadn’t
    overloaded this operator. Open *point.py* and comment out the __add__ method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，使用 `operator.add` 进行的这种归约工作是因为我们的 Point 类重载了 `+` 操作符？让我们看看如果没有重载这个操作符会发生什么。打开
    *point.py*，并注释掉 `__add__` 方法：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the tests again. This time you’ll see an error in the shell:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。这一次你会在终端看到一个错误：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The TypeError with its message (unsupported operand type(s)...) is very descriptive
    about what the error is. Two Point instances cannot be added if they don’t implement
    the __add__ method. Uncomment the __add__ method we commented for the experiment
    and rerun the tests just to make sure it’s all back to how it was.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有消息（不支持的操作数类型...）的 `TypeError` 对错误描述非常清楚。如果两个 Point 实例没有实现 `__add__` 方法，它们不能相加。取消注释我们为实验注释掉的
    `__add__` 方法，然后重新运行测试，确保一切恢复如初。
- en: '***Contains Point***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包含 Point***'
- en: 'Now comes an interesting problem: How do we determine whether a given point
    is inside a polygon? A widely used procedure is the *ray casting algorithm*, which
    counts how many sides of the polygon are intersected by a ray going through the
    point in any direction. An even number of intersections (including zero) means
    the point is outside of the polygon, whereas an odd number means the point is
    inside. Take a look at [Figure 6-4](ch06.xhtml#ch6fig4).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了一个有趣的问题：我们如何确定一个给定的点是否在多边形内部？一种广泛使用的程序是 *射线投射算法*，它计算从点出发的射线在任何方向上与多边形的几条边交叉的次数。交点数为偶数（包括零）意味着点在多边形外部，而交点数为奇数则意味着点在内部。看看
    [图 6-4](ch06.xhtml#ch6fig4)。
- en: The drawing on the left depicts a complex polygon and a point *P* outside of
    it. Every ray cast from that point in any direction intersects zero or an even
    number of sides. The case on the right depicts the point *P* inside the polygon.
    This time, the ray always intersects an odd number of sides.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图展示了一个复杂的多边形和位于外部的点 *P*。从该点发出的每条射线在任何方向上都与零条或偶数条边相交。右侧的案例展示了点 *P* 在多边形内部。这时，射线始终与奇数条边相交。
- en: '![Image](../images/06fig04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig04.jpg)'
- en: '*Figure 6-4: The ray casting algorithm*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：射线投射算法*'
- en: 'Another commonly used algorithm, and the one we’ll be using, is the *winding
    number algorithm*. This algorithm works by summing angles between vectors that
    go from the point under test to the vertices of the polygon. This is how it works.
    To know whether a point *P* is inside a polygon with vertices *V*[1], *V*[2],
    …, *V*[*n*], our algorithm looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的算法，也是我们将使用的算法，是 *绕数算法*。这个算法通过对从待测点到多边形顶点的向量之间的角度求和来工作。它的工作方式是这样的：要知道一个点
    *P* 是否在具有顶点 *V*[1]、*V*[2]、…、*V*[*n*] 的多边形内部，我们的算法如下：
- en: 'Create a vector going from *P* to each of the vertices:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 *P* 到每个顶点的向量：
- en: '![Image](../images/f00140-p1.jpg): Vector from *P* to vertex *V*[1]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Image](../images/f00140-p1.jpg)：从 *P* 到顶点 *V*[1] 的向量'
- en: '![Image](../images/f00140-p2.jpg): Vector from *P* to vertex *V*[2]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Image](../images/f00140-p2.jpg)：从 *P* 到顶点 *V*[2] 的向量'
- en: . . .
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: . . .
- en: '![Image](../images/f00140-p3.jpg): Vector from *P* to vertex *V*[*n*]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Image](../images/f00140-p3.jpg)：从 *P* 到顶点 *V*[*n*] 的向量'
- en: 'Compute the angle from each vector ![Image](../images/rivictorit.jpg) to the
    next ![Image](../images/riplus1victorit.jpg), wrapping around and computing the
    angle between the last vector and the first:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个向量 ![Image](../images/rivictorit.jpg) 到下一个向量 ![Image](../images/riplus1victorit.jpg)
    的角度，绕回并计算最后一个向量与第一个向量之间的角度：
- en: '![Image](../images/f00140-p4.jpg): Angle from ![Image](../images/r1victorit.jpg)
    to ![Image](../images/r2victorit.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f00140-p4.jpg)：从 ![Image](../images/r1victorit.jpg) 到 ![Image](../images/r2victorit.jpg)
    的角度'
- en: '![Image](../images/f00140-p5.jpg): Angle from ![Image](../images/r2victorit.jpg)
    to ![Image](../images/r3victorit.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f00140-p5.jpg)：从 ![Image](../images/r2victorit.jpg) 到 ![Image](../images/r3victorit.jpg)
    的角度'
- en: . . .
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: . . .
- en: '![Image](../images/f00140-p6.jpg): Angle from ![Image](../images/rnvictorit.jpg)
    to ![Image](../images/r1victorit.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f00140-p6.jpg)：从 ![Image](../images/rnvictorit.jpg) 到 ![Image](../images/r1victorit.jpg)
    的角度'
- en: Sum all angles computed in the previous step.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在前一步计算的所有角度相加。
- en: The point *P* is inside the polygon if the angle is 2*π*, outside if 0.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果角度为 2*π*，则点 *P* 在多边形内部；如果为 0，则在外部。
- en: Take a look at [Figure 6-5](ch06.xhtml#ch6fig5) to better understand how this
    algorithm works. It’s easy to see how the sum of angles is 2*π* in the case where
    the point is inside the polygon.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [图 6-5](ch06.xhtml#ch6fig5)，更好地理解这个算法是如何工作的。当点在多边形内部时，可以很容易看出角度之和是 2*π*。
- en: 'Although we could just as well implement the *ray casting algorithm*, I chose
    the *winding number algorithm* because it makes good use of three key functions
    we’ve created in this book: the make_vector_between factory function, make_round_pairs,
    and the angle_to method from the Vector class. Let’s implement it.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们也可以实现 *射线投射算法*，但我选择了 *绕数算法*，因为它很好地利用了我们在本书中创建的三个关键函数：make_vector_between
    工厂函数、make_round_pairs 和 Vector 类中的 angle_to 方法。让我们来实现它。
- en: '![Image](../images/06fig05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig05.jpg)'
- en: '*Figure 6-5: Testing whether a polygon contains a point*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：测试一个多边形是否包含一个点*'
- en: '**Implementing the Winding Number Algorithm**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现绕数算法**'
- en: 'There are a few modules we need to import. Your imports at the top of file
    *polygon.py* should look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入几个模块。你在文件顶部导入的内容应该像这样：*polygon.py*：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once you’ve imported everything, enter the code in [Listing 6-7](ch06.xhtml#ch6lis7)
    as a new method for the Polygon class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了所有内容，输入代码 [列表 6-7](ch06.xhtml#ch6lis7)，作为 Polygon 类的一个新方法。
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-7: Polygon contains_point algorithm*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-7：Polygon contains_point 算法*'
- en: We first compute the list of ![Image](../images/rvictorit.jpg) vectors ➊ using
    a list comprehension, which maps each of the vertices of the polygon into a vector
    going from point to the vertex. Then, using make_round_pairs, we pair the vectors
    and store the result in paired_vecs ➋.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过列表推导式计算出向量列表 ➊，它将多边形的每个顶点映射为一个从点到顶点的向量。然后，使用 make_round_pairs，我们将向量配对并将结果存储在
    paired_vecs ➋ 中。
- en: We map paired vectors to the angle each pair forms using another list comprehension
    ➍. We reduce the resulting list by adding together each of the computed angles
    ➌, and finally, we check whether the computed angle sum (angle_sum) is close enough
    to 2*π* ➎, in which case the point is inside the polygon. We’ll consider any other
    value of the angle to mean the point is outside the polygon.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个列表推导式将成对的向量映射到它们所形成的角度 ➍。然后我们通过将计算出的每个角度 ➌ 相加来简化结果列表，最后我们检查计算出的角度总和（angle_sum）是否足够接近
    2*π* ➎，如果是，则该点在多边形内。我们认为角度的其他任何值都表示该点在多边形外。
- en: '**Testing contains_point**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试 contains_point**'
- en: Let’s make sure this algorithm works by adding two unit tests in file *polygon_test.py*
    (see [Listing 6-8](ch06.xhtml#ch6lis8)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在文件 *polygon_test.py* 中添加两个单元测试来确保这个算法能正常工作（见 [列表 6-8](ch06.xhtml#ch6lis8)）。
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-8: Testing whether the polygon contains point*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-8：测试多边形是否包含某点*'
- en: 'You can run the tests using the green play button in the IDE or from the shell:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 IDE 中的绿色播放按钮或从终端运行测试：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first test, we take a point we know is outside the triangular polygon
    and assert that it’s actually outside. The second test asserts the point (15,
    10) is inside the triangle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们选择一个已知在三角形外的点，并验证它实际上在外面。第二个测试验证点 (15, 10) 在三角形内。
- en: '**Testing an Edge Case**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试边缘情况**'
- en: Let’s try one more test, just to see what happens. What about vertices of the
    polygon? Are they considered to be inside or outside the polygon? This is what
    we know as an *edge case*, a situation that requires special treatment in our
    code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个测试，看看会发生什么。那多边形的顶点呢？它们被认为在多边形内还是外？这是我们所说的 *边缘情况*，这种情况需要在代码中进行特殊处理。
- en: Enter the innocent-looking test in [Listing 6-9](ch06.xhtml#ch6lis9) and run
    all the tests in file *rect_test.py*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输入看似无害的测试代码 [列表 6-9](ch06.xhtml#ch6lis9)，并运行文件 *rect_test.py* 中的所有测试。
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-9: Proposed test of whether a polygon contains one of its vertices*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-9：测试多边形是否包含其一个顶点*'
- en: 'The output from running the test is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后的输出如下：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Oops! We must have done something wrong. Can you guess what by reading the
    traceback? Starting from the last line we find the originator: ZeroDivisionError.
    Apparently we attempted to divide by zero in method angle_value_to. To be specific,
    we did so in this line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们肯定做错了什么。你能通过阅读堆栈跟踪猜出是什么吗？从最后一行开始，我们找到了源头：ZeroDivisionError。显然我们在 angle_value_to
    方法中尝试了除以零。具体来说，我们在这一行做了除法：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This means norm_product was zero; hence, the norm of at least one of the vectors
    used to compute the angle had a length of 0\. Going a bit up in the traceback
    we find the line where the angle method was being used before the error happened:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 norm_product 为零；因此，用来计算角度的至少一个向量的模长为 0。往上查看堆栈跟踪，我们找到了出错前使用角度方法的代码行：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, it appears that when we attempted to compute the angle between two of the
    vectors, one of them had a length of 0\. The vector going from point *P*, this
    time a vertex of the polygon, to itself is obviously a zero vector.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看来当我们尝试计算两个向量之间的角度时，其中一个向量的长度为 0。这个从点 *P*（这次是多边形的一个顶点）到它自身的向量显然是一个零向量。
- en: To handle this particular edge case, we can consider vertices to be inside the
    polygon as a convention. At the beginning of method contains_point, let’s check
    whether the point passed as an argument is a vertex of the polygon, in which case
    we simply return True. Modify the method to accommodate this new condition ([Listing
    6-10](ch06.xhtml#ch6lis10)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个特殊的边缘情况，我们可以将顶点视为在多边形内作为一种约定。在 contains_point 方法的开始部分，我们检查传入的点是否为多边形的一个顶点，如果是，则直接返回
    True。修改该方法以适应这个新条件（见 [列表 6-10](ch06.xhtml#ch6lis10)）。
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-10: Corrected algorithm to check whether a point is inside a polygon*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-10：修正后的算法，检查点是否在多边形内*'
- en: 'As you see, dealing with edge cases requires individualized pieces of code.
    Run all the tests to make sure they all succeed now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，处理边界情况需要一些个性化的代码块。现在，运行所有测试，确保它们都成功：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output this time should be as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此次输出应如下所示：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***Polygon Factory***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多边形工厂***'
- en: In practice, we commonly need to construct polygons from a list of numbers representing
    the coordinates of its vertices. This is done, for example, when reading a polygon
    from a text file, which we’ll see in [Chapter 12](ch12.xhtml#ch12). To do this,
    we first need to pair up the numbers and map them into instances of Point.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们通常需要根据一个包含顶点坐标的数字列表来构建多边形。例如，在从文本文件读取多边形时我们就会用到这种方式，稍后我们将在[第 12 章](ch12.xhtml#ch12)看到。在做这件事之前，我们首先需要将这些数字配对，并将它们映射为
    Point 类的实例。
- en: For instance, the list
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，列表
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'could be used to define the three vertices of a triangle:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于定义一个三角形的三个顶点：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s implement a factory function to create polygons given a sequence of floating-point
    numbers. Create a new file named *polygons.py*. Our project’s structure currently
    looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个工厂函数，根据一系列浮动点数来创建多边形。创建一个名为 *polygons.py* 的新文件。我们项目的结构目前如下所示：
- en: Mechanics
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 机械学
- en: '|- geom2d'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- __init__.py'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- line.py'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- line.py'
- en: '|    |- line_test.py'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- line_test.py'
- en: '|    |- nums.py'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- nums.py'
- en: '|    |- point.py'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point.py'
- en: '|    |- point_test.py'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point_test.py'
- en: '|    |- polygon.py'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- polygon.py'
- en: '|    |- polygon_test.py'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- polygon_test.py'
- en: '|    |- polygons.py'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- polygons.py'
- en: '|    |- segment.py'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- segment.py'
- en: '|    |- segment_test.py'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- segment_test.py'
- en: '|    |- vector.py'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector.py'
- en: '|    |- vector_test.py'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector_test.py'
- en: '|    |- vectors.py'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vectors.py'
- en: '|- utils'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|- utils'
- en: '|    |- __init__.py'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- pairs.py'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- pairs.py'
- en: Inside the new file, enter the code in [Listing 6-11](ch06.xhtml#ch6lis11).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在新文件中，输入代码内容，见[清单 6-11](ch06.xhtml#ch6lis11)。
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-11: Polygon factory function*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：多边形工厂函数*'
- en: The function make_polygon_from_coords takes in a list of coordinates and first
    checks that there are an even number of them (otherwise, they can’t be paired
    up). If the length of the list of coordinates is divisible by 2 with a remainder
    of 0, we have an even number of coordinates.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 make_polygon_from_coords 接受一个坐标列表，并首先检查其是否包含偶数个坐标（否则无法配对）。如果坐标列表的长度除以 2 没有余数，我们就得到了偶数个坐标。
- en: If the number of coordinates is found to be uneven, we raise a ValueError. If
    not, we then construct a list of the indices at which we’ll find the x-coordinate
    of the vertices in the coords list. We achieve this with a range going from 0
    to len(coords) (noninclusive) with a step of 2.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现坐标的数量不均匀，我们将抛出一个 ValueError。如果数量均匀，我们接着构建一个包含索引的列表，在这些索引位置我们将在 coords 列表中找到顶点的
    x 坐标。我们通过一个从 0 到 len(coords)（不包括上限）的步长为 2 的范围来实现这一点。
- en: 'To better understand how we’re doing this, try the following in Python’s shell:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们是如何做到这一点的，请在 Python 的 shell 中尝试以下操作：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With these indices we can easily obtain a list of vertices using a list comprehension.
    Recall that Python’s range function returns a half-open interval that doesn’t
    include the upper bound, which is why we didn’t get the number 10 in the resulting
    list. The list comprehension maps each index to an instance of Point class. We
    create the polygon passing this list to its constructor. As you can see from the
    code, the x-coordinate is the number from the input list at each index i, whereas
    the y-coordinate is the number to the right of it, that is, i + 1.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些索引，我们可以通过列表推导式轻松地获得顶点的列表。回想一下，Python 的 range 函数返回的是一个半开区间，不包含上限，这就是为什么我们在结果列表中没有得到数字
    10 的原因。列表推导式将每个索引映射为一个 Point 类的实例。我们通过将这个列表传递给多边形的构造函数来创建多边形。正如你从代码中看到的，x 坐标是输入列表中每个索引
    i 处的数字，而 y 坐标则是它右边的数字，也就是 i + 1。
- en: With that out of the way, let’s take a look at how to compare polygons for equality.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这些后，让我们看看如何比较多边形的相等性。
- en: '***Polygon Equality***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多边形相等性***'
- en: To make sure we can check whether polygons are equal, let’s implement the __eq__
    method inside the Polygon class (see [Listing 6-12](ch06.xhtml#ch6lis12)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们可以检查多边形是否相等，接下来在 Polygon 类中实现 __eq__ 方法（参见[清单 6-12](ch06.xhtml#ch6lis12)）。
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 6-12: Polygon equality*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-12：多边形相等性*'
- en: We first check whether the passed-in other is the same instance as self, in
    which case we return True. Second, if other is not an instance of Polygon, there’s
    not much we can compare; we already know the equality is impossible.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查传入的 other 是否与 self 为同一个实例，如果是，返回 True。其次，如果 other 不是 Polygon 的实例，我们就没有太多可以比较的地方；我们已经知道它们不可能相等。
- en: 'Since Point already implements the __eq__ method, we just need to compare the
    list of vertices from both polygons if the two previous checks haven’t returned
    anything yet. Python will check whether both lists contain the same vertices in
    the same order. Lists are ordered collections; thus, ordering is important when
    checking for equality. Try the following experiment in the shell:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Point 已经实现了 __eq__ 方法，我们只需要比较两个多边形的顶点列表，前提是之前的两个检查都没有返回结果。Python 将检查两个列表是否包含相同的顶点，并且顺序相同。列表是有序集合，因此在检查相等性时，顺序非常重要。尝试在
    shell 中进行以下实验：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Even though l1 and l2 contain the same numbers, they are considered different
    by Python as they appear in a different order (don’t forget that order matters
    for lists and tuples). By contrast, l2 and l3 do contain the numbers in the same
    order and hence are considered equal. Polygons are made of an ordered collection
    of vertices: different orderings of the same set of vertices would result in unequal
    polygons. This is the reason why we used a list, which is a collection where the
    order is a key factor.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 l1 和 l2 包含相同的数字，Python 也认为它们是不同的，因为它们的顺序不同（别忘了，对于列表和元组，顺序很重要）。相反，l2 和 l3
    的顺序相同，因此被认为是相等的。多边形由一组有序的顶点组成：相同顶点集的不同排列将导致不同的多边形。这就是为什么我们使用列表作为集合，因为在列表中顺序是关键因素。
- en: If you followed along, your *polygon.py* file should look like [Listing 6-13](ch06.xhtml#ch6lis13).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随操作，你的 *polygon.py* 文件应该像 [列表 6-13](ch06.xhtml#ch6lis13) 中那样。
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 6-13: Polygon class*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-13：多边形类*'
- en: Now let’s take a look at circles.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下圆形。
- en: '**Circle Class**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**圆形类**'
- en: A *circle* is the set of all points in the plane a given distance (the *radius*)
    from a single point called the *center*. A circle is therefore defined by the
    position of its center *C* and the value of its radius *r* (see [Figure 6-6](ch06.xhtml#ch6fig6)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*圆形*是平面上距离一个固定点（称为 *中心*）给定距离（即 *半径*）的所有点的集合。因此，圆形由其中心 *C* 的位置和半径 *r* 的值定义（见
    [图 6-6](ch06.xhtml#ch6fig6)）。'
- en: '![Image](../images/06fig06.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig06.jpg)'
- en: '*Figure 6-6: A circle defined by a center point *C* and radius *r**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：一个由中心点 *C* 和半径 *r* 定义的圆形*'
- en: 'As you may remember from high school, the area of a circle is calculated as
    follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能还记得的那样，圆形的面积计算公式如下：
- en: '*A = π ⋅ r*²'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*A = π ⋅ r*²'
- en: 'And a circle’s circumference is calculated as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个圆的周长计算公式如下：
- en: '*l*[c] = 2π ⋅ *r*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*l*[c] = 2π ⋅ *r*'
- en: Create a new file named *circle.py* in the package *geom2d*. In the file, enter
    the code in [Listing 6-14](ch06.xhtml#ch6lis14).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *geom2d* 包中创建一个名为 *circle.py* 的新文件。在文件中输入 [列表 6-14](ch06.xhtml#ch6lis14) 中的代码。
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 6-14: Circle class initialization*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-14：圆形类初始化*'
- en: Great! We now have a class to represent circles with the properties center and
    radius. We’ve also defined properties named area and circumference.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有了一个表示圆形的类，它具有中心和半径这两个属性。我们还定义了名为面积（area）和周长（circumference）的属性。
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To keep the length of the chapter reasonable, we won’t include any more unit
    testing sections. The accompanying code does include unit tests, and I encourage
    you to come up with them yourself.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了保持章节长度的合理性，我们将不再包括更多的单元测试部分。附带的代码确实包含了单元测试，我鼓励你自己动手编写它们。*'
- en: '***Contains Point***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包含点***'
- en: 'Testing whether a point *P* was inside a generic polygon required a few steps,
    but in the case of a circle, the logic is extremely simple. We compute the distance
    from the center *C* to point *P*: *d*(*C,P*). If this distance is smaller than
    the radius, *d*(*C,P*) < *r*, the point is inside the circle. For values of *d*(*C,P*)
    greater than *r*, the point is farther from the center than the radius and thus
    outside the circle. Inside Circle, enter the code in [Listing 6-15](ch06.xhtml#ch6lis15).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个点 *P* 是否在一个通用多边形内部需要一些步骤，但在圆形的情况下，逻辑非常简单。我们计算从中心 *C* 到点 *P* 的距离：*d*(*C,P*)。如果这个距离小于半径，即
    *d*(*C,P*) < *r*，那么该点在圆内。如果 *d*(*C,P*) 大于 *r*，则该点距离中心比半径远，因此在圆外。进入 Circle 类，在
    [列表 6-15](ch06.xhtml#ch6lis15) 中输入代码。
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 6-15: Checking whether a circle contains a point*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-15：检查一个圆形是否包含某个点*'
- en: Can you come up with test cases to ensure method contains_point is bug free?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出一些测试用例来确保 `contains_point` 方法没有 bug 吗？
- en: '***Circle to Polygon***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从圆形到多边形***'
- en: In [Chapter 7](ch07.xhtml#ch07) we’ll be transforming a polygon’s geometry by
    rotating, scaling, and skewing it. After such transformations, circles may not
    be circles anymore, and the mathematical representation for the result can become
    complex.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](ch07.xhtml#ch07)中，我们将通过旋转、缩放和倾斜来变换多边形的几何形状。经过这些变换后，圆形可能不再是圆形，结果的数学表示可能会变得复杂。
- en: Because accounting for all possible shapes using a specific geometry class would
    be arduous, and because our generic polygons work the same no matter their shape,
    why not try approximating the circle using a polygon with enough sides?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用特定几何类来处理所有可能的形状会很繁琐，而我们的通用多边形无论形状如何都能正常工作，为什么不尝试用足够边数的多边形来逼近圆形呢？
- en: To convert a circle to a polygon, a number of divisions have to be chosen, say
    *n*. The entire 2*π* angle is divided into *n* subangles *θ* = 2*π*/*n*. Starting
    at angle 0 and incrementing it by *θ* each time, we can compute *n* points in
    the circumference, which will then become the vertices of a polygon inscribed
    in the circle. We can compute a vertex *V* at a given angle *α* using [Equation
    6.2](ch06.xhtml#ch06eqa02),
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要将圆形转换为多边形，需要选择一个划分数，比如 *n*。整个 2*π* 角度被划分为 *n* 个子角度 *θ* = 2*π*/*n*。从角度 0 开始，每次增加
    *θ*，我们可以计算出 *n* 个圆周上的点，这些点将成为内接圆形的多边形的顶点。我们可以使用[方程 6.2](ch06.xhtml#ch06eqa02)计算给定角度
    *α* 的顶点 *V*。
- en: '![Image](../images/06eqa02.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06eqa02.jpg)'
- en: where *C* is the center of the circle and *r* is the radius. [Figure 6-7](ch06.xhtml#ch6fig7)
    shows the result of choosing *n* = 8, which converts the circle into an octagon
    with vertices *V*[1], *V*[2], …, *V*[8].
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *C* 是圆心，*r* 是半径。[图 6-7](ch06.xhtml#ch6fig7) 显示了选择 *n* = 8 的结果，这将圆形转换为一个八边形，顶点为
    *V*[1]、*V*[2]、……、*V*[8]。
- en: '![Image](../images/06fig07.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig07.jpg)'
- en: '*Figure 6-7: Converting a circle to a polygon*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：将圆形转换为多边形*'
- en: Also note how for small numbers of *n* the resulting polygon poorly approximates
    the circle. In [Figure 6-8](ch06.xhtml#ch6fig8), for example, *n* was chosen to
    be 3, 4, and 5, respectively. As you can see, the inscribed polygons only look
    remotely like the circles they approximate. We’ll typically choose *n* values
    ranging from 30 to 200 to yield an acceptable result.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当 *n* 的值较小时，所得的多边形与圆形的近似效果较差。例如，在[图 6-8](ch06.xhtml#ch6fig8)中，*n* 分别选择为
    3、4 和 5。正如你所看到的，内接多边形看起来只和它们所近似的圆形相似。通常我们会选择 *n* 的值在 30 到 200 之间，以得到一个可接受的结果。
- en: '![Image](../images/06fig08.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig08.jpg)'
- en: '*Figure 6-8: Number of divisions when converting a circle to a polygon*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：将圆形转换为多边形时的划分数*'
- en: Inside Circle, implement to_polygon as in [Listing 6-16](ch06.xhtml#ch6lis16).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Circle 类中实现 to_polygon 方法，参考[清单 6-16](ch06.xhtml#ch6lis16)。
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 6-16: Creating a polygon from a circle*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-16：从圆形创建多边形*'
- en: 'This time we divided the algorithm in two: the main logic handled by to_polygon
    and a private method __point_at_angle, which, given an angle, returns the point
    in the circumference at that angle ➌. Such a point is computed according to [Equation
    6.2](ch06.xhtml#ch06eqa02).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将算法分成了两部分：主要逻辑由 to_polygon 方法处理，另一个私有方法 __point_at_angle 用于根据角度返回圆周上的点 ➌。这样的点是根据[方程
    6.2](ch06.xhtml#ch06eqa02)计算的。
- en: The to_polygon method first computes the angle delta (or angle increment) for
    the given number of divisions ➊. Then, using a list comprehension, it maps each
    integer number in the range [0,*n*) to a point in the circumference at incremental
    angles ➋. This list of points is passed as the vertices for the initialization
    of a polygon. Note how we convert the range [0, *n*) into an angle by multiplying
    the current number in the range by the angle increment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: to_polygon 方法首先计算给定划分数 ➊ 的角度增量（或角度增量）。然后，使用列表推导式，它将范围 [0,*n*) 中的每个整数映射到圆周上对应增量角度的位置
    ➋。这个点的列表将作为多边形初始化时的顶点。注意，我们如何通过将当前数字与角度增量相乘，将范围 [0, *n*) 转换为角度。
- en: '***Equality and String Representation***'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***相等性和字符串表示***'
- en: Let’s implement equality comparison and string representation methods in our
    Circle class. Enter the code in [Listing 6-17](ch06.xhtml#ch6lis17).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Circle 类中实现相等性比较和字符串表示方法。请在[清单 6-17](ch06.xhtml#ch6lis17)中输入代码。
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 6-17: Circle equality and string representation*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-17：圆形相等性和字符串表示*'
- en: If you followed along, your *circle.py* file should look like [Listing 6-18](ch06.xhtml#ch6lis18).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟着做的话，你的 *circle.py* 文件应该和[清单 6-18](ch06.xhtml#ch6lis18)一样。
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 6-18: The Circle class*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-18：Circle 类*'
- en: '***Circle Factories***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***圆形工厂***'
- en: 'We’ll typically construct circles from a center point and a radius, but there
    are a few more ways we can construct them. In this section, we’ll look at one
    such case: generating a circle out of three points. We’ll do this mostly for fun,
    but it also gives a sense of how powerful the geometrical primitives we’re building
    are.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常从圆心和半径来构建圆，但也有几种不同的构建方式。在这一节中，我们将探讨其中一种：通过三点生成一个圆。我们这样做主要是为了趣味，但这也能让我们感受到我们正在构建的几何原始体的强大。
- en: So, say we’re given three non-collinear points, namely, *A*, *B*, and *C*. As
    you can see in [Figure 6-9](ch06.xhtml#ch6fig9), you can find a circle such that
    it passes through all three points.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们给定了三个不共线的点，分别是*A*、*B*和*C*。正如你在[图6-9](ch06.xhtml#ch6fig9)中看到的，你可以找到一个通过这三个点的圆。
- en: '![Image](../images/06fig09.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig09.jpg)'
- en: '*Figure 6-9: Defining a circle with three points*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：通过三点定义圆*'
- en: 'To solve the problem, we need to find the center and radius, but the latter
    is straightforward since if we know where the center is, the distance of any of
    the three points to it yields the radius. So, the problem boils down to finding
    the center of a circle passing through the given points. Here’s one way we can
    find it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要找到圆的中心和半径，后者比较简单，因为如果我们知道圆心的位置，任何一个三点到圆心的距离都能得到半径。所以，问题归结为寻找一个通过给定点的圆的圆心。我们可以通过以下方式来找到它：
- en: Compute the segment going from *A* to *B*; let’s call it *seg*[1].
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从*A*到*B*的线段，我们称之为*seg*[1]。
- en: Compute the segment going from *B* to *C*; let’s call it *seg*[2].
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从*B*到*C*的线段，我们称之为*seg*[2]。
- en: Find the intersection between bisectors of *seg*[1] and *seg*[2].
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到*seg*[1]和*seg*[2]的角平分线的交点。
- en: The intersection point *O* is the center of the circle (see [Figure 6-10](ch06.xhtml#ch6fig10)).
    And, as previously stated, finding the radius of the circle is as simple as measuring
    the distance between *O* and *A*, *B*, or *C*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 交点*O*是圆的中心（见[图6-10](ch06.xhtml#ch6fig10)）。如前所述，求圆的半径非常简单，只需测量*O*与*A*、*B*或*C*之间的距离即可。
- en: '![Image](../images/06fig10.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig10.jpg)'
- en: '*Figure 6-10: The center and radius of a circle defined by three points*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：通过三点定义的圆的圆心和半径*'
- en: We’re ready to implement the logic. Create a new file in the *geom2d* package
    and name it *circles.py*. In the file, enter the code in [Listing 6-19](ch06.xhtml#ch6lis19).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备实现逻辑了。在*geom2d*包中创建一个新文件，并命名为*circles.py*。在该文件中输入[清单6-19](ch06.xhtml#ch6lis19)中的代码。
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 6-19: Circle from three points*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-19：由三点生成圆*'
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall that the chord of a circle is a segment whose endpoints lie on the
    circumference and cut across the circle.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*回顾一下，圆弦是一个线段，其端点位于圆周上，并穿过圆。*'
- en: If you were asked to simplify the function, could you? Each line tells you exactly
    what it’s doing; you can read the lines one by one and match them with the description
    of the algorithm. Self-explanatory code that clearly states its intent is commonly
    referred to as *clean code*, which is such a celebrated concept in the software
    industry that there are several books devoted to the topic. Two of my all-time
    favorites include [6] and [1], which I recommend you also read if you want to
    write truly readable code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被要求简化这个函数，你能做到吗？每一行代码都清楚地告诉你它在做什么；你可以一行一行地阅读，并将其与算法描述进行匹配。自解释的代码清楚地表达了其意图，这种代码通常被称为*清晰代码*，它在软件行业中是一个备受推崇的概念，甚至有几本书专门讨论这一话题。我最喜欢的两本书包括[6]和[1]，如果你想编写真正易读的代码，我也推荐你阅读它们。
- en: '**Rect Class**'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**矩形类**'
- en: The last geometric primitive we’ll implement in this chapter is a rectangle,
    but it’s not any sort of rectangle—it’s the kind whose sides are always horizontal
    and vertical. Rotated rectangles can be represented using the Polygon primitive
    from earlier in the chapter. The reason behind this seemingly restrictive rule
    has to do with what this primitive is typically used for.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将实现的最后一个几何原始体是矩形，但它不是任何类型的矩形——它是那种边始终水平和垂直的矩形。旋转矩形可以通过本章前面提到的多边形原始体来表示。这个看似限制性的规则背后有其原因，主要与该原始体通常用于什么用途有关。
- en: 'Rectangles like this are often used in two-dimensional graphic applications
    for things like the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种矩形通常用于二维图形应用程序，应用场景包括以下几种：
- en: Representing a portion of the screen that needs to be redrawn
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示屏幕上需要重新绘制的部分
- en: Determining the position on the screen where something needs to be drawn
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定屏幕上需要绘制某物的位置
- en: Determining the size of the geometry that has to be drawn
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定必须绘制的几何形状的大小
- en: Testing whether two objects are likely to collide
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试两个对象是否可能发生碰撞
- en: Testing whether the mouse cursor is over a region of the screen
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试鼠标光标是否位于屏幕的某个区域上
- en: 'A *rectangle* can be defined by a point (called the *origin*) and a size, which
    in turn has two properties: width and height (see [Figure 6-11](ch06.xhtml#ch6fig11)).
    By convention, the origin point will be located at the bottom-left corner of the
    rectangle, assuming a coordinate system with an y-axis that points upward.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*矩形*可以通过一个点（称为*原点*）和一个大小来定义，大小又有两个属性：宽度和高度（见[图 6-11](ch06.xhtml#ch6fig11)）。按照约定，原点位于矩形的左下角，假设坐标系的
    y 轴指向上方。
- en: '![Image](../images/06fig11.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig11.jpg)'
- en: '*Figure 6-11: A rectangle defined by an origin point *O*, width *w*, and height
    *h**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：由原点 *O*、宽度 *w* 和高度 *h* 定义的矩形*'
- en: Let’s start with a class to represent sizes. Inside package *geom2d*, create
    a new file named *size.py* including the definition in [Listing 6-20](ch06.xhtml#ch6lis20).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个类开始，来表示大小。在 *geom2d* 包中，创建一个名为 *size.py* 的新文件，包含[列表 6-20](ch06.xhtml#ch6lis20)中的定义。
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 6-20: The Size class*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-20：Size 类*'
- en: Using this representation of a size, let’s create the initial definition of
    Rect. Create a new file named *rect.py* and enter the code in [Listing 6-21](ch06.xhtml#ch6lis21).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种大小的表示法，让我们来创建 Rect 的初始定义。创建一个名为 *rect.py* 的新文件，并输入[列表 6-21](ch06.xhtml#ch6lis21)中的代码。
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 6-21: The Rect class*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-21：Rect 类*'
- en: 'The class stores a Point instance for the origin point and a Size instance
    encoding its width and length. We defined some interesting properties in the class,
    namely:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 该类存储了一个 Point 实例表示原点，以及一个 Size 实例表示它的宽度和长度。我们在类中定义了一些有趣的属性，即：
- en: left    The x-coordinate of the left-most side of the rectangle
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: left    矩形最左边的 x 坐标
- en: right    The x-coordinate of the right-most side of the rectangle
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: right    矩形最右边的 x 坐标
- en: bottom    The y-coordinate of the bottom-most side of the rectangle
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: bottom    矩形最底部边缘的 y 坐标
- en: top    The y-coordinate of the top-most side of the rectangle
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: top    矩形最顶部边缘的 y 坐标
- en: area    The area of the rectangle
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: area    矩形的面积
- en: perimeter    The perimeter of the rectangle
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: perimeter    矩形的周长
- en: 'Let’s create one of our rectangles in the shell:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 shell 中创建一个矩形：
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And let’s inspect some of its properties:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下它的一些属性：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***Contains Point***'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包含点***'
- en: 'The next logical step is implementing a method to test whether a point is inside
    the rectangle. To test whether a point *P* lies inside a rectangle, we’ll use
    the following two conditions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是实现一个方法来测试一个点是否在矩形内。为了测试一个点 *P* 是否位于矩形内部，我们将使用以下两个条件：
- en: '![Image](../images/f00158-p1.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00158-p1.jpg)'
- en: Thanks to the attributes we added to the class, this is a piece of cake (see
    [Listing 6-22](ch06.xhtml#ch6lis22)).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们为类添加的属性，这变得轻而易举（见[列表 6-22](ch06.xhtml#ch6lis22)）。
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 6-22: Testing whether a rectangle contains a point*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-22：测试矩形是否包含一个点*'
- en: Notice Python’s beautiful syntax for compound inequalities,
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Python 中复合不等式的优美语法，
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'which in most other languages would have to be expressed as two different conditions:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 而在其他大多数编程语言中，这通常需要用两个不同的条件来表示：
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***Intersections***'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交集***'
- en: Suppose we have two rectangles and we want to know if they overlap. Since Rect
    represents rectangles with sides that are always horizontal and vertical, the
    problem simplifies a lot. Testing whether two Rects overlap is the same as testing
    whether their projections in both the x- and y-axes overlap. By *projections*,
    we mean the shadows they cast on the axis lines. Each shadow is an interval starting
    in the position of the value of the rectangle’s origin, with a length that’s either
    its width or its height (see [Figure 6-12](ch06.xhtml#ch6fig12)).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个矩形，并且我们想知道它们是否重叠。由于 Rect 表示的矩形边缘始终是水平和垂直的，因此这个问题简化了很多。测试两个矩形是否重叠，实际上就是测试它们在
    x 轴和 y 轴上的投影是否重叠。我们所说的*投影*，是指它们在轴线上的阴影。每个阴影是一个区间，从矩形原点的值所在的位置开始，长度要么是它的宽度，要么是它的高度（见[图
    6-12](ch06.xhtml#ch6fig12)）。
- en: '![Image](../images/06fig12.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig12.jpg)'
- en: '*Figure 6-12: Projections of a rectangle*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：矩形的投影*'
- en: For example, the shadow in the horizontal axis of [Figure 6-12](ch06.xhtml#ch6fig12)
    can be represented as the following interval,
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图 6-12](ch06.xhtml#ch6fig12) 中的水平轴阴影可以表示为以下区间，
- en: (*O*[x], *O*[x] + *w*)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: (*O*[x]，*O*[x] + *w*)
- en: 'where *O* is the origin point and *w* is the width of the rectangle. Similarly,
    the vertical shadow or projection would be:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: (*O*[y], *O*[y] + *h*)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: where *h* is the height this time. Note that the result of *O*[*x*] + *w* is
    exactly the right property as we’ve defined it in our Rect class, and *O*[*y*]
    + *h* is top.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-13](ch06.xhtml#ch6fig13) depicts two rectangles whose vertical projections
    overlap but whose horizontal projections don’t. Thus, the rectangles don’t overlap.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig13.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: Two nonintersecting rectangles*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-14](ch06.xhtml#ch6fig14), on the other hand, depicts two rectangles
    with vertical and horizontal projections that overlap. As you can see, this layout
    does generate an overlapping region, shaded in gray. We can observe that overlapping
    rectangles always result in rectangular overlapping regions.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig14.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: Two intersecting rectangles*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Using the nomenclature from the previous figures, we can numerically define
    the condition using *open intervals*, intervals where the end points are excluded.
    Two rectangles overlap if
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0160-01.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: where ∩ is the intersection binary operator.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Intervals**'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that we’ve reduced the problem to computing the intersection between intervals,
    let’s create a new class OpenInterval to implement this logic. Note that writing
    the implementation of the algorithm to find the intersection between two intervals
    inside the Rect class would be conceptually wrong. Each class must only contain
    logic related to its domain of knowledge, and it seems obvious that interval intersection
    is not specifically about rectangles. A rectangle should know nothing about how
    the intersection of two intervals is performed; it’s not part of its domain of
    knowledge. If it needs to compute one, like in our case, it should delegate it
    to the subject’s expert: OpenRange.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If you respect this simple guideline, your code will be much easier to reason
    about and extend. Every piece of knowledge in your code should live exactly where
    it’s supposed to, and only there. One of the worst enemies of software is *knowledge
    duplication*, a phenomenon where one piece of knowledge (call it an algorithm
    if you prefer) is written in more than one place. When the core of such logic
    needs to change, you need to remember to change it everywhere. Trust me when I
    say this problem is much worse than it sounds.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '*Most authors use the phrase* duplication of code*, but I prefer to call it*
    duplication of knowledge*. The choice of words is intentional as I’ve noticed
    some developers tend to misinterpret the concept, probably because the word* code
    *is quite generic. It’s the knowledge expressed by the code that should not be
    duplicated.*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named *open_interval.py* in *geom2d*, and inside, define the
    OpenInterval class as in [Listing 6-23](ch06.xhtml#ch6lis23).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 6-23: The OpenInterval class*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: An OpenInterval is created with start and end properties. We make sure that
    start is smaller than end; otherwise, we raise a ValueError exception. Recall
    our failing fast convention; we don’t want an ill-constructed interval lying around.
    Next, we define the length of the interval as a property ➊ and a method to test
    whether a given value is inside the range ➋.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenInterval` 是通过起始和结束属性创建的。我们确保起始值小于结束值；否则，我们会引发一个 `ValueError` 异常。回想一下我们的快速失败约定；我们不希望有构造不当的区间存在。接下来，我们将区间的长度定义为一个属性
    ➊，并定义一个方法来测试给定的值是否在区间范围内 ➋。'
- en: 'Let’s now include two more methods: one for checking whether intervals overlap
    and another one for actually computing the resulting overlap (see [Listing 6-24](ch06.xhtml#ch6lis24)).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加入另外两种方法：一种用于检查区间是否重叠，另一种用于实际计算重叠的结果（见[清单 6-24](ch06.xhtml#ch6lis24)）。
- en: '[PRE49]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 6-24: Open interval overlapping*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-24: 开区间重叠*'
- en: The first method, overlaps_interval, returns a boolean that will be True if
    the interval overlaps with other passed as an argument. To do this, we first check
    whether the two intervals have the same start and end values ➊, in which case
    we return True. Then we check whether any of the four ends is contained in the
    other interval ➋. If you’re confused by this piece of logic, take a pen and some
    paper and draw every possible combination of two overlapping intervals (I’ve done
    this for you in [Figure 6-15](ch06.xhtml#ch6fig15), excluding the case where the
    two intervals have the same start and end values).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法 `overlaps_interval` 返回一个布尔值，如果区间与传入的另一个区间重叠，则返回 True。为此，我们首先检查两个区间的起始和结束值是否相同
    ➊，如果相同则返回 True。然后检查四个端点是否有一个包含在另一个区间内 ➋。如果你对这段逻辑感到困惑，可以拿一支笔和一些纸，画出所有可能的两个重叠区间的组合（我已经为你在[图
    6-15](ch06.xhtml#ch6fig15)中画出了这些组合，排除了两个区间的起始和结束值相同的情况）。
- en: '![Image](../images/06fig15.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig15.jpg)'
- en: '*Figure 6-15: The possible cases for interval positions*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15: 区间位置的可能情况*'
- en: The second method, compute_overlap_with, starts by making sure there’s actually
    an overlap, returning None if there isn’t ➌. The overlap is simply a new interval
    where the start is the maximum between both start values, and the end is the minimum
    between the two end values ➍.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 `compute_overlap_with` 开始时会确保实际上存在重叠，如果没有重叠则返回 None ➌。重叠部分是一个新的区间，起始值为两个起始值中的最大值，结束值为两个结束值中的最小值
    ➍。
- en: I encourage you to write unit tests for this overlapping logic. It’s a wonderful
    opportunity to develop your testing skills. There are a bunch of combinations
    of overlapping intervals; try to cover them all.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你为这个重叠逻辑编写单元测试。这是一个极好的机会来提升你的测试技能。重叠区间有很多组合，尽量覆盖所有情况。
- en: '**Computing Intersections**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算交集**'
- en: 'With the help of OpenInterval, rectangle intersections become simple to solve.
    Go back to *rect.py* and import the OpenInterval class:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OpenInterval` 的帮助下，矩形交集问题变得容易解决。返回到 *rect.py*，并导入 `OpenInterval` 类：
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, underneath the contains_point method, enter the code from [Listing 6-25](ch06.xhtml#ch6lis25).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `contains_point` 方法下面，输入[清单 6-25](ch06.xhtml#ch6lis25)中的代码。
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 6-25: Intersection between two rectangles*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-25: 两个矩形的交集*'
- en: 'There are two private helper methods that compute both the horizontal and vertical
    overlaps; we’ll take a look at those in a moment. The method first computes the
    horizontal overlap between self and other ➊. If it finds it to be None, there’s
    no horizontal overlap; therefore, the rectangles don’t intersect. None is returned.
    The same procedure goes for the vertical overlap ➋. Only if both are not None,
    which means we found both horizontal and vertical projections overlapping, will
    we reach the last return where the resulting rectangle is computed ➌. How do we
    go about finding the origin and size of such a rectangle? It’s easy: the origin
    coordinates are the start values from both horizontal and vertical overlap intervals,
    the width is the length of the horizontal overlap, and the height is the length
    of the vertical overlap.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个私有的辅助方法计算水平和垂直重叠；我们稍后会详细了解这两个方法。方法首先计算 `self` 和 `other` 之间的水平重叠 ➊。如果发现没有重叠，则返回
    None，意味着矩形没有交集。垂直重叠也采用相同的步骤 ➋。只有当两个重叠都不为 None 时，即水平和垂直投影都重叠，我们才会进入最后的返回步骤，其中计算结果矩形
    ➌。我们怎么找到这个矩形的原点和大小呢？很简单：原点坐标是水平和垂直重叠区间的起始值，宽度是水平重叠的长度，高度是垂直重叠的长度。
- en: So, the only missing part is the implementation of the private methods that
    finds the horizontal and vertical interval overlaps, if they exist. The code for
    that is in [Listing 6-26](ch06.xhtml#ch6lis26).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 6-26: Intersection private methods*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at how to build a generic polygon based on the rectangle.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '***Convert to Polygon***'
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with circles, applying an affine transformation to a rectangle may result
    in some nonrectangular shape. In fact, after a generic affine transformation,
    a rectangle gets transformed into a parallelogram, as depicted in [Figure 6-16](ch06.xhtml#ch6fig16),
    and these shapes can’t be described by our Rect class.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig16.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: A rectangle after an affine transformation*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a method to create a polygon from a rectangle is straightforward,
    as the vertices of such polygons are the four corners of the rectangle. In Rect
    class, add the method in [Listing 6-27](ch06.xhtml#ch6lis27). Don’t forget to
    import the Polygon class.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 6-27: Creating a polygon from a rectangle*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, vertices should be given in order, clockwise or counterclockwise,
    but respecting the order nevertheless. It’s really easy to mess up the order of
    vertices and end up with crossing sides. To make sure this never happens, we should
    write a test, which is left for you as an exercise.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '***Equality***'
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re already an expert at implementing __eq__ methods, aren’t you? [Listing
    6-28](ch06.xhtml#ch6lis28) shows the code for it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 6-28: Rectangle equality*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The only thing to note is that we were able to directly compare sizes using
    == because we also implemented __eq__ on class Size.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Note that implementing __\textit{eq}__ in *Rect* like are_close_enough(self.size.width,other.size.width)
    ... would not be ideal. Remember the law of Demeter? That knowledge belongs to
    class *Size* and should be implemented there and only there.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: For reference, [Listing 6-29](ch06.xhtml#ch6lis29) shows how your *rect.py*
    file should look.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 6-29: The Rect implementation*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '***Rectangle Factories***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll often use rectangles to approximate the outside bounds of a set of geometries.
    In future chapters of the book, for example, we’ll be generating diagrams as part
    of the solution for mechanics problems. To fit the diagrams inside an image of
    the right size, we’ll create a rectangle that can contain everything. To do this,
    we’ll create a factory function that returns a rectangle that contains a given
    list of points.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we’re given the list of points [*A, B, C, D, E*], the rectangle
    will look like the left illustration from [Figure 6-17](ch06.xhtml#ch6fig17).
    We’ll also need another factory function that does something similar but also
    adds some margin to the rectangle.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig17.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: A rectangle containing points*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Inside package *geom2d*, create a new file and name it *rects.py*. Add the first
    factory function (in [Listing 6-30](ch06.xhtml#ch6lis30)).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 6-30: Creating a rectangle containing a list of points*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The first step is checking that the list points contains at least one point
    ➊. You may be surprised about the syntax; the trick here is that Python evaluates
    empty lists as False in boolean contexts. In fact, that’s a Pythonic idiom used
    to check whether a list is empty.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to look for the bounds of the rectangle: the minimum and maximum
    x and y projections. Four variables store those values ➋ ➌ initialized with the
    coordinates of the first point in the list. Then we iterate through all points
    except for this first one, as it was already used to initialize the aforementioned
    variables. To avoid passing through the first point, we slice the points list
    starting at index 1 and going all the way to the end of the list: points[1:].
    (You can refer to “Lists” on [page 15](ch01.xhtml#ch00lev2sec15) for a refresher
    on slicing lists.) For each point, the minimum and maximum x ➍ and y ➎ projections
    are compared to the values currently stored.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Once we have these four values, we construct the resulting rectangle ➏ using
    the minimum x and y projections for the origin and the difference between each
    maximum and minimum for the size.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement a similar function with the addition of a margin around
    the points. After make_rect_containing, enter the code in [Listing 6-31](ch06.xhtml#ch6lis31).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 6-31: Creating a rectangle containing a list of points and a given
    margin*'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: This function starts with a rectangle computed by the previous function ➊. The
    new rectangle is then computed by displacing rect’s origin by the width of the
    margin to the left and downward ➋ and increasing the size by two times the width
    of the margin ➌. Recall that the margin is added to the left and to the right,
    which is why we add it twice to the width—the same goes for the height.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last way we may want to build a rectangle: using its center and
    size. The implementation is straightforward, as you can see in [Listing 6-32](#ch6lis32).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 6-32: Creating a rectangle given its center and size*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: With these three factory methods we have convenient ways of creating rectangles.
    We’ll be using these in further chapters, so we want to make sure they yield the
    expected rectangle with some automated unit tests. I’ll leave this as an exercise
    for you. You’ll find the tests I wrote in *rects_test.py* in the source code accompanying
    the book.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We started the chapter implementing a generic polygon, described by a sequence
    of at least three vertices. We wrote an algorithm to pair sequences of objects
    such that the last and first elements are also paired up and used this logic to
    generate the sides of the polygon. We also implemented the winding number algorithm
    to check whether the polygon contains a point.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The second geometric primitive we created in this chapter was the circle. As
    you saw, checking whether a point is inside a circle was much simpler to implement
    than in the case of generic polygons. We came up with a way of constructing a
    generic polygon that approximates the geometry of the circle using a given number
    of divisions or sides. We’ll make use of this method in the next chapter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们创建的第二个几何原始元素是圆形。正如你所看到的，检查一个点是否在圆内比检查它是否在普通多边形内要简单得多。我们想出了一个方法，利用给定的分割数或边数来构造一个逼近圆形几何的通用多边形。我们将在下一章中使用这个方法。
- en: Lastly, we implemented a rectangle. To compute intersection between rectangles,
    we needed a way of figuring out the overlap between two intervals; thus, we created
    an abstraction of an open interval to handle this logic.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个矩形。为了计算矩形之间的交集，我们需要一种方法来确定两个区间之间的重叠；因此，我们创建了一个开放区间的抽象来处理这个逻辑。
- en: Our geometry library is almost complete. We have all the primitives that we
    need for the book; the only thing missing is a way of transforming them, which
    is the topic of the next chapter.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的几何库几乎完成了。我们已经具备了书中所需的所有基本元素；唯一缺少的就是一种变换它们的方法，这也是下一章的主题。
