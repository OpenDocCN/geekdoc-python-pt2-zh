- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: STORING USER INPUT IN A DATABASE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户输入存储在数据库中**
- en: '![Image](../Images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../Images/comm1.jpg)'
- en: Many applications designed for business need to transfer the data they work
    with to a database at some point. For example, a food-ordering chatbot might save
    an order form after filling it out using the information extracted from dialogue
    with a customer. Once the order appears in the database, it becomes available
    for further processing, and the product is eventually shipped to the customer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多为商业设计的应用程序需要在某个时刻将它们处理的数据传输到数据库中。例如，一个食品订购聊天机器人可能在通过与客户的对话提取信息后填写订单表单并保存该表单。一旦订单出现在数据库中，它就可以进行进一步处理，最终产品将被发送给客户。
- en: This chapter discusses how you can turn information extracted from submitted
    text into a structured format so you can store and manipulate it within a *relational*
    (row-and-column) database. Through examples, you’ll learn how a chatbot can shred
    input text into pieces and compose a ready-for-database structure from it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何将从提交的文本中提取的信息转换为结构化格式，以便将其存储并在*关系型*（行列）数据库中进行操作。通过示例，你将学习一个聊天机器人如何将输入文本拆解成小片段，并从中构建一个准备好存入数据库的结构。
- en: '**Converting Unstructured Data into Structured Data**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将非结构化数据转换为结构化数据**'
- en: '*Structured data* is organized using a predefined data schema in a formatted
    repository. If you’ve worked with relational databases before, you know you must
    first convert any data you’ll enter in the database into a structured format so
    it fits into a table or set of related tables.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化数据*是使用预定义的数据架构在格式化的存储库中组织的。如果你之前使用过关系数据库，你会知道必须首先将任何你要输入数据库的数据转换为结构化格式，这样它才能适应表格或一组相关表格。'
- en: The problem is that the natural language input that apps receive from users
    is *unstructured*, meaning it has no predefined organizational schema. Typical
    examples of unstructured data include text and multimedia content, such as emails,
    web pages, business documents, videos, photos, and so on. Although you can still
    store unstructured data in a database, usually you must perform some preprocessing
    when you insert it. For example, you might need to label photos so the database
    can classify them or assign IDs to text documents so the database can distinguish
    between them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，应用程序从用户接收到的自然语言输入是*非结构化*的，这意味着它没有预定义的组织架构。非结构化数据的典型示例包括文本和多媒体内容，如电子邮件、网页、商业文档、视频、照片等。尽管你仍然可以将非结构化数据存储在数据库中，但通常在插入时需要进行一些预处理。例如，你可能需要为照片加标签，以便数据库能够对其进行分类，或者为文本文件分配ID，以便数据库能够区分它们。
- en: Sometimes, you might need to perform more radical transformations to unstructured
    text content, such as extracting pieces of information from it, before grouping
    those pieces into a formatted structure. For example, a business chatbot typically
    needs to parse a customer’s utterances to fill in a certain form. A different
    app might extract just certain elements from a web page, label those elements,
    and then convert the information into a table, as shown in [Figure 9-1](../Text/ch09.xhtml#ch09fig01).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要对非结构化文本内容进行更为彻底的转换，例如从中提取信息片段，然后将这些片段按格式组织成结构。例如，商业聊天机器人通常需要解析客户的言语，以填写某个表单。另一个应用程序可能会从网页中提取某些特定元素，对这些元素加标签，然后将信息转换为表格，如[图9-1](../Text/ch09.xhtml#ch09fig01)所示。
- en: '![image](../Images/fig9-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig9-1.jpg)'
- en: '*Figure 9-1: An example of converting unstructured content into structured
    data*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：将非结构化内容转换为结构化数据的示例*'
- en: Tools like spaCy reveal a text’s internal structure by tagging each token in
    a sentence with linguistic annotations. This preprocessing enables you to extract
    specific elements from it, usually by checking the text’s syntactic dependency
    labels. [Figure 9-2](../Text/ch09.xhtml#ch09fig02) describes how a food-ordering
    chatbot might recognize and extract necessary elements from a user’s utterance
    by relying on the syntactic dependency labels spaCy assigns to each token when
    you apply the text-processing pipeline to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类似spaCy这样的工具通过为句子中的每个标记添加语言学注释，揭示了文本的内部结构。这一预处理使你能够从文本中提取特定元素，通常是通过检查文本的句法依赖标签。[图9-2](../Text/ch09.xhtml#ch09fig02)描述了食品订购聊天机器人如何通过依赖于spaCy为每个标记分配的句法依赖标签，在你对文本应用处理管道时，识别并提取用户话语中的必要元素。
- en: '![image](../Images/fig9-2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig9-2.jpg)'
- en: '*Figure 9-2: A high-level view of how raw text can be converted into row–column
    data.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：原始文本如何转换为行列数据的高层次视图。*'
- en: Next, you’ll see how, once you’ve extracted these elements, you can structure
    and insert them into a database table as a row.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到一旦提取了这些元素，如何将它们构建并插入到数据库表中作为一行数据。
- en: '***Extracting Data into Interchange Formats***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***提取数据到交换格式***'
- en: Many current relational databases natively support multiple common data interchange
    formats. For example, MySQL natively supports XML and JSON, the two most common
    data interchange formats on the web.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多当前的关系型数据库本身就支持多种常见的数据交换格式。例如，MySQL本身就支持XML和JSON，这两种是网页上最常见的数据交换格式。
- en: 'Your data format choice can affect the way in which you decide to collect data.
    For example, if the database you’re using supports JSON, you can extract data
    directly into a JSON object that you’ll then send to the database for further
    processing. A JSON object is a key-value data format surrounded by curly brackets.
    It looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据格式选择会影响你决定如何收集数据。例如，如果你使用的数据库支持JSON格式，你可以直接将数据提取到JSON对象中，然后将其发送到数据库进行进一步处理。JSON对象是一种键值对数据格式，围绕着花括号。它的形式如下：
- en: '{"product": "pizza", "type": "Chicago", "qty": 1}'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '{"product": "pizza", "type": "Chicago", "qty": 1}'
- en: Apart from basic values, such as strings and numbers, JSON supports complex
    values, such as arrays and other JSON objects. You’ll see how this works in “[Building
    a Database-Powered Chatbot](../Text/ch09.xhtml#lev122)” on [page 132](../Text/ch09.xhtml#page_132).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本值，如字符串和数字，JSON还支持复杂值，如数组和其他JSON对象。你将看到这一点在《[构建数据库驱动的聊天机器人](../Text/ch09.xhtml#lev122)》中，[第132页](../Text/ch09.xhtml#page_132)有详细说明。
- en: In fact, using the JSON format significantly simplifies the process of composing
    a data structure for the database in your Python script. First, you don’t need
    to prepare a structure that conforms to a less widely used format, which makes
    your code less tied to a given database type. Second, the elements in a JSON object
    can follow any order, which imposes fewer restrictions on how the process of determining
    and extraction of necessary elements from an input text can be organized.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用JSON格式显著简化了在Python脚本中为数据库构建数据结构的过程。首先，你无需准备符合较少使用格式的结构，这使得你的代码不那么依赖于特定的数据库类型。其次，JSON对象中的元素可以按任何顺序排列，这对如何组织从输入文本中提取和确定必要元素的过程限制更少。
- en: '[Figure 9-3](../Text/ch09.xhtml#ch09fig03) illustrates how a food-ordering
    chatbot app might interact with its underlying database using JSON.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-3](../Text/ch09.xhtml#ch09fig03)展示了食品订购聊天机器人应用如何使用JSON与底层数据库进行交互。'
- en: '![image](../Images/fig9-3.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig9-3.jpg)'
- en: '*Figure 9-3: The workflow of a food-ordering chatbot app*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：一个食品订购聊天机器人应用的工作流*'
- en: In step 1, a user submits a request to the chatbot asking for a Greek pizza.
    In step 2, the chatbot processes the submitted utterance with spaCy, generating
    a JSON object that contains the information needed to take an order. In step 3,
    the JSON object representing the order form is submitted to the database, which
    stores the form and generates a response about it for the chatbot. In step 4,
    the chatbot informs the user about whether or not the order has been placed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，用户向聊天机器人提交一个请求，要求订购一份希腊比萨。在第2步，聊天机器人使用spaCy处理提交的语言，生成一个包含订购信息的JSON对象。在第3步，代表订单表单的JSON对象被提交到数据库，数据库存储该表单并生成关于它的响应供聊天机器人使用。在第4步，聊天机器人通知用户订单是否已成功下单。
- en: '***Moving Application Logic to the Database***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将应用程序逻辑移动到数据库***'
- en: Notice that the database in the chatbot application in [Figure 9-3](../Text/ch09.xhtml#ch09fig03)
    not only stores the submitted JSON object, but also generates a response to the
    application about whether the operation of saving the order has been successful.
    The reason is that the database runs a portion of the application logic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图9-3](../Text/ch09.xhtml#ch09fig03)中的聊天机器人应用中，数据库不仅存储了提交的JSON对象，还生成了关于订单保存是否成功的响应。原因是数据库运行了一部分应用程序逻辑。
- en: It’s quite common for database-powered applications to keep application logic
    related to data processing within the database. This approach allows you to reduce
    data moves between the application’s logic tier and the underlying database, eliminating
    redundancy, improving data processing efficiency, and maintaining data security.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库驱动的应用程序通常将与数据处理相关的应用程序逻辑保留在数据库中。这种方法可以减少应用程序逻辑层与底层数据库之间的数据移动，消除冗余，提高数据处理效率，并维护数据安全。
- en: '[Figure 9-4](../Text/ch09.xhtml#ch09fig04) details the database part of the
    chatbot application depicted in [Figure 9-3](../Text/ch09.xhtml#ch09fig03).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](../Text/ch09.xhtml#ch09fig04) 详细描述了聊天机器人应用程序中数据库部分，如 [图 9-3](../Text/ch09.xhtml#ch09fig03)
    所示。'
- en: '![image](../Images/fig9-4.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig9-4.jpg)'
- en: '*Figure 9-4: A more detailed view of the database used in the chatbot application
    depicted in [Figure 9-3](../Text/ch09.xhtml#ch09fig03)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：聊天机器人应用程序中数据库的更详细视图，如 [图 9-3](../Text/ch09.xhtml#ch09fig03) 所示*'
- en: In this application, the database will convert an input JSON object into relational
    data and store that data in a relational table in a way that guarantees that the
    data being inserted is correct and complete. If the value of a field is missing,
    the customer receives a message about what information they should supply.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，数据库将输入的 JSON 对象转换为关系型数据，并以保证数据插入正确和完整的方式存储在关系表中。如果某个字段的值缺失，客户将收到一条消息，告知他们应该提供什么信息。
- en: You can check the value of each field before moving the input to the table with
    the help of stored procedures, ON ERROR clauses in SQL statements, or triggers
    defined on the table to which the data is sent. A more thorough discussion of
    SQL is outside the scope of this book. But in “[Preparing Your Database Environment](../Text/ch09.xhtml#lev125)”
    on [page 135](../Text/ch09.xhtml#page_135), you’ll see an example of using SQL
    to create a database infrastructure to be used in the application, and then interact
    with this infrastructure using Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在将输入数据移动到表格之前，你可以借助存储过程、SQL 语句中的 ON ERROR 子句或在数据表上定义的触发器检查每个字段的值。关于 SQL 的更详细讨论超出了本书的范围。但是在
    “[准备你的数据库环境](../Text/ch09.xhtml#lev125)” 第 [135 页](../Text/ch09.xhtml#page_135)，你将看到一个使用
    SQL 创建数据库基础设施并与 Python 交互的示例。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using a database that doesn’t support features like converting JSON
    data into relational data, you’ll need to implement the logic that checks the
    data for completeness in Python on your own; however, this discussion is beyond
    the scope of this chapter.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用的数据库不支持将 JSON 数据转换为关系型数据等功能，你需要在 Python 中自行实现检查数据完整性的逻辑；然而，这一讨论超出了本章的范围。*'
- en: '**Building a Database-Powered Chatbot**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建一个基于数据库的聊天机器人**'
- en: Now that you have a basic idea of how to implement a database-powered chatbot
    app, let’s create a simple one for the application shown in [Figure 9-3](../Text/ch09.xhtml#ch09fig03).
    The app should process a user’s utterance, extracting the information necessary
    to fill in an order form, such as product name, product type, and amount. Then
    this information gets packed into a JSON object that is sent to the underlying
    database. The database should shred the JSON object into relational data and then
    send a response to the application based on the data’s completeness.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了实现一个基于数据库的聊天机器人应用程序的基本概念，让我们为 [图 9-3](../Text/ch09.xhtml#ch09fig03) 中显示的应用程序创建一个简单的版本。该应用程序应处理用户的发言，提取必要的信息以填写订单表格，例如产品名称、产品类型和数量。然后，这些信息将被打包成一个
    JSON 对象，并发送到底层数据库。数据库应将 JSON 对象拆解为关系型数据，并根据数据的完整性向应用程序发送响应。
- en: '***Gathering the Data and Building a JSON Object***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***收集数据并构建 JSON 对象***'
- en: 'We’ll start by developing the application’s logic tier and use Python to build
    a JSON object that we could then send to any database type. The following code
    shows what this implementation might look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从开发应用程序的逻辑层开始，使用 Python 构建一个 JSON 对象，然后将其发送到任何数据库类型。以下代码展示了这种实现可能的样子：
- en: import spacy
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: nlp = spacy.load('en')
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(u'I want a Greek pizza.')
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u'I want a Greek pizza.')
- en: ➊ orderdict ={}
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ orderdict ={}
- en: '➋ for token in doc:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for token in doc:'
- en: '➌ if token.dep_ == ''dobj'':'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ if token.dep_ == ''dobj'':'
- en: dobj = token
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = token
- en: ➍ orderdict.update(product = dobj.lemma_)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ orderdict.update(product = dobj.lemma_)
- en: '➎ for child in dobj.lefts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for child in dobj.lefts:'
- en: '➏ if child.dep_ == ''amod'' or child.dep_ == ''compound'':'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ if child.dep_ == ''amod'' or child.dep_ == ''compound'':'
- en: orderdict.update(ptype = child.text )
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: orderdict.update(ptype = child.text )
- en: '➐ elif child.dep_ == ''det'':'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ elif child.dep_ == ''det'':'
- en: orderdict.update(qty = 1 )
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: orderdict.update(qty = 1 )
- en: '➑ elif child.dep_ == ''nummod'':'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ elif child.dep_ == ''nummod'':'
- en: orderdict.update(qty = child.text)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: orderdict.update(qty = child.text)
- en: break
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: We define the orderdict dictionary as a container for the JSON object being
    created ➊. We’ll be able to easily convert this dictionary to a JSON string later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `orderdict` 字典定义为创建的 JSON 对象的容器 ➊。稍后我们将能够轻松地将这个字典转换为 JSON 字符串。
- en: Then we iterate over the utterance’s tokens ➋, looking for a direct object ➌.
    We might want a pizza, or we might ask someone to make us a pizza. In either case,
    “pizza” will be a direct object in our utterance so we’re hunting for a direct
    object here. Of course, a real implementation would make more checks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们遍历话语的标记 ➋，寻找直接宾语 ➌。我们可能想要一个比萨，或者可能要求别人给我们做一个比萨。无论哪种情况，“pizza” 都将是我们话语中的直接宾语，因此我们在这里寻找直接宾语。当然，真正的实现会进行更多的检查。
- en: Once it’s found, we define a key-value pair in the orderdict dictionary, sending
    in product as the key and the direct object’s lemma as the value ➍. We use lemmatization
    to reduce the possible word forms of a product’s name to its base form (converting
    from plural to singular in most cases).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到，我们在 `orderdict` 字典中定义一个键值对，将产品作为键，直接宾语的词根作为值 ➍。我们使用词形还原将产品名称的可能词形简化为其基本形式（在大多数情况下，从复数形式转为单数形式）。
- en: Next, we iterate over the direct object’s syntactic left children ➎, because
    that’s where we expect the information about the type of product requested. In
    terms of syntactic dependency labels, the product type can be either a compound
    or an adjectival modifier (amod) ➏. For example, spaCy would consider the word
    “Greek” in the phrase “a Greek pizza” an adjectival modifier, whereas it considers
    the word “Chicago” in the phrase “a Chicago pizza” a compound.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历直接宾语的句法左孩子 ➎，因为我们期望在那里找到关于请求的产品类型的信息。在句法依赖标签方面，产品类型可以是复合词或形容词修饰语（amod）
    ➏。例如，spaCy 会将短语 “a Greek pizza” 中的单词 “Greek” 视为形容词修饰语，而将短语 “a Chicago pizza” 中的单词
    “Chicago” 视为复合词。
- en: Now we check for the presence of a determiner in the children of the modifier
    or compound. The presence of the “a” determiner implies that a customer requests
    a single unit of a product ➐. In contrast, a word labeled with the dependency
    label nummod would indicate a particular number of units ➑.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查修饰词或复合词的孩子中是否有限定词。限定词“a”意味着客户要求单个单位的产品 ➐。相反，带有依赖标签 nummod 的单词表示特定数量的单位
    ➑。
- en: 'Print the orderdict dictionary using this command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打印 `orderdict` 字典：
- en: print(orderdict)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: print(orderdict)
- en: 'This should give you the following result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你以下结果：
- en: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': 1}'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': 1}'
- en: Now we have a JSON string that we can send to an underlying database for further
    processing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一个 JSON 字符串，可以将其发送到底层数据库进行进一步处理。
- en: '***Converting Number Words to Numbers***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将数字单词转换为数字***'
- en: 'Before moving on to the code that will send your JSON string to a database,
    consider what it will look like when a user explicitly specifies the quantity
    of a product, as in the following utterance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 JSON 字符串发送到数据库的代码之前，考虑一下当用户明确指定产品数量时的情况，如以下话语所示：
- en: I want two Greek pizzas.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要两个希腊风味的比萨。
- en: 'If you put this into the previous script, you’d get the following result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此添加到前面的脚本中，你将得到以下结果：
- en: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': two}'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': two}'
- en: In the first sample sentence, the value of the 'qty' key is a numeral. In the
    second, it’s a number spelled out as a word. At this stage, this difference doesn’t
    look like a problem. But the issue is that we must define a data type for each
    column of a relational table when we create it. Attempting to insert data of another
    type into that column will fail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例句子中，'qty' 键的值是一个数字。在第二个示例中，它是一个拼写出来的数字单词。在这个阶段，这种差异看起来不成问题。但问题在于，当我们创建一个关系表时，必须为每一列定义数据类型。尝试将其他类型的数据插入该列会失败。
- en: You should prepare your chatbot for the fact that customers will specify a product’s
    quantity in any way they like. To solve this problem, you’ll have to convert strings
    representing number words to their corresponding integer values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为聊天机器人做好准备，客户可能会以任何他们喜欢的方式指定产品的数量。为了解决这个问题，你需要将表示数字单词的字符串转换为相应的整数值。
- en: To do this, define a list containing numbers spelled in words and sorted in
    increasing order; then iterate over that list to find the correct number. In this
    example, we define a list for number words ranging from “zero” to “twenty,” which
    assumes we don’t expect that a customer will order more than twenty units of the
    same product with one transaction.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，定义一个包含用单词拼写的数字并按升序排列的列表；然后遍历该列表找到正确的数字。在此示例中，我们定义了一个数字单词列表，范围从“zero”到“twenty”，假设我们不认为客户在一次交易中会订购超过二十个相同的产品。
- en: 'We need to implement this conversion scenario as a function that takes either
    a number word or a number (in the latter case, no conversion is needed) and returns
    a number. We should then use the function to modify the script’s code in the preceding
    section. Here is what the implementation of such a function might look like:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这个转换场景实现为一个函数，该函数接收一个数字词或一个数字（在后者情况下，无需转换），并返回一个数字。然后，我们应该使用这个函数修改前面部分脚本的代码。以下是该函数实现的样子：
- en: '➊ def word2int(numword):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def word2int(numword):'
- en: num = 0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: num = 0
- en: '➋ try:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ try:'
- en: ➌ num = int(numword)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ num = int(numword)
- en: ➍ return num
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ return num
- en: 'except ValueError:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: ➎ pass
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ pass
- en: ➏ words = ["zero", "one", "two", "three", "four", "five", "six", "seven",
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ words = ["零", "一", "二", "三", "四", "五", "六", "七",
- en: '"eight","nine", "ten", "eleven", "twelve", "thirteen", "fourteen",'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"八", "九", "十", "十一", "十二", "十三", "十四",'
- en: '"fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"]'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '"十五", "十六", "十七", "十八", "十九", "二十"]'
- en: '➐ for idx, word in enumerate(words):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ for idx, word in enumerate(words):'
- en: '➑ if word in numword:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if word in numword:'
- en: num = idx
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: num = idx
- en: ➒ return num
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ return num
- en: 'The word2int() function takes a single parameter: either a number word to be
    converted to the correspondent digits or a number already, in which case we won’t
    need to convert it ➊. The function has to handle both cases, because we don’t
    know which one we’ll find in a customer’s utterance.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`word2int()` 函数接受一个参数：要转换为对应数字的数字词，或者已经是数字的数字，在后一种情况下我们不需要进行转换 ➊。该函数必须处理这两种情况，因为我们无法确定在顾客的陈述中会出现哪一种。'
- en: We use the try and except block to handle cases when no conversion is needed
    ➋. We check whether the input is an integer ➌, and if it is, all we have to do
    is return the input number as is ➍. Otherwise, we ignore an error caused by an
    attempt to treat a nonnumber value as an integer and move on to converting it
    to a number ➎.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 try 和 except 块来处理不需要转换的情况 ➋。我们检查输入是否为整数 ➌，如果是，所有我们需要做的就是原样返回输入的数字 ➍。否则，我们忽略因尝试将非数字值当作整数处理而引发的错误，并继续将其转换为数字
    ➎。
- en: We define a list of number words, starting from zero and listing them in increasing
    order ➏. Then we iterate over this list with the enumerate() method ➐, looking
    for the word the function received as input ➑. When we find the match, we return
    the iteration number (the index of the word in the list) as the digit representation
    of the input number word ➒.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个数字词列表，从零开始，按递增顺序列出 ➏。然后，我们使用 `enumerate()` 方法遍历这个列表 ➐，寻找函数接收到的输入词 ➑。当找到匹配时，我们返回迭代的编号（该词在列表中的索引），作为输入数字词的数字表示
    ➒。
- en: 'Add the word2int() function definition to the previous script. Then move to
    the end of the script and find the following lines of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `word2int()` 函数定义添加到前面的脚本中。然后转到脚本的末尾，找到以下代码行：
- en: 'elif child.dep_ == ''nummod'':'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif child.dep_ == ''nummod'':'
- en: orderdict.update(qty = child.text)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: orderdict.update(qty = child.text)
- en: 'Change them as follows, using the word2int() function defined in this section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更改它们，使用本节中定义的 `word2int()` 函数：
- en: 'elif child.dep_ == ''nummod'':'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif child.dep_ == ''nummod'':'
- en: orderdict.update(qty = word2int(child.text))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: orderdict.update(qty = word2int(child.text))
- en: 'Now let’s see how the script handles this sentence:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看脚本如何处理这个句子：
- en: I want two Greek pizzas.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要两个希腊式披萨。
- en: 'This time, you should get the following result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你应该得到以下结果：
- en: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': 2}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': 2}'
- en: The value of the 'qty' field is now a digit, and we have a consistent format
    to send to the database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '''qty'' 字段的值现在是一个数字，我们有了一个一致的格式，可以发送到数据库。'
- en: '***Preparing Your Database Environment***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***准备你的数据库环境***'
- en: To prepare your database environment, you need to install or obtain access to
    a database; create the components you’ll need in the database, such as a database
    schema, a table, and so on; and install a Python module that enables you to interact
    with the database.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备你的数据库环境，你需要安装或获得对数据库的访问权限；在数据库中创建你需要的组件，例如数据库模式、表格等；并安装一个允许你与数据库交互的 Python
    模块。
- en: Although you can choose any database that can receive and process JSON data,
    such as an Oracle database, this section uses MySQL. The MySQL database has a
    long history of supporting the most popular data interchange formats, which are
    XML and JSON. Also, MySQL is the world’s most popular open source database and
    is available on a majority of modern operating systems, including Linux, Windows,
    Unix, and macOS. MySQL has a freely downloadable version and commercial editions
    to meet specific business requirements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以选择任何能够接收和处理 JSON 数据的数据库，例如 Oracle 数据库，本节使用的是 MySQL。MySQL 数据库有着长期支持最流行的数据交换格式的历史，包括
    XML 和 JSON。而且，MySQL 是全球最受欢迎的开源数据库，支持大多数现代操作系统，包括 Linux、Windows、Unix 和 macOS。MySQL
    提供免费可下载版本，并且还有商业版来满足特定的业务需求。
- en: For this chapter, you can use MySQL Community Edition—the freely downloadable
    version available under the GPL license. To learn more about the MySQL Community
    Edition, visit its official page at *https://www.mysql.com/products/community/*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你可以使用 MySQL Community Edition——这个可以免费下载安装的版本，适用于 GPL 许可。要了解更多关于 MySQL
    Community Edition 的信息，请访问其官方网站 *https://www.mysql.com/products/community/*。
- en: You’ll first need to install MySQL on your system. At the time of this writing,
    MySQL 8.0 is the most recent version. Refer to the “Installing and Upgrading MySQL”
    chapter at *[https://dev.mysql.com/doc/refman/8.0/en/installing.html](https://dev.mysql.com/doc/refman/8.0/en/installing.html)*
    in the MySQL 8.0 Reference Manual, or the equivalent chapter for future versions
    of MySQL. Here, you’ll find the detailed installation instructions for your operating
    system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要在系统上安装 MySQL。在撰写本文时，MySQL 8.0 是最新版本。请参考 MySQL 8.0 参考手册中的“安装和升级 MySQL”章节
    *[https://dev.mysql.com/doc/refman/8.0/en/installing.html](https://dev.mysql.com/doc/refman/8.0/en/installing.html)*，或者将来
    MySQL 版本的等效章节。在这里，你可以找到针对操作系统的详细安装说明。
- en: After installation, you can start the MySQL server using the command the installation
    guide specifies for your operating system. Before you can start working with the
    database, you need to obtain a password for the mysql superuser (‘root’@‘localhost’)
    generated during the installation. You’ll find the password in the installation
    error log file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用安装指南为你的操作系统指定的命令来启动 MySQL 服务器。在开始使用数据库之前，你需要获取安装过程中为 mysql 超级用户（‘root’@‘localhost’）生成的密码。你可以在安装错误日志文件中找到该密码。
- en: 'Once you have the superuser password, you can connect to the MySQL server from
    a system terminal using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有超级用户密码后，你可以通过系统终端使用以下命令连接到 MySQL 服务器：
- en: $ mysql -uroot -p
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: $ mysql -uroot -p
- en: 'Enter password: ******'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码：******
- en: mysql>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: mysql>
- en: If you prefer to use a GUI, you can take advantage of MySQL Workbench (*[https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)*),
    which is a unified visual tool designed to model and manage MySQL databases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用图形界面，可以利用 MySQL Workbench (*[https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)*)，它是一个统一的可视化工具，旨在建模和管理
    MySQL 数据库。
- en: 'After connecting to the server, your first step is to choose a new password
    for the root user, replacing the random password generated during the installation.
    Use the following command to do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到服务器后，你的第一步是为 root 用户选择一个新密码，替换安装过程中生成的随机密码。使用以下命令来进行操作：
- en: ALTER USER 'root'@'localhost' IDENTIFIED BY 'Your-pswd';
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ALTER USER 'root'@'localhost' IDENTIFIED BY 'Your-pswd';
- en: 'Now you’re ready to start developing the infrastructure on the server that
    you need for your application. You’ll begin by creating a database that you’ll
    use as the container for the other objects the application needs to interact with.
    To create the database, enter the following command at the mysql> prompt:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始为应用程序开发所需的服务器基础设施了。你将首先创建一个数据库，将它作为其他对象的容器，这些对象是应用程序需要交互的。要创建数据库，请在 mysql>
    提示符下输入以下命令：
- en: mysql> CREATE DATABASE mybot;
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: mysql> CREATE DATABASE mybot;
- en: Query OK, 1 row affected (0.03 sec)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查询 OK, 1 行受影响 (0.03 秒)
- en: 'Then select the newly created database for use, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择刚创建的数据库进行使用，方法如下：
- en: mysql> USE mybot;
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: mysql> USE mybot;
- en: Database changed
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库已更改
- en: 'You’re ready to start creating your database’s structure. For this example,
    you’ll need a single table you create with the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好开始创建数据库的结构了。对于这个例子，你需要创建一个包含以下命令的单个表：
- en: CREATE TABLE orders (
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE orders (
- en: id INT NOT NULL AUTO_INCREMENT,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: id INT NOT NULL AUTO_INCREMENT,
- en: product VARCHAR(30),
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: product VARCHAR(30),
- en: ptype VARCHAR(30),
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ptype VARCHAR(30),
- en: qty INT,
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: qty INT,
- en: PRIMARY KEY (id)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: PRIMARY KEY (id)
- en: );
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'With this database infrastructure set up, you need to install the MySQL Connector/Python
    driver, which allows your Python code to interact with that infrastructure. On
    any operating system, you can install Connector/Python via pip, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这个数据库基础设施后，你需要安装MySQL Connector/Python驱动程序，它允许你的Python代码与该基础设施进行交互。在任何操作系统上，你都可以通过pip安装Connector/Python，方法如下：
- en: pip install mysql-connector-python
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: pip install mysql-connector-python
- en: For further details on how to install this driver, check the documentation at
    *[https://dev.mysql.com/doc/connector-python/en/](https://dev.mysql.com/doc/connector-python/en/).*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关如何安装此驱动程序的详细信息，请查看文档 *[https://dev.mysql.com/doc/connector-python/en/](https://dev.mysql.com/doc/connector-python/en/)。*
- en: 'Using the following simple script, ensure that you’ve installed Connector/Python:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下简单脚本，确保你已安装了Connector/Python：
- en: import mysql.connector
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: import mysql.connector
- en: cnx = mysql.connector.connect(user='root', password='Your_pswd',
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: cnx = mysql.connector.connect(user='root', password='Your_pswd',
- en: host='127.0.0.1',
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: host='127.0.0.1',
- en: database='mybot')
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: database='mybot')
- en: cnx.close()
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: cnx.close()
- en: If the install is successful, you should see no error messages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，您应该看不到任何错误信息。
- en: '***Sending Data to the Underlying Database***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将数据发送到底层数据库***'
- en: 'Let’s return to the script we had on [page 134](../Text/ch09.xhtml#page_134).
    The following code connects to your database and passes order data to the orders
    table. Append this code to the script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[第134页](../Text/ch09.xhtml#page_134)的脚本。以下代码连接到你的数据库并将订单数据传递给orders表。将此代码附加到脚本中：
- en: import json
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: import json
- en: ➊ json_str = json.dumps(orderdict)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ json_str = json.dumps(orderdict)
- en: import mysql.connector
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: import mysql.connector
- en: from mysql.connector import errorcode
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: from mysql.connector import errorcode
- en: 'try:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: ➋ cnx = mysql.connector.connect(user='root', password='Your_pswd',
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ cnx = mysql.connector.connect(user='root', password='Your_pswd',
- en: host='127.0.0.1',
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: host='127.0.0.1',
- en: database='mybot')
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: database='mybot')
- en: ➌ query = ("""INSERT INTO orders (product, ptype, qty)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ query = ("""INSERT INTO orders (product, ptype, qty)
- en: SELECT product, ptype, qty FROM
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT product, ptype, qty FROM
- en: JSON_TABLE(
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JSON_TABLE(
- en: ➍ %s,
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ %s,
- en: '"$" COLUMNS('
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '"$" COLUMNS('
- en: qty    INT PATH '$.qty',
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: qty    INT PATH '$.qty',
- en: product   VARCHAR(30) PATH "$.product",
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: product   VARCHAR(30) PATH "$.product",
- en: ptype     VARCHAR(30) PATH "$.ptype"
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ptype     VARCHAR(30) PATH "$.ptype"
- en: )
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ) AS jt1""")
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ) AS jt1""")
- en: ➎ cursor = cnx.cursor()
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ cursor = cnx.cursor()
- en: ➏ cursor.execute(query, ➐(json_str,))
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ cursor.execute(query, ➐(json_str,))
- en: ➑ cnx.commit()
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ cnx.commit()
- en: '➒ except mysql.connector.Error as err:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ except mysql.connector.Error as err:'
- en: print("Error-Code:", err.errno)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: print("错误代码:", err.errno)
- en: 'print("Error-Message: {}".format(err.msg))'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("错误消息: {}".format(err.msg))'
- en: 'finally:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'finally:'
- en: cursor.close()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: cursor.close()
- en: cnx.close()
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: cnx.close()
- en: We start by converting the orderdict dictionary into a JSON string ➊. Next,
    we connect to the database ➋ and define an insert SQL statement to be passed into
    the database for processing ➌. Note the use of a placeholder (called a *bind variable*)
    in the statement ➍. Using placeholders allows us to write SQL statements that
    accept inputs at runtime.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将orderdict字典转换为JSON字符串 ➊。接下来，我们连接到数据库 ➋，并定义一个插入SQL语句，以便将其传递给数据库进行处理 ➌。注意语句中使用了占位符（称为*绑定变量*）
    ➍。使用占位符可以让我们编写在运行时接受输入的SQL语句。
- en: Before we can execute the statement, we create a mysql.connector cursor object
    ➎, which enables operations over the objects in the database we’re connected to.
    Then we can execute the INSERT statement ➏, binding the JSON string ➐ we obtained
    in the beginning of this code snippet to the placeholder in the statement. Note
    the use of the JSON_TABLE function that shreds the submitted JSON data to tabular
    data, making it appropriate for inserting into a relational table.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行语句之前，我们首先创建一个mysql.connector的cursor对象 ➎，它使我们能够在连接到的数据库中对对象进行操作。然后我们可以执行INSERT语句
    ➏，将我们在代码片段开头获得的JSON字符串 ➐ 绑定到语句中的占位符。请注意使用JSON_TABLE函数，它将提交的JSON数据拆解为表格数据，使其适合插入到关系表中。
- en: After the execution of the INSERT statement, we need to explicitly commit the
    statement’s changes with the commit() method ➑. Otherwise, the insertion will
    roll back when the connection closes (either explicitly with cnx.close() or when
    the script’s execution is complete).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行INSERT语句之后，我们需要显式地使用commit()方法提交语句的更改 ➑。否则，当连接关闭时（无论是通过cnx.close()显式关闭，还是脚本执行完成后），插入操作将会回滚。
- en: The except block will begin to execute if an error occurs on the database side
    ➒. In the next section, you’ll learn how to take advantage of this functionality
    when the JSON string passed in doesn’t contain all the fields.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库端发生错误，except代码块将开始执行 ➒。在接下来的部分中，你将学习如何在传递的JSON字符串没有包含所有字段时利用这个功能。
- en: 'Now execute the script. If you don’t see any error messages, return to the
    mysql prompt you worked with in the preceding section and enter the following
    select statement:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行脚本。如果没有看到任何错误消息，返回到你在前一部分使用的 mysql 提示符并输入以下 SELECT 语句：
- en: mysql> SELECT * FROM orders;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: mysql> SELECT * FROM orders;
- en: ID   PRODUCT     PTYPE    QTY
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ID   PRODUCT     PTYPE    QTY
- en: '---- ----------- -------- ---'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '----  -----------  --------  ---'
- en: 1    pizza       Greek    2
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 1    pizza       Greek    2
- en: If you can see this output, your Python script is working as expected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能看到这个输出，说明你的 Python 脚本按预期工作。
- en: '***When a User’s Request Doesn’t Contain Enough Information***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当用户的请求不包含足够的信息时***'
- en: 'Sometimes, a user’s request might not contain enough information to fill in
    all the fields in the order form. As an example, consider the following utterance:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，用户的请求可能没有提供足够的信息来填写订单表单中的所有字段。例如，考虑以下话句：
- en: I want two pizzas.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我要两个披萨。
- en: '[Table 9-1](../Text/ch09.xhtml#ch09tab01) shows the order form the application
    discussed here will generate from this sentence.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](../Text/ch09.xhtml#ch09tab01) 显示了应用程序根据这个句子生成的订单表单。'
- en: '**Table 9-1:** An Order Form Missing Information'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1:** 缺失信息的订单表单'
- en: '| **product** | **ptype** | **quantity** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **product** | **ptype** | **quantity** |'
- en: '| --- | --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| pizza |  | 2 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| pizza |  | 2 |'
- en: 'The value of the ptype field is missing because the user didn’t identify the
    type of pizza they want. To address this issue, enhance the INSERT statement in
    the previous script as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户没有指定他们想要的披萨类型，ptype 字段的值缺失。为了解决这个问题，按照以下方式增强之前脚本中的 INSERT 语句：
- en: query = ("""INSERT INTO orders (product, ptype, qty)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: query = ("""INSERT INTO orders (product, ptype, qty)
- en: SELECT product, ptype, qty FROM
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT product, ptype, qty FROM
- en: JSON_TABLE(
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: JSON_TABLE(
- en: '%s,'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '%s,'
- en: '"$"'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '"$"'
- en: COLUMNS(
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: COLUMNS(
- en: qty    INT PATH '$.qty' ➊ERROR ON EMPTY,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: qty    INT PATH '$.qty' ➊ERROR ON EMPTY,
- en: product   VARCHAR(30) PATH "$.product" ➊ERROR ON EMPTY,
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: product   VARCHAR(30) PATH "$.product" ➊ERROR ON EMPTY,
- en: ptype     VARCHAR(30) PATH "$.ptype" ➊ERROR ON EMPTY
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ptype     VARCHAR(30) PATH "$.ptype" ➊ERROR ON EMPTY
- en: )
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ) AS jt1""");
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ) AS jt1""");
- en: We add the ERROR ON EMPTY option ➊ to each column in JSON_TABLE. This option
    allows us to handle errors caused by trying to insert a JSON string that doesn’t
    contain all the fields it’s supposed to contain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个 JSON_TABLE 列中添加了 ERROR ON EMPTY 选项 ➊。这个选项允许我们处理因尝试插入一个未包含所有必需字段的 JSON
    字符串而导致的错误。
- en: 'Now when you execute the script with the “I want two pizzas.” sample sentence,
    you should see the following output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你执行包含“我要两个披萨。”的示例句子时，你应该会看到以下输出：
- en: 'Error-Code: 3665'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码：3665
- en: 'Error-Message: Missing value for JSON_TABLE column ''ptype'''
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息：缺少 JSON_TABLE 列 'ptype' 的值
- en: 'We could expand on the script so in such cases the chatbot asks the customer
    to clarify their order using the following question:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展脚本，在这种情况下，聊天机器人会询问客户使用以下问题来澄清他们的订单：
- en: What type of pizza do you want?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要什么类型的披萨？
- en: 'An answer might look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可能是这样的：
- en: I want Greek ones.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要希腊式的。
- en: The structure of the sentence representing the answer we’re supposed to receive
    here is similar to the structure of the original sentence. Therefore, we can use
    the same code to analyze this answer that we used to analyze the original sentence.
    Of course, this approach makes assumptions about a user’s response. A real implementation
    would start with this approach and then, if necessary, move on to the other possible
    response structures. For example, a user’s response might consist of a single
    word, “Greek.” In that case, all we need to do is to check whether it’s included
    in our list of pizza types.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该收到的答案句子的结构与原始句子的结构相似。因此，我们可以使用与分析原始句子时相同的代码来分析这个答案。当然，这种方法是基于对用户回应的假设。真实的实现将从这种方法开始，然后在必要时，转向其他可能的回应结构。例如，用户的回应可能只是一个词，“希腊”。在这种情况下，我们只需要检查它是否包含在我们的披萨类型列表中。
- en: '***Try This***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试这个***'
- en: 'The error message tells you what specific field is missing. But you still need
    to extract this field name from the message so you can ask the customer to clarify
    a specific part of their order. One way to do this is to look at the object of
    the preposition in the message. For example, in the message, Error-Message: Missing
    value for JSON_TABLE column ''ptype'', the object of the preposition is ptype.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '错误消息会告诉你缺少了哪个特定字段。但你仍然需要从消息中提取这个字段名，以便你可以要求客户澄清他们订单中的特定部分。一种方法是查看消息中介词的宾语。例如，在消息
    Error-Message: Missing value for JSON_TABLE column ''ptype'' 中，介词的宾语是 ptype。'
- en: '**Summary**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to cut raw text into shreds to insert the text
    into a relational database. You used the JSON format to interact with a database
    that can process a JSON input, extracting it into relational data. You also learned
    to implement some application logic within the database with the help of pure
    SQL, allowing you to move data processing closer to the data. To implement more
    complicated scenarios, you might need to use triggers and stored procedures—the
    details can be found in the documentation for the database you’re using.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将原始文本切割成碎片，并将其插入到关系型数据库中。你使用了 JSON 格式与能够处理 JSON 输入的数据库进行交互，并将其提取为关系型数据。你还学会了在数据库中实现一些应用逻辑，借助纯
    SQL，使得数据处理更加贴近数据本身。为了实现更复杂的场景，你可能需要使用触发器和存储过程——具体细节可以参考你所使用的数据库文档。
