- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STORING USER INPUT IN A DATABASE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../Images/comm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many applications designed for business need to transfer the data they work
    with to a database at some point. For example, a food-ordering chatbot might save
    an order form after filling it out using the information extracted from dialogue
    with a customer. Once the order appears in the database, it becomes available
    for further processing, and the product is eventually shipped to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how you can turn information extracted from submitted
    text into a structured format so you can store and manipulate it within a *relational*
    (row-and-column) database. Through examples, you’ll learn how a chatbot can shred
    input text into pieces and compose a ready-for-database structure from it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting Unstructured Data into Structured Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Structured data* is organized using a predefined data schema in a formatted
    repository. If you’ve worked with relational databases before, you know you must
    first convert any data you’ll enter in the database into a structured format so
    it fits into a table or set of related tables.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the natural language input that apps receive from users
    is *unstructured*, meaning it has no predefined organizational schema. Typical
    examples of unstructured data include text and multimedia content, such as emails,
    web pages, business documents, videos, photos, and so on. Although you can still
    store unstructured data in a database, usually you must perform some preprocessing
    when you insert it. For example, you might need to label photos so the database
    can classify them or assign IDs to text documents so the database can distinguish
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you might need to perform more radical transformations to unstructured
    text content, such as extracting pieces of information from it, before grouping
    those pieces into a formatted structure. For example, a business chatbot typically
    needs to parse a customer’s utterances to fill in a certain form. A different
    app might extract just certain elements from a web page, label those elements,
    and then convert the information into a table, as shown in [Figure 9-1](../Text/ch09.xhtml#ch09fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: An example of converting unstructured content into structured
    data*'
  prefs: []
  type: TYPE_NORMAL
- en: Tools like spaCy reveal a text’s internal structure by tagging each token in
    a sentence with linguistic annotations. This preprocessing enables you to extract
    specific elements from it, usually by checking the text’s syntactic dependency
    labels. [Figure 9-2](../Text/ch09.xhtml#ch09fig02) describes how a food-ordering
    chatbot might recognize and extract necessary elements from a user’s utterance
    by relying on the syntactic dependency labels spaCy assigns to each token when
    you apply the text-processing pipeline to it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig9-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: A high-level view of how raw text can be converted into row–column
    data.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll see how, once you’ve extracted these elements, you can structure
    and insert them into a database table as a row.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extracting Data into Interchange Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many current relational databases natively support multiple common data interchange
    formats. For example, MySQL natively supports XML and JSON, the two most common
    data interchange formats on the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your data format choice can affect the way in which you decide to collect data.
    For example, if the database you’re using supports JSON, you can extract data
    directly into a JSON object that you’ll then send to the database for further
    processing. A JSON object is a key-value data format surrounded by curly brackets.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '{"product": "pizza", "type": "Chicago", "qty": 1}'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from basic values, such as strings and numbers, JSON supports complex
    values, such as arrays and other JSON objects. You’ll see how this works in “[Building
    a Database-Powered Chatbot](../Text/ch09.xhtml#lev122)” on [page 132](../Text/ch09.xhtml#page_132).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, using the JSON format significantly simplifies the process of composing
    a data structure for the database in your Python script. First, you don’t need
    to prepare a structure that conforms to a less widely used format, which makes
    your code less tied to a given database type. Second, the elements in a JSON object
    can follow any order, which imposes fewer restrictions on how the process of determining
    and extraction of necessary elements from an input text can be organized.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](../Text/ch09.xhtml#ch09fig03) illustrates how a food-ordering
    chatbot app might interact with its underlying database using JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig9-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: The workflow of a food-ordering chatbot app*'
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, a user submits a request to the chatbot asking for a Greek pizza.
    In step 2, the chatbot processes the submitted utterance with spaCy, generating
    a JSON object that contains the information needed to take an order. In step 3,
    the JSON object representing the order form is submitted to the database, which
    stores the form and generates a response about it for the chatbot. In step 4,
    the chatbot informs the user about whether or not the order has been placed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Moving Application Logic to the Database***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that the database in the chatbot application in [Figure 9-3](../Text/ch09.xhtml#ch09fig03)
    not only stores the submitted JSON object, but also generates a response to the
    application about whether the operation of saving the order has been successful.
    The reason is that the database runs a portion of the application logic.
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite common for database-powered applications to keep application logic
    related to data processing within the database. This approach allows you to reduce
    data moves between the application’s logic tier and the underlying database, eliminating
    redundancy, improving data processing efficiency, and maintaining data security.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-4](../Text/ch09.xhtml#ch09fig04) details the database part of the
    chatbot application depicted in [Figure 9-3](../Text/ch09.xhtml#ch09fig03).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig9-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: A more detailed view of the database used in the chatbot application
    depicted in [Figure 9-3](../Text/ch09.xhtml#ch09fig03)*'
  prefs: []
  type: TYPE_NORMAL
- en: In this application, the database will convert an input JSON object into relational
    data and store that data in a relational table in a way that guarantees that the
    data being inserted is correct and complete. If the value of a field is missing,
    the customer receives a message about what information they should supply.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the value of each field before moving the input to the table with
    the help of stored procedures, ON ERROR clauses in SQL statements, or triggers
    defined on the table to which the data is sent. A more thorough discussion of
    SQL is outside the scope of this book. But in “[Preparing Your Database Environment](../Text/ch09.xhtml#lev125)”
    on [page 135](../Text/ch09.xhtml#page_135), you’ll see an example of using SQL
    to create a database infrastructure to be used in the application, and then interact
    with this infrastructure using Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re using a database that doesn’t support features like converting JSON
    data into relational data, you’ll need to implement the logic that checks the
    data for completeness in Python on your own; however, this discussion is beyond
    the scope of this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Database-Powered Chatbot**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have a basic idea of how to implement a database-powered chatbot
    app, let’s create a simple one for the application shown in [Figure 9-3](../Text/ch09.xhtml#ch09fig03).
    The app should process a user’s utterance, extracting the information necessary
    to fill in an order form, such as product name, product type, and amount. Then
    this information gets packed into a JSON object that is sent to the underlying
    database. The database should shred the JSON object into relational data and then
    send a response to the application based on the data’s completeness.
  prefs: []
  type: TYPE_NORMAL
- en: '***Gathering the Data and Building a JSON Object***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll start by developing the application’s logic tier and use Python to build
    a JSON object that we could then send to any database type. The following code
    shows what this implementation might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: import spacy
  prefs: []
  type: TYPE_NORMAL
- en: nlp = spacy.load('en')
  prefs: []
  type: TYPE_NORMAL
- en: doc = nlp(u'I want a Greek pizza.')
  prefs: []
  type: TYPE_NORMAL
- en: ➊ orderdict ={}
  prefs: []
  type: TYPE_NORMAL
- en: '➋ for token in doc:'
  prefs: []
  type: TYPE_NORMAL
- en: '➌ if token.dep_ == ''dobj'':'
  prefs: []
  type: TYPE_NORMAL
- en: dobj = token
  prefs: []
  type: TYPE_NORMAL
- en: ➍ orderdict.update(product = dobj.lemma_)
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for child in dobj.lefts:'
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if child.dep_ == ''amod'' or child.dep_ == ''compound'':'
  prefs: []
  type: TYPE_NORMAL
- en: orderdict.update(ptype = child.text )
  prefs: []
  type: TYPE_NORMAL
- en: '➐ elif child.dep_ == ''det'':'
  prefs: []
  type: TYPE_NORMAL
- en: orderdict.update(qty = 1 )
  prefs: []
  type: TYPE_NORMAL
- en: '➑ elif child.dep_ == ''nummod'':'
  prefs: []
  type: TYPE_NORMAL
- en: orderdict.update(qty = child.text)
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: We define the orderdict dictionary as a container for the JSON object being
    created ➊. We’ll be able to easily convert this dictionary to a JSON string later.
  prefs: []
  type: TYPE_NORMAL
- en: Then we iterate over the utterance’s tokens ➋, looking for a direct object ➌.
    We might want a pizza, or we might ask someone to make us a pizza. In either case,
    “pizza” will be a direct object in our utterance so we’re hunting for a direct
    object here. Of course, a real implementation would make more checks.
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s found, we define a key-value pair in the orderdict dictionary, sending
    in product as the key and the direct object’s lemma as the value ➍. We use lemmatization
    to reduce the possible word forms of a product’s name to its base form (converting
    from plural to singular in most cases).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate over the direct object’s syntactic left children ➎, because
    that’s where we expect the information about the type of product requested. In
    terms of syntactic dependency labels, the product type can be either a compound
    or an adjectival modifier (amod) ➏. For example, spaCy would consider the word
    “Greek” in the phrase “a Greek pizza” an adjectival modifier, whereas it considers
    the word “Chicago” in the phrase “a Chicago pizza” a compound.
  prefs: []
  type: TYPE_NORMAL
- en: Now we check for the presence of a determiner in the children of the modifier
    or compound. The presence of the “a” determiner implies that a customer requests
    a single unit of a product ➐. In contrast, a word labeled with the dependency
    label nummod would indicate a particular number of units ➑.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the orderdict dictionary using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: print(orderdict)
  prefs: []
  type: TYPE_NORMAL
- en: 'This should give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a JSON string that we can send to an underlying database for further
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Number Words to Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before moving on to the code that will send your JSON string to a database,
    consider what it will look like when a user explicitly specifies the quantity
    of a product, as in the following utterance:'
  prefs: []
  type: TYPE_NORMAL
- en: I want two Greek pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put this into the previous script, you’d get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': two}'
  prefs: []
  type: TYPE_NORMAL
- en: In the first sample sentence, the value of the 'qty' key is a numeral. In the
    second, it’s a number spelled out as a word. At this stage, this difference doesn’t
    look like a problem. But the issue is that we must define a data type for each
    column of a relational table when we create it. Attempting to insert data of another
    type into that column will fail.
  prefs: []
  type: TYPE_NORMAL
- en: You should prepare your chatbot for the fact that customers will specify a product’s
    quantity in any way they like. To solve this problem, you’ll have to convert strings
    representing number words to their corresponding integer values.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, define a list containing numbers spelled in words and sorted in
    increasing order; then iterate over that list to find the correct number. In this
    example, we define a list for number words ranging from “zero” to “twenty,” which
    assumes we don’t expect that a customer will order more than twenty units of the
    same product with one transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to implement this conversion scenario as a function that takes either
    a number word or a number (in the latter case, no conversion is needed) and returns
    a number. We should then use the function to modify the script’s code in the preceding
    section. Here is what the implementation of such a function might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def word2int(numword):'
  prefs: []
  type: TYPE_NORMAL
- en: num = 0
  prefs: []
  type: TYPE_NORMAL
- en: '➋ try:'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ num = int(numword)
  prefs: []
  type: TYPE_NORMAL
- en: ➍ return num
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: ➎ pass
  prefs: []
  type: TYPE_NORMAL
- en: ➏ words = ["zero", "one", "two", "three", "four", "five", "six", "seven",
  prefs: []
  type: TYPE_NORMAL
- en: '"eight","nine", "ten", "eleven", "twelve", "thirteen", "fourteen",'
  prefs: []
  type: TYPE_NORMAL
- en: '"fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"]'
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for idx, word in enumerate(words):'
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if word in numword:'
  prefs: []
  type: TYPE_NORMAL
- en: num = idx
  prefs: []
  type: TYPE_NORMAL
- en: ➒ return num
  prefs: []
  type: TYPE_NORMAL
- en: 'The word2int() function takes a single parameter: either a number word to be
    converted to the correspondent digits or a number already, in which case we won’t
    need to convert it ➊. The function has to handle both cases, because we don’t
    know which one we’ll find in a customer’s utterance.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the try and except block to handle cases when no conversion is needed
    ➋. We check whether the input is an integer ➌, and if it is, all we have to do
    is return the input number as is ➍. Otherwise, we ignore an error caused by an
    attempt to treat a nonnumber value as an integer and move on to converting it
    to a number ➎.
  prefs: []
  type: TYPE_NORMAL
- en: We define a list of number words, starting from zero and listing them in increasing
    order ➏. Then we iterate over this list with the enumerate() method ➐, looking
    for the word the function received as input ➑. When we find the match, we return
    the iteration number (the index of the word in the list) as the digit representation
    of the input number word ➒.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the word2int() function definition to the previous script. Then move to
    the end of the script and find the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'elif child.dep_ == ''nummod'':'
  prefs: []
  type: TYPE_NORMAL
- en: orderdict.update(qty = child.text)
  prefs: []
  type: TYPE_NORMAL
- en: 'Change them as follows, using the word2int() function defined in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'elif child.dep_ == ''nummod'':'
  prefs: []
  type: TYPE_NORMAL
- en: orderdict.update(qty = word2int(child.text))
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how the script handles this sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: I want two Greek pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, you should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '{''product'': ''pizza'', ''ptype'': ''Greek'', ''qty'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the 'qty' field is now a digit, and we have a consistent format
    to send to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '***Preparing Your Database Environment***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To prepare your database environment, you need to install or obtain access to
    a database; create the components you’ll need in the database, such as a database
    schema, a table, and so on; and install a Python module that enables you to interact
    with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can choose any database that can receive and process JSON data,
    such as an Oracle database, this section uses MySQL. The MySQL database has a
    long history of supporting the most popular data interchange formats, which are
    XML and JSON. Also, MySQL is the world’s most popular open source database and
    is available on a majority of modern operating systems, including Linux, Windows,
    Unix, and macOS. MySQL has a freely downloadable version and commercial editions
    to meet specific business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, you can use MySQL Community Edition—the freely downloadable
    version available under the GPL license. To learn more about the MySQL Community
    Edition, visit its official page at *https://www.mysql.com/products/community/*.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll first need to install MySQL on your system. At the time of this writing,
    MySQL 8.0 is the most recent version. Refer to the “Installing and Upgrading MySQL”
    chapter at *[https://dev.mysql.com/doc/refman/8.0/en/installing.html](https://dev.mysql.com/doc/refman/8.0/en/installing.html)*
    in the MySQL 8.0 Reference Manual, or the equivalent chapter for future versions
    of MySQL. Here, you’ll find the detailed installation instructions for your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: After installation, you can start the MySQL server using the command the installation
    guide specifies for your operating system. Before you can start working with the
    database, you need to obtain a password for the mysql superuser (‘root’@‘localhost’)
    generated during the installation. You’ll find the password in the installation
    error log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the superuser password, you can connect to the MySQL server from
    a system terminal using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ mysql -uroot -p
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter password: ******'
  prefs: []
  type: TYPE_NORMAL
- en: mysql>
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to use a GUI, you can take advantage of MySQL Workbench (*[https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)*),
    which is a unified visual tool designed to model and manage MySQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'After connecting to the server, your first step is to choose a new password
    for the root user, replacing the random password generated during the installation.
    Use the following command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: ALTER USER 'root'@'localhost' IDENTIFIED BY 'Your-pswd';
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’re ready to start developing the infrastructure on the server that
    you need for your application. You’ll begin by creating a database that you’ll
    use as the container for the other objects the application needs to interact with.
    To create the database, enter the following command at the mysql> prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: mysql> CREATE DATABASE mybot;
  prefs: []
  type: TYPE_NORMAL
- en: Query OK, 1 row affected (0.03 sec)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then select the newly created database for use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: mysql> USE mybot;
  prefs: []
  type: TYPE_NORMAL
- en: Database changed
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re ready to start creating your database’s structure. For this example,
    you’ll need a single table you create with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE orders (
  prefs: []
  type: TYPE_NORMAL
- en: id INT NOT NULL AUTO_INCREMENT,
  prefs: []
  type: TYPE_NORMAL
- en: product VARCHAR(30),
  prefs: []
  type: TYPE_NORMAL
- en: ptype VARCHAR(30),
  prefs: []
  type: TYPE_NORMAL
- en: qty INT,
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY (id)
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'With this database infrastructure set up, you need to install the MySQL Connector/Python
    driver, which allows your Python code to interact with that infrastructure. On
    any operating system, you can install Connector/Python via pip, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: pip install mysql-connector-python
  prefs: []
  type: TYPE_NORMAL
- en: For further details on how to install this driver, check the documentation at
    *[https://dev.mysql.com/doc/connector-python/en/](https://dev.mysql.com/doc/connector-python/en/).*
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following simple script, ensure that you’ve installed Connector/Python:'
  prefs: []
  type: TYPE_NORMAL
- en: import mysql.connector
  prefs: []
  type: TYPE_NORMAL
- en: cnx = mysql.connector.connect(user='root', password='Your_pswd',
  prefs: []
  type: TYPE_NORMAL
- en: host='127.0.0.1',
  prefs: []
  type: TYPE_NORMAL
- en: database='mybot')
  prefs: []
  type: TYPE_NORMAL
- en: cnx.close()
  prefs: []
  type: TYPE_NORMAL
- en: If the install is successful, you should see no error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Data to the Underlying Database***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s return to the script we had on [page 134](../Text/ch09.xhtml#page_134).
    The following code connects to your database and passes order data to the orders
    table. Append this code to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: ➊ json_str = json.dumps(orderdict)
  prefs: []
  type: TYPE_NORMAL
- en: import mysql.connector
  prefs: []
  type: TYPE_NORMAL
- en: from mysql.connector import errorcode
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ cnx = mysql.connector.connect(user='root', password='Your_pswd',
  prefs: []
  type: TYPE_NORMAL
- en: host='127.0.0.1',
  prefs: []
  type: TYPE_NORMAL
- en: database='mybot')
  prefs: []
  type: TYPE_NORMAL
- en: ➌ query = ("""INSERT INTO orders (product, ptype, qty)
  prefs: []
  type: TYPE_NORMAL
- en: SELECT product, ptype, qty FROM
  prefs: []
  type: TYPE_NORMAL
- en: JSON_TABLE(
  prefs: []
  type: TYPE_NORMAL
- en: ➍ %s,
  prefs: []
  type: TYPE_NORMAL
- en: '"$" COLUMNS('
  prefs: []
  type: TYPE_NORMAL
- en: qty    INT PATH '$.qty',
  prefs: []
  type: TYPE_NORMAL
- en: product   VARCHAR(30) PATH "$.product",
  prefs: []
  type: TYPE_NORMAL
- en: ptype     VARCHAR(30) PATH "$.ptype"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ) AS jt1""")
  prefs: []
  type: TYPE_NORMAL
- en: ➎ cursor = cnx.cursor()
  prefs: []
  type: TYPE_NORMAL
- en: ➏ cursor.execute(query, ➐(json_str,))
  prefs: []
  type: TYPE_NORMAL
- en: ➑ cnx.commit()
  prefs: []
  type: TYPE_NORMAL
- en: '➒ except mysql.connector.Error as err:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error-Code:", err.errno)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Error-Message: {}".format(err.msg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'finally:'
  prefs: []
  type: TYPE_NORMAL
- en: cursor.close()
  prefs: []
  type: TYPE_NORMAL
- en: cnx.close()
  prefs: []
  type: TYPE_NORMAL
- en: We start by converting the orderdict dictionary into a JSON string ➊. Next,
    we connect to the database ➋ and define an insert SQL statement to be passed into
    the database for processing ➌. Note the use of a placeholder (called a *bind variable*)
    in the statement ➍. Using placeholders allows us to write SQL statements that
    accept inputs at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can execute the statement, we create a mysql.connector cursor object
    ➎, which enables operations over the objects in the database we’re connected to.
    Then we can execute the INSERT statement ➏, binding the JSON string ➐ we obtained
    in the beginning of this code snippet to the placeholder in the statement. Note
    the use of the JSON_TABLE function that shreds the submitted JSON data to tabular
    data, making it appropriate for inserting into a relational table.
  prefs: []
  type: TYPE_NORMAL
- en: After the execution of the INSERT statement, we need to explicitly commit the
    statement’s changes with the commit() method ➑. Otherwise, the insertion will
    roll back when the connection closes (either explicitly with cnx.close() or when
    the script’s execution is complete).
  prefs: []
  type: TYPE_NORMAL
- en: The except block will begin to execute if an error occurs on the database side
    ➒. In the next section, you’ll learn how to take advantage of this functionality
    when the JSON string passed in doesn’t contain all the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute the script. If you don’t see any error messages, return to the
    mysql prompt you worked with in the preceding section and enter the following
    select statement:'
  prefs: []
  type: TYPE_NORMAL
- en: mysql> SELECT * FROM orders;
  prefs: []
  type: TYPE_NORMAL
- en: ID   PRODUCT     PTYPE    QTY
  prefs: []
  type: TYPE_NORMAL
- en: '---- ----------- -------- ---'
  prefs: []
  type: TYPE_NORMAL
- en: 1    pizza       Greek    2
  prefs: []
  type: TYPE_NORMAL
- en: If you can see this output, your Python script is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '***When a User’s Request Doesn’t Contain Enough Information***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, a user’s request might not contain enough information to fill in
    all the fields in the order form. As an example, consider the following utterance:'
  prefs: []
  type: TYPE_NORMAL
- en: I want two pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](../Text/ch09.xhtml#ch09tab01) shows the order form the application
    discussed here will generate from this sentence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** An Order Form Missing Information'
  prefs: []
  type: TYPE_NORMAL
- en: '| **product** | **ptype** | **quantity** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| pizza |  | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'The value of the ptype field is missing because the user didn’t identify the
    type of pizza they want. To address this issue, enhance the INSERT statement in
    the previous script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: query = ("""INSERT INTO orders (product, ptype, qty)
  prefs: []
  type: TYPE_NORMAL
- en: SELECT product, ptype, qty FROM
  prefs: []
  type: TYPE_NORMAL
- en: JSON_TABLE(
  prefs: []
  type: TYPE_NORMAL
- en: '%s,'
  prefs: []
  type: TYPE_NORMAL
- en: '"$"'
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS(
  prefs: []
  type: TYPE_NORMAL
- en: qty    INT PATH '$.qty' ➊ERROR ON EMPTY,
  prefs: []
  type: TYPE_NORMAL
- en: product   VARCHAR(30) PATH "$.product" ➊ERROR ON EMPTY,
  prefs: []
  type: TYPE_NORMAL
- en: ptype     VARCHAR(30) PATH "$.ptype" ➊ERROR ON EMPTY
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ) AS jt1""");
  prefs: []
  type: TYPE_NORMAL
- en: We add the ERROR ON EMPTY option ➊ to each column in JSON_TABLE. This option
    allows us to handle errors caused by trying to insert a JSON string that doesn’t
    contain all the fields it’s supposed to contain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you execute the script with the “I want two pizzas.” sample sentence,
    you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error-Code: 3665'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error-Message: Missing value for JSON_TABLE column ''ptype'''
  prefs: []
  type: TYPE_NORMAL
- en: 'We could expand on the script so in such cases the chatbot asks the customer
    to clarify their order using the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: What type of pizza do you want?
  prefs: []
  type: TYPE_NORMAL
- en: 'An answer might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: I want Greek ones.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the sentence representing the answer we’re supposed to receive
    here is similar to the structure of the original sentence. Therefore, we can use
    the same code to analyze this answer that we used to analyze the original sentence.
    Of course, this approach makes assumptions about a user’s response. A real implementation
    would start with this approach and then, if necessary, move on to the other possible
    response structures. For example, a user’s response might consist of a single
    word, “Greek.” In that case, all we need to do is to check whether it’s included
    in our list of pizza types.
  prefs: []
  type: TYPE_NORMAL
- en: '***Try This***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The error message tells you what specific field is missing. But you still need
    to extract this field name from the message so you can ask the customer to clarify
    a specific part of their order. One way to do this is to look at the object of
    the preposition in the message. For example, in the message, Error-Message: Missing
    value for JSON_TABLE column ''ptype'', the object of the preposition is ptype.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to cut raw text into shreds to insert the text
    into a relational database. You used the JSON format to interact with a database
    that can process a JSON input, extracting it into relational data. You also learned
    to implement some application logic within the database with the help of pure
    SQL, allowing you to move data processing closer to the data. To implement more
    complicated scenarios, you might need to use triggers and stored procedures—the
    details can be found in the documentation for the database you’re using.
  prefs: []
  type: TYPE_NORMAL
