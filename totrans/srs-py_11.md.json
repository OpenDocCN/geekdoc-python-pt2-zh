["```py\nimport random\nimport threading\nresults = []\ndef compute():\n    results.append(sum(\n        [random.randint(1, 100) for i in range(1000000)]))\nworkers = [threading.Thread(target=compute) for x in range(8)] for worker in workers:\n    worker.start()\nfor worker in workers:\n    worker.join()\nprint(\"Results: %s\" % results)\n```", "```py\n$ time python worker.py\nResults: [50517927, 50496846, 50494093, 50503078, 50512047, 50482863,\n50543387, 50511493]\npython worker.py  13.04s user 2.11s system 129% cpu 11.662 total\n```", "```py\nimport multiprocessing\nimport random\n\ndef compute(n):\n    return sum(\n        [random.randint(1, 100) for i in range(1000000)])\n\n# Start 8 workers\npool = multiprocessing.Pool(processes=8)\nprint(\"Results: %s\" % pool.map(compute, range(8)))\n```", "```py\n$ time python workermp.py\nResults: [50495989, 50566997, 50474532, 50531418, 50522470, 50488087, 0498016, 50537899]\npython workermp.py  16.53s user 0.12s system 363% cpu 4.581 total\n```", "```py\nimport select\nimport socket\n\nserver = socket.socket(socket.AF_INET,\n                       socket.SOCK_STREAM)\n# Never block on read/write operations\nserver.setblocking(0)\n\n# Bind the socket to the port\nserver.bind(('localhost', 10000))\nserver.listen(8)\n\nwhile True:\n    # select() returns 3 arrays containing the object (sockets, files...)\n\n    # that are ready to be read, written to or raised an error\ninputs,\noutputs, excepts = select.select([server], [], [server])\n    if server in inputs:\n        connection, client_address = server.accept()\n        connection.send(\"hello!\\n\")\n```", "```py\nimport aiohttp\nimport asyncio\n\nasync def get(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return response\n\nloop = asyncio.get_event_loop()\n\ncoroutines = [get(\"http://example.com\") for _ in range(8)]\n\nresults = loop.run_until_complete(asyncio.gather(*coroutines))\n\nprint(\"Results: %s\" % results)\n```", "```py\n   import multiprocessing\n   import random\n   import zmq\n\n   def compute():\n       return sum(\n           [random.randint(1, 100) for i in range(1000000)])\n\n   def worker():\n       context = zmq.Context()\n       work_receiver = context.socket(zmq.PULL)\n       work_receiver.connect(\"tcp://0.0.0.0:5555\")\n       result_sender = context.socket(zmq.PUSH)\n       result_sender.connect(\"tcp://0.0.0.0:5556\")\n       poller = zmq.Poller()\n       poller.register(work_receiver, zmq.POLLIN)\n\n       while True:\n           socks = dict(poller.poll())\n           if socks.get(work_receiver) == zmq.POLLIN:\n               obj = work_receiver.recv_pyobj()\n               result_sender.send_pyobj(obj())\n\n   context = zmq.Context()\n   # Build a channel to send work to be done\n➊ work_sender = context.socket(zmq.PUSH)\n   work_sender.bind(\"tcp://0.0.0.0:5555\")\n   # Build a channel to receive computed results\n➋ result_receiver = context.socket(zmq.PULL)\n   result_receiver.bind(\"tcp://0.0.0.0:5556\")\n   # Start 8 workers\n   processes = []\n   for x in range(8):\n➌     p = multiprocessing.Process(target=worker)\n       p.start()\n       processes.append(p)\n   # Send 8 jobs\n   for x in range(8):\n       work_sender.send_pyobj(compute)\n   # Read 8 results\n\n   results = []\n   for x in range(8):\n➍     results.append(result_receiver.recv_pyobj()) # Terminate all processes\n   for p in processes:\n       p.terminate()\n   print(\"Results: %s\" % results)\n```"]