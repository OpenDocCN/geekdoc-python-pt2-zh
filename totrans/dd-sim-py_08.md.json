["```py\nimport random\n\ndef roll_dice(sides):\n    return random.randint(1, sides)\n```", "```py\nprint(\"Roll for initiative...\")\nplayer1 = ❶ roll_dice(20)\nplayer2 = roll_dice(20)\nif player1 >= player2:\n    print(f\"Player 1 goes first (rolled {player1}).\")\nelse:\n    print(f\"Player 2 goes first (rolled {player2}).\")\n```", "```py\nimport random\n\ndef roll_dice(sides, dice):\n    **return tuple(random.randint(1, sides) for** ****_ in range(dice))****\n```", "```py\nprint(\"Roll for initiative...\")\nplayer1**, player2** = roll_dice(20**, 2**)\nif player1 >= player2:\n    print(f\"Player 1 goes first (rolled {player1}).\")\nelse:\n    print(f\"Player 2 goes first (rolled {player2}).\")\n```", "```py\nimport random\n\ndef roll_dice(sides, dice):\n    **if dice < 1:**\n        **return ()**\n    roll = random.randint(1, sides)\n    return **(roll, ) + roll_dice(sides, dice-1)**\n```", "```py\ndice_cup = roll_dice(6, 5)\nprint(dice_cup)\n```", "```py\n()\n(2,)\n(3, 2)\n(6, 3, 2)\n(4, 6, 3, 2)\n(4, 4, 6, 3, 2)\n```", "```py\nRecursionError: maximum recursion depth exceeded while calling a Python object\n```", "```py\n if dice < 1:\n        return ()\n```", "```py\nimport sys\nsys.setrecursionlimit(2000)\n```", "```py\nresult, = roll_dice(20, 1)\n```", "```py\nimport random\n\ndef roll_dice(sides, dice**=1**):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\nresult, = roll_dice(6)\n```", "```py\nplayer1, player2 = roll_dice(20, 2)\n```", "```py\ndef fibonacci_next(series ❶ =[1, 1]):\n  ❷ series.append(series[-1] + series[-2])\n    return series\n```", "```py\nfib1 = fibonacci_next()\nprint(fib1)  # prints [1, 1, 2]\nfib1 = fibonacci_next(fib1)\nprint(fib1)  # prints [1, 1, 2, 3]\n\nfib2 = fibonacci_next()\nprint(fib2)  # should be [1, 1, 2] riiiiight?\n```", "```py\n[1, 1, 2]\n[1, 1, 2, 3]\n[1, 1, 2]\n```", "```py\n[1, 1, 2]\n[1, 1, 2, 3]\n[1, 1, 2, 3, 5]\n```", "```py\ndef fibonacci_next(series**=None**):\n    **if series is None:**\n        **series = [1, 1]**\n    series.append(series[-1] + series[-2])\n    return series\n```", "```py\n[1, 1, 2]\n[1, 1, 2, 3]\n[1, 1, 2]\n```", "```py\ndice_cup = roll_dice(6, 5)\n```", "```py\ndice_cup = roll_dice(**sides=6, dice=5**)\n```", "```py\ndice_cups = roll_dice(**dice=5, sides=6**)\n```", "```py\nimport random\n\ndef roll_dice(sides=6, dice=1):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\ndice_cups = roll_dice(**dice=5**)\n```", "```py\ndice_cups = roll_dice(6**, dice=5**)\n```", "```py\nimport random\n\ndef roll_dice(*dice):\n    return tuple(random.randint(1, d) for d in dice)\n```", "```py\ndice_cup = roll_dice(6, 6, 6, 6, 6)\nprint(dice_cup)\n\nbunch_o_dice = roll_dice(20, 6, 8, 4)\nprint(bunch_o_dice)\n```", "```py\ndef roll_dice(*dice):\n **if dice:**\n **roll = random.randint(1, dice[0])**\n **return (roll,) + roll_dice(**❶ ***dice** ❷ **[1:])**\n **return ()**\n```", "```py\ndef call_something_else(func, *args, **kwargs):\n    return func(*args, **kwargs)\n```", "```py\ndef say_hi(name):\n    print(f\"Hello, {name}!\")\n\ncall_something_else(say_hi, name=\"Bob\")\n```", "```py\nHello, Bob!\n```", "```py\nimport random\n\ndef roll_dice(*, sides=6, dice=1):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\ndice_cup = roll_dice(sides=6, dice=5)\nprint(dice_cup)\n```", "```py\ndice_cup = roll_dice(6, 5)  # raises TypeError\nprint(dice_cup) \n```", "```py\nimport random\n\ndef roll_dice(dice=1, /, sides=6):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\nroll_dice(4, 20)             # OK; dice=4, sides=20\nroll_dice(4)                 # OK; dice=4, sides=6\nroll_dice(sides=20)          # OK; dice=1, sides=20\nroll_dice(4, sides=20)       # OK; dice=4, sides=20\n\nroll_dice(dice=4)            # TypeError\nroll_dice(dice=4, sides=20)  # TypeError\n```", "```py\ndef func(pos_only=None, /, pos_kw=None, *, kw_only=None):\n```", "```py\nimport random\n\ndef roll_dice(sides**=6**, dice**=1**):\n    **def roll():**\n        **return** random.randint(1, sides)\n\n    if dice < 1:\n        return ()\n    return (**roll()**, ) + roll_dice(sides, dice-1)\n```", "```py\ndice_cup = roll_dice(**sides=**6, **dice=**5)\nprint(dice_cup)\n```", "```py\nimport random\n\ndef make_dice_cup(sides=6, dice=1):\n    def roll():\n        return tuple(random.randint(1, sides) for _ in range(dice))\n\n  ❶ return roll\n```", "```py\nroll_for_damage = make_dice_cup(sides=8, dice=5)\ndamage = roll_for_damage()\nprint(damage)\n```", "```py\nimport random\n\ndef make_dice_cup(sides=6, dice=1):\n    def roll():\n        nonlocal dice\n        if dice < 1:\n            return ()\n        die = random.randint(1, sides)\n        dice -= 1\n        return (die, ) + roll()\n\n    return roll\n```", "```py\nroll_for_damage = make_dice_cup(sides=8, dice=5)\ndamage = roll_for_damage()\nprint(damage)\n\ndamage = roll_for_damage()\nprint(damage)\n```", "```py\n(1, 3, 4, 3, 7)\n()\n```", "```py\nimport random\n\ndef make_dice_cup(sides=6, dice=1):\n    def roll(**dice=dice**):\n        if dice < 1:\n            return ()\n        die = random.randint(1, sides)\n        return (die, ) + roll(**dice - 1**)\n\n    return roll\n```", "```py\nimport random\n\ndef start_turn(limit, dice=5, sides=6):\n    def roll():\n        nonlocal limit\n        if limit < 1:\n            return None\n        limit -= 1\n        return tuple(random.randint(1, sides) for _ in range(dice))\n\n    return roll\n```", "```py\nturn1 = start_turn(limit=3)\nwhile toss := turn1():\n    print(toss)\n\nturn2 = start_turn(limit=3)\nwhile toss := turn2():\n    print(toss)\n```", "```py\n(4, 1, 2, 1, 1)\n(4, 2, 3, 1, 5)\n(1, 6, 3, 4, 2)\n(1, 6, 4, 5, 5)\n(2, 1, 4, 5, 3)\n(2, 4, 1, 6, 1)\n```", "```py\nlambda x, y: x + y\n```", "```py\nadd = lambda x, y: x + y\nanswer = add(20, 22)\nprint(answer)  # outputs \"42\"\n```", "```py\nimport random\n\nhealth = 10\nxp = 10\n```", "```py\ndef attempt(action, min_roll, ❶ outcome):\n    global health, xp\n    roll = random.randint(1, 20)\n    if roll >= min_roll:\n        print(f\"{action} SUCCEEDED.\")\n        result = True\n    else:\n        print(f\"{action} FAILED.\")\n        result = False\n\n    scores = ❷ outcome(result)\n    health = health + scores[0]\n    print(f\"Health is now {health}\")\n    xp = xp + scores[1]\n    print(f\"Experience is now {xp}\")\n\n    return result\n```", "```py\ndef eat_bread(success):\n    if success:\n        return (1, 0)\n    return (-1, 0)\n\ndef fight_ice_weasel(success):\n    if success:\n        return (0, 10)\n    return (-10, 10)\n\n❶ attempt(\"Eating bread\", 5, eat_bread)\nattempt(\"Fighting ice weasel\", 15, fight_ice_weasel)\n```", "```py\nattempt(\"Eating bread\", 5,\n        **lambda success: (1, 0) if success else (-1, 0)**)\n\nattempt(\"Fighting ice weasel\", 15,\n        **lambda success: (0, 10) if success else (-10, 10)**)\n```", "```py\nlambda success: (1, 0) if success else (-1, 0))\n```", "```py\npeople = [\n    (\"Jason\", \"McDonald\"),\n    (\"Denis\", \"Pobedrya\"),\n    (\"Daniel\", \"Foerster\"),\n    (\"Jaime\", \"López\"),\n    (\"James\", \"Beecham\")\n]\n\nby_last_name = sorted(people, ❶ key=lambda x: x[1])\nprint(by_last_name)\n```", "```py\nimport random\n\ncharacter = \"Sir Bob\"\nhealth = 15\nxp = 0\n```", "```py\ndef eat_food(food):\n    global health\n  ❶ if health <= 0:\n        print(f\"{character} is too weak.\")\n        return\n\n    print(f\"{character} ate {food}.\")\n    health += 1\n  ❷ print(f\"    Health: {health} | XP: {xp}\")\n\ndef fight_monster(monster, strength):\n    global health, xp\n  ❸ if health <= 0:\n        print(f\"{character} is too weak.\")\n        return\n\n    if random.randint(1, 20) >= strength:\n        print(f\"{character} defeated {monster}.\")\n        xp += 10\n    else:\n        print(f\"{character} flees from {monster}.\")\n        health -= 10\n        xp += 5\n  ❹ print(f\"    Health: {health} | XP: {xp}\")\n```", "```py\neat_food(\"bread\")\nfight_monster(\"Imp\", 15)\nfight_monster(\"Direwolf\", 15)\nfight_monster(\"Minotaur\", 19)\n```", "```py\n❶ **import functools**\nimport random\n\ncharacter = \"Sir Bob\"\nhealth = 15\nxp = 0\n\n**def character_action(func):**\n  ❷ **@functools.wraps(func)**\n  ❸ **def wrapper(*args, **kwargs):**\n **if health <= 0:**\n **print(f\"{character} is too weak.\")**\n **return**\n\n **result = func(*args, **kwargs)**\n **print(f\"    Health: {health} | XP: {xp}\")**\n **return result**\n\n  ❹ **return wrapper**\n```", "```py\n**@character_action**\ndef eat_food(food):\n    global health\n    print(f\"{character} ate {food}.\")\n    health += 1\n\n**@character_action**\ndef fight_monster(monster, strength):\n    global health, xp\n    if random.randint(1, 20) >= strength:\n        print(f\"{character} defeated {monster}.\")\n        xp += 10\n    else:\n        print(f\"{character} flees from {monster}.\")\n        health -= 10\n        xp += 5\n```", "```py\nanswer: int = 42\n```", "```py\nimport random\n**import typing**\n\ndef roll_dice(sides**: int** = 6, dice**: int** = 1) **-> typing.Tuple[int, ...]**:\n    # `--snip--`\n```", "```py\nimport random\nimport typing\n\n**TupleInts = typing.Tuple[int, ...]**\n\ndef roll_dice(sides: int = 6, dice: int = 1) -> **TupleInts**:\n    # `--snip--`\n```", "```py\nmypy dice_roll.py\n```", "```py\ndef search(within: typing.Iterable[typing.Any]):\n```"]