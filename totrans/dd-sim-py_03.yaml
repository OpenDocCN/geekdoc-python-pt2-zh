- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your Workbench
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Your development environment is a major factor in how productive you’ll be in
    a language. Instead of contenting yourself with a bare-bones default shell, you’ll
    want to assemble a development environment worthy of any production-level project.
  prefs: []
  type: TYPE_NORMAL
- en: A good Python development environment usually consists of the language interpreter,
    the pip package manager, a *virtual environment*, a Python-oriented code editor,
    and one or more *static analyzers* to check your code for errors and problems.
    I’ll discuss each of these in this chapter. I’ll also introduce the style conventions
    common in Python and round out the chapter with a guided tour of the most common
    Python integrated development environments (IDEs).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can do anything, you have to install Python itself, along with a
    couple of essential tools. As you know from Chapter 1, Python is an interpreted
    language, so you’ll need to install its *interpreter*. You must also install pip,
    the Python package manager, so you can install additional Python tools and libraries.
    The exact steps for setup depend on your platform, but I will cover the major
    platforms here.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’m using Python 3.9, the latest version at the time of writing.
    If you’re reading this at a later date, just use the latest stable release of
    Python 3\. All the instructions should work the same. You need only replace the
    version number in the obvious ways on any commands run in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: This is merely a quick guide to installation. For the complete, official instructions,
    which cover many more situations and advanced options, see [https://docs.python.org/using/](https://docs.python.org/using/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Windows, Python is not generally installed by default, so you’ll need to
    download it yourself from [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    and run that installer. On the first screen of the installer, be sure you check
    the boxes for **Install the launcher for all users** and **Add Python to PATH**.
  prefs: []
  type: TYPE_NORMAL
- en: Python is also available through the Windows App Store. However, as of the date
    of my writing, this particular installation method is still officially considered
    unstable. I recommend downloading the official installer instead.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On macOS, you can use either MacPorts or Homebrew to install Python and pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following commands to install Python and pip with MacPorts, replacing
    the `38` with whatever version you want to download (removing the decimal point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, here’s the command to install both Python and pip in one step
    with Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use only one of the two methods described above.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re running a Linux operating system, chances are that Python (`python3`)
    is installed by default, although the other tools you need may not be. (I’ll show
    you how to install Python anyway, just to be on the safe side.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Python and pip on Ubuntu, Debian, or related, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On Fedora, RHEL, or CentOS, you can run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On Arch Linux, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For other distributions, you’ll need to search for the Python 3 and pip packages
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Installing from Source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re running a UNIX-like system, and if your system either has an outdated
    version of Python 3 in the system packages or lacks a package manager altogether,
    you can build Python from source. This is how I usually install the latest Python.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On macOS, there are some relatively complex considerations when it comes to
    installing Python’s build dependencies. You should consult the documentation at
    [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x).
  prefs: []
  type: TYPE_NORMAL
- en: On most Linux systems, you will need to make sure you have the development files
    for several libraries that Python relies upon. The best way to install these depends
    on your system and, more specifically, which package manager you use.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on a Linux distribution that uses the APT package manager—such as
    Ubuntu, Pop!_OS, Debian, or Linux Mint—then you should either check the box to
    enable Source Code as a source in your Software Sources or Software & Updates
    settings or make sure you have it included in your *sources.list* file. (The exact
    method depends on your system, and that topic is beyond the scope of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you get the message `Unable to find a source package for python3.9`, change
    the `9` to a lower (or higher) number until you find one that works. The dependencies
    for Python 3 don’t really change much between minor versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Linux distribution uses the DNF package manager, such as if you’re
    on modern Fedora, RHEL, or CentOS, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re on an older version of Fedora or RHEL that uses the yum package manager,
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you’re on SUSE Linux, you’ll have to install the dependencies, including
    needed libraries, one by one. [Table 2-1](#table2-1) lists these dependencies.
    If you’re on another UNIX-based system, this list will be helpful, although you
    may need to change the package names or build the dependencies from source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: Python 3 Build Dependencies According to SUSE Linux'
  prefs: []
  type: TYPE_NORMAL
- en: '| automake | intltool | netcfg |'
  prefs: []
  type: TYPE_TB
- en: '| fdupes | libbz2-devel | openssl-devel |'
  prefs: []
  type: TYPE_TB
- en: '| gcc | libexpat-devel | pkgconfig |'
  prefs: []
  type: TYPE_TB
- en: '| gcc-c++ | libffi-devel | readline-devel |'
  prefs: []
  type: TYPE_TB
- en: '| gcc-fortran | libnsl-devel | sqlite-devel |'
  prefs: []
  type: TYPE_TB
- en: '| gdbm-devel | lzma-devel | xz |'
  prefs: []
  type: TYPE_TB
- en: '| gettext-tools | make | zlib-devel |'
  prefs: []
  type: TYPE_TB
- en: '| gmp-devel | ncurses-devel |  |'
  prefs: []
  type: TYPE_TB
- en: Downloading and Building Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can download the Python source as a Gzipped source tarball, which is a compressed
    file (*.tgz*), from [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/).
    I usually like to move this tarball file into a dedicated directory for Python
    source tarballs, especially as I tend to have multiple versions of Python at any
    one time. Within that directory, extract (uncompress) this file with `tar -xzvf
    Python-3.x.x.tgz`, substituting the name of the tarball you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, from within the extracted directory, run the following, ensuring that
    each command succeeds before running the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This should configure Python for normal use, ensure it won’t encounter any errors
    in the current environment, and then install it *alongside* any existing Python
    installations.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, you can use Python right away.
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Interpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve installed that interpreter, you can run Python scripts and projects.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The interpreter’s *interactive session* allows you to enter and run code in
    real time and see the outcomes. You can start an interactive session on the command
    line with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the above should work on Windows, the same as on any other system,
    the Python documentation recommends the following alternative on Windows instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just to keep everything system-agnostic, I’ll use `python3` throughout the rest
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start the interactive session, you should see something that looks
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter any Python code you want at the prompt `>`, and the interpreter will
    run it immediately. You can even enter multiline statements, such as conditional
    statements, and the interpreter will know more lines are expected before it runs
    the code. You’ll see the three-dot (`...`) prompt when the interpreter is waiting
    for more lines. When you’re done, press Enter on a blank line, and the interpreter
    will run the whole block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To quit the interactive session, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The interactive session is useful for testing things out in Python, but not
    much else. You should know of its existence moving forward, but I won’t use it
    much in this book. Instead, you should be using a proper code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You write scripts and programs in a text or code editor. I’ll introduce several
    code editors and IDEs at the end of this chapter, but in the meantime, you can
    use your favorite text editor for writing your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python code is written in *.py* files. To run a Python file (*myfile.py*, for
    example), you’d use this in the command line (*not* the interpreter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Packages and Virtual Environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *package* is a collection of code, which is analogous to a library in most
    other programming languages. Python is rather famous for being “batteries included,”
    since most things “just work” with a simple `import` statement. But if you need
    to do something beyond the basics, such as creating a snazzy user interface, you
    often have to install a package.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, installing most third-party libraries is easy. Library authors bundle
    their libraries into packages, which can be installed using the handy little pip
    package manager tool that we installed earlier. I’ll cover that tool later.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple third-party packages requires a bit of finesse. Some packages
    require other packages to be installed first. Certain packages have conflicts
    with other packages. You can also install specific versions of a package, depending
    on what exactly you need. Did I mention that some of the applications and operating
    system components on your computer rely on certain Python packages? This is why
    virtual environments exist.
  prefs: []
  type: TYPE_NORMAL
- en: A *virtual environment* is a sandbox where you can install only the Python packages
    you need for a particular project, without the risk of those packages clashing
    with those for another project (or your system). You create different little sandboxes
    for each project and install only the packages you want in it. Everything stays
    neatly organized. You never actually change what Python packages are installed
    on your system, so you avoid breaking important things that have nothing to do
    with your project.
  prefs: []
  type: TYPE_NORMAL
- en: You may even create virtual environments that have nothing to do with a particular
    project. For example, I have a dedicated virtual environment for running random
    code files in Python 3.10, with a particular set of tools I use for finding problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Virtual Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each virtual environment resides in a dedicated directory. Conventionally, we
    name this folder *env* or *venv*.
  prefs: []
  type: TYPE_NORMAL
- en: For each project, I typically like to create a dedicated virtual environment
    inside the project folder. Python provides a tool called *venv* for this.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Git or another *version control system* *(VCS)* for tracking changes
    to your code, there’s an additional setup step I’ll get to in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the virtual environment with the name `venv` in the current working
    directory, run the following command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `venv` ❶ is a command that creates a virtual environment, and the
    second `venv` ❷ is the desired path to the virtual environment. In this case,
    `venv` is just a relative path, creating a *venv/* directory in the current working
    directory. However, you could also use an absolute path, and you could call it
    whatever you want. For example, you could create a virtual environment called
    *myvirtualenv* in the */opt* directory of a UNIX system, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note, I’m specifying `python3` here, although I can run this with whatever Python
    version I want to use, such as `python3.9 -m venv venv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use something older than Python 3.3, make sure you install your system’s
    `virtualenv` package and then use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now if you look at your working directory, you’ll notice that the directory
    *venv/* has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Activating a Virtual Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use your virtual environment, you need to activate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On UNIX-like systems, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you use PowerShell on Windows, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Some PowerShell users must first run `set-executionpolicy RemoteSigned` for
    virtual environments to work on Windows PowerShell. If you run into trouble, try
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Like magic, you’re now using your virtual environment! You should see `(venv)`
    at the start of your command line prompt (not at the end), to indicate that you’re
    using a virtual environment named `venv`.
  prefs: []
  type: TYPE_NORMAL
- en: While inside your virtual environment, you can still access all the same files
    on your system that you use outside the virtual environment, but your environment
    *paths* will be overridden by the virtual environment. Practically speaking, any
    packages you install in the virtual environment are only usable there, and from
    the `venv`, the system-wide packages cannot be accessed unless you explicitly
    specify otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the virtual environment to also see the system-wide packages, you
    can do so with a special flag, which has to be set when you first create the virtual
    environment. You can’t change this after the virtual environment is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Leaving a Virtual Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get out of the virtual environment and back to reality . . . er, *ahem*,
    the system, you need a simple command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You ready for this, UNIX users? Just run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That really is it. The same works for Windows PowerShell users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things are only slightly more complicated on the Windows command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Still pretty painless. Remember, like with activation, if you named your virtual
    environment something else, you’d have to change the `venv` in that line accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing pip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of us have great expectations for Python’s package system. Python’s package
    manager is *pip*, which usually makes package installation trivial, especially
    in virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: System-Wide Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember, for any Python development work, you should almost always work in
    virtual environments. This will ensure that you’re always using the right packages
    for your work, without potentially messing up which packages (and versions thereof)
    are available to other programs on your computer. If you absolutely, positively
    know you want to install packages in your system-wide Python environment, you
    may use pip for that as well. First, make sure you are *not* working in a virtual
    environment, and then use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `command` with your pip commands, which I’ll cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install a package, run `pip install` `package`. For example, to install
    PySide6 within an activated virtual environment, you’d use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to install a specific version of something, append two equal signs
    (`==`), followed by the desired version number (no spaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Bonus: you can even use operators like `>=`, to mean “at least this version
    or greater.” These are called *requirement specifiers*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That line would install the latest version of PySide6 that is at least version
    `6.1.2`. This is really helpful if you want the most recent version of a package
    but also want to ensure you at least install a *minimum* version of a package
    (you might not). If it isn’t possible to install a version of the package that
    meets the requirement, pip will display an error message.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on a UNIX-like system, you may need to use `pip install "PySide6>=6.1.2"`
    instead, since `>` has another meaning in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: requirements.txt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can save even more time for yourself and others by writing a *requirements.txt*
    file for your project. This file lists the packages your project needs. When creating
    a virtual environment, you and other users can install all the required packages
    with a single command, using this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this file, list the name of a pip package, as well as its version
    (if required), on each line. For example, one of my projects has a *requirements.txt*
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: *requirements.txt*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now anyone can install all those packages in one shot with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I’ll revisit *requirements.txt* in Chapter 18, when I cover packaging and distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can update an already-installed package with pip as well. For example,
    to update to the latest version of PySide6, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a *requirements.txt* file, you can also upgrade all your required
    packages at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Removing Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can remove packages with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Replace `package` with the package name.
  prefs: []
  type: TYPE_NORMAL
- en: There is one minor wrinkle. Installing one package will also install any other
    packages it relies upon, which we call its *dependencies*. Uninstalling a package
    does not remove its dependencies, so you may need to go through and remove them
    yourself. This can get tricky, since multiple packages may share dependencies
    and you therefore risk breaking a separate package.
  prefs: []
  type: TYPE_NORMAL
- en: Herein lies one more advantage of virtual environments. Once I’m in that sort
    of a pickle, I can delete the virtual environment, create a new one, and install
    only those packages I need.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Great, so now you can install, upgrade, and remove things. But how do you even
    know what packages pip has to offer?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to find out. The first is to use pip itself to run a search.
    Say you want a package for web scraping. Run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That will give you a whole ton of results to sift through, but it’s helpful
    at those times when you simply forget the name of a package.
  prefs: []
  type: TYPE_NORMAL
- en: If you want something a lot more browsable and informative, [https://pypi.org/](https://pypi.org/%20)
    is the official Python Package Index.
  prefs: []
  type: TYPE_NORMAL
- en: One Warning About pip . . .
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless you have expertise in the full technical implications, ***never*** use
    `sudo pip` on a UNIX-like system! It can do so many bad things to your system
    installation—things that your system package manager cannot correct—that if you
    decide to use it, you will regret it for the remainder of your system’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when someone thinks they need to use `sudo pip`, they should really
    use `python3 -m pip` or `pip install --user` to install to their local user directory.
    Most other problems can be solved with virtual environments. Unless you’re an
    expert who fully understands what you’re doing and how to reverse it, don’t *ever*
    use `sudo pip`!
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Environments and Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with virtual environments and a VCS, like Git, can be tricky. Within
    a virtual environment’s directory are the *actual packages* you installed with
    pip. Those would clutter up your VCS repository with big, unnecessary files, and
    you can’t necessarily copy a virtual environment folder from one computer to another
    and expect it to work anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, you *don’t* want to track these files in your VCS. There are two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Only create virtual environments outside of your repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Untrack the virtual environment directory in the VCS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are arguments in favor of both rules, but which one you should use really
    depends on your project, environment, and particular needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using Git, create or edit a file called *.gitignore* in the root
    directory of your repository. Add this line somewhere in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: *.gitignore*'
  prefs: []
  type: TYPE_NORMAL
- en: If you used a different name for your virtual environment, change that line
    to match. If you’re using a different VCS, like Subversion or Mercurial, check
    the documentation to see how to ignore a directory like *venv*.
  prefs: []
  type: TYPE_NORMAL
- en: Conventionally, every developer who clones your repository will build their
    own virtual environment, probably using that *requirements.txt* file you provided.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you plan to place your virtual environments outside of the repository,
    it’s good to use your *.gitignore* file, just as a little extra insurance. Best
    VCS practice is to handpick which files to commit, but mistakes happen. Since
    *venv* is one of the most conventional names for a virtual environment directory,
    adding it to the *.gitignore* at least helps prevent some accidental commits.
    If your team has other standard names for virtual environments, you might consider
    adding those as well.
  prefs: []
  type: TYPE_NORMAL
- en: The Whole Shebang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many users and developers who might be running your code will also be using
    virtual environments. Yet all of this can come apart at the seams very easily
    if the very first line of your Python file is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m talking about the *shebang*, a special command at the top of a Python file,
    by which you can make that file directly executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: *hello_world.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shebang (short for haSH-BANG, or `#!`) ❶ provides the path to the Python
    interpreter. While it’s optional, I strongly recommend including it in your code,
    as it means the file can be marked as executable and run directly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is helpful, but as I’ve hinted before, one must be careful with shebangs.
    A shebang tells the computer where to find the exact Python interpreter to use,
    so the wrong shebang can break out of the confines of a virtual environment or
    even point to a version of the interpreter that isn’t installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have seen this kind of shebang in the wild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: *shebang.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: That line is terribly wrong, because it forces the computer to use a particular
    system-wide copy of Python. Again, that dismisses the entire purpose of a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you should always use this shebang for any Python file that only runs
    with Python 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: *shebang.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you happen to have a script which runs in *both* Python 2 and Python 3,
    use this shebang instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: *shebang.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: The rules about shebangs and how they are handled are officially outlined in
    PEP 394 (for UNIX-like systems) and PEP 397 (for Windows systems). Regardless
    of which system you develop for, it’s good to understand the implications of shebangs
    in both UNIX and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: File Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Python 3.1, all Python files have used the *UTF-8 encoding*, allowing
    the interpreter to use all of the characters in Unicode. (Prior to that version,
    the default was to use the old ASCII encoding.)
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use a different encoding system, instead of the default UTF-8,
    you need to tell the Python interpreter that outright.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to use Latin-1 encoding in a Python file, include this line at
    the top of your file, right below the shebang. To work, it must be on the first
    or second line—that’s where the interpreter looks for this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you want another encoding system, replace `latin-1` with whatever you need.
    If you specify an encoding that Python doesn’t recognize, it will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the preceding is the conventional way to specify encoding, there are
    two other valid ways to write the above comment. You can use this form, without
    the hard-to-remember `-*-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use this longer but more English-like form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Whatever you use, it must be *exactly* as shown above, except for swapping `latin-1`
    for whatever encoding you want. For this reason, the first or second forms are
    preferred.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more, read PEP 263, which defined this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you’ll be fine using the default UTF-8 encoding anyway; if
    you need something else, now you know how to inform the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: A Few Extra Virtual Environment Tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you get used to using virtual environments and pip, you’ll pick up additional
    tricks and tools to make the whole process easier. Here are a few of the more
    popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Virtual Environment Without Activating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the binaries that are a part of the virtual environment without
    activating it. For example, you can execute `venv/bin/python` to run the virtual
    environment’s own Python instance, or `venv/bin/pip` to run its instance of pip.
    It’ll work the same as if you had activated the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assuming my virtual environment is `venv`, I could do this in
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It works! Yet, `import pylint` still will not work on the system-wide Python
    interactive shell (unless, of course, you installed it on the system).
  prefs: []
  type: TYPE_NORMAL
- en: The Alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, I’ll be using pip and `venv`, as they’re the default tools
    for modern Python. However, there are a few other solutions out there worth looking
    into.
  prefs: []
  type: TYPE_NORMAL
- en: Pipenv
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number of Python developers swear by *Pipenv*, which combines both pip and
    `venv` into one cohesive tool, with many additional features.
  prefs: []
  type: TYPE_NORMAL
- en: Because the workflow is quite different, I won’t cover Pipenv here. If you’re
    interested in it, I recommend reading their superb documentation at [https://docs.pipenv.org/](https://docs.pipenv.org/).
    You’ll find comprehensive setup and usage instructions there, as well as a more
    detailed explanation of the advantages Pipenv offers.
  prefs: []
  type: TYPE_NORMAL
- en: pip-tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number of tasks in pip can be simplified with pip-tools, including automatic
    updating, aids for writing *requirements.txt*, and more.
  prefs: []
  type: TYPE_NORMAL
- en: If you use pip-tools, you should only install it within a virtual environment.
    It is designed specifically for that use case.
  prefs: []
  type: TYPE_NORMAL
- en: More information is available at [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: poetry
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some Python developers absolutely hate the entire pip workflow. One such developer
    created *poetry* as an alternative package manager. I don’t use it in this book,
    as it behaves very differently, but I’d be remiss not to point it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information, download directions (the creator does not recommend
    using pip to install it), and access documentation on their website: [https://python-poetry.org/](https://python-poetry.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to PEP 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike many languages, where style decisions are left entirely to the discretion
    of the community at large, Python does have an official style guide, which is
    published as *PEP 8*. Although the conventions in the guide are intended primarily
    for standard library code, many Python developers choose to stick to them as a
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'That doesn’t make them mandatory: if you have an objective reason to follow
    a different style convention in your project, that’s fine, although you should
    apply that style consistently, as much as is reasonable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8 itself makes this distinction clear, early on:'
  prefs: []
  type: TYPE_NORMAL
- en: A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is more important. Consistency within one module
    or function is the most important.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, know when to be inconsistent—sometimes, style guide recommendations
    just aren’t applicable. When in doubt, use your best judgment. Look at other examples
    and decide what looks best. And don’t hesitate to ask!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In practice, you’ll likely find very little reason to deviate from PEP 8\. The
    style guide is far from all-encompassing. It leaves plenty of breathing room,
    while making it clear what constitutes a good or bad coding style.
  prefs: []
  type: TYPE_NORMAL
- en: The Line Limit Debate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PEP 8 recommends a line limit of 79 characters, or an 80-character cutoff, though
    there’s a lot of debate on the topic. Some Python developers respect that rule,
    while others prefer cutoffs of 100 or 120 characters. What to do?
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common argument for longer limits is that modern monitors are wider
    and higher resolution. Surely, the 80-character limit is a relic of a bygone era,
    right? ***Definitely not!*** There are several reasons to stick to a common line
    limit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Vision-impaired individuals who must work with larger font sizes or zoomed-in
    interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing differences in a file between commits in a side-by-side diff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split-screen editors, displaying multiple files simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical monitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side-by-side windows on a laptop monitor, wherein the editor only has half its
    usual space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individuals with older monitors, who cannot afford to upgrade to the latest
    1080p monster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing code on mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing coding books for No Starch Press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In all of these scenarios, the reasoning behind the 80-character limit becomes
    apparent: there simply isn’t enough horizontal space for 120 characters or more
    per line. Soft text wrapping, wherein the remainder of a cut-off line appears
    on a separate line (without a line number), does solve some of these issues. However,
    it can be difficult to read, as many people forced to rely on it regularly will
    attest to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn’t mean that you have to follow this 79-character maximum religiously.
    There are exceptions. Above all, *readability* and *consistency* are the goals.
    Many developers embrace the 80/100 rule: an 80-character “soft” cutoff, you try
    to respect in most cases; and a 100-character “hard” cutoff, you reserve for all
    those cases where the lower limit would negatively impact readability.'
  prefs: []
  type: TYPE_NORMAL
- en: Tabs or Spaces?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ah yes, the civil war over which many friendships have been strained and many
    relationships have abruptly ended (okay, maybe just that one?). Most programmers
    have strong feelings on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 recommends spaces over tabs, but technically, it allows either. The important
    thing is to *never mix the two*. Use either spaces or tabs, and stick to it throughout
    your entire project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do use spaces, then there’s the debate about how many spaces to use.
    PEP 8 answers this question, too: *four spaces per indentation level*. Any less
    can negatively impact code readability, especially for people with visual impairments
    or some forms of dyslexia.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, most code editors are able to automatically enter four spaces when
    they press Tab, so there’s rarely an excuse to press space repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quality Control: Static Analyzers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful tools in any programmer’s toolkit is a reliable *static
    analyzer*, which reads your source code, looking for potential problems or deviations
    from the standards. If you’ve never used one before, now is the time to change
    that. One common type of static analyzer, called a *linter*, checks your source
    code for common mistakes, potential errors, and style inconsistencies. Two of
    the most popular linters are *Pylint* and *PyFlakes*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more kinds of static analyzers available for Python, including
    static type checkers like *Mypy* and complexity analyzers like *mccabe*.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover how to install all of these below, and I’ll discuss how to use many
    of them. I recommend you choose only one of these two linters and install the
    rest of the static analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: Pylint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pylint is perhaps the most versatile static analyzer in Python. It works decently
    well by default, and it allows you to customize exactly what you want it to look
    for and ignore.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the Pylint package with pip, which I recommend doing in a virtual
    environment. Once installed, you pass Pylint the name of a file you want analyzed,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also analyze an entire package or module at once. (I’ll define what
    modules and packages are in Chapter 4.) For example, if you want Pylint to analyze
    a package called `myawesomeproject` in the current working directory, you’d run
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Pylint will scan the files and display its warnings and recommendations on the
    command line. Then, you can edit your file and make the necessary changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: *cooking.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll run the linter on that file with the following in the system command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Pylint provides the following feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The linter found five errors in my code: both the module and the function are
    missing their docstrings (see Chapter 3). I tried to use the variables `eggs`
    and `order`, neither of which exist. I also assigned a value to the variable `ham`,
    but I never used that value anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If Pylint takes umbrage at a particular line of code you feel should be left
    as is, you can tell the static analyzer to ignore it and move on. You do this
    with a special comment, either inline on the line in question or at the top of
    the affected block. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: *cooking.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the first command, I tell Pylint not to alert me about the missing docstring
    on the module; that affects the entire block of code. The inline comment on the
    next line will suppress the warning about the missing docstring on the function,
    and it will only affect that line. If I ran the linter again, I’d only see the
    other two linter errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At this point, I’d edit my code and actually fix the rest of those problems.
    (Except I won’t, for this example.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also control Pylint’s project-wide behavior by creating a *pylintrc*
    file in the root directory of your project. To do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Find that file; open it; and edit it to turn on and off different warnings,
    ignore files, and define other settings. The documentation isn’t fantastic for
    this, but you can often work out what different options do from the comments in
    that *pylintrc* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run Pylint, it will look for a *pylintrc* (or *.pylintrc*) file in
    the current working directory. Alternatively, you can specify a different filename
    for Pylint to read its settings from, such as *myrcfile*, by passing the filename
    to the `--rcfile` option when invoking Pylint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Some regular users of Pylint like to create `.pylintrc` or `.config/pylintrc`
    in their home directory (UNIX-like systems only). If Pylint cannot find another
    configuration file, it will use the one in the home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Pylint documentation is far from comprehensive, it can still be
    useful. You can find it at [https://pylint.readthedocs.io/](https://pylint.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Flake8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Flake8* tool is actually a combination of three static analyzers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PyFlakes* is a linter, similar in purpose to Pylint. It is designed to work
    faster and to avoid false positives (both being common complaints about Pylint).
    It also ignores style rules, which are handled by the next tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pycodestyle* is a style checker, to help ensure you write PEP 8-compliant
    code. (This tool used to be called `pep8`, but it was renamed to avoid confusion
    with the actual style guide.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*mccabe* checks the McCabe (or Cyclomatic) complexity of your code. If you
    don’t know what that is, don’t worry—its purpose is essentially just to warn you
    when your code’s structure is getting too complicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install the Flake8 package with pip, which I typically do within a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To scan a file, module, or package, pass it to `flake8` on the command line.
    For example, to scan my earlier *cooking.py* file ([Listing 2-8](#listing2-8)),
    I’d use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: (You’ll notice that Flake8 isn’t complaining about the lack of docstrings; that’s
    disabled by default in this linter.)
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, only PyFlakes and pycodestyle are run. If you want to analyze the
    complexity of your code, you also need to pass the argument `--max-complexity`,
    followed by a number. Anything higher than `10` is considered too complex, but
    if you understand McCabe complexity, you can change this to suit your needs. So,
    for example, to check the complexity of the *cooking.py* file, you’d run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: However you run Flake8, you’ll get a comprehensive list of all the errors and
    warnings in your code.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to tell Flake8 to ignore something it thinks is a problem, you use
    a `# noqa` comment, followed by the error code to ignore. This comment should
    be inline, on the line where the error occurs. If you omit the error code, then
    `# noqa` will cause Flake8 to ignore all errors on that line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my code, if I wanted to ignore both of the errors I received, it might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: *cooking.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you see three different scenarios. First, I’m ignoring only warning `F841`.
    Second, I’m ignoring two errors (even though one of them isn’t actually raised;
    this is just a silly example). Third, I’m ignoring all possible errors.
  prefs: []
  type: TYPE_NORMAL
- en: Flake8 also supports configuration files. In the project directory, you can
    create a *.flake8* file. Start a section in that file with the line `[flake8]`,
    followed by all the Flake8 settings you want to define. (See the documentation.)
  prefs: []
  type: TYPE_NORMAL
- en: Flake8 will also accept project-wide configuration files called *tox.ini* or
    *setup.cfg*, so long as they have a `[flake8]` section within them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to automatically run mccabe each time you invoke Flake8,
    rather than specify `--max-complexity` every time, you could define a *.flake8*
    file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: *.flake8*'
  prefs: []
  type: TYPE_NORMAL
- en: Some developers like to define a system-wide configuration file for Flake8,
    which you can do (only) on a UNIX-like system. In your home folder, create the
    configuration file as either *.flake8* or *.config/flake8*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the chief advantages of Flake8 over Pylint is the documentation. Flake8
    has a complete list of their warnings, errors, options, and the like. You can
    find the documentation at [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Mypy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Mypy* is an unusual static analyzer because it focuses entirely on *type annotations*
    (see Chapter 6). Because it involves so many concepts I haven’t covered yet, I
    won’t go into much depth here.'
  prefs: []
  type: TYPE_NORMAL
- en: Still, now is a good time to get it installed. Like everything else so far,
    you can install the `mypy` package from pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, Mypy can be used by passing it the file, package, or module
    you wish to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Mypy will only attempt to check files that have type annotations, and it will
    ignore the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Style Janitors: Autoformatting Tools'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another tool you may find useful is an *autoformatter,* which can automatically
    change your Python code—spacing, indentation, and preferred equivalent expressions
    (such as `!=` instead of `<>`)—to be PEP 8 compliant. Two options are *autopep8*
    and *Black*.
  prefs: []
  type: TYPE_NORMAL
- en: autopep8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The autopep8 tool leverages pycodestyle (part of Flake8), even using the same
    configuration file as that tool to determine what style rules it ultimately follows
    or ignores.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you can install `autopep8` with pip.
  prefs: []
  type: TYPE_NORMAL
- en: By default, autopep8 only fixes whitespace, but if you pass the `--aggressive`
    argument to it, it will make additional changes. In fact, if you pass that argument
    twice, it will do even more. The complete list is beyond the scope of this explanation,
    so consult the documentation at [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix most PEP 8 issues on a Python code file by changing it in place (as
    opposed to making a copy, which is the default behavior), run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the file directly may sound a bit risky, but it really isn’t. Style
    changes are just that: style. They don’t affect the actual behavior of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Black
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Black tool is a little more straightforward: it assumes you want to follow
    PEP 8 in its entirety, and it doesn’t overwhelm you with many options as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like autopep8, you install `black` with pip, although it requires Python 3.6
    or later. To format a file with it, pass the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A complete list of Black’s few options can be seen via `black --help`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing frameworks form an essential part of any good development workflow,
    but I won’t go into detail about them in this chapter. Python has three major
    options for testing frameworks: *Pytest*, *nose2*, and *unittest*, in addition
    to a promising new project called *ward*. All of these can be installed with pip.'
  prefs: []
  type: TYPE_NORMAL
- en: More knowledge is essential to cover this topic effectively, so I’ll revisit
    it in Chapter 20.
  prefs: []
  type: TYPE_NORMAL
- en: An Exhibition of Code Editors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have your Python interpreter, your virtual environments, your static analyzers,
    and other such tools. Now you are prepared to write code.
  prefs: []
  type: TYPE_NORMAL
- en: You can write Python in any basic text editor, just as you could with practically
    any other programming language. Yet you’ll probably have an easier time writing
    production-quality code with a proper code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Before I end this chapter, I want to take you on a tour of several of the most
    popular Python code editors and integrated development environments (*IDEs*) available.
    This is only a sampling, as there are many more options besides. **If you already
    know what code editor or IDE you want to use, skip forward to the last section
    of this chapter.**
  prefs: []
  type: TYPE_NORMAL
- en: IDLE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has its own IDE, called *IDLE*, which ships with the standard distribution
    of Python. It’s a fairly bare-bones IDE with two components: an editor and an
    interface for the interactive shell. You could do worse than IDLE, so if you aren’t
    in the mood to install a different editor right now, start here. However, I recommend
    exploring your options, as most editors and IDEs have a host of useful features
    that IDLE lacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Emacs and Vim
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purists and old-school hackers among you will be glad to know that Emacs
    and Vim both have excellent Python support. Setting up either is not for the faint
    of heart, so I’m not going into any of that here.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re already a lover of either (or both?) code editors, you can find excellent
    tutorials for both at Real Python.
  prefs: []
  type: TYPE_NORMAL
- en: For Emacs, see [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/).
  prefs: []
  type: TYPE_NORMAL
- en: For Vim, see [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/).
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to “The State of Developer Ecosystem 2021” developer survey by JetBrains,
    the PyCharm IDE from JetBrains is far and away the most popular option for Python
    programming. It comes in two flavors: the free *PyCharm Community Edition* and
    the paid *PyCharm Professional Edition*. (Steps were taken by JetBrains to eliminate
    bias. See the survey here: [https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/).)'
  prefs: []
  type: TYPE_NORMAL
- en: Both versions offer a dedicated Python code editor with autocompletion, refactoring,
    debugging, and testing tools. It can manage and use virtual environments with
    ease, and it integrates with your version control software. It even performs static
    analysis (using its own tool). The professional edition adds tools for data, scientific
    development, and web development.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with other JetBrains IDEs, like IntelliJ IDEA or CLion, PyCharm
    would be a great Python IDE to start with. It requires more computer resources
    than many code editors, but if you have a decently powerful machine, this won’t
    be a problem. If you haven’t used JetBrains IDEs before, try the Community Edition
    before investing in the paid version.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information and downloads at [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/).
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Visual Studio Code* has excellent Python support. It’s the second-most popular
    Python code editor, according to that 2021 JetBrains survey. It’s free and open
    source, and it runs on virtually every platform. Install the official Python extension
    from Microsoft, and you’re ready to go!'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code supports autocompletion, refactoring, debugging, and virtual
    environment switching, along with the usual version control integration. It integrates
    with Pylint, Flake8, and Mypy, among several other popular static analyzers. It
    even works with the most common Python unit testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: Download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Sublime* is another popular multilanguage code editor. It is appreciated for
    its speed and simplicity, and it is easily customized with extensions and configuration
    files. Sublime Text is free to try, but if you find you like it and wish to continue
    using it, you need to purchase it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Anaconda plug-in transforms Sublime Text into a Python IDE, with everything:
    autocompletion, navigation, static analysis, autoformatting, test running, and
    even a documentation browser. It requires a little more hand-tuned configuration
    than some of the other options, especially if you want to use virtual environments.
    However, if Sublime Text is your jam, it’s worth it.'
  prefs: []
  type: TYPE_NORMAL
- en: Download Sublime Text at [https://sublimetext.com/](https://sublimetext.com/)
    and the Anaconda plug-in at [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/).
    That second link also provides instructions for installing the plug-in in Sublime
    Text.
  prefs: []
  type: TYPE_NORMAL
- en: Spyder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your focus is scientific programming or data analysis, or if you’re a fan
    of MATLAB’s interface, you’ll be right at home in *Spyder*, a free and open source
    Python IDE that is also written *in* Python.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the usual features—a dedicated Python code editor, a debugger,
    integration with static analyzers, and documentation viewing—Spyder includes integration
    with many common Python libraries for data analysis and scientific computing.
    It integrates a full code profiler and variable explorer. Plug-ins exist for supporting
    unit tests, autoformatting, and editing Jupyter notebooks, among other features.
  prefs: []
  type: TYPE_NORMAL
- en: Download Spyder at [https://spyder-ide.org/](https://spyder-ide.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse + PyDev/LiClipse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Eclipse* has lost a lot of ground to the newer editors, but it still has a
    loyal user base. Although it’s geared toward languages like Java, C++, PHP, and
    JavaScript, Eclipse can also become a Python IDE with the *PyDev* plug-in.'
  prefs: []
  type: TYPE_NORMAL
- en: If you already have installed Eclipse, which is completely free, then you only
    need to install the PyDev plug-in from the Eclipse Marketplace. Download Eclipse
    at [https://eclipse.org/ide/](https://eclipse.org/ide/) and look in the marketplace
    for the plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can install *LiClipse,* which bundles Eclipse, PyDev, and
    other useful tools. The PyDev developers recommend this approach, as it directly
    supports their development work. You can use LiClipse without a license for 30
    days, after which point, you must purchase a license. Download LiClipse from [https://liclipse.com/](https://liclipse.com/).
  prefs: []
  type: TYPE_NORMAL
- en: PyDev offers autocompletion, refactoring, support for type hinting and static
    analysis, debugging, unit test integration, and many more features. You can find
    more information about PyDev at [https://pydev.org/](https://pydev.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The Eric Python IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Eric* might be the oldest IDE on the list, but it’s still as reliable as ever.
    Named after Eric Idle of *Monty Python’s Flying Circus*, Eric is a free and open
    source IDE written in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It offers everything you could possibly need to write Python: autocompletion,
    debugging, refactoring, static analysis, testing integration, documentation tools,
    virtual environment management, and the list goes on.'
  prefs: []
  type: TYPE_NORMAL
- en: Find information about Eric and download it at [https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing code involves so much more than just code. Having set up your development
    environment, project, and IDE, you are now prepared to focus exclusively on making
    your code the best it can be.
  prefs: []
  type: TYPE_NORMAL
- en: By this point, you should have assembled a Python development workbench worthy
    of any production-level project. At minimum, you should have installed the Python
    interpreter, pip, `venv`, one or more static analyzers, and a Python code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, in your code editor or IDE, create a *FiringRange* project for experimenting
    in while working through this book. For the moment, to be sure everything works,
    you can make a single Python file in that project with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-11: *hello_world.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: I’ll go into the correct structure for Python projects in Chapter 4, but writing
    and running individual Python files in your firing range project should be sufficient
    for Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re new to the IDE you have selected, take a few minutes now to familiarize
    yourself with it. You should particularly ensure you know how to navigate and
    run code, manage files, work with virtual environments, access the interactive
    console, and use the static analyzers.
  prefs: []
  type: TYPE_NORMAL
