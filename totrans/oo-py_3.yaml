- en: '***The Main Program Creating Shapes***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-5 shows the source of the main program, which creates a list of
  prefs: []
  type: TYPE_NORMAL
- en: randomly chosen shape objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Main_ShapesExample.py**'
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: from Square import *
  prefs: []
  type: TYPE_NORMAL
- en: from Circle import *
  prefs: []
  type: TYPE_NORMAL
- en: from Triangle import *
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: Set up the constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WHITE = (255, 255, 255)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: N_SHAPES = 10
  prefs: []
  type: TYPE_NORMAL
- en: Set up the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: '**190** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock
    = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: shapesList = []
  prefs: []
  type: TYPE_NORMAL
- en: shapeClassesTuple = (Square, Circle, Triangle)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, N_SHAPES): 1'
  prefs: []
  type: TYPE_NORMAL
- en: randomlyChosenClass = random.choice(shapeClassesTuple)
  prefs: []
  type: TYPE_NORMAL
- en: oShape = randomlyChosenClass (window, WINDOW_WIDTH, WINDOW_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: shapesList.append(oShape)
  prefs: []
  type: TYPE_NORMAL
- en: oStatusLine = pygwidgets.DisplayText(window, (4,4),
  prefs: []
  type: TYPE_NORMAL
- en: '''Click on shapes'', fontSize=28)'
  prefs: []
  type: TYPE_NORMAL
- en: Main loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == MOUSEBUTTONDOWN: 2'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse order to check last drawn shape first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for oShape in reversed(shapesList): 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oShape.clickedInside(event.pos): 4'
  prefs: []
  type: TYPE_NORMAL
- en: area = oShape.getArea() 5
  prefs: []
  type: TYPE_NORMAL
- en: area = str(area)
  prefs: []
  type: TYPE_NORMAL
- en: theType = oShape.getType()
  prefs: []
  type: TYPE_NORMAL
- en: newText = 'Clicked on a ' + theType + ' whose area is' + area)
  prefs: []
  type: TYPE_NORMAL
- en: oStatusLine.setValue(newText)
  prefs: []
  type: TYPE_NORMAL
- en: 'break # only deal with topmost shape'
  prefs: []
  type: TYPE_NORMAL
- en: Tell each shape to draw itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(WHITE)
  prefs: []
  type: TYPE_NORMAL
- en: 'for oShape in shapesList:'
  prefs: []
  type: TYPE_NORMAL
- en: oShape.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oStatusLine.draw()
  prefs: []
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-5: The main program that creates random shapes from three classes*'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 4, w](index_split_001.html#p86)henever we have a large
    number of objects to manage, the typical approach is to build a list of objects.
    So, before the
  prefs: []
  type: TYPE_NORMAL
- en: main loop starts, the program first builds a list of shapes 1 by randomly
  prefs: []
  type: TYPE_NORMAL
- en: choosing among a circle, a square, and a triangle; creating an object of that
  prefs: []
  type: TYPE_NORMAL
- en: type; and appending it to the list. Using this approach, we can then iterate
  prefs: []
  type: TYPE_NORMAL
- en: over the list and call methods of the same name in every object in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop, the program checks for the mouse down event 2
  prefs: []
  type: TYPE_NORMAL
- en: that happens when the user clicks. Whenever the event is detected, the code
  prefs: []
  type: TYPE_NORMAL
- en: iterates through the shapesList 3 and calls the clickedInside() 4 method
  prefs: []
  type: TYPE_NORMAL
- en: for each shape. Because of polymorphism, it doesn’t matter which class the
  prefs: []
  type: TYPE_NORMAL
- en: object was instantiated from. Again, the key is that the implementation of
  prefs: []
  type: TYPE_NORMAL
- en: the clickedInside() method can be different for different classes.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **191**
  prefs: []
  type: TYPE_NORMAL
- en: When any clickedInside() method returns True 5, we call the getArea() then getType()
    methods of that object, without worrying about which type of
  prefs: []
  type: TYPE_NORMAL
- en: object was clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the output of a typical run, after clicking on a few of the differ-
  prefs: []
  type: TYPE_NORMAL
- en: 'ent shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Circle whose area is 5026.544
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Square whose area is 1600
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Triangle whose area is 1982.5
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Square whose area is 1600
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Square whose area is 100
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Triangle whose area is 576.0
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on a Circle whose area is 3019.06799
  prefs: []
  type: TYPE_NORMAL
- en: '***Extending a Pattern***'
  prefs: []
  type: TYPE_NORMAL
- en: Building classes with commonly named methods creates a consistent pat-
  prefs: []
  type: TYPE_NORMAL
- en: tern that allows us to easily extend the program. For example, to add the
  prefs: []
  type: TYPE_NORMAL
- en: ability for our program to include ellipses, we would build an Ellipse class
  prefs: []
  type: TYPE_NORMAL
- en: that implements the getArea(), clickedInside(), draw(), and getType() meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods. (The code of the clickedInside() method might be mathematically com-
  prefs: []
  type: TYPE_NORMAL
- en: plicated for an ellipse!)
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve written the code of the Ellipse class, the only change we
  prefs: []
  type: TYPE_NORMAL
- en: need to make to the setup code is to add Ellipse to the tuple of shape classes
  prefs: []
  type: TYPE_NORMAL
- en: to choose from. The code in the main loop that does the checking for clicks,
  prefs: []
  type: TYPE_NORMAL
- en: gets the area of the shape, and so on will not need to change at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates two important features of polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: • Polymorphism extends the concept of abstraction discussed in
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8 t](index_split_003.html#p192)o a collection of classes. If multiple
    classes have the same interfaces for their methods, the client programmer can
    ignore the'
  prefs: []
  type: TYPE_NORMAL
- en: implementation of those methods in all the classes.
  prefs: []
  type: TYPE_NORMAL
- en: • Polymorphism can make client programming easier. If a client pro-
  prefs: []
  type: TYPE_NORMAL
- en: grammer is already familiar with the interfaces provided by one or
  prefs: []
  type: TYPE_NORMAL
- en: more classes, then calling the methods of another polymorphic class
  prefs: []
  type: TYPE_NORMAL
- en: should as be simple as following the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**pygwidgets Exhibits Polymorphism**'
  prefs: []
  type: TYPE_NORMAL
- en: All the classes in pygwidgets were designed to use polymorphism, and they
  prefs: []
  type: TYPE_NORMAL
- en: all implement two common methods. The first is the handleEvent() method
  prefs: []
  type: TYPE_NORMAL
- en: we first used i[n Chapter 6, w](index_split_002.html#p150)hich takes an event
    object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Each class must contain its own code in this method to handle any event
  prefs: []
  type: TYPE_NORMAL
- en: that pygame may generate. Each time through the main loop, client pro-
  prefs: []
  type: TYPE_NORMAL
- en: grams need to call the handleEvent() method for every instance of every
  prefs: []
  type: TYPE_NORMAL
- en: object instantiated from pygwidgets.
  prefs: []
  type: TYPE_NORMAL
- en: '**192** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second is the draw() method, which draws images to the window. A typical drawing
    portion of a program that uses pygwidgets might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: inputTextA.draw()
  prefs: []
  type: TYPE_NORMAL
- en: inputTextB.draw()
  prefs: []
  type: TYPE_NORMAL
- en: displayTextA.draw()
  prefs: []
  type: TYPE_NORMAL
- en: displayTextB.draw()
  prefs: []
  type: TYPE_NORMAL
- en: restartButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: checkBoxA.draw()
  prefs: []
  type: TYPE_NORMAL
- en: checkBoxB.draw()
  prefs: []
  type: TYPE_NORMAL
- en: radioCustom1.draw()
  prefs: []
  type: TYPE_NORMAL
- en: radioCustom2.draw()
  prefs: []
  type: TYPE_NORMAL
- en: radioCustom3.draw()
  prefs: []
  type: TYPE_NORMAL
- en: checkBoxC.draw()
  prefs: []
  type: TYPE_NORMAL
- en: radioDefault1.draw()
  prefs: []
  type: TYPE_NORMAL
- en: radioDefault2.draw()
  prefs: []
  type: TYPE_NORMAL
- en: radioDefault3.draw()
  prefs: []
  type: TYPE_NORMAL
- en: statusButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: From the client’s point of view, each line just calls the draw() method and
  prefs: []
  type: TYPE_NORMAL
- en: passes in nothing. From an internal point of view, the code to implement
  prefs: []
  type: TYPE_NORMAL
- en: each of these methods is very different. The draw() method of the TextButton
  prefs: []
  type: TYPE_NORMAL
- en: class is completely different from that of the InputText class, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, all widgets that manage a value contain a setValue() and
  prefs: []
  type: TYPE_NORMAL
- en: optionally a getValue() method. For example, to get the text the user enters
  prefs: []
  type: TYPE_NORMAL
- en: into an InputText widget, you call the getValue() getter method. Radio button
  prefs: []
  type: TYPE_NORMAL
- en: and checkbox widgets also have a getValue() method to get their current val-
  prefs: []
  type: TYPE_NORMAL
- en: ues. To put new text into a DisplayText widget, you call the setValue() setter
  prefs: []
  type: TYPE_NORMAL
- en: method, passing in the new text. Radio button and checkbox widgets can
  prefs: []
  type: TYPE_NORMAL
- en: be set with a call to their setValue() method.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism allows client programmers to feel comfortable with a
  prefs: []
  type: TYPE_NORMAL
- en: collection of classes. When clients see a pattern, like using methods named
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() and draw(), it makes it easy for them to predict how to use a
  prefs: []
  type: TYPE_NORMAL
- en: new class in the same collection.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the pygwidgets package does not provide either a hori-
  prefs: []
  type: TYPE_NORMAL
- en: zontal or a vertical Slider class widget to allow a user to easily select from
    a
  prefs: []
  type: TYPE_NORMAL
- en: range of numbers. If I were to add these widgets, they would certainly con-
  prefs: []
  type: TYPE_NORMAL
- en: 'tain the following: a handleEvent() method, where all user interaction would'
  prefs: []
  type: TYPE_NORMAL
- en: take place; a getValue() and a setValue() method to get and set a current
  prefs: []
  type: TYPE_NORMAL
- en: value for the Slider; and a draw() method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymorphism for Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: Python also exhibits polymorphism with operators. Consider the following
  prefs: []
  type: TYPE_NORMAL
- en: 'example with the + operator:'
  prefs: []
  type: TYPE_NORMAL
- en: value1 = 4
  prefs: []
  type: TYPE_NORMAL
- en: value2 = 5
  prefs: []
  type: TYPE_NORMAL
- en: result = value1 + value2
  prefs: []
  type: TYPE_NORMAL
- en: print(result)
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **193**
  prefs: []
  type: TYPE_NORMAL
- en: 'which prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: The + operator here clearly means “add” in a mathematic sense
  prefs: []
  type: TYPE_NORMAL
- en: because both variables contain integer values. But now consider this second
  prefs: []
  type: TYPE_NORMAL
- en: 'example:'
  prefs: []
  type: TYPE_NORMAL
- en: value1 = 'Joe'
  prefs: []
  type: TYPE_NORMAL
- en: value2 = 'Schmoe'
  prefs: []
  type: TYPE_NORMAL
- en: result = value1 + value2
  prefs: []
  type: TYPE_NORMAL
- en: print(result)
  prefs: []
  type: TYPE_NORMAL
- en: 'which prints:'
  prefs: []
  type: TYPE_NORMAL
- en: JoeSchmoe
  prefs: []
  type: TYPE_NORMAL
- en: The line result = value1 + value2 is exactly the same as in the first exam-
  prefs: []
  type: TYPE_NORMAL
- en: ple, but it performs a completely different operation. With string values, the
  prefs: []
  type: TYPE_NORMAL
- en: + operator performs a string concatenation. The same operator was used,
  prefs: []
  type: TYPE_NORMAL
- en: but a different action was performed.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of having multiple meanings for an operator is com-
  prefs: []
  type: TYPE_NORMAL
- en: monly known as *operator overloading*. For some classes, the ability to overload
    operators adds highly useful features and greatly improves the readability
  prefs: []
  type: TYPE_NORMAL
- en: of client code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Magic Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: Python reserves method names with the unusual form of two underscores,
  prefs: []
  type: TYPE_NORMAL
- en: 'some name, and two underscores for a particular purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: __ *<someName>* __()
  prefs: []
  type: TYPE_NORMAL
- en: These are officially called *special methods* but are more commonly
  prefs: []
  type: TYPE_NORMAL
- en: referred to by Python programmers as *magic methods*. Many of these are
  prefs: []
  type: TYPE_NORMAL
- en: already defined, such as __init__(), which is called whenever you instanti-
  prefs: []
  type: TYPE_NORMAL
- en: ate an object from a class, but all other names in this style are available
    for
  prefs: []
  type: TYPE_NORMAL
- en: future expansion. These are known as “magic” methods because Python
  prefs: []
  type: TYPE_NORMAL
- en: calls them behind the scenes whenever it detects an operator, a special
  prefs: []
  type: TYPE_NORMAL
- en: function call, or some other special circumstance. They are not intended to
  prefs: []
  type: TYPE_NORMAL
- en: be called by client code directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because the names of these magic methods are difficult to pronounce—for example,*
    *__init__() is read as “underscore underscore init underscore underscore”—Python*
    *programmers often refer to these as* dunder *methods (a shortened version of*
    double underscore *). This method would be referred to as “dunder init.”*'
  prefs: []
  type: TYPE_NORMAL
- en: '**194** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the previous examples, we’ll look at how this works with the
    + operator. The built-in data types (integer, float, string, Boolean,
  prefs: []
  type: TYPE_NORMAL
- en: and so on) are actually implemented as classes in Python. We can see this
  prefs: []
  type: TYPE_NORMAL
- en: by testing with the built-in isinstance() function, which takes an object and
  prefs: []
  type: TYPE_NORMAL
- en: a class and returns True if the object was instantiated from the class or False
  prefs: []
  type: TYPE_NORMAL
- en: 'if not. These lines will both report True:'
  prefs: []
  type: TYPE_NORMAL
- en: print(isinstance(123, int))
  prefs: []
  type: TYPE_NORMAL
- en: print(isinstance('some string', str))
  prefs: []
  type: TYPE_NORMAL
- en: The classes for the built-in data types contain a set of magic methods,
  prefs: []
  type: TYPE_NORMAL
- en: including ones for the basic math operators. When Python detects the +
  prefs: []
  type: TYPE_NORMAL
- en: operator with integers, it calls the magic method named __add__() in the
  prefs: []
  type: TYPE_NORMAL
- en: built-in integer class, which performs integer addition. When Python sees
  prefs: []
  type: TYPE_NORMAL
- en: the same operator used with strings, it calls the __add__() method in the
  prefs: []
  type: TYPE_NORMAL
- en: string class, which performs string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is generalized so that when Python encounters a +
  prefs: []
  type: TYPE_NORMAL
- en: operator when working with objects instantiated from your class, it will call
  prefs: []
  type: TYPE_NORMAL
- en: the __add__() method if one is present in your class. Therefore, as the class
  prefs: []
  type: TYPE_NORMAL
- en: developer, you can write code to invent a new meaning for this operator.
  prefs: []
  type: TYPE_NORMAL
- en: Each operator maps to a specific magic method name. While there are
  prefs: []
  type: TYPE_NORMAL
- en: many types of magic methods, let’s start with those related to the compari-
  prefs: []
  type: TYPE_NORMAL
- en: son operators.
  prefs: []
  type: TYPE_NORMAL
- en: '***Comparison Operator Magic Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: Consider our Square class from Listing 9-2\. You want client software to be
  prefs: []
  type: TYPE_NORMAL
- en: able to compare two Square objects to see if they are equal. It is up to you
  prefs: []
  type: TYPE_NORMAL
- en: to decide what “equal” means when comparing objects. For instance, you
  prefs: []
  type: TYPE_NORMAL
- en: might define it as two objects being the same color and at the same location
  prefs: []
  type: TYPE_NORMAL
- en: and with the same size. As a simple example, we’ll define two Square objects
  prefs: []
  type: TYPE_NORMAL
- en: as equal if they just have the same side length. This is easily implemented
    by
  prefs: []
  type: TYPE_NORMAL
- en: comparing the self.heightAndWidth instance variables of the two objects and
  prefs: []
  type: TYPE_NORMAL
- en: returning a Boolean. You could write your own equals() method, and client
  prefs: []
  type: TYPE_NORMAL
- en: 'software could then call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oSquare1.equals(oSquare2):'
  prefs: []
  type: TYPE_NORMAL
- en: This would work fine. However, it would be more natural for client soft-
  prefs: []
  type: TYPE_NORMAL
- en: 'ware to use the standard == comparison operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oSquare1 == oSquare2:'
  prefs: []
  type: TYPE_NORMAL
- en: Written this way, Python translates the == operator into a call to a magic
  prefs: []
  type: TYPE_NORMAL
- en: method of the first object. In this case, Python will attempt to call a magic
  prefs: []
  type: TYPE_NORMAL
- en: method named __eq__() in the Square class. Table 9-1 shows the magic meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods for all the comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **195**
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Comparison Operator Symbols, Meanings, and Magic Method Names
    **Symbol**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Magic method name**'
  prefs: []
  type: TYPE_NORMAL
- en: ==
  prefs: []
  type: TYPE_NORMAL
- en: Equal to
  prefs: []
  type: TYPE_NORMAL
- en: __eq__()
  prefs: []
  type: TYPE_NORMAL
- en: '!='
  prefs: []
  type: TYPE_NORMAL
- en: Not equal to
  prefs: []
  type: TYPE_NORMAL
- en: __ne__()
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: Less than
  prefs: []
  type: TYPE_NORMAL
- en: __lt__()
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Greater than
  prefs: []
  type: TYPE_NORMAL
- en: __gt__()
  prefs: []
  type: TYPE_NORMAL
- en: <=
  prefs: []
  type: TYPE_NORMAL
- en: Less than or equal to
  prefs: []
  type: TYPE_NORMAL
- en: __le__()
  prefs: []
  type: TYPE_NORMAL
- en: '>='
  prefs: []
  type: TYPE_NORMAL
- en: Greater than or equal to
  prefs: []
  type: TYPE_NORMAL
- en: __ge__()
  prefs: []
  type: TYPE_NORMAL
- en: To allow the == comparison operator to check for equality between two
  prefs: []
  type: TYPE_NORMAL
- en: 'Square objects, you would write a method like this in the Square class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __eq__(self, oOtherSquare):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(oOtherSquare, Square):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Second object was not a Square')
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.heightAndWidth == oOtherSquare.heightAndWidth:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return True # match'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # not a match'
  prefs: []
  type: TYPE_NORMAL
- en: When Python detects an == comparison where the first object is a Square,
  prefs: []
  type: TYPE_NORMAL
- en: it calls this method in the Square class. Since Python is a loosely typed lan-
  prefs: []
  type: TYPE_NORMAL
- en: guage (it doesn’t require you to define variable types), the second parame-
  prefs: []
  type: TYPE_NORMAL
- en: ter could be of any data type. However, in order for the comparison to work
  prefs: []
  type: TYPE_NORMAL
- en: correctly, the second parameter must also be a Square object. We perform
  prefs: []
  type: TYPE_NORMAL
- en: a check using the isinstance() function, which works with programmer-
  prefs: []
  type: TYPE_NORMAL
- en: defined classes the same way it works with built-in classes. If the second
  prefs: []
  type: TYPE_NORMAL
- en: object is not a Square, we raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We then compare the heightAndWidth of the current object (self) with
  prefs: []
  type: TYPE_NORMAL
- en: the heightAndWidth of a second object (oOtherSquare). This is a case where
  prefs: []
  type: TYPE_NORMAL
- en: using direct access to the instance variables of two objects is perfectly
  prefs: []
  type: TYPE_NORMAL
- en: acceptable, because both objects are of the same type, and therefore they
  prefs: []
  type: TYPE_NORMAL
- en: must contain the same instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Rectangle Class with Magic Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: To expand, we’ll build a program that draws a number of rectangle
  prefs: []
  type: TYPE_NORMAL
- en: shapes using a Rectangle class. The user will be able to click on any two
  prefs: []
  type: TYPE_NORMAL
- en: rectangles, and the program will report if the rectangles have the same
  prefs: []
  type: TYPE_NORMAL
- en: area or if the area of the first one is larger or smaller than the area of the
  prefs: []
  type: TYPE_NORMAL
- en: second rectangle. We’ll use the ==, <, and > operators and expect the result
  prefs: []
  type: TYPE_NORMAL
- en: to be a Boolean True or False for each comparison. Listing 9-6 contains
  prefs: []
  type: TYPE_NORMAL
- en: the code of the Rectangle class, which implements magic methods for these
  prefs: []
  type: TYPE_NORMAL
- en: operators.
  prefs: []
  type: TYPE_NORMAL
- en: '**196** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MagicMethods/Rectangle/Rectangle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Rectangle():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.width = random.choice((20, 30, 40))
  prefs: []
  type: TYPE_NORMAL
- en: self.height = random.choice((20, 30, 40))
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(0, 400)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(0, 400)
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
  prefs: []
  type: TYPE_NORMAL
- en: self.area = self.width * self.height
  prefs: []
  type: TYPE_NORMAL
- en: 'def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: clicked = self.rect.collidepoint(mousePoint)
  prefs: []
  type: TYPE_NORMAL
- en: return clicked
  prefs: []
  type: TYPE_NORMAL
- en: Magic method called when you compare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: two Rectangle objects with the == operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __eq__ (self, oOtherRectangle): 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(oOtherRectangle, Rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Second object was not a Rectangle')
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.area == oOtherRectangle.area:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: Magic method called when you compare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: two Rectangle objects with the < operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __lt__(self, oOtherRectangle): 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(oOtherRectangle, Rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Second object was not a Rectangle')
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.area < oOtherRectangle.area:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: Magic method called when you compare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: two Rectangle objects with the > operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __gt__(self, oOtherRectangle): 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(oOtherRectangle, Rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Second object was not a Rectangle')
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **197**
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.area > oOtherRectangle.area:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.area
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.rect(self.window, self.color, (self.x, self.y, self.width, self.height))
    *Listing 9-6: The Rectangle class*'
  prefs: []
  type: TYPE_NORMAL
- en: The methods __eq__() 1, __lt__() 2, and __gt__() 3 allow client code
  prefs: []
  type: TYPE_NORMAL
- en: to use standard comparison operators between Rectangle objects. To com-
  prefs: []
  type: TYPE_NORMAL
- en: 'pare two rectangles for equality, you would write:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oRectangle1 == oRectangle2:'
  prefs: []
  type: TYPE_NORMAL
- en: When this line runs, the __eq__() method of the first object is called,
  prefs: []
  type: TYPE_NORMAL
- en: and the second object is passed in as the second parameter. The function
  prefs: []
  type: TYPE_NORMAL
- en: returns either True or False. Similarly, to compare for less than, you would
  prefs: []
  type: TYPE_NORMAL
- en: 'write a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oRectangle1 < oRectangle2:'
  prefs: []
  type: TYPE_NORMAL
- en: The __lt__() method then checks for the area of the first rectangle
  prefs: []
  type: TYPE_NORMAL
- en: being less than the area of the second rectangle. If client code used the >
  prefs: []
  type: TYPE_NORMAL
- en: operator to compare two rectangles, the __gt__() method would be called.
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Program Using Magic Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-7 shows the code of the main program that tests the magic methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MagicMethods/Rectangle/Main_RectangleExample.py**'
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: from Rectangle import *
  prefs: []
  type: TYPE_NORMAL
- en: Set up the constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WHITE = (255, 255, 255)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: N_RECTANGLES = 10
  prefs: []
  type: TYPE_NORMAL
- en: FIRST_RECTANGLE = 'first'
  prefs: []
  type: TYPE_NORMAL
- en: SECOND_RECTANGLE = 'second'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: '**198** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock
    = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: rectanglesList = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, N_RECTANGLES):'
  prefs: []
  type: TYPE_NORMAL
- en: oRectangle = Rectangle(window)
  prefs: []
  type: TYPE_NORMAL
- en: rectanglesList.append(oRectangle)
  prefs: []
  type: TYPE_NORMAL
- en: whichRectangle = FIRST_RECTANGLE
  prefs: []
  type: TYPE_NORMAL
- en: Main loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == MOUSEBUTTONDOWN:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for oRectangle in rectanglesList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oRectangle.clickedInside(event.pos):'
  prefs: []
  type: TYPE_NORMAL
- en: print('Clicked on', whichRectangle, 'rectangle.')
  prefs: []
  type: TYPE_NORMAL
- en: 'if whichRectangle == FIRST_RECTANGLE:'
  prefs: []
  type: TYPE_NORMAL
- en: oFirstRectangle = oRectangle 1
  prefs: []
  type: TYPE_NORMAL
- en: whichRectangle = SECOND_RECTANGLE
  prefs: []
  type: TYPE_NORMAL
- en: 'elif whichRectangle == SECOND_RECTANGLE:'
  prefs: []
  type: TYPE_NORMAL
- en: oSecondRectangle2 = oRectangle 2
  prefs: []
  type: TYPE_NORMAL
- en: User has chosen 2 rectangles, let's compare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if oFirstRectangle == oSecondRectangle: 3'
  prefs: []
  type: TYPE_NORMAL
- en: print('Rectangles are the same size.')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oFirstRectangle < oSecondRectangle: 4'
  prefs: []
  type: TYPE_NORMAL
- en: print('First rectangle is smaller than second rectangle.')
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # must be larger 5'
  prefs: []
  type: TYPE_NORMAL
- en: print('First rectangle is larger than second rectangle.')
  prefs: []
  type: TYPE_NORMAL
- en: whichRectangle = FIRST_RECTANGLE
  prefs: []
  type: TYPE_NORMAL
- en: Clear the window and draw all rectangles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(WHITE)
  prefs: []
  type: TYPE_NORMAL
- en: 'for oRectangle in rectanglesList: 6'
  prefs: []
  type: TYPE_NORMAL
- en: oRectangle.draw()
  prefs: []
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-7: The main program that draws and then compares Rectangle objects*'
  prefs: []
  type: TYPE_NORMAL
- en: The user of the program clicks on pairs of rectangles to compare their
  prefs: []
  type: TYPE_NORMAL
- en: sizes. We store the selected rectangles in two variables 1 2\.
  prefs: []
  type: TYPE_NORMAL
- en: We check for equality using the == operator 3, which resolves to calling
  prefs: []
  type: TYPE_NORMAL
- en: the __eq__() method of the Rectangle class. If the rectangles are the same
  prefs: []
  type: TYPE_NORMAL
- en: size, we print out an appropriate message. If not, we check if the first rect-
  prefs: []
  type: TYPE_NORMAL
- en: angle is smaller than the second using the < operator 4, which results in
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **199**
  prefs: []
  type: TYPE_NORMAL
- en: a call to the __lt__() method. If this comparison is also not True, we print
    the message for the first being larger than the second 5\. We didn’t need to
  prefs: []
  type: TYPE_NORMAL
- en: use the > operator in this program; however, since other client code might
  prefs: []
  type: TYPE_NORMAL
- en: implement size comparisons differently, we’ve included the __gt__() method
  prefs: []
  type: TYPE_NORMAL
- en: for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we draw all the rectangles in our list 6\.
  prefs: []
  type: TYPE_NORMAL
- en: Because we included the magic methods __eq__(), __lt__(), and __gt__()
  prefs: []
  type: TYPE_NORMAL
- en: in the Rectangle class, we were able to use the standard comparison opera-
  prefs: []
  type: TYPE_NORMAL
- en: tors in a highly intuitive and readable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from clicking on a number of different rectangles:'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on first rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on second rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangles are the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on first rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on second rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: First rectangle is smaller than second rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on first rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Clicked on second rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: First rectangle is larger than second rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '***Math Operator Magic Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: You can write additional magic methods to define what happens when cli-
  prefs: []
  type: TYPE_NORMAL
- en: ent code uses the other arithmetic operators between objects instantiated
  prefs: []
  type: TYPE_NORMAL
- en: from your class.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2 shows the methods that are called for the basic arithmetic
  prefs: []
  type: TYPE_NORMAL
- en: operators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Math Operator Symbols, Meanings, and Magic Method Names'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbol**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Magic method name**'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: Addition
  prefs: []
  type: TYPE_NORMAL
- en: __add__()
  prefs: []
  type: TYPE_NORMAL
- en: '-'
  prefs: []
  type: TYPE_NORMAL
- en: Subtraction
  prefs: []
  type: TYPE_NORMAL
- en: __sub__()
  prefs: []
  type: TYPE_NORMAL
- en: '*'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication
  prefs: []
  type: TYPE_NORMAL
- en: __mul__()
  prefs: []
  type: TYPE_NORMAL
- en: /
  prefs: []
  type: TYPE_NORMAL
- en: Division (floating-point
  prefs: []
  type: TYPE_NORMAL
- en: __truediv__()
  prefs: []
  type: TYPE_NORMAL
- en: result)
  prefs: []
  type: TYPE_NORMAL
- en: //
  prefs: []
  type: TYPE_NORMAL
- en: Integer division
  prefs: []
  type: TYPE_NORMAL
- en: __floordiv__()
  prefs: []
  type: TYPE_NORMAL
- en: '%'
  prefs: []
  type: TYPE_NORMAL
- en: Modulo
  prefs: []
  type: TYPE_NORMAL
- en: __mod__()
  prefs: []
  type: TYPE_NORMAL
- en: abs
  prefs: []
  type: TYPE_NORMAL
- en: Absolute value
  prefs: []
  type: TYPE_NORMAL
- en: __abs__()
  prefs: []
  type: TYPE_NORMAL
- en: For example, to handle the + operator, you would implement a method
  prefs: []
  type: TYPE_NORMAL
- en: 'in your class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __add__(self, oOther):'
  prefs: []
  type: TYPE_NORMAL
- en: Your code here to determine what happens when code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: attempts to add two of these objects.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**200** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: A full list of all the magic or dunder methods can be found in the official
    documentation at [*https://docs.python.org/3/reference/datamodel.html*](https://docs.python.org/3/reference/datamodel.html).
  prefs: []
  type: TYPE_NORMAL
- en: '***Vector Example***'
  prefs: []
  type: TYPE_NORMAL
- en: In math, a *vector* is an ordered pair of x and y values that is often repre-
  prefs: []
  type: TYPE_NORMAL
- en: sented on a graph as a directed line segment. In this section, we’ll build
  prefs: []
  type: TYPE_NORMAL
- en: a class that uses math operator magic methods to operate on vectors.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of math operations that can be performed on vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9-2 shows an example of adding two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: y–axis
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: =Vector 4, 5
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: Vector 1, 3
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: plus
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: Vector 3, 2
  prefs: []
  type: TYPE_NORMAL
- en: x–axis
  prefs: []
  type: TYPE_NORMAL
- en: –6 –5
  prefs: []
  type: TYPE_NORMAL
- en: –4
  prefs: []
  type: TYPE_NORMAL
- en: –3
  prefs: []
  type: TYPE_NORMAL
- en: –2
  prefs: []
  type: TYPE_NORMAL
- en: –1
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: –1
  prefs: []
  type: TYPE_NORMAL
- en: –2
  prefs: []
  type: TYPE_NORMAL
- en: –3
  prefs: []
  type: TYPE_NORMAL
- en: –4
  prefs: []
  type: TYPE_NORMAL
- en: –5
  prefs: []
  type: TYPE_NORMAL
- en: –6
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-2: Vector addition in Cartesian coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding two vectors results in a new vector whose x value is the sum of
  prefs: []
  type: TYPE_NORMAL
- en: the x values of the two added vectors and whose y value is the sum of the y
  prefs: []
  type: TYPE_NORMAL
- en: values of the two added vectors. In Figure 9-2, we add the vector (3, 2) and
  prefs: []
  type: TYPE_NORMAL
- en: the vector (1, 3) to create a vector (4, 5).
  prefs: []
  type: TYPE_NORMAL
- en: Two vectors are considered equal if their x values are the same and
  prefs: []
  type: TYPE_NORMAL
- en: their y values are the same. A vector’s size is computed to be the hypotenuse
  prefs: []
  type: TYPE_NORMAL
- en: of the right triangle with one side of length x and the second side of length
  prefs: []
  type: TYPE_NORMAL
- en: y. We can use the Pythagorean theorem to compute the length and use the
  prefs: []
  type: TYPE_NORMAL
- en: lengths to compare two vectors’ sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **201**
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-8 is a Vector class that illustrates the appropriate magic methods
    for doing math and comparisons between two Vector objects. (Each of
  prefs: []
  type: TYPE_NORMAL
- en: these methods has additional code using a call to isinstance() to ensure that
  prefs: []
  type: TYPE_NORMAL
- en: the second object is a Vector. These checks are included in the download-
  prefs: []
  type: TYPE_NORMAL
- en: able file, but I have omitted them here to save space.)
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MagicMethods/Vectors/Vector.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Vector class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'class Vector():'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''The Vector class represents two values as a vector,'
  prefs: []
  type: TYPE_NORMAL
- en: allows for many math calculations'''
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, x, y):'
  prefs: []
  type: TYPE_NORMAL
- en: self.x = x
  prefs: []
  type: TYPE_NORMAL
- en: self.y = y
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __add__(self, oOther): # called for + operator'
  prefs: []
  type: TYPE_NORMAL
- en: return Vector(self.x + oOther.x, self.y + oOther.y)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __sub__(self, oOther): # called for - operator'
  prefs: []
  type: TYPE_NORMAL
- en: return Vector(self.x - oOther.x, self.y - oOther.y)
  prefs: []
  type: TYPE_NORMAL
- en: '2 def __mul__(self, oOther): # called for * operator'
  prefs: []
  type: TYPE_NORMAL
- en: Special code to allow for multiplying by a vector or a scalar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if isInstance(oOther, Vector): # multiply two vectors'
  prefs: []
  type: TYPE_NORMAL
- en: return Vector((self.x * oOther.x), (self.y * oOther.y))
  prefs: []
  type: TYPE_NORMAL
- en: 'elif isinstance(oOther, (int, float)): # multiply by a scalar'
  prefs: []
  type: TYPE_NORMAL
- en: return Vector((self.x * oOther), (self.y * oOther))
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Second value must be a vector or scalar')
  prefs: []
  type: TYPE_NORMAL
- en: 'def __abs__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return math.sqrt((self.x ** 2) + (self.y ** 2))
  prefs: []
  type: TYPE_NORMAL
- en: 'def __eq__(self, oOther): # called for == operator'
  prefs: []
  type: TYPE_NORMAL
- en: return (self.x == oOther.x) and (self.y == oOther.y)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __ne__(self, oOther): # called for != operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'return not (self == oOther) # calls __eq__ method'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __lt__(self, oOther): # called for < operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'if abs(self) < abs(oOther): # calls __abs__ method'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'def __gt__(self, oOther): # called for > operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'if abs(self) > abs(oOther): # calls __abs__ method'
  prefs: []
  type: TYPE_NORMAL
- en: '**202** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-8: The Vector class that implements a number of magic methods*'
  prefs: []
  type: TYPE_NORMAL
- en: This class implements arithmetic and comparison operators as magic
  prefs: []
  type: TYPE_NORMAL
- en: methods. Client code would use standard symbols for math and compari-
  prefs: []
  type: TYPE_NORMAL
- en: son between two Vector objects. For example, the addition of vectors in
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9-2 could be handled like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oVector1 = Vector(3, 2)
  prefs: []
  type: TYPE_NORMAL
- en: oVector2 = Vector(1, 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'oNewVector = oVector1 + oVector2 # use the + operator to add vectors'
  prefs: []
  type: TYPE_NORMAL
- en: When the third line runs, the __add__() method 1is called to add the
  prefs: []
  type: TYPE_NORMAL
- en: two Vector objects, resulting in the creation of a new Vector object. There
    is a
  prefs: []
  type: TYPE_NORMAL
- en: special check in the __mul__() method 2 that allows the * operator to either
  prefs: []
  type: TYPE_NORMAL
- en: multiply two Vectors or multiply one Vector by a scalar value, depending on
  prefs: []
  type: TYPE_NORMAL
- en: the type of the second value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a String Representation of Values in an Object**'
  prefs: []
  type: TYPE_NORMAL
- en: A standard approach to debugging is to add calls to print() to write out the
  prefs: []
  type: TYPE_NORMAL
- en: 'values of variables at certain points in your program:'
  prefs: []
  type: TYPE_NORMAL
- en: print('My variable is', myVariable)
  prefs: []
  type: TYPE_NORMAL
- en: However, if you try to use print() to help you debug the contents of an
  prefs: []
  type: TYPE_NORMAL
- en: object, the results are not particularly helpful. For example, here we create
  prefs: []
  type: TYPE_NORMAL
- en: 'a Vector object and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: oVector = Vector(3, 4)
  prefs: []
  type: TYPE_NORMAL
- en: print('My vector is', oVector)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: <Vector object at 0x10361b518>
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that we have an object instantiated from the Vector class
  prefs: []
  type: TYPE_NORMAL
- en: and shows the memory address of that object. However, in most cases, what
  prefs: []
  type: TYPE_NORMAL
- en: we really want to know are the values of the instance variables in the object
  prefs: []
  type: TYPE_NORMAL
- en: at that moment. Luckily, we can use magic methods for that.
  prefs: []
  type: TYPE_NORMAL
- en: There are two magic methods that can be useful in getting information
  prefs: []
  type: TYPE_NORMAL
- en: '(as strings) from an object:'
  prefs: []
  type: TYPE_NORMAL
- en: • The __str__() method is used to create a string representation of an
  prefs: []
  type: TYPE_NORMAL
- en: object that can be read easily by humans. If client code makes a call to
  prefs: []
  type: TYPE_NORMAL
- en: the str() built-in function and passes in an object, Python will call the
  prefs: []
  type: TYPE_NORMAL
- en: magic method __str__() if it is present in that class.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **203**
  prefs: []
  type: TYPE_NORMAL
- en: • The __repr__() method is used to create an unambiguous, possibly machine-readable
    string representation of the object. If client code
  prefs: []
  type: TYPE_NORMAL
- en: makes a call to the repr() built-in function and passes in an object,
  prefs: []
  type: TYPE_NORMAL
- en: Python will attempt to call the magic method __repr__() in that class,
  prefs: []
  type: TYPE_NORMAL
- en: if present.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show the __str__() method, as it’s more generally used for simple
  prefs: []
  type: TYPE_NORMAL
- en: debugging. When you call the print() function, Python calls the built-in
  prefs: []
  type: TYPE_NORMAL
- en: str() function to convert each argument into a string. For any argument
  prefs: []
  type: TYPE_NORMAL
- en: that does not have a __str__() method, this function formats a string that
  prefs: []
  type: TYPE_NORMAL
- en: contains the type of the object, the words “object at,” and the memory
  prefs: []
  type: TYPE_NORMAL
- en: address, then returns the resulting string. That’s why we see the earlier out-
  prefs: []
  type: TYPE_NORMAL
- en: put containing the memory address.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you can write your own version of __str__() and have it produce
  prefs: []
  type: TYPE_NORMAL
- en: whatever string you want to help debug the code of your class. The general
  prefs: []
  type: TYPE_NORMAL
- en: approach is to build a string that contains the values of any instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: ables that you want to see and return that string to be printed. For example,
  prefs: []
  type: TYPE_NORMAL
- en: we can add the following method to the Vector class from Listing 9-8 to get
  prefs: []
  type: TYPE_NORMAL
- en: 'information about any Vector object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Vector():'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snipped all previous methods ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __str__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return 'This vector has the value (' + str(self.x) + ', ' + str(self.y) + ')'
  prefs: []
  type: TYPE_NORMAL
- en: If you instantiate a Vector, you can then call the print() function and
  prefs: []
  type: TYPE_NORMAL
- en: 'pass in a Vector object:'
  prefs: []
  type: TYPE_NORMAL
- en: oVector = Vector(10, 7)
  prefs: []
  type: TYPE_NORMAL
- en: print(oVector)
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just printing the memory address of the Vector object, you
  prefs: []
  type: TYPE_NORMAL
- en: will get a nicely formatted report of the values of the two instance variables
  prefs: []
  type: TYPE_NORMAL
- en: 'contained in the object:'
  prefs: []
  type: TYPE_NORMAL
- en: This vector has the value (10, 7)
  prefs: []
  type: TYPE_NORMAL
- en: The main code in Listing 9-9 creates a few Vector objects, does some
  prefs: []
  type: TYPE_NORMAL
- en: vector math, and prints out the results of some Vector calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Vectors/Main_Vectors.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Vector test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Vector import *
  prefs: []
  type: TYPE_NORMAL
- en: v1 = Vector(3, 4)
  prefs: []
  type: TYPE_NORMAL
- en: v2 = Vector(2, 2)
  prefs: []
  type: TYPE_NORMAL
- en: v3 = Vector(3, 4)
  prefs: []
  type: TYPE_NORMAL
- en: '**204** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: These lines print Boolean or numeric values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print(v1 == v2)
  prefs: []
  type: TYPE_NORMAL
- en: print(v1 == v3)
  prefs: []
  type: TYPE_NORMAL
- en: print(v1 < v2)
  prefs: []
  type: TYPE_NORMAL
- en: print(v1 > v2)
  prefs: []
  type: TYPE_NORMAL
- en: print(abs(v1))
  prefs: []
  type: TYPE_NORMAL
- en: print(abs(v2))
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: These lines print Vectors (calls the __str__() method)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Vector 1:', v1)
  prefs: []
  type: TYPE_NORMAL
- en: print('Vector 2:', v2)
  prefs: []
  type: TYPE_NORMAL
- en: print('Vector 1 + Vector 2:', v1 + v2)
  prefs: []
  type: TYPE_NORMAL
- en: print('Vector 1 - Vector 2:', v1 - v2)
  prefs: []
  type: TYPE_NORMAL
- en: print('Vector 1 times Vector 2:', v1 * v2)
  prefs: []
  type: TYPE_NORMAL
- en: print('Vector 2 times 5:', v1 * 5)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-9: Sample main code that creates and compares Vectors, does math,
    and prints* *Vectors*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: '5.0'
  prefs: []
  type: TYPE_NORMAL
- en: '2.8284271247461903'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector 1: This vector has the value (3, 4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector 2: This vector has the value (2, 2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector 1 + Vector 2: This vector has the value (5, 6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector 1 - Vector 2: This vector has the value (1, 2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector 1 times Vector 2: This vector has the value (6, 8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector 2 times 5: This vector has the value (15, 20)'
  prefs: []
  type: TYPE_NORMAL
- en: The first set of calls to print() output Boolean and numeric values,
  prefs: []
  type: TYPE_NORMAL
- en: which result from calling math and comparison operator magic methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the second set, we print two Vector objects, then compute and print
  prefs: []
  type: TYPE_NORMAL
- en: some new Vectors. Internally, the print() function first calls Python’s str()
  prefs: []
  type: TYPE_NORMAL
- en: function for each item to be printed; that results in a call to the Vector’s
  prefs: []
  type: TYPE_NORMAL
- en: __str__() magic method, which creates a formatted string with the relevant
  prefs: []
  type: TYPE_NORMAL
- en: information.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Fraction Class with Magic Methods**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put some of these magic methods together in a more complex exam-
  prefs: []
  type: TYPE_NORMAL
- en: ple. Listing 9-10 shows the code of a Fraction class. Each Fraction object is
  prefs: []
  type: TYPE_NORMAL
- en: made up of a numerator (top part) and a denominator (bottom part). The
  prefs: []
  type: TYPE_NORMAL
- en: class keeps track of a fraction by storing the separate parts in instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: ables, along with the fraction’s approximate decimal value. The methods
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **205**
  prefs: []
  type: TYPE_NORMAL
- en: allow the caller to get the reduced value of the fraction, print the fraction
    along with its floating-point value, compare two fractions for equality, and
  prefs: []
  type: TYPE_NORMAL
- en: add two Fraction objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MagicMethods/Fraction.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Fraction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'class Fraction():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, numerator, denominator): 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(numerator, int):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Numerator', numerator, 'must be an integer')
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(denominator, int):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Denominator', denominator, 'must be an integer')
  prefs: []
  type: TYPE_NORMAL
- en: self.numerator = numerator
  prefs: []
  type: TYPE_NORMAL
- en: self.denominator = denominator
  prefs: []
  type: TYPE_NORMAL
- en: Use the math package to find the greatest common divisor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: greatestCommonDivisor = math.gcd(self.numerator, self.denominator)
  prefs: []
  type: TYPE_NORMAL
- en: 'if greatestCommonDivisor > 1:'
  prefs: []
  type: TYPE_NORMAL
- en: self.numerator = self.numerator // greatestCommonDivisor
  prefs: []
  type: TYPE_NORMAL
- en: self.denominator = self.denominator // greatestCommonDivisor
  prefs: []
  type: TYPE_NORMAL
- en: self.value = self.numerator / self.denominator
  prefs: []
  type: TYPE_NORMAL
- en: Normalize the sign of the numerator and denominator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.numerator = int(math.copysign(1.0, self.value)) * abs(self.numerator)
  prefs: []
  type: TYPE_NORMAL
- en: self.denominator = abs(self.denominator)
  prefs: []
  type: TYPE_NORMAL
- en: 'def getValue(self): 2'
  prefs: []
  type: TYPE_NORMAL
- en: return self.value
  prefs: []
  type: TYPE_NORMAL
- en: 'def __str__(self): 3'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Create a string representation of the fraction'''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'output = '' Fraction: '' + str(self.numerator) + ''/'' + \'
  prefs: []
  type: TYPE_NORMAL
- en: str(self.denominator) + '\n' + \
  prefs: []
  type: TYPE_NORMAL
- en: ''' Value: '' + str(self.value) + ''\n'''
  prefs: []
  type: TYPE_NORMAL
- en: return output
  prefs: []
  type: TYPE_NORMAL
- en: 'def __add__(self, oOtherFraction): 4'
  prefs: []
  type: TYPE_NORMAL
- en: ''''''' Add two Fraction objects'''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(oOtherFraction, Fraction):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError('Second value in attempt to add is not a Fraction')
  prefs: []
  type: TYPE_NORMAL
- en: Use the math package to find the least common multiple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: newDenominator = math.lcm(self.denominator, oOtherFraction.denominator)
  prefs: []
  type: TYPE_NORMAL
- en: multiplicationFactor = newDenominator // self.denominator
  prefs: []
  type: TYPE_NORMAL
- en: equivalentNumerator = self.numerator * multiplicationFactor
  prefs: []
  type: TYPE_NORMAL
- en: otherMultiplicationFactor = newDenominator // oOtherFraction.denominator
  prefs: []
  type: TYPE_NORMAL
- en: oOtherFractionEquivalentNumerator =
  prefs: []
  type: TYPE_NORMAL
- en: oOtherFraction.numerator * otherMultiplicationFactor
  prefs: []
  type: TYPE_NORMAL
- en: '**206** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: newNumerator = equivalentNumerator + oOtherFractionEquivalentNumerator oAddedFraction
    = Fraction(newNumerator, newDenominator)
  prefs: []
  type: TYPE_NORMAL
- en: return oAddedFraction
  prefs: []
  type: TYPE_NORMAL
- en: 'def __eq__(self, oOtherFraction): 5'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Test for equality '''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(oOtherFraction, Fraction):'
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # not comparing to a fraction'
  prefs: []
  type: TYPE_NORMAL
- en: if (self.numerator == oOtherFraction.numerator) and \
  prefs: []
  type: TYPE_NORMAL
- en: '(self.denominator == oOtherFraction.denominator):'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-10: The Fraction class that implements a number of magic methods*'
  prefs: []
  type: TYPE_NORMAL
- en: When you create a Fraction object, you pass in a numerator and a
  prefs: []
  type: TYPE_NORMAL
- en: denominator 1, and the __init__() method immediately calculates the
  prefs: []
  type: TYPE_NORMAL
- en: reduced fraction and its floating-point value. At any time, client code can
  prefs: []
  type: TYPE_NORMAL
- en: call the getValue() method to retrieve that value 2\. Client code can also call
  prefs: []
  type: TYPE_NORMAL
- en: print() to print out the object, and Python will call the __str__() method to
  prefs: []
  type: TYPE_NORMAL
- en: format a string to be printed 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The client can add two different Fraction objects together with the
  prefs: []
  type: TYPE_NORMAL
- en: + operator. When this happens, the __add__() method is called 4\. That
  prefs: []
  type: TYPE_NORMAL
- en: method uses the math.lcd() (least common denominator) method to ensure
  prefs: []
  type: TYPE_NORMAL
- en: that the resulting Fraction object has the smallest common denominator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, client code can use the == operator to check if two Fraction
  prefs: []
  type: TYPE_NORMAL
- en: objects are equal. When you use this operator, the __eq__() method is
  prefs: []
  type: TYPE_NORMAL
- en: called 5, which checks the values of the two Fractions and returns True or
  prefs: []
  type: TYPE_NORMAL
- en: False.
  prefs: []
  type: TYPE_NORMAL
- en: Here is some code that instantiates Fraction objects and tests the various
  prefs: []
  type: TYPE_NORMAL
- en: 'magic methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'oFraction1 = Fraction(1, 3) # create a Fraction object'
  prefs: []
  type: TYPE_NORMAL
- en: oFraction2 = Fraction(2, 5)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Fraction1\n'', oFraction1) # print the object ... calls __str__'
  prefs: []
  type: TYPE_NORMAL
- en: print('Fraction2\n', oFraction2)
  prefs: []
  type: TYPE_NORMAL
- en: 'oSumFraction = oFraction1 + oFraction2 # calls __add__'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sum is\n', oSumFraction)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Are fractions 1 and 2 equal?'', (oFraction1 == oFraction2)) # expect
    False'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: oFraction3 = Fraction(-20, 80)
  prefs: []
  type: TYPE_NORMAL
- en: oFraction4 = Fraction(4, -16)
  prefs: []
  type: TYPE_NORMAL
- en: print('Fraction3\n', oFraction3)
  prefs: []
  type: TYPE_NORMAL
- en: print('Fraction4\n', oFraction4)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Are fractions 3 and 4 equal?'', (oFraction3 == oFraction4)) # expect
    True'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **207**
  prefs: []
  type: TYPE_NORMAL
- en: oFraction5 = Fraction(5, 2)
  prefs: []
  type: TYPE_NORMAL
- en: oFraction6 = Fraction(500, 200)
  prefs: []
  type: TYPE_NORMAL
- en: print('Sum of 5/2 and 500/2\n', oFraction5 + oFraction6)
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, this code produces:'
  prefs: []
  type: TYPE_NORMAL
- en: Fraction1
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraction: 1/3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: 0.3333333333333333'
  prefs: []
  type: TYPE_NORMAL
- en: Fraction2
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraction: 2/5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: 0.4'
  prefs: []
  type: TYPE_NORMAL
- en: Sum is
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraction: 11/15'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: 0.7333333333333333'
  prefs: []
  type: TYPE_NORMAL
- en: Are fractions 1 and 2 equal? False
  prefs: []
  type: TYPE_NORMAL
- en: Fraction3
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraction: -1/4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: -0.25'
  prefs: []
  type: TYPE_NORMAL
- en: Fraction4
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraction: -1/4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: -0.25'
  prefs: []
  type: TYPE_NORMAL
- en: Are fractions 3 and 4 equal? True
  prefs: []
  type: TYPE_NORMAL
- en: Sum of 5/2 and 500/2
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraction: 5/1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: 5.0'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was about the key OOP concept of polymorphism. Stated
  prefs: []
  type: TYPE_NORMAL
- en: simply, polymorphism is the ability for multiple classes to implement meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods with the same names. Each class contains specific code to do whatever
  prefs: []
  type: TYPE_NORMAL
- en: needs to be done for objects instantiated from that class. As a demonstra-
  prefs: []
  type: TYPE_NORMAL
- en: tion program, I showed how you could create a number of different shape
  prefs: []
  type: TYPE_NORMAL
- en: classes, each of which had an __init__(), getArea(), clickedInside(), and
  prefs: []
  type: TYPE_NORMAL
- en: draw() method. The code of each version of these methods was specific to
  prefs: []
  type: TYPE_NORMAL
- en: the type of the shape.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw, there are two key advantages to using polymorphism. First,
  prefs: []
  type: TYPE_NORMAL
- en: it extends the concept of abstraction to a collection of classes, allowing the
  prefs: []
  type: TYPE_NORMAL
- en: client programmer to ignore the implementation. Second, it allows for a
  prefs: []
  type: TYPE_NORMAL
- en: system of classes that work in similar ways, making a system predictable to
  prefs: []
  type: TYPE_NORMAL
- en: client programmers.
  prefs: []
  type: TYPE_NORMAL
- en: '**208** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: I also discussed the idea of polymorphism in operators, explaining how the same
    operator could do different operations with different types
  prefs: []
  type: TYPE_NORMAL
- en: of data. I showed how Python’s magic methods are used to make this hap-
  prefs: []
  type: TYPE_NORMAL
- en: pen and how you can build methods to implement these operators in your
  prefs: []
  type: TYPE_NORMAL
- en: own classes. To demonstrate the use of arithmetic and comparison operator
  prefs: []
  type: TYPE_NORMAL
- en: magic methods, I showed a Vector class and a Fraction class. I also showed
  prefs: []
  type: TYPE_NORMAL
- en: how you can use the __str__() method to help in debugging the content of
  prefs: []
  type: TYPE_NORMAL
- en: an object.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **209**
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I N H E R I T A N C E**'
  prefs: []
  type: TYPE_NORMAL
- en: The third tenet of OOP is *inheritance*, which
  prefs: []
  type: TYPE_NORMAL
- en: is a mechanism for deriving a new class
  prefs: []
  type: TYPE_NORMAL
- en: from an existing class. Rather than starting
  prefs: []
  type: TYPE_NORMAL
- en: from scratch and potentially duplicating code,
  prefs: []
  type: TYPE_NORMAL
- en: inheritance allows a programmer to write code for
  prefs: []
  type: TYPE_NORMAL
- en: a new class that extends or differentiates it from an
  prefs: []
  type: TYPE_NORMAL
- en: existing class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with a real-world example that demonstrates what inheri-
  prefs: []
  type: TYPE_NORMAL
- en: tance is basically about. You’re attending culinary school. One of your les-
  prefs: []
  type: TYPE_NORMAL
- en: sons involves an exhaustive demonstration of making hamburgers. You learn
  prefs: []
  type: TYPE_NORMAL
- en: everything that there is to know about the different cuts of meat, the grind-
  prefs: []
  type: TYPE_NORMAL
- en: ing of the meat, the best types of buns, the best lettuce, tomato, and condi-
  prefs: []
  type: TYPE_NORMAL
- en: ments—just about everything you could imagine. You also learn about the
  prefs: []
  type: TYPE_NORMAL
- en: best way to cook the hamburger, how long to cook it, when and how often to
  prefs: []
  type: TYPE_NORMAL
- en: flip it over, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The next lesson in the curriculum is about cheeseburgers. The instructor
  prefs: []
  type: TYPE_NORMAL
- en: '*could* start from scratch and go through all the material about hamburgers'
  prefs: []
  type: TYPE_NORMAL
- en: again. But instead, they assume that you’ve retained the knowledge from the
    previous lesson and so already know everything there is to know about creating
    a great hamburger. This lesson therefore focuses on what types of cheese
  prefs: []
  type: TYPE_NORMAL
- en: to use, when to add it, how much to use, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The point of the story is that there is no need to “reinvent the wheel”;
  prefs: []
  type: TYPE_NORMAL
- en: instead, you can simply add on to what you already know.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance in Object-Oriented Programming**'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in OOP is the ability to create a class that builds on ( *extends*)
    an existing class. When creating large programs, you will often use classes that
  prefs: []
  type: TYPE_NORMAL
- en: provide very useful general capabilities. You’ll sometimes want to build a
  prefs: []
  type: TYPE_NORMAL
- en: class that’s similar to a class that already exists, but does some things slightly
  prefs: []
  type: TYPE_NORMAL
- en: differently. Inheritance allows you to do just that, creating a new class that
  prefs: []
  type: TYPE_NORMAL
- en: includes all the methods and instance variables of an existing class, but adds
  prefs: []
  type: TYPE_NORMAL
- en: new and different functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is an extremely powerful concept. When classes are set up
  prefs: []
  type: TYPE_NORMAL
- en: correctly, using inheritance can *seem* simple. However, being able to design
    classes to use it in a clear manner is a skill that’s difficult to master. As
    an
  prefs: []
  type: TYPE_NORMAL
- en: implementer, inheritance takes a great deal of practice to use properly and
  prefs: []
  type: TYPE_NORMAL
- en: efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance, we talk about the relationship between two classes,
  prefs: []
  type: TYPE_NORMAL
- en: typically referred to as the *base class* and *subclass*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Base class**'
  prefs: []
  type: TYPE_NORMAL
- en: The class that is inherited from; it serves as a starting point for the subclass
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**Subclass**'
  prefs: []
  type: TYPE_NORMAL
- en: The class that is doing the inheriting; it enhances the base class .
  prefs: []
  type: TYPE_NORMAL
- en: While these are the most common terms used to describe the two
  prefs: []
  type: TYPE_NORMAL
- en: 'classes in Python, you may also hear them referred to in other ways, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: • *Superclass* and *subclass*
  prefs: []
  type: TYPE_NORMAL
- en: • *Base class* and *derived* *class*
  prefs: []
  type: TYPE_NORMAL
- en: • *Parent* *class* and *child* *class*
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10-1 is a standard diagram that shows this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Base class
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: Subclass
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-1: A subclass inherits*'
  prefs: []
  type: TYPE_NORMAL
- en: '*from a base class.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**212** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: A subclass inherits all of the methods and instance variables defined in a base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10-2 provides a different, perhaps more accurate, way to think of
  prefs: []
  type: TYPE_NORMAL
- en: the relationship between the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Base class
  prefs: []
  type: TYPE_NORMAL
- en: Subclass
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-2: A base class is*'
  prefs: []
  type: TYPE_NORMAL
- en: '*incorporated into a subclass.*'
  prefs: []
  type: TYPE_NORMAL
- en: As the implementer, you can think of the base class as being incorpo-
  prefs: []
  type: TYPE_NORMAL
- en: rated into the subclass. That is, the base class actually becomes part of the
  prefs: []
  type: TYPE_NORMAL
- en: larger subclass. As a client of a subclass, you think about the subclass as
    a
  prefs: []
  type: TYPE_NORMAL
- en: single unit and do not need to know that the base class is there at all.
  prefs: []
  type: TYPE_NORMAL
- en: When discussing inheritance, we often say there is an *is a* relationship
  prefs: []
  type: TYPE_NORMAL
- en: between a subclass and a base class. For example, a student is a person, an
  prefs: []
  type: TYPE_NORMAL
- en: orange is a fruit, a car is a vehicle, and so on. The subclass is a specialized
  prefs: []
  type: TYPE_NORMAL
- en: version of the base class that inherits all the properties and behavior of the
  prefs: []
  type: TYPE_NORMAL
- en: base class, but also provides additional details and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, a subclass extends a base class in either or both of
  prefs: []
  type: TYPE_NORMAL
- en: 'the following ways (which will be explained soon):'
  prefs: []
  type: TYPE_NORMAL
- en: • A subclass can *redefine* a method that’s defined in the base class. That
  prefs: []
  type: TYPE_NORMAL
- en: is, a subclass can provide a method with same name as one in the base
  prefs: []
  type: TYPE_NORMAL
- en: class but with different functionality. This is called *overriding* a method.
  prefs: []
  type: TYPE_NORMAL
- en: When client code makes a call to an overridden method, the method in
  prefs: []
  type: TYPE_NORMAL
- en: the subclass is called. (However, the code of the method in the subclass
  prefs: []
  type: TYPE_NORMAL
- en: can still call the method of the same name in the base class.)
  prefs: []
  type: TYPE_NORMAL
- en: • A subclass can add new methods and instance variables that do not
  prefs: []
  type: TYPE_NORMAL
- en: appear in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: One way to think of a subclass is with the phrase *coding by difference*.
  prefs: []
  type: TYPE_NORMAL
- en: Since the subclass inherits all the instance variables and methods of the
  prefs: []
  type: TYPE_NORMAL
- en: base class, it does not need to repeat all of that code; the subclass only
  prefs: []
  type: TYPE_NORMAL
- en: needs to contain code that differentiates it from the base class. The code
  prefs: []
  type: TYPE_NORMAL
- en: of the subclass therefore only contains new instance variables (and their
  prefs: []
  type: TYPE_NORMAL
- en: initialization), overriding methods, and/or new methods not found in the
  prefs: []
  type: TYPE_NORMAL
- en: base class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of inheritance in Python is simple and elegant. The base class
  prefs: []
  type: TYPE_NORMAL
- en: does not need to *know* that it is being used as a base class. Only the subclass
    Inheritance **213**
  prefs: []
  type: TYPE_NORMAL
- en: 'needs to indicate that it wants to inherit from a base class. Here is the general
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class *<BaseClassName>* ():'
  prefs: []
  type: TYPE_NORMAL
- en: BaseClass methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class *<SubClassName>* ( *<BaseClassName>* ):'
  prefs: []
  type: TYPE_NORMAL
- en: SubClass methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the class statement of the subclass, within the parentheses you spec-
  prefs: []
  type: TYPE_NORMAL
- en: ify the name of the base class it should inherit from. In this case, we want
  prefs: []
  type: TYPE_NORMAL
- en: the subclass *<SubClassName>* to inherit from the base class *<BaseClassName>*
    .
  prefs: []
  type: TYPE_NORMAL
- en: '(Programmers will often use the word *subclass* as a verb, as in “Let’s subclass
    ClassA to build ClassB.”) Here’s an example with real class names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Widget():'
  prefs: []
  type: TYPE_NORMAL
- en: Widget's methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class WidgetWithFrills(Widget):'
  prefs: []
  type: TYPE_NORMAL
- en: WidgetWithFrills's methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Widget class will provide general functionality. The WidgetWithFrills
  prefs: []
  type: TYPE_NORMAL
- en: class will include everything from the Widget class and define any additional
  prefs: []
  type: TYPE_NORMAL
- en: methods and instance variables it wants with more specific capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Employee and Manager Example**'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with an extremely simple example to make the key concepts clear,
  prefs: []
  type: TYPE_NORMAL
- en: then move on to some more practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: '***Base Class: Employee***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10-1 defines a base class called Employee.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Employee Manager inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: Define the Employee class, which we will use as a base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Employee():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, title, ratePerHour=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: self.title = title
  prefs: []
  type: TYPE_NORMAL
- en: 'if ratePerHour is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: ratePerHour = float(ratePerHour)
  prefs: []
  type: TYPE_NORMAL
- en: self.ratePerHour = ratePerHour
  prefs: []
  type: TYPE_NORMAL
- en: 'def getName(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.name
  prefs: []
  type: TYPE_NORMAL
- en: 'def getTitle(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '**214** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: return self.title
  prefs: []
  type: TYPE_NORMAL
- en: 'def payPerYear(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 52 weeks * 5 days a week * 8 hours per day
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pay = 52 * 5 * 8 * self.ratePerHour
  prefs: []
  type: TYPE_NORMAL
- en: return pay
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-1: The Employee class, which will be used as a base class*'
  prefs: []
  type: TYPE_NORMAL
- en: The Employee class has the methods __init__(), getName(), getTitle(), and
  prefs: []
  type: TYPE_NORMAL
- en: payPerYear(). It also has three instance variables, self.name, self.title, and
  prefs: []
  type: TYPE_NORMAL
- en: self.ratePerHour, which are set in the __init__() method. We retrieve the
  prefs: []
  type: TYPE_NORMAL
- en: name and title using getter methods. These employees are paid per hour, so
  prefs: []
  type: TYPE_NORMAL
- en: self.payPerYear() does a calculation to determine the annual pay based on the
  prefs: []
  type: TYPE_NORMAL
- en: hourly rate. Everything in this class should be familiar to you; there is noth-
  prefs: []
  type: TYPE_NORMAL
- en: ing new here. You can instantiate an Employee object by itself, and it will
    work
  prefs: []
  type: TYPE_NORMAL
- en: fine.
  prefs: []
  type: TYPE_NORMAL
- en: '***Subclass: Manager***'
  prefs: []
  type: TYPE_NORMAL
- en: For the Manager class, we consider the differences between a manager and an
  prefs: []
  type: TYPE_NORMAL
- en: 'employee: the manager is a salaried employee who has a number of direct'
  prefs: []
  type: TYPE_NORMAL
- en: reports. If this manager does a good job, they get a 10 percent bonus for the
  prefs: []
  type: TYPE_NORMAL
- en: year. The Manager class can extend the Employee class, since the manager is
    an
  prefs: []
  type: TYPE_NORMAL
- en: employee but has additional capabilities and responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10-2 shows the code of our Manager class. It only needs to contain
  prefs: []
  type: TYPE_NORMAL
- en: code that is different from the Employee class, so you’ll see that it doesn’t
  prefs: []
  type: TYPE_NORMAL
- en: have a getName() or getTitle() method. Any calls to those methods with a
  prefs: []
  type: TYPE_NORMAL
- en: Manager object will be handled by the methods in the Employee class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Define a Manager subclass that inherits from Employee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1 class Manager(Employee):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, title, salary, reportsList=None):'
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.salary = float(salary)
  prefs: []
  type: TYPE_NORMAL
- en: 'if reportsList is None:'
  prefs: []
  type: TYPE_NORMAL
- en: reportsList = []
  prefs: []
  type: TYPE_NORMAL
- en: self.reportsList = reportsList
  prefs: []
  type: TYPE_NORMAL
- en: 3 super().__init__(name, title)
  prefs: []
  type: TYPE_NORMAL
- en: '4 def getReports(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.reportsList
  prefs: []
  type: TYPE_NORMAL
- en: '5 def payPerYear(self, giveBonus=False):'
  prefs: []
  type: TYPE_NORMAL
- en: pay = self.salary
  prefs: []
  type: TYPE_NORMAL
- en: 'if giveBonus:'
  prefs: []
  type: TYPE_NORMAL
- en: 'pay = pay + (.10 * self.salary) # add a bonus of 10%'
  prefs: []
  type: TYPE_NORMAL
- en: 6 print(self.name, 'gets a bonus for good work')
  prefs: []
  type: TYPE_NORMAL
- en: return pay
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-2: The Manager class, implemented as a subclass of the Employee
    class* Inheritance **215**'
  prefs: []
  type: TYPE_NORMAL
- en: In the class statement 1, you can see that this class inherits from the Employee
    class because Employee is inside the parentheses after the name
  prefs: []
  type: TYPE_NORMAL
- en: Manager.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method of the Employee class expects a name, a title, and
  prefs: []
  type: TYPE_NORMAL
- en: an optional rate per hour. A manager is a salaried employee and manages a
  prefs: []
  type: TYPE_NORMAL
- en: number of employees, so the __init__() method of the Manager class expects
  prefs: []
  type: TYPE_NORMAL
- en: a name, a title, a salary, and a list of employees. Adhering to the principle
  prefs: []
  type: TYPE_NORMAL
- en: of coding by difference, the __init__() method starts by initializing any-
  prefs: []
  type: TYPE_NORMAL
- en: thing the __init__() method of the Employee class doesn’t do. Therefore, we
  prefs: []
  type: TYPE_NORMAL
- en: save the salary and reportsList in similarly named instance variables 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Next we want to call the __init__() method of the Employee base class 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I am calling the built-in function super(), which asks Python to figure
  prefs: []
  type: TYPE_NORMAL
- en: out which class is the base class (often referred to as the *superclass*) and
    call that class’s __init__() method. It also adjusts the arguments to include
    self
  prefs: []
  type: TYPE_NORMAL
- en: as the first argument in this call. Therefore, you can think of this line as
  prefs: []
  type: TYPE_NORMAL
- en: 'translating to:'
  prefs: []
  type: TYPE_NORMAL
- en: Employee.__init__(self, name, title)
  prefs: []
  type: TYPE_NORMAL
- en: In fact, coding that line this way would work perfectly well; using the
  prefs: []
  type: TYPE_NORMAL
- en: call to super() is simply a much cleaner way to write the call without having
  prefs: []
  type: TYPE_NORMAL
- en: to specify the name of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: The effect is that the new Manager class’s __init__() method initializes
  prefs: []
  type: TYPE_NORMAL
- en: the two instance variables (self.salary and self.reportsList) that are dif-
  prefs: []
  type: TYPE_NORMAL
- en: ferent from those in the Employee class, and the Employee class’s __init__()
  prefs: []
  type: TYPE_NORMAL
- en: method initializes the self.name and self.title instance variables that are
  prefs: []
  type: TYPE_NORMAL
- en: common to any Employee or Manager object that is created. For a Manager who
  prefs: []
  type: TYPE_NORMAL
- en: has a salary, self.ratePerHour is set to None.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Older versions of Python required you to write this code in yet a third way,
    so you may* *see this in older programs and documentation:*'
  prefs: []
  type: TYPE_NORMAL
- en: super(Employee, self).__init__(name, salary)
  prefs: []
  type: TYPE_NORMAL
- en: '*This also does the exact same thing. However, the newer syntax with the simple*'
  prefs: []
  type: TYPE_NORMAL
- en: '*call to super() is much easier to remember. Using super() also makes it less
    error-prone if you decide that you want to change the name of your base class.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Manager class has an added getter method, getReports() 4, that
  prefs: []
  type: TYPE_NORMAL
- en: allows client code to retrieve a list of Employees who report to the Manager.
  prefs: []
  type: TYPE_NORMAL
- en: The payPerYear() method 5 calculates and returns the Manager’s pay.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both the Employee and the Manager classes have a method
  prefs: []
  type: TYPE_NORMAL
- en: named payPerYear(). If you call the payPerYear() method using an instance
  prefs: []
  type: TYPE_NORMAL
- en: of Employee, the Employee class’s method will run and calculate the pay based
  prefs: []
  type: TYPE_NORMAL
- en: on the hourly rate. If you call the payPerYear() method with an instance of
  prefs: []
  type: TYPE_NORMAL
- en: Manager, the Manager class’s method will run and do a different calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The payPerYear() method in the Manager class *overrides* the method by the
  prefs: []
  type: TYPE_NORMAL
- en: same name in the base class. Overriding a method in a subclass specializes
  prefs: []
  type: TYPE_NORMAL
- en: '**216** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: the subclass to differentiate it from the base class. The overriding method
    must have the exact same name as the method that it overrides (although it
  prefs: []
  type: TYPE_NORMAL
- en: 'may have a different list of parameters). In the overriding method, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: • Completely replace the overridden method in the base class. We see
  prefs: []
  type: TYPE_NORMAL
- en: this in the payPerYear() method of the Manager class.
  prefs: []
  type: TYPE_NORMAL
- en: • Do some work on its own and call the inherited or overridden method
  prefs: []
  type: TYPE_NORMAL
- en: of the same name in the base class. We see this in the __init__()
  prefs: []
  type: TYPE_NORMAL
- en: method of the Manager class.
  prefs: []
  type: TYPE_NORMAL
- en: The actual content of the overriding method depends on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: If the client makes a call to a method that does not exist in a subclass, the
  prefs: []
  type: TYPE_NORMAL
- en: method call will be sent on to the base class. For example, notice that there
  prefs: []
  type: TYPE_NORMAL
- en: is no method named getName() in the Manager class, but it does exist in the
  prefs: []
  type: TYPE_NORMAL
- en: Employee base class. If a client calls getName() on an instance of Manager,
    that
  prefs: []
  type: TYPE_NORMAL
- en: call is handled by the base class, Employee.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payPerYear() method of the Manager class contains this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if giveBonus:'
  prefs: []
  type: TYPE_NORMAL
- en: 'pay = pay + (.10 * self.salary) # add a bonus of 10%'
  prefs: []
  type: TYPE_NORMAL
- en: 6 print(self.name, 'gets a bonus for good work')
  prefs: []
  type: TYPE_NORMAL
- en: The instance variable self.name was defined in the Employee class, but the
  prefs: []
  type: TYPE_NORMAL
- en: Manager class has no previous mention of it. This demonstrates that instance
  prefs: []
  type: TYPE_NORMAL
- en: variables defined in a base class are available for use in methods of a sub-
  prefs: []
  type: TYPE_NORMAL
- en: class. Here we are calculating the pay for a manager, which works correctly
  prefs: []
  type: TYPE_NORMAL
- en: because payPerYear() has access to instance variables defined inside its own
  prefs: []
  type: TYPE_NORMAL
- en: class (self.salary) *and* instance variables defined in the base class (printing
    using self.name 6).
  prefs: []
  type: TYPE_NORMAL
- en: '***Test Code***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test our Employee and Manager objects and call methods of each.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Create objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oEmployee1 = Employee('Joe Schmoe', 'Pizza Maker', 16)
  prefs: []
  type: TYPE_NORMAL
- en: oEmployee2 = Employee('Chris Smith', 'Cashier', 14)
  prefs: []
  type: TYPE_NORMAL
- en: oManager = Manager('Sue Jones', 'Pizza Restaurant Manager',
  prefs: []
  type: TYPE_NORMAL
- en: 55000, [oEmployee1, oEmployee2])
  prefs: []
  type: TYPE_NORMAL
- en: Call methods of the Employee objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Employee name:', oEmployee1.getName())
  prefs: []
  type: TYPE_NORMAL
- en: print('Employee salary:', '{:,.2f}'.format(oEmployee1.payPerYear()))
  prefs: []
  type: TYPE_NORMAL
- en: print('Employee name:', oEmployee2.getName())
  prefs: []
  type: TYPE_NORMAL
- en: print('Employee salary:', '{:,.2f}'.format(oEmployee2.payPerYear()))
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: Call methods of the Manager object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: managerName = oManager.getName()
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **217**
  prefs: []
  type: TYPE_NORMAL
- en: print('Manager name:', managerName)
  prefs: []
  type: TYPE_NORMAL
- en: Give the manager a bonus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Manager salary:', '{:,.2f}'.format(oManager.payPerYear(True)))
  prefs: []
  type: TYPE_NORMAL
- en: print(managerName, '(' + oManager.getTitle() + ')', 'direct reports:')
  prefs: []
  type: TYPE_NORMAL
- en: reportsList = oManager.getReports()
  prefs: []
  type: TYPE_NORMAL
- en: 'for oEmployee in reportsList:'
  prefs: []
  type: TYPE_NORMAL
- en: print(' ', oEmployee.getName(),
  prefs: []
  type: TYPE_NORMAL
- en: '''('' + oEmployee.getTitle() + '')'')'
  prefs: []
  type: TYPE_NORMAL
- en: When we run this code, we see the following output, as we would
  prefs: []
  type: TYPE_NORMAL
- en: 'expect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Employee name: Joe Schmoe'
  prefs: []
  type: TYPE_NORMAL
- en: 'Employee salary: 33,280.00'
  prefs: []
  type: TYPE_NORMAL
- en: 'Employee name: Chris Smith'
  prefs: []
  type: TYPE_NORMAL
- en: 'Employee salary: 29,120.00'
  prefs: []
  type: TYPE_NORMAL
- en: 'Manager name: Sue Jones'
  prefs: []
  type: TYPE_NORMAL
- en: Sue Jones gets a bonus for good work
  prefs: []
  type: TYPE_NORMAL
- en: 'Manager salary: 60,500.00'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sue Jones (Pizza Restaurant Manager) direct reports:'
  prefs: []
  type: TYPE_NORMAL
- en: Joe Schmoe (Pizza Maker)
  prefs: []
  type: TYPE_NORMAL
- en: Chris Smith (Cashier)
  prefs: []
  type: TYPE_NORMAL
- en: '**The Client’s View of a Subclass**'
  prefs: []
  type: TYPE_NORMAL
- en: The discussion so far has been focused on the details of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: But classes can look different depending on whether you are the developer
  prefs: []
  type: TYPE_NORMAL
- en: of a class or are writing code to use a class. Let’s change focus and take a
  prefs: []
  type: TYPE_NORMAL
- en: look at inheritance from the client’s point of view. As far as client code is
  prefs: []
  type: TYPE_NORMAL
- en: concerned, a subclass has all the functionality of the base class, plus any-
  prefs: []
  type: TYPE_NORMAL
- en: thing defined in the subclass itself. It may help to think about the result-
  prefs: []
  type: TYPE_NORMAL
- en: ing collection of methods as layers of paint on a wall. When a client looks
  prefs: []
  type: TYPE_NORMAL
- en: at the Employee class, the client sees all the methods defined in that class
  prefs: []
  type: TYPE_NORMAL
- en: (Figure 10-3).
  prefs: []
  type: TYPE_NORMAL
- en: Employee
  prefs: []
  type: TYPE_NORMAL
- en: _init_()
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs: []
  type: TYPE_NORMAL
- en: getName()
  prefs: []
  type: TYPE_NORMAL
- en: getTitle()
  prefs: []
  type: TYPE_NORMAL
- en: payPerYear()
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-3: What a client would see looking at the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*interface of the Employee class*'
  prefs: []
  type: TYPE_NORMAL
- en: '**218** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: When we introduce the Manager class that inherits from the Employee class, it’s
    like adding paint to touch up the places where we want to add or
  prefs: []
  type: TYPE_NORMAL
- en: change methods. For methods that we don’t want to change, we just leave
  prefs: []
  type: TYPE_NORMAL
- en: the old layer of paint (Figure 10-4).
  prefs: []
  type: TYPE_NORMAL
- en: Manager
  prefs: []
  type: TYPE_NORMAL
- en: Employee
  prefs: []
  type: TYPE_NORMAL
- en: _init_()
  prefs: []
  type: TYPE_NORMAL
- en: _init_()
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs: []
  type: TYPE_NORMAL
- en: getName()
  prefs: []
  type: TYPE_NORMAL
- en: getTitle()
  prefs: []
  type: TYPE_NORMAL
- en: payPerYear()
  prefs: []
  type: TYPE_NORMAL
- en: payPerYear()
  prefs: []
  type: TYPE_NORMAL
- en: getReports()
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-4: What a client would see looking at the interface of*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the Manager class*'
  prefs: []
  type: TYPE_NORMAL
- en: As the developer, we know that the Manager class inherits from the
  prefs: []
  type: TYPE_NORMAL
- en: Employee class and overrides some methods. As the client, we just see five
  prefs: []
  type: TYPE_NORMAL
- en: methods. The client doesn’t need to know that some methods are imple-
  prefs: []
  type: TYPE_NORMAL
- en: mented in the Manager class and others come from the inherited Employee
  prefs: []
  type: TYPE_NORMAL
- en: class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-World Examples of Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at two real-world examples of inheritance. First, I’ll show
  prefs: []
  type: TYPE_NORMAL
- en: you how to build an input field that only allows you to enter numbers. I’ll
  prefs: []
  type: TYPE_NORMAL
- en: then build an output field that formats monetary values.
  prefs: []
  type: TYPE_NORMAL
- en: '***InputNumber***'
  prefs: []
  type: TYPE_NORMAL
- en: In this first example, we’ll create an input field that allows the user to input
  prefs: []
  type: TYPE_NORMAL
- en: only numerical data. As a general user interface design principle, it’s much
  prefs: []
  type: TYPE_NORMAL
- en: better to restrict the input to allow only for correctly formatted data while
  prefs: []
  type: TYPE_NORMAL
- en: the user is entering the data, rather than allowing any input and checking
  prefs: []
  type: TYPE_NORMAL
- en: its correctness later. Entering letters or other symbols in this input field,
    or
  prefs: []
  type: TYPE_NORMAL
- en: attempting to enter multiple decimal points or multiple minus signs, should
  prefs: []
  type: TYPE_NORMAL
- en: not be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets package contains an InputText class that allows the user
  prefs: []
  type: TYPE_NORMAL
- en: to input any characters. We’ll write an InputNumber class to allow only valid
  prefs: []
  type: TYPE_NORMAL
- en: numbers as input. The new InputNumber class will inherit much of its code
  prefs: []
  type: TYPE_NORMAL
- en: 'from InputText. We’ll only need to override three methods of InputText:'
  prefs: []
  type: TYPE_NORMAL
- en: __init__(), handleEvent(), and getValue(). Listing 10-3 shows the InputNumber
  prefs: []
  type: TYPE_NORMAL
- en: class that overrides these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **219**
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MoneyExamples/InputNumber.py**'
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber class - allows the user to enter only numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: Demo of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WHITE = (255, 255, 255)
  prefs: []
  type: TYPE_NORMAL
- en: Tuple of legal editing keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LEGAL_KEYS_TUPLE = (pygame.K_RIGHT, pygame.K_LEFT, pygame.K_HOME,
  prefs: []
  type: TYPE_NORMAL
- en: pygame.K_END, pygame.K_DELETE, pygame.K_BACKSPACE,
  prefs: []
  type: TYPE_NORMAL
- en: pygame.K_RETURN, pygame.K_KP_ENTER)
  prefs: []
  type: TYPE_NORMAL
- en: Legal keys to be typed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LEGAL_UNICODE_CHARS = ('0123456789.-')
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber inherits from InputText
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: 'class InputNumber(pygwidgets.InputText):'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, window, loc, value='', fontName=None, 1
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=24, width=200, textColor=BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=WHITE, focusColor=BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: initialFocus=False, nickName=None, callback=None,
  prefs: []
  type: TYPE_NORMAL
- en: mask=None, keepFocusOnSubmit=False,
  prefs: []
  type: TYPE_NORMAL
- en: 'allowFloatingNumber=True, allowNegativeNumber=True):'
  prefs: []
  type: TYPE_NORMAL
- en: self.allowFloatingNumber = allowFloatingNumber
  prefs: []
  type: TYPE_NORMAL
- en: self.allowNegativeNumber = allowNegativeNumber
  prefs: []
  type: TYPE_NORMAL
- en: Call the __init__ method of our base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: super().__init__(window, loc, value, fontName, fontSize, 2
  prefs: []
  type: TYPE_NORMAL
- en: width, textColor, backgroundColor,
  prefs: []
  type: TYPE_NORMAL
- en: focusColor, initialFocus, nickName, callback,
  prefs: []
  type: TYPE_NORMAL
- en: mask, keepFocusOnSubmit)
  prefs: []
  type: TYPE_NORMAL
- en: Override handleEvent so we can filter for proper keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def handleEvent(self, event): 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (event.type == pygame.KEYDOWN):'
  prefs: []
  type: TYPE_NORMAL
- en: If it's not an editing or numeric key, ignore it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unicode value is only present on key down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: allowableKey = (event.key in LEGAL_KEYS_TUPLE) or
  prefs: []
  type: TYPE_NORMAL
- en: (event.unicode in LEGAL_UNICODE_CHARS))
  prefs: []
  type: TYPE_NORMAL
- en: 'if not allowableKey:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.unicode == ''-'': # user typed a minus sign'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.allowNegativeNumber:'
  prefs: []
  type: TYPE_NORMAL
- en: If no negatives, don't pass it through
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.cursorPosition > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '**220** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # can''t put minus sign after 1st char'
  prefs: []
  type: TYPE_NORMAL
- en: 'if ''-'' in self.text:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # can''t enter a second minus sign'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.unicode == ''.'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.allowFloatingNumber:'
  prefs: []
  type: TYPE_NORMAL
- en: If no floats, don't pass the period through
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'if ''.'' in self.text:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # can''t enter a second period'
  prefs: []
  type: TYPE_NORMAL
- en: Allow the key to go through to the base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: result = super().handleEvent(event)
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'def getValue(self): 4'
  prefs: []
  type: TYPE_NORMAL
- en: userString = super().getValue()
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.allowFloatingNumber:'
  prefs: []
  type: TYPE_NORMAL
- en: returnValue = float(userString)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: returnValue = int(userString)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError('Entry is not a number, needs to have at least one digit.')
  prefs: []
  type: TYPE_NORMAL
- en: return returnValue
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-3: InputNumber only al ows the user to enter numeric data.*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method allows for the same parameters as the InputText
  prefs: []
  type: TYPE_NORMAL
- en: 'base class, plus a few more 1\. It adds two Booleans: allowFloatingNumber to'
  prefs: []
  type: TYPE_NORMAL
- en: determine if the user should be allowed to enter floating-point numbers
  prefs: []
  type: TYPE_NORMAL
- en: and allowNegativeNumber to determine if the user can enter a number starting
  prefs: []
  type: TYPE_NORMAL
- en: with a minus sign. Both default to True, so the default case allows the user
    to
  prefs: []
  type: TYPE_NORMAL
- en: enter a floating-point number and both positive and negative numbers. You
  prefs: []
  type: TYPE_NORMAL
- en: could use these to restrict the user to, for example, only entering a positive
  prefs: []
  type: TYPE_NORMAL
- en: integer value by setting both to False. The __init__() method saves the val-
  prefs: []
  type: TYPE_NORMAL
- en: ues of these two additional parameters in instance variables, then calls the
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method of the base class using the call to super() 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The significant code is in the handleEvent() method 3, which restricts
  prefs: []
  type: TYPE_NORMAL
- en: 'the allowed keys to a small subset: the numbers zero through nine, the'
  prefs: []
  type: TYPE_NORMAL
- en: minus sign, a period (decimal point), ENTER, and a few editing keys. When
  prefs: []
  type: TYPE_NORMAL
- en: the user presses a key, this method is called and a KEYDOWN or KEYUP event is
  prefs: []
  type: TYPE_NORMAL
- en: passed in. The code first ensures that the key pressed is in the restricted
    set.
  prefs: []
  type: TYPE_NORMAL
- en: If the user enters a key not in that set (for example, any letter), we return
  prefs: []
  type: TYPE_NORMAL
- en: False to indicate that nothing important has happened in this widget, and
  prefs: []
  type: TYPE_NORMAL
- en: that key is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The handleEvent() method then does a few more checks to ensure that
  prefs: []
  type: TYPE_NORMAL
- en: the number being entered is legal (for example, doesn’t have two periods,
  prefs: []
  type: TYPE_NORMAL
- en: only has one minus sign and, so on). Whenever a valid key press is detected,
  prefs: []
  type: TYPE_NORMAL
- en: the code calls the handleEvent() method of the InputText base class to do
  prefs: []
  type: TYPE_NORMAL
- en: whatever it needs to do with that key (display or edit the field).
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **221**
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses RETURN or ENTER, client code calls the get-
  prefs: []
  type: TYPE_NORMAL
- en: Value() method 4 to get the user’s entry. The getValue() method in this class
  prefs: []
  type: TYPE_NORMAL
- en: calls getValue() in the InputText class to get the string from the field, then
  prefs: []
  type: TYPE_NORMAL
- en: attempts to convert that string to a number. If that conversion fails, it raises
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: By overriding methods, we have built a very powerful new reusable class
  prefs: []
  type: TYPE_NORMAL
- en: that extends the functionality of the InputText class, without changing a
  prefs: []
  type: TYPE_NORMAL
- en: single line in the base class. InputText will continue to function as a class
    by
  prefs: []
  type: TYPE_NORMAL
- en: itself, without any changes to its functionality whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: '***DisplayMoney***'
  prefs: []
  type: TYPE_NORMAL
- en: As a second real-world example, we’ll create a field to display an amount of
  prefs: []
  type: TYPE_NORMAL
- en: money. To make this general, we’ll display the amount with a chosen cur-
  prefs: []
  type: TYPE_NORMAL
- en: rency symbol, place that currency symbol to the left or the right of the text
  prefs: []
  type: TYPE_NORMAL
- en: (as appropriate), and format the number by adding commas between every
  prefs: []
  type: TYPE_NORMAL
- en: three digits, followed by a period and then two decimal digits. For example,
  prefs: []
  type: TYPE_NORMAL
- en: we would like to be able to display 1234.56 US dollars as $1,234.56\.
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets package already has a DisplayText class. We can instanti-
  prefs: []
  type: TYPE_NORMAL
- en: 'ate an object from that class using the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, window, loc=(0, 0), value='',
  prefs: []
  type: TYPE_NORMAL
- en: fontName=None, fontSize=18, width=None, height=None,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=PYGWIDGETS_BLACK, backgroundColor=None,
  prefs: []
  type: TYPE_NORMAL
- en: 'justified=''left'', nickname=None):'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we have some code that creates a DisplayText object
  prefs: []
  type: TYPE_NORMAL
- en: named oSomeDisplayText using the appropriate arguments. Any time that we
  prefs: []
  type: TYPE_NORMAL
- en: want to update the text in a DisplayText object, we must call its setValue()
  prefs: []
  type: TYPE_NORMAL
- en: 'method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oSomeDisplayText.setValue('1234.56')
  prefs: []
  type: TYPE_NORMAL
- en: The functionality of displaying a number (as a string) with a DisplayText
  prefs: []
  type: TYPE_NORMAL
- en: object already exists. We want to create a new class named DisplayMoney that
    is
  prefs: []
  type: TYPE_NORMAL
- en: similar to DisplayText but adds functionality, so we’ll inherit from DisplayText.
  prefs: []
  type: TYPE_NORMAL
- en: Our DisplayMoney class will have an enhanced version of the setValue()
  prefs: []
  type: TYPE_NORMAL
- en: method that overrides the base class’s setValue() method. The DisplayMoney
  prefs: []
  type: TYPE_NORMAL
- en: version will add the desired formatting, by adding a currency symbol, add-
  prefs: []
  type: TYPE_NORMAL
- en: ing commas, optionally truncating to two decimal digits, and so on. At the
  prefs: []
  type: TYPE_NORMAL
- en: end, the method will call the inherited setValue() method of the DisplayText
  prefs: []
  type: TYPE_NORMAL
- en: base class and pass in a string version of the formatted text to display in
    the
  prefs: []
  type: TYPE_NORMAL
- en: window.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also add some additional setup parameters in the __init__()
  prefs: []
  type: TYPE_NORMAL
- en: 'method to allow client code to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Choose the currency symbol (defaults to $)
  prefs: []
  type: TYPE_NORMAL
- en: • Place the currency symbol on the left or right (defaults to left)
  prefs: []
  type: TYPE_NORMAL
- en: • Show or hide two decimal places (defaults to show)
  prefs: []
  type: TYPE_NORMAL
- en: '**222** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10-4 shows the code of our new DisplayMoney class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MoneyExamples/DisplayMoney.py**'
  prefs: []
  type: TYPE_NORMAL
- en: DisplayMoney class - displays a number as an amount of money
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: Demo of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: DisplayMoney class inherits from DisplayText class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: '1 class DisplayMoney(pygwidgets.DisplayText):'
  prefs: []
  type: TYPE_NORMAL
- en: 2 def __init__(self, window, loc, value=None,
  prefs: []
  type: TYPE_NORMAL
- en: fontName=None, fontSize=24, width=150, height=None,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=BLACK, backgroundColor=None,
  prefs: []
  type: TYPE_NORMAL
- en: justified='left', value=None, currencySymbol='$',
  prefs: []
  type: TYPE_NORMAL
- en: 'currencySymbolOnLeft=True, showCents=True):'
  prefs: []
  type: TYPE_NORMAL
- en: 3 self.currencySymbol = currencySymbol
  prefs: []
  type: TYPE_NORMAL
- en: self.currencySymbolOnLeft = currencySymbolOnLeft
  prefs: []
  type: TYPE_NORMAL
- en: self.showCents = showCents
  prefs: []
  type: TYPE_NORMAL
- en: 'if value is None:'
  prefs: []
  type: TYPE_NORMAL
- en: value = 0.00
  prefs: []
  type: TYPE_NORMAL
- en: Call the __init__ method of our base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 super().__init__(window, loc, value,
  prefs: []
  type: TYPE_NORMAL
- en: fontName, fontSize, width, height,
  prefs: []
  type: TYPE_NORMAL
- en: textColor, backgroundColor, justified)
  prefs: []
  type: TYPE_NORMAL
- en: '5 def setValue(self, money):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if money == '''':'
  prefs: []
  type: TYPE_NORMAL
- en: money = 0.00
  prefs: []
  type: TYPE_NORMAL
- en: money = float(money)
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.showCents:'
  prefs: []
  type: TYPE_NORMAL
- en: money = '{:,.2f}'.format(money)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: money = '{:,.0f}'.format(money)
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.currencySymbolOnLeft:'
  prefs: []
  type: TYPE_NORMAL
- en: theText = self.currencySymbol + money
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: theText = money + self.currencySymbol
  prefs: []
  type: TYPE_NORMAL
- en: Call the setValue method of our base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6 super().setValue(theText)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-4: DisplayMoney displays a number format ed as a monetary value.*'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **223**
  prefs: []
  type: TYPE_NORMAL
- en: In the class definition, we explicitly inherit from pygwidgets.DisplayText 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DisplayMoney class only contains two methods: __init__() and setValue().'
  prefs: []
  type: TYPE_NORMAL
- en: These two methods override the methods with the same names in the base
  prefs: []
  type: TYPE_NORMAL
- en: class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client instantiates a DisplayMoney object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oDisplayMoney = DisplayMoney(widow, (100, 100), 1234.56)
  prefs: []
  type: TYPE_NORMAL
- en: With this line, the __init__() method in DisplayMoney 2 will run and
  prefs: []
  type: TYPE_NORMAL
- en: override the __init__() method in the base class. This method does some
  prefs: []
  type: TYPE_NORMAL
- en: initialization, including saving any client preferences for the currency
  prefs: []
  type: TYPE_NORMAL
- en: symbol, the side on which to show the symbol, and whether or not we
  prefs: []
  type: TYPE_NORMAL
- en: should show cents, all in instance variables 3\. The method ends with a
  prefs: []
  type: TYPE_NORMAL
- en: call to the __init__() method of the base class, DisplayText 4 (which it
  prefs: []
  type: TYPE_NORMAL
- en: finds by calling super()), and passes on the data required by that
  prefs: []
  type: TYPE_NORMAL
- en: method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, the client makes a call like this to show a value:'
  prefs: []
  type: TYPE_NORMAL
- en: oDisplayMoney.setValue(12233.44)
  prefs: []
  type: TYPE_NORMAL
- en: The setValue() method 5 in the DisplayMoney class runs to create a ver-
  prefs: []
  type: TYPE_NORMAL
- en: sion of the amount of money formatted as a currency value. The method
  prefs: []
  type: TYPE_NORMAL
- en: ends by calling the inherited setValue() method in the DisplayText class 6 to
  prefs: []
  type: TYPE_NORMAL
- en: set the new text to display.
  prefs: []
  type: TYPE_NORMAL
- en: When a call is made to any other method with an instance of DisplayMoney,
  prefs: []
  type: TYPE_NORMAL
- en: the version residing in DisplayText will run. Most importantly, every time
  prefs: []
  type: TYPE_NORMAL
- en: through the loop, the client code should call oDisplayMoney.draw(), which
  prefs: []
  type: TYPE_NORMAL
- en: draws the field in the window. Since DisplayMoney does *not* have a draw()
  prefs: []
  type: TYPE_NORMAL
- en: method, that call will go to the DisplayText base class, which does have a
  prefs: []
  type: TYPE_NORMAL
- en: draw() method.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example Usage***'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10-5 shows the output of an example program that takes advantage
  prefs: []
  type: TYPE_NORMAL
- en: of both the InputNumber and DisplayMoney classes. The user enters a number
  prefs: []
  type: TYPE_NORMAL
- en: into an InputNumber field. When the user presses OK or ENTER, that value will
  prefs: []
  type: TYPE_NORMAL
- en: be displayed in the two DisplayMoney fields. The first field shows the number
  prefs: []
  type: TYPE_NORMAL
- en: with decimal places, and the second rounds to the closest dollar using dif-
  prefs: []
  type: TYPE_NORMAL
- en: ferent initial settings.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10-5 contains the full code of the main program. Notice
  prefs: []
  type: TYPE_NORMAL
- en: that the code creates a single InputNumber object and two DisplayMoney
  prefs: []
  type: TYPE_NORMAL
- en: objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**224** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 28](index-254_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: A client program where the user enters an amount into an InputNumber*
    *field and the amount is displayed in two DisplayMoney fields*'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MoneyExamples/Main_MoneyExample.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Money example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrates overriding inherited DisplayText and InputText methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: from DisplayMoney import *
  prefs: []
  type: TYPE_NORMAL
- en: from InputNumber import *
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLACKISH = (10, 10, 10)
  prefs: []
  type: TYPE_NORMAL
- en: GRAY = (128, 128, 128)
  prefs: []
  type: TYPE_NORMAL
- en: WHITE = (255, 255, 255)
  prefs: []
  type: TYPE_NORMAL
- en: BACKGROUND_COLOR = (0, 180, 180)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode([WINDOW_WIDTH, WINDOW_HEIGHT])
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance **225**
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: title = pygwidgets.DisplayText(window, (0, 40),
  prefs: []
  type: TYPE_NORMAL
- en: '''Demo of InputNumber and DisplayMoney fields'','
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=36, width=WINDOW_WIDTH, justified='center')
  prefs: []
  type: TYPE_NORMAL
- en: inputCaption = pygwidgets.DisplayText(window, (20, 150),
  prefs: []
  type: TYPE_NORMAL
- en: '''Input money amount:'', fontSize=24,'
  prefs: []
  type: TYPE_NORMAL
- en: width=190, justified='right')
  prefs: []
  type: TYPE_NORMAL
- en: inputField = InputNumber(window, (230, 150), '', width=150)
  prefs: []
  type: TYPE_NORMAL
- en: okButton = pygwidgets.TextButton(window, (430, 150), 'OK')
  prefs: []
  type: TYPE_NORMAL
- en: outputCaption1 = pygwidgets.DisplayText(window, (20, 300),
  prefs: []
  type: TYPE_NORMAL
- en: '''Output dollars & cents: '', fontSize=24,'
  prefs: []
  type: TYPE_NORMAL
- en: width=190, justified='right')
  prefs: []
  type: TYPE_NORMAL
- en: moneyField1 = DisplayMoney(window, (230, 300), '', textColor=BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=WHITE, width=150)
  prefs: []
  type: TYPE_NORMAL
- en: outputCaption2 = pygwidgets.DisplayText(window, (20, 400),
  prefs: []
  type: TYPE_NORMAL
- en: '''Output dollars only: '', fontSize=24,'
  prefs: []
  type: TYPE_NORMAL
- en: width=190, justified='right')
  prefs: []
  type: TYPE_NORMAL
- en: moneyField2 = DisplayMoney(window, (230, 400), '', textColor=BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=WHITE, width=150,
  prefs: []
  type: TYPE_NORMAL
- en: showCents=False)
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: If the event was a click on the close box, quit pygame and the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: Pressing Return/Enter or clicking OK triggers action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if inputField.handleEvent(event) or okButton.handleEvent(event): 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: theValue = inputField.getValue()
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError: # any remaining error'
  prefs: []
  type: TYPE_NORMAL
- en: inputField.setValue('(not a number)')
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # input was OK'
  prefs: []
  type: TYPE_NORMAL
- en: theText = str(theValue)
  prefs: []
  type: TYPE_NORMAL
- en: moneyField1.setValue(theText)
  prefs: []
  type: TYPE_NORMAL
- en: moneyField2.setValue(theText)
  prefs: []
  type: TYPE_NORMAL
- en: 8 Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BACKGROUND_COLOR)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: title.draw()
  prefs: []
  type: TYPE_NORMAL
- en: inputCaption.draw()
  prefs: []
  type: TYPE_NORMAL
- en: inputField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: okButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '**226** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: outputCaption1.draw()
  prefs: []
  type: TYPE_NORMAL
- en: moneyField1.draw()
  prefs: []
  type: TYPE_NORMAL
- en: outputCaption2.draw()
  prefs: []
  type: TYPE_NORMAL
- en: moneyField2.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-5: The main program to demonstrate the InputNumber and DisplayMoney
    classes* The user enters the number into an InputNumber field. As the user types,'
  prefs: []
  type: TYPE_NORMAL
- en: any inappropriate characters are filtered out and ignored by the handleEvent()
  prefs: []
  type: TYPE_NORMAL
- en: method. When the user clicks OK 1, the code reads the input and passes it to
  prefs: []
  type: TYPE_NORMAL
- en: the two DisplayMoney fields. The first shows the dollar and cents amount (with
  prefs: []
  type: TYPE_NORMAL
- en: two decimal digits), while the second shows the value in dollars only. Both
  prefs: []
  type: TYPE_NORMAL
- en: add a $ as the currency symbol and add commas every three digits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Classes Inheriting from the Same Base Class**'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple different classes can inherit from the same base class. You can
  prefs: []
  type: TYPE_NORMAL
- en: build a very general base class, then construct any number of subclasses
  prefs: []
  type: TYPE_NORMAL
- en: that inherit from it. Figure 10-6 is a representation of this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Base class
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: Subclass
  prefs: []
  type: TYPE_NORMAL
- en: Subclass
  prefs: []
  type: TYPE_NORMAL
- en: Subclass
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-6: Three or more different subclasses inheriting from a common base
    class* Each of the different subclasses can then be a variant (a more specific'
  prefs: []
  type: TYPE_NORMAL
- en: version) of the generic base class. Each subclass can override any methods
  prefs: []
  type: TYPE_NORMAL
- en: of the base class that it wants to or needs to, independent of any other
  prefs: []
  type: TYPE_NORMAL
- en: subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through an example using the Shapes program from
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9 t](index_split_003.html#p212)hat created and drew circles, squares,
    and triangles. The code also allowed the user to click on any shape in the window
    to see the area of'
  prefs: []
  type: TYPE_NORMAL
- en: that shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program was implemented with three different shape classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Circle, Square, and Triangle. If we look back at those three classes, we find
  prefs: []
  type: TYPE_NORMAL
- en: 'that each one has this exact same method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getType(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **227**
  prefs: []
  type: TYPE_NORMAL
- en: Further, looking at the __init__() methods of the three classes, we find that
    there is some common code that remembers the window, chooses a
  prefs: []
  type: TYPE_NORMAL
- en: 'random color, and chooses a random location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(1, maxHeight - 100)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, each class sets the instance variable self.shapeType to an appro-
  prefs: []
  type: TYPE_NORMAL
- en: priate string.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we find a set of classes that implement the exact same method
  prefs: []
  type: TYPE_NORMAL
- en: and/or share some code in a commonly named method, we should recog-
  prefs: []
  type: TYPE_NORMAL
- en: nize that this is a good candidate for inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extract the common code from the three classes and build a com-
  prefs: []
  type: TYPE_NORMAL
- en: mon base class named Shape, shown in Listing 10-6\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/ShapeBasic.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Shape class - basic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Shape():'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, shapeType, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = shapeType
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  prefs: []
  type: TYPE_NORMAL
- en: '2 def getType(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-6: The Shape class, to be used as a base class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class consists of only two methods: __init__() and getType(). The'
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method 1 remembers the data passed in in instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: ables, then randomly chooses a color and a starting location (self.x and
  prefs: []
  type: TYPE_NORMAL
- en: self.y). The getType() method 2 just returns the type of the shape given
  prefs: []
  type: TYPE_NORMAL
- en: at initialization.
  prefs: []
  type: TYPE_NORMAL
- en: We can now write any number of subclasses that inherit from Shape.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create three subclasses that will call the __init__() method of the Shape
  prefs: []
  type: TYPE_NORMAL
- en: class, passing in a string that identifies its type and the size of the window.
  prefs: []
  type: TYPE_NORMAL
- en: The getType() method will only appear in the Shape class, so any client calls
  prefs: []
  type: TYPE_NORMAL
- en: '**228** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: to getType() will be handled by that method in the inherited Shape class.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the code for the Square class, shown in Listing 10-7\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/Square.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Square class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from Shape import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class Square(Shape): 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__(window, 'Square', maxWidth, maxHeight) 2
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y,
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight, self.widthAndHeight)
  prefs: []
  type: TYPE_NORMAL
- en: 'def clickedInside(self, mousePoint): 3'
  prefs: []
  type: TYPE_NORMAL
- en: clicked = self.rect.collidepoint(mousePoint)
  prefs: []
  type: TYPE_NORMAL
- en: return clicked
  prefs: []
  type: TYPE_NORMAL
- en: 'def getArea(self): 4'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = self.widthAndHeight * self.widthAndHeight
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self): 5'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect(self.window, self.color,
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y, self.widthAndHeight, self.widthAndHeight))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-7: The Square class that inherits from the Shape class*'
  prefs: []
  type: TYPE_NORMAL
- en: The Square class starts by inheriting from the Shape class 1\. The
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method calls the __init__() method of its base class (or super-
  prefs: []
  type: TYPE_NORMAL
- en: class) 2, identifying this shape as a square and randomly choosing its size.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have three methods whose implementation is specific
  prefs: []
  type: TYPE_NORMAL
- en: to a square. The clickedInside() method only needs to make a call to
  prefs: []
  type: TYPE_NORMAL
- en: rect.collidepoint() to determine if a click happened inside its rectan-
  prefs: []
  type: TYPE_NORMAL
- en: gle 3\. The getArea() method simply multiplies the widthAndHeight by the
  prefs: []
  type: TYPE_NORMAL
- en: widthAndHeight 4\. Finally, the draw() method draws a rectangle using the
  prefs: []
  type: TYPE_NORMAL
- en: value of widthAndHeight 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10-8 shows the Circle class, which has also been modified to
  prefs: []
  type: TYPE_NORMAL
- en: inherit from the Shape class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/Circle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Circle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from Shape import *
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **229**
  prefs: []
  type: TYPE_NORMAL
- en: 'class Circle(Shape):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__(window, 'Circle', maxWidth, maxHeight)
  prefs: []
  type: TYPE_NORMAL
- en: self.radius = random.randrange(10, 50)
  prefs: []
  type: TYPE_NORMAL
- en: self.centerX = self.x + self.radius
  prefs: []
  type: TYPE_NORMAL
- en: self.centerY = self.y + self.radius
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y, self.radius * 2, self.radius * 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: theDistance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
  prefs: []
  type: TYPE_NORMAL
- en: ((mousePoint[1] - self.centerY) ** 2))
  prefs: []
  type: TYPE_NORMAL
- en: 'if theDistance <= self.radius:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = math.pi * (self.radius ** 2)
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle(self.window, self.color, (self.centerX, self.centerY),
  prefs: []
  type: TYPE_NORMAL
- en: self.radius, 0)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-8: The Circle class that inherits from the Shape class*'
  prefs: []
  type: TYPE_NORMAL
- en: The Circle class also contains the clickedInside(), getArea(), and draw()
  prefs: []
  type: TYPE_NORMAL
- en: methods, whose implementation is specific to a circle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Listing 10-9 shows the code of the Triangle class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/Triangle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Triangle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from Shape import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class Triangle(Shape):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__(window, 'Triangle', maxWidth, maxHeight)
  prefs: []
  type: TYPE_NORMAL
- en: self.width = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.height = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.triangleSlope = -1 * (self.height / self.width)
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
  prefs: []
  type: TYPE_NORMAL
- en: 'def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: inRect = self.rect.collidepoint(mousePoint)
  prefs: []
  type: TYPE_NORMAL
- en: 'if not inRect:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: Do some math to see if the point is inside the triangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: xOffset = mousePoint[0] - self.x
  prefs: []
  type: TYPE_NORMAL
- en: '**230** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: yOffset = mousePoint[1] – self.y
  prefs: []
  type: TYPE_NORMAL
- en: 'if xOffset == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'pointSlopeFromYIntercept = (yOffset – self.height) / xOffset # rise over run'
  prefs: []
  type: TYPE_NORMAL
- en: 'if pointSlopeFromYIntercept < 1:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = .5 * self.width * self.height
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon(self.window, self.color, (
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y + self.height),
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y),
  prefs: []
  type: TYPE_NORMAL
- en: (self.x + self.width, self.y)))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-9: The Triangle class that inherits from the Shape class*'
  prefs: []
  type: TYPE_NORMAL
- en: The main code we used for testing i[n Chapter 9 d](index_split_003.html#p212)oesn’t
    have to change at all. As a client of these new classes, it instantiates Square,
    Circle, and Triangle objects without having to worry about the implementation
    of those classes. It
  prefs: []
  type: TYPE_NORMAL
- en: doesn’t need to know that each is subclassed from a common Shape class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract Classes and Methods**'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, our Shape base class has a potential bug. At the moment, a
  prefs: []
  type: TYPE_NORMAL
- en: client could instantiate a generic Shape object, which is too generic to have
  prefs: []
  type: TYPE_NORMAL
- en: its own getArea() method. Further, all classes that inherit from the Shape
  prefs: []
  type: TYPE_NORMAL
- en: class (like Square, Circle, and Triangle) *must* implement clickedInside(),
  prefs: []
  type: TYPE_NORMAL
- en: getArea(), and draw(). To solve both of these problems, I’ll introduce the
  prefs: []
  type: TYPE_NORMAL
- en: concepts of an *abstract class* and an *abstract method*.
  prefs: []
  type: TYPE_NORMAL
- en: '**abstract class**'
  prefs: []
  type: TYPE_NORMAL
- en: A class that is *not* intended to be instantiated directly, but only to be used
    as a base class by one or more subclasses . (In some other languages, an abstract
    class is
  prefs: []
  type: TYPE_NORMAL
- en: referred to as a *virtual class* .)
  prefs: []
  type: TYPE_NORMAL
- en: '**abstract method** A method that *must* be overridden in every subclass .'
  prefs: []
  type: TYPE_NORMAL
- en: Often, a base class cannot correctly implement an abstract method
  prefs: []
  type: TYPE_NORMAL
- en: because it cannot know the detailed data it should operate on, or it may not
  prefs: []
  type: TYPE_NORMAL
- en: be possible to implement a general algorithm. Instead, all subclasses need
  prefs: []
  type: TYPE_NORMAL
- en: to implement their own version of the abstract method.
  prefs: []
  type: TYPE_NORMAL
- en: In our shapes example, we want the Shape class to be an abstract class
  prefs: []
  type: TYPE_NORMAL
- en: so no client code can instantiate a Shape object. Further, our Shape class
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **231**
  prefs: []
  type: TYPE_NORMAL
- en: should indicate that all its subclasses need to implement the clickedInside(),
    getArea(), and draw() methods.
  prefs: []
  type: TYPE_NORMAL
- en: Python does not have a keyword to designate a class or method as
  prefs: []
  type: TYPE_NORMAL
- en: abstract. However, the Python Standard Library contains the abc mod-
  prefs: []
  type: TYPE_NORMAL
- en: ule, short for *abstract base class*, which is designed to help developers build
    abstract base classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at what we need to do to build an abstract class with
  prefs: []
  type: TYPE_NORMAL
- en: abstract methods. To begin, we need to import two things from the abc
  prefs: []
  type: TYPE_NORMAL
- en: 'module:'
  prefs: []
  type: TYPE_NORMAL
- en: from abc import ABC, abstractmethod
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to indicate that the class we want to act as an abstract
  prefs: []
  type: TYPE_NORMAL
- en: base class should inherit from the ABC class, which we do by putting ABC
  prefs: []
  type: TYPE_NORMAL
- en: 'inside parentheses after the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class *<classWeWantToDesignateAsAbstract>* (ABC):'
  prefs: []
  type: TYPE_NORMAL
- en: We then must use the special decorator @abstractmethod before any meth-
  prefs: []
  type: TYPE_NORMAL
- en: 'ods that must be overwritten by all subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  prefs: []
  type: TYPE_NORMAL
- en: 'def *<someMethodThatMustBeOverwritten>* (self, ...):'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10-10 shows how we can mark our Shape class as an abstract base
  prefs: []
  type: TYPE_NORMAL
- en: class and indicate its abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/Shape.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Shape class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: To be used as a base class for other classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: from abc import ABC, abstractmethod
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  prefs: []
  type: TYPE_NORMAL
- en: '1 class Shape(ABC): # identifies this as an abstract base class'
  prefs: []
  type: TYPE_NORMAL
- en: '2 def __init__(self, window, shapeType, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = shapeType
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  prefs: []
  type: TYPE_NORMAL
- en: '3 def getType(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  prefs: []
  type: TYPE_NORMAL
- en: '**232** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: 4 @abstractmethod
  prefs: []
  type: TYPE_NORMAL
- en: 'def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 5 @abstractmethod
  prefs: []
  type: TYPE_NORMAL
- en: 'def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 6 @abstractmethod
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-10: The Shape base class that inherits from ABC with abstract methods*
    The Shape class inherits from the ABC class 1, telling Python to prevent'
  prefs: []
  type: TYPE_NORMAL
- en: client code from instantiating a Shape object directly. Any attempt to do so
  prefs: []
  type: TYPE_NORMAL
- en: 'results in the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: Can''t instantiate abstract class Shape with abstract methods'
  prefs: []
  type: TYPE_NORMAL
- en: clickedInside, draw, getArea
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() 2 and getType() 3 methods contain code that will be
  prefs: []
  type: TYPE_NORMAL
- en: shared by all subclasses of Shape.
  prefs: []
  type: TYPE_NORMAL
- en: The clickedInside() 4, getArea() 5, and draw() 6 methods are all pre-
  prefs: []
  type: TYPE_NORMAL
- en: ceded by the @abstractmethod decorator. This decorator indicates that these
  prefs: []
  type: TYPE_NORMAL
- en: methods *must* be overwritten by all subclasses of Shape. Since these methods
    in this abstract class will never run, the implementation here consists only
  prefs: []
  type: TYPE_NORMAL
- en: of raise NotImplementedError to further emphasize that the method doesn’t
  prefs: []
  type: TYPE_NORMAL
- en: do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extend the shape demonstration program to add a new Rectangle
  prefs: []
  type: TYPE_NORMAL
- en: class, as shown in Listing 10-11\. The Rectangle class inherits from the
  prefs: []
  type: TYPE_NORMAL
- en: abstract Shape class and therefore must implement the clickedInside(),
  prefs: []
  type: TYPE_NORMAL
- en: getArea(), and draw() methods. I’ll make an intentional error in this subclass
  prefs: []
  type: TYPE_NORMAL
- en: to show what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/Rectangle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from Shape import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class Rectangle(Shape):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__(window, 'Rectangle', maxWidth, maxHeight)
  prefs: []
  type: TYPE_NORMAL
- en: self.width = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.height = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
  prefs: []
  type: TYPE_NORMAL
- en: 'def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **233**
  prefs: []
  type: TYPE_NORMAL
- en: clicked = self.rect.collidepoint(mousePoint)
  prefs: []
  type: TYPE_NORMAL
- en: return clicked
  prefs: []
  type: TYPE_NORMAL
- en: 'def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = self.width * self.height
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-11: The Rectangle class that implements clickedInside() and getArea(),
    but not draw()* As a demonstration, this class mistakenly does not contain a draw()'
  prefs: []
  type: TYPE_NORMAL
- en: method. Listing 10-12 shows a modified version of the main code that
  prefs: []
  type: TYPE_NORMAL
- en: includes the creation of Rectangle objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InheritedShapes/Main_ShapesWithRectangle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: shapesList = []
  prefs: []
  type: TYPE_NORMAL
- en: shapeClassesTuple = ('Square', 'Circle', 'Triangle', 'Rectangle')
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, N_SHAPES):'
  prefs: []
  type: TYPE_NORMAL
- en: randomlyChosenClass = random.choice(shapeClassesTuple)
  prefs: []
  type: TYPE_NORMAL
- en: oShape = randomlyChosenClass(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: shapesList.append(oShape)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-12: The main code that randomly creates Squares, Circles, Triangles,
    and* *Rectangles*'
  prefs: []
  type: TYPE_NORMAL
- en: When this code attempts to create a Rectangle object, Python generates
  prefs: []
  type: TYPE_NORMAL
- en: 'this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: Can''t instantiate abstract class Rectangle with abstract method'
  prefs: []
  type: TYPE_NORMAL
- en: draw
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that we cannot instantiate a Rectangle object because we did
  prefs: []
  type: TYPE_NORMAL
- en: not write a draw() method in our Rectangle class. Adding a draw() method to
  prefs: []
  type: TYPE_NORMAL
- en: the Rectangle class (with appropriate code to draw the rectangle) fixes the
  prefs: []
  type: TYPE_NORMAL
- en: error.
  prefs: []
  type: TYPE_NORMAL
- en: '**How pygwidgets Uses Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets module uses inheritance to share common code. For exam-
  prefs: []
  type: TYPE_NORMAL
- en: ple, consider the two button classes we discussed in [Chapter 7:](index_split_003.html#p172)
    TextButton and CustomButton. The TextButton class requires a string to be used
    as a label
  prefs: []
  type: TYPE_NORMAL
- en: on the button, while the CustomButton class requires you to supply your own
  prefs: []
  type: TYPE_NORMAL
- en: art. The way that you create an instance of each of these classes is dif-
  prefs: []
  type: TYPE_NORMAL
- en: ferent—you need to specify a different set of arguments. However, once
  prefs: []
  type: TYPE_NORMAL
- en: created, all the remaining methods of both objects are exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: That’s because the two classes inherit from a common base class, named
  prefs: []
  type: TYPE_NORMAL
- en: PygWidgetsButton (Figure 10-7).
  prefs: []
  type: TYPE_NORMAL
- en: PygWidgetsButton is an abstract class. Client code is not supposed to
  prefs: []
  type: TYPE_NORMAL
- en: create an instance of it, and attempting to do so will generate an error
  prefs: []
  type: TYPE_NORMAL
- en: message.
  prefs: []
  type: TYPE_NORMAL
- en: '**234** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 29](index-264_1.png)'
  prefs: []
  type: TYPE_IMG
- en: (Abstract base class)
  prefs: []
  type: TYPE_NORMAL
- en: PygWidgetsButton
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: TextButton
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-7: The pygwidgets TextButton and CustomButton*'
  prefs: []
  type: TYPE_NORMAL
- en: '*classes both inherit from PygWidgetsButton.*'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, PygWidgetsButton is subclassed by the TextButton and CustomButton
  prefs: []
  type: TYPE_NORMAL
- en: classes. Those classes each provide the single method, __init__(), which
  prefs: []
  type: TYPE_NORMAL
- en: will do whatever is needed to initialize their type of button. Each will then
  prefs: []
  type: TYPE_NORMAL
- en: pass on identical arguments to the __init__() method of the base class,
  prefs: []
  type: TYPE_NORMAL
- en: PygWidgetsButton.
  prefs: []
  type: TYPE_NORMAL
- en: The TextButton class is used to build a text-based button with minimal
  prefs: []
  type: TYPE_NORMAL
- en: art. This is helpful when trying to get programs up and running quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface for creating a TextButton object:'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, window, loc, text, width=None, height=40,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=PYGWIDGETS_BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: upColor= PYGWIDGETS_NORMAL_GRAY,
  prefs: []
  type: TYPE_NORMAL
- en: overColor= PYGWIDGETS_OVER_GRAY,
  prefs: []
  type: TYPE_NORMAL
- en: downColor=PYGWIDGETS_DOWN_GRAY,
  prefs: []
  type: TYPE_NORMAL
- en: fontName=None, fontSize=20, soundOnClick=None,
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=False, callBack=None, nickname=None)
  prefs: []
  type: TYPE_NORMAL
- en: While many of the parameters default to reasonable values, the caller
  prefs: []
  type: TYPE_NORMAL
- en: must provide a value for text, which will appear on the button. The __init__()
  prefs: []
  type: TYPE_NORMAL
- en: method itself creates “surfaces” (images) for the button that are used in dis-
  prefs: []
  type: TYPE_NORMAL
- en: playing a standard button. The code to create a typical TextButton object looks
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')
  prefs: []
  type: TYPE_NORMAL
- en: When drawn, the user sees a button that looks like Figure 10-8\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-8: An example of a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*typical TextButton*'
  prefs: []
  type: TYPE_NORMAL
- en: The CustomButton class is used to build a button using artwork the client
  prefs: []
  type: TYPE_NORMAL
- en: 'supplies. Here is the interface for creating a CustomButton:'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, window, loc, up, down=None, over=None,
  prefs: []
  type: TYPE_NORMAL
- en: disabled=None, soundOnClick=None,
  prefs: []
  type: TYPE_NORMAL
- en: 'nickname=None, enterToActivate=False):'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **235**
  prefs: []
  type: TYPE_NORMAL
- en: The key difference is that this version of the __init__() method requires the
    caller to supply a value for the up parameter (remember, a button has
  prefs: []
  type: TYPE_NORMAL
- en: 'four images: up, down, disabled, and over). You can optionally also sup-'
  prefs: []
  type: TYPE_NORMAL
- en: ply down, over, and disabled images. For any image that is not supplied,
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton makes a copy of the up image of the button and uses that.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the __init__() methods for *both* the TextButton and
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton classes is a call to the __init__() method of the common base
  prefs: []
  type: TYPE_NORMAL
- en: class, PygWidgetsButton. Both calls pass in four images for the button, along
  prefs: []
  type: TYPE_NORMAL
- en: 'with other arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__(window, loc, surfaceUp, surfaceOver,
  prefs: []
  type: TYPE_NORMAL
- en: surfaceDown, surfaceDisabled, buttonRect,
  prefs: []
  type: TYPE_NORMAL
- en: soundOnClick, nickname, enterToActivate, callBack)
  prefs: []
  type: TYPE_NORMAL
- en: From the client’s point of view, you see two completely different classes
  prefs: []
  type: TYPE_NORMAL
- en: with many methods (most of which are identical). But from the implement-
  prefs: []
  type: TYPE_NORMAL
- en: er’s point of view, you can now see how inheritance allowed us to override
  prefs: []
  type: TYPE_NORMAL
- en: the single __init__() method in the base class to provide client program-
  prefs: []
  type: TYPE_NORMAL
- en: mers with two similar, but very useful, ways of creating buttons. The two
  prefs: []
  type: TYPE_NORMAL
- en: classes share everything other than the __init__() method. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: the way that the buttons function, and the method calls that are available
  prefs: []
  type: TYPE_NORMAL
- en: ( handleEvent(), draw(), disable(), enable(), and so on), must be identical.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of benefits to this kind of inheritance. First, it pro-
  prefs: []
  type: TYPE_NORMAL
- en: 'vides consistency for both the client code and the end user: TextButton and'
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton objects work the same way. It also makes bugs easier to fix—
  prefs: []
  type: TYPE_NORMAL
- en: fixing a bug in a base class means you have then fixed the bug in all sub-
  prefs: []
  type: TYPE_NORMAL
- en: classes that inherit from it. Finally, if you add functionality in the base
    class,
  prefs: []
  type: TYPE_NORMAL
- en: it is available immediately in all classes that inherit from the base class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Hierarchy**'
  prefs: []
  type: TYPE_NORMAL
- en: Any class can be used as a base class, even a subclass that already inherits
  prefs: []
  type: TYPE_NORMAL
- en: from another base class. This kind of relationship, known as a *class hierarchy*,
    is depicted in Figure 10-9\.
  prefs: []
  type: TYPE_NORMAL
- en: Class A
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: Class B
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: Class C
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-9: A class hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: '**236** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, class C inherits from class B, which inherits from class A.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, class C is a subclass and class B is a base class, but class B is
    also a subclass of class A. So, class B serves in both roles. In cases like this,
    class C
  prefs: []
  type: TYPE_NORMAL
- en: inherits not only all the methods and instance variables in class B, but also
  prefs: []
  type: TYPE_NORMAL
- en: all the methods and instance variables in class A. This type of hierarchy can
  prefs: []
  type: TYPE_NORMAL
- en: be very useful when building more and more specific classes. Class A can be
  prefs: []
  type: TYPE_NORMAL
- en: very general, class B more detailed, and class C even more specific.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10-10 provides a different way to think about the relationships in
  prefs: []
  type: TYPE_NORMAL
- en: a class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Class A
  prefs: []
  type: TYPE_NORMAL
- en: Class B
  prefs: []
  type: TYPE_NORMAL
- en: Class C
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-10: A different way of*'
  prefs: []
  type: TYPE_NORMAL
- en: '*portraying a class hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the client sees only class C, but this class is made up of all the
  prefs: []
  type: TYPE_NORMAL
- en: methods and instance variables defined collectively in classes C, B, and A.
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets package uses a class hierarchy for all widgets. The first
  prefs: []
  type: TYPE_NORMAL
- en: class in pygwidgets is the abstract class PygWidget, which supplies basic func-
  prefs: []
  type: TYPE_NORMAL
- en: tionality to all widgets in the package. Its code consists of methods that
  prefs: []
  type: TYPE_NORMAL
- en: allow for showing and hiding, enabling and disabling, getting and setting
  prefs: []
  type: TYPE_NORMAL
- en: the location, and getting the nickname (internal name) of any widget.
  prefs: []
  type: TYPE_NORMAL
- en: There are other classes in pygwidgets that are used as abstract classes,
  prefs: []
  type: TYPE_NORMAL
- en: including the aforementioned PygWidgetsButton, which is the base class of
  prefs: []
  type: TYPE_NORMAL
- en: both TextButton and CustomButton. Figure 10-11 should help make this rela-
  prefs: []
  type: TYPE_NORMAL
- en: tionship clear.
  prefs: []
  type: TYPE_NORMAL
- en: PygWidget
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: PygWidgetsButton
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from
  prefs: []
  type: TYPE_NORMAL
- en: TextButton
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-11: Class hierarchy in pygwidgets*'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **237**
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the PygWidgetsButton class is both a subclass of PygWidget and
    a base class for TextButton and CustomButton.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Difficulty of Programming with Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: When developing using inheritance, it can be difficult to understand what
  prefs: []
  type: TYPE_NORMAL
- en: 'to put where. You’re constantly asking yourself questions like: Should this'
  prefs: []
  type: TYPE_NORMAL
- en: instance variable be in the base class? Is there enough common code in sub-
  prefs: []
  type: TYPE_NORMAL
- en: classes to create a method in the base class? What are appropriate param-
  prefs: []
  type: TYPE_NORMAL
- en: eters for a method in a subclass? What are appropriate parameters and
  prefs: []
  type: TYPE_NORMAL
- en: defaults to be used in a base class that expects to be overridden or called
  prefs: []
  type: TYPE_NORMAL
- en: from a subclass?
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to understand the interactions among all the variables and
  prefs: []
  type: TYPE_NORMAL
- en: methods in a hierarchy of classes can be an extremely difficult, tricky, and
  prefs: []
  type: TYPE_NORMAL
- en: frustrating task. This is especially true when reading the code of a class
  prefs: []
  type: TYPE_NORMAL
- en: hierarchy developed by another programmer. To fully understand what’s
  prefs: []
  type: TYPE_NORMAL
- en: going on, you often have to become familiar with the code in the base
  prefs: []
  type: TYPE_NORMAL
- en: classes all the way up the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a hierarchy in which class D is a subclass of C,
  prefs: []
  type: TYPE_NORMAL
- en: which is a subclass of B, which is a subclass of the base class A. In class
    D, you
  prefs: []
  type: TYPE_NORMAL
- en: may encounter code that branches based on the value of an instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: able, but that variable might never be set in the code of class D. In cases
    like
  prefs: []
  type: TYPE_NORMAL
- en: this, you must look for the instance variable in the code of class C. If it
    is not
  prefs: []
  type: TYPE_NORMAL
- en: found there, then you must look in the code of class B, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a class hierarchy, perhaps the best way to avoid this
  prefs: []
  type: TYPE_NORMAL
- en: problem is to only call methods and use instance variables inherited from
  prefs: []
  type: TYPE_NORMAL
- en: one layer up in the hierarchy. In our example, code in class D should only
  prefs: []
  type: TYPE_NORMAL
- en: make calls to methods in class C, while class C should only make calls to
  prefs: []
  type: TYPE_NORMAL
- en: methods in class B, and so on. This is a simplistic version of the *Law of*
  prefs: []
  type: TYPE_NORMAL
- en: '*Demeter*. Stated simply, you (meaning objects) should only talk to your'
  prefs: []
  type: TYPE_NORMAL
- en: immediate friends (nearby objects) and never talk to strangers (distant
  prefs: []
  type: TYPE_NORMAL
- en: objects). A detailed discussion is beyond the scope of this book, but there
  prefs: []
  type: TYPE_NORMAL
- en: are many references available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach, which we first talked about i[n Chapter 4, i](index_split_001.html#p86)s
    to take advantage of *composition*, where an object instantiates one or more other
  prefs: []
  type: TYPE_NORMAL
- en: objects. The key difference is that inheritance is used to model an “is a”
  prefs: []
  type: TYPE_NORMAL
- en: relationship, whereas composition uses a “has a” relationship. For example,
  prefs: []
  type: TYPE_NORMAL
- en: if we wanted to have a spinbox widget (an editable text number field with
  prefs: []
  type: TYPE_NORMAL
- en: an up and a down arrow), we could build a SpinBox class that instantiates
  prefs: []
  type: TYPE_NORMAL
- en: a DisplayNumber object and two CustomButton objects for the arrows. Each of
  prefs: []
  type: TYPE_NORMAL
- en: these objects already knows how to handle its user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**238** Chapter 10'
  prefs: []
  type: TYPE_NORMAL
- en: '**MULTIPLE INHERITANCE**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how a class can inherit from another class . In fact, Python (like
  prefs: []
  type: TYPE_NORMAL
- en: some other programming languages) al ows a class to inherit from more than
  prefs: []
  type: TYPE_NORMAL
- en: 'just one class . This is known as *multiple inheritance* . The Python syntax
    is for inheriting from more than one class is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class *SomeClass*( *<BaseClass1>* , *<BaseClass2>* , ...): However, it’s important
    to be aware that multiple inheritance can potential y introduce conflicts when
    the base classes you inherit from contain iden-'
  prefs: []
  type: TYPE_NORMAL
- en: tical y named methods and/or instance variables . Python does have rules
  prefs: []
  type: TYPE_NORMAL
- en: (known as the *method resolution order*, or *MRO*) to resolve these potential
    problems . I consider this an advanced topic and will not cover it here, but if
  prefs: []
  type: TYPE_NORMAL
- en: you want to look into it, a detailed discussion can be found a[t *ht ps://www*](https://www.python.org/download/releases/2.3/mro)
  prefs: []
  type: TYPE_NORMAL
- en: '[*.python.org/download/releases/2.3/mro.*](https://www.python.org/download/releases/2.3/mro)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a very ambitious chapter on the topic of inheritance: the art of'
  prefs: []
  type: TYPE_NORMAL
- en: “programming by difference.” The basic idea of inheritance is to build a
  prefs: []
  type: TYPE_NORMAL
- en: class (a subclass) that incorporates all the methods and instance variables
  prefs: []
  type: TYPE_NORMAL
- en: of another class (a base class), thereby allowing you to reuse existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Your new subclass can choose to use or override the methods of the base
  prefs: []
  type: TYPE_NORMAL
- en: class, as well as define its own methods. A method in a subclass can find the
  prefs: []
  type: TYPE_NORMAL
- en: base class by using a call to super().
  prefs: []
  type: TYPE_NORMAL
- en: We built two classes, InputNumber and DisplayMoney that provide highly
  prefs: []
  type: TYPE_NORMAL
- en: reusable functionality. These classes are implemented as subclasses that use
  prefs: []
  type: TYPE_NORMAL
- en: classes in the pygwidgets package as base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Any client code that uses your subclass will see an interface that incor-
  prefs: []
  type: TYPE_NORMAL
- en: porates methods defined in both the subclass and the base class. Any num-
  prefs: []
  type: TYPE_NORMAL
- en: ber of subclasses can be built using the same base class. An abstract class
  prefs: []
  type: TYPE_NORMAL
- en: is one that is not intended to be instantiated by client code, but rather is
  prefs: []
  type: TYPE_NORMAL
- en: intended only to be inherited from by subclasses. An abstract method in a
  prefs: []
  type: TYPE_NORMAL
- en: base class is one that *must* be overridden in each subclass.
  prefs: []
  type: TYPE_NORMAL
- en: We worked through a number of examples to demonstrate inheritance
  prefs: []
  type: TYPE_NORMAL
- en: in the pygwidgets package, including how the TextButton and CustomButton
  prefs: []
  type: TYPE_NORMAL
- en: classes both inherit from a common base class, PygWidgetsButton.
  prefs: []
  type: TYPE_NORMAL
- en: I showed how you can build a class hierarchy, where a class inherits
  prefs: []
  type: TYPE_NORMAL
- en: from another class, which in turn inherits from a third class, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance can be complex—reading someone else’s code can be
  prefs: []
  type: TYPE_NORMAL
- en: confusing—but as we’ve seen, inheritance can be extremely powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance **239**
  prefs: []
  type: TYPE_NORMAL
- en: '**11**'
  prefs: []
  type: TYPE_NORMAL
- en: '**M A N A G I N G M E M O R Y**'
  prefs: []
  type: TYPE_NORMAL
- en: '**U S E D B Y O B J E C T S**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain a few important
  prefs: []
  type: TYPE_NORMAL
