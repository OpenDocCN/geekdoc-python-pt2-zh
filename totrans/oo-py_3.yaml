- en: '***The Main Program Creating Shapes***'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '***主程序创建形状***'
- en: Listing 9-5 shows the source of the main program, which creates a list of
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-5 显示了主程序的源代码，该程序创建了一个形状列表
- en: randomly chosen shape objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择的形状对象。
- en: '**File: Shapes/Main_ShapesExample.py**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Shapes/Main_ShapesExample.py**'
- en: import pygame
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: import sys
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: from pygame.locals import *
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: from Square import *
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: from Square import *
- en: from Circle import *
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: from Circle import *
- en: from Triangle import *
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: from Triangle import *
- en: import pygwidgets
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: Set up the constants
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置常量
- en: WHITE = (255, 255, 255)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: WINDOW_WIDTH = 640
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: N_SHAPES = 10
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: N_SHAPES = 10
- en: Set up the window
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置窗口
- en: pygame.init()
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: '**190** Chapter 9'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**190** 第9章'
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock
    = pygame.time.Clock()
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock
    = pygame.time.Clock()
- en: shapesList = []
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: shapesList = []
- en: shapeClassesTuple = (Square, Circle, Triangle)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: shapeClassesTuple = (Square, Circle, Triangle)
- en: 'for i in range(0, N_SHAPES): 1'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, N_SHAPES): 1'
- en: randomlyChosenClass = random.choice(shapeClassesTuple)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: randomlyChosenClass = random.choice(shapeClassesTuple)
- en: oShape = randomlyChosenClass (window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: oShape = randomlyChosenClass (window, WINDOW_WIDTH, WINDOW_HEIGHT)
- en: shapesList.append(oShape)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: shapesList.append(oShape)
- en: oStatusLine = pygwidgets.DisplayText(window, (4,4),
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: oStatusLine = pygwidgets.DisplayText(window, (4,4),
- en: '''Click on shapes'', fontSize=28)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '''点击形状''，字体大小=28)'
- en: Main loop
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主循环
- en: 'while True:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == QUIT:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == QUIT:'
- en: pygame.quit()
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if event.type == MOUSEBUTTONDOWN: 2'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == MOUSEBUTTONDOWN: 2'
- en: Reverse order to check last drawn shape first
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以相反的顺序检查最后绘制的形状
- en: 'for oShape in reversed(shapesList): 3'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'for oShape in reversed(shapesList): 3'
- en: 'if oShape.clickedInside(event.pos): 4'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'if oShape.clickedInside(event.pos): 4'
- en: area = oShape.getArea() 5
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: area = oShape.getArea() 5
- en: area = str(area)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: area = str(area)
- en: theType = oShape.getType()
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: theType = oShape.getType()
- en: newText = 'Clicked on a ' + theType + ' whose area is' + area)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: newText = '点击了一个 ' + theType + '，其面积为' + area)
- en: oStatusLine.setValue(newText)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: oStatusLine.setValue(newText)
- en: 'break # only deal with topmost shape'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'break # 只处理最上层的形状'
- en: Tell each shape to draw itself
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉每个形状绘制自己
- en: window.fill(WHITE)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(WHITE)
- en: 'for oShape in shapesList:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'for oShape in shapesList:'
- en: oShape.draw()
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: oShape.draw()
- en: oStatusLine.draw()
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: oStatusLine.draw()
- en: pygame.display.update()
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 9-5: The main program that creates random shapes from three classes*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-5：从三个类中创建随机形状的主程序*'
- en: As we saw in [Chapter 4, w](index_split_001.html#p86)henever we have a large
    number of objects to manage, the typical approach is to build a list of objects.
    So, before the
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 [第4章，w](index_split_001.html#p86) 中看到的，当我们需要管理大量对象时，通常的做法是构建一个对象列表。所以，在
- en: main loop starts, the program first builds a list of shapes 1 by randomly
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环开始时，程序首先通过随机
- en: choosing among a circle, a square, and a triangle; creating an object of that
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆形、正方形和三角形之间选择；创建该类的对象
- en: type; and appending it to the list. Using this approach, we can then iterate
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类型；并将其添加到列表中。通过这种方法，我们可以接着进行迭代
- en: over the list and call methods of the same name in every object in the list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表并调用每个对象中同名的方法。
- en: Inside the main loop, the program checks for the mouse down event 2
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，程序检查鼠标按下事件 2
- en: that happens when the user clicks. Whenever the event is detected, the code
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击时发生的事情。每当检测到该事件时，代码
- en: iterates through the shapesList 3 and calls the clickedInside() 4 method
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历 shapesList 3 并调用 clickedInside() 4 方法
- en: for each shape. Because of polymorphism, it doesn’t matter which class the
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个形状进行处理。由于多态性，形状的类无关紧要
- en: object was instantiated from. Again, the key is that the implementation of
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是从哪个类实例化的。再次强调，关键是每个类的实现
- en: the clickedInside() method can be different for different classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: clickedInside() 方法对于不同的类可以是不同的。
- en: Polymorphism **191**
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性 **191**
- en: When any clickedInside() method returns True 5, we call the getArea() then getType()
    methods of that object, without worrying about which type of
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何 clickedInside() 方法返回 True 5 时，我们调用该对象的 getArea() 和 getType() 方法，而不需要关心对象属于哪种类型
- en: object was clicked on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 被点击的对象。
- en: Here is the output of a typical run, after clicking on a few of the differ-
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是典型运行的输出，点击了几个不同的形状后
- en: 'ent shapes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 入口形状：
- en: Clicked on a Circle whose area is 5026.544
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个圆形，面积为5026.544
- en: Clicked on a Square whose area is 1600
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个正方形，面积为1600
- en: Clicked on a Triangle whose area is 1982.5
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个三角形，面积为1982.5
- en: Clicked on a Square whose area is 1600
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个正方形，面积为1600
- en: Clicked on a Square whose area is 100
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个面积为 100 的正方形
- en: Clicked on a Triangle whose area is 576.0
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个面积为 576.0 的三角形
- en: Clicked on a Circle whose area is 3019.06799
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了一个面积为 3019.06799 的圆形
- en: '***Extending a Pattern***'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***扩展模式***'
- en: Building classes with commonly named methods creates a consistent pat-
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建具有常用方法名的类会创建一个一致的模式，
- en: tern that allows us to easily extend the program. For example, to add the
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们能够轻松扩展程序的模式。例如，要添加
- en: ability for our program to include ellipses, we would build an Ellipse class
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序能够包含椭圆形，我们会构建一个 Ellipse 类
- en: that implements the getArea(), clickedInside(), draw(), and getType() meth-
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了 getArea()、clickedInside()、draw() 和 getType() 方法，
- en: ods. (The code of the clickedInside() method might be mathematically com-
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ods。（clickedInside() 方法的代码可能在数学上复杂）
- en: plicated for an ellipse!)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对椭圆形来说，复杂的代码更难理解！
- en: Once we’ve written the code of the Ellipse class, the only change we
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了 Ellipse 类的代码，唯一需要修改的地方是
- en: need to make to the setup code is to add Ellipse to the tuple of shape classes
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置代码唯一需要做的修改是将 Ellipse 添加到形状类的元组中
- en: to choose from. The code in the main loop that does the checking for clicks,
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 供选择的内容。主循环中的代码负责检查点击事件，
- en: gets the area of the shape, and so on will not need to change at all.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 获取形状的面积等等，完全不需要改变。
- en: 'This example demonstrates two important features of polymorphism:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了多态性的重要两个特性：
- en: • Polymorphism extends the concept of abstraction discussed in
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: • 多态性扩展了抽象概念的讨论
- en: '[Chapter 8 t](index_split_003.html#p192)o a collection of classes. If multiple
    classes have the same interfaces for their methods, the client programmer can
    ignore the'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 8 章 t](index_split_003.html#p192) 到一组类。如果多个类的接口方法相同，客户端程序员可以忽略'
- en: implementation of those methods in all the classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类中这些方法的实现。
- en: • Polymorphism can make client programming easier. If a client pro-
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: • 多态性可以使客户端编程更容易。如果客户端程序员
- en: grammer is already familiar with the interfaces provided by one or
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员已经熟悉了一个或多个类提供的接口
- en: more classes, then calling the methods of another polymorphic class
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的类，然后调用另一个多态类的方法
- en: should as be simple as following the pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应该像遵循模式一样简单。
- en: '**pygwidgets Exhibits Polymorphism**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**pygwidgets 展示了多态性**'
- en: All the classes in pygwidgets were designed to use polymorphism, and they
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 中的所有类都设计为使用多态性，它们
- en: all implement two common methods. The first is the handleEvent() method
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 都实现了两个共同的方法。第一个是 handleEvent() 方法
- en: we first used i[n Chapter 6, w](index_split_002.html#p150)hich takes an event
    object as a parameter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在第 6 章中使用了 i[n Chapter 6, w](index_split_002.html#p150)，它接受一个事件对象作为参数。
- en: Each class must contain its own code in this method to handle any event
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都必须在该方法中包含自己的代码来处理任何事件
- en: that pygame may generate. Each time through the main loop, client pro-
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: pygame 可能生成的事件。每次通过主循环时，客户端程序
- en: grams need to call the handleEvent() method for every instance of every
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要对每个类的每个实例调用 handleEvent() 方法
- en: object instantiated from pygwidgets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 是通过 pygwidgets 实例化的。
- en: '**192** Chapter 9'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**192** 第 9 章'
- en: 'Second is the draw() method, which draws images to the window. A typical drawing
    portion of a program that uses pygwidgets might look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 draw() 方法，它将图像绘制到窗口。使用 pygwidgets 的程序中的典型绘制部分可能如下所示：
- en: inputTextA.draw()
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: inputTextA.draw()
- en: inputTextB.draw()
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: inputTextB.draw()
- en: displayTextA.draw()
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: displayTextA.draw()
- en: displayTextB.draw()
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: displayTextB.draw()
- en: restartButton.draw()
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: restartButton.draw()
- en: checkBoxA.draw()
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: checkBoxA.draw()
- en: checkBoxB.draw()
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: checkBoxB.draw()
- en: radioCustom1.draw()
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: radioCustom1.draw()
- en: radioCustom2.draw()
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: radioCustom2.draw()
- en: radioCustom3.draw()
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: radioCustom3.draw()
- en: checkBoxC.draw()
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: checkBoxC.draw()
- en: radioDefault1.draw()
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: radioDefault1.draw()
- en: radioDefault2.draw()
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: radioDefault2.draw()
- en: radioDefault3.draw()
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: radioDefault3.draw()
- en: statusButton.draw()
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: statusButton.draw()
- en: From the client’s point of view, each line just calls the draw() method and
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，每行代码只是调用 draw() 方法并且
- en: passes in nothing. From an internal point of view, the code to implement
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不传入任何参数。从内部的角度来看，实现代码
- en: each of these methods is very different. The draw() method of the TextButton
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法各自非常不同。TextButton 对象的 draw() 方法
- en: class is completely different from that of the InputText class, for instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类与 InputText 类的完全不同，例如。
- en: Additionally, all widgets that manage a value contain a setValue() and
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有管理值的小部件都包含一个 setValue() 方法
- en: optionally a getValue() method. For example, to get the text the user enters
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地使用一个 getValue() 方法。例如，获取用户输入的文本
- en: into an InputText widget, you call the getValue() getter method. Radio button
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 InputText 小部件中获取值，可以调用 getValue() 获取方法。例如，单选按钮
- en: and checkbox widgets also have a getValue() method to get their current val-
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮和复选框控件也有一个getValue()方法，用于获取它们的当前值
- en: ues. To put new text into a DisplayText widget, you call the setValue() setter
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ues。要将新文本放入DisplayText控件中，你需要调用setValue()方法
- en: method, passing in the new text. Radio button and checkbox widgets can
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，传入新文本。单选按钮和复选框控件可以
- en: be set with a call to their setValue() method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用它们的setValue()方法来设置值。
- en: Polymorphism allows client programmers to feel comfortable with a
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 多态使得客户端程序员能舒适地使用
- en: collection of classes. When clients see a pattern, like using methods named
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 类的集合。当客户端看到一种模式，比如使用名为
- en: handleEvent() and draw(), it makes it easy for them to predict how to use a
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: handleEvent() 和 draw()，这使得它们很容易预测如何使用一个
- en: new class in the same collection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类属于同一集合。
- en: As of this writing, the pygwidgets package does not provide either a hori-
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，pygwidgets包没有提供水平或垂直Slider类控件
- en: zontal or a vertical Slider class widget to allow a user to easily select from
    a
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 水平或垂直的Slider类控件允许用户从一系列数字中轻松选择
- en: range of numbers. If I were to add these widgets, they would certainly con-
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数字范围。如果我将这些控件加起来，它们肯定会包含以下内容：一个handleEvent()方法，用于处理所有用户交互
- en: 'tain the following: a handleEvent() method, where all user interaction would'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 包含以下内容：一个handleEvent()方法，用于处理所有用户交互
- en: take place; a getValue() and a setValue() method to get and set a current
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 发生；有一个getValue()和一个setValue()方法用于获取和设置当前值
- en: value for the Slider; and a draw() method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Slider的值；以及一个draw()方法。
- en: '**Polymorphism for Operators**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符的多态性**'
- en: Python also exhibits polymorphism with operators. Consider the following
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python还通过运算符展示了多态。考虑以下示例
- en: 'example with the + operator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用 + 运算符：
- en: value1 = 4
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: value1 = 4
- en: value2 = 5
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: value2 = 5
- en: result = value1 + value2
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: result = value1 + value2
- en: print(result)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: print(result)
- en: Polymorphism **193**
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **193**
- en: 'which prints:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果为：
- en: '9'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: The + operator here clearly means “add” in a mathematic sense
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: + 运算符在这里显然表示“加法”，在数学意义上
- en: because both variables contain integer values. But now consider this second
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这两个变量都包含整数值。但是现在考虑第二个
- en: 'example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: value1 = 'Joe'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: value1 = 'Joe'
- en: value2 = 'Schmoe'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: value2 = 'Schmoe'
- en: result = value1 + value2
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: result = value1 + value2
- en: print(result)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: print(result)
- en: 'which prints:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果为：
- en: JoeSchmoe
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: JoeSchmoe
- en: The line result = value1 + value2 is exactly the same as in the first exam-
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行 result = value1 + value2 和第一个示例完全相同，
- en: ple, but it performs a completely different operation. With string values, the
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，但它执行的是完全不同的操作。对于字符串值，+运算符会执行字符串连接操作。
- en: + operator performs a string concatenation. The same operator was used,
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: + 运算符执行的是字符串连接操作。相同的运算符被使用了，
- en: but a different action was performed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但执行了不同的操作。
- en: This technique of having multiple meanings for an operator is com-
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种运算符具有多重含义的技术是通过
- en: monly known as *operator overloading*. For some classes, the ability to overload
    operators adds highly useful features and greatly improves the readability
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常被称为*运算符重载*。对于某些类，能够重载运算符增加了非常有用的特性，并大大提高了可读性
- en: of client code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码的集合。
- en: '***Magic Methods***'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '***魔法方法***'
- en: Python reserves method names with the unusual form of two underscores,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python保留了带有两个下划线的特殊方法名称，
- en: 'some name, and two underscores for a particular purpose:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名称和两个下划线是为了某个特定的目的：
- en: __ *<someName>* __()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: __ *<someName>* __()
- en: These are officially called *special methods* but are more commonly
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法官方称为*特殊方法*，但通常被称为
- en: referred to by Python programmers as *magic methods*. Many of these are
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 被Python程序员称为*魔法方法*。其中许多方法
- en: already defined, such as __init__(), which is called whenever you instanti-
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义好了，比如__init__()，它在你实例化时会被调用
- en: ate an object from a class, but all other names in this style are available
    for
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从类中创建对象，但所有其他类似的名称都是可以使用的
- en: future expansion. These are known as “magic” methods because Python
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被称为“魔法”方法，因为Python
- en: calls them behind the scenes whenever it detects an operator, a special
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Python在后台调用这些方法，每当它检测到一个运算符或特殊情况时
- en: function call, or some other special circumstance. They are not intended to
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用，或其他某些特殊情况。它们并不打算
- en: be called by client code directly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接由客户端代码调用。
- en: '**N O T E**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because the names of these magic methods are difficult to pronounce—for example,*
    *__init__() is read as “underscore underscore init underscore underscore”—Python*
    *programmers often refer to these as* dunder *methods (a shortened version of*
    double underscore *). This method would be referred to as “dunder init.”*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于这些魔法方法的名称很难发音——例如，*__init__()读作“下划线下划线 init 下划线下划线”——Python* *程序员通常将它们称为*
    dunder *方法（即双下划线的缩写）。这个方法将被称为“dunder init”。*'
- en: '**194** Chapter 9'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**第194章 第9节**'
- en: Continuing with the previous examples, we’ll look at how this works with the
    + operator. The built-in data types (integer, float, string, Boolean,
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 继续之前的示例，我们来看这个如何与 + 操作符一起工作。内建数据类型（整数、浮点数、字符串、布尔值等
- en: and so on) are actually implemented as classes in Python. We can see this
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 等等）实际上在 Python 中是作为类实现的。我们可以看到这
- en: by testing with the built-in isinstance() function, which takes an object and
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用内置的isinstance()函数来测试，该函数接受一个对象并
- en: a class and returns True if the object was instantiated from the class or False
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类，并且如果对象是从该类实例化的，返回 True，否则返回 False
- en: 'if not. These lines will both report True:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有。这些行将都报告 True：
- en: print(isinstance(123, int))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: print(isinstance(123, int))
- en: print(isinstance('some string', str))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: print(isinstance('some string', str))
- en: The classes for the built-in data types contain a set of magic methods,
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内建数据类型的类包含一组魔法方法，
- en: including ones for the basic math operators. When Python detects the +
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '包括基本数学操作符的 ones。当 Python 检测到 + '
- en: operator with integers, it calls the magic method named __add__() in the
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数的操作符时，它会调用名为__add__()的魔法方法
- en: built-in integer class, which performs integer addition. When Python sees
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内建整数类，它执行整数加法。当 Python 看到
- en: the same operator used with strings, it calls the __add__() method in the
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串使用相同的操作符时，它会调用__add__()方法。
- en: string class, which performs string concatenation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类，执行字符串连接操作。
- en: This mechanism is generalized so that when Python encounters a +
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '该机制是通用的，因此当 Python 遇到 + '
- en: operator when working with objects instantiated from your class, it will call
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理从你类实例化的对象时，它将调用操作符
- en: the __add__() method if one is present in your class. Therefore, as the class
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类中有__add__()方法，则会调用它。因此，当类
- en: developer, you can write code to invent a new meaning for this operator.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你可以编写代码，为这个操作符发明新的意义。
- en: Each operator maps to a specific magic method name. While there are
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作符映射到一个特定的魔法方法名称。虽然有
- en: many types of magic methods, let’s start with those related to the compari-
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的魔法方法，让我们从那些与比较相关的方法开始—
- en: son operators.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 子操作符。
- en: '***Comparison Operator Magic Methods***'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '***比较操作符魔法方法***'
- en: Consider our Square class from Listing 9-2\. You want client software to be
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们来自列表 9-2 的 Square 类。你希望客户端软件能够
- en: able to compare two Square objects to see if they are equal. It is up to you
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 能够比较两个 Square 对象，看它们是否相等。决定权在你
- en: to decide what “equal” means when comparing objects. For instance, you
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 来决定在比较对象时“相等”的意义。例如，你
- en: might define it as two objects being the same color and at the same location
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会定义为两个对象颜色相同且位于相同位置
- en: and with the same size. As a simple example, we’ll define two Square objects
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 并且具有相同的大小。作为一个简单的示例，我们将定义两个 Square 对象
- en: as equal if they just have the same side length. This is easily implemented
    by
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为相等，如果它们只有相同的边长。这个可以通过返回布尔值来轻松实现。
- en: comparing the self.heightAndWidth instance variables of the two objects and
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个对象的 self.heightAndWidth 实例变量和
- en: returning a Boolean. You could write your own equals() method, and client
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写自己的equals()方法，然后客户端软件可以像这样调用它：
- en: 'software could then call it like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端软件可以像这样调用它：
- en: 'if oSquare1.equals(oSquare2):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oSquare1.equals(oSquare2):'
- en: This would work fine. However, it would be more natural for client soft-
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会正常工作。然而，客户端软件使用时会更自然—
- en: 'ware to use the standard == comparison operator:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的==比较操作符：
- en: 'if oSquare1 == oSquare2:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 oSquare1 == oSquare2：
- en: Written this way, Python translates the == operator into a call to a magic
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写时，Python 将 == 操作符转换为调用魔法
- en: method of the first object. In this case, Python will attempt to call a magic
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象的方法。在这种情况下，Python 会尝试调用一个魔法
- en: method named __eq__() in the Square class. Table 9-1 shows the magic meth-
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Square 类中有一个名为__eq__()的方法。表 9-1 展示了魔法方法—
- en: ods for all the comparison operators.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所有比较操作符的ods。
- en: Polymorphism **195**
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **195**
- en: '**Table 9-1:** Comparison Operator Symbols, Meanings, and Magic Method Names
    **Symbol**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 比较操作符符号、意义和魔法方法名称 **符号**'
- en: '**Meaning**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**Magic method name**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**魔法方法名称**'
- en: ==
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ==
- en: Equal to
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 等于
- en: __eq__()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: __eq__()
- en: '!='
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '!='
- en: Not equal to
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于
- en: __ne__()
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: __ne__()
- en: <
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: Less than
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 小于
- en: __lt__()
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: __lt__()
- en: '>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Greater than
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大于
- en: __gt__()
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: __gt__()
- en: <=
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <=
- en: Less than or equal to
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 小于或等于
- en: __le__()
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: __le__()
- en: '>='
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>='
- en: Greater than or equal to
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 大于或等于
- en: __ge__()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: __ge__()
- en: To allow the == comparison operator to check for equality between two
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 == 比较操作符检查两个
- en: 'Square objects, you would write a method like this in the Square class:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Square 对象时，你需要在 Square 类中编写一个像这样的函数：
- en: 'def __eq__(self, oOtherSquare):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __eq__(self, oOtherSquare):'
- en: 'if not isinstance(oOtherSquare, Square):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是 isinstance(oOtherSquare, Square)：
- en: raise TypeError('Second object was not a Square')
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 TypeError('第二个对象不是正方形')
- en: 'if self.heightAndWidth == oOtherSquare.heightAndWidth:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 self.heightAndWidth == oOtherSquare.heightAndWidth：
- en: 'return True # match'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 True # 匹配'
- en: 'else:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'return False # not a match'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 False # 不匹配'
- en: When Python detects an == comparison where the first object is a Square,
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 检测到一个 == 比较，并且第一个对象是一个正方形时，
- en: it calls this method in the Square class. Since Python is a loosely typed lan-
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它会调用正方形类中的此方法。由于 Python 是一种松散类型的语言，
- en: guage (it doesn’t require you to define variable types), the second parame-
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 测量（它不要求你定义变量类型），第二个参数
- en: ter could be of any data type. However, in order for the comparison to work
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数可以是任何数据类型。然而，为了使比较正常工作，
- en: correctly, the second parameter must also be a Square object. We perform
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地，第二个参数必须也是一个正方形对象。我们执行
- en: a check using the isinstance() function, which works with programmer-
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 isinstance() 函数进行检查，它与程序员定义的类一样
- en: defined classes the same way it works with built-in classes. If the second
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义的类中，工作方式与内置类相同。如果第二个
- en: object is not a Square, we raise an exception.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象不是一个正方形，则会引发异常。
- en: We then compare the heightAndWidth of the current object (self) with
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将当前对象（self）的高度和宽度与
- en: the heightAndWidth of a second object (oOtherSquare). This is a case where
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对象（oOtherSquare）的高度和宽度。这是一个
- en: using direct access to the instance variables of two objects is perfectly
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问两个对象的实例变量是完全可以接受的，因为这两个对象属于同一类型，因此它们
- en: acceptable, because both objects are of the same type, and therefore they
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 是可以接受的，因为这两个对象属于同一类型，因此它们
- en: must contain the same instance variables.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 必须包含相同的实例变量。
- en: '***A Rectangle Class with Magic Methods***'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '***具有魔术方法的矩形类***'
- en: To expand, we’ll build a program that draws a number of rectangle
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展，我们将构建一个程序来绘制多个矩形
- en: shapes using a Rectangle class. The user will be able to click on any two
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩形类绘制图形。用户可以点击任意两个
- en: rectangles, and the program will report if the rectangles have the same
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形，程序将报告这两个矩形是否具有相同的
- en: area or if the area of the first one is larger or smaller than the area of the
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 面积或者第一个矩形的面积是否大于或小于第二个矩形的面积
- en: second rectangle. We’ll use the ==, <, and > operators and expect the result
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个矩形。我们将使用 ==、< 和 > 运算符并期望结果
- en: to be a Boolean True or False for each comparison. Listing 9-6 contains
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 每次比较时返回布尔值 True 或 False。列表 9-6 包含
- en: the code of the Rectangle class, which implements magic methods for these
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形类的代码，它实现了这些运算符的魔术方法
- en: operators.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符。
- en: '**196** Chapter 9'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**第196页 第9章**'
- en: '**File: MagicMethods/Rectangle/Rectangle.py**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MagicMethods/Rectangle/Rectangle.py**'
- en: Rectangle class
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形类
- en: import pygame
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygame
- en: import random
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 导入随机模块
- en: Set up the colors
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: RED = (255, 0, 0)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 红色 = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色 = (0, 255, 0)
- en: BLUE = (0, 0, 255)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色 = (0, 0, 255)
- en: 'class Rectangle():'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '类矩形（）： '
- en: 'def __init__(self, window):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 __init__(self, window):'
- en: self.window = window
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.width = random.choice((20, 30, 40))
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = random.choice((20, 30, 40))
- en: self.height = random.choice((20, 30, 40))
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = random.choice((20, 30, 40))
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(0, 400)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(0, 400)
- en: self.y = random.randrange(0, 400)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(0, 400)
- en: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
- en: self.area = self.width * self.height
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: self.area = self.width * self.height
- en: 'def clickedInside(self, mousePoint):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 clickedInside(self, mousePoint)
- en: clicked = self.rect.collidepoint(mousePoint)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: clicked = self.rect.collidepoint(mousePoint)
- en: return clicked
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 clicked
- en: Magic method called when you compare
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你比较时调用的魔术方法
- en: two Rectangle objects with the == operator
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 == 运算符比较两个矩形对象
- en: 'def __eq__ (self, oOtherRectangle): 1'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 __eq__(self, oOtherRectangle): 1'
- en: 'if not isinstance(oOtherRectangle, Rectangle):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是 isinstance(oOtherRectangle, Rectangle)：
- en: raise TypeError('Second object was not a Rectangle')
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 TypeError('第二个对象不是矩形')
- en: 'if self.area == oOtherRectangle.area:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 self.area == oOtherRectangle.area：
- en: return True
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'else:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: Magic method called when you compare
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你比较时调用的魔术方法
- en: two Rectangle objects with the < operator
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 < 运算符比较两个矩形对象
- en: 'def __lt__(self, oOtherRectangle): 2'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 __lt__(self, oOtherRectangle): 2'
- en: 'if not isinstance(oOtherRectangle, Rectangle):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是 isinstance(oOtherRectangle, Rectangle)：
- en: raise TypeError('Second object was not a Rectangle')
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 TypeError('第二个对象不是矩形')
- en: 'if self.area < oOtherRectangle.area:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 self.area < oOtherRectangle.area：
- en: return True
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'else:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: Magic method called when you compare
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你比较时调用的魔术方法
- en: two Rectangle objects with the > operator
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 > 运算符比较两个矩形对象
- en: 'def __gt__(self, oOtherRectangle): 3'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '定义__gt__(self, oOtherRectangle): 3'
- en: 'if not isinstance(oOtherRectangle, Rectangle):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果oOtherRectangle不是一个矩形（Rectangle）实例：
- en: raise TypeError('Second object was not a Rectangle')
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 引发TypeError('第二个对象不是矩形')
- en: Polymorphism **197**
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **197**
- en: 'if self.area > oOtherRectangle.area:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self.area > oOtherRectangle.area：
- en: return True
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 返回True
- en: 'else:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 返回False
- en: 'def getArea(self):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 定义getArea(self)方法：
- en: return self.area
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 返回self.area
- en: 'def draw(self):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 定义draw(self)方法：
- en: 'pygame.draw.rect(self.window, self.color, (self.x, self.y, self.width, self.height))
    *Listing 9-6: The Rectangle class*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.rect(self.window, self.color, (self.x, self.y, self.width, self.height))
    *列表 9-6：Rectangle类*
- en: The methods __eq__() 1, __lt__() 2, and __gt__() 3 allow client code
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 方法__eq__() 1，__lt__() 2，和__gt__() 3允许客户端代码
- en: to use standard comparison operators between Rectangle objects. To com-
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准比较运算符比较矩形对象。要比较—
- en: 'pare two rectangles for equality, you would write:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要比较两个矩形是否相等，您应该写：
- en: 'if oRectangle1 == oRectangle2:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '如果oRectangle1 == oRectangle2:'
- en: When this line runs, the __eq__() method of the first object is called,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当这行代码执行时，第一个对象的__eq__()方法会被调用，
- en: and the second object is passed in as the second parameter. The function
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 并且第二个对象作为第二个参数传递。该函数
- en: returns either True or False. Similarly, to compare for less than, you would
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 返回True或False。同样，要进行小于比较，您应该
- en: 'write a line like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 写一行像这样的代码：
- en: 'if oRectangle1 < oRectangle2:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '如果oRectangle1 < oRectangle2:'
- en: The __lt__() method then checks for the area of the first rectangle
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: __lt__()方法接着检查第一个矩形的面积
- en: being less than the area of the second rectangle. If client code used the >
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 比第二个矩形的面积要小。如果客户端代码使用了>
- en: operator to compare two rectangles, the __gt__() method would be called.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用>操作符比较两个矩形时，将调用__gt__()方法。
- en: '***Main Program Using Magic Methods***'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用魔法方法的主程序***'
- en: Listing 9-7 shows the code of the main program that tests the magic methods.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-7展示了测试魔法方法的主程序代码。
- en: '**File: MagicMethods/Rectangle/Main_RectangleExample.py**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MagicMethods/Rectangle/Main_RectangleExample.py**'
- en: import pygame
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 导入pygame
- en: import sys
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 导入sys
- en: from pygame.locals import *
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从pygame.locals导入所有内容
- en: from Rectangle import *
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从Rectangle导入所有内容
- en: Set up the constants
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置常量
- en: WHITE = (255, 255, 255)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: WINDOW_WIDTH = 640
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: N_RECTANGLES = 10
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: N_RECTANGLES = 10
- en: FIRST_RECTANGLE = 'first'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: FIRST_RECTANGLE = 'first'
- en: SECOND_RECTANGLE = 'second'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: SECOND_RECTANGLE = 'second'
- en: Set up the window
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置窗口
- en: pygame.init()
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: '**198** Chapter 9'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**198** 第9章'
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock
    = pygame.time.Clock()
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock
    = pygame.time.Clock()
- en: rectanglesList = []
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: rectanglesList = []
- en: 'for i in range(0, N_RECTANGLES):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于i在范围(0, N_RECTANGLES)内：
- en: oRectangle = Rectangle(window)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: oRectangle = Rectangle(window)
- en: rectanglesList.append(oRectangle)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: rectanglesList.append(oRectangle)
- en: whichRectangle = FIRST_RECTANGLE
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: whichRectangle = FIRST_RECTANGLE
- en: Main loop
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主循环
- en: 'while True:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一直循环：
- en: 'for event in pygame.event.get():'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于pygame.event.get()中的每个事件：
- en: 'if event.type == QUIT:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是QUIT：
- en: pygame.quit()
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if event.type == MOUSEBUTTONDOWN:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是MOUSEBUTTONDOWN：
- en: 'for oRectangle in rectanglesList:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历矩形列表中的每个矩形：
- en: 'if oRectangle.clickedInside(event.pos):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '如果oRectangle.clickedInside(event.pos):'
- en: print('Clicked on', whichRectangle, 'rectangle.')
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: print('点击了', whichRectangle, '矩形。')
- en: 'if whichRectangle == FIRST_RECTANGLE:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '如果whichRectangle == FIRST_RECTANGLE:'
- en: oFirstRectangle = oRectangle 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: oFirstRectangle = oRectangle 1
- en: whichRectangle = SECOND_RECTANGLE
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: whichRectangle = SECOND_RECTANGLE
- en: 'elif whichRectangle == SECOND_RECTANGLE:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '如果whichRectangle == SECOND_RECTANGLE:'
- en: oSecondRectangle2 = oRectangle 2
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: oSecondRectangle2 = oRectangle 2
- en: User has chosen 2 rectangles, let's compare
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户选择了两个矩形，我们来比较一下
- en: 'if oFirstRectangle == oSecondRectangle: 3'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '如果oFirstRectangle == oSecondRectangle: 3'
- en: print('Rectangles are the same size.')
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: print('矩形大小相同。')
- en: 'elif oFirstRectangle < oSecondRectangle: 4'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '如果oFirstRectangle < oSecondRectangle: 4'
- en: print('First rectangle is smaller than second rectangle.')
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: print('第一个矩形小于第二个矩形。')
- en: 'else: # must be larger 5'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：# 必须更大 5
- en: print('First rectangle is larger than second rectangle.')
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: print('第一个矩形大于第二个矩形。')
- en: whichRectangle = FIRST_RECTANGLE
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: whichRectangle = FIRST_RECTANGLE
- en: Clear the window and draw all rectangles
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除窗口并绘制所有矩形
- en: window.fill(WHITE)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(WHITE)
- en: 'for oRectangle in rectanglesList: 6'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历矩形列表中的每个矩形：6
- en: oRectangle.draw()
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: oRectangle.draw()
- en: pygame.display.update()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 9-7: The main program that draws and then compares Rectangle objects*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-7：绘制并比较矩形对象的主程序*'
- en: The user of the program clicks on pairs of rectangles to compare their
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的用户点击矩形对进行比较
- en: sizes. We store the selected rectangles in two variables 1 2\.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 大小。我们将选中的矩形存储在两个变量中 1 2\。
- en: We check for equality using the == operator 3, which resolves to calling
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 == 运算符检查相等性，结果调用
- en: the __eq__() method of the Rectangle class. If the rectangles are the same
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这是矩形类的 __eq__() 方法。如果矩形相同
- en: size, we print out an appropriate message. If not, we check if the first rect-
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小相同，我们打印出适当的信息。如果不相同，我们检查第一个矩形
- en: angle is smaller than the second using the < operator 4, which results in
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角度小于第二个，则使用 < 运算符 4，这将导致
- en: Polymorphism **199**
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性 **199**
- en: a call to the __lt__() method. If this comparison is also not True, we print
    the message for the first being larger than the second 5\. We didn’t need to
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 __lt__() 方法。如果这个比较结果不为真，我们打印出第一个比第二个大的信息 5\. 我们不需要
- en: use the > operator in this program; however, since other client code might
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中使用 > 运算符；然而，由于其他客户端代码可能
- en: implement size comparisons differently, we’ve included the __gt__() method
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现不同的大小比较，我们包括了 __gt__() 方法
- en: for completeness.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性
- en: Finally, we draw all the rectangles in our list 6\.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制出列表中的所有矩形 6\。
- en: Because we included the magic methods __eq__(), __lt__(), and __gt__()
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在矩形类中包含了魔术方法 __eq__()、__lt__() 和 __gt__()
- en: in the Rectangle class, we were able to use the standard comparison opera-
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩形类中，由于我们包括了这些方法，我们能够使用标准比较运算符
- en: tors in a highly intuitive and readable way.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在极其直观和易读的方式中实现向量。
- en: 'Here is the output from clicking on a number of different rectangles:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是点击多个不同矩形后的输出：
- en: Clicked on first rectangle.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了第一个矩形。
- en: Clicked on second rectangle.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了第二个矩形。
- en: Rectangles are the same size.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形大小相同。
- en: Clicked on first rectangle.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了第一个矩形。
- en: Clicked on second rectangle.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了第二个矩形。
- en: First rectangle is smaller than second rectangle.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个矩形小于第二个矩形。
- en: Clicked on first rectangle.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了第一个矩形。
- en: Clicked on second rectangle.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 点击了第二个矩形。
- en: First rectangle is larger than second rectangle.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个矩形大于第二个矩形。
- en: '***Math Operator Magic Methods***'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '***数学运算符魔术方法***'
- en: You can write additional magic methods to define what happens when cli-
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写额外的魔术方法来定义点击时会发生的事情
- en: ent code uses the other arithmetic operators between objects instantiated
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现有代码使用其他算术运算符在对象间进行操作
- en: from your class.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 来自你的类。
- en: Table 9-2 shows the methods that are called for the basic arithmetic
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2 显示了基本算术操作时调用的方法
- en: operators.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符。
- en: '**Table 9-2:** Math Operator Symbols, Meanings, and Magic Method Names'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 数学运算符符号、含义和魔术方法名称'
- en: '**Symbol**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**'
- en: '**Meaning**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**含义**'
- en: '**Magic method name**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**魔术方法名称**'
- en: +
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: Addition
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 加法
- en: __add__()
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: __add__()
- en: '-'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '-'
- en: Subtraction
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 减法
- en: __sub__()
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: __sub__()
- en: '*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: Multiplication
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法
- en: __mul__()
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: __mul__()
- en: /
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: /
- en: Division (floating-point
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 除法（浮动点数）
- en: __truediv__()
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: __truediv__()
- en: result)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 结果）
- en: //
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: Integer division
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 整数除法
- en: __floordiv__()
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: __floordiv__()
- en: '%'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '%'
- en: Modulo
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 求余
- en: __mod__()
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: __mod__()
- en: abs
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: abs
- en: Absolute value
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对值
- en: __abs__()
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: __abs__()
- en: For example, to handle the + operator, you would implement a method
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要处理 + 运算符，你可以实现一个方法
- en: 'in your class like this:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的类中像这样：
- en: 'def __add__(self, oOther):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __add__(self, oOther):'
- en: Your code here to determine what happens when code
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的代码在这里定义点击时会发生什么
- en: attempts to add two of these objects.
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试添加两个这些对象。
- en: '**200** Chapter 9'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**200** 第9章'
- en: A full list of all the magic or dunder methods can be found in the official
    documentation at [*https://docs.python.org/3/reference/datamodel.html*](https://docs.python.org/3/reference/datamodel.html).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 所有魔术或双下划线方法的完整列表可以在官方文档中找到，链接如下：[*https://docs.python.org/3/reference/datamodel.html*](https://docs.python.org/3/reference/datamodel.html)。
- en: '***Vector Example***'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '***向量示例***'
- en: In math, a *vector* is an ordered pair of x and y values that is often repre-
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*向量*是一个有序的 x 和 y 值对，通常表示为
- en: sented on a graph as a directed line segment. In this section, we’ll build
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中表示为有向线段。在这一部分，我们将构建
- en: a class that uses math operator magic methods to operate on vectors.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用数学运算符魔术方法来操作向量的类。
- en: There are a number of math operations that can be performed on vectors.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数学操作可以对向量进行。
- en: Figure 9-2 shows an example of adding two vectors.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2 显示了两个向量相加的例子。
- en: y–axis
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: y 轴
- en: '6'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: =Vector 4, 5
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: =向量 4, 5
- en: '3'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: Vector 1, 3
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 1, 3
- en: '2'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: plus
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 加号
- en: '1'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: Vector 3, 2
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 3, 2
- en: x–axis
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: x 轴
- en: –6 –5
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: –6 –5
- en: –4
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: –4
- en: –3
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: –3
- en: –2
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: –2
- en: –1
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: –1
- en: '1'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: –1
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: –1
- en: –2
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: –2
- en: –3
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: –3
- en: –4
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: –4
- en: –5
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: –5
- en: –6
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: –6
- en: '*Figure 9-2: Vector addition in Cartesian coordinates*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：笛卡尔坐标系中的向量加法*'
- en: Adding two vectors results in a new vector whose x value is the sum of
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个向量相加会得到一个新的向量，其 x 值是两者之和
- en: the x values of the two added vectors and whose y value is the sum of the y
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 两个相加向量的 x 值和其 y 值是 y 值的总和
- en: values of the two added vectors. In Figure 9-2, we add the vector (3, 2) and
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 两个相加向量的值。在图 9-2 中，我们加法了向量 (3, 2) 和
- en: the vector (1, 3) to create a vector (4, 5).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 (1, 3) 创建了一个向量 (4, 5)。
- en: Two vectors are considered equal if their x values are the same and
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个向量的 x 值相同，它们被认为是相等的，且
- en: their y values are the same. A vector’s size is computed to be the hypotenuse
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的 y 值相同。一个向量的大小通过计算直角三角形的斜边来得到
- en: of the right triangle with one side of length x and the second side of length
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 直角三角形的一个边长为 x，第二个边长为
- en: y. We can use the Pythagorean theorem to compute the length and use the
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: y。我们可以使用毕达哥拉斯定理来计算长度并使用
- en: lengths to compare two vectors’ sizes.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边长比较两个向量的大小。
- en: Polymorphism **201**
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **201**
- en: Listing 9-8 is a Vector class that illustrates the appropriate magic methods
    for doing math and comparisons between two Vector objects. (Each of
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-8 是一个 Vector 类，演示了适用于两个向量对象之间进行数学计算和比较的魔术方法。（每个
- en: these methods has additional code using a call to isinstance() to ensure that
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法还通过调用 isinstance() 来确保
- en: the second object is a Vector. These checks are included in the download-
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对象是一个向量。检查项包含在下载的文件中，
- en: able file, but I have omitted them here to save space.)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的文件中，但为了节省空间，我在这里省略了它们。)
- en: '**File: MagicMethods/Vectors/Vector.py**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MagicMethods/Vectors/Vector.py**'
- en: Vector class
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量类
- en: import math
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 math
- en: 'class Vector():'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '类 Vector():'
- en: '''''''The Vector class represents two values as a vector,'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''Vector 类表示两个值作为一个向量，'
- en: allows for many math calculations'''
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 允许进行许多数学计算'''
- en: 'def __init__(self, x, y):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, x, y):'
- en: self.x = x
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: '1 def __add__(self, oOther): # called for + operator'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __add__(self, oOther): # 调用 + 运算符'
- en: return Vector(self.x + oOther.x, self.y + oOther.y)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Vector(self.x + oOther.x, self.y + oOther.y)
- en: 'def __sub__(self, oOther): # called for - operator'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __sub__(self, oOther): # 调用 - 运算符'
- en: return Vector(self.x - oOther.x, self.y - oOther.y)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Vector(self.x - oOther.x, self.y - oOther.y)
- en: '2 def __mul__(self, oOther): # called for * operator'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def __mul__(self, oOther): # 调用 * 运算符'
- en: Special code to allow for multiplying by a vector or a scalar
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许乘法的特殊代码，用于向量或标量的乘法
- en: 'if isInstance(oOther, Vector): # multiply two vectors'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '如果是实例化(oOther, Vector): # 两个向量相乘'
- en: return Vector((self.x * oOther.x), (self.y * oOther.y))
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Vector((self.x * oOther.x), (self.y * oOther.y))
- en: 'elif isinstance(oOther, (int, float)): # multiply by a scalar'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif isinstance(oOther, (int, float)): # 乘以标量'
- en: return Vector((self.x * oOther), (self.y * oOther))
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Vector((self.x * oOther), (self.y * oOther))
- en: 'else:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: raise TypeError('Second value must be a vector or scalar')
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 TypeError('第二个值必须是向量或标量')
- en: 'def __abs__(self):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __abs__(self):'
- en: return math.sqrt((self.x ** 2) + (self.y ** 2))
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 math.sqrt((self.x ** 2) + (self.y ** 2))
- en: 'def __eq__(self, oOther): # called for == operator'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __eq__(self, oOther): # 调用 == 运算符'
- en: return (self.x == oOther.x) and (self.y == oOther.y)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 (self.x == oOther.x) 和 (self.y == oOther.y)
- en: 'def __ne__(self, oOther): # called for != operator'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __ne__(self, oOther): # 调用 != 运算符'
- en: 'return not (self == oOther) # calls __eq__ method'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 not (self == oOther) # 调用 __eq__ 方法'
- en: 'def __lt__(self, oOther): # called for < operator'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __lt__(self, oOther): # 调用 < 运算符'
- en: 'if abs(self) < abs(oOther): # calls __abs__ method'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 abs(self) < abs(oOther): # 调用 __abs__ 方法'
- en: return True
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'else:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: 'def __gt__(self, oOther): # called for > operator'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __gt__(self, oOther): # 调用 > 运算符'
- en: 'if abs(self) > abs(oOther): # calls __abs__ method'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 abs(self) > abs(oOther): # 调用 __abs__ 方法'
- en: '**202** Chapter 9'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**202** 第 9 章'
- en: return True
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'else:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: '*Listing 9-8: The Vector class that implements a number of magic methods*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8: 实现多个魔术方法的 Vector 类*'
- en: This class implements arithmetic and comparison operators as magic
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了算术和比较运算符，作为魔术方法
- en: methods. Client code would use standard symbols for math and compari-
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。客户端代码将使用标准符号进行数学和比较-
- en: son between two Vector objects. For example, the addition of vectors in
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个向量对象。例如，向量的加法
- en: 'Figure 9-2 could be handled like this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2 可以这样处理：
- en: oVector1 = Vector(3, 2)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: oVector1 = Vector(3, 2)
- en: oVector2 = Vector(1, 3)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: oVector2 = Vector(1, 3)
- en: 'oNewVector = oVector1 + oVector2 # use the + operator to add vectors'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 'oNewVector = oVector1 + oVector2 # 使用 + 运算符加法两个向量'
- en: When the third line runs, the __add__() method 1is called to add the
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当第三行运行时，__add__() 方法被调用来加法
- en: two Vector objects, resulting in the creation of a new Vector object. There
    is a
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量对象，最终创建一个新的向量对象。这里有一个
- en: special check in the __mul__() method 2 that allows the * operator to either
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊检查在 __mul__() 方法中，允许 * 运算符可以
- en: multiply two Vectors or multiply one Vector by a scalar value, depending on
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个向量相乘或将一个向量与标量相乘，具体取决于
- en: the type of the second value.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个值的类型。
- en: '**Creating a String Representation of Values in an Object**'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建对象值的字符串表示**'
- en: A standard approach to debugging is to add calls to print() to write out the
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的一种标准方法是添加print()调用，输出
- en: 'values of variables at certain points in your program:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在程序某些位置的值：
- en: print('My variable is', myVariable)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: print('我的变量是', myVariable)
- en: However, if you try to use print() to help you debug the contents of an
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试使用print()帮助你调试一个
- en: object, the results are not particularly helpful. For example, here we create
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的结果并不特别有用。例如，在这里我们创建
- en: 'a Vector object and print it:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Vector对象并打印它：
- en: oVector = Vector(3, 4)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: oVector = Vector(3, 4)
- en: print('My vector is', oVector)
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: print('我的向量是', oVector)
- en: 'This is what is printed:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是输出的内容：
- en: <Vector object at 0x10361b518>
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: <Vector对象位于0x10361b518>
- en: This tells us that we have an object instantiated from the Vector class
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们我们已经实例化了一个来自Vector类的对象
- en: and shows the memory address of that object. However, in most cases, what
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 并显示该对象的内存地址。然而，在大多数情况下，我们
- en: we really want to know are the values of the instance variables in the object
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想知道的是对象中实例变量的值
- en: at that moment. Luckily, we can use magic methods for that.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻。幸运的是，我们可以使用魔法方法来实现。
- en: There are two magic methods that can be useful in getting information
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个魔法方法在获取信息时非常有用
- en: '(as strings) from an object:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个对象中获取（作为字符串）：
- en: • The __str__() method is used to create a string representation of an
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: • __str__() 方法用于创建对象的字符串表示
- en: object that can be read easily by humans. If client code makes a call to
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的字符串表示，便于人类阅读。如果客户端代码调用
- en: the str() built-in function and passes in an object, Python will call the
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: str()内置函数并传入一个对象时，Python会调用该
- en: magic method __str__() if it is present in that class.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该类中存在魔法方法 __str__()，则使用该方法。
- en: Polymorphism **203**
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **203**
- en: • The __repr__() method is used to create an unambiguous, possibly machine-readable
    string representation of the object. If client code
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: • __repr__() 方法用于创建一个明确的、可能是机器可读的对象字符串表示。如果客户端代码
- en: makes a call to the repr() built-in function and passes in an object,
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 调用repr()内置函数并传入一个对象时，
- en: Python will attempt to call the magic method __repr__() in that class,
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Python会尝试调用该类中的魔法方法__repr__()，
- en: if present.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在的话。
- en: I’ll show the __str__() method, as it’s more generally used for simple
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示__str__()方法，因为它更常用于简单的
- en: debugging. When you call the print() function, Python calls the built-in
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 调试。当你调用print()函数时，Python会调用内置的
- en: str() function to convert each argument into a string. For any argument
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: str()函数将每个参数转换为字符串。对于任何参数
- en: that does not have a __str__() method, this function formats a string that
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有__str__()方法的对象，这个函数会格式化一个字符串
- en: contains the type of the object, the words “object at,” and the memory
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 包含对象类型、"对象位于"字样和内存地址的字符串。
- en: address, then returns the resulting string. That’s why we see the earlier out-
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 地址，然后返回结果字符串。这就是我们之前看到的输出—
- en: put containing the memory address.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 包含内存地址的字符串。
- en: Instead, you can write your own version of __str__() and have it produce
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写自己的__str__()版本，让它生成
- en: whatever string you want to help debug the code of your class. The general
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你想要的字符串来帮助调试你类的代码。一般的
- en: approach is to build a string that contains the values of any instance vari-
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是构建一个包含任何实例变量值的字符串，
- en: ables that you want to see and return that string to be printed. For example,
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望查看并将该字符串返回以供打印。例如，
- en: we can add the following method to the Vector class from Listing 9-8 to get
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向来自示例9-8中的Vector类添加以下方法来获取
- en: 'information about any Vector object:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 获取任何Vector对象的信息：
- en: 'class Vector():'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Vector():'
- en: '--- snipped all previous methods ---'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 省略所有之前的方法 ---'
- en: 'def __str__(self):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __str__(self):'
- en: return 'This vector has the value (' + str(self.x) + ', ' + str(self.y) + ')'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: return '这个向量的值是 (' + str(self.x) + ', ' + str(self.y) + ')'
- en: If you instantiate a Vector, you can then call the print() function and
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实例化一个Vector对象，之后你可以调用print()函数并
- en: 'pass in a Vector object:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 传入一个Vector对象：
- en: oVector = Vector(10, 7)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: oVector = Vector(10, 7)
- en: print(oVector)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: print(oVector)
- en: Rather than just printing the memory address of the Vector object, you
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 与其仅仅打印Vector对象的内存地址，你
- en: will get a nicely formatted report of the values of the two instance variables
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 将得到一个格式良好的报告，显示两个实例变量的值
- en: 'contained in the object:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 对象中包含的内容：
- en: This vector has the value (10, 7)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量的值是 (10, 7)
- en: The main code in Listing 9-9 creates a few Vector objects, does some
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-9 中的主代码创建了几个 Vector 对象，做了一些
- en: vector math, and prints out the results of some Vector calculations.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数学，并打印一些向量计算的结果。
- en: '**File: Vectors/Main_Vectors.py**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Vectors/Main_Vectors.py**'
- en: Vector test code
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量测试代码
- en: from Vector import *
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: from Vector import *
- en: v1 = Vector(3, 4)
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: v1 = Vector(3, 4)
- en: v2 = Vector(2, 2)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: v2 = Vector(2, 2)
- en: v3 = Vector(3, 4)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: v3 = Vector(3, 4)
- en: '**204** Chapter 9'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '**204** 第9章'
- en: These lines print Boolean or numeric values
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这些行打印布尔值或数值
- en: print(v1 == v2)
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: print(v1 == v2)
- en: print(v1 == v3)
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: print(v1 == v3)
- en: print(v1 < v2)
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: print(v1 < v2)
- en: print(v1 > v2)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: print(v1 > v2)
- en: print(abs(v1))
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: print(abs(v1))
- en: print(abs(v2))
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: print(abs(v2))
- en: print()
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: These lines print Vectors (calls the __str__() method)
  id: totrans-626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这些行打印向量（调用 __str__() 方法）
- en: print('Vector 1:', v1)
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: print('向量 1:', v1)
- en: print('Vector 2:', v2)
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: print('向量 2:', v2)
- en: print('Vector 1 + Vector 2:', v1 + v2)
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: print('向量 1 + 向量 2:', v1 + v2)
- en: print('Vector 1 - Vector 2:', v1 - v2)
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: print('向量 1 - 向量 2:', v1 - v2)
- en: print('Vector 1 times Vector 2:', v1 * v2)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: print('向量 1 乘 向量 2:', v1 * v2)
- en: print('Vector 2 times 5:', v1 * 5)
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: print('向量 2 乘以 5:', v1 * 5)
- en: '*Listing 9-9: Sample main code that creates and compares Vectors, does math,
    and prints* *Vectors*'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 9-9：示例主代码，创建并比较 Vectors，进行数学计算并打印* *Vectors*'
- en: 'This generates the following output:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: 'False'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'True'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'True'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '5.0'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '5.0'
- en: '2.8284271247461903'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '2.8284271247461903'
- en: 'Vector 1: This vector has the value (3, 4)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 1：这个向量的值是 (3, 4)
- en: 'Vector 2: This vector has the value (2, 2)'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 2：这个向量的值是 (2, 2)
- en: 'Vector 1 + Vector 2: This vector has the value (5, 6)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 1 + 向量 2：这个向量的值是 (5, 6)
- en: 'Vector 1 - Vector 2: This vector has the value (1, 2)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 1 - 向量 2：这个向量的值是 (1, 2)
- en: 'Vector 1 times Vector 2: This vector has the value (6, 8)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 1 乘 向量 2：这个向量的值是 (6, 8)
- en: 'Vector 2 times 5: This vector has the value (15, 20)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 2 乘以 5：这个向量的值是 (15, 20)
- en: The first set of calls to print() output Boolean and numeric values,
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 print() 输出布尔值和数值，
- en: which result from calling math and comparison operator magic methods.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是调用数学和比较运算符魔法方法后的结果。
- en: In the second set, we print two Vector objects, then compute and print
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二组中，我们打印两个 Vector 对象，然后计算并打印
- en: some new Vectors. Internally, the print() function first calls Python’s str()
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 一些新的 Vectors。内部，print() 函数首先调用 Python 的 str()
- en: function for each item to be printed; that results in a call to the Vector’s
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个要打印的项提供一个函数；这会调用 Vector 的
- en: __str__() magic method, which creates a formatted string with the relevant
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: __str__() 魔法方法，用于创建一个包含相关信息的格式化字符串
- en: information.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 信息。
- en: '**A Fraction Class with Magic Methods**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个带有魔法方法的分数类**'
- en: Let’s put some of these magic methods together in a more complex exam-
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些魔法方法结合起来，做一个更复杂的示例
- en: ple. Listing 9-10 shows the code of a Fraction class. Each Fraction object is
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 例如。列出 9-10 显示了一个 Fraction 类的代码。每个 Fraction 对象由
- en: made up of a numerator (top part) and a denominator (bottom part). The
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 由分子（上部分）和分母（下部分）组成。该
- en: class keeps track of a fraction by storing the separate parts in instance vari-
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 类通过在实例变量中存储分数的不同部分来跟踪分数。
- en: ables, along with the fraction’s approximate decimal value. The methods
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: ables，连同分数的近似小数值。方法
- en: Polymorphism **205**
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **205**
- en: allow the caller to get the reduced value of the fraction, print the fraction
    along with its floating-point value, compare two fractions for equality, and
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 允许调用者获取分数的简化值，打印分数及其浮点值，比较两个分数是否相等，并
- en: add two Fraction objects.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个 Fraction 对象。
- en: '**File: MagicMethods/Fraction.py**'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MagicMethods/Fraction.py**'
- en: Fraction class
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fraction 类
- en: import math
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: 'class Fraction():'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Fraction():'
- en: 'def __init__(self, numerator, denominator): 1'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, numerator, denominator): 1'
- en: 'if not isinstance(numerator, int):'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 numerator 不是整数：
- en: raise TypeError('Numerator', numerator, 'must be an integer')
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError('分子', numerator, '必须是整数')
- en: 'if not isinstance(denominator, int):'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 denominator 不是整数：
- en: raise TypeError('Denominator', denominator, 'must be an integer')
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError('分母', denominator, '必须是整数')
- en: self.numerator = numerator
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: self.numerator = numerator
- en: self.denominator = denominator
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: self.denominator = denominator
- en: Use the math package to find the greatest common divisor
  id: totrans-674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 math 包来计算最大公约数
- en: greatestCommonDivisor = math.gcd(self.numerator, self.denominator)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: greatestCommonDivisor = math.gcd(self.numerator, self.denominator)
- en: 'if greatestCommonDivisor > 1:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 greatestCommonDivisor > 1：
- en: self.numerator = self.numerator // greatestCommonDivisor
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: self.numerator = self.numerator // greatestCommonDivisor
- en: self.denominator = self.denominator // greatestCommonDivisor
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: self.denominator = self.denominator // greatestCommonDivisor
- en: self.value = self.numerator / self.denominator
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: self.value = self.numerator / self.denominator
- en: Normalize the sign of the numerator and denominator
  id: totrans-680
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化分子和分母的符号
- en: self.numerator = int(math.copysign(1.0, self.value)) * abs(self.numerator)
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: self.numerator = int(math.copysign(1.0, self.value)) * abs(self.numerator)
- en: self.denominator = abs(self.denominator)
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: self.denominator = abs(self.denominator)
- en: 'def getValue(self): 2'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getValue(self): 2'
- en: return self.value
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: return self.value
- en: 'def __str__(self): 3'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __str__(self): 3'
- en: '''''''Create a string representation of the fraction'''''''
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''创建分数的字符串表示'''''''
- en: 'output = '' Fraction: '' + str(self.numerator) + ''/'' + \'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 'output = '' Fraction: '' + str(self.numerator) + ''/'' + \'
- en: str(self.denominator) + '\n' + \
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: str(self.denominator) + '\n' + \
- en: ''' Value: '' + str(self.value) + ''\n'''
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: ''' Value: '' + str(self.value) + ''\n'''
- en: return output
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: return output
- en: 'def __add__(self, oOtherFraction): 4'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __add__(self, oOtherFraction): 4'
- en: ''''''' Add two Fraction objects'''''''
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''将两个 Fraction 对象相加'''''''
- en: 'if not isinstance(oOtherFraction, Fraction):'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(oOtherFraction, Fraction):'
- en: raise TypeError('Second value in attempt to add is not a Fraction')
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError('第二个值尝试加法的对象不是 Fraction')
- en: Use the math package to find the least common multiple
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 math 包来找到最小公倍数
- en: newDenominator = math.lcm(self.denominator, oOtherFraction.denominator)
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: newDenominator = math.lcm(self.denominator, oOtherFraction.denominator)
- en: multiplicationFactor = newDenominator // self.denominator
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: multiplicationFactor = newDenominator // self.denominator
- en: equivalentNumerator = self.numerator * multiplicationFactor
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: equivalentNumerator = self.numerator * multiplicationFactor
- en: otherMultiplicationFactor = newDenominator // oOtherFraction.denominator
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: otherMultiplicationFactor = newDenominator // oOtherFraction.denominator
- en: oOtherFractionEquivalentNumerator =
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: oOtherFractionEquivalentNumerator =
- en: oOtherFraction.numerator * otherMultiplicationFactor
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: oOtherFraction.numerator * otherMultiplicationFactor
- en: '**206** Chapter 9'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**206** 第 9 章'
- en: newNumerator = equivalentNumerator + oOtherFractionEquivalentNumerator oAddedFraction
    = Fraction(newNumerator, newDenominator)
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: newNumerator = equivalentNumerator + oOtherFractionEquivalentNumerator oAddedFraction
    = Fraction(newNumerator, newDenominator)
- en: return oAddedFraction
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: return oAddedFraction
- en: 'def __eq__(self, oOtherFraction): 5'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __eq__(self, oOtherFraction): 5'
- en: '''''''Test for equality '''''''
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''测试相等性'''''''
- en: 'if not isinstance(oOtherFraction, Fraction):'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(oOtherFraction, Fraction):'
- en: 'return False # not comparing to a fraction'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 'return False # 不是与分数进行比较'
- en: if (self.numerator == oOtherFraction.numerator) and \
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: if (self.numerator == oOtherFraction.numerator) and \
- en: '(self.denominator == oOtherFraction.denominator):'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '(self.denominator == oOtherFraction.denominator):'
- en: return True
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'else:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return False
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: '*Listing 9-10: The Fraction class that implements a number of magic methods*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-10: 实现多个魔法方法的 Fraction 类*'
- en: When you create a Fraction object, you pass in a numerator and a
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 Fraction 对象时，你需要传入一个分子和一个
- en: denominator 1, and the __init__() method immediately calculates the
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 分母为 1，并且 __init__() 方法会立即计算
- en: reduced fraction and its floating-point value. At any time, client code can
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 约简后的分数及其浮点值。任何时候，客户端代码都可以
- en: call the getValue() method to retrieve that value 2\. Client code can also call
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 getValue() 方法来获取该值 2\。客户端代码还可以调用
- en: print() to print out the object, and Python will call the __str__() method to
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: print() 来打印出该对象，Python 会调用 __str__() 方法来
- en: format a string to be printed 3\.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化要打印的字符串 3\.
- en: The client can add two different Fraction objects together with the
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以将两个不同的 Fraction 对象相加，使用
- en: + operator. When this happens, the __add__() method is called 4\. That
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: + 运算符。此时，会调用 __add__() 方法 4\。那
- en: method uses the math.lcd() (least common denominator) method to ensure
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 方法使用 math.lcd()（最小公分母）来确保
- en: that the resulting Fraction object has the smallest common denominator.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 Fraction 对象具有最小公分母。
- en: Finally, client code can use the == operator to check if two Fraction
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端代码可以使用 == 运算符来检查两个 Fraction 对象是否相等。
- en: objects are equal. When you use this operator, the __eq__() method is
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是否相等。当你使用此运算符时，会调用 __eq__() 方法
- en: called 5, which checks the values of the two Fractions and returns True or
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用 5 次，检查两个 Fraction 的值并返回 True 或
- en: False.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: False.
- en: Here is some code that instantiates Fraction objects and tests the various
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些代码，用于实例化 Fraction 对象并测试各种
- en: 'magic methods:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法方法：
- en: Test code
  id: totrans-731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'oFraction1 = Fraction(1, 3) # create a Fraction object'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 'oFraction1 = Fraction(1, 3) # 创建一个 Fraction 对象'
- en: oFraction2 = Fraction(2, 5)
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: oFraction2 = Fraction(2, 5)
- en: 'print(''Fraction1\n'', oFraction1) # print the object ... calls __str__'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''Fraction1\n'', oFraction1) # 打印对象 ... 调用 __str__'
- en: print('Fraction2\n', oFraction2)
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: print('Fraction2\n', oFraction2)
- en: 'oSumFraction = oFraction1 + oFraction2 # calls __add__'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 'oSumFraction = oFraction1 + oFraction2 # 调用 __add__'
- en: print('Sum is\n', oSumFraction)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: print('和为\n', oSumFraction)
- en: 'print(''Are fractions 1 and 2 equal?'', (oFraction1 == oFraction2)) # expect
    False'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''分数 1 和 2 是否相等?'', (oFraction1 == oFraction2)) # 预期为 False'
- en: print()
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: oFraction3 = Fraction(-20, 80)
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: oFraction3 = Fraction(-20, 80)
- en: oFraction4 = Fraction(4, -16)
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: oFraction4 = Fraction(4, -16)
- en: print('Fraction3\n', oFraction3)
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: print('Fraction3\n', oFraction3)
- en: print('Fraction4\n', oFraction4)
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: print('Fraction4\n', oFraction4)
- en: 'print(''Are fractions 3 and 4 equal?'', (oFraction3 == oFraction4)) # expect
    True'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''分数 3 和 4 是否相等?'', (oFraction3 == oFraction4)) # 预期结果为 True'
- en: print()
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: Polymorphism **207**
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **207**
- en: oFraction5 = Fraction(5, 2)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: oFraction5 = Fraction(5, 2)
- en: oFraction6 = Fraction(500, 200)
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: oFraction6 = Fraction(500, 200)
- en: print('Sum of 5/2 and 500/2\n', oFraction5 + oFraction6)
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: print('5/2 和 500/2 的和\n', oFraction5 + oFraction6)
- en: 'When run, this code produces:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这段代码会输出：
- en: Fraction1
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 分数1
- en: 'Fraction: 1/3'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：1/3
- en: 'Value: 0.3333333333333333'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 值：0.3333333333333333
- en: Fraction2
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction2
- en: 'Fraction: 2/5'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：2/5
- en: 'Value: 0.4'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 值：0.4
- en: Sum is
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 总和是
- en: 'Fraction: 11/15'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：11/15
- en: 'Value: 0.7333333333333333'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 值：0.7333333333333333
- en: Are fractions 1 and 2 equal? False
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 分数 1 和 2 是否相等？ 错误
- en: Fraction3
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction3
- en: 'Fraction: -1/4'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：-1/4
- en: 'Value: -0.25'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 值：-0.25
- en: Fraction4
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction4
- en: 'Fraction: -1/4'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：-1/4
- en: 'Value: -0.25'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 值：-0.25
- en: Are fractions 3 and 4 equal? True
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 分数 3 和 4 是否相等？ 正确
- en: Sum of 5/2 and 500/2
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 5/2 和 500/2 的和
- en: 'Fraction: 5/1'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：5/1
- en: 'Value: 5.0'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 值：5.0
- en: '**Summary**'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter was about the key OOP concept of polymorphism. Stated
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解了OOP的关键概念——多态。正如
- en: simply, polymorphism is the ability for multiple classes to implement meth-
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，多态是指多个类可以实现方法
- en: ods with the same names. Each class contains specific code to do whatever
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称相同的多个版本。每个类包含特定的代码，用于执行所需的操作
- en: needs to be done for objects instantiated from that class. As a demonstra-
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 对象实例化时需要做的事情。作为一个示范，
- en: tion program, I showed how you could create a number of different shape
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在该课程中，我展示了如何创建多个不同形状的方法
- en: classes, each of which had an __init__(), getArea(), clickedInside(), and
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 类，每个类都有一个 __init__()、getArea()、clickedInside() 和
- en: draw() method. The code of each version of these methods was specific to
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法。每个版本的代码针对这些方法的实现是特定的
- en: the type of the shape.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的类型。
- en: As you saw, there are two key advantages to using polymorphism. First,
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用多态有两个关键优点。首先，
- en: it extends the concept of abstraction to a collection of classes, allowing the
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 它扩展了抽象的概念，适用于一组类，使得
- en: client programmer to ignore the implementation. Second, it allows for a
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序员可以忽略实现细节。其次，它允许
- en: system of classes that work in similar ways, making a system predictable to
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以相似方式工作的类系统，使得该系统对
- en: client programmers.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序员。
- en: '**208** Chapter 9'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '**208** 第9章'
- en: I also discussed the idea of polymorphism in operators, explaining how the same
    operator could do different operations with different types
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我还讨论了运算符中的多态性，解释了同一运算符如何针对不同类型执行不同的操作
- en: of data. I showed how Python’s magic methods are used to make this hap-
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的使用。我展示了如何使用Python的魔术方法来实现这一点
- en: pen and how you can build methods to implement these operators in your
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 以及如何在自己的类中实现这些运算符的方法
- en: own classes. To demonstrate the use of arithmetic and comparison operator
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 自己的类。为了演示算术和比较运算符的使用，
- en: magic methods, I showed a Vector class and a Fraction class. I also showed
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术方法中，我展示了一个Vector类和一个Fraction类。我还展示了
- en: how you can use the __str__() method to help in debugging the content of
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 __str__() 方法来帮助调试类的内容
- en: an object.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象。
- en: Polymorphism **209**
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 **209**
- en: '**10**'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**I N H E R I T A N C E**'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '**继 承**'
- en: The third tenet of OOP is *inheritance*, which
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: OOP的第三个原则是*继承*，它
- en: is a mechanism for deriving a new class
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 是推导新类的一种机制
- en: from an existing class. Rather than starting
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有类继承。与其从头开始
- en: from scratch and potentially duplicating code,
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始并可能重复代码，
- en: inheritance allows a programmer to write code for
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许程序员为
- en: a new class that extends or differentiates it from an
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 一个扩展或与现有类区分开来的新类
- en: existing class.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 现有类。
- en: Let’s begin with a real-world example that demonstrates what inheri-
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个实际示例开始，展示继承是什么
- en: tance is basically about. You’re attending culinary school. One of your les-
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 学厨艺的基本理念。你正在参加烹饪学校。你的一节课
- en: sons involves an exhaustive demonstration of making hamburgers. You learn
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 一些涉及制作汉堡的课程演示。你将学习
- en: everything that there is to know about the different cuts of meat, the grind-
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有不同肉类切割、研磨方式的细节
- en: ing of the meat, the best types of buns, the best lettuce, tomato, and condi-
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 肉的烹饪方式，最好的面包，最好的生菜、西红柿和配料
- en: ments—just about everything you could imagine. You also learn about the
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 其他课程——几乎涵盖了你能想到的所有方面。你还将了解
- en: best way to cook the hamburger, how long to cook it, when and how often to
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的煮汉堡的方式，煮多久，何时以及多频繁地
- en: flip it over, and so on.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转汉堡，等等。
- en: The next lesson in the curriculum is about cheeseburgers. The instructor
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 课程中的下一课是关于芝士汉堡的。讲师
- en: '*could* start from scratch and go through all the material about hamburgers'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以*从头开始，学习所有关于汉堡的内容'
- en: again. But instead, they assume that you’ve retained the knowledge from the
    previous lesson and so already know everything there is to know about creating
    a great hamburger. This lesson therefore focuses on what types of cheese
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，但它们假设您已经保留了上一课的知识，因此已经了解了所有创建美味汉堡的内容。本课因此专注于不同类型的奶酪
- en: to use, when to add it, how much to use, and so on.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用，何时添加，使用多少，等等。
- en: The point of the story is that there is no need to “reinvent the wheel”;
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的重点是没有必要“重新发明轮子”；
- en: instead, you can simply add on to what you already know.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您只需要在已有知识的基础上进行扩展。
- en: '**Inheritance in Object-Oriented Programming**'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程中的继承**'
- en: Inheritance in OOP is the ability to create a class that builds on ( *extends*)
    an existing class. When creating large programs, you will often use classes that
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: OOP 中的继承是创建一个建立在（*扩展*）现有类基础上的类的能力。当创建大型程序时，您经常会使用类，
- en: provide very useful general capabilities. You’ll sometimes want to build a
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 提供非常有用的通用功能。你有时会想构建一个
- en: class that’s similar to a class that already exists, but does some things slightly
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于已经存在的类，但做了一些稍微不同的事情
- en: differently. Inheritance allows you to do just that, creating a new class that
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 不同地。继承让你正是可以做到这一点，创建一个新的类，
- en: includes all the methods and instance variables of an existing class, but adds
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 包含现有类的所有方法和实例变量，但增加了
- en: new and different functionality.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 新的和不同的功能。
- en: Inheritance is an extremely powerful concept. When classes are set up
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一个极其强大的概念。当类被设置
- en: correctly, using inheritance can *seem* simple. However, being able to design
    classes to use it in a clear manner is a skill that’s difficult to master. As
    an
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用继承可能看起来*简单*。然而，能够设计出清晰使用继承的类是一项很难掌握的技能。作为一名
- en: implementer, inheritance takes a great deal of practice to use properly and
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 实现者，继承需要大量的练习才能正确使用并
- en: efficiently.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地。
- en: With inheritance, we talk about the relationship between two classes,
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承时，我们讨论的是两个类之间的关系，
- en: typically referred to as the *base class* and *subclass*.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 通常称为*基类*和*子类*。
- en: '**Base class**'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '**基类**'
- en: The class that is inherited from; it serves as a starting point for the subclass
    .
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 从中继承的类；它作为子类的起始点。
- en: '**Subclass**'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**子类**'
- en: The class that is doing the inheriting; it enhances the base class .
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 正在继承的类；它增强了基类。
- en: While these are the most common terms used to describe the two
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是描述两个类之间关系时最常用的术语
- en: 'classes in Python, you may also hear them referred to in other ways, such as:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中定义类时，您可能也会听到它们被以其他方式提到，例如：
- en: • *Superclass* and *subclass*
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: • *超类* 和 *子类*
- en: • *Base class* and *derived* *class*
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: • *基类* 和 *派生* *类*
- en: • *Parent* *class* and *child* *class*
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: • *父类* 和 *子类*
- en: Figure 10-1 is a standard diagram that shows this relationship.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1 是显示这种关系的标准图。
- en: Base class
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 基类
- en: Inherits from
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: Subclass
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 子类
- en: '*Figure 10-1: A subclass inherits*'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：子类继承*'
- en: '*from a base class.*'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '*来自基类。*'
- en: '**212** Chapter 10'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '**212** 第10章'
- en: A subclass inherits all of the methods and instance variables defined in a base
    class.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 子类继承了基类中定义的所有方法和实例变量。
- en: Figure 10-2 provides a different, perhaps more accurate, way to think of
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2 提供了一种不同的，可能更准确的思考方式
- en: the relationship between the two classes.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类之间的关系。
- en: Base class
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 基类
- en: Subclass
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 子类
- en: '*Figure 10-2: A base class is*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：基类是*'
- en: '*incorporated into a subclass.*'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '*并入子类中。*'
- en: As the implementer, you can think of the base class as being incorpo-
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现者，您可以将基类视为被并入
- en: rated into the subclass. That is, the base class actually becomes part of the
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 并入子类中。也就是说，基类实际上成为了子类的一部分
- en: larger subclass. As a client of a subclass, you think about the subclass as
    a
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的子类。作为子类的客户端，您将子类视为一个
- en: single unit and do not need to know that the base class is there at all.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 单一单元，不需要知道基类的存在。
- en: When discussing inheritance, we often say there is an *is a* relationship
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论继承时，我们常说存在*“是一个”*的关系
- en: between a subclass and a base class. For example, a student is a person, an
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 子类和基类之间。例如，学生是一个人，某
- en: orange is a fruit, a car is a vehicle, and so on. The subclass is a specialized
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 橙子是水果，汽车是车辆，等等。子类是一个特殊化
- en: version of the base class that inherits all the properties and behavior of the
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的一个版本，它继承了所有的属性和行为
- en: base class, but also provides additional details and functionality.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 基类，但也提供了额外的细节和功能。
- en: Most importantly, a subclass extends a base class in either or both of
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，子类可以在一个或两个方面扩展基类，
- en: 'the following ways (which will be explained soon):'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式（稍后将解释）：
- en: • A subclass can *redefine* a method that’s defined in the base class. That
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: • 子类可以 *重定义* 基类中定义的方法。那
- en: is, a subclass can provide a method with same name as one in the base
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 即，子类可以提供一个与基类中同名的方法
- en: class but with different functionality. This is called *overriding* a method.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 类，但功能不同。这叫做 *重写* 方法。
- en: When client code makes a call to an overridden method, the method in
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端代码调用一个被重写的方法时，该方法会在
- en: the subclass is called. (However, the code of the method in the subclass
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的是子类。 (然而，子类中方法的代码
- en: can still call the method of the same name in the base class.)
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以调用基类中同名的方法。）
- en: • A subclass can add new methods and instance variables that do not
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: • 子类可以添加新的方法和实例变量，这些方法和实例变量
- en: appear in the base class.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中不会出现。
- en: One way to think of a subclass is with the phrase *coding by difference*.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思考子类的方式是使用短语 *通过差异编码*。
- en: Since the subclass inherits all the instance variables and methods of the
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子类继承了基类的所有实例变量和方法，
- en: base class, it does not need to repeat all of that code; the subclass only
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 基类中，它不需要重复所有代码；子类只需要
- en: needs to contain code that differentiates it from the base class. The code
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 需要包含与基类不同的代码。代码
- en: of the subclass therefore only contains new instance variables (and their
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，子类只包含新的实例变量（以及它们的
- en: initialization), overriding methods, and/or new methods not found in the
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化），重写方法，和/或基类中没有的新方法
- en: base class.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 基类。
- en: '**Implementing Inheritance**'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现继承**'
- en: The syntax of inheritance in Python is simple and elegant. The base class
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的继承语法简单而优雅。基类
- en: does not need to *know* that it is being used as a base class. Only the subclass
    Inheritance **213**
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要 *知道* 它作为基类被使用。只有子类 继承 **213**
- en: 'needs to indicate that it wants to inherit from a base class. Here is the general
    syntax:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 需要表明它想从基类继承。以下是一般语法：
- en: 'class *<BaseClassName>* ():'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '类 *<BaseClassName>* ():'
- en: BaseClass methods
  id: totrans-884
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基类方法
- en: 'class *<SubClassName>* ( *<BaseClassName>* ):'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 'class *<SubClassName>* ( *<BaseClassName>* ):'
- en: SubClass methods
  id: totrans-886
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类方法
- en: In the class statement of the subclass, within the parentheses you spec-
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类的类声明中，括号内需要指定
- en: ify the name of the base class it should inherit from. In this case, we want
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 明确基类的名称以进行继承。在这种情况下，我们希望
- en: the subclass *<SubClassName>* to inherit from the base class *<BaseClassName>*
    .
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 子类 *<SubClassName>* 继承基类 *<BaseClassName>* 。
- en: '(Programmers will often use the word *subclass* as a verb, as in “Let’s subclass
    ClassA to build ClassB.”) Here’s an example with real class names:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: （程序员经常使用 *子类* 作为动词，例如“我们来子类化 ClassA 来构建 ClassB。”）以下是一个真实类名的示例：
- en: 'class Widget():'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Widget():'
- en: Widget's methods
  id: totrans-892
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Widget 的方法
- en: 'class WidgetWithFrills(Widget):'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 'class WidgetWithFrills(Widget):'
- en: WidgetWithFrills's methods
  id: totrans-894
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WidgetWithFrills 的方法
- en: The Widget class will provide general functionality. The WidgetWithFrills
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: Widget 类将提供通用功能。WidgetWithFrills
- en: class will include everything from the Widget class and define any additional
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 类将包括 Widget 类中的所有内容，并定义任何附加的
- en: methods and instance variables it wants with more specific capabilities.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和实例变量，它想要具备更具体功能的。
- en: '**Employee and Manager Example**'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**员工和经理示例**'
- en: I’ll start with an extremely simple example to make the key concepts clear,
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从一个非常简单的例子开始，以便使关键概念清晰，
- en: then move on to some more practical examples.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进入一些更实用的示例。
- en: '***Base Class: Employee***'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '***基类：员工***'
- en: Listing 10-1 defines a base class called Employee.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-1 定义了一个名为 Employee 的基类。
- en: '**File: EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
- en: Employee Manager inheritance
  id: totrans-904
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 员工经理继承
- en: '#'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: Define the Employee class, which we will use as a base class
  id: totrans-906
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Employee 类，我们将其用作基类
- en: 'class Employee():'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Employee():'
- en: 'def __init__(self, name, title, ratePerHour=None):'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, title, ratePerHour=None):'
- en: self.name = name
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.title = title
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: self.title = title
- en: 'if ratePerHour is not None:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ratePerHour 不是 None：
- en: ratePerHour = float(ratePerHour)
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: ratePerHour = float(ratePerHour)
- en: self.ratePerHour = ratePerHour
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: self.ratePerHour = ratePerHour
- en: 'def getName(self):'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getName(self):'
- en: return self.name
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: return self.name
- en: 'def getTitle(self):'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getTitle(self):'
- en: '**214** Chapter 10'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '**214** 第 10 章'
- en: return self.title
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: return self.title
- en: 'def payPerYear(self):'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 'def payPerYear(self):'
- en: 52 weeks * 5 days a week * 8 hours per day
  id: totrans-920
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 52 周 * 每周 5 天 * 每天 8 小时
- en: pay = 52 * 5 * 8 * self.ratePerHour
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: pay = 52 * 5 * 8 * self.ratePerHour
- en: return pay
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 pay
- en: '*Listing 10-1: The Employee class, which will be used as a base class*'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：Employee 类，它将作为基类使用*'
- en: The Employee class has the methods __init__(), getName(), getTitle(), and
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: Employee 类包含方法 __init__()、getName()、getTitle()，以及
- en: payPerYear(). It also has three instance variables, self.name, self.title, and
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: payPerYear()。它还拥有三个实例变量：self.name、self.title 和
- en: self.ratePerHour, which are set in the __init__() method. We retrieve the
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: self.ratePerHour，在 __init__() 方法中设置。我们检索
- en: name and title using getter methods. These employees are paid per hour, so
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 getter 方法获取姓名和头衔。这些员工按小时计薪，因此
- en: self.payPerYear() does a calculation to determine the annual pay based on the
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: self.payPerYear() 进行计算，以确定基于
- en: hourly rate. Everything in this class should be familiar to you; there is noth-
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 每小时费率。这个类中的所有内容应该对你来说很熟悉；没有什么
- en: ing new here. You can instantiate an Employee object by itself, and it will
    work
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以单独实例化一个 Employee 对象，它将正常工作
- en: fine.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。
- en: '***Subclass: Manager***'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '***子类：Manager***'
- en: For the Manager class, we consider the differences between a manager and an
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Manager 类，我们考虑经理与员工之间的差异
- en: 'employee: the manager is a salaried employee who has a number of direct'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 员工：经理是一个有薪员工，管理一组直接
- en: reports. If this manager does a good job, they get a 10 percent bonus for the
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 报告。如果这个经理做得好，他们将获得 10% 的奖金
- en: year. The Manager class can extend the Employee class, since the manager is
    an
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 年薪。Manager 类可以扩展 Employee 类，因为经理是一个
- en: employee but has additional capabilities and responsibilities.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 员工，但拥有额外的能力和责任。
- en: Listing 10-2 shows the code of our Manager class. It only needs to contain
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-2 显示了 Manager 类的代码。它只需要包含
- en: code that is different from the Employee class, so you’ll see that it doesn’t
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与 Employee 类有所不同，因此你会看到它不
- en: have a getName() or getTitle() method. Any calls to those methods with a
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 getName() 或 getTitle() 方法。任何对这些方法的调用，如果
- en: Manager object will be handled by the methods in the Employee class.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 对象将由 Employee 类中的方法处理。
- en: '**File: EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
- en: Define a Manager subclass that inherits from Employee
  id: totrans-943
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个继承自 Employee 的 Manager 子类
- en: '1 class Manager(Employee):'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '1 class Manager(Employee):'
- en: 'def __init__(self, name, title, salary, reportsList=None):'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, title, salary, reportsList=None):'
- en: 2 self.salary = float(salary)
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 2 self.salary = float(salary)
- en: 'if reportsList is None:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 reportsList 为 None：
- en: reportsList = []
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: reportsList = []
- en: self.reportsList = reportsList
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: self.reportsList = reportsList
- en: 3 super().__init__(name, title)
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 3 super().__init__(name, title)
- en: '4 def getReports(self):'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def getReports(self):'
- en: return self.reportsList
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self.reportsList
- en: '5 def payPerYear(self, giveBonus=False):'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def payPerYear(self, giveBonus=False):'
- en: pay = self.salary
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: pay = self.salary
- en: 'if giveBonus:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 giveBonus:'
- en: 'pay = pay + (.10 * self.salary) # add a bonus of 10%'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 'pay = pay + (.10 * self.salary)  # 添加 10% 奖金'
- en: 6 print(self.name, 'gets a bonus for good work')
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 6 print(self.name, '因为工作出色获得奖金')
- en: return pay
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 pay
- en: '*Listing 10-2: The Manager class, implemented as a subclass of the Employee
    class* Inheritance **215**'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：作为 Employee 类子类实现的 Manager 类* 继承 **215**'
- en: In the class statement 1, you can see that this class inherits from the Employee
    class because Employee is inside the parentheses after the name
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明 1 中，你可以看到这个类继承自 Employee 类，因为 Employee 位于名称后面的括号内
- en: Manager.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: Manager。
- en: The __init__() method of the Employee class expects a name, a title, and
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: Employee 类的 __init__() 方法期望一个姓名，一个头衔和
- en: an optional rate per hour. A manager is a salaried employee and manages a
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选的每小时费率。经理是一个有薪员工，并管理一个
- en: number of employees, so the __init__() method of the Manager class expects
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 员工数量，因此 Manager 类的 __init__() 方法期望
- en: a name, a title, a salary, and a list of employees. Adhering to the principle
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 一个姓名，一个头衔，一个薪水，和一个员工列表。遵循
- en: of coding by difference, the __init__() method starts by initializing any-
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 基于差异化编码，__init__() 方法从初始化开始
- en: thing the __init__() method of the Employee class doesn’t do. Therefore, we
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Employee 类的 __init__() 方法所未做的事情。因此，我们
- en: save the salary and reportsList in similarly named instance variables 2\.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 将薪水和 reportsList 存储在同名实例变量中 2\。
- en: Next we want to call the __init__() method of the Employee base class 3\.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想调用 Employee 基类的 __init__() 方法 3\。
- en: Here, I am calling the built-in function super(), which asks Python to figure
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我调用了内建函数 super()，它请求 Python 计算
- en: out which class is the base class (often referred to as the *superclass*) and
    call that class’s __init__() method. It also adjusts the arguments to include
    self
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 找出哪个类是基类（通常称为*父类*），并调用该类的 __init__() 方法。它还调整了参数，包含了 self
- en: as the first argument in this call. Therefore, you can think of this line as
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此调用中的第一个参数。因此，你可以将这一行理解为
- en: 'translating to:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译为：
- en: Employee.__init__(self, name, title)
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: Employee.__init__(self, name, title)
- en: In fact, coding that line this way would work perfectly well; using the
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，以这种方式编写代码是完全可行的；使用
- en: call to super() is simply a much cleaner way to write the call without having
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 super() 只是编写调用的更简洁方式，不需要
- en: to specify the name of the base class.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 指定基类的名称。
- en: The effect is that the new Manager class’s __init__() method initializes
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 其效果是新的 Manager 类的 __init__() 方法初始化
- en: the two instance variables (self.salary and self.reportsList) that are dif-
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实例变量（self.salary 和 self.reportsList）是不同的，
- en: ferent from those in the Employee class, and the Employee class’s __init__()
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Employee 类中的那些不同，并且 Employee 类的 __init__()
- en: method initializes the self.name and self.title instance variables that are
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 方法初始化了 self.name 和 self.title 实例变量，这些变量
- en: common to any Employee or Manager object that is created. For a Manager who
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何创建的 Employee 或 Manager 对象都通用。对于经理来说，
- en: has a salary, self.ratePerHour is set to None.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有工资时，self.ratePerHour 设置为 None。
- en: '**N O T E**'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Older versions of Python required you to write this code in yet a third way,
    so you may* *see this in older programs and documentation:*'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '*旧版本的 Python 需要你以第三种方式编写此代码，因此你可能* *在旧程序和文档中看到这个：*'
- en: super(Employee, self).__init__(name, salary)
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: super(Employee, self).__init__(name, salary)
- en: '*This also does the exact same thing. However, the newer syntax with the simple*'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '*这也做了完全相同的事情。然而，使用更简洁的语法的新方式*'
- en: '*call to super() is much easier to remember. Using super() also makes it less
    error-prone if you decide that you want to change the name of your base class.*'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用 super() 更容易记住。如果你决定更改基类的名称，使用 super() 还使得出错的概率更低。*'
- en: The Manager class has an added getter method, getReports() 4, that
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 类添加了一个 getter 方法 getReports()，它
- en: allows client code to retrieve a list of Employees who report to the Manager.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 允许客户端代码检索向经理汇报的员工列表。
- en: The payPerYear() method 5 calculates and returns the Manager’s pay.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: payPerYear() 方法计算并返回经理的薪水。
- en: Notice that both the Employee and the Manager classes have a method
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Employee 类和 Manager 类都有一个名为
- en: named payPerYear(). If you call the payPerYear() method using an instance
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 payPerYear()。如果你使用 Manager 实例调用 payPerYear() 方法
- en: of Employee, the Employee class’s method will run and calculate the pay based
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是 Employee 的实例，Employee 类的方法会运行并根据
- en: on the hourly rate. If you call the payPerYear() method with an instance of
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 按小时费率计算。如果你使用
- en: Manager, the Manager class’s method will run and do a different calculation.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 类的方法会运行并执行不同的计算。
- en: The payPerYear() method in the Manager class *overrides* the method by the
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 类中的 payPerYear() 方法 *重写*了基类中的方法
- en: same name in the base class. Overriding a method in a subclass specializes
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 与基类中同名的方法相同。在子类中重写方法可以使
- en: '**216** Chapter 10'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '**216** 第 10 章'
- en: the subclass to differentiate it from the base class. The overriding method
    must have the exact same name as the method that it overrides (although it
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 子类用以区分基类。重写的方法必须与它重写的方法完全相同（尽管它
- en: 'may have a different list of parameters). In the overriding method, you can:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有不同的参数列表）。在重写的方法中，你可以：
- en: • Completely replace the overridden method in the base class. We see
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: • 完全替代基类中被重写的方法。我们看到
- en: this in the payPerYear() method of the Manager class.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Manager 类的 payPerYear() 方法中看到这个。
- en: • Do some work on its own and call the inherited or overridden method
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: • 做一些自己的工作并调用继承或重写的方法
- en: of the same name in the base class. We see this in the __init__()
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 基类中同名的方法。我们在 __init__()
- en: method of the Manager class.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 类的方法。
- en: The actual content of the overriding method depends on the situation.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 重写方法的实际内容取决于具体情况。
- en: If the client makes a call to a method that does not exist in a subclass, the
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端调用子类中不存在的方法，则
- en: method call will be sent on to the base class. For example, notice that there
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用将传递给基类。例如，注意到这里
- en: is no method named getName() in the Manager class, but it does exist in the
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 类中没有名为 getName() 的方法，但它确实存在于
- en: Employee base class. If a client calls getName() on an instance of Manager,
    that
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: Employee 基类中。如果客户端在 Manager 实例上调用 getName()，那么
- en: call is handled by the base class, Employee.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 调用由基类 Employee 处理。
- en: 'The payPerYear() method of the Manager class contains this code:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 经理类中的 payPerYear() 方法包含这段代码：
- en: 'if giveBonus:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给奖金：
- en: 'pay = pay + (.10 * self.salary) # add a bonus of 10%'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 'pay = pay + (.10 * self.salary) # 添加10%的奖金'
- en: 6 print(self.name, 'gets a bonus for good work')
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 6 print(self.name, '因为表现出色获得奖金')
- en: The instance variable self.name was defined in the Employee class, but the
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量 self.name 是在员工类中定义的，但
- en: Manager class has no previous mention of it. This demonstrates that instance
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 经理类之前没有提到过它。这表明实例
- en: variables defined in a base class are available for use in methods of a sub-
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中定义的变量可以在子类方法中使用
- en: class. Here we are calculating the pay for a manager, which works correctly
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 类。这里我们正在计算经理的薪资，并且其工作正常
- en: because payPerYear() has access to instance variables defined inside its own
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 payPerYear() 访问的是定义在其自身
- en: class (self.salary) *and* instance variables defined in the base class (printing
    using self.name 6).
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 类（self.salary）*和*在基类中定义的实例变量（使用 self.name 6 打印）。
- en: '***Test Code***'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '***测试代码***'
- en: Let’s test our Employee and Manager objects and call methods of each.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的员工和经理对象，并调用每个对象的方法。
- en: '**File: EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：EmployeeManagerInheritance/EmployeeManagerInheritance.py**'
- en: Create objects
  id: totrans-1026
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: oEmployee1 = Employee('Joe Schmoe', 'Pizza Maker', 16)
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: oEmployee1 = 员工('Joe Schmoe', '披萨师傅', 16)
- en: oEmployee2 = Employee('Chris Smith', 'Cashier', 14)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: oEmployee2 = 员工('Chris Smith', '收银员', 14)
- en: oManager = Manager('Sue Jones', 'Pizza Restaurant Manager',
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: oManager = 经理('Sue Jones', '披萨餐厅经理',
- en: 55000, [oEmployee1, oEmployee2])
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 55000, [oEmployee1, oEmployee2])
- en: Call methods of the Employee objects
  id: totrans-1031
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用员工对象的方法
- en: print('Employee name:', oEmployee1.getName())
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: print('员工姓名：', oEmployee1.getName())
- en: print('Employee salary:', '{:,.2f}'.format(oEmployee1.payPerYear()))
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: print('员工工资：', '{:,.2f}'.format(oEmployee1.payPerYear()))
- en: print('Employee name:', oEmployee2.getName())
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: print('员工姓名：', oEmployee2.getName())
- en: print('Employee salary:', '{:,.2f}'.format(oEmployee2.payPerYear()))
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: print('员工工资：', '{:,.2f}'.format(oEmployee2.payPerYear()))
- en: print()
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: Call methods of the Manager object
  id: totrans-1037
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用经理对象的方法
- en: managerName = oManager.getName()
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: managerName = oManager.getName()
- en: Inheritance **217**
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **217**
- en: print('Manager name:', managerName)
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: print('经理姓名：', managerName)
- en: Give the manager a bonus
  id: totrans-1041
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给经理发放奖金
- en: print('Manager salary:', '{:,.2f}'.format(oManager.payPerYear(True)))
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: print('经理工资：', '{:,.2f}'.format(oManager.payPerYear(True)))
- en: print(managerName, '(' + oManager.getTitle() + ')', 'direct reports:')
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: print(managerName, '(' + oManager.getTitle() + ')', '直接报告：')
- en: reportsList = oManager.getReports()
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: reportsList = oManager.getReports()
- en: 'for oEmployee in reportsList:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 oEmployee in reportsList:'
- en: print(' ', oEmployee.getName(),
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: print(' ', oEmployee.getName(),
- en: '''('' + oEmployee.getTitle() + '')'')'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '''('' + oEmployee.getTitle() + '')'')'
- en: When we run this code, we see the following output, as we would
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，看到以下输出，就像我们预期的那样
- en: 'expect:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 预期：
- en: 'Employee name: Joe Schmoe'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 员工姓名：Joe Schmoe
- en: 'Employee salary: 33,280.00'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 员工工资：33,280.00
- en: 'Employee name: Chris Smith'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 员工姓名：Chris Smith
- en: 'Employee salary: 29,120.00'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 员工工资：29,120.00
- en: 'Manager name: Sue Jones'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 经理姓名：Sue Jones
- en: Sue Jones gets a bonus for good work
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: Sue Jones 因为表现出色获得了奖金
- en: 'Manager salary: 60,500.00'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 经理工资：60,500.00
- en: 'Sue Jones (Pizza Restaurant Manager) direct reports:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: Sue Jones（披萨餐厅经理）直接报告：
- en: Joe Schmoe (Pizza Maker)
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: Joe Schmoe（披萨师傅）
- en: Chris Smith (Cashier)
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: Chris Smith（收银员）
- en: '**The Client’s View of a Subclass**'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端视角下的子类**'
- en: The discussion so far has been focused on the details of implementation.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的讨论重点是实现细节。
- en: But classes can look different depending on whether you are the developer
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 但类的表现可能会有所不同，取决于你是否是开发者
- en: of a class or are writing code to use a class. Let’s change focus and take a
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 类的使用者或者在编写代码使用类时。让我们改变焦点并进行
- en: look at inheritance from the client’s point of view. As far as client code is
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度看继承。就客户端代码而言，
- en: concerned, a subclass has all the functionality of the base class, plus any-
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，子类拥有基类的所有功能，外加任何
- en: thing defined in the subclass itself. It may help to think about the result-
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 子类中定义的内容。考虑结果时，可能会有所帮助——
- en: ing collection of methods as layers of paint on a wall. When a client looks
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: ing 将方法集合看作墙上的一层层涂料。当客户端查看时，
- en: at the Employee class, the client sees all the methods defined in that class
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 在员工类中，客户端看到的是该类中定义的所有方法
- en: (Figure 10-3).
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: （图10-3）。
- en: Employee
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 员工
- en: _init_()
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: _init_()
- en: Client
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: getName()
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: getName()
- en: getTitle()
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: getTitle()
- en: payPerYear()
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: payPerYear()
- en: '*Figure 10-3: What a client would see looking at the*'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：客户端在查看时会看到的内容*'
- en: '*interface of the Employee class*'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '*员工类的接口*'
- en: '**218** Chapter 10'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '**218** 第10章'
- en: When we introduce the Manager class that inherits from the Employee class, it’s
    like adding paint to touch up the places where we want to add or
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引入继承自 Employee 类的 Manager 类时，就像是在我们想要添加或修正的地方加上一层油漆
- en: change methods. For methods that we don’t want to change, we just leave
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 更改方法。对于我们不想更改的方法，我们只需保持
- en: the old layer of paint (Figure 10-4).
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的一层油漆（图 10-4）。
- en: Manager
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: Manager
- en: Employee
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: Employee
- en: _init_()
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: _init_()
- en: _init_()
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: _init_()
- en: Client
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: getName()
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: getName()
- en: getTitle()
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: getTitle()
- en: payPerYear()
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: payPerYear()
- en: payPerYear()
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: payPerYear()
- en: getReports()
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: getReports()
- en: '*Figure 10-4: What a client would see looking at the interface of*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：客户端在界面中看到的内容*'
- en: '*the Manager class*'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '*Manager 类*'
- en: As the developer, we know that the Manager class inherits from the
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们知道 Manager 类继承自
- en: Employee class and overrides some methods. As the client, we just see five
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: Employee 类并重写了一些方法。作为客户端，我们只看到五个
- en: methods. The client doesn’t need to know that some methods are imple-
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。客户端无需了解一些方法是如何实现的
- en: mented in the Manager class and others come from the inherited Employee
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Manager 类中实现的，其他则来自继承的 Employee
- en: class.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 类。
- en: '**Real-World Examples of Inheritance**'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承的现实世界示例**'
- en: Let’s take a look at two real-world examples of inheritance. First, I’ll show
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看两个继承的现实世界示例。首先，我将展示
- en: you how to build an input field that only allows you to enter numbers. I’ll
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 教你如何构建一个只允许输入数字的输入框。我将
- en: then build an output field that formats monetary values.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后构建一个输出框，用于格式化货币值。
- en: '***InputNumber***'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '***InputNumber***'
- en: In this first example, we’ll create an input field that allows the user to input
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，我们将创建一个输入框，允许用户输入
- en: only numerical data. As a general user interface design principle, it’s much
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 只允许输入数字数据。作为一般的用户界面设计原则，限制输入非常重要
- en: better to restrict the input to allow only for correctly formatted data while
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地限制输入，只允许正确格式的数据，同时
- en: the user is entering the data, rather than allowing any input and checking
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入数据时进行限制，而不是允许任何输入然后再检查
- en: its correctness later. Entering letters or other symbols in this input field,
    or
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 它的正确性稍后再验证。输入字母或其他符号，或者
- en: attempting to enter multiple decimal points or multiple minus signs, should
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入多个小数点或多个负号时，应该
- en: not be allowed.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许其他字符输入。
- en: The pygwidgets package contains an InputText class that allows the user
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包含一个 InputText 类，允许用户
- en: to input any characters. We’ll write an InputNumber class to allow only valid
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 输入任何字符。我们将编写一个 InputNumber 类，只允许有效的
- en: numbers as input. The new InputNumber class will inherit much of its code
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 仅允许输入数字作为数据。新的 InputNumber 类将继承大部分代码
- en: 'from InputText. We’ll only need to override three methods of InputText:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 InputText。我们只需要重写 InputText 的三个方法：
- en: __init__(), handleEvent(), and getValue(). Listing 10-3 shows the InputNumber
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: __init__()，handleEvent() 和 getValue()。清单 10-3 显示了 InputNumber
- en: class that overrides these methods.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 重写这些方法的类。
- en: Inheritance **219**
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **219**
- en: '**File: MoneyExamples/InputNumber.py**'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MoneyExamples/InputNumber.py**'
- en: InputNumber class - allows the user to enter only numbers
  id: totrans-1119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InputNumber 类 - 只允许用户输入数字
- en: '#'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: Demo of inheritance
  id: totrans-1121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的示例
- en: import pygame
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import pygwidgets
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: BLACK = (0, 0, 0)
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WHITE = (255, 255, 255)
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: Tuple of legal editing keys
  id: totrans-1127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合法编辑键的元组
- en: LEGAL_KEYS_TUPLE = (pygame.K_RIGHT, pygame.K_LEFT, pygame.K_HOME,
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: LEGAL_KEYS_TUPLE = (pygame.K_RIGHT, pygame.K_LEFT, pygame.K_HOME,
- en: pygame.K_END, pygame.K_DELETE, pygame.K_BACKSPACE,
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.K_END, pygame.K_DELETE, pygame.K_BACKSPACE,
- en: pygame.K_RETURN, pygame.K_KP_ENTER)
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.K_RETURN, pygame.K_KP_ENTER)
- en: Legal keys to be typed
  id: totrans-1131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许输入的合法键
- en: LEGAL_UNICODE_CHARS = ('0123456789.-')
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: LEGAL_UNICODE_CHARS = ('0123456789.-')
- en: '#'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: InputNumber inherits from InputText
  id: totrans-1134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InputNumber 继承自 InputText
- en: '#'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: 'class InputNumber(pygwidgets.InputText):'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 'class InputNumber(pygwidgets.InputText):'
- en: def __init__(self, window, loc, value='', fontName=None, 1
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, window, loc, value='', fontName=None, 1
- en: fontSize=24, width=200, textColor=BLACK,
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=24, width=200, textColor=BLACK,
- en: backgroundColor=WHITE, focusColor=BLACK,
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: backgroundColor=WHITE, focusColor=BLACK,
- en: initialFocus=False, nickName=None, callback=None,
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: initialFocus=False, nickName=None, callback=None,
- en: mask=None, keepFocusOnSubmit=False,
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: mask=None, keepFocusOnSubmit=False,
- en: 'allowFloatingNumber=True, allowNegativeNumber=True):'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 'allowFloatingNumber=True, allowNegativeNumber=True):'
- en: self.allowFloatingNumber = allowFloatingNumber
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: self.allowFloatingNumber = allowFloatingNumber
- en: self.allowNegativeNumber = allowNegativeNumber
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: self.allowNegativeNumber = allowNegativeNumber
- en: Call the __init__ method of our base class
  id: totrans-1145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用我们基类的 __init__ 方法
- en: super().__init__(window, loc, value, fontName, fontSize, 2
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, loc, value, fontName, fontSize, 2
- en: width, textColor, backgroundColor,
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度，文本颜色，背景颜色，
- en: focusColor, initialFocus, nickName, callback,
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: focusColor, initialFocus, nickName, callback，
- en: mask, keepFocusOnSubmit)
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: mask, keepFocusOnSubmit)
- en: Override handleEvent so we can filter for proper keys
  id: totrans-1150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写 handleEvent 方法，以便我们可以过滤合适的键
- en: 'def handleEvent(self, event): 3'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: def handleEvent(self, event)：3
- en: 'if (event.type == pygame.KEYDOWN):'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 (event.type == pygame.KEYDOWN):'
- en: If it's not an editing or numeric key, ignore it
  id: totrans-1153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果不是编辑键或数字键，则忽略它
- en: Unicode value is only present on key down
  id: totrans-1154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode 值仅在按键时存在
- en: allowableKey = (event.key in LEGAL_KEYS_TUPLE) or
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的键是 (event.key 在 LEGAL_KEYS_TUPLE 中) 或
- en: (event.unicode in LEGAL_UNICODE_CHARS))
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: (event.unicode 在 LEGAL_UNICODE_CHARS 中))
- en: 'if not allowableKey:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许的键：
- en: return False
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: 'if event.unicode == ''-'': # user typed a minus sign'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 event.unicode == '-'：# 用户输入了负号
- en: 'if not self.allowNegativeNumber:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许负数：
- en: If no negatives, don't pass it through
  id: totrans-1161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果没有负号，则不传递它
- en: return False
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: 'if self.cursorPosition > 0:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 self.cursorPosition > 0：
- en: '**220** Chapter 10'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '**220** 第10章'
- en: 'return False # can''t put minus sign after 1st char'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 False # 不能在第一个字符后放负号'
- en: 'if ''-'' in self.text:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 '-' 在 self.text 中：
- en: 'return False # can''t enter a second minus sign'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 False # 不能输入第二个负号'
- en: 'if event.unicode == ''.'':'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 event.unicode == '.'：
- en: 'if not self.allowFloatingNumber:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许浮动数字：
- en: If no floats, don't pass the period through
  id: totrans-1170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果没有浮动数字，不传递小数点
- en: return False
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: 'if ''.'' in self.text:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 '.' 在 self.text 中：
- en: 'return False # can''t enter a second period'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 False # 不能输入第二个小数点'
- en: Allow the key to go through to the base class
  id: totrans-1174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许键通过到基类
- en: result = super().handleEvent(event)
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果 = super().handleEvent(event)
- en: return result
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果
- en: 'def getValue(self): 4'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getValue(self): 4'
- en: userString = super().getValue()
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: userString = super().getValue()
- en: 'try:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: 'if self.allowFloatingNumber:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许浮动数字：
- en: returnValue = float(userString)
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: returnValue = float(userString)
- en: 'else:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: returnValue = int(userString)
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: returnValue = int(userString)
- en: 'except ValueError:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: raise ValueError('Entry is not a number, needs to have at least one digit.')
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出 ValueError('输入的不是数字，必须至少包含一个数字。')
- en: return returnValue
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 returnValue
- en: '*Listing 10-3: InputNumber only al ows the user to enter numeric data.*'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-3：InputNumber 仅允许用户输入数字数据。*'
- en: The __init__() method allows for the same parameters as the InputText
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法允许与 InputText 相同的参数
- en: 'base class, plus a few more 1\. It adds two Booleans: allowFloatingNumber to'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 基类，再加上几个 1\. 它添加了两个布尔值：allowFloatingNumber 用于
- en: determine if the user should be allowed to enter floating-point numbers
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 确定是否允许用户输入浮点数
- en: and allowNegativeNumber to determine if the user can enter a number starting
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 allowNegativeNumber 用于确定用户是否可以输入以
- en: with a minus sign. Both default to True, so the default case allows the user
    to
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 带有负号。默认都为 True，因此默认情况下允许用户
- en: enter a floating-point number and both positive and negative numbers. You
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 输入浮动数字，并允许正负数。您
- en: could use these to restrict the user to, for example, only entering a positive
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用这些来限制用户仅输入例如正数
- en: integer value by setting both to False. The __init__() method saves the val-
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两者都设为 False 来限制输入整数。__init__() 方法保存了值-
- en: ues of these two additional parameters in instance variables, then calls the
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个额外的参数在实例变量中，然后调用
- en: __init__() method of the base class using the call to super() 2\.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 super() 调用基类的 __init__() 方法 2\。
- en: The significant code is in the handleEvent() method 3, which restricts
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 关键代码在 handleEvent() 方法 3 中，它限制了
- en: 'the allowed keys to a small subset: the numbers zero through nine, the'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的键限制为一个小子集：数字0到9，
- en: minus sign, a period (decimal point), ENTER, and a few editing keys. When
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 负号、小数点（小数点）、回车键和一些编辑键。当
- en: the user presses a key, this method is called and a KEYDOWN or KEYUP event is
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下键时，会调用此方法并触发 KEYDOWN 或 KEYUP 事件
- en: passed in. The code first ensures that the key pressed is in the restricted
    set.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的代码首先确保按下的键在受限集合中。
- en: If the user enters a key not in that set (for example, any letter), we return
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的键不在该集合中（例如，任何字母），我们返回
- en: False to indicate that nothing important has happened in this widget, and
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False 表示该小部件中没有发生任何重要事件，并且
- en: that key is ignored.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 那个键会被忽略。
- en: The handleEvent() method then does a few more checks to ensure that
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: handleEvent() 方法然后做更多的检查，以确保
- en: the number being entered is legal (for example, doesn’t have two periods,
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的数字是否合法（例如，不能有两个小数点，
- en: only has one minus sign and, so on). Whenever a valid key press is detected,
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个负号，等等）。每当检测到有效的按键时，
- en: the code calls the handleEvent() method of the InputText base class to do
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用 InputText 基类的 handleEvent() 方法来处理
- en: whatever it needs to do with that key (display or edit the field).
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 它对该键做所需的任何操作（显示或编辑字段）。
- en: Inheritance **221**
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **221**
- en: When the user presses RETURN or ENTER, client code calls the get-
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下 RETURN 或 ENTER 时，客户端代码调用 get-
- en: Value() method 4 to get the user’s entry. The getValue() method in this class
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: Value() 方法来获取用户的输入。在这个类中的 getValue() 方法
- en: calls getValue() in the InputText class to get the string from the field, then
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 InputText 类中的 getValue() 方法以获取字段中的字符串，然后
- en: attempts to convert that string to a number. If that conversion fails, it raises
    an exception.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将该字符串转换为数字。如果转换失败，将引发异常。
- en: By overriding methods, we have built a very powerful new reusable class
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写方法，我们构建了一个非常强大的新可重用类
- en: that extends the functionality of the InputText class, without changing a
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 InputText 类的功能，而不改变其
- en: single line in the base class. InputText will continue to function as a class
    by
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 基类中的每一行都没有改变。InputText 将继续作为一个类正常工作
- en: itself, without any changes to its functionality whatsoever.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 本身，没有任何功能上的变化。
- en: '***DisplayMoney***'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '***DisplayMoney***'
- en: As a second real-world example, we’ll create a field to display an amount of
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个现实世界的例子，我们将创建一个字段来显示一个金额
- en: money. To make this general, we’ll display the amount with a chosen cur-
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 货币。为了使这个功能更加通用，我们将使用选择的货币符号显示金额。
- en: rency symbol, place that currency symbol to the left or the right of the text
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 货币符号，将该货币符号放置在文本的左侧或右侧
- en: (as appropriate), and format the number by adding commas between every
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: （视情况而定），并通过在每三个数字之间加上逗号来格式化数字，
- en: three digits, followed by a period and then two decimal digits. For example,
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用逗号分隔每三位数字，再加上一个小数点和两位小数数字。例如，
- en: we would like to be able to display 1234.56 US dollars as $1,234.56\.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够将 1234.56 美元显示为 $1,234.56\。
- en: The pygwidgets package already has a DisplayText class. We can instanti-
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包已经有一个 DisplayText 类。我们可以实例化
- en: 'ate an object from that class using the following interface:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下接口从该类创建一个对象：
- en: def __init__(self, window, loc=(0, 0), value='',
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, window, loc=(0, 0), value='',
- en: fontName=None, fontSize=18, width=None, height=None,
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: fontName=None, fontSize=18, width=None, height=None,
- en: textColor=PYGWIDGETS_BLACK, backgroundColor=None,
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=PYGWIDGETS_BLACK, backgroundColor=None,
- en: 'justified=''left'', nickname=None):'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 'justified=''left'', nickname=None):'
- en: Let’s assume that we have some code that creates a DisplayText object
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有一些代码创建了一个 DisplayText 对象
- en: named oSomeDisplayText using the appropriate arguments. Any time that we
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 oSomeDisplayText，使用适当的参数。每次我们
- en: want to update the text in a DisplayText object, we must call its setValue()
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更新 DisplayText 对象中的文本，必须调用其 setValue()
- en: 'method, like this:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，像这样：
- en: oSomeDisplayText.setValue('1234.56')
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: oSomeDisplayText.setValue('1234.56')
- en: The functionality of displaying a number (as a string) with a DisplayText
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个数字（作为字符串）与 DisplayText 的功能
- en: object already exists. We want to create a new class named DisplayMoney that
    is
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 对象已经存在。我们希望创建一个新的类，命名为 DisplayMoney，它是
- en: similar to DisplayText but adds functionality, so we’ll inherit from DisplayText.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 DisplayText，但增加了功能，因此我们将继承自 DisplayText。
- en: Our DisplayMoney class will have an enhanced version of the setValue()
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DisplayMoney 类将有一个增强版的 setValue()
- en: method that overrides the base class’s setValue() method. The DisplayMoney
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，这个方法覆盖了基类的 setValue() 方法。DisplayMoney
- en: version will add the desired formatting, by adding a currency symbol, add-
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 版本将添加所需的格式化功能，包括添加货币符号，添加逗号，
- en: ing commas, optionally truncating to two decimal digits, and so on. At the
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加逗号，可选地截断到两位小数等。最后，方法将调用基类 DisplayText
- en: end, the method will call the inherited setValue() method of the DisplayText
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，方法将调用继承的 DisplayText 的 setValue() 方法
- en: base class and pass in a string version of the formatted text to display in
    the
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 基类并传入一个格式化文本的字符串版本以在
- en: window.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。
- en: We’ll also add some additional setup parameters in the __init__()
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 __init__() 中添加一些额外的设置参数
- en: 'method to allow client code to:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 方法允许客户端代码：
- en: • Choose the currency symbol (defaults to $)
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: • 选择货币符号（默认为 $）
- en: • Place the currency symbol on the left or right (defaults to left)
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: • 将货币符号放在左侧或右侧（默认为左侧）
- en: • Show or hide two decimal places (defaults to show)
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: • 显示或隐藏两位小数（默认为显示）
- en: '**222** Chapter 10'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '**222** 第10章'
- en: Listing 10-4 shows the code of our new DisplayMoney class.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-4 显示了我们新创建的 DisplayMoney 类的代码。
- en: '**File: MoneyExamples/DisplayMoney.py**'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MoneyExamples/DisplayMoney.py**'
- en: DisplayMoney class - displays a number as an amount of money
  id: totrans-1256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DisplayMoney 类 - 将数字显示为货币金额
- en: '#'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: Demo of inheritance
  id: totrans-1258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承示例
- en: import pygwidgets
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: BLACK = (0, 0, 0)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: '#'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: DisplayMoney class inherits from DisplayText class
  id: totrans-1262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DisplayMoney 类继承自 DisplayText 类
- en: '#'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: '1 class DisplayMoney(pygwidgets.DisplayText):'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '1 class DisplayMoney(pygwidgets.DisplayText):'
- en: 2 def __init__(self, window, loc, value=None,
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 2 def __init__(self, window, loc, value=None,
- en: fontName=None, fontSize=24, width=150, height=None,
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: fontName=None, fontSize=24, width=150, height=None,
- en: textColor=BLACK, backgroundColor=None,
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=BLACK, backgroundColor=None,
- en: justified='left', value=None, currencySymbol='$',
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: justified='left', value=None, currencySymbol='$',
- en: 'currencySymbolOnLeft=True, showCents=True):'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 'currencySymbolOnLeft=True, showCents=True):'
- en: 3 self.currencySymbol = currencySymbol
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.currencySymbol = currencySymbol
- en: self.currencySymbolOnLeft = currencySymbolOnLeft
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: self.currencySymbolOnLeft = currencySymbolOnLeft
- en: self.showCents = showCents
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: self.showCents = showCents
- en: 'if value is None:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果value为None：
- en: value = 0.00
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: value = 0.00
- en: Call the __init__ method of our base class
  id: totrans-1275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用我们基类的__init__方法
- en: 4 super().__init__(window, loc, value,
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 4 super().__init__(window, loc, value,
- en: fontName, fontSize, width, height,
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: fontName, fontSize, width, height,
- en: textColor, backgroundColor, justified)
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: textColor, backgroundColor, justified)
- en: '5 def setValue(self, money):'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def setValue(self, money):'
- en: 'if money == '''':'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '如果money == '''':'
- en: money = 0.00
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: money = 0.00
- en: money = float(money)
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: money = float(money)
- en: 'if self.showCents:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self.showCents：
- en: money = '{:,.2f}'.format(money)
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: money = '{:,.2f}'.format(money)
- en: 'else:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: money = '{:,.0f}'.format(money)
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: money = '{:,.0f}'.format(money)
- en: 'if self.currencySymbolOnLeft:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '如果self.currencySymbolOnLeft:'
- en: theText = self.currencySymbol + money
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: theText = self.currencySymbol + money
- en: 'else:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: theText = money + self.currencySymbol
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: theText = money + self.currencySymbol
- en: Call the setValue method of our base class
  id: totrans-1291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用我们基类的setValue方法
- en: 6 super().setValue(theText)
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 6 super().setValue(theText)
- en: '*Listing 10-4: DisplayMoney displays a number format ed as a monetary value.*'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-4：DisplayMoney显示一个格式化为货币值的数字。*'
- en: Inheritance **223**
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **223**
- en: In the class definition, we explicitly inherit from pygwidgets.DisplayText 1\.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，我们显式继承了pygwidgets.DisplayText 1。
- en: 'The DisplayMoney class only contains two methods: __init__() and setValue().'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: DisplayMoney类仅包含两个方法：__init__()和setValue()。
- en: These two methods override the methods with the same names in the base
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法重写了基类中相同名称的方法
- en: class.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 类。
- en: 'A client instantiates a DisplayMoney object like this:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端像这样实例化一个DisplayMoney对象：
- en: oDisplayMoney = DisplayMoney(widow, (100, 100), 1234.56)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: oDisplayMoney = DisplayMoney(widow, (100, 100), 1234.56)
- en: With this line, the __init__() method in DisplayMoney 2 will run and
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行，DisplayMoney 2中的__init__()方法将运行并
- en: override the __init__() method in the base class. This method does some
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖基类中的__init__()方法。此方法做了一些
- en: initialization, including saving any client preferences for the currency
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化，包括保存任何与货币相关的客户端偏好设置
- en: symbol, the side on which to show the symbol, and whether or not we
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: symbol，显示符号的侧边，以及我们是否
- en: should show cents, all in instance variables 3\. The method ends with a
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 应该显示分币，所有的都在实例变量中 3。该方法以
- en: call to the __init__() method of the base class, DisplayText 4 (which it
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 调用基类DisplayText 4的__init__()方法（它
- en: finds by calling super()), and passes on the data required by that
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用super()来查找，并传递所需的数据
- en: method.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。
- en: 'Later, the client makes a call like this to show a value:'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，客户端像这样调用以显示一个值：
- en: oDisplayMoney.setValue(12233.44)
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: oDisplayMoney.setValue(12233.44)
- en: The setValue() method 5 in the DisplayMoney class runs to create a ver-
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: setValue()方法 5 在DisplayMoney类中运行以创建一个版本
- en: sion of the amount of money formatted as a currency value. The method
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化金额为货币值的版本。该方法
- en: ends by calling the inherited setValue() method in the DisplayText class 6 to
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后通过调用DisplayText类中的继承setValue()方法 6 来结束
- en: set the new text to display.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 设置新文本以进行显示。
- en: When a call is made to any other method with an instance of DisplayMoney,
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 当对DisplayMoney的实例调用任何其他方法时，
- en: the version residing in DisplayText will run. Most importantly, every time
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: DisplayText中的版本将运行。最重要的是，每次
- en: through the loop, the client code should call oDisplayMoney.draw(), which
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码应调用oDisplayMoney.draw()，这将
- en: draws the field in the window. Since DisplayMoney does *not* have a draw()
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制窗口中的字段。由于DisplayMoney没有*draw()*
- en: method, that call will go to the DisplayText base class, which does have a
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，调用将转到DisplayText基类，后者确实有一个
- en: draw() method.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: draw()方法。
- en: '***Example Usage***'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '***示例用法***'
- en: Figure 10-5 shows the output of an example program that takes advantage
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5显示了一个示例程序的输出，该程序利用了
- en: of both the InputNumber and DisplayMoney classes. The user enters a number
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数字和DisplayMoney类的实例。用户通过循环输入数字
- en: into an InputNumber field. When the user presses OK or ENTER, that value will
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 输入到InputNumber字段中。当用户按下OK或ENTER时，该值将
- en: be displayed in the two DisplayMoney fields. The first field shows the number
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 将在两个DisplayMoney字段中显示。第一个字段显示数字
- en: with decimal places, and the second rounds to the closest dollar using dif-
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 带有小数位的，第二个方法使用不同的初始设置四舍五入到最接近的美元
- en: ferent initial settings.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的初始设置。
- en: Listing 10-5 contains the full code of the main program. Notice
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5 包含主程序的完整代码。请注意
- en: that the code creates a single InputNumber object and two DisplayMoney
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个InputNumber对象和两个DisplayMoney对象
- en: objects.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: objects.
- en: '**224** Chapter 10'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '**224** 第10章'
- en: '![Image 28](index-254_1.png)'
  id: totrans-1332
  prefs: []
  type: TYPE_IMG
  zh: '![图片 28](index-254_1.png)'
- en: '*Figure 10-5: A client program where the user enters an amount into an InputNumber*
    *field and the amount is displayed in two DisplayMoney fields*'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：一个客户端程序，用户在输入框中输入金额*，*然后金额显示在两个DisplayMoney框中*'
- en: '**File: MoneyExamples/Main_MoneyExample.py**'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MoneyExamples/Main_MoneyExample.py**'
- en: Money example
  id: totrans-1335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金钱示例
- en: '#'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: Demonstrates overriding inherited DisplayText and InputText methods
  id: totrans-1337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示重写继承的DisplayText和InputText方法
- en: 1 - Import packages
  id: totrans-1338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import pygwidgets
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: from DisplayMoney import *
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: from DisplayMoney import *
- en: from InputNumber import *
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: from InputNumber import *
- en: 2 - Define constants
  id: totrans-1345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: BLACKISH = (10, 10, 10)
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: BLACKISH = (10, 10, 10)
- en: GRAY = (128, 128, 128)
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: GRAY = (128, 128, 128)
- en: WHITE = (255, 255, 255)
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: BACKGROUND_COLOR = (0, 180, 180)
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: BACKGROUND_COLOR = (0, 180, 180)
- en: WINDOW_WIDTH = 640
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-1354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode([WINDOW_WIDTH, WINDOW_HEIGHT])
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode([WINDOW_WIDTH, WINDOW_HEIGHT])
- en: clock = pygame.time.Clock()
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: Inheritance **225**
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **225**
- en: 5 - Initialize variables
  id: totrans-1360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: title = pygwidgets.DisplayText(window, (0, 40),
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: title = pygwidgets.DisplayText(window, (0, 40),
- en: '''Demo of InputNumber and DisplayMoney fields'','
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '''输入数字和显示金额字段的演示'','
- en: fontSize=36, width=WINDOW_WIDTH, justified='center')
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=36, width=WINDOW_WIDTH, justified='center')
- en: inputCaption = pygwidgets.DisplayText(window, (20, 150),
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: inputCaption = pygwidgets.DisplayText(window, (20, 150),
- en: '''Input money amount:'', fontSize=24,'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '''输入金额：'', fontSize=24,'
- en: width=190, justified='right')
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: width=190, justified='right')
- en: inputField = InputNumber(window, (230, 150), '', width=150)
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: inputField = InputNumber(window, (230, 150), '', width=150)
- en: okButton = pygwidgets.TextButton(window, (430, 150), 'OK')
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: okButton = pygwidgets.TextButton(window, (430, 150), '确定')
- en: outputCaption1 = pygwidgets.DisplayText(window, (20, 300),
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: outputCaption1 = pygwidgets.DisplayText(window, (20, 300),
- en: '''Output dollars & cents: '', fontSize=24,'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '''输出美元和分：'', fontSize=24,'
- en: width=190, justified='right')
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: width=190, justified='right')
- en: moneyField1 = DisplayMoney(window, (230, 300), '', textColor=BLACK,
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: moneyField1 = DisplayMoney(window, (230, 300), '', textColor=BLACK,
- en: backgroundColor=WHITE, width=150)
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: backgroundColor=WHITE, width=150)
- en: outputCaption2 = pygwidgets.DisplayText(window, (20, 400),
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: outputCaption2 = pygwidgets.DisplayText(window, (20, 400),
- en: '''Output dollars only: '', fontSize=24,'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '''仅显示美元：'', fontSize=24,'
- en: width=190, justified='right')
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: width=190, justified='right')
- en: moneyField2 = DisplayMoney(window, (230, 400), '', textColor=BLACK,
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: moneyField2 = DisplayMoney(window, (230, 400), '', textColor=BLACK,
- en: backgroundColor=WHITE, width=150,
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: backgroundColor=WHITE, width=150,
- en: showCents=False)
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: showCents=False)
- en: 6 - Loop forever
  id: totrans-1380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-1382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: If the event was a click on the close box, quit pygame and the program
  id: totrans-1384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果事件是点击关闭框，退出pygame和程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: Pressing Return/Enter or clicking OK triggers action
  id: totrans-1388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按下Return/Enter或点击OK触发动作
- en: 'if inputField.handleEvent(event) or okButton.handleEvent(event): 1'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 'if inputField.handleEvent(event) or okButton.handleEvent(event): 1'
- en: 'try:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: theValue = inputField.getValue()
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: theValue = inputField.getValue()
- en: 'except ValueError: # any remaining error'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError: # 其他任何错误'
- en: inputField.setValue('(not a number)')
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: inputField.setValue('(不是数字)')
- en: 'else: # input was OK'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 'else: # 输入有效'
- en: theText = str(theValue)
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: theText = str(theValue)
- en: moneyField1.setValue(theText)
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: moneyField1.setValue(theText)
- en: moneyField2.setValue(theText)
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: moneyField2.setValue(theText)
- en: 8 Do any "per frame" actions
  id: totrans-1398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”动作
- en: 9 - Clear the window
  id: totrans-1399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: window.fill(BACKGROUND_COLOR)
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BACKGROUND_COLOR)
- en: 10 - Draw all window elements
  id: totrans-1401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: title.draw()
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: title.draw()
- en: inputCaption.draw()
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: inputCaption.draw()
- en: inputField.draw()
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: inputField.draw()
- en: okButton.draw()
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: okButton.draw()
- en: '**226** Chapter 10'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '**226** 第10章'
- en: outputCaption1.draw()
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: outputCaption1.draw()
- en: moneyField1.draw()
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: moneyField1.draw()
- en: outputCaption2.draw()
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: outputCaption2.draw()
- en: moneyField2.draw()
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: moneyField2.draw()
- en: 11 - Update the window
  id: totrans-1411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 使pygame等待'
- en: '*Listing 10-5: The main program to demonstrate the InputNumber and DisplayMoney
    classes* The user enters the number into an InputNumber field. As the user types,'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-5：演示InputNumber和DisplayMoney类的主程序* 用户将数字输入到InputNumber字段中。用户输入时，'
- en: any inappropriate characters are filtered out and ignored by the handleEvent()
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: handleEvent()会过滤掉任何不适当的字符并忽略它们
- en: method. When the user clicks OK 1, the code reads the input and passes it to
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。当用户点击OK时，代码读取输入并将其传递给
- en: the two DisplayMoney fields. The first shows the dollar and cents amount (with
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 显示金额的两个字段。第一个显示美元和美分金额（保留两位小数），而第二个只显示美元数额。两个字段
- en: two decimal digits), while the second shows the value in dollars only. Both
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 保留两位小数），而第二个只显示美元金额。两个字段
- en: add a $ as the currency symbol and add commas every three digits.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个$符号作为货币符号，并每三位数字添加一个逗号。
- en: '**Multiple Classes Inheriting from the Same Base Class**'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个类继承自同一个基类**'
- en: Multiple different classes can inherit from the same base class. You can
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 多个不同的类可以继承自同一个基类。你可以
- en: build a very general base class, then construct any number of subclasses
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个非常通用的基类，然后构建任意数量的子类
- en: that inherit from it. Figure 10-6 is a representation of this relationship.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自它的类。图10-6 展示了这种关系。
- en: Base class
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 基类
- en: Inherits from
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: Subclass
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 子类
- en: Subclass
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 子类
- en: Subclass
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 子类
- en: …
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '*Figure 10-6: Three or more different subclasses inheriting from a common base
    class* Each of the different subclasses can then be a variant (a more specific'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：三个或更多不同的子类继承自一个公共基类* 每个不同的子类可以是其变种（更具体的版本） '
- en: version) of the generic base class. Each subclass can override any methods
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类的变种，每个子类可以重写任何方法
- en: of the base class that it wants to or needs to, independent of any other
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的字段，子类可以根据需要独立重写，和其他任何
- en: subclass.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 子类。
- en: Let’s walk through an example using the Shapes program from
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Shapes程序中的示例来演示
- en: '[Chapter 9 t](index_split_003.html#p212)hat created and drew circles, squares,
    and triangles. The code also allowed the user to click on any shape in the window
    to see the area of'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章 t](index_split_003.html#p212) 该程序创建并绘制了圆形、正方形和三角形。代码还允许用户点击窗口中的任何形状，以查看其面积。'
- en: that shape.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 那个形状。
- en: 'The program was implemented with three different shape classes:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序实现了三个不同的形状类：
- en: Circle, Square, and Triangle. If we look back at those three classes, we find
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形、正方形和三角形。如果我们回顾这三个类，我们会发现
- en: 'that each one has this exact same method:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都有这个完全相同的方法：
- en: 'def getType(self):'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getType(self):'
- en: return self.shapeType
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: return self.shapeType
- en: Inheritance **227**
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **227**
- en: Further, looking at the __init__() methods of the three classes, we find that
    there is some common code that remembers the window, chooses a
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，查看三个类的__init__()方法时，我们发现有一些共同的代码，用于记住窗口、选择一个
- en: 'random color, and chooses a random location:'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 随机颜色，并选择一个随机位置：
- en: self.window = window
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(1, maxWidth - 100)
- en: self.y = random.randrange(1, maxHeight - 100)
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(1, maxHeight - 100)
- en: Finally, each class sets the instance variable self.shapeType to an appro-
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个类将实例变量self.shapeType设置为一个合适的值
- en: priate string.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 合适的字符串。
- en: Whenever we find a set of classes that implement the exact same method
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发现一组类实现了完全相同的方法
- en: and/or share some code in a commonly named method, we should recog-
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 和/或在一个常用名称的方法中共享一些代码时，我们应该意识到
- en: nize that this is a good candidate for inheritance.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 识别到这是继承的一个良好候选者。
- en: Let’s extract the common code from the three classes and build a com-
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提取三个类中的共同代码，并构建一个通用的
- en: mon base class named Shape, shown in Listing 10-6\.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为Shape的通用基类，如示例 10-6 所示。
- en: '**File: InheritedShapes/ShapeBasic.py**'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/ShapeBasic.py**'
- en: Shape class - basic
  id: totrans-1458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shape类 - 基本
- en: import random
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: Set up the colors
  id: totrans-1460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: RED = (255, 0, 0)
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: RED = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = (0, 255, 0)
- en: BLUE = (0, 0, 255)
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: BLUE = (0, 0, 255)
- en: 'class Shape():'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Shape():'
- en: '1 def __init__(self, window, shapeType, maxWidth, maxHeight):'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __init__(self, window, shapeType, maxWidth, maxHeight):'
- en: self.window = window
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.shapeType = shapeType
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: self.shapeType = shapeType
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(1, maxWidth - 100)
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(25, maxHeight - 100)
- en: '2 def getType(self):'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def getType(self):'
- en: return self.shapeType
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: return self.shapeType
- en: '*Listing 10-6: The Shape class, to be used as a base class*'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-6：Shape 类，用作基类*'
- en: 'The class consists of only two methods: __init__() and getType(). The'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 该类仅由两个方法组成：__init__() 和 getType()。该
- en: __init__() method 1 remembers the data passed in in instance vari-
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法 1 会记住传入实例变量的数据
- en: ables, then randomly chooses a color and a starting location (self.x and
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: ables，然后随机选择颜色和起始位置（self.x 和
- en: self.y). The getType() method 2 just returns the type of the shape given
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: self.y）。getType() 方法 2 只返回给定形状的类型
- en: at initialization.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时。
- en: We can now write any number of subclasses that inherit from Shape.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写任意数量的继承自 Shape 的子类。
- en: We’ll create three subclasses that will call the __init__() method of the Shape
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个子类，它们将调用 Shape
- en: class, passing in a string that identifies its type and the size of the window.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: class，传入一个字符串来标识其类型和窗口的大小。
- en: The getType() method will only appear in the Shape class, so any client calls
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: getType() 方法仅会出现在 Shape 类中，因此任何客户端调用
- en: '**228** Chapter 10'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '**228** 第10章'
- en: to getType() will be handled by that method in the inherited Shape class.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 对 getType() 的调用将由继承自 Shape 类的方法处理。
- en: We’ll start with the code for the Square class, shown in Listing 10-7\.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Square 类的代码开始，如列表 10-7 所示。
- en: '**File: InheritedShapes/Square.py**'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/Square.py**'
- en: Square class
  id: totrans-1487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Square 类
- en: import pygame
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from Shape import *
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: from Shape import *
- en: 'class Square(Shape): 1'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Square(Shape): 1'
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight):'
- en: super().__init__(window, 'Square', maxWidth, maxHeight) 2
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, 'Square', maxWidth, maxHeight) 2
- en: self.widthAndHeight = random.randrange(10, 100)
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: self.widthAndHeight = random.randrange(10, 100)
- en: self.rect = pygame.Rect(self.x, self.y,
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y,
- en: self.widthAndHeight, self.widthAndHeight)
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: self.widthAndHeight, self.widthAndHeight)
- en: 'def clickedInside(self, mousePoint): 3'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 'def clickedInside(self, mousePoint): 3'
- en: clicked = self.rect.collidepoint(mousePoint)
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: clicked = self.rect.collidepoint(mousePoint)
- en: return clicked
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: return clicked
- en: 'def getArea(self): 4'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getArea(self): 4'
- en: theArea = self.widthAndHeight * self.widthAndHeight
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = self.widthAndHeight * self.widthAndHeight
- en: return theArea
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: return theArea
- en: 'def draw(self): 5'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self): 5'
- en: pygame.draw.rect(self.window, self.color,
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.rect(self.window, self.color,
- en: (self.x, self.y, self.widthAndHeight, self.widthAndHeight))
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: (self.x, self.y, self.widthAndHeight, self.widthAndHeight))
- en: '*Listing 10-7: The Square class that inherits from the Shape class*'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-7：继承自 Shape 类的 Square 类*'
- en: The Square class starts by inheriting from the Shape class 1\. The
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: Square 类从 Shape 类继承开始 1。该
- en: __init__() method calls the __init__() method of its base class (or super-
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法调用其基类（或 super-）的 __init__() 方法
- en: class) 2, identifying this shape as a square and randomly choosing its size.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: class) 2，标识这个形状为正方形并随机选择其大小。
- en: Next we have three methods whose implementation is specific
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有三个方法，它们的实现是特定的
- en: to a square. The clickedInside() method only needs to make a call to
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为正方形。clickedInside() 方法只需要调用
- en: rect.collidepoint() to determine if a click happened inside its rectan-
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: rect.collidepoint() 来确定点击是否发生在其矩形内部。
- en: gle 3\. The getArea() method simply multiplies the widthAndHeight by the
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 角度 3。getArea() 方法简单地将 widthAndHeight 乘以
- en: widthAndHeight 4\. Finally, the draw() method draws a rectangle using the
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: widthAndHeight 4。最后，draw() 方法绘制一个矩形，使用
- en: value of widthAndHeight 5\.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: widthAndHeight 的值 5\。
- en: Listing 10-8 shows the Circle class, which has also been modified to
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-8 显示了 Circle 类，它也已经被修改为
- en: inherit from the Shape class.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自 Shape 类。
- en: '**File: InheritedShapes/Circle.py**'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/Circle.py**'
- en: Circle class
  id: totrans-1518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Circle 类
- en: import pygame
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from Shape import *
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: from Shape import *
- en: import math
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: Inheritance **229**
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **229**
- en: 'class Circle(Shape):'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Circle(Shape):'
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight):'
- en: super().__init__(window, 'Circle', maxWidth, maxHeight)
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, 'Circle', maxWidth, maxHeight)
- en: self.radius = random.randrange(10, 50)
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: self.radius = random.randrange(10, 50)
- en: self.centerX = self.x + self.radius
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: self.centerX = self.x + self.radius
- en: self.centerY = self.y + self.radius
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: self.centerY = self.y + self.radius
- en: self.rect = pygame.Rect(self.x, self.y, self.radius * 2, self.radius * 2)
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y, self.radius * 2, self.radius * 2)
- en: 'def clickedInside(self, mousePoint):'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 'def clickedInside(self, mousePoint):'
- en: theDistance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: theDistance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
- en: ((mousePoint[1] - self.centerY) ** 2))
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: ((mousePoint[1] - self.centerY) ** 2))
- en: 'if theDistance <= self.radius:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 theDistance <= self.radius:'
- en: return True
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'else:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return False
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'def getArea(self):'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getArea(self):'
- en: theArea = math.pi * (self.radius ** 2)
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = math.pi * (self.radius ** 2)
- en: return theArea
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: return theArea
- en: 'def draw(self):'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: pygame.draw.circle(self.window, self.color, (self.centerX, self.centerY),
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.circle(self.window, self.color, (self.centerX, self.centerY),
- en: self.radius, 0)
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: self.radius, 0)
- en: '*Listing 10-8: The Circle class that inherits from the Shape class*'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-8：继承自 Shape 类的 Circle 类*'
- en: The Circle class also contains the clickedInside(), getArea(), and draw()
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: Circle 类也包含 clickedInside()、getArea() 和 draw()
- en: methods, whose implementation is specific to a circle.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，其实现特定于一个圆形。
- en: Finally, Listing 10-9 shows the code of the Triangle class.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列表 10-9 显示了 Triangle 类的代码。
- en: '**File: InheritedShapes/Triangle.py**'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/Triangle.py**'
- en: Triangle class
  id: totrans-1548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Triangle 类
- en: import pygame
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygame
- en: from Shape import *
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Shape 导入 *
- en: 'class Triangle(Shape):'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Triangle(Shape):'
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 __init__(self, window, maxWidth, maxHeight)：
- en: super().__init__(window, 'Triangle', maxWidth, maxHeight)
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, 'Triangle', maxWidth, maxHeight)
- en: self.width = random.randrange(10, 100)
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = random.randrange(10, 100)
- en: self.height = random.randrange(10, 100)
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = random.randrange(10, 100)
- en: self.triangleSlope = -1 * (self.height / self.width)
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: self.triangleSlope = -1 * (self.height / self.width)
- en: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
- en: 'def clickedInside(self, mousePoint):'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 clickedInside(self, mousePoint)：
- en: inRect = self.rect.collidepoint(mousePoint)
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: inRect = self.rect.collidepoint(mousePoint)
- en: 'if not inRect:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不在矩形内：
- en: return False
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: Do some math to see if the point is inside the triangle
  id: totrans-1562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一些数学运算，看看点是否在三角形内
- en: xOffset = mousePoint[0] - self.x
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: xOffset = mousePoint[0] - self.x
- en: '**230** Chapter 10'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: '**230** 第 10 章'
- en: yOffset = mousePoint[1] – self.y
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: yOffset = mousePoint[1] – self.y
- en: 'if xOffset == 0:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xOffset == 0：
- en: return True
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'pointSlopeFromYIntercept = (yOffset – self.height) / xOffset # rise over run'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 'pointSlopeFromYIntercept = (yOffset – self.height) / xOffset # 上升除以运行'
- en: 'if pointSlopeFromYIntercept < 1:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pointSlopeFromYIntercept < 1：
- en: return True
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'else:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: 'def getArea(self):'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 getArea(self):'
- en: theArea = .5 * self.width * self.height
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = .5 * self.width * self.height
- en: return theArea
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 theArea
- en: 'def draw(self):'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 draw(self):'
- en: pygame.draw.polygon(self.window, self.color, (
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.polygon(self.window, self.color, (
- en: (self.x, self.y + self.height),
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: （self.x, self.y + self.height），
- en: (self.x, self.y),
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: （self.x, self.y），
- en: (self.x + self.width, self.y)))
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: （self.x + self.width, self.y)））
- en: '*Listing 10-9: The Triangle class that inherits from the Shape class*'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-9：继承自 Shape 类的 Triangle 类*'
- en: The main code we used for testing i[n Chapter 9 d](index_split_003.html#p212)oesn’t
    have to change at all. As a client of these new classes, it instantiates Square,
    Circle, and Triangle objects without having to worry about the implementation
    of those classes. It
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于测试的主要代码（[第9章](index_split_003.html#p212)）完全不需要更改。作为这些新类的客户端，它实例化了 Square、Circle
    和 Triangle 对象，而不必担心这些类的实现。它
- en: doesn’t need to know that each is subclassed from a common Shape class.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要知道每个类都是从一个公共的 Shape 类继承的。
- en: '**Abstract Classes and Methods**'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类和方法**'
- en: Unfortunately, our Shape base class has a potential bug. At the moment, a
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的 Shape 基类有一个潜在的 bug。目前，一个
- en: client could instantiate a generic Shape object, which is too generic to have
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以实例化一个通用的 Shape 对象，但它太通用，无法拥有
- en: its own getArea() method. Further, all classes that inherit from the Shape
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 它自己的 getArea() 方法。进一步地，所有继承自 Shape 的类
- en: class (like Square, Circle, and Triangle) *must* implement clickedInside(),
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 类（如 Square、Circle 和 Triangle）*必须*实现 clickedInside()，
- en: getArea(), and draw(). To solve both of these problems, I’ll introduce the
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: getArea() 和 draw()。为了解决这两个问题，我将引入
- en: concepts of an *abstract class* and an *abstract method*.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象类* 和 *抽象方法* 的概念。'
- en: '**abstract class**'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**'
- en: A class that is *not* intended to be instantiated directly, but only to be used
    as a base class by one or more subclasses . (In some other languages, an abstract
    class is
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*不*打算直接实例化的类，而只是作为一个或多个子类的基类使用。（在其他一些语言中，抽象类是
- en: referred to as a *virtual class* .)
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*虚拟类*。)
- en: '**abstract method** A method that *must* be overridden in every subclass .'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象方法** 一个*必须*在每个子类中重写的方法。'
- en: Often, a base class cannot correctly implement an abstract method
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个基类不能正确实现抽象方法
- en: because it cannot know the detailed data it should operate on, or it may not
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它无法知道它应该操作的详细数据，或者它可能不会
- en: be possible to implement a general algorithm. Instead, all subclasses need
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 可能无法实现一个通用的算法。相反，所有子类都需要
- en: to implement their own version of the abstract method.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 去实现它们自己的抽象方法版本。
- en: In our shapes example, we want the Shape class to be an abstract class
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图形示例中，我们希望 Shape 类是一个抽象类，
- en: so no client code can instantiate a Shape object. Further, our Shape class
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 所以没有客户端代码可以实例化一个 Shape 对象。进一步地，我们的 Shape 类
- en: Inheritance **231**
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **231**
- en: should indicate that all its subclasses need to implement the clickedInside(),
    getArea(), and draw() methods.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指示所有其子类需要实现 clickedInside()、getArea() 和 draw() 方法。
- en: Python does not have a keyword to designate a class or method as
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有关键字来标识类或方法为
- en: abstract. However, the Python Standard Library contains the abc mod-
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的。然而，Python 标准库包含 abc 模块
- en: ule, short for *abstract base class*, which is designed to help developers build
    abstract base classes and methods.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 模块，简称 *abstract base class*，旨在帮助开发者构建抽象基类和方法。
- en: Let’s take a look at what we need to do to build an abstract class with
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为了构建一个抽象类我们需要做什么
- en: abstract methods. To begin, we need to import two things from the abc
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法。首先，我们需要从 abc 模块中导入两件事
- en: 'module:'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 模块：
- en: from abc import ABC, abstractmethod
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: from abc import ABC, abstractmethod
- en: Next, we need to indicate that the class we want to act as an abstract
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指明我们希望作为抽象类使用的类
- en: base class should inherit from the ABC class, which we do by putting ABC
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 基类应该继承自 ABC 类，我们通过在类中添加 ABC 来实现
- en: 'inside parentheses after the class name:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 在类名后面的括号中：
- en: 'class *<classWeWantToDesignateAsAbstract>* (ABC):'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 类 *<classWeWantToDesignateAsAbstract>* (ABC)：
- en: We then must use the special decorator @abstractmethod before any meth-
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须在任何方法之前使用特殊的装饰器 @abstractmethod
- en: 'ods that must be overwritten by all subclasses:'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 方法必须由所有子类重写的标识符：
- en: '@abstractmethod'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '@abstractmethod'
- en: 'def *<someMethodThatMustBeOverwritten>* (self, ...):'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 'def *<someMethodThatMustBeOverwritten>* (self, ...):'
- en: Listing 10-10 shows how we can mark our Shape class as an abstract base
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-10 显示了我们如何将 Shape 类标记为抽象基类
- en: class and indicate its abstract methods.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 类并指明其抽象方法。
- en: '**File: InheritedShapes/Shape.py**'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/Shape.py**'
- en: Shape class
  id: totrans-1621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shape 类
- en: '#'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: To be used as a base class for other classes
  id: totrans-1623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用作其他类的基类
- en: import random
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: from abc import ABC, abstractmethod
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: from abc import ABC, abstractmethod
- en: Set up the colors
  id: totrans-1626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: RED = (255, 0, 0)
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: RED = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = (0, 255, 0)
- en: BLUE = (0, 0, 255)
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: BLUE = (0, 0, 255)
- en: '1 class Shape(ABC): # identifies this as an abstract base class'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: '1 class Shape(ABC): # 将此类标识为抽象基类'
- en: '2 def __init__(self, window, shapeType, maxWidth, maxHeight):'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def __init__(self, window, shapeType, maxWidth, maxHeight):'
- en: self.window = window
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.shapeType = shapeType
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: self.shapeType = shapeType
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(1, maxWidth - 100)
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(25, maxHeight - 100)
- en: '3 def getType(self):'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def getType(self):'
- en: return self.shapeType
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: return self.shapeType
- en: '**232** Chapter 10'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '**232** 第 10 章'
- en: 4 @abstractmethod
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 4 @abstractmethod
- en: 'def clickedInside(self, mousePoint):'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 'def clickedInside(self, mousePoint):'
- en: raise NotImplementedError
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 NotImplementedError
- en: 5 @abstractmethod
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 5 @abstractmethod
- en: 'def getArea(self):'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getArea(self):'
- en: raise NotImplementedError
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 NotImplementedError
- en: 6 @abstractmethod
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 6 @abstractmethod
- en: 'def draw(self):'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: raise NotImplementedError
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 NotImplementedError
- en: '*Listing 10-10: The Shape base class that inherits from ABC with abstract methods*
    The Shape class inherits from the ABC class 1, telling Python to prevent'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-10: 继承自 ABC 并具有抽象方法的 Shape 基类* Shape 类继承自 ABC 类 1，告诉 Python 防止'
- en: client code from instantiating a Shape object directly. Any attempt to do so
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 防止客户端代码直接实例化 Shape 对象。任何尝试这样做的操作
- en: 'results in the following error message:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 会导致以下错误信息：
- en: 'TypeError: Can''t instantiate abstract class Shape with abstract methods'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 无法实例化包含抽象方法的抽象类 Shape'
- en: clickedInside, draw, getArea
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: clickedInside, draw, getArea
- en: The __init__() 2 and getType() 3 methods contain code that will be
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 2 和 getType() 3 方法包含的代码将在
- en: shared by all subclasses of Shape.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Shape 子类共享的部分。
- en: The clickedInside() 4, getArea() 5, and draw() 6 methods are all pre-
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: clickedInside() 4、getArea() 5 和 draw() 6 方法都是预设
- en: ceded by the @abstractmethod decorator. This decorator indicates that these
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 由 @abstractmethod 装饰器标记。该装饰器表示这些
- en: methods *must* be overwritten by all subclasses of Shape. Since these methods
    in this abstract class will never run, the implementation here consists only
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 *必须* 被所有 Shape 子类重写。由于这些方法在这个抽象类中永远不会执行，因此此处的实现仅由
- en: of raise NotImplementedError to further emphasize that the method doesn’t
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引发 NotImplementedError 来进一步强调方法不
- en: do anything.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 做任何事情。
- en: Let’s extend the shape demonstration program to add a new Rectangle
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展形状演示程序，添加一个新的矩形
- en: class, as shown in Listing 10-11\. The Rectangle class inherits from the
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 类，如 Listing 10-11 所示。矩形类继承自该
- en: abstract Shape class and therefore must implement the clickedInside(),
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象 Shape 类，因此必须实现 clickedInside()、
- en: getArea(), and draw() methods. I’ll make an intentional error in this subclass
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: getArea() 和 draw() 方法。我将在这个子类中故意犯一个错误
- en: to show what happens.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 展示发生的情况。
- en: '**File: InheritedShapes/Rectangle.py**'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/Rectangle.py**'
- en: Rectangle class
  id: totrans-1667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形类
- en: import pygame
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from Shape import *
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: from Shape import *
- en: 'class Rectangle(Shape):'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Rectangle(Shape):'
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight):'
- en: super().__init__(window, 'Rectangle', maxWidth, maxHeight)
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, 'Rectangle', maxWidth, maxHeight)
- en: self.width = random.randrange(10, 100)
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = random.randrange(10, 100)
- en: self.height = random.randrange(10, 100)
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = random.randrange(10, 100)
- en: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
- en: 'def clickedInside(self, mousePoint):'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 'def clickedInside(self, mousePoint):'
- en: Inheritance **233**
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **233**
- en: clicked = self.rect.collidepoint(mousePoint)
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: clicked = self.rect.collidepoint(mousePoint)
- en: return clicked
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: return clicked
- en: 'def getArea(self):'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getArea(self):'
- en: theArea = self.width * self.height
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = self.width * self.height
- en: return theArea
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: return theArea
- en: '*Listing 10-11: The Rectangle class that implements clickedInside() and getArea(),
    but not draw()* As a demonstration, this class mistakenly does not contain a draw()'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 10-11：实现 clickedInside() 和 getArea()，但没有 draw() 的矩形类* 作为演示，这个类错误地没有包含
    draw()'
- en: method. Listing 10-12 shows a modified version of the main code that
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。代码清单 10-12 显示了主代码的修改版本，
- en: includes the creation of Rectangle objects.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了矩形对象的创建。
- en: '**File: InheritedShapes/Main_ShapesWithRectangle.py**'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InheritedShapes/Main_ShapesWithRectangle.py**'
- en: shapesList = []
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: shapesList = []
- en: shapeClassesTuple = ('Square', 'Circle', 'Triangle', 'Rectangle')
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: shapeClassesTuple = ('Square', 'Circle', 'Triangle', 'Rectangle')
- en: 'for i in range(0, N_SHAPES):'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, N_SHAPES):'
- en: randomlyChosenClass = random.choice(shapeClassesTuple)
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: randomlyChosenClass = random.choice(shapeClassesTuple)
- en: oShape = randomlyChosenClass(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: oShape = randomlyChosenClass(window, WINDOW_WIDTH, WINDOW_HEIGHT)
- en: shapesList.append(oShape)
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: shapesList.append(oShape)
- en: '*Listing 10-12: The main code that randomly creates Squares, Circles, Triangles,
    and* *Rectangles*'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 10-12：主代码，它随机创建正方形、圆形、三角形和* *矩形*'
- en: When this code attempts to create a Rectangle object, Python generates
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码尝试创建一个矩形对象时，Python 会生成
- en: 'this error message:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息：
- en: 'TypeError: Can''t instantiate abstract class Rectangle with abstract method'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 无法实例化抽象类 Rectangle，缺少抽象方法'
- en: draw
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: draw
- en: This tells us that we cannot instantiate a Rectangle object because we did
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们不能实例化一个矩形对象，因为我们没有
- en: not write a draw() method in our Rectangle class. Adding a draw() method to
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在矩形类中没有写 draw() 方法。向其中添加 draw() 方法
- en: the Rectangle class (with appropriate code to draw the rectangle) fixes the
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形类（包含适当的代码来绘制矩形）修复了
- en: error.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 错误。
- en: '**How pygwidgets Uses Inheritance**'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '**pygwidgets 如何使用继承**'
- en: The pygwidgets module uses inheritance to share common code. For exam-
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 模块使用继承来共享公共代码。例如，
- en: ple, consider the two button classes we discussed in [Chapter 7:](index_split_003.html#p172)
    TextButton and CustomButton. The TextButton class requires a string to be used
    as a label
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在[第 7 章：](index_split_003.html#p172)中讨论的两个按钮类：TextButton 和 CustomButton。TextButton
    类需要一个字符串作为标签
- en: on the button, while the CustomButton class requires you to supply your own
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮上，而 CustomButton 类则要求你提供自己的
- en: art. The way that you create an instance of each of these classes is dif-
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术。你创建这些类实例的方式是不同的——
- en: ferent—you need to specify a different set of arguments. However, once
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 不同——你需要指定一组不同的参数。然而，一旦
- en: created, all the remaining methods of both objects are exactly the same.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，两个对象的其余方法完全相同。
- en: That’s because the two classes inherit from a common base class, named
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 那是因为这两个类都继承自一个共同的基类，名为
- en: PygWidgetsButton (Figure 10-7).
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: PygWidgetsButton（图 10-7）。
- en: PygWidgetsButton is an abstract class. Client code is not supposed to
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: PygWidgetsButton 是一个抽象类。客户端代码不应
- en: create an instance of it, and attempting to do so will generate an error
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 创建它的实例，并尝试这样做会生成一个错误
- en: message.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 信息。
- en: '**234** Chapter 10'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '**234** 第 10 章'
- en: '![Image 29](index-264_1.png)'
  id: totrans-1715
  prefs: []
  type: TYPE_IMG
  zh: '![图片 29](index-264_1.png)'
- en: (Abstract base class)
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: （抽象基类）
- en: PygWidgetsButton
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: PygWidgetsButton
- en: Inherits from
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: TextButton
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: TextButton
- en: CustomButton
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton
- en: '*Figure 10-7: The pygwidgets TextButton and CustomButton*'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：pygwidgets TextButton 和 CustomButton*'
- en: '*classes both inherit from PygWidgetsButton.*'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '*这两个类都继承自 PygWidgetsButton。*'
- en: Instead, PygWidgetsButton is subclassed by the TextButton and CustomButton
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，PygWidgetsButton 被 TextButton 和 CustomButton 类继承。
- en: classes. Those classes each provide the single method, __init__(), which
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类每个都提供了一个方法，__init__()，它
- en: will do whatever is needed to initialize their type of button. Each will then
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行初始化按钮类型所需的任何操作。每个类随后将
- en: pass on identical arguments to the __init__() method of the base class,
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的参数传递给基类的 __init__() 方法，
- en: PygWidgetsButton.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: PygWidgetsButton。
- en: The TextButton class is used to build a text-based button with minimal
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: TextButton 类用于构建一个基于文本的按钮，功能最简
- en: art. This is helpful when trying to get programs up and running quickly.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术资源。这在快速启动程序时非常有帮助。
- en: 'Here is the interface for creating a TextButton object:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建 TextButton 对象的接口：
- en: def __init__(self, window, loc, text, width=None, height=40,
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, window, loc, text, width=None, height=40,
- en: textColor=PYGWIDGETS_BLACK,
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=PYGWIDGETS_BLACK,
- en: upColor= PYGWIDGETS_NORMAL_GRAY,
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: upColor= PYGWIDGETS_NORMAL_GRAY,
- en: overColor= PYGWIDGETS_OVER_GRAY,
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: overColor= PYGWIDGETS_OVER_GRAY,
- en: downColor=PYGWIDGETS_DOWN_GRAY,
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: downColor=PYGWIDGETS_DOWN_GRAY,
- en: fontName=None, fontSize=20, soundOnClick=None,
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: fontName=None, fontSize=20, soundOnClick=None,
- en: enterToActivate=False, callBack=None, nickname=None)
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: enterToActivate=False, callBack=None, nickname=None)
- en: While many of the parameters default to reasonable values, the caller
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多参数默认为合理值，调用者
- en: must provide a value for text, which will appear on the button. The __init__()
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提供 text 的值，该值将出现在按钮上。__init__()
- en: method itself creates “surfaces” (images) for the button that are used in dis-
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 方法本身创建按钮的“表面”（图像），这些图像用于显示
- en: playing a standard button. The code to create a typical TextButton object looks
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 显示标准按钮的方式。创建一个典型 TextButton 对象的代码如下
- en: 'like this:'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')
- en: When drawn, the user sees a button that looks like Figure 10-8\.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制时，用户看到的按钮外观如图 10-8 所示。
- en: '*Figure 10-8: An example of a*'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：一个示例的*'
- en: '*typical TextButton*'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '*典型的 TextButton*'
- en: The CustomButton class is used to build a button using artwork the client
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton 类用于使用客户提供的图像构建按钮
- en: 'supplies. Here is the interface for creating a CustomButton:'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 提供。以下是创建 CustomButton 的接口：
- en: def __init__(self, window, loc, up, down=None, over=None,
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, window, loc, up, down=None, over=None,
- en: disabled=None, soundOnClick=None,
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: disabled=None, soundOnClick=None,
- en: 'nickname=None, enterToActivate=False):'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 'nickname=None, enterToActivate=False):'
- en: Inheritance **235**
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **235**
- en: The key difference is that this version of the __init__() method requires the
    caller to supply a value for the up parameter (remember, a button has
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的区别是，这个版本的 __init__() 方法要求调用者提供 up 参数的值（记住，一个按钮有
- en: 'four images: up, down, disabled, and over). You can optionally also sup-'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 四张图片：up、down、disabled 和 over）。你也可以选择提供
- en: ply down, over, and disabled images. For any image that is not supplied,
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 下、上、over 和 disabled 图像。如果没有提供某个图像，
- en: CustomButton makes a copy of the up image of the button and uses that.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton 会复制按钮的 up 图像并使用它。
- en: The last line of the __init__() methods for *both* the TextButton and
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法的最后一行对于 *TextButton 和
- en: CustomButton classes is a call to the __init__() method of the common base
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton 类的初始化是对公共基类 __init__() 方法的调用
- en: class, PygWidgetsButton. Both calls pass in four images for the button, along
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 类，PygWidgetsButton。两个调用都传递了四张按钮图像，以及
- en: 'with other arguments:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他参数一起：
- en: super().__init__(window, loc, surfaceUp, surfaceOver,
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, loc, surfaceUp, surfaceOver,
- en: surfaceDown, surfaceDisabled, buttonRect,
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: surfaceDown, surfaceDisabled, buttonRect,
- en: soundOnClick, nickname, enterToActivate, callBack)
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: soundOnClick, nickname, enterToActivate, callBack)
- en: From the client’s point of view, you see two completely different classes
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户的角度来看，你会看到两个完全不同的类
- en: with many methods (most of which are identical). But from the implement-
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 具有许多方法（其中大多数是相同的）。但从实现的角度来看，
- en: er’s point of view, you can now see how inheritance allowed us to override
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，你可以看到继承如何允许我们重写
- en: the single __init__() method in the base class to provide client program-
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 基类中的单一 __init__() 方法用于提供客户端程序
- en: mers with two similar, but very useful, ways of creating buttons. The two
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端有两种相似但非常有用的按钮创建方式。这两种
- en: classes share everything other than the __init__() method. Therefore,
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 类别除了 __init__() 方法外，其他一切都相同。因此，
- en: the way that the buttons function, and the method calls that are available
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的功能方式，以及可用的方法调用
- en: ( handleEvent(), draw(), disable(), enable(), and so on), must be identical.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: （handleEvent()、draw()、disable()、enable() 等）必须完全相同。
- en: There are a number of benefits to this kind of inheritance. First, it pro-
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 这种继承方式有许多好处。首先，它提供了
- en: 'vides consistency for both the client code and the end user: TextButton and'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一致性，既适用于客户端代码，也适用于最终用户：TextButton 和
- en: CustomButton objects work the same way. It also makes bugs easier to fix—
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton 对象工作原理相同。它还使得修复错误更加容易—
- en: fixing a bug in a base class means you have then fixed the bug in all sub-
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中修复错误意味着你已经修复了所有子类中的错误—
- en: classes that inherit from it. Finally, if you add functionality in the base
    class,
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 继承它的类。最后，如果你在基类中添加功能，
- en: it is available immediately in all classes that inherit from the base class.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 它会立即在所有继承自基类的类中可用。
- en: '**Class Hierarchy**'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '**类层次结构**'
- en: Any class can be used as a base class, even a subclass that already inherits
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类都可以作为基类，即使是已经继承自其他类的子类。
- en: from another base class. This kind of relationship, known as a *class hierarchy*,
    is depicted in Figure 10-9\.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 来自另一个基类。这种关系被称为 *类层次结构*，如图 10-9 所示。
- en: Class A
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 类 A
- en: Inherits from
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: Class B
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 类 B
- en: Inherits from
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: Class C
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 类 C
- en: '*Figure 10-9: A class hierarchy*'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：类层次结构*'
- en: '**236** Chapter 10'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: '**236** 第 10 章'
- en: In this figure, class C inherits from class B, which inherits from class A.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，类 C 继承自类 B，类 B 继承自类 A。
- en: Therefore, class C is a subclass and class B is a base class, but class B is
    also a subclass of class A. So, class B serves in both roles. In cases like this,
    class C
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类 C 是一个子类，类 B 是基类，但类 B 也是类 A 的子类。所以，类 B 扮演着两种角色。在这种情况下，类 C
- en: inherits not only all the methods and instance variables in class B, but also
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 继承了类 B 中所有方法和实例变量的类，不仅如此，
- en: all the methods and instance variables in class A. This type of hierarchy can
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 类 A 中的所有方法和实例变量。这种类型的层次结构可以
- en: be very useful when building more and more specific classes. Class A can be
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建越来越具体的类时非常有用。类 A 可以是
- en: very general, class B more detailed, and class C even more specific.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 类 B 很一般，类 C 更详细，类 C 更具体。
- en: Figure 10-10 provides a different way to think about the relationships in
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-10 提供了一个不同的视角来思考类之间的关系
- en: a class hierarchy.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类层次结构。
- en: Class A
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 类 A
- en: Class B
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 类 B
- en: Class C
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 类 C
- en: '*Figure 10-10: A different way of*'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：一种不同的*'
- en: '*portraying a class hierarchy*'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: '*描绘类层次结构*'
- en: Here, the client sees only class C, but this class is made up of all the
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户端只看到类 C，但这个类由所有
- en: methods and instance variables defined collectively in classes C, B, and A.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 C、B 和 A 中定义的所有方法和实例变量。
- en: The pygwidgets package uses a class hierarchy for all widgets. The first
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包使用类层次结构来组织所有小部件。首先
- en: class in pygwidgets is the abstract class PygWidget, which supplies basic func-
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 中的类是抽象类 PygWidget，它提供了基本的功能，
- en: tionality to all widgets in the package. Its code consists of methods that
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 它的功能会对所有小部件提供支持。它的代码包含可以
- en: allow for showing and hiding, enabling and disabling, getting and setting
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 允许显示和隐藏，启用和禁用，获取和设置
- en: the location, and getting the nickname (internal name) of any widget.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 获取位置，获取任何小部件的昵称（内部名称）。
- en: There are other classes in pygwidgets that are used as abstract classes,
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 中还有其他作为抽象类使用的类，
- en: including the aforementioned PygWidgetsButton, which is the base class of
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 包括上述的 PygWidgetsButton，它是
- en: both TextButton and CustomButton. Figure 10-11 should help make this rela-
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 同时适用于 TextButton 和 CustomButton。图 10-11 应该有助于让这段关系变得
- en: tionship clear.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 关系明确。
- en: PygWidget
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: PygWidget
- en: Inherits from
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: PygWidgetsButton
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: PygWidgetsButton
- en: Inherits from
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自
- en: TextButton
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: TextButton
- en: CustomButton
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton
- en: '*Figure 10-11: Class hierarchy in pygwidgets*'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：pygwidgets 中的类层次结构*'
- en: Inheritance **237**
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **237**
- en: As you can see, the PygWidgetsButton class is both a subclass of PygWidget and
    a base class for TextButton and CustomButton.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，PygWidgetsButton 类既是 PygWidget 的子类，又是 TextButton 和 CustomButton 的基类。
- en: '**The Difficulty of Programming with Inheritance**'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用继承编程的难度**'
- en: When developing using inheritance, it can be difficult to understand what
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承时，理解如何与继承类交互可能会很困难，
- en: 'to put where. You’re constantly asking yourself questions like: Should this'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 要放在哪里？你会不断问自己：这个应该放在什么地方？应该在哪里？
- en: instance variable be in the base class? Is there enough common code in sub-
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量应该放在哪个基类中？子类中有足够的公共代码吗？
- en: classes to create a method in the base class? What are appropriate param-
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中创建方法时，应该使用哪些适当的参数？
- en: eters for a method in a subclass? What are appropriate parameters and
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 子类方法中应使用哪些适当的参数？
- en: defaults to be used in a base class that expects to be overridden or called
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值应在基类中使用，期望被重写或调用
- en: from a subclass?
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 来自子类？
- en: Attempting to understand the interactions among all the variables and
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试理解所有变量和方法之间的交互会非常复杂，
- en: methods in a hierarchy of classes can be an extremely difficult, tricky, and
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 在类层次结构中调用方法和使用实例变量可能是一个非常困难、棘手且
- en: frustrating task. This is especially true when reading the code of a class
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 挫败的任务。这在阅读类的代码时尤其如此
- en: hierarchy developed by another programmer. To fully understand what’s
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 由另一个程序员开发的层次结构。要完全理解它的
- en: going on, you often have to become familiar with the code in the base
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 发生什么，你通常需要熟悉基类中的代码
- en: classes all the way up the hierarchy.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 类一直向上层次结构。
- en: For example, imagine a hierarchy in which class D is a subclass of C,
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设想一个层次结构，其中类D是类C的子类，
- en: which is a subclass of B, which is a subclass of the base class A. In class
    D, you
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 它是B的子类，B是A的子类。在类D中，你
- en: may encounter code that branches based on the value of an instance vari-
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到根据实例变量值分支的代码，
- en: able, but that variable might never be set in the code of class D. In cases
    like
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 变得可能，但该变量可能从未在类D的代码中设置过。像这样的情况
- en: this, you must look for the instance variable in the code of class C. If it
    is not
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你必须查看类C代码中的实例变量。如果没有
- en: found there, then you must look in the code of class B, and so on.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在类B的代码中没有找到该实例变量，你必须继续查看类B中的代码，依此类推。
- en: When designing a class hierarchy, perhaps the best way to avoid this
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类层次结构时，也许避免这种
- en: problem is to only call methods and use instance variables inherited from
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是只调用继承自
- en: one layer up in the hierarchy. In our example, code in class D should only
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中的上一级代码。在我们的例子中，类D中的代码应该只
- en: make calls to methods in class C, while class C should only make calls to
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 调用类C中的方法，而类C只应调用
- en: methods in class B, and so on. This is a simplistic version of the *Law of*
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 在类B中的方法等等。这是*法则*的简化版本。
- en: '*Demeter*. Stated simply, you (meaning objects) should only talk to your'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: '*德墨忒尔*。简单来说，你（指对象）应该只和你的'
- en: immediate friends (nearby objects) and never talk to strangers (distant
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 直接的朋友（附近的对象）永远不要和陌生人（远离的对象）交谈。
- en: objects). A detailed discussion is beyond the scope of this book, but there
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 对象）。详细讨论超出了本书的范围，但这里
- en: are many references available on the internet.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有很多相关的参考资料。
- en: Another approach, which we first talked about i[n Chapter 4, i](index_split_001.html#p86)s
    to take advantage of *composition*, where an object instantiates one or more other
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，我们在[第4章](index_split_001.html#p86)首次讨论过， 是利用*组合*，其中一个对象实例化一个或多个其他
- en: objects. The key difference is that inheritance is used to model an “is a”
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。关键区别在于继承用来建模“是一个”的关系，
- en: relationship, whereas composition uses a “has a” relationship. For example,
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 关系，而组合使用“拥有一个”关系。例如，
- en: if we wanted to have a spinbox widget (an editable text number field with
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个旋转框小部件（一个可编辑的文本数字字段，
- en: an up and a down arrow), we could build a SpinBox class that instantiates
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 向上和向下箭头），我们可以构建一个SpinBox类，实例化
- en: a DisplayNumber object and two CustomButton objects for the arrows. Each of
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 一个DisplayNumber对象和两个CustomButton对象作为箭头。每个
- en: these objects already knows how to handle its user interactions.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象已经知道如何处理其用户交互。
- en: '**238** Chapter 10'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: '**238** 第10章'
- en: '**MULTIPLE INHERITANCE**'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重继承**'
- en: You’ve seen how a class can inherit from another class . In fact, Python (like
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到一个类如何继承另一个类。事实上，Python（像
- en: some other programming languages) al ows a class to inherit from more than
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些编程语言）允许一个类继承多个
- en: 'just one class . This is known as *multiple inheritance* . The Python syntax
    is for inheriting from more than one class is quite straightforward:'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个类。这被称为*多重继承*。Python的语法对于继承多个类是相当直接的：
- en: 'class *SomeClass*( *<BaseClass1>* , *<BaseClass2>* , ...): However, it’s important
    to be aware that multiple inheritance can potential y introduce conflicts when
    the base classes you inherit from contain iden-'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 类 *SomeClass*( *<BaseClass1>* , *<BaseClass2>* , ...)：然而，需要注意的是，当你继承的基类包含相同
- en: tical y named methods and/or instance variables . Python does have rules
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎同名的方法和/或实例变量。Python确实有规则
- en: (known as the *method resolution order*, or *MRO*) to resolve these potential
    problems . I consider this an advanced topic and will not cover it here, but if
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: （称为*方法解析顺序*，或*MRO*）用来解决这些潜在问题。我认为这是一个高级话题，这里不做详细讨论，但如果
- en: you want to look into it, a detailed discussion can be found a[t *ht ps://www*](https://www.python.org/download/releases/2.3/mro)
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解，详细讨论可以在[ *ht ps://www*](https://www.python.org/download/releases/2.3/mro)找到
- en: '[*.python.org/download/releases/2.3/mro.*](https://www.python.org/download/releases/2.3/mro)'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '[*.python.org/download/releases/2.3/mro.*](https://www.python.org/download/releases/2.3/mro)'
- en: '**Summary**'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'This was a very ambitious chapter on the topic of inheritance: the art of'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于继承主题的一章，非常有雄心：继承的艺术
- en: “programming by difference.” The basic idea of inheritance is to build a
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: “通过差异编程。”继承的基本思想是构建一个
- en: class (a subclass) that incorporates all the methods and instance variables
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 类（一个子类）包含所有方法和实例变量
- en: of another class (a base class), thereby allowing you to reuse existing code.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类（基类）的类，从而允许你重用现有代码。
- en: Your new subclass can choose to use or override the methods of the base
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新子类可以选择使用或重写基类的方法
- en: class, as well as define its own methods. A method in a subclass can find the
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 类，并定义自己的方法。子类中的方法可以找到
- en: base class by using a call to super().
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 super() 来使用基类。
- en: We built two classes, InputNumber and DisplayMoney that provide highly
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了两个类，InputNumber 和 DisplayMoney，它们提供了高度
- en: reusable functionality. These classes are implemented as subclasses that use
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用的功能。这些类作为子类实现，使用
- en: classes in the pygwidgets package as base classes.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pygwidgets 包中，TextButton 和 CustomButton 类作为基类。
- en: Any client code that uses your subclass will see an interface that incor-
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用你的子类的客户端代码将看到一个结合了
- en: porates methods defined in both the subclass and the base class. Any num-
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 结合了子类和基类中定义的方法。任何数量的
- en: ber of subclasses can be built using the same base class. An abstract class
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相同的基类构建多个子类。一个抽象类
- en: is one that is not intended to be instantiated by client code, but rather is
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 是一种不打算由客户端代码实例化的类，而是
- en: intended only to be inherited from by subclasses. An abstract method in a
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供子类继承使用。抽象方法在一个
- en: base class is one that *must* be overridden in each subclass.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 基类是必须在每个子类中重写的。
- en: We worked through a number of examples to demonstrate inheritance
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过许多示例演示了继承的概念
- en: in the pygwidgets package, including how the TextButton and CustomButton
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pygwidgets 包中，包括如何使用 TextButton 和 CustomButton
- en: classes both inherit from a common base class, PygWidgetsButton.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 类都继承自一个共同的基类，PygWidgetsButton。
- en: I showed how you can build a class hierarchy, where a class inherits
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示了如何构建一个类层次结构，其中一个类继承
- en: from another class, which in turn inherits from a third class, and so on.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个类继承，而这个类又继承自第三个类，依此类推。
- en: Inheritance can be complex—reading someone else’s code can be
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可能很复杂——阅读别人写的代码可能会
- en: confusing—but as we’ve seen, inheritance can be extremely powerful.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人感到困惑——但正如我们所见，继承实际上可以非常强大。
- en: Inheritance **239**
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 **239**
- en: '**11**'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**M A N A G I N G M E M O R Y**'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存管理**'
- en: '**U S E D B Y O B J E C T S**'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: '**被对象使用**'
- en: This chapter will explain a few important
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释一些重要的
