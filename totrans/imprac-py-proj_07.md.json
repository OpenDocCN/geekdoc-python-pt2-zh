["```py\n➊ import time\n   import random\n   import statistics\n\n➋ # CONSTANTS (weights in grams)\n➌ GOAL = 50000\n   NUM_RATS = 20\n   INITIAL_MIN_WT = 200\n   INITIAL_MAX_WT = 600\n   INITIAL_MODE_WT = 300\n   MUTATE_ODDS = 0.01\n   MUTATE_MIN = 0.5\n   MUTATE_MAX = 1.2\n   LITTER_SIZE = 8\n   LITTERS_PER_YEAR = 10\n   GENERATION_LIMIT = 500\n\n   # ensure even-number of rats for breeding pairs:\n➍ if NUM_RATS % 2 != 0:\n       NUM_RATS += 1\n```", "```py\n➊ def populate(num_rats, min_wt, max_wt, mode_wt):\n       \"\"\"Initialize a population with a triangular distribution of weights.\"\"\"\n    ➋ return [int(random.triangular(min_wt, max_wt, mode_wt))\\\n               for i in range(num_rats)]\n```", "```py\n➊ def fitness(population, goal):\n       \"\"\"Measure population fitness based on an attribute mean vs target.\"\"\"\n       ave = statistics.mean(population)\n       return ave / goal\n\n➋ def select(population, to_retain):\n       \"\"\"Cull a population to retain only a specified number of members.\"\"\"\n    ➌ sorted_population = sorted(population)\n    ➍ to_retain_by_sex = to_retain//2\n    ➎ members_per_sex = len(sorted_population)//2\n    ➏ females = sorted_population[:members_per_sex]\n       males = sorted_population[members_per_sex:]\n    ➐ selected_females = females[-to_retain_by_sex:]\n       selected_males = males[-to_retain_by_sex:]\n    ➑ return selected_males, selected_females\n```", "```py\n➊ def breed(males, females, litter_size):\n       \"\"\"Crossover genes among members (weights) of a population.\"\"\"\n    ➋ random.shuffle(males)\n       random.shuffle(females)\n    ➌ children = []\n    ➍ for male, female in zip(males, females):\n        ➎ for child in range(litter_size):\n            ➏ child = random.randint(female, male)\n            ➐ children.append(child)\n    ➑ return children\n```", "```py\n➊ def mutate(children, mutate_odds, mutate_min, mutate_max):\n       \"\"\"Randomly alter rat weights using input odds & fractional changes.\"\"\"\n    ➋ for index, rat in enumerate(children):\n           if mutate_odds >= random.random():\n            ➌ children[index] = round(rat * random.uniform(mutate_min,\n                                                            mutate_max))\n       return children\n```", "```py\ndef main():\n    \"\"\"Initialize population, select, breed, and mutate, display results.\"\"\"\n ➊ generations = 0\n\n ➋ parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,\n                       INITIAL_MODE_WT)\n    print(\"initial population weights = {}\".format(parents))\n    popl_fitness = fitness(parents, GOAL)\n    print(\"initial population fitness = {}\".format(popl_fitness))\n    print(\"number to retain = {}\".format(NUM_RATS))\n\n ➌ ave_wt = []\n\n ➍ while popl_fitness < 1 and generations < GENERATION_LIMIT:\n        selected_males, selected_females = select(parents, NUM_RATS)\n        children = breed(selected_males, selected_females, LITTER_SIZE)\n        children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)\n     ➎ parents = selected_males + selected_females + children\n        popl_fitness = fitness(parents, GOAL)\n     ➏ print(\"Generation {} fitness = {:.4f}\".format(generations,\n                                                      popl_fitness))\n     ➐ ave_wt.append(int(statistics.mean(parents)))\n        generations += 1\n ➑ print(\"average weight per generation = {}\".format(ave_wt))\n    print(\"\\nnumber of generations = {}\".format(generations))\n    print(\"number of years = {}\".format(int(generations / LITTERS_PER_YEAR)))\n```", "```py\nif __name__ == '__main__':\n    start_time = time.time()\n    main()\n    end_time = time.time()\n    duration = end_time - start_time\n    print(\"\\nRuntime for this program was {} seconds.\".format(duration))\n```", "```py\n>>> from itertools import product\n>>> combo = (1, 2)\n>>> for perm in product(combo, repeat=2):\n    print(perm)\n(1, 1)\n(1, 2)\n(2, 1)\n(2, 2)\n```", "```py\n➊ import time\n   from itertools import product\n\n   start_time = time.time()\n\n➋ combo = (9, 9, 7, 6, 5, 4, 3)\n\n   # use Cartesian product to generate permutations with repetition\n➌ for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):\n    ➍ if perm == combo:\n           print(\"Cracked! {} {}\".format(combo, perm))\n\n   end_time = time.time()\n➎ print(\"\\nRuntime for this program was {} seconds.\".format\n         (end_time - start_time))\n```", "```py\n➊ import time\n   from random import randint, randrange\n\n➋ def fitness(combo, attempt):\n       \"\"\"Compare items in two lists and count number of matches.\"\"\"\n       grade = 0\n    ➌ for i, j in zip(combo, attempt):\n           if i == j:\n               grade += 1\n       return grade\n```", "```py\ndef main():\n\n    \"\"\"Use hill-climbing algorithm to solve lock combination.\"\"\"\n\n ➊ combination = '6822858902'\n\n    print(\"Combination = {}\".format(combination))\n\n    # convert combination to list:\n\n ➋ combo = [int(i) for i in combination]\n\n    # generate guess & grade fitness:\n\n ➌ best_attempt = [0] * len(combo)\n\n    best_attempt_grade = fitness(combo, best_attempt)\n\n ➍ count = 0\n\n    # evolve guess\n\n ➎ while best_attempt != combo:\n\n        # crossover\n\n     ➏ next_try = best_attempt[:]\n\n        # mutate\n\n        lock_wheel = randrange(0, len(combo))\n\n     ➐ next_try[lock_wheel] = randint(0, 9)\n\n        # grade & select\n\n     ➑ next_try_grade = fitness(combo, next_try)\n\n        if next_try_grade > best_attempt_grade:\n\n            best_attempt = next_try[:]\n\n            best_attempt_grade = next_try_grade\n\n        print(next_try, best_attempt)\n\n        count += 1\n\n    print()\n\n ➒ print(\"Cracked! {}\".format(best_attempt), end=' ')\n\n    print(\"in {} tries!\".format(count))\n\nif __name__ == '__main__':\n\n    start_time = time.time()\n\n    main()\n\n    end_time = time.time()\n\n    duration = end_time - start_time\n\n ➓ print(\"\\nRuntime for this program was {:.5f} seconds.\".format(duration))\n```", "```py\n[6, 8, 6, 2, 0, 5, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]\n[6, 8, 2, 2, 0, 9, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]\n[6, 8, 2, 2, 8, 5, 8, 9, 0, 0] [6, 8, 2, 2, 8, 5, 8, 9, 0, 0]\n[6, 8, 2, 2, 8, 5, 8, 9, 0, 2] [6, 8, 2, 2, 8, 5, 8, 9, 0, 2]\n\nCracked! [6, 8, 2, 2, 8, 5, 8, 9, 0, 2] in 78 tries!\n\nRuntime for this program was 0.69172 seconds.\n```"]