<html><head></head><body>
<p class="calibre1">self.gameOverImage = pygwidgets.Image(self.window, (140, 180), </p>
<p class="calibre1">'images/gameOver.png')</p>
<p class="calibre1">self.titleText = pygwidgets.DisplayText(self.window, </p>
<p class="calibre1">(70, GAME_HEIGHT + 17), </p>
<p class="calibre1">'Score:                                 High Score:', </p>
<p class="calibre1">fontSize=24, textColor=WHITE)</p>
<p class="calibre1">self.scoreText = pygwidgets.DisplayText(self.window, </p>
<p class="calibre1">(80, GAME_HEIGHT + 47), '0', </p>
<p class="calibre1">fontSize=36, textColor=WHITE, </p>
<p class="calibre1">justified='right')</p>
<p class="calibre1">self.highScoreText = pygwidgets.DisplayText(self.window, </p>
<p class="calibre1">(270, GAME_HEIGHT + 47), '', </p>
<p class="calibre1">fontSize=36, textColor=WHITE, </p>
<p class="calibre1">justified='right')</p>
<p class="calibre1">pygame.mixer.music.load('sounds/background.mid')</p>
<p class="calibre1">self.dingSound = pygame.mixer.Sound('sounds/ding.wav')</p>
<p class="calibre1">self.gameOverSound = pygame.mixer.Sound('sounds/gameover.wav')</p>
<p class="calibre1"># Instantiate objects</p>
<p class="calibre1">2 self.oPlayer = Player(self.window)</p>
<p class="calibre1">self.oBaddieMgr = BaddieMgr(self.window)</p>
<p class="calibre1">self.oGoodieMgr = GoodieMgr(self.window)</p>
<p class="calibre1">self.highestHighScore = 0</p>
<p class="calibre1">self.lowestHighScore = 0</p>
<p class="calibre1">self.backgroundMusic = True</p>
<p class="calibre1">self.score = 0</p>
<p class="calibre1">3 self.playingState = STATE_WAITING</p>
<p class="calibre1">4 def getSceneKey(self):</p>
<p class="calibre1">return SCENE_PLAY</p>
<p class="calibre1"> <i class="calibre4">Listing 16-3: The __init__() and getSceneKey() methods of the ScenePlay class </i></p>
<p class="calibre1">When run, the main code of the game instantiates all the scenes. In the </p>
<p class="calibre1">Play scene, the __init__() method creates all the buttons and text display </p>
<p class="calibre1">fields for the bottom of the window 1, then loads the sounds. Very impor-</p>
<p class="calibre1">tantly, we use composition, discussed in Chapters 4 and 10, to create a </p>
<p class="calibre1">Player object (oPlayer), a Baddie manager object (oBaddieMgr), and a Goodie </p>
<p class="calibre1">manager object (oGoodieMgr) 2. The Play scene object creates these manag-</p>
<p class="calibre1">ers and expects them to create and manage all the Baddies and Goodies. </p>
<p class="calibre1">The __init__() method runs when the program starts, but doesn’t actually </p>
<p class="calibre1">start the game. Instead, it implements a state machine (as discussed in </p>
<p class="calibre1"><a href="index_split_006.html#p340">Chapter 15) t</a>hat starts in the waiting state 3. A round of the game starts when the user presses New Game. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">351</b></p>
<p class="calibre1"><a id="p381"/>All scenes must have a getSceneKey() method 4 that returns a string representing the current scene. Listing 16-4 shows the code that retrieves the </p>
<p class="calibre1">scores and resets the game upon request. </p>
<p class="calibre1">1 def enter(self, data):</p>
<p class="calibre1">self.getHiAndLowScores()</p>
<p class="calibre1">2 def getHiAndLowScores(self):</p>
<p class="calibre1"># Ask the High Scores scene for a dict of scores </p>
<p class="calibre1"># that looks like this:</p>
<p class="calibre1">#  {'highest': highestScore, 'lowest': lowestScore}</p>
<p class="calibre1">3 infoDict = self.request(SCENE_HIGH_SCORES, HIGH_SCORES_DATA)</p>
<p class="calibre1">self.highestHighScore = infoDict['highest']</p>
<p class="calibre1">self.highScoreText.setValue(self.highestHighScore)</p>
<p class="calibre1">self.lowestHighScore = infoDict['lowest']</p>
<p class="calibre1">4 def reset(self):  # start a new game</p>
<p class="calibre1">self.score = 0</p>
<p class="calibre1">self.scoreText.setValue(self.score)</p>
<p class="calibre1">self.getHiAndLowScores()</p>
<p class="calibre1"># Tell the managers to reset themselves</p>
<p class="calibre1">5 self.oBaddieMgr.reset()</p>
<p class="calibre1">self.oGoodieMgr.reset()</p>
<p class="calibre1">if self.backgroundMusic:</p>
<p class="calibre1">pygame.mixer.music.play(-1, 0.0)</p>
<p class="calibre1">6 self.startButton.disable()</p>
<p class="calibre1">self.highScoresButton.disable()</p>
<p class="calibre1">self.soundCheckBox.disable()</p>
<p class="calibre1">self.quitButton.disable()</p>
<p class="calibre1">pygame.mouse.set_visible(False)</p>
<p class="calibre1"> <i class="calibre4">Listing 16-4: The enter(), getHiAndLowScores(), and reset() methods of the ScenePlay</i> <i class="calibre4">class</i></p>
<p class="calibre1">When navigating to the Play scene, the scene manager calls enter() 1, </p>
<p class="calibre1">which in turn calls the getHiAndLowScores() method 2. That method issues a </p>
<p class="calibre1">request to the High Scores scene 3 to retrieve the highest and lowest scores </p>
<p class="calibre1">from the high scores table, so we can draw the highest score from that table </p>
<p class="calibre1">in the bar at the bottom of the window. At the end of each game, it com-</p>
<p class="calibre1">pares the game’s score to the lowest top 10 score to see if this game ranks in </p>
<p class="calibre1">the top 10. </p>
<p class="calibre1">When the user clicks the New Game button, the reset() method 4 </p>
<p class="calibre1">is called to reinitialize everything that needs to be reset before starting a </p>
<p class="calibre1">new round of the game. The reset() method tells the Baddie manager and </p>
<p class="calibre1">the Goodie manager to reinitialize themselves by calling their own reset() </p>
<p class="calibre1">methods 5, disables the buttons at the bottom of the screen so they cannot </p>
<p class="calibre1">be pressed during game play 6, and hides the pointer cursor. During play, </p>
<p class="calibre1">the user moves the mouse to control the Player icon in the window. </p>
<p class="calibre1">The code in Listing 16-5 deals with user input. </p>
<p class="calibre1"><b class="calibre3">352</b>   Chapter 16</p>
<p class="calibre1"><a id="p382"/>  1 def handleInputs(self, eventsList, keyPressedList):</p>
<p class="calibre1">2 if self.playingState == STATE_PLAYING:</p>
<p class="calibre1">return  # ignore button events while playing</p>
<p class="calibre1">for event in eventsList:</p>
<p class="calibre1">3 if self.startButton.handleEvent(event):</p>
<p class="calibre1">self.reset()</p>
<p class="calibre1">self.playingState = STATE_PLAYING</p>
<p class="calibre1">4 if self.highScoresButton.handleEvent(event):</p>
<p class="calibre1">self.goToScene(SCENE_HIGH_SCORES)</p>
<p class="calibre1">5 if self.soundCheckBox.handleEvent(event):</p>
<p class="calibre1">self.backgroundMusic = self.soundCheckBox.getValue()</p>
<p class="calibre1">6 if self.quitButton.handleEvent(event):</p>
<p class="calibre1">self.quit()</p>
<p class="calibre1"> <i class="calibre4">Listing 16-5: The handleInputs() method of the ScenePlay class </i></p>
<p class="calibre1">The handleInputs() method 1 is responsible for click events. If the state </p>
<p class="calibre1">machine is in the playing state, the user cannot click the buttons, so we </p>
<p class="calibre1">don’t bother checking for events 2. If the user presses New Game 3, we </p>
<p class="calibre1">call reset() to reinitialize variables and change the state machine to the </p>
<p class="calibre1">playing state. If the user presses Go to High Scores 4, we navigate to the </p>
<p class="calibre1">High Scores scene using the inherited self.goToScene() method. If the user </p>
<p class="calibre1">toggles the Background Music checkbox 5, we call its getValue() method </p>
<p class="calibre1">to retrieve its new setting; the reset() method uses this setting to decide if </p>
<p class="calibre1">background music should be played. If the user presses Quit 6, we call the </p>
<p class="calibre1">inherited self.quit() method from the base class. Listing 16-6 shows the </p>
<p class="calibre1">code for the actual game play. </p>
<p class="calibre1">1 def update(self):</p>
<p class="calibre1">if self.playingState != STATE_PLAYING:</p>
<p class="calibre1">return  # only update when playing</p>
<p class="calibre1"># Move the Player to the mouse position, get back its rect</p>
<p class="calibre1">2 mouseX, mouseY = pygame.mouse.get_pos()</p>
<p class="calibre1">playerRect = self.oPlayer.update(mouseX, mouseY)</p>
<p class="calibre1"># Tell the GoodieMgr to move all Goodies</p>
<p class="calibre1"># Returns the number of Goodies that the Player contacted</p>
<p class="calibre1">3 nGoodiesHit = self.oGoodieMgr.update(playerRect)</p>
<p class="calibre1">if nGoodiesHit &gt; 0:</p>
<p class="calibre1">self.dingSound.play()</p>
<p class="calibre1">self.score = self.score + (nGoodiesHit * POINTS_FOR_GOODIE)</p>
<p class="calibre1"># Tell the BaddieMgr to move all the Baddies</p>
<p class="calibre1"># Returns the number of Baddies that fell off the bottom</p>
<p class="calibre1">4 nBaddiesEvaded = self.oBaddieMgr.update()</p>
<p class="calibre1">self.score = self.score + (nBaddiesEvaded * POINTS_FOR_BADDIE_EVADED)</p>
<p class="calibre1">self.scoreText.setValue(self.score)</p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">353</b></p>
<p class="calibre1"><a id="p383"/>        # Check if the Player has hit any Baddie</p>
<p class="calibre1">5 if self.oBaddieMgr.hasPlayerHitBaddie(playerRect):</p>
<p class="calibre1">pygame.mouse.set_visible(True)</p>
<p class="calibre1">pygame.mixer.music.stop()</p>
<p class="calibre1">self.gameOverSound.play()</p>
<p class="calibre1">self.playingState = STATE_GAME_OVER</p>
<p class="calibre1">6 self.draw()  # force drawing of game over message</p>
<p class="calibre1">7 if self.score &gt; self.lowestHighScore:</p>
<p class="calibre1">scoreAsString = ′Your score: ′ + str(self.score) + ′\n′</p>
<p class="calibre1">if self.score &gt; self.highestHighScore:</p>
<p class="calibre1">dialogText = (scoreString +</p>
<p class="calibre1">'is a new high score, CONGRATULATIONS!')</p>
<p class="calibre1">else:</p>
<p class="calibre1">dialogText = (scoreString + </p>
<p class="calibre1">'gets you on the high scores list.')</p>
<p class="calibre1">result = showCustomYesNoDialog(self.window, dialogText)</p>
<p class="calibre1">if result:  # navigate</p>
<p class="calibre1">self.goToScene(SCENE_HIGH_SCORES, self.score)  </p>
<p class="calibre1">self.startButton.enable()</p>
<p class="calibre1">self.highScoresButton.enable()</p>
<p class="calibre1">self.soundCheckBox.enable()</p>
<p class="calibre1">self.quitButton.enable()</p>
<p class="calibre1"> <i class="calibre4">Listing 16-6: The update() method of the ScenePlay class </i></p>
<p class="calibre1">The scene manager calls the update() method of the ScenePlay class 1 in </p>
<p class="calibre1">every frame. This method handles everything that happens while the game </p>
<p class="calibre1">is being played. First, it tells the Player object to move the Player’s icon to </p>
<p class="calibre1">the position of the mouse. Then it calls the Player’s update() method 2, </p>
<p class="calibre1">which returns the current rectangle of the icon in the window. We use this </p>
<p class="calibre1">to see if the Player’s icon has contacted any Goodies or Baddies. </p>
<p class="calibre1">Next, it calls the Goodie manager’s update() method 3 to move all the </p>
<p class="calibre1">Goodies. This method returns the number of Goodies that the Player has </p>
<p class="calibre1">contacted, which we use to increase the score. </p>
<p class="calibre1">This is followed by a call to the Baddie manager’s update() method 4 </p>
<p class="calibre1">to move all the Baddies. That method returns the number of Baddies that </p>
<p class="calibre1">have fallen off the bottom of the game area. </p>
<p class="calibre1">We then check to see if the Player has contacted any Baddies 5. If so, </p>
<p class="calibre1">the game is over and we display a Game Over graphic. We also make a spe-</p>
<p class="calibre1">cial call to our draw() method 6 because we may put up a dialog for the </p>
<p class="calibre1">user, and the game’s main loop will not draw the Game Over graphic until </p>
<p class="calibre1">the user clicks one of the buttons in the dialog. </p>
<p class="calibre1">Finally, when the game ends, if the current game score is higher than </p>
<p class="calibre1">the tenth-best score 7, we put up a dialog giving the user the option of </p>
<p class="calibre1">recording their score into the high scores list. If the score of the current </p>
<p class="calibre1">game is a new all-time high score, we give a special message in the dialog. </p>
<p class="calibre1">The code in Listing 16-7 draws the game characters. </p>
<p class="calibre1"><b class="calibre3">354</b>   Chapter 16</p>
<p class="calibre1"><a id="p384"/>  1 def draw(self):</p>
<p class="calibre1">self.window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># Tell the managers to draw all the Baddies and Goodies</p>
<p class="calibre1">self.oBaddieMgr.draw()</p>
<p class="calibre1">self.oGoodieMgr.draw()</p>
<p class="calibre1"/>
<p class="calibre1"># Tell the Player to draw itself</p>
<p class="calibre1">self.oPlayer.draw()</p>
<p class="calibre1"/>
<p class="calibre1"># Draw all the info at the bottom of the window</p>
<p class="calibre1">2 self.controlsBackground.draw()</p>
<p class="calibre1">self.titleText.draw()</p>
<p class="calibre1">self.scoreText.draw()</p>
<p class="calibre1">self.highScoreText.draw()</p>
<p class="calibre1">self.soundCheckBox.draw()</p>
<p class="calibre1">self.quitButton.draw()</p>
<p class="calibre1">self.highScoresButton.draw()</p>
<p class="calibre1">self.startButton.draw()</p>
<p class="calibre1">3 if self.playingState == STATE_GAME_OVER:</p>
<p class="calibre1">self.gameOverImage.draw()</p>
<p class="calibre1">4 def leave(self):</p>
<p class="calibre1">pygame.mixer.music.stop()</p>
<p class="calibre1"> <i class="calibre4">Listing 16-7: The draw() and leave() methods of the ScenePlay class </i></p>
<p class="calibre1">The draw() method tells the Player to draw itself and the Goodie and </p>
<p class="calibre1">Baddie managers to draw all the Goodies and Baddies 1. We then draw the </p>
<p class="calibre1">bottom portion of the window 2 with all the buttons and text display fields. </p>
<p class="calibre1">If we are in the game over state 3, we draw the Game Over image. </p>
<p class="calibre1">When the user navigates away from this scene, the scene manager calls </p>
<p class="calibre1">the leave() method 4 and we stop any music. </p>
<p class="calibre1"><b class="calibre3">File: Dodger/Baddies.py</b></p>
<p class="calibre1">The  <i class="calibre4">Baddies.py</i> file contains two classes: Baddie and BaddieMgr. The Play scene creates the single Baddie manager object, which creates and maintains a </p>
<p class="calibre1">list of all Baddies. The Baddie manager instantiates objects from the Baddie </p>
<p class="calibre1">class every few frames, based on a timer. Listing 16-8 contains the code for </p>
<p class="calibre1">the Baddie class. </p>
<p class="calibre1"># Baddie class</p>
<p class="calibre1">--- snip imports ---</p>
<p class="calibre1">class Baddie():</p>
<p class="calibre1">MIN_SIZE = 10</p>
<p class="calibre1">MAX_SIZE = 40</p>
<p class="calibre1">MIN_SPEED = 1</p>
<p class="calibre1">MAX_SPEED = 8</p>
<p class="calibre1"># Load the image only once</p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">355</b></p>
<p class="calibre1"><a id="p385"/>    1 BADDIE_IMAGE = pygame.image.load('images/baddie.png')</p>
<p class="calibre1">def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1"># Create the image object</p>
<p class="calibre1">size = random.randrange(Baddie.MIN_SIZE, Baddie.MAX_SIZE + 1)</p>
<p class="calibre1">self.x = random.randrange(0, WINDOW_WIDTH - size)</p>
<p class="calibre1">self.y = 0 - size  # start above the window</p>
<p class="calibre1">2 self.image = pygwidgets.Image(self.window, (self.x, self.y), </p>
<p class="calibre1">Baddie.BADDIE_IMAGE)</p>
<p class="calibre1"># Scale it</p>
<p class="calibre1">percent = (size * 100) / Baddie.MAX_SIZE</p>
<p class="calibre1">self.image.scale(percent, False)</p>
<p class="calibre1">self.speed = random.randrange(Baddie.MIN_SPEED, </p>
<p class="calibre1">Baddie.MAX_SPEED + 1)</p>
<p class="calibre1">3 def update(self):  # move the Baddie down</p>
<p class="calibre1">self.y = self.y + self.speed</p>
<p class="calibre1">self.image.setLoc((self.x, self.y))</p>
<p class="calibre1">if self.y &gt; GAME_HEIGHT:</p>
<p class="calibre1">return True  # needs to be deleted</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False  # stays in the window</p>
<p class="calibre1">4 def draw(self):</p>
<p class="calibre1">self.image.draw()</p>
<p class="calibre1">5 def collide(self, playerRect):</p>
<p class="calibre1">collidedWithPlayer = self.image.overlaps(playerRect)</p>
<p class="calibre1">return collidedWithPlayer</p>
<p class="calibre1"> <i class="calibre4">Listing 16-8: The Baddie class</i></p>
<p class="calibre1">We load the image of the Baddie as a class variable 1 so the single </p>
<p class="calibre1">image is shared by  <i class="calibre4">all</i> Baddies. </p>
<p class="calibre1">The __init__() method 2 chooses a random size for each new Baddie, </p>
<p class="calibre1">so the user sees differently sized Baddies. It chooses a random x-coordinate </p>
<p class="calibre1">and a y-coordinate that will place the image just above the window. It then </p>
<p class="calibre1">creates an Image object and scales the image down to the selected size 2. </p>
<p class="calibre1">Lastly, it chooses a random speed. </p>
<p class="calibre1">The Baddie manager, the code for which I’ll show in a moment, calls </p>
<p class="calibre1">the update() method 3 in every frame: the code here moves the location of </p>
<p class="calibre1">the Baddie down by the number of pixels that represents its speed. If the </p>
<p class="calibre1">Baddie has moved off the bottom of the game area, we return True to say </p>
<p class="calibre1">this Baddie is ready to be removed. Otherwise, we return False to tell the </p>
<p class="calibre1">Baddie manager to leave this Baddie in the window. </p>
<p class="calibre1">The draw() method 4 draws the Baddie at its new location. </p>
<p class="calibre1">The collide() method 5 checks to see if the Player and the Baddie </p>
<p class="calibre1">intersect. </p>
<p class="calibre1"><b class="calibre3">356</b>   Chapter 16</p>
<p class="calibre1"><a id="p386"/>The BaddieMgr class, shown in Listing 16-9, creates and manages a list of Baddie objects; this is a classic example of an object manager object. </p>
<p class="calibre1"># BaddieMgr class</p>
<p class="calibre1">class BaddieMgr():</p>
<p class="calibre1">ADD_NEW_BADDIE_RATE = 8  # how often to add a new Baddie</p>
<p class="calibre1">1 def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.reset()</p>
<p class="calibre1">2 def reset(self):  # called when starting a new game</p>
<p class="calibre1">self.baddiesList = []</p>
<p class="calibre1">self.nFramesTilNextBaddie = BaddieMgr.ADD_NEW_BADDIE_RATE</p>
<p class="calibre1">3 def update(self):</p>
<p class="calibre1"># Tell each Baddie to update itself</p>
<p class="calibre1"># Count how many Baddies have fallen off the bottom</p>
<p class="calibre1">nBaddiesRemoved = 0</p>
<p class="calibre1">4 baddiesListCopy = self.baddiesList.copy()</p>
<p class="calibre1">for oBaddie in baddiesListCopy:</p>
<p class="calibre1">5 deleteMe = oBaddie.update()</p>
<p class="calibre1">if deleteMe:</p>
<p class="calibre1">self.baddiesList.remove(oBaddie)</p>
<p class="calibre1">nBaddiesRemoved = nBaddiesRemoved + 1</p>
<p class="calibre1"># Check if it's time to add a new Baddie</p>
<p class="calibre1">6 self.nFramesTilNextBaddie = self.nFramesTilNextBaddie - 1</p>
<p class="calibre1">if self.nFramesTilNextBaddie == 0:</p>
<p class="calibre1">oBaddie = Baddie(self.window)</p>
<p class="calibre1">self.baddiesList.append(oBaddie)</p>
<p class="calibre1">self.nFramesTilNextBaddie = BaddieMgr.ADD_NEW_BADDIE_RATE</p>
<p class="calibre1"># Return the count of Baddies that were removed</p>
<p class="calibre1">return nBaddiesRemoved</p>
<p class="calibre1">7 def draw(self):</p>
<p class="calibre1">for oBaddie in self.baddiesList:</p>
<p class="calibre1">oBaddie.draw()</p>
<p class="calibre1">8 def hasPlayerHitBaddie(self, playerRect):</p>
<p class="calibre1">for oBaddie in self.baddiesList:</p>
<p class="calibre1">if oBaddie.collide(playerRect):</p>
<p class="calibre1">return True</p>
<p class="calibre1">return False</p>
<p class="calibre1"> <i class="calibre4">Listing 16-9: The BaddieMgr class</i></p>
<p class="calibre1">The __init__() method calls 1 the BaddieMgr’s own reset() method to </p>
<p class="calibre1">set the list of Baddie objects to the empty list. We use the frame-counting </p>
<p class="calibre1">approach to create a new Baddie relatively often, to keep things interesting. </p>
<p class="calibre1">We use the instance variable self.nFramesTilNextBaddie for counting frames. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">357</b></p>
<p class="calibre1"><a id="p387"/>The reset() method 2 is called when starting a new round of the game. </p>
<p class="calibre1">It clears the list of Baddies and resets the frame counter. </p>
<p class="calibre1">The update() method 3 is where the real management of Baddies hap-</p>
<p class="calibre1">pens. Our intent here is to loop through all the Baddies, telling each one to </p>
<p class="calibre1">update its own position and removing any that have fallen off the bottom of </p>
<p class="calibre1">the window. However, there is a potential bug. If you simply iterate through </p>
<p class="calibre1">a list and remove an element that matches your criteria for deletion, the list </p>
<p class="calibre1">is immediately compacted. When this happens, the element directly follow-</p>
<p class="calibre1">ing the one that was deleted will be skipped; in this loop, that element will </p>
<p class="calibre1">not be told to update itself. Though I didn’t go into detail at the time, we </p>
<p class="calibre1">encountered the same problem i<a href="index_split_004.html#p270">n Chapter 11 i</a>n the Balloon game, where we needed to eliminate balloons that floated off the top of the window. </p>
<p class="calibre1">There I employed a solution using the reversed() function applied to the </p>
<p class="calibre1">list, to iterate in the reverse order (see Listing 11-6). </p>
<p class="calibre1">Here I’ve implemented a more generalized solution 4. The approach </p>
<p class="calibre1">used in the BaddieMgr class is to make a copy of the list and iterate over the </p>
<p class="calibre1"> <i class="calibre4">copied</i> list; then, if we find an element that meets the criteria for deletion (in this case a Baddie that has fallen off the bottom of the window), we </p>
<p class="calibre1">remove that element (that specific Baddie) from the  <i class="calibre4">original</i> list. With this approach, we are iterating over a different list than the one from which we </p>
<p class="calibre1">are removing elements. </p>
<p class="calibre1">As we iterate through the Baddies, the call to the update() method of </p>
<p class="calibre1">each Baddie 5 returns a Boolean: False to indicate it’s still moving down </p>
<p class="calibre1">the window or True to indicate that it has fallen off the bottom. We count the </p>
<p class="calibre1">number of Baddies that fall off the bottom and remove each one from the </p>
<p class="calibre1">list. At the end of the method, we return the count to the main code so it </p>
<p class="calibre1">can update the score. </p>
<p class="calibre1">In every frame, we also check to see if it’s time to create a new </p>
<p class="calibre1">Baddie 6. When we’ve gone through the constant ADD_NEW_BADDIE_RATE num-</p>
<p class="calibre1">ber of frames, we create a new Baddie object and add it to the list of Baddies. </p>
<p class="calibre1">The draw() method 7 iterates through the list of Baddies and calls the </p>
<p class="calibre1">draw() method of each Baddie to draw itself at its appropriate location. </p>
<p class="calibre1">Finally, the hasPlayerHitBaddie() method 8 checks to see if the Player’s </p>
<p class="calibre1">rectangle intersects any Baddie. The code iterates through the list of </p>
<p class="calibre1">Baddies and calls the collide() method of each. If there was an intersec-</p>
<p class="calibre1">tion (overlap) with any Baddie, then we report that back to the main code, </p>
<p class="calibre1">which ends the game. </p>
<p class="calibre1"><b class="calibre3">File: Dodger/Goodies.py</b></p>
<p class="calibre1">The GoodieMgr and Goodie classes are very similar to the BaddieMgr and Baddie </p>
<p class="calibre1">classes. The Goodie manager is an object manager object that maintains a </p>
<p class="calibre1">list of Goodies. The difference from the Baddie manager is that it will ran-</p>
<p class="calibre1">domly place a Goodie at either the left edge of the window (in which case it </p>
<p class="calibre1">moves right) or the right edge (so it moves left). It also creates new Goodies </p>
<p class="calibre1">after a randomized number of frames. When the Player intersects with a </p>
<p class="calibre1">Goodie, the user is rewarded with 25 points. The update() method of the </p>
<p class="calibre1">Goodie manager uses the technique described in the previous section: it </p>
<p class="calibre1">makes a copy of the Goodies list and iterates through the copy. </p>
<p class="calibre1"><b class="calibre3">358</b>   Chapter 16</p>
<p class="calibre1"><a id="p388"/><b class="calibre3">File: Dodger/Player.py</b></p>
<p class="calibre1">The Player class, shown in Listing 16-10, manages the Player icon and keeps </p>
<p class="calibre1">track of where it should appear in the game window. </p>
<p class="calibre1"># Player class</p>
<p class="calibre1">--- snip imports ---</p>
<p class="calibre1">class Player():</p>
<p class="calibre1">1 def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.image = pygwidgets.Image(window, </p>
<p class="calibre1">(-100, -100), 'images/player.png')</p>
<p class="calibre1">playerRect = self.image.getRect()</p>
<p class="calibre1">self.maxX = WINDOW_WIDTH - playerRect.width</p>
<p class="calibre1">self.maxY = GAME_HEIGHT - playerRect.height</p>
<p class="calibre1"># Every frame, move the Player icon to the mouse position</p>
<p class="calibre1"># Limits the x- and y-coordinates to the game area of the window</p>
<p class="calibre1">2 def update(self, x, y):</p>
<p class="calibre1">if x &lt; 0:</p>
<p class="calibre1">x = 0</p>
<p class="calibre1">elif x &gt; self.maxX:</p>
<p class="calibre1">x = self.maxX</p>
<p class="calibre1">if y &lt; 0:</p>
<p class="calibre1">y = 0</p>
<p class="calibre1">elif y &gt; self.maxY:</p>
<p class="calibre1">y = self.maxY</p>
<p class="calibre1">self.image.setLoc((x, y))</p>
<p class="calibre1">return self.image.getRect()</p>
<p class="calibre1">3 def draw(self):</p>
<p class="calibre1">self.image.draw()</p>
<p class="calibre1"> <i class="calibre4">Listing 16-10: The Player class</i></p>
<p class="calibre1">The __init__() method 1 loads the Player icon image and sets up a </p>
<p class="calibre1">number of instance variables for use later. </p>
<p class="calibre1">The update() method 2 is called in every frame by the Play scene. The </p>
<p class="calibre1">basic idea is to show the Player icon at the mouse location, which is passed </p>
<p class="calibre1">in. We do a few checks to ensure that the icon remains within the rect-</p>
<p class="calibre1">angle of the playable area. In every frame, the update() method returns the </p>
<p class="calibre1">updated rectangle of the Player icon so the main Play code in Listing 16-6 </p>
<p class="calibre1">can check if the Player’s rectangle intersects with any Baddie or Goodie. </p>
<p class="calibre1">Finally, the draw() method 3 draws the Player icon at the new location. </p>
<p class="calibre1">The use of the Goodie manager, the Baddie manager, and the Player </p>
<p class="calibre1">object clearly demonstrates the power of OOP. We can just send messages to </p>
<p class="calibre1">these objects, asking them to update or reset themselves, and they do what-</p>
<p class="calibre1">ever they need to do in response. The Goodie and Baddie managers pass </p>
<p class="calibre1">these messages on to all the Goodies and Baddies that they manage. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">359</b></p>
<p class="calibre1"><a id="p389"/><b class="calibre3">File: Dodger/SceneHighScores.py</b></p>
<p class="calibre1">The High Scores scene displays the top 10 high scores (and the names of </p>
<p class="calibre1">the players) in a table. It also allows a user who has scored in the top 10 to </p>
<p class="calibre1">optionally enter their name and score into the table. The scene instantiates </p>
<p class="calibre1">a HighScoresData object to manage the actual data, which includes reading </p>
<p class="calibre1">and writing the data file. This allows the High Scores scene to update the </p>
<p class="calibre1">table and to respond to requests from the Play scene for the current high </p>
<p class="calibre1">and low scores in the table. </p>
<p class="calibre1">Listings 16-11 through 16-13 contain the code of the SceneHighScores </p>
<p class="calibre1">class. We’ll start with the __init__() and getSceneKey() methods in </p>
<p class="calibre1">Listing 16-11. </p>
<p class="calibre1"># High Scores scene</p>
<p class="calibre1">--- snip imports, showCustomAnswersDialog, and showCustomResetDialog ---</p>
<p class="calibre1">class SceneHighScores(pyghelpers.Scene):</p>
<p class="calibre1">def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">1 self.oHighScoresData = HighScoresData()</p>
<p class="calibre1">self.backgroundImage = pygwidgets.Image(self.window, </p>
<p class="calibre1">(0, 0), </p>
<p class="calibre1">'images/highScoresBackground.jpg')</p>
<p class="calibre1">self.namesField = pygwidgets.DisplayText(self.window, </p>
<p class="calibre1">(260, 84), '', fontSize=48, </p>
<p class="calibre1">textColor=BLACK, </p>
<p class="calibre1">width=300, justified='left')</p>
<p class="calibre1">self.scoresField = pygwidgets.DisplayText(self.window, </p>
<p class="calibre1">(25, 84), '', fontSize=48, </p>
<p class="calibre1">textColor=BLACK, </p>
<p class="calibre1">width=175, justified='right')</p>
<p class="calibre1">self.quitButton = pygwidgets.CustomButton(self.window, </p>
<p class="calibre1">(30, 650), </p>
<p class="calibre1">up='images/quitNormal.png', </p>
<p class="calibre1">down='images/quitDown.png', </p>
<p class="calibre1">over='images/quitOver.png', </p>
<p class="calibre1">disabled='images/quitDisabled.png')</p>
<p class="calibre1">self.backButton = pygwidgets.CustomButton(self.window, </p>
<p class="calibre1">(240, 650), </p>
<p class="calibre1">up='images/backNormal.png', </p>
<p class="calibre1">down='images/backDown.png', </p>
<p class="calibre1">over='images/backOver.png', </p>
<p class="calibre1">disabled='images/backDisabled.png')</p>
<p class="calibre1">self.resetScoresButton = pygwidgets.CustomButton(self.window, </p>
<p class="calibre1">(450, 650), </p>
<p class="calibre1">up='images/resetNormal.png', </p>
<p class="calibre1">down='images/resetDown.png', </p>
<p class="calibre1">over='images/resetOver.png', </p>
<p class="calibre1"><b class="calibre3">360</b>   Chapter 16</p>
<p class="calibre1"><a id="p390"/>                                 disabled='images/resetDisabled.png') 2 self.showHighScores()</p>
<p class="calibre1">3 def getSceneKey(self):</p>
<p class="calibre1">return SCENE_HIGH_SCORES</p>
<p class="calibre1"> <i class="calibre4">Listing 16-11: The __init__() and getSceneKey() methods of the SceneHighScores class</i> The __init__() method 1 creates an instance of the HighScoresData class, </p>
<p class="calibre1">which maintains all the data for the High Scores scene. We then create all </p>
<p class="calibre1">the images, fields, and buttons for this scene. At the end of the initializa-</p>
<p class="calibre1">tion, we call self.showHighScores() 2 to populate the name and score fields. </p>
<p class="calibre1">The getSceneKey() method 3 returns a unique key for the scene and </p>
<p class="calibre1">must be implemented in all scenes. </p>
<p class="calibre1">Listing 16-12 shows the code for the enter() method of the </p>
<p class="calibre1">SceneHighScores class. </p>
<p class="calibre1">1 def enter(self, newHighScoreValue=None):</p>
<p class="calibre1"># This can be called two different ways:</p>
<p class="calibre1"># 1. If no new high score, newHighScoreValue will be None</p>
<p class="calibre1"># 2. newHighScoreValue is score of the current game - in top 10</p>
<p class="calibre1">2 if newHighScoreValue is None:</p>
<p class="calibre1">return  # nothing to do</p>
<p class="calibre1">3 self.draw() # draw before showing dialog </p>
<p class="calibre1"># We have a new high score sent in from the Play scene</p>
<p class="calibre1">dialogQuestion = ('To record your score of ' +</p>
<p class="calibre1">str(newHighScoreValue) + ',\n' +</p>
<p class="calibre1">'please enter your name:')</p>
<p class="calibre1">4 playerName = showCustomAnswerDialog(self.window, </p>
<p class="calibre1">dialogQuestion)</p>
<p class="calibre1">5 if playerName is None:</p>
<p class="calibre1">return  # user pressed Cancel</p>
<p class="calibre1"># Add user and score to high scores</p>
<p class="calibre1">if playerName == '':</p>
<p class="calibre1">playerName = 'Anonymous' </p>
<p class="calibre1">6 self.oHighScoresData.addHighScore(playerName, </p>
<p class="calibre1">newHighScoreValue)</p>
<p class="calibre1"># Show the updated high scores table</p>
<p class="calibre1">self.showHighScores()</p>
<p class="calibre1"> <i class="calibre4">Listing 16-12: The enter() method of the SceneHighScores class</i></p>
<p class="calibre1">The scene manager calls the enter() method of the High Scores scene 1 </p>
<p class="calibre1">when navigating to that scene from the Play scene. If the game the user just </p>
<p class="calibre1">finished did not have a score in the top 10, this method just returns 2. But </p>
<p class="calibre1">if the user did earn a top 10 score, the enter() method is called with an extra </p>
<p class="calibre1">value—the score of the game that the user just completed. </p>
<p class="calibre1">In that case, we call draw() 3 to draw the contents of the High Scores </p>
<p class="calibre1">scene before showing the dialog offering the user the choice to add their </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">361</b></p>
<p class="calibre1"><a id="p391"/><img src="index-391_1.png" alt="Image 53" class="calibre2"/></p>
<p class="calibre1">score to the list. We then call an intermediate function, showCustom </p>
<p class="calibre1">AnswerDialog(), that builds and displays the custom dialog 4, as shown  </p>
<p class="calibre1">in Figure 16-7. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-7: A customAnswerDialog to let the user add their name to the high scores list</i> If the user selects No Thanks, we get a returned value of None and </p>
<p class="calibre1">we skip the rest of this method 5. Otherwise, we take the name that is </p>
<p class="calibre1">returned and add the name and score to the table 6 by calling a method  </p>
<p class="calibre1">in the HighScoresData object. Finally, we update the fields by calling the </p>
<p class="calibre1">showHighScores() method. If there is no score in the call to this method 2, </p>
<p class="calibre1">there is nothing to do, since the current list is already displayed. </p>
<p class="calibre1">Listing 16-13 contains the code for the remaining methods of this class. </p>
<p class="calibre1">def showHighScores(self): 1</p>
<p class="calibre1"># Get the scores and names, show them in two fields</p>
<p class="calibre1">scoresList, namesList = self.oHighScoresData.getScoresAndNames()</p>
<p class="calibre1">self.namesField.setValue(namesList)</p>
<p class="calibre1">self.scoresField.setValue(scoresList) </p>
<p class="calibre1">def handleInputs(self, eventsList, keyPressedList): 2</p>
<p class="calibre1">for event in eventsList:</p>
<p class="calibre1">if self.quitButton.handleEvent(event):</p>
<p class="calibre1">self.quit()</p>
<p class="calibre1">elif self.backButton.handleEvent(event):</p>
<p class="calibre1">self.goToScene(SCENE_PLAY)</p>
<p class="calibre1">elif self.resetScoresButton.handleEvent(event):</p>
<p class="calibre1">confirmed = showCustomResetDialog(self.window, 3</p>
<p class="calibre1">'Are you sure you want to \nRESET the high scores?')</p>
<p class="calibre1">if confirmed:</p>
<p class="calibre1">self.oHighScoresData.resetScores()</p>
<p class="calibre1">self.showHighScores()</p>
<p class="calibre1">def draw(self): 4</p>
<p class="calibre1">self.backgroundImage.draw()</p>
<p class="calibre1">self.scoresField.draw()</p>
<p class="calibre1">self.namesField.draw()</p>
<p class="calibre1">self.quitButton.draw()</p>
<p class="calibre1">self.resetScoresButton.draw()</p>
<p class="calibre1">self.backButton.draw()</p>
<p class="calibre1"><b class="calibre3">362</b>   Chapter 16</p>
<p class="calibre1"><a id="p392"/>    def respond(self, requestID): 5</p>
<p class="calibre1">if requestID == HIGH_SCORES_DATA:</p>
<p class="calibre1"># Request from Play scene for the highest and lowest scores</p>
<p class="calibre1"># Build a dictionary and return it to the Play scene</p>
<p class="calibre1">highestScore, lowestScore = self.oHighScoresData.getHighestAndLowest()</p>
<p class="calibre1">return {'highest':highestScore, 'lowest':lowestScore}</p>
<p class="calibre1"> <i class="calibre4">Listing 16-13: The showHighScores(), handleInputs(), draw(), and respond() methods of the SceneHighScores</i> <i class="calibre4">class</i></p>
<p class="calibre1">The showHighScores() method 1 starts by asking the HighScoresData </p>
<p class="calibre1">object for two lists: the top 10 names and scores. It takes the lists that are </p>
<p class="calibre1">returned and sends them to two display fields to be shown. If you pass a list </p>
<p class="calibre1">to the setValue() method of a DisplayText object, it will display each element </p>
<p class="calibre1">on a separate line. We use two DisplayText objects because self.namesField is </p>
<p class="calibre1">left justified, while self.scoresField is right justified. </p>
<p class="calibre1">The handleInputs() method 2 only needs to check for and respond to </p>
<p class="calibre1">the user clicking the Quit, Back, and Reset Scores buttons. Because the </p>
<p class="calibre1">Reset Scores button wipes data, we should ask for confirmation before per-</p>
<p class="calibre1">forming this action. Therefore, when the user clicks this button, we call an </p>
<p class="calibre1">intermediate function, showCustomResetDialog() 3, to put up a dialog asking </p>
<p class="calibre1">the user to confirm that they really want to clear out all the current scores. </p>
<p class="calibre1">The draw() method 4 draws all the elements in the window. </p>
<p class="calibre1">Finally, the respond() method 5 allows another scene to ask this scene for </p>
<p class="calibre1">information. This is what allows the Play scene to request the highest current </p>
<p class="calibre1">score and the tenth-highest score—the minimum score to qualify a player for </p>
<p class="calibre1">the high scores list. The caller sends a value that indicates what information </p>
<p class="calibre1">it’s looking for. In this case, the requested info is HIGH_SCORES_DATA, a constant </p>
<p class="calibre1">that is shared from the  <i class="calibre4">Constants.py</i> file. This method builds up a dictionary of the two requested values and returns it to the calling scene. </p>
<p class="calibre1"><b class="calibre3">File: Dodger/HighScoresData.py</b></p>
<p class="calibre1">The final class is HighScoresData, responsible for managing the high score </p>
<p class="calibre1">information. It reads and writes the data as a file in JSON format. The data </p>
<p class="calibre1">is always kept in order, from the highest to the lowest score. For example, </p>
<p class="calibre1">the file representing the 10 highest scores might look like this:</p>
<p class="calibre1">[['Moe', 987], ['Larry', 812], ... ['Curly', 597]]</p>
<p class="calibre1">Listing 16-14 shows the code of the HighScoresData class. </p>
<p class="calibre1"># HighScoresData class</p>
<p class="calibre1">from Constants import *</p>
<p class="calibre1">from pathlib import Path</p>
<p class="calibre1">import json</p>
<p class="calibre1">class HighScoresData():</p>
<p class="calibre1">"""The data file is stored as a list of lists in JSON format. </p>
<p class="calibre1">Each list is made up of a name and a score:</p>
<p class="calibre1">[[name, score], [name, score], [name, score] ...]</p>
<p class="calibre1">In this class, all scores are kept in self.scoresList. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">363</b></p>
<p class="calibre1"><a id="p393"/>    The list is kept in order of scores, highest to lowest. </p>
<p class="calibre1">""" </p>
<p class="calibre1">1 def __init__(self):</p>
<p class="calibre1">self.BLANK_SCORES_LIST = N_HIGH_SCORES * [['-----', 0]]</p>
<p class="calibre1">2 self.oFilePath = Path('HighScores.json')</p>
<p class="calibre1"># Try to open and load the data from the data file</p>
<p class="calibre1">try:</p>
<p class="calibre1">3 data = self.oFilePath.read_text()</p>
<p class="calibre1">except FileNotFoundError:  # no file, set to blank scores and save</p>
<p class="calibre1">4 self.scoresList = self.BLANK_SCORES_LIST.copy() </p>
<p class="calibre1">self.saveScores()</p>
<p class="calibre1">return</p>
<p class="calibre1"># File exists, load the scores from the JSON file</p>
<p class="calibre1">5 self.scoresList = json.loads(data)</p>
<p class="calibre1">6 def addHighScore(self, name, newHighScore):</p>
<p class="calibre1"># Find the appropriate place to add the new high score</p>
<p class="calibre1">placeFound = False</p>
<p class="calibre1">for index, nameScoreList in enumerate(self.scoresList):</p>
<p class="calibre1">thisScore = nameScoreList[1]</p>
<p class="calibre1">if newHighScore &gt; thisScore:</p>
<p class="calibre1"># Insert into proper place, remove last entry</p>
<p class="calibre1">self.scoresList.insert(index, [name, newHighScore])</p>
<p class="calibre1">self.scoresList.pop(N_HIGH_SCORES)</p>
<p class="calibre1">placeFound = True</p>
<p class="calibre1">break</p>
<p class="calibre1">if not placeFound:</p>
<p class="calibre1">return  # score does not belong in the list</p>
<p class="calibre1"># Save the updated scores</p>
<p class="calibre1">self.saveScores()</p>
<p class="calibre1">7 def saveScores(self):</p>
<p class="calibre1">scoresAsJson = json.dumps(self.scoresList)</p>
<p class="calibre1">self.oFilePath.write_text(scoresAsJson)</p>
<p class="calibre1">8 def resetScores(self):</p>
<p class="calibre1">self.scoresList = self.BLANK_SCORES_LIST.copy()</p>
<p class="calibre1">self.saveScores()    </p>
<p class="calibre1">9 def getScoresAndNames(self):</p>
<p class="calibre1">namesList = []</p>
<p class="calibre1">scoresList = []</p>
<p class="calibre1">for nameAndScore in self.scoresList:</p>
<p class="calibre1">thisName = nameAndScore[0]</p>
<p class="calibre1">thisScore = nameAndScore[1]</p>
<p class="calibre1">namesList.append(thisName)</p>
<p class="calibre1">scoresList.append(thisScore)</p>
<p class="calibre1">return scoresList, namesList</p>
<p class="calibre1">a def getHighestAndLowest(self):</p>
<p class="calibre1"># Element 0 is the highest entry, element -1 is the lowest</p>
<p class="calibre1"><b class="calibre3">364</b>   Chapter 16</p>
<p class="calibre1"><a id="p394"/>        highestEntry = self.scoresList[0]</p>
<p class="calibre1">lowestEntry = self.scoresList[-1]</p>
<p class="calibre1"># Get the score (element 1) of each sublist</p>
<p class="calibre1">highestScore = highestEntry[1]</p>
<p class="calibre1">lowestScore = lowestEntry[1]</p>
<p class="calibre1">return highestScore, lowestScore</p>
<p class="calibre1"> <i class="calibre4">Listing 16-14: The HighScoresData class</i></p>
<p class="calibre1">In the __init__() method 1, we first create a list of all blank entries. We </p>
<p class="calibre1">use the Path module to create a path object with the location of the data </p>
<p class="calibre1">file 2. </p>
<p class="calibre1"><b class="calibre3">N O T E   </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">The path shown in this listing is in the same folder as the code. This is fine for learning the concept of file input and output. However, if you intend to share your program with other people to play on their computers, it would be better to use a different</i> <i class="calibre4">path in the user’s home folder. This path can be constructed like this:</i></p>
<p class="calibre1">import os.path</p>
<p class="calibre1">DATA_FILE_PATH = os.path.expanduser('~/DodgerHighScores.json')</p>
<p class="calibre1"> <i class="calibre4">or:</i></p>
<p class="calibre1">from pathlib import Path</p>
<p class="calibre1">DATA_FILE_PATH = Path('~/DodgerHighScores.json').expanduser()</p>
<p class="calibre1">Next, we check if we already have some high scores saved by checking </p>
<p class="calibre1">for the existence of the data file 3. If the file is not found 4, we set the </p>
<p class="calibre1">scores to the list of blank entries, call saveScores() to save the scores, and </p>
<p class="calibre1">return. Otherwise, we read the contents of the file 5 and convert from </p>
<p class="calibre1">JSON format to a list of lists. </p>
<p class="calibre1">The addHighScores() method 6 is responsible for adding a new high </p>
<p class="calibre1">score to the list. Since the data is always kept in order, we iterate through </p>
<p class="calibre1">the list of scores until we find the appropriate index and insert the new </p>
<p class="calibre1">name and score. Because that operation will extend the list, we remove </p>
<p class="calibre1">the last element to only keep the top 10. We also check that the new score </p>
<p class="calibre1">should actually be inserted into the list. Finally, we call saveScores() to save </p>
<p class="calibre1">the scores to the data file. </p>
<p class="calibre1">The saveScores() method 7 saves the score data to a JSON-formatted </p>
<p class="calibre1">file. It’s called from various places. </p>
<p class="calibre1">The resetScores() method 8 is called when the user says that they wish </p>
<p class="calibre1">to reset all the names and scores to the starting point (all blank names and </p>
<p class="calibre1">all scores set to zero). We call saveScores() to rewrite the data file. </p>
<p class="calibre1">The getScoresAndNames() method 9 is called by the High Scores scene to </p>
<p class="calibre1">get the top 10 scores and names. We iterate through the list of lists of high </p>
<p class="calibre1">scores data to create one list of scores and another of names; both lists are </p>
<p class="calibre1">returned. </p>
<p class="calibre1">Finally, the getHighestAndLowest() method a is called by the High Scores </p>
<p class="calibre1">scene to get the highest and lowest scores in the table. It uses these results </p>
<p class="calibre1">to determine if a user’s score qualifies the user to enter their name and </p>
<p class="calibre1">score into the high scores table. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">365</b></p>
<p class="calibre1"><a id="p395"/> <i class="calibre4"><b class="calibre3">Extensions to the Game</b></i></p>
<p class="calibre1">The overall architecture is modular, allowing for ease of modification. Each </p>
<p class="calibre1">scene encapsulates its own data and methods, while communication and </p>
<p class="calibre1">navigation are handled by the scene manager. Extensions can be handled </p>
<p class="calibre1">in one scene without affecting anything in other scenes. </p>
<p class="calibre1">For example, rather than the game ending as soon as the Player icon </p>
<p class="calibre1">hits a Baddie, you might want the user to start with some number of lives; </p>
<p class="calibre1">when the Player icon hits a Baddie, the number of lives is decremented by </p>
<p class="calibre1">one, and the game is over when the player runs out of lives. This kind of </p>
<p class="calibre1">change would be relatively easy to implement and would affect only the </p>
<p class="calibre1">Play scene. </p>
<p class="calibre1">As another idea, the user might start with a small number of bombs </p>
<p class="calibre1">that they can detonate when they’re in a bind, eliminating all Baddies </p>
<p class="calibre1">within a given radius around the Player icon. The count of bombs would </p>
<p class="calibre1">be decremented each time one is used, until it reaches zero. This change </p>
<p class="calibre1">would affect only the code of the Play scene and the Baddie manager. </p>
<p class="calibre1">Or maybe you want to keep track of more high scores—say, 20 instead </p>
<p class="calibre1">of 10. A change like that can be made in the High Scores scene without </p>
<p class="calibre1">affecting the Play or Splash scenes. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">This chapter demonstrated how to create and use Yes/No and Answer </p>
<p class="calibre1">dialogs—both text and customizable versions. We then focused on building </p>
<p class="calibre1">a full object-oriented game program, Dodger. </p>
<p class="calibre1">We used the pygwidgets module for all the buttons, text displays, and </p>
<p class="calibre1">input text fields. We used the pyghelpers module for all the dialogs. The </p>
<p class="calibre1">SceneMgr allowed us to split up the game into smaller, more manageable </p>
<p class="calibre1">pieces (Scene objects) and to navigate between scenes. </p>
<p class="calibre1">The game used or demonstrated the following object-oriented </p>
<p class="calibre1">concepts: </p>
<p class="calibre1"><b class="calibre3">Encapsulation  </b>Each scene handles only the things specific to the </p>
<p class="calibre1">scene. </p>
<p class="calibre1"><b class="calibre3">Polymorphism  </b>Each scene implements the same methods. </p>
<p class="calibre1"><b class="calibre3">Inheritance  </b>Each scene inherits from the Scene base class. </p>
<p class="calibre1"><b class="calibre3">Object manager object    </b>The Play scene uses composition to create a </p>
<p class="calibre1">Baddie manager object, self.oBaddieMgr, and a Goodie manager object, </p>
<p class="calibre1">self.oGoodieMgr, each of which manages a list of its objects. </p>
<p class="calibre1"><b class="calibre3">Shared constants    </b>We use separate modules for Goodies and Baddies, </p>
<p class="calibre1">and a  <i class="calibre4">Constants.py</i> file allows us to easily share constants across modules. </p>
<p class="calibre1"><b class="calibre3">366</b>   Chapter 16</p>
<p class="calibre1"><a id="p396"/><b class="calibre3">17</b></p>
<p class="calibre1"><b class="calibre3">D E S I G N   P A T T E R N S   </b></p>
<p class="calibre1"><b class="calibre3">A N D   W R A P - U P</b></p>
<p class="calibre1">In this final chapter, I’ll introduce the </p>
<p class="calibre1">object-oriented programming concept of </p>
<p class="calibre1"> <i class="calibre4">design patterns</i>, which are reusable OOP solu-</p>
<p class="calibre1">tions to commonly occurring software prob-</p>
<p class="calibre1">lems. We’ve already seen one design pattern in this </p>
<p class="calibre1">book: using an object manager object to manage a list  </p>
<p class="calibre1">or dictionary of objects. Many full books have been written on the topic of </p>
<p class="calibre1">design patterns, so we obviously cannot discuss all of them. In this chapter </p>
<p class="calibre1">we’ll focus on the Model View Controller pattern that’s used to break a sys-</p>
<p class="calibre1">tem into smaller, more manageable and more modifiable parts. Lastly, I’ll </p>
<p class="calibre1">give a wrap-up on OOP. </p>
<p class="calibre1"><b class="calibre3">Model View Controller</b></p>
<p class="calibre1">The  <i class="calibre4">Model View Controller (MVC)</i> design pattern enforces a clear split </p>
<p class="calibre1">between a collection of data and the way that data is represented to the </p>
<p class="calibre1">user. The pattern separates the functionality into three parts: the model, </p>
<p class="calibre1"><a id="p397"/><img src="index-397_1.png" alt="Image 54" class="calibre2"/></p>
<p class="calibre1"><img src="index-397_2.png" alt="Image 55" class="calibre2"/></p>
<p class="calibre1">the view, and the controller. Each part has a clearly defined responsibility, </p>
<p class="calibre1">and each is implemented by one or more objects. </p>
<p class="calibre1">The model stores data. The view is responsible for drawing the infor-</p>
<p class="calibre1">mation from the model in one of perhaps multiple ways. The controller </p>
<p class="calibre1">typically creates the model and view objects, handles all user interactions, </p>
<p class="calibre1">communicates changes to the model, and tells the view to display the </p>
<p class="calibre1">data. This separation makes the overall system highly maintainable and </p>
<p class="calibre1">modifiable. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">File Display Example</b></i></p>
<p class="calibre1">As a good example of the MVC pattern, consider the way files are displayed </p>
<p class="calibre1">in the macOS Finder or the Windows File Explorer. Say we have a folder that </p>
<p class="calibre1">contains four files and a subfolder. The end user can choose to display these </p>
<p class="calibre1">items as a list, as in Figure 17-1. </p>
<p class="calibre1"> <i class="calibre4">Figure 17-1: Files in a folder shown as a list </i></p>
<p class="calibre1">Alternatively, the user can choose to display the same items as icons, as </p>
<p class="calibre1">in Figure 17-2. </p>
<p class="calibre1"> <i class="calibre4">Figure 17-2: Files in a folder shown as icons </i></p>
<p class="calibre1">The underlying data for both displays is identical, but the representa-</p>
<p class="calibre1">tion of the information to the user is different. In this example, the data is </p>
<p class="calibre1">the list of files and subfolders; it’s kept in a model object. The view object </p>
<p class="calibre1">displays the data in whatever way the user chooses: as a list, as icons, as a </p>
<p class="calibre1">detailed list, and so on. The controller tells the view to display the informa-</p>
<p class="calibre1">tion in the layout chosen by the user. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Statistical Display Example</b></i></p>
<p class="calibre1">As a more extensive example of the MVC pattern, let’s consider a program </p>
<p class="calibre1">that simulates rolling a pair of dice many times and shows the results. In </p>
<p class="calibre1"><b class="calibre3">368</b>   Chapter 17</p>
<p class="calibre1"><a id="p398"/><img src="index-398_1.png" alt="Image 56" class="calibre2"/></p>
<p class="calibre1">each roll we’ll add the values of the two dice, so the sum—which we’ll call </p>
<p class="calibre1">an  <i class="calibre4">outcome</i>—must be between 2 and 12. The data consists of the count of </p>
<p class="calibre1">the number of times each outcome is rolled and the percentage of the </p>
<p class="calibre1">total number of rolls each outcome makes up. The program can display </p>
<p class="calibre1">this data in three different representations: a bar chart, a pie chart, and a </p>
<p class="calibre1">text table. It defaults to a bar chart and displays the result after simulating </p>
<p class="calibre1">rolling a pair of dice 2,500 times. Since this program is just intended as </p>
<p class="calibre1">a working demonstration of the MVC pattern, we’ll generate the output </p>
<p class="calibre1">using pygame and pygwidgets. For more professional-looking charts and </p>
<p class="calibre1">displays, I suggest that you look into Python data visualization libraries </p>
<p class="calibre1">such as Matplotlib, Seaborn, Plotly, Bokeh, and others that are designed </p>
<p class="calibre1">for this purpose. </p>
<p class="calibre1">Figure 17-3 shows the data displayed as a bar chart. </p>
<p class="calibre1"> <i class="calibre4">Figure 17-3: Dice roll data as a bar chart </i></p>
<p class="calibre1">Beneath each bar is the outcome, the count of the number of times that </p>
<p class="calibre1">outcome was rolled, and the percentage of the total number of rolls that </p>
<p class="calibre1">count represents. The height of each bar corresponds to the count (or per-</p>
<p class="calibre1">centage). Clicking Roll Dice runs the simulation again, using the number </p>
<p class="calibre1">of rolls specified in the input field. The user can click the different radio </p>
<p class="calibre1">buttons to show different views of the same data. If the user selects the Pie </p>
<p class="calibre1">Chart radio button, the data is displayed as in Figure 17-4. </p>
<p class="calibre1">Design Patterns and Wrap-Up    <b class="calibre3">369</b></p>
<p class="calibre1"><a id="p399"/><img src="index-399_1.png" alt="Image 57" class="calibre2"/></p>
<p class="calibre1"><img src="index-399_2.png" alt="Image 58" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 17-4: Dice roll data as a pie chart </i></p>
<p class="calibre1">If the user selects the Text radio button, the data is displayed as in </p>
<p class="calibre1">Figure 17-5. </p>
<p class="calibre1"> <i class="calibre4">Figure 17-5: Dice roll data as text</i></p>
<p class="calibre1"><b class="calibre3">370</b>   Chapter 17</p>
<p class="calibre1"><a id="p400"/>The user can change the value in the “Number of rolls” field to roll the dice as many times as they wish. This data in this program is based on statistics </p>
<p class="calibre1">and randomness. With different sample sizes the exact counts will obviously </p>
<p class="calibre1">vary, but the percentages should always be approximately the same. </p>
<p class="calibre1">I won’t show the full listing of the program here, but will focus on a few </p>
<p class="calibre1">key lines that demonstrate the setup and the flow of control in the MVC </p>
<p class="calibre1">pattern. The full program is available for download with the rest of the </p>
<p class="calibre1">book’s resources, in the  <i class="calibre4">MVC_RollTheDice</i> folder. The folder contains the </p>
<p class="calibre1">following files: </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main_MVC.py</b></i><b class="calibre3">  </b>The main Python file</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Controller.py</b></i><b class="calibre3">  </b>Contains the Controller class</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Model.py</b></i><b class="calibre3">  </b>Contains the Model class</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">BarView.py</b></i><b class="calibre3">  </b>Contains the BarView class that displays the bar chart</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Bin.py</b></i><b class="calibre3">  </b>Contains the Bin class that draws a single bar in the bar chart</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">PieView.py</b></i><b class="calibre3">  </b>Contains the PieView class that displays the pie chart</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">TextView.py</b></i><b class="calibre3">  </b>Contains the TextView class that displays the text view</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Constants.py</b></i><b class="calibre3">  </b>Contains constants that are shared by multiple modules The main program instantiates a Controller object and runs the main </p>
<p class="calibre1">loop. Code in the main loop forwards all events (other than the pygame.QUIT </p>
<p class="calibre1">event) to the controller to handle. </p>
<p class="calibre1"><b class="calibre3">The Controller</b></p>
<p class="calibre1">The controller is the supervisor of the whole program. It starts by instan-</p>
<p class="calibre1">tiating the Model object. It then instantiates one of each of the different </p>
<p class="calibre1">view objects: BarView, PieView, and TextView. Here is the startup code in the </p>
<p class="calibre1">__init__() method of the Controller class:</p>
<p class="calibre1"># Instantiate the model</p>
<p class="calibre1">self.oModel = Model()</p>
<p class="calibre1"># Instantiate different view objects</p>
<p class="calibre1">self.oBarView = BarView(self.window, self.oModel)</p>
<p class="calibre1">self.oPieView = PieView(self.window, self.oModel)</p>
<p class="calibre1">self.oTextView = TextView(self.window, self.oModel)</p>
<p class="calibre1">When the Controller object instantiates these View objects, it passes in </p>
<p class="calibre1">the Model object so each View object can request information directly from </p>
<p class="calibre1">the model. Different implementations of the MVC pattern might handle </p>
<p class="calibre1">communication between these three elements differently; for example, a </p>
<p class="calibre1">controller could act as an intermediary, requesting data from the model </p>
<p class="calibre1">and forwarding it on to the current view, rather than allowing the model </p>
<p class="calibre1">and view to communicate directly. </p>
<p class="calibre1">The controller draws and reacts to everything outside the black rectan-</p>
<p class="calibre1">gle in the window, including the title, the image of the dice, and the radio </p>
<p class="calibre1">buttons. It draws the Quit and Roll Dice buttons and reacts when they’re </p>
<p class="calibre1">clicked, and it handles any changes the user makes to the number of rolls. </p>
<p class="calibre1">Design Patterns and Wrap-Up    <b class="calibre3">371</b></p>
<p class="calibre1"><a id="p401"/>The Controller object keeps a current View object, which determines which view is currently displayed. We set it by default to the BarView object </p>
<p class="calibre1">(the bar chart):</p>
<p class="calibre1">self.oView = self.oBarView</p>
<p class="calibre1">When the user clicks a radio button, the Controller sets its current View </p>
<p class="calibre1">object to the newly selected view and tells the new View object to update </p>
<p class="calibre1">itself by calling its update() method:</p>
<p class="calibre1">if self.oBarButton.handleEvent(event):</p>
<p class="calibre1">self.oView = self.oBarView</p>
<p class="calibre1">self.oView.update()</p>
<p class="calibre1">elif self.oPieButton.handleEvent(event):</p>
<p class="calibre1">self.oView = self.oPieView</p>
<p class="calibre1">self.oView.update()</p>
<p class="calibre1">elif self.oTextButton.handleEvent(event):</p>
<p class="calibre1">self.oView = self.oTextView</p>
<p class="calibre1">self.oView.update()</p>
<p class="calibre1">At startup, and whenever the user clicks Roll Dice, the controller vali-</p>
<p class="calibre1">dates the number of rolls specified in the “Number of rolls” field and tells </p>
<p class="calibre1">the model to generate new data:</p>
<p class="calibre1">self.oModel.generateRolls(nRounds)</p>
<p class="calibre1">All the views are polymorphic, so in each frame the Controller object </p>
<p class="calibre1">calls the draw() method of the current View object:</p>
<p class="calibre1">self.oView.draw()  # tell the current view to draw itself</p>
<p class="calibre1"><b class="calibre3">The Model</b></p>
<p class="calibre1">The model is responsible for obtaining (and potentially updating) informa-</p>
<p class="calibre1">tion. In this program, the Model object is simple: it simulates rolling a pair </p>
<p class="calibre1">of dice many times, stores the results in instance variables, and reports the </p>
<p class="calibre1">data when a View object requests it. </p>
<p class="calibre1">When asked to generate data, the model runs a loop simulating rolling </p>
<p class="calibre1">the dice and stores its data in two dictionaries: self.rollsDict, which uses </p>
<p class="calibre1">each outcome as a key and the count as a value, and self.percentsDict, which </p>
<p class="calibre1">uses each outcome as a key and the percentage of rolls as a value. </p>
<p class="calibre1">In more complex programs, the model could get its data from a data-</p>
<p class="calibre1">base, the internet, or other sources. For example, a Model object could main-</p>
<p class="calibre1">tain stock information, population data, city housing data, temperature </p>
<p class="calibre1">readings, and so on. </p>
<p class="calibre1">In this model, the getRoundsRollsPercents() method is called by the </p>
<p class="calibre1">View objects to retrieve all the data at once. However, a model may contain </p>
<p class="calibre1">more information than any one view might need. Therefore, different View </p>
<p class="calibre1">objects can call different methods in the Model object to request different </p>
<p class="calibre1">information from the same model. To support this, in the sample program </p>
<p class="calibre1"><b class="calibre3">372</b>   Chapter 17</p>
<p class="calibre1"><a id="p402"/>I’ve included a number of additional getter methods (getNumberOfRounds(), getRolls(), and getPercents()) that a programmer could use when building a </p>
<p class="calibre1">new View object, to get only the data that the new view might want to display. </p>
<p class="calibre1"><b class="calibre3">The View</b></p>
<p class="calibre1">A View object is responsible for displaying data to the user. In our sample </p>
<p class="calibre1">program, we have three different View objects that display the same under-</p>
<p class="calibre1">lying information in three different forms; each displays the information </p>
<p class="calibre1">within the black rectangle in the window. At startup, and when the user </p>
<p class="calibre1">clicks Roll Dice, the controller calls the update() method of the current View </p>
<p class="calibre1">object. All View objects then make the same call to the Model object to get the </p>
<p class="calibre1">current data: </p>
<p class="calibre1">nRounds, resultsDict, percentsDict = self.oModel.getRoundsRollsPercents()</p>
<p class="calibre1">The View object then formats the data in its own way and presents it to </p>
<p class="calibre1">the user. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Advantages of the MVC Pattern</b></i></p>
<p class="calibre1">The MVC design pattern breaks up responsibility into separate classes that </p>
<p class="calibre1">act independently but work collectively. Building the components as dis-</p>
<p class="calibre1">tinct classes and minimizing the interactions between the resulting objects </p>
<p class="calibre1">allows each individual component to be less complex and less error prone. </p>
<p class="calibre1">Once the interface of each component is defined, the code of the classes </p>
<p class="calibre1">can even be written by different programmers. </p>
<p class="calibre1">With the MVC approach, each component demonstrates the core OOP </p>
<p class="calibre1">concepts of encapsulation and abstraction. Using an MVC object structure, </p>
<p class="calibre1">the model can change the way it represents the data internally without </p>
<p class="calibre1">affecting the controller or the view. As mentioned previously, the model </p>
<p class="calibre1">might contain more data than any single view needs. And as long as the </p>
<p class="calibre1">controller doesn’t change the way it communicates with the model, and </p>
<p class="calibre1">the model continues to return the requested information to the view in an </p>
<p class="calibre1">agreed-upon way, the model can add new data without breaking the system. </p>
<p class="calibre1">The MVC model also makes it easy to add enhancements. For example, </p>
<p class="calibre1">in our dice-rolling program, the model could keep track of the count of the </p>
<p class="calibre1">different combinations of rolls of the two dice that make up each outcome, </p>
<p class="calibre1">such as getting a 5 by rolling a 1 and a 4 or a 2 and a 3. We could then mod-</p>
<p class="calibre1">ify the BarChart view to obtain this additional information from the model </p>
<p class="calibre1">and show each bar split into smaller bars to display the percentages of each </p>
<p class="calibre1">combination. </p>
<p class="calibre1">Each of the View objects is entirely customizable. The TextView could use </p>
<p class="calibre1">different fonts and font sizes, or a different layout. The PieView could show </p>
<p class="calibre1">the wedges in different colors. The bars in the BarView could be thicker or </p>
<p class="calibre1">taller, or be shown in different colors, or even be displayed horizontally. </p>
<p class="calibre1">Any such changes would be made only in the appropriate View object, com-</p>
<p class="calibre1">pletely independent of the model or the controller. </p>
<p class="calibre1">Design Patterns and Wrap-Up    <b class="calibre3">373</b></p>
<p class="calibre1"><a id="p403"/>The MVC pattern also makes it easy to add a new way to view the data, by writing a new View class. The only additional changes required would be </p>
<p class="calibre1">to have the controller draw another radio button, instantiate the new View </p>
<p class="calibre1">object, and call the new View object’s update() method when the user selects </p>
<p class="calibre1">the new view. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">MVC and other design patterns are independent of any specific computer language</i> <i class="calibre4">and can be used in any language that supports OOP. If you’re interested in learning</i> <i class="calibre4">more, I suggest that you search the web for OOP design patterns such as the Factory,</i> <i class="calibre4">Flyweight, Observer, and Visitor patterns; there are numerous video and text tutorials (as well as books) available on all of these. For a general introduction, </i> Design Patterns: Elements of Reusable Object-Oriented Software <i class="calibre4"> (Addison-Wesley) by </i></p>
<p class="calibre1"> <i class="calibre4">Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (the Gang of Four)</i> <i class="calibre4">is considered the bible of design patterns. </i></p>
<p class="calibre1"><b class="calibre3">Wrap-Up </b></p>
<p class="calibre1">When thinking about object-oriented programming, remember my initial </p>
<p class="calibre1">definition of an object: data plus code that acts on that data over time. </p>
<p class="calibre1">OOP gives you a new way to think about programming, offering an easy </p>
<p class="calibre1">and convenient way to group together data and code that acts on that data. </p>
<p class="calibre1">You write classes and instantiate objects from those classes. Each object gets </p>
<p class="calibre1">a set of all instance variables defined in the class, but the instance variables </p>
<p class="calibre1">in different objects can contain different data and remain independent of </p>
<p class="calibre1">each other. The methods of the objects can work differently because they’re </p>
<p class="calibre1">working on different data. Objects can be instantiated at any time and can </p>
<p class="calibre1">be destroyed at any time. </p>
<p class="calibre1">When instantiating multiple objects from one class, you typically build </p>
<p class="calibre1">a list or dictionary of objects, then later iterate over that list or dictionary, </p>
<p class="calibre1">calling methods of each object. </p>
<p class="calibre1">As a final reminder, the three main tenets of OOP are:</p>
<p class="calibre1"><b class="calibre3">Encapsulation  </b>Everything in one place, objects own their data. </p>
<p class="calibre1"><b class="calibre3">Polymorphism  </b>Different objects can implement the same methods. </p>
<p class="calibre1"><b class="calibre3">Inheritance  </b>A class can extend or modify the behavior of another class. </p>
<p class="calibre1">Objects often work in hierarchies; they can use composition to instanti-</p>
<p class="calibre1">ate other objects and can call methods of lower-level objects to ask them to </p>
<p class="calibre1">do work or provide information. </p>
<p class="calibre1">To give you a clear visual representation of OOP in action, most of the </p>
<p class="calibre1">examples in this book focused on widgets and other objects that can be </p>
<p class="calibre1">useful in a gaming environment. I developed the pygwidgets and pyghelpers </p>
<p class="calibre1">packages to demonstrate many different OOP techniques and to allow you </p>
<p class="calibre1">to easily use GUI widgets in pygame programs. I hope you find these pack-</p>
<p class="calibre1">ages useful and go on to use them to develop fun or useful programs of </p>
<p class="calibre1">your own. </p>
<p class="calibre1"><b class="calibre3">374</b>   Chapter 17</p>
<p class="calibre1"><a id="p404"/>More importantly, I hope that you recognize that object-oriented programming is a general-purpose approach that can be applied in a wide </p>
<p class="calibre1">variety of circumstances. Any time you see two or more functions that need </p>
<p class="calibre1">to operate on a shared set of data, you should consider building a class and </p>
<p class="calibre1">instantiating an object. You may also want to consider building an object </p>
<p class="calibre1">manager object to manage a group of objects. </p>
<p class="calibre1">With all that said, I’d like to offer my congratulations: you’ve made it </p>
<p class="calibre1">to the end of the book! Although actually, this should be considered the </p>
<p class="calibre1">beginning of your journey into object-oriented programming. Hopefully, </p>
<p class="calibre1">the concepts described in this book have given you a framework that you </p>
<p class="calibre1">can build on—but the only way to truly get a handle on how OOP works </p>
<p class="calibre1">is to write lots and lots of code. Over time, you will start to notice patterns </p>
<p class="calibre1">that you will use again and again in your code. Understanding how to struc-</p>
<p class="calibre1">ture your classes is a difficult process. Only through experience will it begin </p>
<p class="calibre1">to become easier to ensure that you have the proper methods and instance </p>
<p class="calibre1">variables in the correct classes. </p>
<p class="calibre1">Practice, practice, practice! </p>
<p class="calibre1">Design Patterns and Wrap-Up    <b class="calibre3">375</b></p>
<p class="calibre1"><a id="p405"/>
<a id="p406"/><b class="calibre3">I N D E X</b></p>
<p class="calibre1"><b class="calibre3">Symbols</b></p>
<p class="calibre1">Animation class, 149, 304–306</p>
<p class="calibre1">+ operator example, polymorphism, </p>
<p class="calibre1">animation classes</p>
<p class="calibre1">193–194</p>
<p class="calibre1">building, 296–304</p>
<p class="calibre1">* (asterisk), using with import</p>
<p class="calibre1">merging, 304</p>
<p class="calibre1">statement, 61</p>
<p class="calibre1">in pygwidgets, 304–309</p>
<p class="calibre1">@ (at) property, 174–177</p>
<p class="calibre1">SimpleAnimation class, 296–300</p>
<p class="calibre1">== (equal to), magic method </p>
<p class="calibre1">SimpleSpriteSheetAnimation class, </p>
<p class="calibre1">name, 196</p>
<p class="calibre1">300–304</p>
<p class="calibre1">&gt; (greater than), magic method</p>
<p class="calibre1">animation program, pygwidgets </p>
<p class="calibre1">name, 196</p>
<p class="calibre1">package, 308–309</p>
<p class="calibre1">&gt;= (greater than or equal to), magic </p>
<p class="calibre1">Answer dialogs, Dodger game, 345–347</p>
<p class="calibre1">method name, 196</p>
<p class="calibre1">anti-aliased line, drawing, 118</p>
<p class="calibre1">&lt; (less than), magic method </p>
<p class="calibre1">API (application programming </p>
<p class="calibre1">name, 196</p>
<p class="calibre1">interface), 137, 158</p>
<p class="calibre1">&lt;= (less than or equal to), magic </p>
<p class="calibre1">arc, drawing, 118</p>
<p class="calibre1">method name, 196</p>
<p class="calibre1">arguments</p>
<p class="calibre1">!= (not equal to), magic method </p>
<p class="calibre1">methods and parameters, 144</p>
<p class="calibre1">name, 196</p>
<p class="calibre1">passing to methods, 40–41</p>
<p class="calibre1">rearranging in calls to methods, </p>
<p class="calibre1"><b class="calibre3">A</b></p>
<p class="calibre1">53</p>
<p class="calibre1">abc (abstract base class) module, </p>
<p class="calibre1">asterisk (*), using with import </p>
<p class="calibre1">Python Standard Library, 232</p>
<p class="calibre1">statement, 61</p>
<p class="calibre1">AbortTransaction exception, 79, 81</p>
<p class="calibre1">at (@) property, 174–177</p>
<p class="calibre1">absolute path, using with pygame, 101</p>
<p class="calibre1">abstract base class (abc) module, </p>
<p class="calibre1"><b class="calibre3">B</b></p>
<p class="calibre1">Python Standard Library, 232</p>
<p class="calibre1">background music, playing in pygame, </p>
<p class="calibre1">abstract classes and methods, 231–234. </p>
<p class="calibre1">115–116</p>
<p class="calibre1"> <i class="calibre4">See also</i> classes; methods</p>
<p class="calibre1">Baddies and Goodies, 347</p>
<p class="calibre1">abstraction, 179–181</p>
<p class="calibre1">Ball class, 122–125</p>
<p class="calibre1">Account class</p>
<p class="calibre1">Ball objects, creating, 125–127</p>
<p class="calibre1">error handling in, 59</p>
<p class="calibre1">Balloon game</p>
<p class="calibre1">with exceptions, 78–79</p>
<p class="calibre1">main code, 252–256</p>
<p class="calibre1">testing, 62</p>
<p class="calibre1">module of constants, 253</p>
<p class="calibre1">Account objects, 59, 71</p>
<p class="calibre1">object diagram, 252</p>
<p class="calibre1">dictionary of, 66–67</p>
<p class="calibre1">project folder, 252</p>
<p class="calibre1">in lists, 64–66</p>
<p class="calibre1">screenshot, 251</p>
<p class="calibre1">accounts, creating, 62–64</p>
<p class="calibre1">source files, 252</p>
<p class="calibre1">Alert dialog, Dodger game, 343</p>
<p class="calibre1">balloon manager, 256–258</p>
<p class="calibre1">angle brackets (&lt;&gt;), values in, 16</p>
<p class="calibre1">Balloon sample program, 251–261</p>
<p class="calibre1"><a id="p407"/>Balloon class and objects, </p>
<p class="calibre1">inside vs. outside, 164–165</p>
<p class="calibre1">258–261</p>
<p class="calibre1">making available, 29–30</p>
<p class="calibre1">bank account class, 58–60</p>
<p class="calibre1">and methods, 51</p>
<p class="calibre1">bank account simulations.  <i class="calibre4">See also</i> </p>
<p class="calibre1">and objects, 23–25</p>
<p class="calibre1">procedural implementations</p>
<p class="calibre1">objects and instantiation, 25–33</p>
<p class="calibre1">operations and data, 7–8</p>
<p class="calibre1">representing physical objects as, </p>
<p class="calibre1">table of data, 15–16</p>
<p class="calibre1">35–44</p>
<p class="calibre1">Bank class, 70, 79–81</p>
<p class="calibre1">in use, 45</p>
<p class="calibre1">Bank object, 70–71, 82</p>
<p class="calibre1">writing, 26–27</p>
<p class="calibre1">bank program, using exceptions in, </p>
<p class="calibre1">class hierarchy, inheritance, 236–238</p>
<p class="calibre1">78–83</p>
<p class="calibre1">class scope, 27</p>
<p class="calibre1">base class, inheritance, 212–214, </p>
<p class="calibre1">class statement, inheritance, 216</p>
<p class="calibre1">227–231</p>
<p class="calibre1">class variables.  <i class="calibre4">See also</i> variables</p>
<p class="calibre1">Blackjack deck, 278</p>
<p class="calibre1">constants, 249–250</p>
<p class="calibre1">blit() method, 102, 114, 124, 137</p>
<p class="calibre1">for counting, 250</p>
<p class="calibre1">Boolean True, 105</p>
<p class="calibre1">creating, 248–249</p>
<p class="calibre1">Button class, building, 128–130</p>
<p class="calibre1">client code</p>
<p class="calibre1">buttons, building, 131–132</p>
<p class="calibre1">explained, 164</p>
<p class="calibre1">using direct access, 170</p>
<p class="calibre1"><b class="calibre3">C</b></p>
<p class="calibre1">collidepoint(), 104</p>
<p class="calibre1">callbacks, 137–141</p>
<p class="calibre1">comparison operator magic methods, </p>
<p class="calibre1">CanastaDeck class, 279</p>
<p class="calibre1">195–196</p>
<p class="calibre1">Card class, 268–270</p>
<p class="calibre1"> <i class="calibre4">composition</i>, 71</p>
<p class="calibre1">card games.  <i class="calibre4">See also</i> Higher or Lower </p>
<p class="calibre1"> <i class="calibre4">composition </i> and inheritance, 238</p>
<p class="calibre1">card game</p>
<p class="calibre1">Controller object, 371–372</p>
<p class="calibre1">Blackjack, 278</p>
<p class="calibre1">CountDownTimer class, 293–294</p>
<p class="calibre1">Card class, 268–270</p>
<p class="calibre1">counting objects, 250</p>
<p class="calibre1">Deck class, 270–272</p>
<p class="calibre1">CountUpTimer class, pyghelpers package, </p>
<p class="calibre1">Higher or Lower game, 272–276</p>
<p class="calibre1">291–293</p>
<p class="calibre1">testing with __name__, 276–278</p>
<p class="calibre1"> <i class="calibre4">CPython</i>, 242</p>
<p class="calibre1">with unusual decks, 279</p>
<p class="calibre1">customAnswerDialog dialog, Dodger </p>
<p class="calibre1">Cartesian coordinate system, </p>
<p class="calibre1">game, 347</p>
<p class="calibre1">91–95, 201</p>
<p class="calibre1">CustomButton class, 148, 235–236</p>
<p class="calibre1">catching exceptions, 76</p>
<p class="calibre1">CustomCheckBox class, pygwidgets </p>
<p class="calibre1">child class, inheritance, 212</p>
<p class="calibre1">package, 149</p>
<p class="calibre1">circle, drawing, 119</p>
<p class="calibre1">CustomRadioButton class, pygwidgets </p>
<p class="calibre1">Circle class, 187–190, 227, 230</p>
<p class="calibre1">package, 149</p>
<p class="calibre1">class code, importing, 60–61</p>
<p class="calibre1">customYesNoDialog dialog, Dodger </p>
<p class="calibre1">classes.  <i class="calibre4">See also</i> abstract classes and </p>
<p class="calibre1">game, 345</p>
<p class="calibre1">methods</p>
<p class="calibre1">building, 33–35</p>
<p class="calibre1"><b class="calibre3">D</b></p>
<p class="calibre1">creating instances from, 31–32</p>
<p class="calibre1">data, validating, 168–170</p>
<p class="calibre1">creating objects from, 28–30</p>
<p class="calibre1">databases, accessing with objects and </p>
<p class="calibre1">form of, 26</p>
<p class="calibre1">XTRAS, 178–179</p>
<p class="calibre1">implementing data types as, 32–33</p>
<p class="calibre1">data types, implementation as classes, </p>
<p class="calibre1">and inheritance, 212–213</p>
<p class="calibre1">32–33</p>
<p class="calibre1">inheriting from same base class, </p>
<p class="calibre1">debugging approach, 203</p>
<p class="calibre1">227–231</p>
<p class="calibre1">Deck class, 270–272</p>
<p class="calibre1"><b class="calibre3">378</b>   Index</p>
<p class="calibre1"><a id="p408"/>decorators and at (@) property, </p>
<p class="calibre1">with functions, 164</p>
<p class="calibre1">174–177</p>
<p class="calibre1">interpretations of, 165–172</p>
<p class="calibre1">__del__() method, 246–248, 260</p>
<p class="calibre1">making instance variables more </p>
<p class="calibre1">design patterns, MVC (Model View </p>
<p class="calibre1">private, 172–173</p>
<p class="calibre1">Controller), 367–374</p>
<p class="calibre1">with objects, 164–165</p>
<p class="calibre1">dice roll data, MVC (Model View </p>
<p class="calibre1">in pygwidgets classes, 177</p>
<p class="calibre1">Controller) design pattern, </p>
<p class="calibre1">enter() method used with scenes, 325</p>
<p class="calibre1">369–370</p>
<p class="calibre1">__eq__() magic method name, 196, </p>
<p class="calibre1">__dict__ dictionary, 261–263</p>
<p class="calibre1">198–199</p>
<p class="calibre1">dictionary</p>
<p class="calibre1">equal to (==), magic method name, 196</p>
<p class="calibre1">of account objects, 66–67</p>
<p class="calibre1">error handling</p>
<p class="calibre1">using with instance variables, </p>
<p class="calibre1">in Account class, 59</p>
<p class="calibre1">261–263</p>
<p class="calibre1">with exceptions, 76–78</p>
<p class="calibre1">DimmerSwitch class, 33, 48–50, 52–53</p>
<p class="calibre1">event-driven programs, 95–96</p>
<p class="calibre1">DimmerSwitch objects, creating, 50, 53</p>
<p class="calibre1">event loop, 99</p>
<p class="calibre1">direct access, avoiding, 166–170</p>
<p class="calibre1">except and try, 76–77</p>
<p class="calibre1">Director <i class="calibre4"> </i> from Macromedia project, 178</p>
<p class="calibre1">exceptions</p>
<p class="calibre1">DisplayMoney class, 222–227</p>
<p class="calibre1">in bank program, 78–83</p>
<p class="calibre1">DisplayText class, 149, 222</p>
<p class="calibre1">error handling with, 76–78</p>
<p class="calibre1">Dodger game</p>
<p class="calibre1">handling, 81–83</p>
<p class="calibre1">Alert dialog, 343</p>
<p class="calibre1">Answer dialogs, 345–347</p>
<p class="calibre1"><b class="calibre3">F</b></p>
<p class="calibre1">customAnswerDialog dialog, 347</p>
<p class="calibre1">file display example, 368</p>
<p class="calibre1">customYesNoDialog dialog, 345</p>
<p class="calibre1">Fraction class, magic methods, </p>
<p class="calibre1">extensions to, 366</p>
<p class="calibre1">205–208</p>
<p class="calibre1">implementation, 348</p>
<p class="calibre1">functions</p>
<p class="calibre1">modal dialogs, 342–347</p>
<p class="calibre1">encapsulation with, 164</p>
<p class="calibre1">overview, 347</p>
<p class="calibre1">len(), 164</p>
<p class="calibre1">ScenePlay class, 351–355</p>
<p class="calibre1">vs. methods, 28</p>
<p class="calibre1">textYesNoDialog dialog, 343</p>
<p class="calibre1">super(), 216</p>
<p class="calibre1">Yes/No dialog, 344</p>
<p class="calibre1">vars(), 52</p>
<p class="calibre1">Don’t Repeat Yourself (DRY), 253</p>
<p class="calibre1">Dragger class, pygwidgets package, 149</p>
<p class="calibre1"><b class="calibre3">G</b></p>
<p class="calibre1">drawing shapes, 116–120</p>
<p class="calibre1">Game class, 274</p>
<p class="calibre1">draw() method used with pygwidgets, </p>
<p class="calibre1">Game object, 272</p>
<p class="calibre1">150, 155, 157, 193, 308</p>
<p class="calibre1">games, transient objects in, 242</p>
<p class="calibre1">draw() method used with scenes, 325</p>
<p class="calibre1">garbage collection, 248</p>
<p class="calibre1">draw.rect(), 187</p>
<p class="calibre1">__ge__() magic method name, 196</p>
<p class="calibre1">DRY (Don’t Repeat Yourself), 253</p>
<p class="calibre1">getrefcount() function, 244</p>
<p class="calibre1">getSceneKey() method used with </p>
<p class="calibre1"><b class="calibre3">E</b></p>
<p class="calibre1">scenes, 328</p>
<p class="calibre1">educational project, 178–179</p>
<p class="calibre1">getters and setters, 170–171, 175–176</p>
<p class="calibre1">ellipse, drawing, 119</p>
<p class="calibre1"> <i class="calibre4">Ghostbusters</i>, 138</p>
<p class="calibre1">Ellipse class, 192</p>
<p class="calibre1">GitHub repository, accessing, 157</p>
<p class="calibre1">Employee class, inheritance, 218</p>
<p class="calibre1">global scope, 27</p>
<p class="calibre1">encapsulation</p>
<p class="calibre1">Goodies and Baddies, 347</p>
<p class="calibre1">decorators and @property, 174–177</p>
<p class="calibre1">goToScene() method used with  </p>
<p class="calibre1">direct access, 166–172</p>
<p class="calibre1">scenes, 326</p>
<p class="calibre1">Index   <b class="calibre3">379</b></p>
<p class="calibre1"><a id="p409"/>graphic file formats, using with </p>
<p class="calibre1">employee and manager example, </p>
<p class="calibre1">pygame, 100–101</p>
<p class="calibre1">214–218</p>
<p class="calibre1">greater than (&gt;), magic method  </p>
<p class="calibre1">example usage, 224–227</p>
<p class="calibre1">name, 196</p>
<p class="calibre1">implementing, 213–214</p>
<p class="calibre1">greater than or equal to (&gt;=), magic </p>
<p class="calibre1">InputNumber class, 219–222, </p>
<p class="calibre1">method name, 196</p>
<p class="calibre1">224–227</p>
<p class="calibre1">__gt__() magic method name, 196, 198</p>
<p class="calibre1">“is a” relationship, 213</p>
<p class="calibre1">GUI programs, event-driven model, </p>
<p class="calibre1">Law of Demeter, 238</p>
<p class="calibre1">95–96</p>
<p class="calibre1">in object-oriented programming, </p>
<p class="calibre1">212–213</p>
<p class="calibre1"><b class="calibre3">H</b></p>
<p class="calibre1">and pygwidgets, 234–236</p>
<p class="calibre1">handleEvent() method used with </p>
<p class="calibre1">real-world examples, 219–227</p>
<p class="calibre1">pygwidgets, 150, 192, 221, </p>
<p class="calibre1">from same base class, 227–231</p>
<p class="calibre1">307, 312</p>
<p class="calibre1">subclass, 212</p>
<p class="calibre1">handleInputs() method used with </p>
<p class="calibre1">test code, 217–218</p>
<p class="calibre1">scenes, 363</p>
<p class="calibre1">use by pygwidgets, 234–236</p>
<p class="calibre1">help() function, 152</p>
<p class="calibre1">initialization parameters, 43–44</p>
<p class="calibre1">Higher or Lower card game, 268. </p>
<p class="calibre1">__init__() method, 28, 37, 43, 216</p>
<p class="calibre1"> <i class="calibre4">See also</i> card games</p>
<p class="calibre1">Account class, 59, 79</p>
<p class="calibre1">Game object, 274–276</p>
<p class="calibre1">Ball class, 123</p>
<p class="calibre1">implementation, 4–7</p>
<p class="calibre1">Bank class, 73</p>
<p class="calibre1">main program, 272–274</p>
<p class="calibre1">inheritance examples, 228–229, </p>
<p class="calibre1">representing data, 4</p>
<p class="calibre1">232–233</p>
<p class="calibre1">reusable code, 7</p>
<p class="calibre1">InputNumber, 221</p>
<p class="calibre1">HighScoresData class, 363</p>
<p class="calibre1">pronouncing, 194</p>
<p class="calibre1">property decorators, 175–176</p>
<p class="calibre1"><b class="calibre3">I</b></p>
<p class="calibre1">SceneMgr class, 335</p>
<p class="calibre1">IDLE development environment, </p>
<p class="calibre1">subclass in inheritance, 216</p>
<p class="calibre1">90, 100–101</p>
<p class="calibre1">using, 27</p>
<p class="calibre1">Image class, pygwidgets package, </p>
<p class="calibre1">input() function, 133, 155</p>
<p class="calibre1">149.  <i class="calibre4">See also</i> subimages</p>
<p class="calibre1">InputNumber class, 219–222, 224–227</p>
<p class="calibre1">ImageCollection class, pygwidgets </p>
<p class="calibre1">InputText class, 149, 219, 222</p>
<p class="calibre1">package, 149, 157</p>
<p class="calibre1">installing</p>
<p class="calibre1">implementation vs. interface, </p>
<p class="calibre1">pygame, 90–91</p>
<p class="calibre1">84–85, 137</p>
<p class="calibre1">pyghelpers, 287</p>
<p class="calibre1">importing class code, 60–61</p>
<p class="calibre1">pygwidgets package, 149–150</p>
<p class="calibre1">import statements, 98</p>
<p class="calibre1">instance and scope variables, 27–28</p>
<p class="calibre1">inheritance.  <i class="calibre4">See also</i> multiple </p>
<p class="calibre1">instances, 26, 31–32, 41–43.  <i class="calibre4">See also</i> </p>
<p class="calibre1">inheritance</p>
<p class="calibre1">multiple instances</p>
<p class="calibre1">abstract classes and methods, </p>
<p class="calibre1">instance scope, 27</p>
<p class="calibre1">231–234</p>
<p class="calibre1">instance variables.  <i class="calibre4">See also</i> slots</p>
<p class="calibre1">base class, 212</p>
<p class="calibre1">changing into calculations, </p>
<p class="calibre1">class hierarchy, 236–238</p>
<p class="calibre1">167–168</p>
<p class="calibre1">client’s view of subclass, 218–219</p>
<p class="calibre1">changing names of, 166–167</p>
<p class="calibre1">and composition, 238</p>
<p class="calibre1">using, 27, 165</p>
<p class="calibre1">difficulty of programming with, </p>
<p class="calibre1">instantiate, explained, 26</p>
<p class="calibre1">238–239</p>
<p class="calibre1">instantiation process, 25–33</p>
<p class="calibre1">DisplayMoney class, 222–227</p>
<p class="calibre1">interactive menu, building, 68–70</p>
<p class="calibre1"><b class="calibre3">380</b>   Index</p>
<p class="calibre1"><a id="p410"/>interface vs. implementation, 84–85, 137</p>
<p class="calibre1">and classes, 51</p>
<p class="calibre1"> <i class="calibre4">Invent Your Own Computer Games with </i></p>
<p class="calibre1">vs. functions, 28</p>
<p class="calibre1"> <i class="calibre4">Python</i>, 341</p>
<p class="calibre1">passing arguments to, 40–41</p>
<p class="calibre1">“is a”  <i class="calibre4"> </i> relationship, inheritance, 213</p>
<p class="calibre1">modal dialogs, Dodger game, 342–347</p>
<p class="calibre1">isInstance() function, 196</p>
<p class="calibre1">Model object, 371–372</p>
<p class="calibre1">items() method, 271</p>
<p class="calibre1">module <i class="calibre4"> </i> of constants, Balloon game, 253</p>
<p class="calibre1">mouse click, detecting in pygame, </p>
<p class="calibre1"><b class="calibre3">J</b></p>
<p class="calibre1">102–104</p>
<p class="calibre1">JSON format, 363–365</p>
<p class="calibre1">MOUSEDOWN event, 257</p>
<p class="calibre1">multiple inheritance, 239.  <i class="calibre4">See also</i> </p>
<p class="calibre1"><b class="calibre3">K</b></p>
<p class="calibre1">inheritance</p>
<p class="calibre1">keyword parameters, pygame, 145–146</p>
<p class="calibre1">multiple instances, 41–43.  <i class="calibre4">See also</i> </p>
<p class="calibre1">instances</p>
<p class="calibre1"><b class="calibre3">L</b></p>
<p class="calibre1">music, playing in pygame, 115–116</p>
<p class="calibre1">Law of Demeter, inheritance, 238</p>
<p class="calibre1">MVC (Model View Controller) design </p>
<p class="calibre1">__le__() magic method name, 196</p>
<p class="calibre1">pattern</p>
<p class="calibre1">leave() method used with scenes, 325</p>
<p class="calibre1">advantages of, 373–374</p>
<p class="calibre1">len() function, 15, 164</p>
<p class="calibre1">Controller object, 371–372</p>
<p class="calibre1">less than (&lt;), magic method name, 196</p>
<p class="calibre1">dice roll data, 369–370</p>
<p class="calibre1">less than or equal to (&lt;=), magic </p>
<p class="calibre1">file display example, 368</p>
<p class="calibre1">method name, 196</p>
<p class="calibre1">Model object, 372–373</p>
<p class="calibre1">LIFO (last in, first out) order, 179</p>
<p class="calibre1">overview, 367–368</p>
<p class="calibre1">LightSwitch class and test code, 30</p>
<p class="calibre1">statistical display example, 368–371</p>
<p class="calibre1">light switch example, 22–23, 25–31</p>
<p class="calibre1">View object, 373</p>
<p class="calibre1">LightSwitch object, instantiating, 29</p>
<p class="calibre1">line, drawing, 119</p>
<p class="calibre1"><b class="calibre3">N</b></p>
<p class="calibre1">Lingo language, 178</p>
<p class="calibre1">__name__, testing card games with, </p>
<p class="calibre1">local scope, 27</p>
<p class="calibre1">276–278</p>
<p class="calibre1">__lt__() magic method name, 196, </p>
<p class="calibre1">naming convention, 26</p>
<p class="calibre1">198, 200</p>
<p class="calibre1">__ne__() magic method name, 196</p>
<p class="calibre1">not equal to (!=), magic method  </p>
<p class="calibre1"><b class="calibre3">M</b></p>
<p class="calibre1">name, 196</p>
<p class="calibre1">Macromedia project, 178</p>
<p class="calibre1">magic methods, 194–201.  <i class="calibre4">See also</i> </p>
<p class="calibre1"><b class="calibre3">O</b></p>
<p class="calibre1">methods</p>
<p class="calibre1">object composition, 71</p>
<p class="calibre1">Manager class, inheritance, 219</p>
<p class="calibre1">object lifetime</p>
<p class="calibre1">memory management, slots, 261–263</p>
<p class="calibre1">cascading deletion, 246–248</p>
<p class="calibre1">memory used by objects.  <i class="calibre4">See also</i> objects</p>
<p class="calibre1">death notice, 246–248</p>
<p class="calibre1">Balloon sample program, 251–261</p>
<p class="calibre1">garbage collection, 246–248</p>
<p class="calibre1">class variables, 248–250</p>
<p class="calibre1">reference count, 242–246</p>
<p class="calibre1">managing with slots, 261–263</p>
<p class="calibre1">transaction objects, 242</p>
<p class="calibre1">mental models, 49–52</p>
<p class="calibre1">transient objects, 242</p>
<p class="calibre1">menu, making interactive, 68–70</p>
<p class="calibre1">object manager object, creating, 70–76</p>
<p class="calibre1">methods.  <i class="calibre4">See also</i> abstract classes and </p>
<p class="calibre1">object-oriented programming (OOP)</p>
<p class="calibre1">methods; magic methods</p>
<p class="calibre1">explained, 3</p>
<p class="calibre1">calling, 30, 41</p>
<p class="calibre1">as solution, 45</p>
<p class="calibre1">calling for objects, 30–31</p>
<p class="calibre1">tenets, 374</p>
<p class="calibre1">calling on lists of objects, 83–84</p>
<p class="calibre1">wrap-up, 374–375</p>
<p class="calibre1">Index   <b class="calibre3">381</b></p>
<p class="calibre1"><a id="p411"/>object-oriented pygame. </p>
<p class="calibre1"><b class="calibre3">P</b></p>
<p class="calibre1"> <i class="calibre4">See also</i> pygame</p>
<p class="calibre1">parent class, inheritance, 212</p>
<p class="calibre1">Ball class, 122–125</p>
<p class="calibre1">path, using with pygame, 100</p>
<p class="calibre1">Ball objects, 125–127</p>
<p class="calibre1">pathname, using with pygame, 100</p>
<p class="calibre1">callbacks, 137–141</p>
<p class="calibre1">patterns, extending with </p>
<p class="calibre1">demo ball with SimpleText and </p>
<p class="calibre1">polymorphism, 192</p>
<p class="calibre1">SimpleButton, 135–137</p>
<p class="calibre1">physical objects.  <i class="calibre4">See also</i> objects</p>
<p class="calibre1">interface vs. implementation, 137</p>
<p class="calibre1">building software models of, </p>
<p class="calibre1">program with buttons, 131–132</p>
<p class="calibre1">22–23</p>
<p class="calibre1">reusable object-oriented button, </p>
<p class="calibre1">classes and objects, 23–25, 45</p>
<p class="calibre1">127–132</p>
<p class="calibre1">classes, objects, and instantiation, </p>
<p class="calibre1">reusable object-oriented text </p>
<p class="calibre1">25–33</p>
<p class="calibre1">display, 133–135</p>
<p class="calibre1">complicated classes, 33–44</p>
<p class="calibre1">SimpleButton, 130–131</p>
<p class="calibre1">OOP as solution, 45</p>
<p class="calibre1">SimpleText class, 133–135</p>
<p class="calibre1">representing as classes, 35–44</p>
<p class="calibre1">steps to display text, 133</p>
<p class="calibre1">PIE (polymorphism, inheritance, </p>
<p class="calibre1">object-oriented solutions</p>
<p class="calibre1">encapsulation), 161</p>
<p class="calibre1">classes, 19–20</p>
<p class="calibre1">PinochleDeck class, 279</p>
<p class="calibre1">objects.  <i class="calibre4">See also</i> memory used by </p>
<p class="calibre1">pixels</p>
<p class="calibre1">objects; physical objects</p>
<p class="calibre1">colors, 94–95</p>
<p class="calibre1">calling methods of, 30–31</p>
<p class="calibre1">in window coordinate  </p>
<p class="calibre1">calling methods on lists of, </p>
<p class="calibre1">system, 91</p>
<p class="calibre1">83–84</p>
<p class="calibre1">playing sounds, 114–116</p>
<p class="calibre1">and classes, 23–25</p>
<p class="calibre1">Play scene, Rock, Paper, Scissors  </p>
<p class="calibre1">counting, 250</p>
<p class="calibre1">game, 315</p>
<p class="calibre1">creating from classes, 28–30</p>
<p class="calibre1">polygon, drawing, 119</p>
<p class="calibre1">definition of, 33</p>
<p class="calibre1">polymorphism</p>
<p class="calibre1">encapsulation with, 164</p>
<p class="calibre1">classic example of, 184–185</p>
<p class="calibre1">garbage collection, 248</p>
<p class="calibre1">extending patterns, 192</p>
<p class="calibre1">inside vs. outside, 164–165</p>
<p class="calibre1">Fraction class with magic methods, </p>
<p class="calibre1">owning data, 165</p>
<p class="calibre1">205–208</p>
<p class="calibre1">reference count, 242–248</p>
<p class="calibre1">magic methods, 194–201</p>
<p class="calibre1">sending messages to, 184</p>
<p class="calibre1">main program creating shapes, </p>
<p class="calibre1">string representations of values in, </p>
<p class="calibre1">190–192</p>
<p class="calibre1">203–205</p>
<p class="calibre1">for operators, 193–203</p>
<p class="calibre1">transient type, 242</p>
<p class="calibre1">pygame shapes, 185–192</p>
<p class="calibre1">with unique identifiers, 66</p>
<p class="calibre1">and pygwidgets, 192–193</p>
<p class="calibre1">variables referring to, 244</p>
<p class="calibre1">sending messages to real-world </p>
<p class="calibre1">object scope, 27</p>
<p class="calibre1">objects, 184</p>
<p class="calibre1">OOP (object-oriented programming)</p>
<p class="calibre1">string representations of values in </p>
<p class="calibre1">explained, 3</p>
<p class="calibre1">objects, 203–205</p>
<p class="calibre1">as solution, 45</p>
<p class="calibre1">vector example, 201–203</p>
<p class="calibre1">tenets, 374</p>
<p class="calibre1">pop operation, using with  </p>
<p class="calibre1">wrap-up, 374–375</p>
<p class="calibre1">stacks, 179</p>
<p class="calibre1">operators</p>
<p class="calibre1">positional parameters, pygame, 145</p>
<p class="calibre1">magic methods, 194–201</p>
<p class="calibre1">primitive shapes, drawing in pygame, </p>
<p class="calibre1">polymorphism for, 193–203</p>
<p class="calibre1">116–120</p>
<p class="calibre1">o prefix, 26</p>
<p class="calibre1">print() function, 133, 205</p>
<p class="calibre1"><b class="calibre3">382</b>   Index</p>
<p class="calibre1"><a id="p412"/>procedural implementations.  <i class="calibre4">See also</i> </p>
<p class="calibre1">pygame.Rect(), 104</p>
<p class="calibre1">bank account simulations</p>
<p class="calibre1">pygame shapes</p>
<p class="calibre1">classes, 19–20</p>
<p class="calibre1">Circle and Triangle shape classes, </p>
<p class="calibre1">Higher or Lower card game, 3–4</p>
<p class="calibre1">187–190</p>
<p class="calibre1">problems with, 18–19, 45</p>
<p class="calibre1">Square shape class, 186–187</p>
<p class="calibre1">properties</p>
<p class="calibre1">PygAnimation base class, 304, 307–308</p>
<p class="calibre1">@ (at) and decorators, 174–177</p>
<p class="calibre1">pyghelpers package</p>
<p class="calibre1">and abstraction, 181</p>
<p class="calibre1">classes for tracking time, 290</p>
<p class="calibre1">explained, 174</p>
<p class="calibre1">CountDownTimer class, 293–294</p>
<p class="calibre1">push operation, using with stacks, 179</p>
<p class="calibre1">CountUpTimer class, 291–293</p>
<p class="calibre1">PyCharm IDE, 100–101</p>
<p class="calibre1">installing, 287</p>
<p class="calibre1"> <i class="calibre4">*.py</i> file extension, 61</p>
<p class="calibre1">pygwidgets classes, encapsulation in, 177</p>
<p class="calibre1">pygame.  <i class="calibre4">See also</i> object-oriented pygame</p>
<p class="calibre1">pygwidgets package.  <i class="calibre4">See also</i> pygame </p>
<p class="calibre1">anti-aliased line, 118</p>
<p class="calibre1">GUI widgets</p>
<p class="calibre1">arc, 119</p>
<p class="calibre1">adding images, 151</p>
<p class="calibre1">bringing up blank window, 97–100</p>
<p class="calibre1">Animation class, 304–309</p>
<p class="calibre1">Cartesian coordinate system, 91–94</p>
<p class="calibre1">animation program, 308–309</p>
<p class="calibre1">circle, 119</p>
<p class="calibre1">button object, 154</p>
<p class="calibre1">colors in, 94–95</p>
<p class="calibre1">buttons, 152–154</p>
<p class="calibre1">detecting mouse click, 102–105</p>
<p class="calibre1">checkboxes, 152–154</p>
<p class="calibre1">drawing images, 100–102</p>
<p class="calibre1">classes, 148–149, 157</p>
<p class="calibre1">drawing shapes, 116–120</p>
<p class="calibre1">class hierarchy, 237</p>
<p class="calibre1">ellipse, 119</p>
<p class="calibre1">consistency of API, 158</p>
<p class="calibre1">event-driven programs, 95–96</p>
<p class="calibre1">CustomButton class, 153–154</p>
<p class="calibre1">handling keyboard, 105–109</p>
<p class="calibre1">design approach, 150–151</p>
<p class="calibre1">installing, 90–91</p>
<p class="calibre1">DisplayText class, 155, 222</p>
<p class="calibre1">line, 119</p>
<p class="calibre1">example program, 157–158</p>
<p class="calibre1">location-based animation, 109–111</p>
<p class="calibre1">goals and classes, 148–149</p>
<p class="calibre1">pixel colors, 94–95</p>
<p class="calibre1">images, 151</p>
<p class="calibre1">playing sounds, 114–116</p>
<p class="calibre1">and inheritance, 234–236</p>
<p class="calibre1">polygon, 119</p>
<p class="calibre1">InputText class, 219</p>
<p class="calibre1">primitive shapes, 118–120</p>
<p class="calibre1">polymorphism, 192–193</p>
<p class="calibre1">recognizing key presses, 105–107</p>
<p class="calibre1">PygAnimation base class, 307–308</p>
<p class="calibre1">rect<b class="calibre3"> </b>objects, 104, 107, 111–114, 119</p>
<p class="calibre1">radio buttons, 152–154</p>
<p class="calibre1">repeating keys in continuous </p>
<p class="calibre1">setting up, 149–150</p>
<p class="calibre1">mode, 107–109</p>
<p class="calibre1">sprite module, 151</p>
<p class="calibre1">Splash scene, 314</p>
<p class="calibre1">SpriteSheetAnimation class, 306–307</p>
<p class="calibre1">state machine example, 314–319</p>
<p class="calibre1">TextButton class, 152–153</p>
<p class="calibre1">window coordinate system, 91–95</p>
<p class="calibre1">text output and input, 154–157</p>
<p class="calibre1">pygame.display.set_mode() function, 98</p>
<p class="calibre1">using buttons, 154</p>
<p class="calibre1">pygame GUI widgets.  <i class="calibre4">See also</i> </p>
<p class="calibre1">PyPI (Python Package Index), 149</p>
<p class="calibre1">pygwidgets package</p>
<p class="calibre1">Python, philosophy of, 242</p>
<p class="calibre1">arguments, functions, and </p>
<p class="calibre1">Python Software Foundation, 242</p>
<p class="calibre1">methods, 144–148</p>
<p class="calibre1">Python Standard Library</p>
<p class="calibre1">keywords and default values, 148</p>
<p class="calibre1">abc (abstract base class) module, 232</p>
<p class="calibre1">None as default value, 146–147</p>
<p class="calibre1">calls to, 76–77</p>
<p class="calibre1">positional and keyword </p>
<p class="calibre1">getrefcount() function, 244</p>
<p class="calibre1">parameters, 145–146</p>
<p class="calibre1">Python Tutor website, 50, 243</p>
<p class="calibre1">Index   <b class="calibre3">383</b></p>
<p class="calibre1"><a id="p413"/><b class="calibre3">R</b></p>
<p class="calibre1">navigating between scenes, 326</p>
<p class="calibre1">raise statement and custom exceptions, </p>
<p class="calibre1">project folder, 321</p>
<p class="calibre1">77–78</p>
<p class="calibre1">quitting program, 326</p>
<p class="calibre1">RAM memory space, 262</p>
<p class="calibre1">Rock, Paper, Scissors, 328–332</p>
<p class="calibre1">random package, 104</p>
<p class="calibre1">run() method, 336–337</p>
<p class="calibre1">real-world objects, sending messages </p>
<p class="calibre1">using, 319–320</p>
<p class="calibre1">to, 184</p>
<p class="calibre1">SceneMgr class, 337</p>
<p class="calibre1">receive() method used with scenes, 334</p>
<p class="calibre1">ScenePlay class, Dodger game, </p>
<p class="calibre1">rectangle, drawing, 120</p>
<p class="calibre1">351–355</p>
<p class="calibre1">Rectangle class</p>
<p class="calibre1">scenes</p>
<p class="calibre1">inheritance example, 233–234</p>
<p class="calibre1">communication between, 332–334</p>
<p class="calibre1">with magic methods, 196–198</p>
<p class="calibre1">current and target, 332</p>
<p class="calibre1">reference count, 242–246</p>
<p class="calibre1">state machine approach, 312–319</p>
<p class="calibre1">decrementing, 245–246</p>
<p class="calibre1">testing communications among, </p>
<p class="calibre1">incrementing, 245</p>
<p class="calibre1">334</p>
<p class="calibre1">relative path, using with pygame, </p>
<p class="calibre1">scope and instance variables, </p>
<p class="calibre1">100–101</p>
<p class="calibre1">27–28</p>
<p class="calibre1">respond() method used with scenes, 333</p>
<p class="calibre1">screensaver ball, building with  </p>
<p class="calibre1">Results scene, Rock, Paper, Scissors </p>
<p class="calibre1">object-oriented pygame, 121–127</p>
<p class="calibre1">game, 315–316</p>
<p class="calibre1">“self,” meaning of, 52–55</p>
<p class="calibre1">reusable object-oriented button, </p>
<p class="calibre1">self parameter, 41–42</p>
<p class="calibre1">building, 127–132</p>
<p class="calibre1">self. prefix, 27</p>
<p class="calibre1">reusable object-oriented text display, </p>
<p class="calibre1">send() method used with scenes, 333</p>
<p class="calibre1">building, 133–135</p>
<p class="calibre1">sendAll() method used with scenes, 334</p>
<p class="calibre1">RGB (red, green, blue), 94</p>
<p class="calibre1">setters and getters, 170–171, 175–176</p>
<p class="calibre1">Rock, Paper, Scissors game</p>
<p class="calibre1">Shape class</p>
<p class="calibre1">Play scene, 315</p>
<p class="calibre1">inheritance example, 232–233</p>
<p class="calibre1">Results scene, 315–316</p>
<p class="calibre1">using as base class, 228</p>
<p class="calibre1">Splash scene, 314</p>
<p class="calibre1">shapes, drawing in pygame, 116–120</p>
<p class="calibre1">using scenes, 328–332</p>
<p class="calibre1">SimpleAnimation class, 296–300</p>
<p class="calibre1">run() method of the scene manager, </p>
<p class="calibre1">SimpleButton class, 129, 131–132, </p>
<p class="calibre1">336, 349</p>
<p class="calibre1">139–141</p>
<p class="calibre1">SimpleButton objects, 130–131, </p>
<p class="calibre1"><b class="calibre3">S</b></p>
<p class="calibre1">137–138, 141</p>
<p class="calibre1">Sample class, 250</p>
<p class="calibre1">SimpleText class, 133–137</p>
<p class="calibre1">Scene base class, 322</p>
<p class="calibre1">SimpleText object, 135</p>
<p class="calibre1">scene manager</p>
<p class="calibre1">Slider class, 193</p>
<p class="calibre1">building scenes, 323–326</p>
<p class="calibre1">Slider Puzzle user interface, 290, 293</p>
<p class="calibre1">communication between scenes, </p>
<p class="calibre1">slots, using for memory management, </p>
<p class="calibre1">338–340</p>
<p class="calibre1">261–263.  <i class="calibre4">See also</i> instance </p>
<p class="calibre1">demo program, 320–328</p>
<p class="calibre1">variables</p>
<p class="calibre1">example scene, 326–328</p>
<p class="calibre1">software models, building for physical </p>
<p class="calibre1">features, 319–320</p>
<p class="calibre1">objects, 22–23</p>
<p class="calibre1">implementation of, 334–340</p>
<p class="calibre1">sound effects, playing in pygame, </p>
<p class="calibre1">main methods, 337–338</p>
<p class="calibre1">114–116</p>
<p class="calibre1">main program, 322–323</p>
<p class="calibre1">SpaceShip class, 249</p>
<p class="calibre1">methods for implementing scenes, </p>
<p class="calibre1">special methods, 194</p>
<p class="calibre1">324–325</p>
<p class="calibre1">Splash scene, 313–314, 347</p>
<p class="calibre1"><b class="calibre3">384</b>   Index</p>
<p class="calibre1"><a id="p414"/>SpriteSheetAnimation class, 149, 304, </p>
<p class="calibre1">timers</p>
<p class="calibre1">306–307</p>
<p class="calibre1">building into main loop, 286</p>
<p class="calibre1">sprite sheet image, 300</p>
<p class="calibre1">calculating elapsed time, </p>
<p class="calibre1">Square class, 195, 227</p>
<p class="calibre1">285–287</p>
<p class="calibre1">inheritance example, 229</p>
<p class="calibre1">counting frames, 283</p>
<p class="calibre1">pygame shapes, 186–187</p>
<p class="calibre1">demonstration program, 282</p>
<p class="calibre1">for reference counting, 243</p>
<p class="calibre1">implementing, 283–287</p>
<p class="calibre1">Square object, 243</p>
<p class="calibre1">installing pyghelpers, 287</p>
<p class="calibre1">Stack class, 181</p>
<p class="calibre1">overview, 281–282</p>
<p class="calibre1">stack operations, 179–180</p>
<p class="calibre1">toggle, using, 38</p>
<p class="calibre1">state diagram, 316</p>
<p class="calibre1">transaction objects, 242</p>
<p class="calibre1">state machine, pygame example, </p>
<p class="calibre1">transient objects, 242</p>
<p class="calibre1">312–319</p>
<p class="calibre1">Triangle class, 187, 227, 230–231</p>
<p class="calibre1">statistical display example, 368–373</p>
<p class="calibre1">try/except techniques, 76–81</p>
<p class="calibre1">__str__() method, 203–204</p>
<p class="calibre1">tuple, setting x- and y-coordinates  </p>
<p class="calibre1">subclasses</p>
<p class="calibre1">as, 151</p>
<p class="calibre1">client’s view of, 218–219</p>
<p class="calibre1">TV class, creating, 35–40</p>
<p class="calibre1">inheritance, 212–213, 215–217</p>
<p class="calibre1">TV objects, creating, 42</p>
<p class="calibre1">inheriting from base class, 227</p>
<p class="calibre1">type() function, 32</p>
<p class="calibre1">subimages, creating, 300. </p>
<p class="calibre1"> <i class="calibre4">See also</i> Image class</p>
<p class="calibre1"><b class="calibre3">U</b></p>
<p class="calibre1">superclass, inheritance, 212</p>
<p class="calibre1">update() method used with scenes, 325 </p>
<p class="calibre1">super() function, 216</p>
<p class="calibre1">Sweigart, Al, 341</p>
<p class="calibre1"><b class="calibre3">V</b></p>
<p class="calibre1">variables.  <i class="calibre4">See also</i> class variables</p>
<p class="calibre1"><b class="calibre3">T</b></p>
<p class="calibre1">referring to same object, 244</p>
<p class="calibre1">temporary variable, using, 66</p>
<p class="calibre1">using temporarily, 66</p>
<p class="calibre1">test code</p>
<p class="calibre1">vars() function, 52</p>
<p class="calibre1">accounts, 62–64</p>
<p class="calibre1">vector example, polymorphism, </p>
<p class="calibre1">creating, 61–62</p>
<p class="calibre1">201–203</p>
<p class="calibre1">inheritance, 217–218</p>
<p class="calibre1">View object, 371, 373</p>
<p class="calibre1">test programming, 177</p>
<p class="calibre1">textAnswerDialog dialog, Dodger  </p>
<p class="calibre1"><b class="calibre3">W</b></p>
<p class="calibre1">game, 346</p>
<p class="calibre1">WidgetWithFrills class, 214</p>
<p class="calibre1">TextButton class, 148, 235</p>
<p class="calibre1">window coordinate system, pygame, </p>
<p class="calibre1">TextCheckBox class, pygwidgets  </p>
<p class="calibre1">91–95</p>
<p class="calibre1">package, 149</p>
<p class="calibre1">working directory, using with  </p>
<p class="calibre1">text display, building, 133–135</p>
<p class="calibre1">pygame, 100</p>
<p class="calibre1">TextRadioButton class, pygwidgets </p>
<p class="calibre1">package, 149</p>
<p class="calibre1"><b class="calibre3">X</b></p>
<p class="calibre1">textYesNoDialog dialog, Dodger  </p>
<p class="calibre1">x- and y-coordinates, setting as  </p>
<p class="calibre1">game, 343</p>
<p class="calibre1">tuple, 151</p>
<p class="calibre1">throwing exceptions, 76</p>
<p class="calibre1">XTRAs and objects, accessing </p>
<p class="calibre1">time, displaying, 290–294</p>
<p class="calibre1">databases with, 178–179</p>
<p class="calibre1">Timer class, 287–290</p>
<p class="calibre1">timer demonstration program, 282</p>
<p class="calibre1"><b class="calibre3">Y</b></p>
<p class="calibre1">timer event, 284–285</p>
<p class="calibre1">Yes/No and Alert dialogs, Dodger </p>
<p class="calibre1">Timer object, 288</p>
<p class="calibre1">game, 342–345</p>
<p class="calibre1">Index   <b class="calibre3">385</b></p>
<p class="calibre1"><a id="p415"/>
<a id="p416"/><img src="index-416_1.png" alt="Image 59" class="calibre2"/></p>
<p class="calibre1">Never before has the world relied so heavily on the Internet </p>
<p class="calibre1">to stay connected and informed. That makes the Electronic </p>
<p class="calibre1">Frontier Foundation’s mission—to ensure that technology </p>
<p class="calibre1">supports freedom, justice, and innovation for all people—</p>
<p class="calibre1">more urgent than ever. </p>
<p class="calibre1">For over 30 years, EFF has fought for tech users through </p>
<p class="calibre1">activism, in the courts, and by developing software to over-</p>
<p class="calibre1">come obstacles to your privacy, security, and free expression. </p>
<p class="calibre1">This dedication empowers all of us through darkness. With </p>
<p class="calibre1">your help we can navigate toward a brighter digital future. </p>
<p class="calibre1">LEARN MORE AND JOIN EFF AT EFF.ORG/NO-STARCH-PRESS</p>
<p class="calibre1"><a id="p417"/><img src="index-417_1.jpg" alt="Image 60" class="calibre2"/></p>
<p class="calibre1"><img src="index-417_2.png" alt="Image 61" class="calibre2"/></p>
<p class="calibre1"><img src="index-417_3.jpg" alt="Image 62" class="calibre2"/></p>
<p class="calibre1"><img src="index-417_4.jpg" alt="Image 63" class="calibre2"/></p>
<p class="calibre1"><img src="index-417_5.png" alt="Image 64" class="calibre2"/></p>
<p class="calibre1"><img src="index-417_6.jpg" alt="Image 65" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">RESOURCES</b></p>
<p class="calibre1">Visit <a href="https://nostarch.com/object-oriented-python/"> <i class="calibre4">https://nostarch.com/object-oriented-python/</i></a> for errata and more information. </p>
<p class="calibre1"> <i class="calibre4">More no-nonsense books from</i></p>
<p class="calibre1"><b class="calibre3">NO STARCH PRESS</b></p>
<p class="calibre1"><b class="calibre3">BEYOND THE BASIC STUFF </b></p>
<p class="calibre1"><b class="calibre3">SERIOUS PYTHON</b></p>
<p class="calibre1"><b class="calibre3">THE MISSING README</b></p>
<p class="calibre1"><b class="calibre3">WITH PYTHON </b></p>
<p class="calibre1"><b class="calibre3">Black-Belt Advice on Deployment, </b></p>
<p class="calibre1"><b class="calibre3">A Guide for the New Software Engineer</b></p>
<p class="calibre1"><b class="calibre3">Scalability, Testing, and More</b></p>
<p class="calibre1"> <i class="calibre4">by </i> Chris Riccomini and </p>
<p class="calibre1"><b class="calibre3">Best Practices for Writing Clean Code</b></p>
<p class="calibre1"> <i class="calibre4">by </i> Julien Danjou</p>
<p class="calibre1">Dmitriy Ryaboy</p>
<p class="calibre1"> <i class="calibre4">by </i> Al Sweigart</p>
<p class="calibre1">240 pp., $34.95</p>
<p class="calibre1">288 pp., $24.99</p>
<p class="calibre1">384 pp., $34.95</p>
<p class="calibre1">ISBN: 978-1-59327-878-6</p>
<p class="calibre1">ISBN: 978-1-7185-0183-6</p>
<p class="calibre1">ISBN: 978-1-59327-966-0</p>
<p class="calibre1"><b class="calibre3">ALGORITHMIC THINKING</b></p>
<p class="calibre1"><b class="calibre3">THE SECRET LIFE OF PROGRAMS</b></p>
<p class="calibre1"><b class="calibre3">WRITE GREAT CODE, VOLUME 3</b></p>
<p class="calibre1"><b class="calibre3">A Problem-Based Introduction</b></p>
<p class="calibre1"><b class="calibre3">Understand Computers—Craft Better Code</b></p>
<p class="calibre1"><b class="calibre3">Engineering Software</b></p>
<p class="calibre1"> <i class="calibre4">by </i> Daniel Zingaro</p>
<p class="calibre1"> <i class="calibre4">by </i> Jonathan E. Steinhart</p>
<p class="calibre1"> <i class="calibre4">by </i> Randall Hyde</p>
<p class="calibre1">408 pp., $49.95</p>
<p class="calibre1">504 pp., $44.95</p>
<p class="calibre1">376 pp., $49.95</p>
<p class="calibre1">ISBN: 978-1-7185-0080-8</p>
<p class="calibre1">ISBN: 978-1-59327-970-7</p>
<p class="calibre1">ISBN: 978-1-59327-979-0</p>
<p class="calibre1"><b class="calibre3">phone:</b></p>
<p class="calibre1"><b class="calibre3">email:</b></p>
<p class="calibre1">800.420.7240 or</p>
<p class="calibre1">sales@nostarch.com</p>
<p class="calibre1">415.863.9900</p>
<p class="calibre1"><b class="calibre3">web:</b></p>
<p class="calibre1">www.nostarch.com</p>
<p class="calibre1"><a id="p418"/><img src="index-418_1.png" alt="Image 66" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_2.png" alt="Image 67" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_3.png" alt="Image 68" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_4.png" alt="Image 69" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_5.png" alt="Image 70" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_6.png" alt="Image 71" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_7.png" alt="Image 72" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_8.png" alt="Image 73" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_9.png" alt="Image 74" class="calibre2"/></p>
<p class="calibre1"><img src="index-418_10.png" alt="Image 75" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">B U I LT   W I T H </b></p>
<p class="calibre1"><b class="calibre3">T A K E   C O N T R O L </b></p>
<p class="calibre1"><b class="calibre3">P Y T H O N   3 . x   A N D </b></p>
<p class="calibre1"><b class="calibre3">O F   Y O U R   P Y T H O N </b></p>
<p class="calibre1"><b class="calibre3">P Y G A M E   2 . x</b></p>
<p class="calibre1"><b class="calibre3">O B J E C T S</b></p>
<p class="calibre1"><b class="calibre3">O B J E C T- O R I E N T E D</b></p>
<p class="calibre1"><b class="calibre3">OBJECT-ORIENTED PYTHON</b></p>
<p class="calibre1"><b class="calibre3">P Y T H O N</b></p>
<p class="calibre1">Object-oriented programming (OOP) is a paradigm </p>
<p class="calibre1">You’ll learn how to:</p>
<p class="calibre1"><b class="calibre3">M A S T E R   O O P   B Y</b></p>
<p class="calibre1">that combines data and code into cohesive units, </p>
<p class="calibre1">• Create and manage multiple objects using an object</p>
<p class="calibre1"><b class="calibre3">B U I L D I N G   G A M E S   A N D   G U I S</b></p>
<p class="calibre1">allowing you to think differently about computational </p>
<p class="calibre1">problems and solve them in a highly reusable way. </p>
<p class="calibre1">manager object</p>
<p class="calibre1">Aimed at intermediate-level programmers,  <i class="calibre4">Object-</i></p>
<p class="calibre1">• Use encapsulation to hide the inner details of objects</p>
<p class="calibre1"> <i class="calibre4">Oriented Python</i> is a hands-on tutorial that goes deep </p>
<p class="calibre1">from client code</p>
<p class="calibre1"><b class="calibre3">I R V   K A L B</b></p>
<p class="calibre1">into the core tenets of OOP, showing you how to use </p>
<p class="calibre1">encapsulation, polymorphism, and inheritance to write </p>
<p class="calibre1">• Use polymorphism to defi ne one interface and</p>
<p class="calibre1">games and apps using Python. </p>
<p class="calibre1">implement it in multiple classes</p>
<p class="calibre1">The book begins by demonstrating key problems </p>
<p class="calibre1">• Apply inheritance to build on existing code</p>
<p class="calibre1">inherent in procedural programming, then guides you </p>
<p class="calibre1">through the basics of creating classes and objects in </p>
<p class="calibre1"> <i class="calibre4">Object-Oriented Python</i> is a visual, intuitive guide to </p>
<p class="calibre1">Python. You’ll build on this groundwork by developing </p>
<p class="calibre1">fully understanding how OOP operates and how you </p>
<p class="calibre1">buttons, text fi elds, and other GUI elements that are </p>
<p class="calibre1">can use it to make your code more maintainable, </p>
<p class="calibre1">standard in event-driven environments. You’ll also use </p>
<p class="calibre1">readable, and effi cient—without sacrifi cing </p>
<p class="calibre1">many real-world code examples and two pygame-</p>
<p class="calibre1">functionality. </p>
<p class="calibre1">based packages to help turn theory into practice, </p>
<p class="calibre1">enabling you to easily write interactive games and </p>
<p class="calibre1"><b class="calibre3">A B O U T   T H E   A U T H O R</b></p>
<p class="calibre1">applications complete with GUI widgets, animations, </p>
<p class="calibre1">Irv Kalb is an adjunct professor at UCSC Silicon </p>
<p class="calibre1">multiple scenes, and reusable game logic. In the final </p>
<p class="calibre1">Valley Extension and the University of Silicon Valley, </p>
<p class="calibre1">chapter, you’ll bring it all together by building a </p>
<p class="calibre1">where he teaches introductory and object-oriented </p>
<p class="calibre1">fully functional video game that incorporates many </p>
<p class="calibre1">programming courses in Python. He is also the author </p>
<p class="calibre1">of the OOP techniques and GUI elements covered in </p>
<p class="calibre1">of  <i class="calibre4">Learn to Program with Python 3: A Step-by-Step </i></p>
<p class="calibre1">the book. </p>
<p class="calibre1"> <i class="calibre4">Guide to Programming. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">THE FINEST IN GEEK ENTERTAINMENT ™</b></i></p>
<p class="calibre1">www.nostarch.com</p>
<p class="calibre1"><b class="calibre3">KALB</b></p>
<p class="calibre1"><b class="calibre3">$44.99 ($59.99 CDN)</b></p>
<p class="calibre1"><a id="outline"/></p>

<h1 class="calibre5" id="calibre_pb_0">Document Outline</h1>
<ul class="calibre6">
<li class="calibre7"><a href="index_split_000.html#p20">Acknowledgments</a></li>
<li class="calibre7"><a href="index_split_000.html#p22">Introduction</a></li>
<li class="calibre7"><a href="index_split_000.html#p30">Part I: Introducing Object-oriented Programming</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p32">Chapter 1: Procedural Python Examples</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p33">Higher or Lower Card Game</a></li>
<li class="calibre7"><a href="index_split_000.html#p36">Bank Account Simulations</a></li>
<li class="calibre7"><a href="index_split_000.html#p47">Common Problems with Procedural Implementation</a></li>
<li class="calibre7"><a href="index_split_000.html#p48">Object-Oriented Solution—First Look at a Class</a></li>
<li class="calibre7"><a href="index_split_000.html#p49">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p50">Chapter 2: Modeling Physical Objects with Object-Oriented Programming</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p51">Building Software Models of Physical Objects</a></li>
<li class="calibre7"><a href="index_split_000.html#p52">Introduction to Classes and Objects</a></li>
<li class="calibre7"><a href="index_split_000.html#p54">Classes, Objects, and Instantiation</a></li>
<li class="calibre7"><a href="index_split_001.html#p62">Building a Slightly More Complicated Class</a></li>
<li class="calibre7"><a href="index_split_001.html#p64">Representing a More Complicated Physical Object as a Class</a></li>
<li class="calibre7"><a href="index_split_001.html#p74">Classes in Use</a></li>
<li class="calibre7"><a href="index_split_001.html#p74">OOP as a Solution</a></li>
<li class="calibre7"><a href="index_split_001.html#p75">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p76">Chapter 3: Mental Models of Objects and the Meaning of “self” </a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p77">Revisiting the DimmerSwitch Class</a></li>
<li class="calibre7"><a href="index_split_001.html#p78">High-Level Mental Model #1</a></li>
<li class="calibre7"><a href="index_split_001.html#p78">A Deeper Mental Model #2</a></li>
<li class="calibre7"><a href="index_split_001.html#p81">What Is the Meaning of “self”? </a></li>
<li class="calibre7"><a href="index_split_001.html#p84">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p86">Chapter 4: Managing Multiple Objects</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p87">Bank Account Class</a></li>
<li class="calibre7"><a href="index_split_001.html#p89">Importing Class Code</a></li>
<li class="calibre7"><a href="index_split_001.html#p90">Creating Some Test Code</a></li>
<li class="calibre7"><a href="index_split_001.html#p99">Creating an Object Manager Object</a></li>
<li class="calibre7"><a href="index_split_001.html#p105">Better Error Handling with Exceptions</a></li>
<li class="calibre7"><a href="index_split_001.html#p107">Using Exceptions in Our Bank Program</a></li>
<li class="calibre7"><a href="index_split_002.html#p112">Calling the Same Method on a List of Objects</a></li>
<li class="calibre7"><a href="index_split_002.html#p113">Interface vs. Implementation</a></li>
<li class="calibre7"><a href="index_split_002.html#p114">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_002.html#p116">Part II: Graphical User interfaces with Pygame</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_002.html#p118">Chapter 5: Introduction to Pygame</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_002.html#p119">Installing Pygame</a></li>
<li class="calibre7"><a href="index_split_002.html#p120">Window Details</a></li>
<li class="calibre7"><a href="index_split_002.html#p124">Event-Driven Programs</a></li>
<li class="calibre7"><a href="index_split_002.html#p125">Using Pygame</a></li>
<li class="calibre7"><a href="index_split_002.html#p143">Playing Sounds</a></li>
<li class="calibre7"><a href="index_split_002.html#p145">Drawing Shapes</a></li>
<li class="calibre7"><a href="index_split_002.html#p149">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_002.html#p150">Chapter 6: Object-Oriented Pygame</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_002.html#p150">Building the Screensaver Ball with OOP Pygame</a></li>
<li class="calibre7"><a href="index_split_002.html#p156">Building a Reusable Object-Oriented Button</a></li>
<li class="calibre7"><a href="index_split_002.html#p162">Building a Reusable Object-Oriented Text Display</a></li>
<li class="calibre7"><a href="index_split_003.html#p164">Demo Ball with SimpleText and SimpleButton</a></li>
<li class="calibre7"><a href="index_split_003.html#p166">Interface vs. Implementation</a></li>
<li class="calibre7"><a href="index_split_003.html#p166">Callbacks</a></li>
<li class="calibre7"><a href="index_split_003.html#p170">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_003.html#p172">Chapter 7: Pygame GUI Widgets</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_003.html#p173">Passing Arguments into a Function or Method</a></li>
<li class="calibre7"><a href="index_split_003.html#p177">The pygwidgets Package</a></li>
<li class="calibre7"><a href="index_split_003.html#p187">The Importance of a Consistent API</a></li>
<li class="calibre7"><a href="index_split_003.html#p187">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_003.html#p190">Part III: Encapsulation, Polymorphism, and Inheritance</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_003.html#p192">Chapter 8: Encapsulation</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_003.html#p193">Encapsulation with Functions</a></li>
<li class="calibre7"><a href="index_split_003.html#p193">Encapsulation with Objects</a></li>
<li class="calibre7"><a href="index_split_003.html#p194">Interpretations of Encapsulation</a></li>
<li class="calibre7"><a href="index_split_003.html#p201">Making Instance Variables More Private</a></li>
<li class="calibre7"><a href="index_split_003.html#p203">Decorators and @property</a></li>
<li class="calibre7"><a href="index_split_003.html#p206">Encapsulation in pygwidgets Classes</a></li>
<li class="calibre7"><a href="index_split_003.html#p207">A Story from the Real World</a></li>
<li class="calibre7"><a href="index_split_003.html#p208">Abstraction</a></li>
<li class="calibre7"><a href="index_split_003.html#p211">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_003.html#p212">Chapter 9: Polymorphism</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_003.html#p213">Sending Messages to Real-World Objects</a></li>
<li class="calibre7"><a href="index_split_003.html#p213">A Classic Example of Polymorphism in Programming</a></li>
<li class="calibre7"><a href="index_split_003.html#p214">Example Using Pygame Shapes</a></li>
<li class="calibre7"><a href="index_split_004.html#p221">pygwidgets Exhibits Polymorphism</a></li>
<li class="calibre7"><a href="index_split_004.html#p222">Polymorphism for Operators</a></li>
<li class="calibre7"><a href="index_split_004.html#p232">Creating a String Representation of Values in an Object</a></li>
<li class="calibre7"><a href="index_split_004.html#p234">A Fraction Class with Magic Methods</a></li>
<li class="calibre7"><a href="index_split_004.html#p237">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_004.html#p240">Chapter 10: Inheritance</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_004.html#p241">Inheritance in Object-Oriented Programming</a></li>
<li class="calibre7"><a href="index_split_004.html#p242">Implementing Inheritance</a></li>
<li class="calibre7"><a href="index_split_004.html#p243">Employee and Manager Example</a></li>
<li class="calibre7"><a href="index_split_004.html#p247">The Client’s View of a Subclass</a></li>
<li class="calibre7"><a href="index_split_004.html#p248">Real-World Examples of Inheritance</a></li>
<li class="calibre7"><a href="index_split_004.html#p256">Multiple Classes Inheriting from the Same Base Class</a></li>
<li class="calibre7"><a href="index_split_004.html#p260">Abstract Classes and Methods</a></li>
<li class="calibre7"><a href="index_split_004.html#p263">How pygwidgets Uses Inheritance</a></li>
<li class="calibre7"><a href="index_split_004.html#p265">Class Hierarchy</a></li>
<li class="calibre7"><a href="index_split_004.html#p267">The Difficulty of Programming with Inheritance</a></li>
<li class="calibre7"><a href="index_split_004.html#p268">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_004.html#p270">Chapter 11: Managing Memory Used by Objects</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_005.html#p271">Object Lifetime</a></li>
<li class="calibre7"><a href="index_split_005.html#p277">Class Variables</a></li>
<li class="calibre7"><a href="index_split_005.html#p280">Putting It All Together: Balloon Sample Program</a></li>
<li class="calibre7"><a href="index_split_005.html#p290">Managing Memory: Slots</a></li>
<li class="calibre7"><a href="index_split_005.html#p292">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_005.html#p294">Part IV: Using OOP in Game Development</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_005.html#p296">Chapter 12: Card Games </a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_005.html#p297">The Card Class</a></li>
<li class="calibre7"><a href="index_split_005.html#p299">The Deck Class</a></li>
<li class="calibre7"><a href="index_split_005.html#p301">The Higher or Lower Game</a></li>
<li class="calibre7"><a href="index_split_005.html#p305">Testing with __name__</a></li>
<li class="calibre7"><a href="index_split_005.html#p307">Other Card Games</a></li>
<li class="calibre7"><a href="index_split_005.html#p308">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_005.html#p310">Chapter 13: Timers</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_005.html#p311">Timer Demonstration Program</a></li>
<li class="calibre7"><a href="index_split_005.html#p312">Three Approaches for Implementing Timers</a></li>
<li class="calibre7"><a href="index_split_005.html#p316">Installing pyghelpers</a></li>
<li class="calibre7"><a href="index_split_005.html#p316">The Timer Class</a></li>
<li class="calibre7"><a href="index_split_005.html#p319">Displaying Time</a></li>
<li class="calibre7"><a href="index_split_005.html#p323">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_005.html#p324">Chapter 14: Animation</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_005.html#p325">Building Animation Classes</a></li>
<li class="calibre7"><a href="index_split_006.html#p333">Animation Classes in pygwidgets</a></li>
<li class="calibre7"><a href="index_split_006.html#p339">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p340">Chapter 15: Scenes</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_006.html#p341">The State Machine Approach</a></li>
<li class="calibre7"><a href="index_split_006.html#p343">A pygame Example with a State Machine</a></li>
<li class="calibre7"><a href="index_split_006.html#p348">A Scene Manager for Managing Many Scenes</a></li>
<li class="calibre7"><a href="index_split_006.html#p349">A Demo Program Using a Scene Manager</a></li>
<li class="calibre7"><a href="index_split_006.html#p357">Rock, Paper, Scissors Using Scenes</a></li>
<li class="calibre7"><a href="index_split_006.html#p361">Communication Between Scenes</a></li>
<li class="calibre7"><a href="index_split_006.html#p363">Implementation of the Scene Manager</a></li>
<li class="calibre7"><a href="index_split_006.html#p369">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p370">Chapter 16: Full Game: Dodger</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_006.html#p371">Modal Dialogs</a></li>
<li class="calibre7"><a href="index_split_006.html#p376">Building a Full Game: Dodger</a></li>
<li class="calibre7"><a href="index_split_007.html#p395">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_007.html#p396">Chapter 17: Design Patterns and Wrap-Up</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_007.html#p396">Model View Controller</a></li>
<li class="calibre7"><a href="index_split_007.html#p403">Wrap-Up</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_007.html#p406">Index</a></li>
</ul><p class="calibre1"/>


</body></html>