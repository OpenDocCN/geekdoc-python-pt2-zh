<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="1" id="Page_1"/>Part I</span><br/>
<span class="PartTitle">THE PYTHON ENVIRONMENT</span></h1>
</header>
</section>
</div>
<div id="sbo-rt-content"><section>

<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="3" id="Page_3"/>1</span><br/>
<span class="ChapterTitle">The Python Philosophy</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">I believe the best place to start learning Python is not with the language itself, but with the guiding philosophy driving it. To write good Python code, you must first understand what Python is. That’s what this chapter will focus on.</p>
<h2 id="h1-500920c01-0001">What Is Python, Exactly?</h2>
<p class="BodyFirst">Python is a programming language developed in 1991 by Dutch programmer Guido van Rossum. The name refers not to the snake often used as a mascot, but to <em>Monty Python’s Flying Circus</em> (that fact alone should tell you a lot about the mindset behind the language). What began as a hobby project over Christmas break turned into one of the most perennially popular computer languages today.</p>
<p><span epub:type="pagebreak" title="4" id="Page_4"/>From a technical perspective, Python is considered a high-level, general-purpose language, with full support for the procedural, object-oriented, and functional programming paradigms, among others.</p>
<p>Fans of Python are quick to point out its famous readability and simplicity, which lend to an initial feeling that the language is “magic.” This has also given rise to a less-than-useful bit of advice for newcomers: “Python is easy; it’s just pseudocode!”</p>
<p>That isn’t strictly true. Don’t let the natural readability fool you: Python is beautifully unique and influenced by many other languages, but it often bears little resemblance to any of them. To truly master it, one must take it by itself, not in strong comparison to other languages. That is exactly what this book will do.</p>
<p>Most importantly, however, Python is an idea. It’s the collective creation of a diverse group of nerds, united by nothing more than an audacious desire to build an awesome programming language. When you truly understand Python, it alters your entire perspective. You’re a part of something larger; something that has taken on a life of its own.</p>
<p>As Guido van Rossum explained in his famous King’s Day speech:</p>
<blockquote class="blockquote">
<p class="Blockquote">I believe the most important idea is that Python is developed on the Internet, entirely in the open, by a community of volunteers (but not amateurs!) who feel passion and ownership.</p>
</blockquote>
<h2 id="h1-500920c01-0002">Myths: What Python Isn’t</h2>
<p class="BodyFirst">There are a lot of myths about Python, many of which lead to people shunning the language for certain applications, if not altogether.</p>
<h3 id="h2-500920c01-0001">Myth #1: Python Is Merely a Scripting Language</h3>
<p class="BodyFirst">I consider “scripting language” to be one of the most insidious terms used in discussing programming languages. It implies that the language is somehow unsuited for writing “real” software (see Myth #5).</p>
<p>Python is <em>turing-complete</em>, which means that you could implement any programming language in Python and then be able to execute any program written in that language.</p>
<p>To put that another way, anything another programming language can do, Python can do. Whether it’s easy, or even advisable, depends on what you’re attempting.</p>
<h3 id="h2-500920c01-0002">Myth #2: Python Is Slow</h3>
<p class="BodyFirst">It’s easy to assume that high-level or interpreted languages like Python are naturally slower than compiled or low-level languages like C. In truth, it depends on the implementation of the language and how it’s used. In this book, we’ll cover several concepts related to improving the performance of Python code.</p>
<p><span epub:type="pagebreak" title="5" id="Page_5"/>The default implementation of the Python language interpreter, CPython, is written in C, and it is indeed slower than native machine code. However, there are various libraries and techniques—as well as other implementations of the language, including PyPy—which have much better performance overall (see <span class="xref" itemid="xref_target_Chapter 21">Chapter 21</span>) and even approach the speed of native machine code.</p>
<p>With all that said, you should understand how performance actually factors into your project. In most situations, Python is plenty fast enough to be a good choice for application development, data analysis, scientific computing, game development, web development, and the list goes on. The performance drawbacks inherent in CPython usually only become problematic when you are dealing with very specific scenarios demanding extraordinarily high performance. Even then, there are ways around the bottlenecks. For the majority of projects, Python’s baseline performance is more than sufficient.</p>
<h3 id="h2-500920c01-0003">Myth #3: Python Cannot Be Compiled</h3>
<p class="BodyFirst">Python is an <em>interpreted language</em>, meaning the code is read, interpreted, and executed at runtime by the language’s <em>interpreter</em>. An end user running a project written in Python will typically have to have the Python interpreter installed.</p>
<p>This contrasts with what I like to call <em>assembled languages</em>, like C, C++, or FORTRAN. In these languages, the final result of compilation is machine code, which can be executed directly on any compatible computer without needing an additional program on that machine (or somehow bundled with the code).</p><p/>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>PEDANTIC NOTE</h2><p class="BoxBodyFirst">There’s a surprising amount of contention about the term <em>compiled language</em>, which is why I like to use the terms <em>interpreted</em> and <em>assembled</em> to differentiate. This is a rather deep rabbit hole.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Many developers take this to mean that Python cannot be compiled (assembled) to machine code, which seems like the obvious corollary. In fact, it is possible to compile Python to machine code, although this is rarely necessary and seldom done.</p>
<p>If you want to go this route, there are a few options. On UNIX, the built-in <em>Freeze</em> tool transpiles to C arrays of Python bytecode, and then it assembles this C code to machine code. This doesn’t result in truly assembled Python code, however, because the Python interpreter must still be invoked behind the scenes. Freeze only works on UNIX systems. The <em>cx_Freeze</em> tool, as well as <em>py2exe</em> on Windows, does much the same thing as Freeze.</p>
<p>To truly compile Python to machine code, you must use an intermediary language. <em>Nuitka</em> can be used to transpile Python code C and C++, which can then be assembled to machine code. You can also transpile Python to Java with <em>VOC</em>. <em>Cython</em> also allows transpiling a specialized form of Python to C, although it’s primarily geared toward writing Python extensions in C.</p>
<h3 id="h2-500920c01-0004"><span epub:type="pagebreak" title="6" id="Page_6"/>Myth #4: Python Gets Compiled Behind the Scenes</h3>
<p class="BodyFirst">The Python interpreter converts code to <em>bytecode</em>, which is then executed. The interpreter includes a <em>virtual machine</em>, which executes the Python bytecode similarly to how a CPU executes machine code. Sometimes, the interpreter will do the conversion to bytecode in advance, for performance reasons, generating <em>.pyc</em> files containing bytecode. While this is “compiling” in one sense of the term, there is a key difference between compiling to bytecode and compiling to machine code: bytecode is still run through the interpreter, whereas machine code executes directly, without needing an additional program. (Technically, “compiling” to machine code is called <em>assembling</em>, although this distinction is often neglected or overlooked.)</p>
<p>In practice, the majority of Python projects ship as source code, or at least Python bytecode, which is run in the Python interpreter installed on the user’s machine. There are occasions when a standard executable is preferable, such as for ease of installation on end-user computers or in closed-source projects. For those situations, tools such as <em>PyInstaller</em> and <em>cx_Freeze</em> exist. These don’t compile the code, but rather bundle the Python source code or bytecode with the interpreter so it can be executed by itself (see <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>).</p>
<h3 id="h2-500920c01-0005">Myth #5: Python Is Unsuitable for Large Projects</h3>
<p class="BodyFirst">I’ve heard some developers say, “Python is only useful if the whole project fits in one file.” This adage is partially based on the misconception that Python projects with multiple files are confusingly structured. This indeed tends to be the trend, but only because so few developers know how to correctly structure a Python project.</p>
<p>In reality, project structure in Python is far simpler than in C++ and Java. Once the developer understands the concepts of packages, modules, and the import system (see <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>), working with multiple code files becomes trivial.</p>
<p>Another reason for this myth has to do with the fact that Python is dynamically typed, rather than statically typed like Java or C++, which some believe makes refactoring harder. This doesn’t have to be the case, once the developer knows how to work with Python’s type system, instead of against it (see <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>).</p>
<h2 id="h1-500920c01-0003">Python 2 vs. Python 3</h2>
<p class="BodyFirst">For many years, there existed two major versions of Python. Starting in 2001, <em>Python 2</em> was the standard, meaning most books and articles about Python were written for this version. The last release was Python 2.7.</p>
<p>The current version is <em>Python 3</em>, known during its development as <em>Python 3000</em> or <em>Py3k</em>. From its release in 2008 until 2019, we were in a sort of limbo between the two versions; a lot of existing code and packages were written in Python 2, while Python 3 was increasingly recommended for new projects that didn’t require legacy support. Many techniques and tools existed <span epub:type="pagebreak" title="7" id="Page_7"/>for writing code that could run in either version, which eased the transition for many existing projects.</p>
<p>In more recent years, especially since the release of Python 3.5, we’ve begun moving away from Python 2 altogether. Most major libraries officially supported Python 3, and legacy support became less of a priority.</p>
<p>As of January 1, 2020, Python 2 has been officially retired, and Python 3 is the definitive standard. Since Python 4 is still nothing more than a vague wisp of a rumor at this point, it’s safe to say that Python 3 will be with us for years to come.</p>
<p>Unfortunately, many software development teams have been slow (sometimes unavoidably) about porting their code bases from Python 2 to Python 3. This has left a lot of projects in limbo. If you use Python in a professional capacity, there is a good chance you’ll have to help transition some code to Python 3. Python’s standard library includes a tool called <em>2to3</em>, which helps automate this process. Running the code through this tool is a good first step, but you will still need to manually update the code to use some of the newer patterns and tools Python 3 has to offer.</p>
<h2 id="h1-500920c01-0004">Defining “Pythonic” Code</h2>
<p class="BodyFirst">Among Python developers, you’ll hear a lot of talk about <em>Pythonic</em> code and what it constitutes, precisely. In a general sense, idiomatic code that makes good use of the language’s features is considered Pythonic.</p>
<p>Unfortunately, this is very much open to interpretation. As a result, the topic of best practices in Python is a regular source of heated debate in the community. Don’t be alarmed by this. By regularly grappling with our own conventions and standards, we continually improve them and our own understanding along the way.</p>
<p>Our tendency to debate best practices in Python is rooted in our philosophy of <em>There’s Only One Way To Do It (TOOWTDI)</em>, a phrase coined by PythonLabs in 2000 as a tongue-in-cheek response to the Perl community’s own adage of <em>There’s More Than One Way To Do It (TMTOWTDI)</em>. Despite the historic rivalry between these communities, these philosophies aren’t strictly opposing.</p>
<p>Python developers rightly assume there is some single, quantifiably “best” solution to any specific problem. Our task is to figure out what that solution is, but we also know we will often fall far short of the goal. Through continual discussion, debate, and experimentation, we refine our approaches in pursuit of the theoretical Best Solution.</p>
<p>In the same way, the Perl community understands that it is often impossible to definitively arrive at that Best Solution, so they emphasize experimentation instead of compliance with strict standards, in an effort to discover better and better solutions.</p>
<p>In the end, the goal is the same: to ultimately define the best possible solution to a problem. Only the emphasis differs.</p>
<p>In this book, I’ll focus a lot on the generally accepted Pythonic ways of writing code. However, I don’t claim to be the final authority. My colleagues <span epub:type="pagebreak" title="8" id="Page_8"/>in the Python community will always have plenty to add to these discussions. I never fail to learn something new from them!</p>
<h2 id="h1-500920c01-0005">The Zen of Python</h2>
<p class="BodyFirst">In 1999, a discussion started on the official Python mailing list about the need to write down some sort of formal guiding principles for the language. Tim Peters, a prominent member of the community, jokingly laid out a poetic summary of 19 principles to serve as an outline, leaving the 20th spot open for Guido van Rossum to complete (which he never did).</p>
<p>Other community members quickly seized on this summary as a fantastic overview of Python’s philosophy, ultimately adopting it wholesale as <em>The Zen of Python</em>. The entire text is published by Python as PEP 20.</p>
<blockquote class="blockquote">
<p class="Blockquote">Beautiful is better than ugly.</p>

<p class="Blockquote">Explicit is better than implicit.</p>
<p class="Blockquote">Simple is better than complex.</p>
<p class="Blockquote">Complex is better than complicated.</p>
<p class="Blockquote">Flat is better than nested.</p>
<p class="Blockquote">Sparse is better than dense.</p>
<p class="Blockquote">Readability counts.</p>
<p class="Blockquote">Special cases aren’t special enough to break the rules.</p>
<p class="Blockquote">Although practicality beats purity.</p>
<p class="Blockquote">Errors should never pass silently.</p>
<p class="Blockquote">Unless explicitly silenced.</p>
<p class="Blockquote">In the face of ambiguity, refuse the temptation to guess.</p>
<p class="Blockquote">There should be one—and preferably only one—obvious way to do it.</p>
<p class="Blockquote">Although that way may not be obvious at first unless you’re Dutch.</p>
<p class="Blockquote">Now is better than never.</p>
<p class="Blockquote">Although never is often better than *right* now.</p>
<p class="Blockquote">If the implementation is hard to explain, it’s a bad idea.</p>
<p class="Blockquote">If the implementation is easy to explain, it may be a good idea.</p>
<p class="Blockquote">Namespaces are one honking great idea—let’s do more of those!</p></blockquote>
<p>This, too, is open to interpretation, and some argue that Tim Peters was kidding when he wrote The Zen of Python. However, if there’s one thing <span epub:type="pagebreak" title="9" id="Page_9"/>I’ve learned about Python developers, it’s that the line between “kidding” and “serious” is fine as spider silk.</p>
<p>In any case, The Zen of Python is a great place to start when talking about best practices in Python. Many developers, including myself, often refer back to it. I’ll refer to it frequently throughout this book.</p>
<h2 id="h1-500920c01-0006">Documentation, PEPs, and You</h2>
<p class="BodyFirst"><em>Dead Simple Python</em> is intended as a beginning, not an ending, to your learning journey. Once you are well acquainted with the Python language, you can turn to the language’s extensive official documentation to learn more about any particular features or tools. These docs are found online at <a href="https://docs.python.org/" class="LinkURL">https://docs.python.org/</a>.</p>
<p>Any new feature in Python begins its life as a <em>Python Enhancement Proposal</em> (PEP). Each is assigned a unique number and published to the official PEP index at <a href="https://python.org/dev/peps/" class="LinkURL">https://python.org/dev/peps/</a>. Once proposed, a PEP will be considered, discussed, and ultimately accepted or rejected.</p>
<p>Accepted PEPs are effectively extensions of the documentation, as they are the most cohesive and authoritative descriptions of the feature(s) they define. Additionally, there are several Meta-PEPs and Informational PEPs that provide the backbone for the Python community and language.</p>
<p>As such, the official documentation and PEP index should be the first place you go if you have any questions about Python. I’ll refer to these frequently throughout this book.</p>
<h2 id="h1-500920c01-0007">Who Calls the Shots?</h2>
<p class="BodyFirst">To understand how and why the language evolves, it is important to know who’s in charge. When a PEP is proposed, who gets to decide if it’s accepted or rejected?</p>
<p>Python is an open source project officially owned by the nonprofit Python Software Foundation. Unlike many other popular languages, no formal associations exist between Python and any for-profit organization.</p>
<p>As an open source project, Python is supported by an active and vibrant community. At its heart is the core team, the trusted volunteers who maintain the language and keep the community running smoothly.</p>
<p>Language creator Guido van Rossum served as the Benevolent Dictator for Life (BDFL), making the final decisions on all PEPs and overseeing ongoing development of the language. In 2018, he made the decision to step down from the role.</p>
<p>A few months after his resignation, PEP 13 was created to establish a new system of governance. Now the language is governed by a five-person steering committee, elected by the core team. Every time a new release of the language comes out, a new steering committee is elected.</p>
<h2 id="h1-500920c01-0008"><span epub:type="pagebreak" title="10" id="Page_10"/>The Python Community</h2>
<p class="BodyFirst">The Python community is a vast and diverse group of individuals from all over the world, united by their passion for this unique language. Ever since I stumbled upon the community many years ago as an utter novice, I have gained immeasurable help, guidance, and inspiration from it and its people. I’ve been privileged to offer the same to others in return. This book would not have ever happened without the continual feedback of my Python friends!</p>
<p>The Python community is moderated by the core team and governed by the Python Code of Conduct. In short, it emphasizes open, considerate, and respectful behavior, summarizing itself as follows:</p>
<blockquote class="blockquote">
<p class="Blockquote">Overall, we’re good to each other. We contribute to this community, not because we have to, but because we want to. If we remember that, these guidelines will come naturally.</p>
</blockquote>
<p>I strongly encourage any developer who uses Python to plug into this vibrant community. One of the best ways to participate is through the Libera.Chat IRC <code>#python</code> chatroom. You can find guides to getting onto IRC at <a href="https://python.org/community/" class="LinkURL">https://python.org/community/</a>.</p>
<p>If you have any questions about Python, including while you read through this book, I recommend asking for help in the IRC channel. Chances are, you’ll find me and most of my technical editors there.</p>
<p>In <span class="xref" itemid="xref_target_Chapter 21">Chapter 21</span>, I’ll discuss the many facets of the Python community.</p>
<h2 id="h1-500920c01-0009">The Pursuit of the One Obvious Way</h2>
<p class="BodyFirst">The Python mantra “There’s Only One Way to Do It” can be quite confusing at first. There are many possible ways to solve any one problem. Are Pythonistas just too enamored with their own ideas?</p>
<p>Thankfully, no. This mantra means something much more encouraging, and it’s something every Python developer should understand.</p>
<p>Some insight comes from The Zen of Python, which includes this rather cryptic quip:</p>
<blockquote class="blockquote">
<p class="Blockquote">There should be one—and preferably only one—obvious way to do it.</p>

<p class="Blockquote">Although that way may not be obvious at first unless you’re Dutch.</p></blockquote>
<p>Tim Peters was, of course, referring to language creator Guido van Rossum, a Dutch national. As the creator of the language, Guido could usually cut right to the “most obvious way” of solving problems in Python, especially in the early days of the language.</p>
<p>This <em>obvious way</em> is Python’s term for “the best solution”—a marriage of good practice, clean style, and reasonable efficiency, resulting in elegant code that is comprehensible to even the greenest novice.</p>
<p>The details of the problem being solved will usually inform this “obvious way”: one situation may call for a loop, another for recursion, and yet <span epub:type="pagebreak" title="11" id="Page_11"/>another for a list comprehension. Contrary to the usual implications of the word <em>obvious</em>, the solution is often anything but simple to work out. The best solution is only obvious <em>once you know it</em>; arriving at it is where things get tricky. Most of us aren’t Guido.</p>
<p>However, the <em>pursuit</em> of the “one obvious way” is a defining facet of the Python community, and it has had a profound impact on <em>Dead Simple Python</em>. A lot of the insights in this book were born out of sometimes intense debate between myself and my fellow Pythonistas. For this reason, I hand-selected my panel of technical editors from those colleagues who are commonly in opposition to me, and often each other, on pedantic technical points.</p>
<p>Anything ultimately adopted as the “right way” to solve a problem is usually accepted as such because of its technical merit, rather than because of some like-minded bias among Python developers, who are among the most exacting folks I’ve had the privilege of working with. This approach to logic overflows into every other conversation we have (which leads to some rather amazing and enlightening academic debates).</p>
<p>New situations present themselves regularly. There will never come a point in any Python developer’s career when coding becomes truly “easy.” Situations will arise in every project that demand careful consideration, and often, debate. Developers must attempt to solve problems in the way that seems most obvious to them, then submit the solution to the critique of peers.</p>
<p>The approaches in this book are, in many cases, the most obvious according to my view. Most have been seconded by my colleagues, yet I dare not assert that I am altogether “Dutch” in the Python sense. If you find yourself debating techniques in the Python community, please do not wave this book in anyone’s face as evidence that your solution is best! Skill in finding an obvious solution is not something that can be taught; rather it is only learned through practice.</p>
<h2 id="h1-500920c01-0010">Wrapping Up</h2>
<p class="BodyFirst">Despite the many myths that have been tossed around over the years, Python is a versatile and technically sound language, capable of handling just about any problem you can throw at it. It’s a solid choice, whether you are writing automation, crunching massive datasets, building native user applications, implementing machine learning, or crafting web applications and APIs. Most importantly, Python is backed by a vibrant, diverse, and helpful community.</p>
<p>The key to success, then, is writing Python code that makes the most of the strengths and features of the language. The goal is not simply to write code that works, but to write code that both looks and behaves elegantly. The rest of this book will teach you how to do exactly that.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="13" id="Page_13"/>2</span><br/>
<span class="ChapterTitle">Your Workbench</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Your development environment is a major factor in how productive you’ll be in a language. Instead of contenting yourself with a bare-bones default shell, you’ll want to assemble a development environment worthy of any production-level project.</p>
<p>A good Python development environment usually consists of the language interpreter, the pip package manager, a <em>virtual environment</em>, a Python-oriented code editor, and one or more <em>static analyzers</em> to check your code for errors and problems. I’ll discuss each of these in this chapter. I’ll also introduce the style conventions common in Python and round out the chapter with a guided tour of the most common Python integrated development environments (IDEs).</p>
<h2 id="h1-500920c02-0001"><span epub:type="pagebreak" title="14" id="Page_14"/>Installing Python</h2>
<p class="BodyFirst">Before you can do anything, you have to install Python itself, along with a couple of essential tools. As you know from <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, Python is an interpreted language, so you’ll need to install its <em>interpreter</em>. You must also install pip, the Python package manager, so you can install additional Python tools and libraries. The exact steps for setup depend on your platform, but I will cover the major platforms here.</p>
<p>In this book, I’m using Python 3.9, the latest version at the time of writing. If you’re reading this at a later date, just use the latest stable release of Python 3. All the instructions should work the same. You need only replace the version number in the obvious ways on any commands run in the command line.</p>
<p>This is merely a quick guide to installation. For the complete, official instructions, which cover many more situations and advanced options, see <a href="https://docs.python.org/using/" class="LinkURL">https://docs.python.org/using/</a>.</p>
<h3 id="h2-500920c02-0001">Installing on Windows</h3>
<p class="BodyFirst">On Windows, Python is not generally installed by default, so you’ll need to download it yourself from <a href="https://python.org/downloads/windows/" class="LinkURL">https://python.org/downloads/windows/</a> and run that installer. On the first screen of the installer, be sure you check the boxes for <b>Install the launcher for all users</b> and <b>Add Python to PATH</b>.</p>
<p>Python is also available through the Windows App Store. However, as of the date of my writing, this particular installation method is still officially considered unstable. I recommend downloading the official installer instead.</p>
<h3 id="h2-500920c02-0002">Installing on macOS</h3>
<p class="BodyFirst">On macOS, you can use either MacPorts or Homebrew to install Python and pip.</p>
<p>Use the following commands to install Python and pip with MacPorts, replacing the <code>38</code> with whatever version you want to download (removing the decimal point):</p>
<pre><code>sudo port install python38 py38-pip
sudo port select --set python python38
sudo port select --set pip py38-pip</code></pre>
<p>Alternatively, here’s the command to install both Python and pip in one step with Homebrew:</p>
<pre><code>brew install python</code></pre>
<p>Use only one of the two methods described above.</p>
<h3 id="h2-500920c02-0003"><span epub:type="pagebreak" title="15" id="Page_15"/>Installing on Linux</h3>
<p class="BodyFirst">If you’re running a Linux operating system, chances are that Python (<code>python3</code>) is installed by default, although the other tools you need may not be. (I’ll show you how to install Python anyway, just to be on the safe side.)</p>
<p>To install Python and pip on Ubuntu, Debian, or related, run this command:</p>
<pre><code>sudo apt install python3 python3-pip python3-venv</code></pre>
<p>On Fedora, RHEL, or CentOS, you can run this:</p>
<pre><code>sudo dnf python3 python3-pip</code></pre>
<p>On Arch Linux, run this:</p>
<pre><code>sudo pacman -S python python-pip</code></pre>
<p>For other distributions, you’ll need to search for the Python 3 and pip packages yourself.</p>
<h3 id="h2-500920c02-0004">Installing from Source</h3>
<p class="BodyFirst">If you’re running a UNIX-like system, and if your system either has an outdated version of Python 3 in the system packages or lacks a package manager altogether, you can build Python from source. This is how I usually install the latest Python.</p>
<h4 id="h3-500920c02-0001">Installing Dependencies</h4>
<p class="BodyFirst">On macOS, there are some relatively complex considerations when it comes to installing Python’s build dependencies. You should consult the documentation at <a href="https://devguide.python.org/setup/#macos-and-os-x" class="LinkURL">https://devguide.python.org/setup/#macos-and-os-x</a>.</p>
<p>On most Linux systems, you will need to make sure you have the development files for several libraries that Python relies upon. The best way to install these depends on your system and, more specifically, which package manager you use.</p>
<p>If you’re on a Linux distribution that uses the APT package manager—such as Ubuntu, Pop!_OS, Debian, or Linux Mint—then you should either check the box to enable Source Code as a source in your Software Sources or Software &amp; Updates settings or make sure you have it included in your <em>sources.list</em> file. (The exact method depends on your system, and that topic is beyond the scope of this book.)</p>
<p>Then, run the following commands:</p>
<pre><code>sudo apt-get update
sudo apt-get build-dep python3.9</code></pre>
<p><span epub:type="pagebreak" title="16" id="Page_16"/>If you get the message <code>Unable to find a source package for python3.9</code>, change the <code>9</code> to a lower (or higher) number until you find one that works. The dependencies for Python 3 don’t really change much between minor versions.</p>
<p>If your Linux distribution uses the DNF package manager, such as if you’re on modern Fedora, RHEL, or CentOS, run the following commands:</p>
<pre><code>sudo dnf install dnf-plugins-core
sudo dnf builddep python3</code></pre>
<p>If you’re on an older version of Fedora or RHEL that uses the yum package manager, run the following commands:</p>
<pre><code>sudo yum install yum-utils
sudo yum-builddep python3</code></pre>
<p>If you’re on SUSE Linux, you’ll have to install the dependencies, including needed libraries, one by one. <a href="#table2-1" id="tableanchor2-1">Table 2-1</a> lists these dependencies. If you’re on another UNIX-based system, this list will be helpful, although you may need to change the package names or build the dependencies from source.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1:</a> Python 3 Build Dependencies According to SUSE Linux</p></figcaption>
<table id="table-500920c02-0001" border="1"><tbody>
<tr>
<td>automake</td>
<td>intltool</td>
<td>netcfg</td>
</tr>
<tr>
<td>fdupes</td>
<td>libbz2-devel</td>
<td>openssl-devel</td>
</tr>
<tr>
<td>gcc</td>
<td>libexpat-devel</td>
<td>pkgconfig</td>
</tr>
<tr>
<td>gcc-c++</td>
<td>libffi-devel</td>
<td>readline-devel</td>
</tr>
<tr>
<td>gcc-fortran</td>
<td>libnsl-devel</td>
<td>sqlite-devel</td>
</tr>
<tr>
<td>gdbm-devel</td>
<td>lzma-devel</td>
<td>xz</td>
</tr>
<tr>
<td>gettext-tools</td>
<td>make</td>
<td>zlib-devel</td>
</tr>
<tr>
<td>gmp-devel</td>
<td>ncurses-devel</td>
<td/>
</tr>
</tbody>
</table>
</figure>
<h4 id="h3-500920c02-0002">Downloading and Building Python</h4>
<p class="BodyFirst">You can download the Python source as a Gzipped source tarball, which is a compressed file (<em>.tgz</em>), from <a href="https://www.python.org/downloads/source/" class="LinkURL">https://www.python.org/downloads/source/</a>. I usually like to move this tarball file into a dedicated directory for Python source tarballs, especially as I tend to have multiple versions of Python at any one time. Within that directory, extract (uncompress) this file with <code>tar -xzvf Python-3.x.x.tgz</code>, substituting the name of the tarball you downloaded.</p>
<p>Next, from within the extracted directory, run the following, ensuring that each command succeeds before running the next one:</p>
<pre><code>./configure --enable-optimizations
make
make altinstall</code></pre>
<p><span epub:type="pagebreak" title="17" id="Page_17"/>This should configure Python for normal use, ensure it won’t encounter any errors in the current environment, and then install it <em>alongside</em> any existing Python installations.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALERT</h2><p class="BoxBodyFirst">You should always run<code> make altinstall</code> if you have any other version of Python already installed. Otherwise, the existing installation may be overwritten or hidden, <em>breaking</em> your system! If you are absolutely certain this is the first Python installation on the system, <em>only then</em> may you run <code>make install</code> instead.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Once the installation is complete, you can use Python right away.</p>
<h2 id="h1-500920c02-0002">Meet the Interpreter</h2>
<p class="BodyFirst">Now that you’ve installed that interpreter, you can run Python scripts and projects.</p>
<h3 id="h2-500920c02-0005">Interactive Session</h3>
<p class="BodyFirst">The interpreter’s <em>interactive session</em> allows you to enter and run code in real time and see the outcomes. You can start an interactive session on the command line with this command:</p>
<pre><code>python3</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Gotcha Alert</h2>	<p class="BoxBodyFirst">You should be in the habit of specifying <code>python2</code> or <code>python3</code>, instead of using the <code>python</code> command, since the latter may refer to the wrong version (which comes preinstalled on many systems, even today). You can always check the exact version of Python invoked by any of those three commands with the<code class="bold"> </code><code>--version</code> flag (for example, <code>python3 --version</code>).</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Although the above should work on Windows, the same as on any other system, the Python documentation recommends the following alternative on Windows instead:</p>
<pre><code>py.exe -3</code></pre>
<p>Just to keep everything system-agnostic, I’ll use <code>python3</code> throughout the rest of this book.</p>
<p>When you start the interactive session, you should see something that looks similar to this:</p>
<pre><code>Python 3.10.2 (default)
Type "help", "copyright", "credits" or "license" for more information.
&gt; </code></pre>
<p><span epub:type="pagebreak" title="18" id="Page_18"/>Enter any Python code you want at the prompt<code> &gt;</code>, and the interpreter will run it immediately. You can even enter multiline statements, such as conditional statements, and the interpreter will know more lines are expected before it runs the code. You’ll see the three-dot (<code>...</code>) prompt when the interpreter is waiting for more lines. When you’re done, press <span class="Caps">Enter</span> on a blank line, and the interpreter will run the whole block:</p>
<pre><code>&gt; <b>spam = True</b>
&gt; <b>if spam:</b>
...     <b>print("Spam, spam, spam, spam...")</b>
...
Spam, spam, spam, spam...</code></pre>
<p>To quit the interactive session, run this command:</p>
<pre><code>&gt; <b>exit()</b></code></pre>
<p>The interactive session is useful for testing things out in Python, but not much else. You should know of its existence moving forward, but I won’t use it much in this book. Instead, you should be using a proper code editor.</p>
<h3 id="h2-500920c02-0006">Running Python Files</h3>
<p class="BodyFirst">You write scripts and programs in a text or code editor. I’ll introduce several code editors and IDEs at the end of this chapter, but in the meantime, you can use your favorite text editor for writing your code.</p>
<p>Python code is written in <em>.py</em> files. To run a Python file (<em>myfile.py</em>, for example), you’d use this in the command line (<em>not</em> the interpreter):</p>
<pre><code>python3 myfile.py</code></pre>
<h2 id="h1-500920c02-0003">Packages and Virtual Environments</h2>
<p class="BodyFirst">A <em>package</em> is a collection of code, which is analogous to a library in most other programming languages. Python is rather famous for being “batteries included,” since most things “just work” with a simple <code>import</code> statement. But if you need to do something beyond the basics, such as creating a snazzy user interface, you often have to install a package.</p>
<p>Thankfully, installing most third-party libraries is easy. Library authors bundle their libraries into packages, which can be installed using the handy little pip package manager tool that we installed earlier. I’ll cover that tool later.</p>
<p>Using multiple third-party packages requires a bit of finesse. Some packages require other packages to be installed first. Certain packages have conflicts with other packages. You can also install specific versions of a package, depending on what exactly you need. Did I mention that some of the applications and operating system components on your <span epub:type="pagebreak" title="19" id="Page_19"/>computer rely on certain Python packages? This is why virtual environments exist.</p>
<p>A <em>virtual environment</em> is a sandbox where you can install only the Python packages you need for a particular project, without the risk of those packages clashing with those for another project (or your system). You create different little sandboxes for each project and install only the packages you want in it. Everything stays neatly organized. You never actually change what Python packages are installed on your system, so you avoid breaking important things that have nothing to do with your project.</p>
<p>You may even create virtual environments that have nothing to do with a particular project. For example, I have a dedicated virtual environment for running random code files in Python 3.10, with a particular set of tools I use for finding problems.</p>
<h3 id="h2-500920c02-0007">Creating a Virtual Environment</h3>
<p class="BodyFirst">Each virtual environment resides in a dedicated directory. Conventionally, we name this folder <em>env</em> or <em>venv</em>.</p>
<p>For each project, I typically like to create a dedicated virtual environment inside the project folder. Python provides a tool called <em>venv</em> for this.</p>
<p>If you use Git or another <em>version control system</em> <em>(VCS)</em> for tracking changes to your code, there’s an additional setup step I’ll get to in a moment.</p>
<p>To create the virtual environment with the name <code>venv</code> in the current working directory, run the following command in the command line:</p>
<pre><code>python3 -m <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> venv <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> venv</code></pre>
<p>The first <code>venv</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> is a command that creates a virtual environment, and the second <code>venv</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span> is the desired path to the virtual environment. In this case, <code>venv</code> is just a relative path, creating a <em>venv/</em> directory in the current working directory. However, you could also use an absolute path, and you could call it whatever you want. For example, you could create a virtual environment called <em>myvirtualenv</em> in the <em>/opt</em> directory of a UNIX system, like this:</p>
<pre><code>python3 -m venv /opt/myvirtualenv</code></pre>
<p>Note, I’m specifying <code>python3</code> here, although I can run this with whatever Python version I want to use, such as <code>python3.9 -m venv venv</code>.</p>
<p>If you use something older than Python 3.3, make sure you install your system’s <code>virtualenv</code> package and then use this command:</p>
<pre><code>virtualenv -p python3 venv</code></pre>
<p>Now if you look at your working directory, you’ll notice that the directory <em>venv/</em> has been created.</p>
<h3 id="h2-500920c02-0008"><span epub:type="pagebreak" title="20" id="Page_20"/>Activating a Virtual Environment</h3>
<p class="BodyFirst">To use your virtual environment, you need to activate it.</p>
<p>On UNIX-like systems, run this command:</p>
<pre><code>$ <b>source venv/bin/activate</b></code></pre>
<p>On Windows, run this:</p>
<pre><code>&gt; <b>venv\Scripts\activate.bat</b></code></pre>
<p>Alternatively, if you use PowerShell on Windows, run this:</p>
<pre><code>&gt; <b>venv\Scripts\activate.ps1</b></code></pre>
<p>Some PowerShell users must first run <code>set-executionpolicy RemoteSigned</code> for virtual environments to work on Windows PowerShell. If you run into trouble, try this.</p>
<p>Like magic, you’re now using your virtual environment! You should see <code>(venv)</code> at the start of your command line prompt (not at the end), to indicate that you’re using a virtual environment named <code>venv</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALert</h2><p class="BoxBodyFirst">If you have multiple shells (usually terminal windows) open, you should be aware that the virtual environment is only active for the one shell you explicitly activated it in! On shells that support it, look for the <code>(venv)</code> notation to make sure you’re using the virtual environment.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>While inside your virtual environment, you can still access all the same files on your system that you use outside the virtual environment, but your environment <em>paths</em> will be overridden by the virtual environment. Practically speaking, any packages you install in the virtual environment are only usable there, and from the <code>venv</code>, the system-wide packages cannot be accessed unless you explicitly specify otherwise.</p>
<p>If you want the virtual environment to also see the system-wide packages, you can do so with a special flag, which has to be set when you first create the virtual environment. You can’t change this after the virtual environment is created.</p>
<pre><code>python3 -m venv <b>--system-site-packages</b> venv</code></pre>
<h3 id="h2-500920c02-0009">Leaving a Virtual Environment</h3>
<p class="BodyFirst">To get out of the virtual environment and back to reality . . . er, <em>ahem</em>, the system, you need a simple command.</p>
<p>You ready for this, UNIX users? Just run this:</p>
<pre><code>$ <b>deactivate</b></code></pre>
<p>That really is it. The same works for Windows PowerShell users.</p>
<p><span epub:type="pagebreak" title="21" id="Page_21"/>Things are only slightly more complicated on the Windows command line:</p>
<pre><code>&gt; <b>venv\Scripts\deactivate.bat</b></code></pre>
<p>Still pretty painless. Remember, like with activation, if you named your virtual environment something else, you’d have to change the <code>venv</code> in that line accordingly.</p>
<h2 id="h1-500920c02-0004">Introducing pip</h2>
<p class="BodyFirst">Most of us have great expectations for Python’s package system. Python’s package manager is <em>pip</em>, which usually makes package installation trivial, especially in virtual environments.</p>
<h3 id="h2-500920c02-0010">System-Wide Packages</h3>
<p class="BodyFirst">Remember, for any Python development work, you should almost always work in virtual environments. This will ensure that you’re always using the right packages for your work, without potentially messing up which packages (and versions thereof) are available to other programs on your computer. If you absolutely, positively know you want to install packages in your system-wide Python environment, you may use pip for that as well. First, make sure you are <em>not</em> working in a virtual environment, and then use this:</p>
<pre><code>python3 -m pip <var>command</var></code></pre>
<p>Replace the <var>command</var> with your pip commands, which I’ll cover next.</p>
<h3 id="h2-500920c02-0011">Installing Packages</h3>
<p class="BodyFirst">To install a package, run <code>pip install </code><var>package</var>. For example, to install PySide6 within an activated virtual environment, you’d use this:</p>
<pre><code>pip install PySide6</code></pre>
<p>If you want to install a specific version of something, append two equal signs (<code>==</code>), followed by the desired version number (no spaces):</p>
<pre><code>pip install PySide6==6.1.2</code></pre>
<p>Bonus: you can even use operators like <code>&gt;=</code>, to mean “at least this version or greater.” These are called <em>requirement specifiers</em>.</p>
<pre><code>pip install PySide6&gt;=6.1.2</code></pre>
<p>That line would install the latest version of PySide6 that is at least version <code>6.1.2</code>. This is really helpful if you want the most recent version of a package but also want to ensure you at least install a <em>minimum</em> version of a package (you might not). If it isn’t possible to install a version of the package that meets the requirement, pip will display an error message.</p>
<p><span epub:type="pagebreak" title="22" id="Page_22"/>If you’re on a UNIX-like system, you may need to use <code>pip install "PySide6&gt;=6.1.2"</code> instead, since <code>&gt;</code> has another meaning in the shell.</p>
<h3 id="h2-500920c02-0012">requirements.txt</h3>
<p class="BodyFirst">You can save even more time for yourself and others by writing a <em>requirements.txt</em> file for your project. This file lists the packages your project needs. When creating a virtual environment, you and other users can install all the required packages with a single command, using this file.</p>
<p>To create this file, list the name of a pip package, as well as its version (if required), on each line. For example, one of my projects has a <em>requirements.txt</em> file like this:</p>
<pre><code>PySide2&gt;=5.11.1
appdirs</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: <em>requirements.txt</em></p>
<p>Now anyone can install all those packages in one shot with this command:</p>
<pre><code>pip install -r requirements.txt</code></pre>
<p>I’ll revisit <em>requirements.txt</em> in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, when I cover packaging and distribution.</p>
<h3 id="h2-500920c02-0013">Upgrading Packages</h3>
<p class="BodyFirst">You can update an already-installed package with pip as well. For example, to update to the latest version of PySide6, run this:</p>
<pre><code>pip install --upgrade PySide6</code></pre>
<p>If you have a <em>requirements.txt</em> file, you can also upgrade all your required packages at once:</p>
<pre><code>pip install --upgrade -r requirements.txt</code></pre>
<h3 id="h2-500920c02-0014">Removing Packages</h3>
<p class="BodyFirst">You can remove packages with this command:</p>
<pre><code>pip uninstall <var>package</var></code></pre>
<p>Replace <var>package</var> with the package name.</p>
<p>There is one minor wrinkle. Installing one package will also install any other packages it relies upon, which we call its <em>dependencies</em>. Uninstalling a package does not remove its dependencies, so you may need to go through and remove them yourself. This can get tricky, since multiple packages may share dependencies and you therefore risk breaking a separate package.</p>
<p><span epub:type="pagebreak" title="23" id="Page_23"/>Herein lies one more advantage of virtual environments. Once I’m in that sort of a pickle, I can delete the virtual environment, create a new one, and install only those packages I need.</p>
<h3 id="h2-500920c02-0015">Finding Packages</h3>
<p class="BodyFirst">Great, so now you can install, upgrade, and remove things. But how do you even know what packages pip has to offer?</p>
<p>There are two ways to find out. The first is to use pip itself to run a search. Say you want a package for web scraping. Run this command:</p>
<pre><code>pip search web scraping</code></pre>
<p>That will give you a whole ton of results to sift through, but it’s helpful at those times when you simply forget the name of a package.</p>
<p>If you want something a lot more browsable and informative, <a href="https://pypi.org/%20" class="LinkURL">https://pypi.org/ </a>is the official Python Package Index.</p>
<h3 id="h2-500920c02-0016">One Warning About pip . . .</h3>
<p class="BodyFirst">Unless you have expertise in the full technical implications, <b><i>never</i></b> use <code>sudo pip</code> on a UNIX-like system! It can do so many bad things to your system installation—things that your system package manager cannot correct—that if you decide to use it, you will regret it for the remainder of your system’s lifetime.</p>
<p>Usually, when someone thinks they need to use <code>sudo pip</code>, they should really use <code>python3 -m pip</code> or <code>pip install --user</code> to install to their local user directory. Most other problems can be solved with virtual environments. Unless you’re an expert who fully understands what you’re doing and how to reverse it, don’t <em>ever</em> use <code>sudo pip</code>!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">Seriously. Never use <code>sudo pip</code>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c02-0005">Virtual Environments and Git</h2>
<p class="BodyFirst">Working with virtual environments and a VCS, like Git, can be tricky. Within a virtual environment’s directory are the <em>actual packages</em> you installed with pip. Those would clutter up your VCS repository with big, unnecessary files, and you can’t necessarily copy a virtual environment folder from one computer to another and expect it to work anyway.</p>
<p>Thus, you <em>don’t</em> want to track these files in your VCS. There are two solutions:</p>
<ol class="decimal">
<li value="1">Only create virtual environments outside of your repository.</li>
<li value="2">Untrack the virtual environment directory in the VCS.</li>
</ol>
<p>There are arguments in favor of both rules, but which one you should use really depends on your project, environment, and particular needs.</p>
<p><span epub:type="pagebreak" title="24" id="Page_24"/>If you’re using Git, create or edit a file called <em>.gitignore</em> in the root directory of your repository. Add this line somewhere in it:</p>
<pre><code>venv/</code></pre>
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: <em>.gitignore</em></p>
<p>If you used a different name for your virtual environment, change that line to match. If you’re using a different VCS, like Subversion or Mercurial, check the documentation to see how to ignore a directory like <em>venv</em>.</p>
<p>Conventionally, every developer who clones your repository will build their own virtual environment, probably using that <em>requirements.txt</em> file you provided.</p>
<p>Even if you plan to place your virtual environments outside of the repository, it’s good to use your <em>.gitignore</em> file, just as a little extra insurance. Best VCS practice is to handpick which files to commit, but mistakes happen. Since <em>venv</em> is one of the most conventional names for a virtual environment directory, adding it to the <em>.gitignore</em> at least helps prevent some accidental commits. If your team has other standard names for virtual environments, you might consider adding those as well.</p>
<h3 id="h2-500920c02-0017">The Whole Shebang</h3>
<p class="BodyFirst">Many users and developers who might be running your code will also be using virtual environments. Yet all of this can come apart at the seams very easily if the very first line of your Python file is wrong.</p>
<p>I’m talking about the <em>shebang</em>, a special command at the top of a Python file, by which you can make that file directly executable:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span><span class="Regular"> </span>#!/usr/bin/env python3

print("Hello, world!")</code></pre>
<p class="CodeListingCaption"><a id="listing2-3">Listing 2-3</a>: <em>hello_world.py</em></p>
<p>The shebang (short for haSH-BANG, or <code>#!</code>) <span class="CodeAnnotation" aria-label="annotation1">❶</span> provides the path to the Python interpreter. While it’s optional, I strongly recommend including it in your code, as it means the file can be marked as executable and run directly, like this:</p>
<pre><code>./hello_world.py</code></pre>
<p>This is helpful, but as I’ve hinted before, one must be careful with shebangs. A shebang tells the computer where to find the exact Python interpreter to use, so the wrong shebang can break out of the confines of a virtual environment or even point to a version of the interpreter that isn’t installed.</p>
<p><span epub:type="pagebreak" title="25" id="Page_25"/>You may have seen this kind of shebang in the wild:</p>
<pre><code>#!/usr/bin/python</code></pre>
<p class="CodeListingCaption"><a id="listing2-4">Listing 2-4</a>: <em>shebang.py:1a</em></p>
<p>That line is terribly wrong, because it forces the computer to use a particular system-wide copy of Python. Again, that dismisses the entire purpose of a virtual environment.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE	</h2><p class="BoxBodyFirst">You may be wondering how <code>#!/usr/bin/python</code> would even be a valid path on Windows. It does function, thanks to some cleverness outlined in PEP 397. (You still should avoid using it.)</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Instead, you should always use this shebang for any Python file that only runs with Python 3:</p>
<pre><code>#!/usr/bin/<b>env python3</b></code></pre>
<p class="CodeListingCaption"><a id="listing2-5">Listing 2-5</a>: <em>shebang.py:1b</em></p>
<p>If you happen to have a script which runs in <em>both</em> Python 2 and Python 3, use this shebang instead:</p>
<pre><code>#!/usr/bin/env <b>python</b></code></pre>
<p class="CodeListingCaption"><a id="listing2-6">Listing 2-6</a>: <em>shebang.py:1c</em></p>
<p>The rules about shebangs and how they are handled are officially outlined in PEP 394 (for UNIX-like systems) and PEP 397 (for Windows systems). Regardless of which system you develop for, it’s good to understand the implications of shebangs in both UNIX and Windows.</p>
<h3 id="h2-500920c02-0018">File Encoding</h3>
<p class="BodyFirst">Since Python 3.1, all Python files have used the <em>UTF-8 encoding</em>, allowing the interpreter to use all of the characters in Unicode. (Prior to that version, the default was to use the old ASCII encoding.)</p>
<p>If you need to use a different encoding system, instead of the default UTF-8, you need to tell the Python interpreter that outright.</p>
<p>For example, to use Latin-1 encoding in a Python file, include this line at the top of your file, right below the shebang. To work, it must be on the first or second line—that’s where the interpreter looks for this information:</p>
<pre><code># -*- coding: latin-1 -*-</code></pre>
<p>If you want another encoding system, replace <code>latin-1</code> with whatever you need. If you specify an encoding that Python doesn’t recognize, it will throw an error.</p>
<p><span epub:type="pagebreak" title="26" id="Page_26"/>Although the preceding is the conventional way to specify encoding, there are two other valid ways to write the above comment. You can use this form, without the hard-to-remember <code>-*-</code>:</p>
<pre><code># coding: latin-1</code></pre>
<p>Or you can use this longer but more English-like form:</p>
<pre><code># This Python file uses the following encoding: latin-1</code></pre>
<p>Whatever you use, it must be <em>exactly</em> as shown above, except for swapping <code>latin-1</code> for whatever encoding you want. For this reason, the first or second forms are preferred.</p>
<p>To learn more, read PEP 263, which defined this feature.</p>
<p>Most of the time, you’ll be fine using the default UTF-8 encoding anyway; if you need something else, now you know how to inform the interpreter.</p>
<h2 id="h1-500920c02-0006">A Few Extra Virtual Environment Tricks</h2>
<p class="BodyFirst">As you get used to using virtual environments and pip, you’ll pick up additional tricks and tools to make the whole process easier. Here are a few of the more popular ones:</p>
<h3 id="h2-500920c02-0019">Using a Virtual Environment Without Activating</h3>
<p class="BodyFirst">You can use the binaries that are a part of the virtual environment without activating it. For example, you can execute <code>venv/bin/python</code> to run the virtual environment’s own Python instance, or <code>venv/bin/pip</code> to run its instance of pip. It’ll work the same as if you had activated the virtual environment.</p>
<p>For example, assuming my virtual environment is <code>venv</code>, I could do this in the terminal:</p>
<pre><code>venv/bin/pip install pylint
venv/bin/python

&gt; import pylint</code></pre>
<p>It works! Yet, <code>import pylint</code> still will not work on the system-wide Python interactive shell (unless, of course, you installed it on the system).</p>
<h3 id="h2-500920c02-0020">The Alternatives</h3>
<p class="BodyFirst">Throughout this book, I’ll be using pip and <code>venv</code>, as they’re the default tools for modern Python. However, there are a few other solutions out there worth looking into.</p>
<h4 id="h3-500920c02-0003"><span epub:type="pagebreak" title="27" id="Page_27"/>Pipenv</h4>
<p class="BodyFirst">A number of Python developers swear by <em>Pipenv</em>, which combines both pip and <code>venv</code> into one cohesive tool, with many additional features.</p>
<p>Because the workflow is quite different, I won’t cover Pipenv here. If you’re interested in it, I recommend reading their superb documentation at <a href="https://docs.pipenv.org/" class="LinkURL">https://docs.pipenv.org/</a>. You’ll find comprehensive setup and usage instructions there, as well as a more detailed explanation of the advantages Pipenv offers.</p>
<h4 id="h3-500920c02-0004">pip-tools</h4>
<p class="BodyFirst">A number of tasks in pip can be simplified with pip-tools, including automatic updating, aids for writing <em>requirements.txt</em>, and more.</p>
<p>If you use pip-tools, you should only install it within a virtual environment. It is designed specifically for that use case.</p>
<p>More information is available at <a href="https://pypi.org/project/pip-tools/" class="LinkURL">https://pypi.org/project/pip-tools/</a>.</p>
<h4 id="h3-500920c02-0005">poetry</h4>
<p class="BodyFirst">Some Python developers absolutely hate the entire pip workflow. One such developer created <em>poetry</em> as an alternative package manager. I don’t use it in this book, as it behaves very differently, but I’d be remiss not to point it out.</p>
<p>You can find more information, download directions (the creator does not recommend using pip to install it), and access documentation on their website: <a href="https://python-poetry.org/" class="LinkURL">https://python-poetry.org/</a>.</p>
<h2 id="h1-500920c02-0007">Introduction to PEP 8</h2>
<p class="BodyFirst">Unlike many languages, where style decisions are left entirely to the discretion of the community at large, Python does have an official style guide, which is published as <em>PEP 8</em>. Although the conventions in the guide are intended primarily for standard library code, many Python developers choose to stick to them as a rule.</p>
<p>That doesn’t make them mandatory: if you have an objective reason to follow a different style convention in your project, that’s fine, although you should apply that style consistently, as much as is reasonable.</p>
<p>PEP 8 itself makes this distinction clear, early on:</p>
<blockquote class="blockquote">
<p class="Blockquote">A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.</p>

<p class="Blockquote">However, know when to be inconsistent—sometimes, style guide recommendations just aren’t applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don’t hesitate to ask!</p></blockquote>
<p><span epub:type="pagebreak" title="28" id="Page_28"/>In practice, you’ll likely find very little reason to deviate from PEP 8. The style guide is far from all-encompassing. It leaves plenty of breathing room, while making it clear what constitutes a good or bad coding style.</p>
<h3 id="h2-500920c02-0021">The Line Limit Debate</h3>
<p class="BodyFirst">PEP 8 recommends a line limit of 79 characters, or an 80-character cutoff, though there’s a lot of debate on the topic. Some Python developers respect that rule, while others prefer cutoffs of 100 or 120 characters. What to do?</p>
<p>The most common argument for longer limits is that modern monitors are wider and higher resolution. Surely, the 80-character limit is a relic of a bygone era, right? <b><i>Definitely not!</i></b> There are several reasons to stick to a common line limit. For example:</p>
<ul>
<li>Vision-impaired individuals who must work with larger font sizes or zoomed-in interfaces</li>
<li>Viewing differences in a file between commits in a side-by-side diff</li>
<li>Split-screen editors, displaying multiple files simultaneously</li>
<li>Vertical monitors</li>
<li>Side-by-side windows on a laptop monitor, wherein the editor only has half its usual space</li>
<li>Individuals with older monitors, who cannot afford to upgrade to the latest 1080p monster</li>
<li>Viewing code on mobile devices</li>
<li>Writing coding books for No Starch Press</li>
</ul>
<p>In all of these scenarios, the reasoning behind the 80-character limit becomes apparent: there simply isn’t enough horizontal space for 120 characters or more per line. Soft text wrapping, wherein the remainder of a cut-off line appears on a separate line (without a line number), does solve some of these issues. However, it can be difficult to read, as many people forced to rely on it regularly will attest to.</p>
<p>This doesn’t mean that you have to follow this 79-character maximum religiously. There are exceptions. Above all, <em>readability</em> and <em>consistency</em> are the goals. Many developers embrace the 80/100 rule: an 80-character “soft” cutoff, you try to respect in most cases; and a 100-character “hard” cutoff, you reserve for all those cases where the lower limit would negatively impact readability.</p>
<h3 id="h2-500920c02-0022">Tabs or Spaces?</h3>
<p class="BodyFirst">Ah yes, the civil war over which many friendships have been strained and many relationships have abruptly ended (okay, maybe just that one?). Most programmers have strong feelings on the topic.</p>
<p><span epub:type="pagebreak" title="29" id="Page_29"/>PEP 8 recommends spaces over tabs, but technically, it allows either. The important thing is to <em>never mix the two</em>. Use either spaces or tabs, and stick to it throughout your entire project.</p>
<p>If you do use spaces, then there’s the debate about how many spaces to use. PEP 8 answers this question, too: <em>four spaces per indentation level</em>. Any less can negatively impact code readability, especially for people with visual impairments or some forms of dyslexia.</p>
<p>By the way, most code editors are able to automatically enter four spaces when they press <span class="Caps">Tab</span>, so there’s rarely an excuse to press <span class="Caps">space</span> repeatedly.</p>
<h2 id="h1-500920c02-0008">Quality Control: Static Analyzers</h2>
<p class="BodyFirst">One of the most useful tools in any programmer’s toolkit is a reliable <em>static analyzer</em>, which reads your source code, looking for potential problems or deviations from the standards. If you’ve never used one before, now is the time to change that. One common type of static analyzer, called a <em>linter</em>, checks your source code for common mistakes, potential errors, and style inconsistencies. Two of the most popular linters are <em>Pylint</em> and <em>PyFlakes</em>.</p>
<p>There are many more kinds of static analyzers available for Python, including static type checkers like <em>Mypy</em> and complexity analyzers like <em>mccabe</em>.</p>
<p>I’ll cover how to install all of these below, and I’ll discuss how to use many of them. I recommend you choose only one of these two linters and install the rest of the static analyzers.</p>
<h3 id="h2-500920c02-0023">Pylint</h3>
<p class="BodyFirst">Pylint is perhaps the most versatile static analyzer in Python. It works decently well by default, and it allows you to customize exactly what you want it to look for and ignore.</p>
<p>You can install the Pylint package with pip, which I recommend doing in a virtual environment. Once installed, you pass Pylint the name of a file you want analyzed, like this:</p>
<pre><code>pylint filetocheck.py</code></pre>
<p>You can also analyze an entire package or module at once. (I’ll define what modules and packages are in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.) For example, if you want Pylint to analyze a package called <var>myawesomeproject</var> in the current working directory, you’d run this:</p>
<pre><code>pylint <var>myawesomeproject</var></code></pre>
<p> Pylint will scan the files and display its warnings and recommendations on the command line. Then, you can edit your file and make the necessary changes.</p>
<p><span epub:type="pagebreak" title="30" id="Page_30"/>For example, consider the following Python file:</p>
<pre><code>def cooking():
    ham = True
    print(eggs)
    return order</code></pre>
<p class="CodeListingCaption"><a id="listing2-7">Listing 2-7</a>: <em>cooking.py:1a</em></p>
<p>I’ll run the linter on that file with the following in the system command line:</p>
<pre><code>pylint cooking.py</code></pre>
<p>Pylint provides the following feedback:</p>
<pre><code>************* Module cooking
cooking.py:1:0: C0111: Missing module docstring (missing-docstring)
cooking.py:1:0: C0111: Missing function docstring (missing-docstring)
cooking.py:3:10: E0602: Undefined variable 'eggs' (undefined-variable)
cooking.py:4:11: E0602: Undefined variable 'order' (undefined-variable)
cooking.py:2:4: W0612: Unused variable 'ham' (unused-variable)

-----------------------------------------------------------------------
Your code has been rated at -22.50/10</code></pre>
<p>The linter found five errors in my code: both the module and the function are missing their docstrings (see <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>). I tried to use the variables <code>eggs</code> and <code>order</code>, neither of which exist. I also assigned a value to the variable <code>ham</code>, but I never used that value anywhere.</p>
<p>If Pylint takes umbrage at a particular line of code you feel should be left as is, you can tell the static analyzer to ignore it and move on. You do this with a special comment, either inline on the line in question or at the top of the affected block. For example:</p>
<pre><code><b># pylint: disable=missing-docstring</b>

def cooking():  <b># pylint: disable=missing-docstring</b>
    ham = True
    print(eggs)
    return order</code></pre>
<p class="CodeListingCaption"><a id="listing2-8">Listing 2-8</a>: <em>cooking.py:1b</em></p>
<p>With the first command, I tell Pylint not to alert me about the missing docstring on the module; that affects the entire block of code. The inline comment on the next line will suppress the warning about the missing docstring on the function, and it will only affect that line. If I ran the linter again, I’d only see the other two linter errors:</p>
<pre><code>************* Module cooking
cooking.py:5:10: E0602: Undefined variable 'eggs' (undefined-variable)
cooking.py:6:11: E0602: Undefined variable 'order' (undefined-variable)
<span epub:type="pagebreak" title="31" id="Page_31"/>cooking.py:4:4: W0612: Unused variable 'ham' (unused-variable)

----------------------------------------------------------------------
Your code has been rated at -17.50/10 (previous run: -22.50/10, +5.00)</code></pre>
<p>At this point, I’d edit my code and actually fix the rest of those problems. (Except I won’t, for this example.)</p>
<p>You can also control Pylint’s project-wide behavior by creating a <em>pylintrc</em> file in the root directory of your project. To do this, run the following:</p>
<pre><code>pylint --generate-rcfile &gt; pylintrc</code></pre>
<p>Find that file; open it; and edit it to turn on and off different warnings, ignore files, and define other settings. The documentation isn’t fantastic for this, but you can often work out what different options do from the comments in that <em>pylintrc</em> file.</p>
<p>When you run Pylint, it will look for a <em>pylintrc</em> (or <em>.pylintrc</em>) file in the current working directory. Alternatively, you can specify a different filename for Pylint to read its settings from, such as <em>myrcfile</em>, by passing the filename to the <code>--rcfile</code> option when invoking Pylint:</p>
<pre><code>pylint --rcfile=myrcfile <var>filetocheck.py</var></code></pre>
<p>Some regular users of Pylint like to create <code>.pylintrc</code> or <code>.config/pylintrc</code> in their home directory (UNIX-like systems only). If Pylint cannot find another configuration file, it will use the one in the home directory.</p>
<p>Although the Pylint documentation is far from comprehensive, it can still be useful. You can find it at <a href="https://pylint.readthedocs.io/" class="LinkURL">https://pylint.readthedocs.io/</a>.</p>
<h3 id="h2-500920c02-0024">Flake8</h3>
<p class="BodyFirst">The <em>Flake8</em> tool is actually a combination of three static analyzers:</p>
<ul>
<li><em>PyFlakes</em> is a linter, similar in purpose to Pylint. It is designed to work faster and to avoid false positives (both being common complaints about Pylint). It also ignores style rules, which are handled by the next tool.</li>
<li><em>pycodestyle</em> is a style checker, to help ensure you write PEP 8-compliant code. (This tool used to be called <code>pep8</code>, but it was renamed to avoid confusion with the actual style guide.)</li>
<li><em>mccabe</em> checks the McCabe (or Cyclomatic) complexity of your code. If you don’t know what that is, don’t worry—its purpose is essentially just to warn you when your code’s structure is getting too complicated.</li>
</ul>
<p>You can install the Flake8 package with pip, which I typically do within a virtual environment.</p>
<p>To scan a file, module, or package, pass it to <code>flake8</code> on the command line. For example, to scan my earlier <em>cooking.py</em> file (<a href="#listing2-8" id="listinganchor2-8">Listing 2-8</a>), I’d use this command:</p>
<pre><code>flake8 cooking.py</code></pre>
<p><span epub:type="pagebreak" title="32" id="Page_32"/>That outputs the following:</p>
<pre><code>cooking.py:2:5: F841 local variable 'ham' is assigned to but never used
cooking.py:3:11: F821 undefined name 'eggs'
cooking.py:4:12: F821 undefined name 'order'</code></pre>
<p>(You’ll notice that Flake8 isn’t complaining about the lack of docstrings; that’s disabled by default in this linter.)</p>
<p>By default, only PyFlakes and pycodestyle are run. If you want to analyze the complexity of your code, you also need to pass the argument <code>--max-complexity</code>, followed by a number. Anything higher than <code>10</code> is considered too complex, but if you understand McCabe complexity, you can change this to suit your needs. So, for example, to check the complexity of the <em>cooking.py</em> file, you’d run this:</p>
<pre><code>flake8 --max-complexity 10 cooking.py</code></pre>
<p>However you run Flake8, you’ll get a comprehensive list of all the errors and warnings in your code.</p>
<p>If you need to tell Flake8 to ignore something it thinks is a problem, you use a <code># noqa</code> comment, followed by the error code to ignore. This comment should be inline, on the line where the error occurs. If you omit the error code, then <code># noqa</code> will cause Flake8 to ignore all errors on that line.</p>
<p>In my code, if I wanted to ignore both of the errors I received, it might look like this:</p>
<pre><code>def cooking():
    ham = True    # noqa F841
    print(eggs)   # noqa F821, F841
    return order  # noqa</code></pre>
<p class="CodeListingCaption"><a id="listing2-9">Listing 2-9</a>: <em>cooking.py:1c</em></p>
<p>Here, you see three different scenarios. First, I’m ignoring only warning <code>F841</code>. Second, I’m ignoring two errors (even though one of them isn’t actually raised; this is just a silly example). Third, I’m ignoring all possible errors.</p>
<p>Flake8 also supports configuration files. In the project directory, you can create a <em>.flake8</em> file. Start a section in that file with the line <code>[flake8]</code>, followed by all the Flake8 settings you want to define. (See the documentation.)</p>
<p>Flake8 will also accept project-wide configuration files called <em>tox.ini</em> or <em>setup.cfg</em>, so long as they have a <code>[flake8]</code> section within them.</p>
<p>For example, if you want to automatically run mccabe each time you invoke Flake8, rather than specify <code>--max-complexity</code> every time, you could define a <em>.flake8</em> file that looks like this:</p>
<pre><code>[flake8]
max-complexity = 10</code></pre>
<p class="CodeListingCaption"><a id="listing2-10">Listing 2-10</a>: <em>.flake8</em></p>
<p><span epub:type="pagebreak" title="33" id="Page_33"/>Some developers like to define a system-wide configuration file for Flake8, which you can do (only) on a UNIX-like system. In your home folder, create the configuration file as either <em>.flake8</em> or <em>.config/flake8</em>.</p>
<p>One of the chief advantages of Flake8 over Pylint is the documentation. Flake8 has a complete list of their warnings, errors, options, and the like. You can find the documentation at <a href="https://flake8.readthedocs.io/" class="LinkURL">https://flake8.readthedocs.io/</a>.</p>
<h3 id="h2-500920c02-0025">Mypy</h3>
<p class="BodyFirst"><em>Mypy</em> is an unusual static analyzer because it focuses entirely on <em>type annotations</em> (see <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>). Because it involves so many concepts I haven’t covered yet, I won’t go into much depth here.</p>
<p>Still, now is a good time to get it installed. Like everything else so far, you can install the <code>mypy</code> package from pip.</p>
<p>Once installed, Mypy can be used by passing it the file, package, or module you wish to check:</p>
<pre><code>mypy <var>filetocheck.py</var></code></pre>
<p>Mypy will only attempt to check files that have type annotations, and it will ignore the rest.</p>
<h2 id="h1-500920c02-0009">Style Janitors: Autoformatting Tools</h2>
<p class="BodyFirst">Another tool you may find useful is an <em>autoformatter,</em> which can automatically change your Python code—spacing, indentation, and preferred equivalent expressions (such as <code>!=</code> instead of <code>&lt;&gt;</code>)—to be PEP 8 compliant. Two options are <em>autopep8</em> and <em>Black</em>.</p>
<h3 id="h2-500920c02-0026">autopep8</h3>
<p class="BodyFirst">The autopep8 tool leverages pycodestyle (part of Flake8), even using the same configuration file as that tool to determine what style rules it ultimately follows or ignores.</p>
<p>As always, you can install <code>autopep8</code> with pip.</p>
<p>By default, autopep8 only fixes whitespace, but if you pass the <code>--aggressive</code> argument to it, it will make additional changes. In fact, if you pass that argument twice, it will do even more. The complete list is beyond the scope of this explanation, so consult the documentation at <a href="https://pypi.org/project/autopep8/" class="LinkURL">https://pypi.org/project/autopep8/</a> to learn more.</p>
<p>To fix most PEP 8 issues on a Python code file by changing it in place (as opposed to making a copy, which is the default behavior), run this:</p>
<pre><code>autopep8 --in-place --aggressive --aggressive <var>filetochange.py</var></code></pre>
<p>Changing the file directly may sound a bit risky, but it really isn’t. Style changes are just that: style. They don’t affect the actual behavior of the code.</p>
<h3 id="h2-500920c02-0027"><span epub:type="pagebreak" title="34" id="Page_34"/>Black</h3>
<p class="BodyFirst">The Black tool is a little more straightforward: it assumes you want to follow PEP 8 in its entirety, and it doesn’t overwhelm you with many options as a result.</p>
<p>Like autopep8, you install <code>black</code> with pip, although it requires Python 3.6 or later. To format a file with it, pass the filename:</p>
<pre><code>black <var>filetochange.py</var></code></pre>
<p>A complete list of Black’s few options can be seen via <code>black --help</code>.</p>
<h2 id="h1-500920c02-0010">Testing Frameworks</h2>
<p class="BodyFirst">Testing frameworks form an essential part of any good development workflow, but I won’t go into detail about them in this chapter. Python has three major options for testing frameworks: <em>Pytest</em>, <em>nose2</em>, and <em>unittest</em>, in addition to a promising new project called <em>ward</em>. All of these can be installed with pip.</p>
<p>More knowledge is essential to cover this topic effectively, so I’ll revisit it in <span class="xref" itemid="xref_target_Chapter 20">Chapter 20</span>.</p>
<h2 id="h1-500920c02-0011">An Exhibition of Code Editors</h2>
<p class="BodyFirst">You have your Python interpreter, your virtual environments, your static analyzers, and other such tools. Now you are prepared to write code.</p>
<p>You can write Python in any basic text editor, just as you could with practically any other programming language. Yet you’ll probably have an easier time writing production-quality code with a proper code editor.</p>
<p>Before I end this chapter, I want to take you on a tour of several of the most popular Python code editors and integrated development environments (<em>IDEs</em>) available. This is only a sampling, as there are many more options besides. <b>If you already know what code editor or IDE you want to use, skip forward to the last section of this chapter.</b></p>
<h3 id="h2-500920c02-0028">IDLE</h3>
<p class="BodyFirst">Python has its own IDE, called <em>IDLE</em>, which ships with the standard distribution of Python. It’s a fairly bare-bones IDE with two components: an editor and an interface for the interactive shell. You could do worse than IDLE, so if you aren’t in the mood to install a different editor right now, start here. However, I recommend exploring your options, as most editors and IDEs have a host of useful features that IDLE lacks.</p>
<h3 id="h2-500920c02-0029">Emacs and Vim</h3>
<p class="BodyFirst">The purists and old-school hackers among you will be glad to know that Emacs and Vim both have excellent Python support. Setting up either is not for the faint of heart, so I’m not going into any of that here.</p>
<p><span epub:type="pagebreak" title="35" id="Page_35"/>If you’re already a lover of either (or both?) code editors, you can find excellent tutorials for both at Real Python. </p>
<p>For Emacs, see <a href="https://realpython.com/emacs-the-best-python-editor/" class="LinkURL">https://realpython.com/emacs-the-best-python-editor/</a>.</p>
<p>For Vim, see <a href="https://realpython.com/vim-and-python-a-match-made-in-heaven/" class="LinkURL">https://realpython.com/vim-and-python-a-match-made-in-heaven/</a>.</p>
<h3 id="h2-500920c02-0030">PyCharm</h3>
<p class="BodyFirst">According to “The State of Developer Ecosystem 2021” developer survey by JetBrains, the PyCharm IDE from JetBrains is far and away the most popular option for Python programming. It comes in two flavors: the free <em>PyCharm Community Edition</em> and the paid <em>PyCharm Professional Edition</em>. (Steps were taken by JetBrains to eliminate bias. See the survey here: <a href="https://www.jetbrains.com/lp/devecosystem-2021/python/" class="LinkURL">https://www.jetbrains.com/lp/devecosystem-2021/python/</a>.)</p>
<p>Both versions offer a dedicated Python code editor with autocompletion, refactoring, debugging, and testing tools. It can manage and use virtual environments with ease, and it integrates with your version control software. It even performs static analysis (using its own tool). The professional edition adds tools for data, scientific development, and web development.</p>
<p>If you’re familiar with other JetBrains IDEs, like IntelliJ IDEA or CLion, PyCharm would be a great Python IDE to start with. It requires more computer resources than many code editors, but if you have a decently powerful machine, this won’t be a problem. If you haven’t used JetBrains IDEs before, try the Community Edition before investing in the paid version.</p>
<p>You can find more information and downloads at <a href="https://jetbrains.com/pycharm/" class="LinkURL">https://jetbrains.com/pycharm/</a>.</p>
<h3 id="h2-500920c02-0031">Visual Studio Code</h3>
<p class="BodyFirst"><em>Visual Studio Code</em> has excellent Python support. It’s the second-most popular Python code editor, according to that 2021 JetBrains survey. It’s free and open source, and it runs on virtually every platform. Install the official Python extension from Microsoft, and you’re ready to go!</p>
<p>Visual Studio Code supports autocompletion, refactoring, debugging, and virtual environment switching, along with the usual version control integration. It integrates with Pylint, Flake8, and Mypy, among several other popular static analyzers. It even works with the most common Python unit testing tools.</p>
<p>Download it at <a href="https://code.visualstudio.com/" class="LinkURL">https://code.visualstudio.com/</a>.</p>
<h3 id="h2-500920c02-0032">Sublime Text</h3>
<p class="BodyFirst"><em>Sublime</em> is another popular multilanguage code editor. It is appreciated for its speed and simplicity, and it is easily customized with extensions and configuration files. Sublime Text is free to try, but if you find you like it and wish to continue using it, you need to purchase it.</p>
<p>The Anaconda plug-in transforms Sublime Text into a Python IDE, with everything: autocompletion, navigation, static analysis, autoformatting, <span epub:type="pagebreak" title="36" id="Page_36"/>test running, and even a documentation browser. It requires a little more hand-tuned configuration than some of the other options, especially if you want to use virtual environments. However, if Sublime Text is your jam, it’s worth it.</p>
<p>Download Sublime Text at <a href="https://sublimetext.com/" class="LinkURL">https://sublimetext.com/</a> and the Anaconda plug-in at <a href="https://damnwidget.github.io/anaconda/" class="LinkURL">https://damnwidget.github.io/anaconda/</a>. That second link also provides instructions for installing the plug-in in Sublime Text.</p>
<h3 id="h2-500920c02-0033">Spyder</h3>
<p class="BodyFirst">If your focus is scientific programming or data analysis, or if you’re a fan of MATLAB’s interface, you’ll be right at home in <em>Spyder</em>, a free and open source Python IDE that is also written <em>in</em> Python.</p>
<p>In addition to the usual features—a dedicated Python code editor, a debugger, integration with static analyzers, and documentation viewing—Spyder includes integration with many common Python libraries for data analysis and scientific computing. It integrates a full code profiler and variable explorer. Plug-ins exist for supporting unit tests, autoformatting, and editing Jupyter notebooks, among other features.</p>
<p>Download Spyder at <a href="https://spyder-ide.org/" class="LinkURL">https://spyder-ide.org/</a>.</p>
<h3 id="h2-500920c02-0034">Eclipse + PyDev/LiClipse</h3>
<p class="BodyFirst"><em>Eclipse</em> has lost a lot of ground to the newer editors, but it still has a loyal user base. Although it’s geared toward languages like Java, C++, PHP, and JavaScript, Eclipse can also become a Python IDE with the <em>PyDev</em> plug-in.</p>
<p>If you already have installed Eclipse, which is completely free, then you only need to install the PyDev plug-in from the Eclipse Marketplace. Download Eclipse at <a href="https://eclipse.org/ide/" class="LinkURL">https://eclipse.org/ide/</a> and look in the marketplace for the plug-in.</p>
<p>Alternatively, you can install <em>LiClipse,</em> which bundles Eclipse, PyDev, and other useful tools. The PyDev developers recommend this approach, as it directly supports their development work. You can use LiClipse without a license for 30 days, after which point, you must purchase a license. Download LiClipse from <a href="https://liclipse.com/" class="LinkURL">https://liclipse.com/</a>.</p>
<p>PyDev offers autocompletion, refactoring, support for type hinting and static analysis, debugging, unit test integration, and many more features. You can find more information about PyDev at <a href="https://pydev.org/" class="LinkURL">https://pydev.org/</a>.</p>
<h3 id="h2-500920c02-0035">The Eric Python IDE</h3>
<p class="BodyFirst"><em>Eric</em> might be the oldest IDE on the list, but it’s still as reliable as ever. Named after Eric Idle of <em>Monty Python’s Flying Circus</em>, Eric is a free and open source IDE written in Python.</p>
<p>It offers everything you could possibly need to write Python: autocompletion, debugging, refactoring, static analysis, testing integration, documentation tools, virtual environment management, and the list goes on.</p>
<p>Find information about Eric and download it at <a href="https://eric-ide.python-projects.org/" class="LinkURL">https://eric-ide.python-projects.org/</a>.</p>
<h2 id="h1-500920c02-0012"><span epub:type="pagebreak" title="37" id="Page_37"/>Wrapping Up</h2>
<p class="BodyFirst">Writing code involves so much more than just code. Having set up your development environment, project, and IDE, you are now prepared to focus exclusively on making your code the best it can be.</p>
<p>By this point, you should have assembled a Python development workbench worthy of any production-level project. At minimum, you should have installed the Python interpreter, pip, <code>venv</code>, one or more static analyzers, and a Python code editor.</p>
<p>Right now, in your code editor or IDE, create a <em>FiringRange</em> project for experimenting in while working through this book. For the moment, to be sure everything works, you can make a single Python file in that project with these contents:</p>
<pre><code>#!/usr/bin/env python3

print("Hello, world!")</code></pre>
<p class="CodeListingCaption"><a id="listing2-11">Listing 2-11</a>: <em>hello_world.py</em></p>
<p>Run that like this:</p>
<pre><code>python3 hello_world.py</code></pre>
<p>You should see the following output:</p>
<pre><code>Hello, world!</code></pre>
<p>I’ll go into the correct structure for Python projects in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, but writing and running individual Python files in your firing range project should be sufficient for <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>
<p>If you’re new to the IDE you have selected, take a few minutes now to familiarize yourself with it. You should particularly ensure you know how to navigate and run code, manage files, work with virtual environments, access the interactive console, and use the static analyzers.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="39" id="Page_39"/>3</span><br/>
<span class="ChapterTitle">Syntax Crash Course</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Python is an unusual mix of common and unique concepts. Before diving into the intricacies of the language, you must first grasp its essential syntax.</p>
<p>In this chapter, you’ll learn most of the essential syntactic structures you’ll encounter in Python, and you’ll also become familiar with the basic mathematical and logical features of the language.</p>
<p>Most Python developers will point newcomers to the official Python tutorial, which is an excellent introduction to the language’s structure. While I’ll cover all of these concepts in this book in depth, the tutorial is still a good resource worth reading: <a href="https://docs.python.org/3/tutorial/" class="LinkURL">https://docs.python.org/3/tutorial/</a>.</p>
<h2 id="h1-500920c03-0001">Hello, World!</h2>
<p class="BodyFirst">It won’t feel like a proper introduction to the language without the classic Hello World program. In Python, it’s written like this:</p>
<pre><code>print("Hello, world")</code></pre>
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: <em>hello_world.py</em></p>
<p><span epub:type="pagebreak" title="40" id="Page_40"/>There’s nothing novel here. You call the <code>print()</code> function to write text to the console, and you pass data in a string, wrapped in quotes as an argument. You can pass whatever sort of data you like, and it will be output on the console.</p>
<p>I can also get input from the console with the <code>input()</code> function:</p>
<pre><code>name = input( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> "What is your name? ")
print("Hello, " + name)</code></pre>
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: <em>hello_input.py</em></p>
<p>I use the <code>input()</code> function and pass my prompt as a string <span class="CodeAnnotation" aria-label="annotation1">❶</span>. When I run that code, Python greets me using the name I entered on the console.</p>
<h2 id="h1-500920c03-0002">Statements and Expression</h2>
<p class="BodyFirst">Each line of code in Python that ends with a line break is a <em>statement</em>, sometimes more specifically known as a <em>simple statement</em>. Unlike in many C-inspired languages, you don’t need to end a line in Python with a special character.</p>
<p>A section of code that evaluates to a single value is called an <em>expression</em>. In Python, you can put expressions nearly anywhere a value is expected. The expression is evaluated down to a value, and that value is used in that position in the statement.</p>
<p>For example, in one statement, I can create a variable, and in another statement, I can print its contents to the console:</p>
<pre><code>message = "Hello, world!"
print(message)</code></pre>
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: <em>hello_statements.py:1a</em></p>
<p>I assign the expression <code>"Hello, world!"</code> to <code>message</code>, and then I pass the expression <code>message</code> to <code>print()</code>.</p>
<p>If you ever need to place multiple statements on the same line, you can separate them with a semicolon (<code>;</code>). To demonstrate this, here are the same two statements as earlier, but packed onto one line, with a semicolon to separate them:</p>
<pre><code>message = "Hello, world!"<b>; </b>print(message)</code></pre>
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: <em>hello_statements.py:1b</em></p>
<p>While this is valid code, using this technique is somewhat discouraged. The Python philosophy places a high value on readability, and the placement of multiple statements on the same line often detracts from that.</p>
<p>Stick to placing one statement per line, unless you have a specific reason to do otherwise.</p>
<h2 id="h1-500920c03-0003"><span epub:type="pagebreak" title="41" id="Page_41"/>The Importance of Whitespace</h2>
<p class="BodyFirst">When you’re looking at a sample of Python source code, the first thing that will probably jump out at you is the use of indentation for nesting. A <em>compound statement</em> is made up of one or more <em>clauses</em>, each of which consists of a line of code called a <em>header</em> and a block of code called a <em>suite</em>, which is associated with the header. </p>
<p>For example, this program prints different messages, depending on whether a <code>name</code> is specified:</p>
<pre><code>name = "Jason"
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> if name != "":
    message = "Hello, " + name + "!"
    print(message)
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> print("I am a computer.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: <em>hello_conditional.py</em></p>
<p>I set up a conditional statement with an <code>if</code> header <span class="CodeAnnotation" aria-label="annotation1">❶</span>, after which I have a suite made up of two indented lines of code, which “belongs” to the header. These lines of code are executed only if the conditional expression in the header is evaluated to <code>True</code>.</p>
<p>The unindented line <span class="CodeAnnotation" aria-label="annotation2">❷</span> is not part of the suite that belongs to the conditional statement, and it will be run every time.</p>
<p>As I nest deeper, I need to add more indentation:</p>
<pre><code>raining = True
hailing = False
if raining:
    if hailing:
       print("NOPE")
    else:
        print("Umbrella time.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: <em>weather_nested_conditional.py</em></p>
<p>The first <code>print</code> statement is indented twice, which is how Python knows that it belongs to both preceding conditional statements.</p>
<p>Given the importance of whitespace, the “tabs versus spaces” war is fairly common in Python world. You’ll remember from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> that the PEP 8 style guide stresses using either four spaces or a single tab per indentation level. <b><i>Consistency is key!</i></b> Python really doesn’t care whether you use tabs, two spaces, four spaces, or even seven spaces (although that’s probably a step too far) for each level of indentation. The point is to be consistent within any and every given block of code.</p>
<p>You should use only one indentation style throughout your project, even if your situation provides a technical loophole. Don’t mix tabs and spaces. Chances are your IDE has tools to help you with this.</p>
<p>For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout my code examples. While I’d recommend you follow this same convention—you can even configure your editor to insert four spaces each <span epub:type="pagebreak" title="42" id="Page_42"/>time you hit the <span class="Caps">Tab</span> key—if you have a strong preference for tabs, you’re welcome to use those instead. It really doesn’t matter.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2>	<p class="BoxBodyFirst">If you ever need to pack a conditional statement (or something similar) onto one line, you can omit both the line break and the indentation, as in this example: <code>if raining: print("Umbrella time.")</code> The colon (<code>:</code>) serves as the separator. However, as with the semicolon from earlier, be mindful of the effect this can have on readability.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c03-0004">Doing Nothing</h2>
<p class="BodyFirst">On occasion, you will need to insert a statement that has absolutely no effect. This is particularly useful when you need to put a syntactically valid placeholder where a suite of code will exist later. For this purpose, Python provides the <code>pass</code> keyword.</p>
<p>For example, I can employ the <code>pass</code> keyword as a placeholder in my <code>if raining</code> conditional, until I’m able to write the final code:</p>
<pre><code>raining = True
if raining:
    <code>pass</code></code></pre>
<p class="CodeListingCaption"><a id="listing3-7">Listing 3-7</a>: <em>raining_pass.py</em></p>
<p>Just remember, <code>pass</code> does absolutely nothing. That’s the only reason it exists.</p>
<h2 id="h1-500920c03-0005">Comments and Docstrings</h2>
<p class="BodyFirst">To write comments in Python, precede the line with a hash (<code>#</code>). Everything between the hash and the end of the line is a comment and will be ignored by the interpreter.</p>
<pre><code># This is a comment
print("Hello, world!")
print("How are you?") <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> # This is an inline comment.
# Here's another comment
# And another
# And...you get the idea</code></pre>
<p class="CodeListingCaption"><a id="listing3-8">Listing 3-8</a>: <em>comments.py</em></p>
<p>If you ran this program, the <code>print</code> statements would both execute. The rest of the second <code>print </code>statement, from the hash onward, is an inline comment <span class="CodeAnnotation" aria-label="annotation1">❶</span> and would be ignored by the interpreter. All the other lines are only comments.</p><p/>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">If the octothorpe (#) appears in a string, it will be interpreted as a literal character in that string; it won’t produce a comment.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside><h3 id="h2-500920c03-0001"><span epub:type="pagebreak" title="43" id="Page_43"/>Docstrings</h3>
<p class="BodyFirst">Officially, there is no syntax for “multiline” comments; you just comment each line. There is one special exception: the <em>docstring</em>. It looks like this:</p>
<pre><code>def make_tea():
    """Will produce a concoction almost,
    but not entirely unlike tea.
    """
    #  ...function logic...</code></pre>
<p class="CodeListingCaption"><a id="listing3-9">Listing 3-9</a>: <em>docstrings.py:1</em></p>
<p>I define a function that would (theoretically) make tea, and I place the description of the function inside a docstring.</p>
<p>Docstrings exist to provide documentation for functions, classes, and modules, especially public ones. They conventionally begin and end with three quotation marks (<code>"""</code>), allowing the string to automatically span multiple lines. You would typically place docstrings at the top, inside of whatever they’re defining, such as in the function above.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">You can use any string literal as a docstring, but the standard is to only use triple quotes. See PEP 257.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>There are three important distinctions between comments and docstrings:</p>
<ol class="decimal">
<li value="1">Docstrings are string literals, and they are seen by the interpreter; comments are ignored.</li>
<li value="2">Docstrings are used in automatic documentation generation.</li>
<li value="3">Docstrings are generally only docstrings when they appear at the top of the module, function, class, or method they define. Comments can live anywhere.</li>
</ol>
<p>It is perfectly possible to use a triple-quoted string literal to write a sort of “multiline comment,” but it’s not recommended, since a string literal can easily get left in a place where Python will try to use it as a value.</p>
<p>In short, use docstrings as intended, and stick with comments for everything else. Many Python IDEs have hotkeys for toggling comments on a selection, which can save you a lot of time.</p>
<p>I can access these docstrings later in my code. For instance, given the previous example, I can do this:</p>
<pre><code>print(make_tea.__doc__)  # This always works.
help(make_tea)           # Intended for use in the interactive shell.</code></pre>
<p class="CodeListingCaption"><a id="listing3-10">Listing 3-10</a>: <em>docstrings.py:2</em></p>
<p>Docstrings have their own style conventions, which are outlined in depth in PEP 257.</p>
<h2 id="h1-500920c03-0006"><span epub:type="pagebreak" title="44" id="Page_44"/>Declaring Variables</h2>
<p class="BodyFirst">You may have already noticed that Python doesn’t have a distinct keyword for declaring a new variable (technically called a <em>name</em> in this language; see <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>). Here, I define two variables—<code>name</code> and <code>points</code>:</p>
<pre><code>name = "Jason"
points = 4571
print(name)   # displays "Jason"
print(points) # displays 4571
points = 42
print(points) # displays 42</code></pre>
<p class="CodeListingCaption"><a id="listing3-11">Listing 3-11</a>: <em>variables.py</em></p>
<p>Python is <em>dynamically typed</em>, meaning the data type of a value is determined when it is evaluated. This contrasts with statically typed languages, in which you declare the data type initially. (C++ and Java are both statically typed.)</p>
<p>With Python, you can assign a value to a name anytime, by using the assignment operator (<code>=</code>). It infers the data type. If the name is a new variable, Python will create it; if the name already exists, Python will change the value. It’s a pretty straightforward system.</p>
<p>In general, there are only two rules to follow with Python variables:</p>
<ol class="decimal">
<li value="1">Define a variable before you access it; otherwise, you’ll get an error.</li>
<li value="2">Don’t change what kind of data you’re storing in the variable, even when replacing a value.</li>
</ol>
<p>Python is considered a <em>strongly typed language</em>, meaning you usually can’t magically combine data of different types. For example, it won’t allow you to add an integer and a string together. On the other hand, <em>weakly typed</em> languages let you do practically anything with different data types, and they try to figure out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire spectrum between those last two terms and plenty of debate about what behaviors qualify under which name. While Python is decidedly in the “strongly typed” camp, it still has weaker typing than some languages.</p>
<p>Python is, however, <em>weakly bound</em>, so it is possible to assign a value of a different type to an existing variable. While this is technically permissible, it is strongly discouraged, as it can produce confusing code.</p>
<h3 id="h2-500920c03-0002">What About Constants?</h3>
<p class="BodyFirst">Python doesn’t have any formally defined constants. In keeping with PEP 8, you would indicate a variable is intended to be treated as a constant by using all-caps names with underscores. This naming convention is sometimes humorously referred to as <em>screaming snake case</em> for the all-caps (screaming) and the underscores (snakes). For example, the name <code>INTEREST_RATE</code> <span epub:type="pagebreak" title="45" id="Page_45"/>indicates that you don’t want the variable redefined or changed in any way. While the interpreter itself won’t prevent the variable from being modified, your linter will usually complain if you do.</p>
<h2 id="h1-500920c03-0007">Mathematics</h2>
<p class="BodyFirst">Python has all the math functionality you would expect from a good programming language; its excellent support for both simple and complicated mathematics is one of the reasons Python is popular for scientific programming, data processing, and statistical analysis.</p>
<h3 id="h2-500920c03-0003">Meet the Number Types</h3>
<p class="BodyFirst">Before I get into the operations, you should be aware of the three data types used for storing numbers.</p>
<p><em>Integers</em> (<code>int</code>) store whole numbers. In Python, integers are always signed and effectively have no maximum value. Integers use decimal base (base-10) by default, but they can also be specified in binary (<code>0b101010</code>), octal (<code>0o52</code>), or hexadecimal (<code>0x2A</code>).</p>
<p><em>Floating-point numbers</em> (<code>float</code>) store numbers with a decimal part (for example, <code>3.141592</code>). You can also use scientific notation (for example, <code>2.49e4</code>). Internally, values are stored as double-precision, IEEE 754 floating-point numbers, which are subject to the limits inherent in that format. (For more insight into the limits and gotchas of floating-point arithmetic, read the article “What Every Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg: <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" class="LinkURL">https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a><em>.</em>)</p>
<p>You can also specify an invalid number with <code>float("nan")</code>, a number larger than the largest possible value with <code>float("inf")</code>, or a number smaller than the smallest possible value with <code>float("-inf")</code>. </p>
<p>Notice that I wrapped the special values in quotes. This is necessary if you want to use these values without <em>importing</em> the <code>math</code> module (see <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> for more about importing). If you have imported the <code>math</code> module (see “The <code>math</code> Module” subsection below), you can use the constants <code>nan</code>, <code>inf</code>, and so forth, instead of the quoted versions.</p>
<p><em>Complex numbers</em> (<code>complex</code>) can store imaginary numbers by appending <code>j</code> to the value, as in <code>42j</code>. You can combine a real part with the imaginary part, using addition: <code>24+42j</code>.</p>
<p>In case you missed it in math class, an imaginary number has the square root of negative one as one of its factors, even though this value is utterly impossible; there is no value that you can multiply by itself to get negative one! Yet imaginary numbers definitely show up in real-world math. Spooky, no?</p>
<p><em>Decimal</em> and <em>Fraction</em> are two of the additional object types for storing numeric data. <code>Decimal</code> stores fixed-point decimal numbers, while <code>Fraction</code> does the same for fractions. To use either, you’ll need to import them first.</p>
<p><span epub:type="pagebreak" title="46" id="Page_46"/>Here’s a brief example that uses both types:</p>
<pre><code>from decimal import Decimal
from fractions import Fraction

third_fraction = Fraction(1, 3)
third_fixed = Decimal("0.333")
third_float = 1 / 3

print(third_fraction)  # 1/3
print(third_fixed)     # 0.333
print(third_float)     # 0.3333333333333333

third_float = float(third_fraction)
print(third_float)     # 0.3333333333333333

third_float = float(third_fixed)
print(third_float)     # 0.333</code></pre>
<p class="CodeListingCaption"><a id="listing3-12">Listing 3-12</a>: <em>fractions_and_decimals.py</em></p>
<p>The <code>float()</code> function turns <code>Fraction</code> and <code>Decimal</code> objects into floats.</p>
<h3 id="h2-500920c03-0004">Operators</h3>
<p class="BodyFirst">Python has the usual operators, with a couple of additions that may not be familiar to some developers.</p>
<p>Here’s a bit of code that will demonstrate the math operators. I’ll wrap each equation inside a <code>print()</code> statement, so you can run the code and see the results:</p>
<pre><code>print(-42)         # negative (unary), evaluates to -42
print(abs(-42))    # absolute value, evaluates to 42
print(40 + 2)      # addition, evaluates to 42
print(44 - 2)      # subtraction, evaluates to 42
print(21 * 2)      # multiplication, evaluates to 42
print(680 / 16)    # division, evaluates to 42.5
print(680 // 16)   # floor division (discard remainder), evaluates to 42
print(1234 % 149)  # modulo, evaluates to 42
print(7 ** 2)      # exponent, evaluates to 49
print((9 + 5) * 3) # parentheses, evaluates to 42</code></pre>
<p class="CodeListingCaption"><a id="listing3-13">Listing 3-13</a>: <em>math_operators.py</em></p>
<p>The <em>unary</em> (one-operand) negative operator flips the sign of whatever follows it. The <code>abs()</code> function is technically considered a unary operator as well. The rest of the operators here are <em>binary</em>, meaning they accept two operands.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="47" id="Page_47"/>Pedantic NOTE</h2><p class="BoxBodyFirst">There’s also a unary <code>+</code> operator, purely so statements like <code>+4</code> are syntactically valid. It doesn’t actually have an effect on any of the built-in types. The statements <code>+-3</code> and <code>-+3</code> would both produce the value <code>-3</code>.</p>
	<p>In addition to the common arithmetic operators, Python offers <em>augmented assignment operators</em>, sometimes informally called <em>compound assignment operators</em>. These allow you to perform an operation with the current value of the variable as the left operand.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<pre><code>foo = 10
foo += 10   # value is now 20 (10 + 10)
foo -= 5    # value is now 15 (20 – 5)
foo *= 16   # value is now 240 (15 * 16)
foo //= 5   # value is now 48 (240 // 5)
foo /= 4    # value is now 12.0 (48 / 4)
foo **= 2   # value is now 144.0 (12.0 ** 2)
foo %= 51   # value is now 42.0 (144.0 % 15)</code></pre>
 
<p class="CodeListingCaption"><a id="listing3-14">Listing 3-14</a>: <em>augmented_assignment_operators.py</em></p>
<p>If you need both floor division (<code>//</code>) and modulo (<code>%</code>) on the same operands, Python provides the <code>divmod()</code> function to efficiently perform the calculation, returning the two results in a tuple. Thus, <code>c = divmod(a, b)</code> is the same as <code>c = (a // b, a % b)</code>.</p>
<p>Python also has <code>bitwise</code> operators, which I’ll list below for those readers already familiar with bitwise arithmetic. I won’t introduce these concepts until <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>:</p>
<pre><code>print(9 &amp; 8)    # bitwise AND, evaluates to 8
print(9 | 8)    # bitwise OR, evaluates to 9
print(9 ^ 8)    # bitwise XOR, evaluates to 1
print(~8)       # unary bitwise ones complement (flip), evaluates to -9
print(1 &lt;&lt; 3)   # bitwise left shift, evaluates to 8
print(8 &gt;&gt; 3)   # bitwise right shift, evaluates to 1</code></pre>
<p class="CodeListingCaption"><a id="listing3-15">Listing 3-15</a>: <em>bitwise_operators.py</em></p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">Python also has a binary operator for matrix multiplication, <code>@</code>, although none of the built-in types support it. If you have variables that support this operator, you can use it via <code>x @ y</code>. The related augmented assignment <code>@=</code> also exists.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c03-0005">The math Module</h3>
<p class="BodyFirst">Python provides plenty of additional functions in the <code>math</code> module, along with the five most common math constants: <code>pi</code>, <code>tau</code>, <code>e</code>, <code>inf</code>, and <code>nan</code>.</p>
<pre><code>import math

print(math.pi)   # PI
print(math.tau)  # TAU
<span epub:type="pagebreak" title="48" id="Page_48"/>print(math.e)    # Euler's number
print(math.inf)  # Infinity
print(math.nan)  # Not-a-Number

infinity_1 = float('inf')
infinity_2 = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> math.inf 
print(infinity_1 == infinity_2)  # prints True</code></pre>
<p class="CodeListingCaption"><a id="listing3-16">Listing 3-16</a>: <em>math_constants.py</em></p>
<p>All five constants are floats and can be directly used as such <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The official documentation provides a complete list of everything available in the <code>math</code> module.</p>
<p>You might remember a little trick from high school trigonometry, where you could calculate the height of something using your distance to it and the angle from your vantage point to the top of the object. Here’s a way to calculate that with Python, using the <code>math</code> module:</p>
<pre><code>import math

distance_ft = 65  # the distance to the object
angle_deg = 74    # the angle to the top of the object

# Convert from degrees to radians
angle_rad = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> math.radians(angle_deg)
# Calculate the height of the object
height_ft = distance_ft * <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> math.tan(angle_rad)
# Round to one decimal place
height_ft = <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> round(height_ft, 1)

print(height_ft)  # outputs 226.7</code></pre>
<p class="CodeListingCaption"><a id="listing3-17">Listing 3-17</a>: <em>surveying_height.py</em></p>
<p>I use two functions from the <code>math</code> module: <code>math.radians()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <code>math.tan()</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The <code>round()</code> function <span class="CodeAnnotation" aria-label="annotation3">❸</span> is built into the language itself.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">The <code>round()</code> function can behave in surprising ways with floats, because of how floating-point numbers are stored. You may consider using string formatting instead.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside><h2 id="h1-500920c03-0008">Logic</h2>
<p class="BodyFirst">Python’s clean, obvious syntax for logical expressions is one of the attractive elements of the language. Here, I’ll cover conditional statements and expressions, as well as the comparison and logic operators.</p>
<h3 id="h2-500920c03-0006"><span epub:type="pagebreak" title="49" id="Page_49"/>Conditionals</h3>
<p class="BodyFirst">Conditionals are compound statements composed of <code>if</code>, <code>elif</code>, and <code>else</code> clauses, each made up of a header and a suite. As with most languages, you can have as many <code>elif</code> conditionals in Python as you want, sandwiched between <code>if</code> and (optionally) <code>else</code>. Here’s a really simple example:</p>
<pre><code>command = "greet"

if command == "greet":
    print("Hello!")
elif command == "exit":
    print("Goodbye")
else:
    print("I don't understand.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-18">Listing 3-18</a>: <em>conditional_greet.py</em></p>
<p>This conditional statement is made up of three clauses. The <code>if</code> clause evaluates first, and if the expression in its header evaluates to <code>True</code>, its suite runs, printing <code>"Hello!"</code> Otherwise, it evaluates the expression in the <code>elif</code> header next. If none of the expressions evaluate to <code>True</code>, then the <code>else</code> clause runs.</p>
<p>You’ll notice you don’t need to wrap the conditional expressions, such as <code>command == "greet"</code>, in parentheses, although you may do so anyway if it helps clarify your code. You’ll see an example of this shortly.</p>
<p>If you’re looking for something similar to the <code>switch</code> statement from your favorite programming language, see the “Structural Pattern Matching” section toward the end of this chapter.</p>
<h3 id="h2-500920c03-0007">Comparison Operators</h3>
<p class="BodyFirst">Python has all the comparison operators you’d expect. Take a look at these in the context of comparing two integers:</p>
<pre><code>score = 98
high_score = 100

print(score == high_score)  # equals, evaluates to False
print(score != high_score)  # not equals, evaluates to True
print(score &lt; high_score)   # less than, evaluates to True
print(score &lt;= high_score)  # less than or equals, evaluates to True
print(score &gt; high_score)   # greater than, evaluates to False
print(score &gt;= high_score)  # greater than or equals, evaluates to False</code></pre>
<p class="CodeListingCaption"><a id="listing3-19">Listing 3-19</a>: <em>comparison_operators.py</em></p>
<p><span epub:type="pagebreak" title="50" id="Page_50"/>As you can see, Python has operators for <code>equals</code>, <code>not equals</code>, <code>less than</code>, <code>less than or equals</code>, <code>greater than</code>, and <code>greater than or equals</code>.</p>
<p>No surprises there, but what about boolean comparisons? This is where Python takes a different line.</p>
<h3 id="h2-500920c03-0008">Boolean, None, and Identity Operators</h3>
<p class="BodyFirst">Python offers the values <code>True</code> and <code>False</code>, which are the two values for boolean (type <code>bool</code>) variables. It also has a dedicated <code>None</code> value (type <code>NoneType</code>), which serves in the capacity of a “null” value.</p>
<p>You check for these values in a very different way than with other data types. Instead of the comparison operators, use the special <em>identity operator</em> <code>is</code>. (I’ll also use the logical operator <code>not</code> below, which I’ll discuss separately in a bit.)</p>
<p>Here’s an example:</p>
<pre><code>spam = True
eggs = False
potatoes = None

if spam is True:          # Evaluates to True
    print("We have spam.")

if spam is not False:     # Evaluates to True
    print("I DON'T LIKE SPAM!")

<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> if spam:                  # Implicitly evaluates to True (preferred)
    print("Spam, spam, spam, spam...")


if eggs is False:         # Evaluates to True
    print("We're all out of eggs.")

if eggs is not True:      # Evaluates to True
    print("No eggs, but we have spam, spam, spam, spam...")

<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> if not eggs:              # Implicitly evaluates to True (preferred)
    print("Would you like spam instead?")


if potatoes is not None:  # Evaluates to False (preferred)
    print("Yum")          # We never reach this...potatoes is None!

if potatoes is None:      # Evaluates to True (preferred)
    print("Yes, we have no potatoes.")


<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> if eggs is spam:          # Evaluates to False (CAUTION!!!)
    print("This won't work.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-20">Listing 3-20</a>: <em>boolean_identity_operators.py</em></p>
<p><span epub:type="pagebreak" title="51" id="Page_51"/>Aside from being a little high in sodium, that code shows the many ways of testing boolean values and checking for <code>None</code>.</p>
<p>You can test if a variable is set to <code>True</code>, <code>False</code>, or <code>None</code> by comparing with the <code>is</code> operator. You can also invert the logic with <code>is not</code>.</p>
<p>Most commonly, when testing against <code>True</code>, you can use the variable as the entire condition <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For <code>False</code>, invert that condition test with <code>not</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Take particular note of the last condition, which illustrates an important gotcha with the <code>is</code> operator <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It actually compares the identity of the variables, rather than the value. This is particularly troublesome, as the logic looks sound but is a bug waiting for a place to happen. That probably doesn’t mean much to you yet, but rest assured, I’ll cover this concept in depth in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<p>For now, you can take this rule for granted: use <code>is</code> <em>only</em> for comparing directly to <code>None</code>, and use regular comparison operators for everything else. In practice, we usually say <code>if spam</code> or <code>if not spam</code>, instead of directly comparing to <code>True</code> or <code>False</code>.</p>
<h3 id="h2-500920c03-0009">Truthiness</h3>
<p class="BodyFirst">Most expressions and values in Python can be evaluated to a <code>True</code> or <code>False</code> value. This is typically done by using the value as an expression by itself, although you can also pass it to the <code>bool()</code> function to convert it explicitly.</p>
<pre><code>answer = 42

if answer:
    print("Evaluated to True")  # this runs

print(bool(answer))             # prints True</code></pre>
<p class="CodeListingCaption"><a id="listing3-21">Listing 3-21</a>: <em>truthiness.py</em></p>
<p>When an expression will evaluate to <code>True</code>, it is considered “truthy.” When it will evaluate to <code>False</code>, it is “falsey.” The <code>None</code> constant, values representing zero, and empty collections are all considered “falsey,” while most other values are “truthy.”</p>
<h3 id="h2-500920c03-0010">Logical Operators</h3>
<p class="BodyFirst">If you’re coming from a language where logical operators are a little more difficult to remember, you’ll find Python refreshing: it simply uses the keywords <code>and</code>, <code>or</code>, and <code>not</code>!</p>
<pre><code>spam = True
eggs = False

if spam and eggs:        # AND operator, evaluates to False
    print("I do not like green eggs and spam.")

if spam or eggs:         # OR operator, evaluates to True
    print("Here's your meal.")

<span epub:type="pagebreak" title="52" id="Page_52"/>if (not eggs) and spam:  # NOT (and AND) operators, evaluates to True
    print("But I DON'T LIKE SPAM!")</code></pre>
<p class="CodeListingCaption"><a id="listing3-22">Listing 3-22</a>: <em>logical_operators.py</em></p>
<p>With the <code>and</code> condition, both expressions must evaluate to <code>True</code>. With the <code>or</code> condition, one or the other (or both) must evaluate to <code>True</code>. The third condition adds <code>not</code> to the picture, requiring that <code>eggs</code> be <code>False</code> and <code>spam</code> be <code>True</code>.</p>
<p>I could have omitted the parentheses on the third condition, as <code>not</code> takes precedence and so is evaluated before <code>and</code>. However, the parentheses help to clarify my intended logic.</p>
<p>In practice, you can use the <code>not</code> keyword to invert any conditional expression, such as in the following:</p>
<pre><code>score = 98
high_score = 100
print(score != high_score)      # not equals operator, evaluates to True
print(not score == high_score)  # not operator, evaluates to True</code></pre>
<p class="CodeListingCaption"><a id="listing3-23">Listing 3-23</a>: <em>not_operators.py</em></p>
<p>Both comparisons do the same thing; the issue becomes readability. In this case, the expression using <code>not</code> is less readable because your eyes might skip over the <code>not</code> keyword, so you might not catch what’s happening in the code. The condition employing the <code>!=</code> operator is preferred for readability. While you might find situations where <code>not</code> is the best way to invert your conditional logic, remember The Zen of Python: <b><i>Readability counts!</i></b></p>
<h3 id="h2-500920c03-0011">The Walrus Operator</h3>
<p class="BodyFirst">Python 3.8 introduced <em>assignment expressions</em>, which allow you to assign a value to a variable and use that variable in another expression at the same time. This is possible with the so-called <em>walrus operator</em> (<code>:=</code>).</p>
<pre><code>if (eggs := 7 + 5) == 12:
    print("We have one dozen eggs")

print(eggs)  # prints 12</code></pre>
<p class="CodeListingCaption"><a id="listing3-24">Listing 3-24</a>: <em>walrus.py</em></p>
<p>With the walrus operator, Python first evaluates the expression on the left (<code>7+5</code>) and then assigns it to the variable <code>eggs</code>. The assignment expression is enclosed in parentheses for readability, although I technically could have omitted them.</p>
<p>The assignment expression is then evaluated to a single value, namely the value of <code>eggs</code>, which is used in the comparison. Since the value is <code>12</code>, the condition evaluates to <code>True</code>.</p>
<p><span epub:type="pagebreak" title="53" id="Page_53"/>What’s interesting about the assignment expression is that <code>eggs</code> is now a valid variable in the outer scope, so I can print its value outside of the conditional.</p>
<p>This feature is potentially useful in many scenarios, not only in conditional expressions, as above.</p>
<p>Assignment expressions and the walrus operator were defined in PEP 572, which also contains an in-depth discussion about when and where this feature should be used. Two particularly useful style rules are put forth by this PEP:</p>
<ul>
<li>If either assignment statements or assignment expressions can be used, then prefer statements; they are clear declarations of intent.</li>
<li>If using assignment expressions would lead to ambiguity about execution order, then restructure to use statements instead.</li>
</ul>
<p>As of the writing of this book, Python assignment expressions are still in their infancy. A lot of debate and controversy still surrounds them. In any case, resist the temptation to abuse the walrus operator to cram as much logic onto one line as possible. You should always aim for readability and clarity in your code, above all else.</p>
<h3 id="h2-500920c03-0012">Ellipsis</h3>
<p class="BodyFirst">One seldom-used piece of syntax is the <em>Ellipsis</em>:</p>
<pre><code>...</code></pre>
<p>This is sometimes used by various libraries and modules, but seldom consistently. For example, it’s used with multidimensional arrays in the NumPy third-party library and when working with type hints from the built-in <code>typing</code> module. When you see it come up, consult the documentation for whatever module you’re using.</p>
<h2 id="h1-500920c03-0009">Strings</h2>
<p class="BodyFirst">There are a few things to know about strings as you move forward. Here, I’ll cover the three kinds of strings: string literals, raw strings, and formatted strings.</p>
<h3 id="h2-500920c03-0013">String Literals</h3>
<p class="BodyFirst">There are multiple ways of defining a <em>string literal</em>:</p>
<pre><code>danger = "Cuidado, llamas!"
danger = 'Cuidado, llamas!'
danger = '''Cuidado, llamas!'''
danger = """Cuidado, llamas!"""</code></pre>
<p class="CodeListingCaption"><a id="listing3-25">Listing 3-25</a>: <em>string_literals.py</em></p>
<p><span epub:type="pagebreak" title="54" id="Page_54"/>You can wrap a literal in double quotes (<code>"</code>), single quotes (<code>'</code>), or triple quotes (<code>"""</code>) of either type. You may remember from earlier that there’s something special about triple quotes, but I’ll come back to that in a moment.</p>
<p>PEP 8 addresses the use of single and double quotes:</p>
<blockquote class="blockquote">
<p class="Blockquote">In Python, single-quoted strings and double-quoted strings are the same. This PEP does not make a recommendation for this. Pick a rule and stick to it. When a string contains single or double quote characters, however, use the other one to avoid backslashes in the string. It improves readability.</p>
</blockquote>
<p>The advice about placing quotes inside a string comes in handy when dealing with something like this:</p>
<pre><code>quote = "Shout \"Cuidado, llamas!\""</code></pre>
<p class="CodeListingCaption"><a id="listing3-26">Listing 3-26</a>: <em>escaping_quotes.py:1a</em></p>
<p>This version escapes the double quotes I want to include in the string literal itself. The backslash (<code>\</code>) before the quotes means I want the string to contain that <em>literal character</em>, not to have Python treat the double quote as the boundary of a string. The string literal must always be wrapped in matching quotes.</p>
<p>It is possible to avoid backslashes in this scenario, however:</p>
<pre><code>quote = <b>'</b>Shout, "Cuidado, llamas!"<b>'</b></code></pre>
<p class="CodeListingCaption"><a id="listing3-27">Listing 3-27</a>: <em>escaping_quotes.py:1b</em></p>
<p>This second version wraps the literal in single quotes, so the double quotes will be automatically interpreted as part of the string literal. That approach is much more readable. By wrapping the string in single quotes, Python will assume the double quotes are characters in the string.</p>
<p>The only time you’d really need to escape either single or double quotes with backslashes would be if you had both types of quotes in the string at once:</p>
<pre><code>question = "What do you mean, \"it's fine\"?"</code></pre>
<p class="CodeListingCaption"><a id="listing3-28">Listing 3-28</a>: <em>escaping_quotes.py:2a</em></p>
<p>Personally, in cases like that, I’d prefer to use (and escape) the double quotes, because they don’t evade my attention like an apostrophe would tend to do.</p>
<p>You also have the option to use triple quotes:</p>
<pre><code>question = <b>"""</b>What do you mean, "it's fine"?<b>"""</b></code></pre>
<p class="CodeListingCaption"><a id="listing3-29">Listing 3-29</a>: <em>escaping_quotes.py:2b</em></p>
<p><span epub:type="pagebreak" title="55" id="Page_55"/>Remember that triple quotes define <em>multiline string literals</em>. In other words, I can use them to do this:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> parrot = """\
This parrot is no more!
He has ceased to be!
He's expired
    and gone to meet his maker!
He's a stiff!
Bereft of life,
    he rests in peace!"""

print(parrot)</code></pre>
<p class="CodeListingCaption"><a id="listing3-30">Listing 3-30</a>: <em>multiline_string.py</em></p>
<p>Everything, including newlines and leading whitespace, is literal in triple quotes. If I <code>print("parrot")</code>, it will display exactly like this in the terminal.</p>
<p>The only exception occurs when you use a backslash (<code>\</code>) to escape a particular character, like I did with that newline at the beginning <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It is conventional to escape the first newline after the opening triple quotes, just to make the code look cleaner.</p>
<p>The built-in <code>textwrap</code> module has some functions for working with multiline strings, including tools that allow you remove leading indentation (<code>textwrap.dedent</code>).</p>
<p>Alternatively, you can <em>concatenate</em> (combine) string literals, simply by writing them next to one another, without any operators between them. For example, <code>spam = "Hello " "world" "!"</code> is valid, resulting in the string <code>Hello world!.</code> If you wrap the assignment expression in parentheses, you can even span multiple lines.</p>
<h3 id="h2-500920c03-0014">Raw Strings</h3>
<p class="BodyFirst"><em>Raw strings</em> constitute another form of string literal, wherein the backslash (<code>\</code>) is always treated as a literal character. They’re preceded with an <code>r</code>, such as in this example:</p>
<pre><code>print(r"I love backslashes: \ Aren't they cool?")</code></pre>
<p class="CodeListingCaption"><a id="listing3-31">Listing 3-31</a>: <em>raw_string.py</em></p>
<p>The backslash is treated like a literal character, which means that nothing can be escaped inside of a raw string. The output of that line of code looks like this:</p>
<pre><code>I love backslashes: \ Aren't they cool?</code></pre>
<p>This has implications for what type of quotes you use, so beware.</p>
<p><span epub:type="pagebreak" title="56" id="Page_56"/>Compare these two lines and their outputs:</p>
<pre><code>print("A\nB")
print(r"A\nB")</code></pre>
<p class="CodeListingCaption"><a id="listing3-32">Listing 3-32</a>: <em>raw_or_not.py</em></p>
<p>The first string is ordinary, so <code>\n</code> is treated as a normal escape sequence: specifically, the newline character. That line break appears in the output, like this:</p>
<pre><code>A
B</code></pre>
<p> The second string is a raw string, so the backslash (<code>\</code>) is treated as a literal character in its own right. The output would be as follows:</p>
<pre><code>A\nB</code></pre>
<p>This is particularly useful for regular expression patterns, where you’re likely to have plenty of backslashes that you want as part of the <em>pattern</em>, not interpreted by Python before it gets there. <b><i>Always use raw strings for regular expression patterns.</i></b></p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">If the backslash (<code>\</code>) is the last character in your raw string, it’ll still act to escape out your closing quote and create a syntax error as a result. That has to do with Python’s own language lexing rules, not with strings.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside><h3 id="h2-500920c03-0015">Formatted Strings</h3>
<p class="BodyFirst">A third kind of string literal is a <em>formatted string</em> or <em>f-string</em>, which is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values of variables into a string in a very elegant manner.</p>
<p>If I wanted to include the value of a variable in a string without an f-string, the code might look like this:</p>
<pre><code>in_stock = 0
print("This cheese shop has " + str(in_stock) + " types of cheese.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-33">Listing 3-33</a>: <em>cheese_shop.py:1a</em></p>
<p>The <code>str()</code> function converts the value passed to it into a string, and then the three strings are <em>concatenated</em>, or combined, into one, using the <code>+</code> operator.</p>
<p>Using f-strings, this code becomes more elegant.</p>
<pre><code>in_stock = 0
print(<b>f</b>"This cheese shop has <b>{in_stock}</b> types of cheese.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-34">Listing 3-34</a>: <em>cheese_shop.py:1b</em></p>
<p><span epub:type="pagebreak" title="57" id="Page_57"/>You precede the string literal with an <code>f</code>. Inside, you can substitute a variable by wrapping it in curly braces (<code>{ }</code>). The <code>f</code> tells Python to interpret and evaluate as an expression anything in the string that’s wrapped in curly braces. This means you’re not limited to variables in those curly braces. You can put just about any valid Python code in there, including math, function calls, conditional expressions, or whatever you need.</p>
<p>As of Python 3.8, you can even display both the expression <em>and</em> its result by appending a trailing equal sign (<code>=</code>).</p>
<pre><code>print(f"{5+5=}")  # prints "5+5=10"</code></pre>
<p class="CodeListingCaption"><a id="listing3-35">Listing 3-35</a>: <em>expression_fstring.py</em></p>
<p>There are a couple of gotchas when using f-strings:</p>
<p>First, if you want to wrap an expression in literal curly braces, you must use two curly braces (<code>{{ }}</code>) for every one you want displayed:</p>
<pre><code>answer = 42
print(f"{{answer}}")          # prints "{42}"
print(f"{{{{answer}}}}")      # prints "{{42}}"
print(f"{{{{{{answer}}}}}}")  # prints "{{{42}}}"</code></pre>
<p class="CodeListingCaption"><a id="listing3-36">Listing 3-36</a>: <em>literal_curly_braces.py</em></p>
<p>If you have an odd number of braces, one pair will be ignored. So, if I used five pairs, the result would be the same as if I only had four: two literal pairs would be printed.</p>
<p>Second, you cannot use backslashes within an expression in an f-string. This makes it difficult to escape quotes inside expressions. For example, this would not work:</p>
<pre><code>print(f"{ord('\"')}")     # SyntaxError</code></pre>
<p>To get around this, I’d need to use triple quotes on the outside of the string, to ensure I can employ both single and double quotes inside of the expression.</p>
<pre><code>print(f"""{ord('"')}""")  # prints "34"</code></pre>
<p>Backslashes have other roles. The documentation points out the following problematic situation:</p>
<pre><code>print(f"{ord('\n')}")     # SyntaxError</code></pre>
<p>There’s no direct way around this limitation. Instead, you’d have to evaluate that expression in advance, assign the result to a name, and use it in the f-string.</p>
<pre><code>newline_ord = ord('\n')
print(f"{newline_ord}")   # prints "10"</code></pre>
<p><span epub:type="pagebreak" title="58" id="Page_58"/>Third, and perhaps least surprising, you cannot put comments inside of f-string expressions; the hash (<code>#</code>) symbol isn’t allowed, except as a string literal.</p>
<pre><code>print(f"{# a comment}")   # SyntaxError
print(f"{ord('#')}")      # OK, prints "35"</code></pre>
<p>Lastly, you can never use f-strings as docstrings.</p>
<p>These small wrinkles aside, f-strings are incredibly straightforward to work with.</p>
<h4 id="h3-500920c03-0001">Format Specifications</h4>
<p class="BodyFirst">Besides arbitrary expressions, f-strings support <em>format specifications</em>, which allow you to control how values are displayed. This is a fairly in-depth topic that could easily become a main section on its own, so I will entrust you to the guidance of the documentation for the bulk of it. I’ll breeze over the essentials herein.</p>
<p>Immediately after the expression, you may choose to include one of three special flags: <code>!r</code>, <code>!a</code>, or <code>!s</code> (although that last one is the default behavior, so it can be omitted in most cases). These determine which function is used to fetch the string representation of some value: <code>repr()</code>, <code>ascii()</code>, or <code>str()</code>, respectively (see “String Conversion” below).</p>
<p>Next comes the format specification itself, which always begins with a colon (<code>:</code>), followed by one or more flags. These have to be specified in a particular order to work, although any of them may be omitted if they’re not desired:</p>
<p class="RunInPara"><span class="RunInHead">Align</span>  An alignment flag, specifying left (<code>&lt;</code>), right (<code>&gt;</code>), center (<code>^</code>), or (if numeric) split with the sign aligned left but the digits aligned right (<code>=</code>). This is optionally preceded by a character that will be used to fill any blank space in the alignment.</p>
<p class="RunInPara"><span class="RunInHead">Sign</span>  A flag controlling when the sign is displayed on a number. The plus (<code>+</code>) flag displays the sign on both positive and negative numbers, while the minus (<code>–</code>) flag only displays it on negative numbers. A third option is to show a leading space on positive numbers and a sign on negative numbers (<span class="Caps">space</span>).</p>
<p class="RunInPara"><span class="RunInHead">Alternative form</span>  The hash (<code>#</code>) flag turns on the “alternative form,” which has different meanings for different types (see documentation).</p>
<p class="RunInPara"><span class="RunInHead">Leading zeros</span>  The zero (<code>0</code>) flag causes leading zeros to be displayed (unless a fill character is specified for alignment).</p>
<p class="RunInPara"><span class="RunInHead">Width</span>  The width of the output string in characters. This is where the alignment comes into play.</p>
<p class="RunInPara"><span class="RunInHead">Grouping</span>  A flag controlling whether numbers should separate thousands with a comma (<code>,</code>) or an underscore (<code>_</code>). If omitted, no separator is used. If enabled, the underscore separator also appears every four digits in octal, hexadecimal, and binary numbers.</p>
<p class="RunInPara"><span class="RunInHead">Precision</span>  A dot (<code>.</code>), followed by an integer for decimal precision.</p>
<p class="RunInPara"><span class="RunInHead"><span epub:type="pagebreak" title="59" id="Page_59"/>Type</span>  A flag controlling how numbers are displayed; common options include binary (<code>b</code>), character (<code>c</code>), decimal (<code>d</code>), hexadecimal (<code>x</code>), exponent notation (<code>e</code>), fixed-point (<code>f</code>), and general (<code>g</code>). There are more (see documentation).</p>
<p>All that is a bit abstract, so here are a few quick examples:</p>
<pre><code>spam = 1234.56789
print(f"{spam:=^+15,.2f}")  # prints "===+1,234.57==="

spam = 42
print(f"{spam:#07x}")       # prints "0x0002a"

spam = "Hi!"
print(f"{spam:-^20}")       # prints "--------Hi!---------"</code></pre>
<p class="CodeListingCaption"><a id="listing3-37">Listing 3-37</a>: <em>formatting_strings.py</em></p>
<p>Complete details about the format specification can be found in the official Python documentation: <a href="https://docs.python.org/3/library/string.html#format-string-syntax" class="LinkURL">https://docs.python.org/3/library/string.html#format-string-syntax</a>.</p>
<p>Another useful reference is <a href="https://pyformat.info" class="LinkURL">https://pyformat.info</a>, although as of this writing, it only shows the format specification in the context of the old <code>format()</code> function. You will need to apply it to f-strings yourself.</p>
<h4 id="h3-500920c03-0002">Previous String-Formatting Methods</h4>
<p class="BodyFirst">If you’re reading older Python code, you may encounter the two previous forms of string formatting: <code>%</code> notation and the newer <code>format()</code>. These have both been superseded by f-strings, which have superior performance. That’s because they’re parsed and converted to bytecode <em>before</em> the code is run.</p>
<p>If you find yourself needing to rewrite a <code>format()</code> call as an f-string, the process is thankfully quite simple.</p>
<p>Here’s an example. I’ll start out with a couple of variables:</p>
<pre><code>a = 42
b = 64</code></pre>
<p class="CodeListingCaption"><a id="listing3-38">Listing 3-38</a>: <em>format_to_fstring.py:1</em></p>
<p>Before the advent of f-strings, if I wanted to print out a message containing the values of those two variables, I’d have used <code>format()</code>:</p>
<pre><code>print( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> "{:#x} and {:#o}".format( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> a, b))</code></pre>
<p class="CodeListingCaption"><a id="listing3-39">Listing 3-39</a>: <em>format_to_fstring.py:2a</em></p>
<p>In the old format, a string literal <span class="CodeAnnotation" aria-label="annotation1">❶</span> would contain sets of curly braces, optionally containing the format specifications. The <code>format()</code> function would be called on that string literal (or on a name referencing it). Then, the expressions to be evaluated would be passed to the <code>format()</code> function in order <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p><span epub:type="pagebreak" title="60" id="Page_60"/>That would have the following output:</p>
<pre><code>0x2a 0o100</code></pre>
<p>Converting this to an f-string is as simple as moving the expressions into the string literal in order and then prepending an <code>f</code> to the literal to make it an f-string:</p>
<pre><code>print(f"{<b>a</b>:#x} and {<b>b</b>:#o}")  # prints "0x2a 0o100"</code></pre>
<p class="CodeListingCaption"><a id="listing3-40">Listing 3-40</a>: <em>format_to_fstring.py:2b</em></p>
<p>The output is the same as before.</p>
<p>Optionally, with <code>format()</code>, you could refer to the index of the expression in the argument list:</p>
<pre><code>print("{0:d}={0:#x} | {1:d}={1:#x}".format(a, b))</code></pre>
<p class="CodeListingCaption"><a id="listing3-41">Listing 3-41</a>: <em>format_to_fstring.py:3a</em></p>
<p>That produces this output:</p>
<pre><code>42=0x2a | 64=0x40</code></pre>
<p>To convert this code to an f-string, you substitute the expressions in place of the indices in the string literal, which you (again) turn into an f-string by prepending an <code>f</code>:</p>
<pre><code>f"{<b>a</b>:d}={<b>a</b>:#x} | {<b>b</b>:d}={<b>b</b>:#x}"</code></pre>
<p class="CodeListingCaption"><a id="listing3-42">Listing 3-42</a>: <em>format_to_fstring.py:3b</em></p>
<p>Converting from <code>%</code> notation is a little less trivial, but most Python 3 code uses <code>format()</code> anyway. If you find yourself needing to do this, <a href="https://pyformat.info" class="LinkURL">https://pyformat.info</a> does an excellent job of comparing <code>%</code> notation and <code>format()</code>.</p>
<h3 id="h2-500920c03-0016">Template Strings</h3>
<p class="BodyFirst"><em>Template strings</em> constitute one more alternative to f-strings that is worth knowing about, especially as it still fulfills some use cases, including internationalizing user interfaces. Personally, I find template strings a bit more reusable. On the other hand, the drawback is that they’re considerably more limited in terms of formatting.</p>
<p>If you know how they work, you’ll be equipped to decide for yourself which tool is best for your particular situation.</p>
<p>Here’s a template string for greeting a user:</p>
<pre><code>from string import Template</code></pre>
<p class="CodeListingCaption"><a id="listing3-43">Listing 3-43</a>: <em>template_string.py:1</em></p>
<p><span epub:type="pagebreak" title="61" id="Page_61"/>To use template strings, I first have to import <code>Template</code> from the <code>string</code> module.</p>
<p>Then I can create a new <code>Template</code> and pass it a string literal:</p>
<pre><code>s = Template("$greeting, $user!")</code></pre>
<p class="CodeListingCaption"><a id="listing3-44">Listing 3-44</a>: <em>template_string.py:2</em></p>
<p>I can name my fields whatever I want, preceding each with a dollar sign (<code>$</code>).</p>
<p>Finally, I call the <code>substitute()</code> function on the template I created (<code>s</code>) and pass expressions to each of the fields:</p>
<pre><code>print(s.substitute(greeting="Hi", user="Jason"))</code></pre>
<p class="CodeListingCaption"><a id="listing3-45">Listing 3-45</a>: <em>template_string.py:3</em></p>
<p>The finished string is returned, and in this case, it is passed to <code>print()</code> and displayed:</p>
<pre><code>Hi, Jason!</code></pre>
<p>There are a couple of odd syntax rules with template strings. First, to show a literal dollar sign in the string literal, use two dollar signs (<code>$$</code>). Second, to substitute an expression as part of a word, wrap the name of the field in curly braces (<code>{ }</code>). Both of these rules are demonstrated below:</p>
<pre><code>s = Template("A ${thing}ify subscription costs $$$price/mo.")
print(s.substitute(thing="Code", price=19.95))</code></pre>
<p class="CodeListingCaption"><a id="listing3-46">Listing 3-46</a>: <em>template_string.py:4</em></p>
<p>That outputs the following:</p>
<pre><code>A Codeify subscription costs $19.95/mo.</code></pre>
<p>There’s a handful of additional abilities contained within string templates, but I’ll entrust you to the official Python documentation for the rest of that.</p>
<h3 id="h2-500920c03-0017">String Conversion</h3>
<p class="BodyFirst">I previously mentioned that there are three ways to get the string representation of a value: <code>str()</code>, <code>repr()</code>, and <code>ascii()</code>. </p>
<p>The first function, <code>str()</code>, is the one you’ll use most often, as it returns the <em>human-readable</em> representation of the value.</p>
<p>By contrast, <code>repr()</code> returns the <em>canonical string representation</em> of the value: that is, (usually) the value as Python sees it. In the case of many basic data types, this will return the same thing as <code>str()</code>, but when used on most objects, the output contains additional information useful in debugging.</p>
<p>The <code>ascii()</code> function is the same as <code>repr()</code>, except that the string literal it returns is completely ASCII-compatible, having escaped any non-ASCII (for example, Unicode) characters.</p>
<p><span epub:type="pagebreak" title="62" id="Page_62"/>I’ll return to this concept in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, when I start defining my own objects.</p>
<h3 id="h2-500920c03-0018">A Note on String Concatenation</h3>
<p class="BodyFirst">Up to this point, I’ve been using the addition (<code>+</code>) operator for concatenating strings together. This is acceptable in basic situations.</p>
<p>However, this is seldom the most efficient solution, especially when combining multiple strings. Therefore, it is recommended to prefer the <code>join()</code> method, which is called on a string or string literal instead.</p>
<p>Here’s a comparison between the two. I start with a couple of string variables:</p>
<pre><code>greeting = "Hello"
name = "Jason"</code></pre>
<p class="CodeListingCaption"><a id="listing3-47">Listing 3-47</a>: <em>concat_strings.py:1</em></p>
<p>So far, you’ve seen concatenation with the addition (<code>+</code>) operator, like this:</p>
<pre><code>message = greeting + ", " + name + "!"  # value is "Hello, Jason!"
print(message)</code></pre>
<p class="CodeListingCaption"><a id="listing3-48">Listing 3-48</a>: <em>concat_strings.py:2a</em></p>
<p>Alternatively, I can use the <code>join()</code> method:</p>
<pre><code>message = <b>"".join((</b>greeting, ", ", name, "!"<b>))</b>  # value is "Hello, Jason!"
print(message)</code></pre>
<p class="CodeListingCaption"><a id="listing3-49">Listing 3-49</a>: <em>concat_strings.py:2b</em></p>
<p>I call the <code>join()</code> method on the string that will appear between each piece. In this case, I use an empty string. The <code>join()</code> method accepts a <em>tuple</em> of strings—an array-like structure wrapped in parentheses, and therefore, the double set of parentheses in the code. I’ll introduce tuples in an upcoming section.</p>
<p class="BodyFirst">Typical concatenation with <code>+</code> or the <code>join()</code> function has the same result, but the latter function will be <em>as fast or faster</em>, especially when you’re using other implementations of Python besides CPython. Therefore, whenever you need to concatenate and f-strings aren’t right for the job, you should consider using <code>join()</code> instead of the <code>+</code> or <code>+=</code> operators. In practice, f-strings are the fastest, but <code>join()</code> is your next-best option.</p>
<h2 id="h1-500920c03-0010">Functions</h2>
<p class="BodyFirst">Python functions are <em>first-class citizens</em>, which means they can be treated like any other object. Even so, you call them as you would in any other programming language.</p>
<p><span epub:type="pagebreak" title="63" id="Page_63"/>Here’s an example of a very basic function, which prints a selected type of joke to the terminal.</p>
<p>I start with the function header:</p>
<pre><code>def tell_joke(joke_type):</code></pre>
<p class="CodeListingCaption"><a id="listing3-50">Listing 3-50</a>: <em>joke_function.py:1</em></p>
<p>I declared the function with the <code>def</code> keyword, followed by the name of the function. Parameters are named in the parentheses after the function name. The entire header is concluded with a colon (<code>:</code>).</p>
<p>Below the header, indented one level, is the <em>suite</em> (or body) of the function:</p>
<pre><code>    if joke_type == "funny":
        print("How can you tell an elephant is in your fridge?")
        print("There are footprints in the butter!")
    elif joke_type == "lethal":
        print("Wenn ist das Nunstück git und Slotermeyer?")
        print("Ja! Beiherhund das Oder die Flipperwaldt gersput!")
    else:
        print("Why did the chicken cross the road?")
        print("To get to the other side!")</code></pre>
<p class="CodeListingCaption"><a id="listing3-51">Listing 3-51</a>: <em>joke_function.py:2</em></p>
<p>You call functions in much the same way as in most languages:</p>
<pre><code>tell_joke("funny")</code></pre>
<p class="CodeListingCaption"><a id="listing3-52">Listing 3-52</a>: <em>joke_function.py:3</em></p>
<p>I’ll go into depth on functions and their many cousins in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<h2 id="h1-500920c03-0011">Classes and Objects</h2>
<p class="BodyFirst">Python fully supports object-oriented programming. In fact, one of the language’s design principles is that “everything is an object,” at least behind the scenes.</p>
<p>There’s a lot more to classes than meets the eye, but for now, you should just get an absolutely bare-bones familiarity with the syntax.</p>
<p>The following class contains a joke of a selected type and displays it on demand:</p>
<pre><code>class Joke:</code></pre>
<p class="CodeListingCaption"><a id="listing3-53">Listing 3-53</a>: <em>joke_class.py:1</em></p>
<p>I define the class using the <code>class</code> keyword, the name of the class, and a colon (<code>:</code>) at the end of the header.</p>
<p><span epub:type="pagebreak" title="64" id="Page_64"/>This is followed by the suite of the class, indented one level:</p>
<pre><code>    def __init__(self, joke_type):
        if joke_type == "funny":
            self.question = "How can you tell an elephant is in your fridge?"
            self.answer = "There are footprints in the butter!"
        elif joke_type == "lethal":
            self.question = "Wenn ist das Nunstück git und Slotermeyer?"
            self.answer = "Ja! Beiherhund das Oder die Flipperwaldt gersput!"
        else:
            self.question = "Why did the chicken cross the road?"
            self.answer = "To get to the other side!"</code></pre>
<p class="CodeListingCaption"><a id="listing3-54">Listing 3-54</a>: <em>joke_class.py:2</em></p>
<p>The initializer, which is similar in purpose to the constructor in other OOP languages, is a member function, or <em>method</em>, with the name <code>__init__()</code> and at least one parameter, <code>self</code>.</p>
<pre><code>    def tell(self):
        print(self.question)
        print(self.answer)</code></pre>
<p class="CodeListingCaption"><a id="listing3-55">Listing 3-55</a>: <em>joke_class.py:3</em></p>
<p>Functions that belong to the class are called methods and are part of the class suite. Methods must accept at least one parameter: <code>self</code>.</p>
<p>You would use this class like so:</p>
<pre><code>lethal_joke = Joke("lethal")
lethal_joke.tell()</code></pre>
<p class="CodeListingCaption"><a id="listing3-56">Listing 3-56</a>: <em>joke_class.py:4</em></p>
<p>You create a new instance of the <code>Joke</code> class by passing the string <code>"lethal"</code> to its <em>initializer</em>, the <code>__init__()</code> from earlier. The new object is stored in the variable <code>lethal_joke</code>.</p>
<p>Then, you use the <em>dot operator</em> (<code>.</code>) to call the function <code>tell()</code> within the object. Take note that you didn’t have to pass any argument for <code>self</code>. That’s done automatically when you call the function in this manner.</p>
<p>I’ll discuss classes and objects in detail in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> and further in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</p>
<h2 id="h1-500920c03-0012">Error Handling</h2>
<p class="BodyFirst">Python offers error and exception handling functionality through the <code>try</code> compound statement.</p>
<p>For example, if I wanted to get a number from the user, I couldn’t reliably predict what they would type in. Trying to convert a string, like <code>"spam"</code>, to an integer would cause an error. I can use error handling to take a different action if it isn’t possible to convert the user <code>input</code>.</p>
<pre><code><span epub:type="pagebreak" title="65" id="Page_65"/>num_from_user = input("Enter a number: ")

try:
    num = int(num_from_user)
except ValueError:
    print("You didn't enter a valid number.")
    num = 0

print(f"Your number squared is {num**2}")</code></pre>
<p class="CodeListingCaption"><a id="listing3-57">Listing 3-57</a>: <em>try_except.py</em></p>
<p>I get a string from the user, and then in the <code>try</code> clause, I attempt to convert it to an integer with the <code>int()</code> function. That would raise a <code>ValueError</code> exception if the string it’s trying to convert is not a valid whole number (base 10).</p>
<p>If that exception is raised, I catch it in the <code>except</code> clause and handle the failure.</p>
<p>In any case, the last line would always be run.</p>
<p>There are additional features and subtleties to the <code>try</code> statement, including <code>finally</code> and <code>else</code> clauses, which I’ll cover in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. For now, it’s better to avoid these concepts rather than use them incorrectly.</p>
<h2 id="h1-500920c03-0013">Tuples and Lists</h2>
<p class="BodyFirst">Two of Python’s most common built-in data structures, called <em>collections</em>, are tuples and lists.</p>
<p><em>Lists</em> constitute the most array-like collection in Python. In CPython, they are implemented as variable-length arrays, not as linked lists like the name might suggest.</p>
<p>For example, here is a list of strings with names of cheeses:</p>
<pre><code>cheeses = ["Red Leicester", "Tilsit", "Caerphilly", "Bel Paese"]</code></pre>
<p class="CodeListingCaption"><a id="listing3-58">Listing 3-58</a>: <em>cheese_list.py:1</em></p>
<p>You enclose a list literal in square brackets, separating each item in the list with commas.</p>
<p>You can access or reassign the values of individual items with the same bracket notation used by most programming languages:</p>
<pre><code>print(cheeses[1])  # prints "Tilsit"
cheeses[1] = "Cheddar"
print(cheeses[1])  # prints "Cheddar"</code></pre>
<p class="CodeListingCaption"><a id="listing3-59">Listing 3-59</a>: <em>cheese_list.py:2</em></p>
<p>A <em>tuple</em> is somewhat similar to a list, but with a few key differences. First, a tuple cannot have items added, reassigned, or removed after its creation. Attempting to modify the contents of a tuple with bracket notation will result in a <code>TypeError</code>. This is because tuples, unlike lists, are <em>immutable</em>, <span epub:type="pagebreak" title="66" id="Page_66"/>effectively meaning their contents cannot be modified (see <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> for the full explanation).</p>
<p>Here is an example of a tuple:</p>
<pre><code>answers = ("Sir Lancelot", "To seek the holy grail", 0x0000FF)</code></pre>
<p class="CodeListingCaption"><a id="listing3-60">Listing 3-60</a>: <em>knight_tuple.py:1</em></p>
<p>You enclose tuple literals in parentheses (<code>( )</code>), instead of brackets (<code>[ ]</code>). Nevertheless, you still use bracket notation to access individual items:</p>
<pre><code>print(answers[0])  # prints "Sir Lancelot"</code></pre>
<p class="CodeListingCaption"><a id="listing3-61">Listing 3-61</a>: <em>knight_tuple.py:2</em></p>
<p>As I said, you cannot change the items of a tuple after creation, such as if you tried to reassign the first item:</p>
<pre><code>answers[0] = "King Arthur"  # raises TypeError</code></pre>
<p class="CodeListingCaption"><a id="listing3-62">Listing 3-62</a>: <em>knight_tuple.py:3</em></p>
<p>The guideline is to use tuples for collections of items of different types (<em>heterogeneous</em> collections) and to use lists for collections of items of the same type (<em>homogeneous</em> collections).</p>
<p>I’ll discuss these collections, and many more, in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.</p>
<h2 id="h1-500920c03-0014">Loops</h2>
<p class="BodyFirst">Python has two basic loop types: <em>while</em> and <em>for</em>.</p>
<h3 id="h2-500920c03-0019">while Loop</h3>
<p class="BodyFirst">The <code>while</code> loop probably looks familiar from other languages:</p>
<pre><code>n = 0

while n &lt; 10:
    n += 1
    print(n)</code></pre>
<p class="CodeListingCaption"><a id="listing3-63">Listing 3-63</a>: <em>while_loop.py</em></p>
<p>I start the loop with the <code>while</code> keyword, follow it with the condition to test, and finish the header with a colon (<code>:</code>). As long as that condition evaluates to <code>True</code>, the code in the suite of the loop is executed.</p>
<p>When you need to keep running a loop until some condition is met, use <code>while</code> loops. These are particularly useful when you don’t know how many iterations of the loop will take place before the condition is met.</p>
<h3 id="h2-500920c03-0020"><span epub:type="pagebreak" title="67" id="Page_67"/>Loop Control</h3>
<p class="BodyFirst">You can manually control the loop, using two keywords. The <code>continue</code> keyword abandons the current iteration and jumps to the next one. The <code>break</code> keyword exits the loop altogether.</p>
<p>One common scenario where you may use these keywords is in an infinite loop used for running a game or a user interface. For example, here’s a very simple command prompt:</p>
<pre><code>while True:
    command = input("Enter command: ")
    if command == "exit":
        break
    elif command == "sing":
        print("La la LAAA")
        continue

    print("Command unknown.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-64">Listing 3-64</a>: <em>loop_control.py</em></p>
<p>The loop <code>while True</code> is inherently infinite; <code>True</code> is always <code>True</code>. That’s the behavior I actually want here, since I want to keep iterating until the user enters the string <code>"exit"</code>, at which point, I manually end the loop with <code>break</code>. (By the way, if you’ve been waiting for a <code>do-while</code> loop, this is effectively the way to recreate that behavior.)</p>
<p>The command <code>"sing"</code> has a different behavior, after which I’d want to immediately go to the top and prompt the user for another command, skipping the last print statement. The <code>continue</code> keyword does exactly that, immediately abandoning the current iteration and jumping back to the top of the loop.</p>
<h3 id="h2-500920c03-0021">for Loop</h3>
<p class="BodyFirst">Python’s <code>for</code> loop is a little different from loops in many languages. It’s generally used for iterating over a range, list, or other collection.</p>
<pre><code>for i in range(1, 11):
    print(i)</code></pre>
<p class="CodeListingCaption"><a id="listing3-65">Listing 3-65</a>: <em>for_loop.py</em></p>
<p>I start the loop header with the <code>for</code> keyword. Technically, this kind of loop is a <code>for</code>-<code>in</code> (or “<code>for</code>-<code>each</code>”) loop, meaning the loop iterates once for each item in the given range, list, or other collection. This means the loop needs something to iterate over—in this case, a special object called <code>range()</code>—which iterates over a range of values, returning each one in turn. I’ve specified that I want the range to start with the value <code>1</code> and end before <code>11</code>. The local variable <code>i</code> will refer to the current item for each iteration. Finally, the <code>in</code> keyword precedes the thing I’m iterating over—that is, before <code>range()</code> in this example.</p>
<p><span epub:type="pagebreak" title="68" id="Page_68"/>As long as there are items to iterate over, the code belonging to the loop will be executed—in this case, printing out the value of the current item. The loop stops when the last item is iterated over.</p>
<p>Running this code would print the numbers 1 through 10.</p>
<p>This only scratches the surface of loops. See <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> for more.</p>
<h2 id="h1-500920c03-0015">Structural Pattern Matching</h2>
<p class="BodyFirst">For many years, developers coming to Python from languages like C, C++, Java, or Javascript would ask if there was a Python equivalent to the <code>switch</code>/<code>case</code> statement (or <code>match</code>/<code>case</code> in Scala, <code>case</code>/<code>when</code> in Ruby, and so on). They’d always be disappointed to hear a resounding “No!” Python only had conditional statements.</p>
<p>At long last, Python 3.10 gained <em>structural pattern matching</em> via PEP 634. This provides conditional logic that is at least syntactically similar to <code>switch</code> statements of other languages. In short, you test a single <em>subject</em>, such as a variable, against one or more <em>patterns</em>. If the subject matches the pattern, the associated suite of code runs.</p>
<h3 id="h2-500920c03-0022">Literal Patterns and Wildcards</h3>
<p class="BodyFirst">In the most basic use case, you can check a variable against different possible values. These are called <em>literal patterns</em>. For example, perhaps I want to display different messages, depending on a user’s <code>input</code> <code>lunch</code> <code>order</code>:</p>
<pre><code>lunch_order = input("What would you like for lunch? ")

match lunch_order:
    case 'pizza':
        print("Pizza time!")
    case 'sandwich':
        print("Here's your sandwich")
    case 'taco':
        print('Taco, taco, TACO, tacotacotaco!')
    case _:
        print("Yummy.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-66">Listing 3-66</a>: <em>pattern_match.py:1a</em></p>
<p>The value of <code>lunch_order</code> is compared to each case until it matches one. Once a match is found, the case’s suite is run, and the match statement is finished; the value won’t be checked against additional patterns once it matches one. So, if the user inputs <code class="bold">"pizza"</code>, the <code>"Pizza</code> <code>time!"</code> message is displayed. Similarly, if they input <code class="bold">"taco"</code>, the message <code>"Taco,</code> <code>taco,</code> <code>TACO,</code> <code>tacotacotaco!"</code> is displayed instead.</p>
<p>The underscore (<code>_</code>) in the last case is the <em>wildcard</em>, which will match any value. This serves as a fallback case, and it must come last, as it will match anything.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="69" id="Page_69"/>Pedantic note</h2><p class="BoxBodyFirst">Despite their superficial similarity, <code>match</code> statements are not the same as a C or C++ <code>switch</code> statement. Python’s <code>match</code> statements do not have jump tables, and they therefore have none of the potential performance gains of a <code>switch</code>. But don’t feel too disappointed, as this also means they’re not limited to working with integer types.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c03-0023">Or Patterns</h3>
<p class="BodyFirst">A single case can cover multiple possible values. One way to do this is with an <em>or pattern</em>, where possible literal values are separated by the bar character:</p>
<pre><code>lunch_order = input("What would you like for lunch? ") 

match lunch_order:
    # <var>--snip--</var>
    case 'taco':
        print('Taco, taco, TACO, tacotacotaco!')
    <b>case 'salad' | 'soup':</b>
<b>        print('Eating healthy, eh?')</b>
    case _:
        print("Yummy.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-67">Listing 3-67</a>: <em>pattern_match.py:1b</em></p>
<p>This pattern will match if the user enters either <code class="bold">"salad"</code> or <code class="bold">"soup"</code> at the prompt.</p>
<h3 id="h2-500920c03-0024">Capture Patterns</h3>
<p class="BodyFirst">One particularly helpful feature of structural pattern matching is the ability to capture part or all of the subject. For example, it isn’t very helpful in our example that the fallback case only says <code>"Yummy."</code>. Instead, I’d like to have a default message announcing the user’s selection. To do that, I write a <em>capture pattern</em> like this:</p>
<pre><code>lunch_order = input("What would you like for lunch? ") 

match lunch_order:
    # <var>--snip--</var>
    case 'salad' | 'soup':
        print('Eating healthy, eh?')
    case <b>order</b>:
        print(<b>f"Enjoy your {order}."</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing3-68">Listing 3-68</a>: <em>pattern_match.py:1c</em></p>
<p>This pattern acts like a wildcard, except the value of <code>lunch_order</code> is captured as <code>order</code>. Now, no matter what the user enters, if it doesn’t match any of the previous patterns, the value will be captured and displayed in the message here.</p>
<p><span epub:type="pagebreak" title="70" id="Page_70"/>Capture patterns don’t just have to capture the entire value. For example, I can write a pattern that matches a tuple or list (a <em>sequence</em>) and then captures only part of that sequence:</p>
<pre><code>lunch_order = input("What would you like for lunch? ")
<b>if ' ' in lunch_order:</b>
<b>    lunch_order = lunch_order.split(maxsplit=1)</b>

match lunch_order:
    <b>case (flavor, 'ice cream'):</b>
<b>        print(f"Here's your very grown-up {flavor}...lunch.")</b>
    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing3-69">Listing 3-69</a>: <em>pattern_match.py:1d</em></p>
<p>In this version, if the lunch order has a space, I split the string into two parts, which are stored in a list. Then, if the second item in the sequence has the value <code>"ice cream"</code>, the first part is captured as <code>flavor</code>. Thus, the code can account for Bojan if he decides to break down and have strawberry ice cream for lunch. (And I’m not stopping him!)</p>
<p>The capture pattern feature has one surprising downside: all <em>unqualified</em> names in patterns—that is, any bare variable names with no dots—will be used to capture. This means that if you want to use the value assigned to some variable, it must be <em>qualified</em>, meaning you must access it within some class or module with the dot operator:</p>
<pre><code><b>class Special:</b>
<b>    TODAY = 'lasagna'</b>

lunch_order = input("What would you like for lunch? ")

match lunch_order:
<b>    case Special.TODAY:</b>
<b>        print("Today's special is awesome!")</b>
    case 'pizza':
        print("Pizza time!")
    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing3-70">Listing 3-70</a>: <em>pattern_match.py:1e</em></p>
<h3 id="h2-500920c03-0025">Guard Statements</h3>
<p class="BodyFirst">One last trick I’ll demonstrate with pattern matching is the <em>guard statement</em>, an additional conditional statement that must be satisfied for a pattern to match.</p>
<p>For example, in the current version of my lunch order example, using the logic to split the order by spaces means the code doesn’t behave very nicely with other foods with spaces in them. Also, if I enter <code class="bold">"rocky road ice cream"</code>, it won’t match the current ice cream pattern.</p>
<p>Instead of splitting my string by spaces, I can write a pattern with a guard statement that looks for the words <em>ice cream</em> in the lunch order.</p>
<pre><code><span epub:type="pagebreak" title="71" id="Page_71"/>class Special:
    TODAY = 'lasagna'

lunch_order = input("What would you like for lunch? ")

match lunch_order:
    # <var>--snip--</var>
    case 'salad' | 'soup':
        print('Eating healthy, eh?')
<b>    case ice_cream if 'ice cream' in ice_cream:</b>
<b>        flavor = ice_cream.replace('ice cream', '').strip()</b>
<b>        print(f"Here's your very grown-up {flavor}...lunch.")</b>
    case order:
        print(f"Enjoy your {order}.")</code></pre>
<p class="CodeListingCaption"><a id="listing3-71">Listing 3-71</a>: <em>pattern_match_object.py:1f</em></p>
<p>The pattern here captures the value as <code>ice_cream</code>, but only if the guard statement <code>if 'ice cream' in ice_cream</code> is satisfied. In that case, I use <code>.replace()</code> to remove the words <em>ice cream</em> from the captured value, leaving me with only the name of the flavor. I also use <code>.strip()</code> to remove any leading or trailing whitespace from the new string. Finally, I print out my message.</p>
<h3 id="h2-500920c03-0026">More About Structural Pattern Matching</h3>
<p class="BodyFirst">There are quite a few other tricks and techniques that work with structural pattern matching. They work with objects (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>), with dictionaries via mapping patterns (see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>), and even by support nesting patterns within other patterns.</p>
<p>As with many Python techniques, pattern matching feels like “magic,” and there’s a strong temptation to use it everywhere possible. Resist this urge! Structural pattern matching is very useful for checking a single subject against multiple possible patterns, but as you can even see from the “ice cream” situation in the lunch order example, it quickly reaches its limits as the possible values of the subject get more elaborate. As a rule, if you’re unsure whether you need structural pattern matching in a particular situation, stick with conditional statements.</p>
<p>To learn even more, read PEP 636, which serves as the official tutorial for this topic and demonstrates all of the functionality available with this language feature: <a href="https://peps.python.org/pep-0636/" class="LinkURL">https://peps.python.org/pep-0636/</a>.</p>
<h2 id="h1-500920c03-0016">Wrapping Up</h2>
<p class="BodyFirst">You should now have a feeling for Python’s syntax and a basic familiarity with its key structures. If you were to stop here, you could probably write Python code that at least works. In fact, many developers new to the language do indeed work with about this much information, implicitly bringing the habits and practices of whatever language they know best.</p>
<p>There is a profound difference between valid code and idiomatic, Pythonic code. Writing the latter is the focus of this book.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="73" id="Page_73"/>4</span><br/>
<span class="ChapterTitle">Project Structure and Imports</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">I’ve found that structuring a Python project is one of the most often overlooked components of teaching the language. Many developers therefore get their project structure wrong, stumbling through a jumble of common mistakes until they arrive at something that at least works.</p>
<p>Here’s the good news: you don’t have to be one of them!</p>
<p>In this chapter, I’ll introduce import statements, modules, and packages, and I’ll show you how to fit everything together without tearing your hair out.</p>
<p>Be aware, I’m skipping over one critical piece of project structure in this chapter: <em>setup.cfg</em>, as it relies on concepts we haven’t yet covered. Without a <em>setup.cfg</em> or <em>setup.py</em> file, your project will not be ready to ship to end users. In this chapter, you’ll put everything in the right place for development. From there, preparing your project for distribution will be a fairly simple process. I’ll cover <em>setup.cfg</em>, <em>setup.py</em>, and other project structure issues relating to distribution in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>.</p>
<h2 id="h1-500920c04-0001"><span epub:type="pagebreak" title="74" id="Page_74"/>Setting Up the Repository</h2>
<p class="BodyFirst">Before delving into the actual project structure, I want to address how it will fit into your <em>version control system (VCS)</em>, which I recommend using. For the rest of this book, I’ll assume you’re using Git, as that’s the most common option.</p>
<p>Once you’ve created your repository and cloned a local copy to your computer, you can begin to set up your project. At minimum, create the following files:</p>
<ul>
<li><em>README</em>, which is a description of your project and its goals</li>
<li><em>LICENSE</em>, which is your project’s license</li>
<li><em>.gitignore</em>, which is a special file that tells Git what files and directories to ignore</li>
<li>A directory, which has the name of your project</li>
</ul>
<p>Your Python code belongs in a separate subdirectory and not in the root of the repository. This is very important, as your repository’s root directory will get mighty cluttered with build files, packaging scripts, documentation, virtual environments, and all manner of other things that aren’t actually part of the source code.</p>
<p>As an example, in this chapter, I’ll use one of my own Python projects: <em>omission</em>.</p>
<p>A Python project is composed of modules and packages. In the next section, I’ll cover what those are and how to create them.</p>
<h2 id="h1-500920c04-0002">Modules and Packages</h2>
<p class="BodyFirst">A <em>module</em> is any Python (<em>.py</em>) file. (Anticlimactic, isn’t it?)</p>
<p>A <em>package</em>, occasionally called a <em>regular package</em>, is one or more modules within a directory. That directory must include a file called <em>__init__.py</em> (which can be empty). The <em>__init__.py</em> file is important! If it isn’t there, Python will not know the directory constitutes a package.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">Modules are actually objects, not just files. They can come from places other than the filesystem, including compressed files and network locations. Packages are modules too, just with a <code>__path__</code> attribute. Chances are, this will never matter for what you’re doing, but once you get deep into the import system, this distinction <em>will</em> matter.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>You can leave the <em>__init__.py</em> file empty (it often is), or you can use it to run certain code when the package is first imported. For example, you might use <code>__init__.py</code> to select and rename certain functions, so the end user of the package doesn’t need to understand how the modules are laid out. (See the subsection “<span class="xref" itemid="xref_target_Controlling Package Imports">Controlling Package Imports</span>” later in the chapter.)</p>
<p><span epub:type="pagebreak" title="75" id="Page_75"/>If you do forget <em>__init__.py</em> in your package, it becomes an <em>implicit namespace package</em>, also just known as a <em>namespace package</em>. These behave differently from regular packages. <b><i>The two are not interchangeable!</i></b> A namespace package allows you to distribute a package in multiple pieces, called <em>portions</em>. There are some cool advanced things you can do with namespace packages, but you will seldom need them. As this is a doozy of a rabbit hole, if you need namespace packages, see the documentation at <a href="https://packaging.python.org/guides/packaging-namespace-packages/" class="LinkURL">https://packaging.python.org/guides/packaging-namespace-packages/</a>. You can also read PEP 420, which officially defined the concept.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>gotcha Alert</h2>	<p class="BoxBodyFirst">A number of articles, posts, and Stack Overflow answers claim that since Python 3, you no longer need <em>__init__.py</em> in packages. This is entirely <b><i>false</i></b>! Namespace packages are for very specific edge cases; they cannot replace “traditional” packages.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside><p>In my project structure, <em>omission</em> is a package that contains other packages. Thus, <em>omission</em> is my <em>top-level package</em>, and all the packages underneath it are its <em>subpackages</em>. This convention will be important once you start importing stuff.</p>
<h3 id="h2-500920c04-0001">PEP 8 and Naming</h3>
<p class="BodyFirst">Your packages and modules need clear names to identify them. Consulting with PEP 8 about the naming conventions reveals this:</p>
<blockquote class="blockquote">
<p class="Blockquote">Modules should have short, all-lowercase names. Underscores can be used in the module name if it improves readability. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged.</p>
</blockquote>
<p>Understand that modules are named by filenames and packages are named by their directory name. Thus, these conventions define how you name your directories and code files.</p>
<p>To reiterate, filenames should be all lowercase, with underscores (<code>_</code>) if that improves readability. Similarly, directory names should be all lowercase, without underscores if at all possible. To put that another way . . .</p>
<ol class="none">
<li>Do this: <em>omission/data/data_loader.py</em></li>
<li>NOT this: <em>omission/Data/DataLoader.py</em></li>
</ol>
<h3 id="h2-500920c04-0002">Project Directory Structure</h3>
<p class="BodyFirst">With that covered, take a look at my project’s repository directory structure:</p>
<pre><code>omission-git/
├── LICENSE.md
├── omission/
│   ├── __init__.py
│   ├── __main__.py
<span epub:type="pagebreak" title="76" id="Page_76"/>│   ├── app.py
│   ├── common/
│   │   ├── __init__.py
│   │   ├── classproperty.py
│   │   ├── constants.py
│   │   └── game_enums.py
│   ├── data/
│   │   ├── __init__.py
│   │   ├── data_loader.py
│   │   ├── game_round_settings.py
│   │   ├── scoreboard.py
│   │   └── settings.py
│   ├── interface/
│   ├── game/
│   │   ├── __init__.py
│   │   ├── content_loader.py
│   │   ├── game_item.py
│   │   ├── game_round.py
│   │   └── timer.py
│   ├── resources/
│   └── tests/
│       ├── __init__.py
│       ├── test_game_item.py
│       ├── test_game_round_settings.py
│       ├── test_scoreboard.py
│       ├── test_settings.py
│       ├── test_test.py
│       └── test_timer.py
├── omission.py
├── pylintrc
├── README.md
└── .gitignore</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Directory structure of <em>omission-git/</em></p>
<p>You’ll see that I have one top-level package called <em>omission</em>, with four subpackages: <em>common/</em>, <em>data/</em>, <em>game/</em>, and <em>tests/</em>. Each subpackage contains an <em>__init__.py</em> file, which is what designates them as packages. Every file that ends in <em>.py</em> is a module.</p>
<p>I also have the directory <em>resources/</em>, but that only contains game audio, images, and other sundry files (omitted here for brevity). The <em>resources/</em> directory is <em>not</em> a regular package, as it doesn’t contain an <em>__init__.py</em>.</p>
<p>I have another special file in my top-level package: <em>__main__.py</em>. This is the file that runs when I execute my top-level package directly, via this command:</p>
<pre><code>python3 -m omission</code></pre>
<p>I’ll come back to <em>__main__.py</em> in a bit (see the subsection “<span class="xref" itemid="xref_target_Package Entry Points">Package Entry Points</span>” later in the chapter), as well as explain that lonely little <em>omission.py</em> file outside the top-level package.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="77" id="Page_77"/>Pedantic NOTE</h2><p class="BoxBodyFirst">This is a good project structure to start with, but once tests and packaging get involved, you’ll have much better success with a slightly modified structure involving an <em>src/</em> directory. I’ll cover this in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c04-0003">How import Works</h2>
<p class="BodyFirst">If you’ve written any meaningful Python code before, you’re almost certainly familiar with the <code>import</code> statement for importing modules. For example, to use it to import the module for regex, you’d enter this:</p>
<pre><code>import re</code></pre>
<p>Once you’ve imported a module, you can access any variables, functions, or classes defined within it.</p>
<p>When you import the module, you are actually running it, which in turn executes any other <code>import</code> statements in the module. If there are any errors or performance costs in those secondarily (and onward) imported modules, they might seem to originate from your otherwise innocent import statement. It also means that Python has to be able to find all those modules.</p>
<p>For example, the module <em>re.py</em>, which is part of the Python standard library, has several import statements of its own, which are executed when you <code>import re</code>. The contents of those imported modules aren’t automatically available to the file you imported <code>re</code> from, but those module files have to exist for <code>import re</code> to succeed. If, for some unlikely reason, <em>enum.py</em> (another module that is part of the Python standard library) got deleted from your Python environment and you ran <code>import re</code>, it would fail with an error:</p>
<pre><code>Traceback (most recent call last):
File "weird.py", line 1, in 
import re
File "re.py", line 122, in 
import enum
ModuleNotFoundError: No module named 'enum'</code></pre>
<p>This might seem like a confusing error message. I’ve seen people erroneously wonder why the outer module (in this example, <code>re</code>) couldn’t be found. Others have wondered why the inner module (<code>enum</code> here) is being imported at all, since they didn’t ask for it directly in their code.</p>
<p>The problem is that the <code>re</code> module was imported, and that in turn imported the <code>enum</code> module. However, because the <code>enum</code> module is missing, importing <code>re</code> fails with a <code>ModuleNotFoundError</code>.</p>
<p>Take note that this scenario is fictional: <code>import enum</code> and <code>import re</code> will never fail under normal circumstances, because both modules are part of Python’s standard library. However, this little example demonstrates the common problem of <code>import</code> statements failing due to missing modules.</p>
<h2 id="h1-500920c04-0004"><span epub:type="pagebreak" title="78" id="Page_78"/>Import Dos and Don’ts</h2>
<p class="BodyFirst">There are various ways of importing, but most of them should rarely, if ever, be used.</p>
<p>For the upcoming examples, I’ll be using a module called <em>smart_door.py</em>, which reads as follows:</p>
<pre><code>#!/usr/bin/env python3


def open():
    print("Ahhhhhhhhhhhhhh.")


def close():
    print("Thank you for making a simple door very happy.")</code></pre>
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: <em>smart_door.py</em></p>
<p>Let’s say I want to use this module in another Python file, which (in this example) is in the same directory. To run the functions defined in that module, I’d have to first import the module <code>smart_door</code>. The easiest way to do this is as follows:</p>
<pre><code>import smart_door
smart_door.open()
smart_door.close()</code></pre>
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: <em>use_smart_door.py:1a</em></p>
<p>The <em>namespace</em> of <code>open()</code> and <code>close()</code> is <code>smart_door</code>. A <em>namespace</em> is an explicitly defined path to something, such as a function. The function <code>open()</code> has the namespace <code>smart_door</code>, which tells me that <code>open()</code> belongs to that particular module. Remember this from The Zen of Python?</p>
<blockquote class="blockquote">
<p class="Blockquote">Namespaces are one honking great idea—let’s do more of those!</p>
</blockquote>
<p>Python developers really like namespaces because they make it obvious where functions and whatnot are coming from. That comes in handy when you have multiple functions that have similar names or the same name, but that are defined in different modules. Without that bit of namespace, <code>smart_door</code>, you would not know that <code>open()</code> had anything to do with opening the smart door. Appropriately using namespaces can help you avoid massive errors in your code. However, as important as namespaces are, they can get out of hand very quickly if used improperly.</p>
<p>Be advised, in referring to <em>namespaces</em>, I’m not necessarily talking about <em>implicit namespace packages</em>, which I don’t cover in this book.</p>
<p>Here’s a look at some good and bad examples of namespaces in action.</p>
<h3 id="h2-500920c04-0003"><span epub:type="pagebreak" title="79" id="Page_79"/>Importing Functions from Modules</h3>
<p class="BodyFirst">In my previous <code>smart_door</code> function calls, I referenced the namespace on every function call. This is usually best when a function is called only a handful of times, but if you use a function often, it gets tedious to use a namespace for every single function call.</p>
<p>Thankfully, Python provides a way around that. To be able to use the <code>open()</code> function without constantly having to precede it with its module name (<code>smart_door</code>), I need only know the <em>qualified name</em>—that is, the name of the function, class, or variable, preceded by its complete namespace within one of its modules or packages (if any). Within the <em>smart_door.py</em> module, the qualified name of the function I want is just <code>open</code>. Thus, I import that function like this, instead:</p>
<pre><code><b>from</b> smart_door <b>import open</b>
open()</code></pre>
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4</a>: <em>use_smart_door.py:1b</em></p>
<p>This introduces a new problem. Neither <code>close()</code> nor <code>smart_door.close()</code> will work in this example, because I didn’t import the function outright. The entire <code>smart_door</code> module was still run by the import command, but only the <code>open()</code> function was actually imported. To use <code>smart_door.close()</code>, I’d need to change the code to this:</p>
<pre><code>from smart_door import open<b>, close</b>
open()
<b>close()</b></code></pre>
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5</a>: <em>use_smart_door.py:1c</em></p>
<p>This gives me access to both functions, no namespace required.</p>
<h3 id="h2-500920c04-0004">The Problem of Shadowing</h3>
<p class="BodyFirst">You might have noticed another problem: <code>open()</code> is already a built-in Python function! Assume I also need to read a file called <em>data.txt</em>, which exists in my current directory. If I try this after importing <code>open()</code> from the <code>smart_door</code> function (<a href="#listing4-5" id="listinganchor4-5">Listing 4-5</a>), my program is going to behave very badly:</p>
<pre><code>somefile = open("data.txt", "r")
# ...work with the file...
somefile.close()</code></pre>
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6</a>: <em>use_smart_door.py:2</em></p>
<p>When I used <code>open()</code> earlier (<a href="#listing4-5">Listing 4-5</a>), I wanted to use <code>smart_door.open()</code>. Now, in the same file, I’m trying to call Python’s built-in <code>open()</code> function to open a text file for reading. Unfortunately, because of the earlier import, the built-in <code>open()</code> function has been <em>shadowed</em> by <code>smart_door.open()</code>, meaning the presence of the latter is making it impossible for Python to even find the former. This code will fail!</p>
<pre><code><span epub:type="pagebreak" title="80" id="Page_80"/>Traceback (most recent call last):
  File "ch4_import2-bad.py", line 9, in &lt;module&gt;
    somefile = open("data.txt", "r")
TypeError: open() takes no arguments (2 given)</code></pre>
<p>I got that error because I’m trying to use the built-in <code>open()</code> function, which accepts two arguments, but I unintentionally called <code>smart_door.open()</code>, which doesn’t accept any arguments.</p>
<p>Getting an actual error message is one of the better failure scenarios for this sort of mistake. Imagine if <code>smart_door.open()</code> did accept similar arguments to the built-in <code>open()</code>. Depending on my code, I might wind up with an error elsewhere (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect but technically valid behavior. This sort of mistake is infamously difficult to debug, so it is wise to avoid.</p>
<p>So how should I fix this? If I were the one who wrote <em>smart_door.py</em>, I should just go and change the function name. It’s universally considered bad practice to use function names that shadow built-in Python functions anyhow, unless the entire point <em>is</em> to shadow. However, assume that I’m not the author of that module and I need another solution. Thankfully, Python offers one in the <code>as</code> keyword, which allows me to create an alias for that function:</p>
<pre><code>from smart_door import open as door_open
from smart_door import close

door_open()
close()</code></pre>
<p class="CodeListingCaption"><a id="listing4-7">Listing 4-7</a>: <em>use_smart_door.py:1d</em></p>
<p>In the import, I use the <code>as</code> keyword to rename <code>smart_door.open()</code> to <code>door_open()</code>, but only in the context of this file. Then, I can refer to <code>door_open()</code> where I wanted <code>smart_door.open()</code>.</p>
<p> This leaves Python’s built-in <code>open()</code> function unshadowed, so the earlier code for working with the file (<a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a>) can function properly.</p>
<pre><code>somefile = open("data.txt", "r")
# ...work with the file...
somefile.close()</code></pre>
<h3 id="h2-500920c04-0005">The Trouble with Nested Packages</h3>
<p class="BodyFirst">As you’ve seen, packages can contain other packages. In my <em>omission</em> project, if I wanted to import the module <em>data_loader.py</em>, I could use this line (refer back to the <em>omission</em> project structure):</p>
<pre><code>import omission.data.data_loader</code></pre>
<p>The Python interpreter looks for the <em>omission</em> package, the <em>data</em> package inside that, and the <em>data_loader</em> module inside that. The <em>data_loader</em> module (and only that module) is imported. This is a good structure, and all’s well.</p>
<p><span epub:type="pagebreak" title="81" id="Page_81"/>At a certain point, however, nesting packages can become a pain. A function call like <code>musicapp.player.data.library.song.play()</code> is just ugly, not to mention, difficult to read. As The Zen of Python muses:</p>
<blockquote class="blockquote">
<p class="Blockquote">Flat is better than nested.</p>
</blockquote>
<p>Some nesting of packages is certainly okay, but when your project starts looking like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize your modules into packages, but keep the structure reasonably simple. Nesting two or three packages deep is okay; deeper is generally not advisable, if it can be avoided.</p>
<p>Although we’d never have overly nested nightmares in an ideal world, real-life projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting structures. I need another way to keep my import statements sane. Graciously, the import system can handle this:</p>
<pre><code>from musicapp.player.data.library.song import play

play()</code></pre>
<p>I only have to deal with the deeply nested namespace once, in the actual import statement. After that, I just use the function name, <code>play()</code>.</p>
<p>Alternatively, if I want a little bit of namespace, I can have that, too:</p>
<pre><code>from musicapp.player.data.library import song

song.do_thing()</code></pre>
<p>My import statement has resolved all but that last bit of namespace, <code>song</code>, so I still know where the <code>play()</code> function is coming from.</p>
<p>The import system is deliciously flexible like that.</p>
<h3 id="h2-500920c04-0006">Beware of Importing All</h3>
<p class="BodyFirst">Before long, you’ll probably find yourself tempted to import all of the hundreds of functions in your module, to save time. This is the point at which many developers go off the rails:</p>
<pre><code>from smart_door import *</code></pre>
<p>This statement imports nearly everything in the module directly, except for anything preceded by one or more underscores. This import-all pattern is a Very Bad Idea, as you won’t know what all is getting imported or what will be shadowed in the process.</p>
<p>The problem gets even worse when you start importing all from multiple modules:</p>
<pre><code>from smart_door import *
from gzip import *
open()</code></pre>
<p><span epub:type="pagebreak" title="82" id="Page_82"/>Doing this, you may be blissfully unaware that <code>open()</code>, <code>smart_door.open()</code>, and <code>gzip.open()</code> all exist and are fighting over the same name in your file! The function <code>gzip.open()</code> will win out in this example, because it’s the last version of <code>open()</code> that was imported. The other two functions have been shadowed, which means you effectively can’t call them at all.</p>
<p>Since no one is likely to remember every single function, class, and variable in every module that gets imported, one can easily wind up with a whole lot of messes.</p>
<p>The Zen of Python applies to this situation:</p>
<blockquote class="blockquote">
<p class="Blockquote">Explicit is better than implicit.</p>

<p class="Blockquote">(. . .)</p>
<p class="Blockquote">In the face of ambiguity, refuse the temptation to guess.</p></blockquote>
<p>You should never have to guess where a function or variable is coming from. There should be code somewhere in the file that explicitly tells you where everything comes from, as seen in the preceding examples.</p>
<p>This <code>import *</code> doesn’t quite work the same way with packages. By default, a line like <code>from some_package import *</code> will be functionally the same as <code>import some_package</code>, unless the package has been configured to work with <code>import *</code>. I’ll come back to this later.</p>
<h2 id="h1-500920c04-0005">Importing Within Your Project</h2>
<p class="BodyFirst">Now that you know how to structure your project and import from packages and modules, I’ll tie everything together.</p>
<p>Recall my <em>omission</em> project structure from <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>. Here’s a subsection of that project directory:</p>
<pre><code>omission-git/
└── omission/
    ├── __init__.py
    ├── __main__.py
    ├── app.py
    ├── common/
    │   ├── __init__.py
    │   ├── classproperty.py
    │   ├── constants.py
    │   └── game_enums.py
    ├── data/
    │   ├── __init__.py
    │   ├── data_loader.py
    │   ├── game_round_settings.py
    │   ├── scoreboard.py
    │   └── settings.py</code></pre>
<p class="CodeListingCaption"><a id="listing4-8">Listing 4-8</a>: Directory structure of <em>omission-git/</em></p>
<p><span epub:type="pagebreak" title="83" id="Page_83"/>Any one module in my project may need to be able to import from another module, whether it’s within the same package or somewhere else in the project structure. I’ll explain how to handle both scenarios.</p>
<h3 id="h2-500920c04-0007">Absolute Imports</h3>
<p class="BodyFirst">I have a class <code>GameMode</code> defined within the <em>game_enums.py</em> module<span class="CodeAnnotation" aria-label="annotation"><span class="CodeAnnotation"/></span>, which lives in the <em>omission/common</em> package. I want to use that class within my <em>game_round_settings.py</em> module, defined in the <em>omission/data</em> package. How do I get to it?</p>
<p>Because I defined <em>omission</em> as a top-level package and organized my modules into subpackages, it’s pretty straightforward. In <em>game_round_settings.py</em>, I’d write the following:</p>
<pre><code>from omission.common.game_enums import GameMode</code></pre>
<p class="CodeListingCaption"><a id="listing4-9">Listing 4-9</a>: <em>game_round_settings.py:1a</em></p>
<p>This line is an <em>absolute import</em>. It starts at the top-level package, <em>omission</em>, and walks down into the <em>common</em> package, where it looks for <em>game_enums.py</em>. Inside that module, it finds whatever has the name <code>GameMode</code> and imports that.</p>
<h3 id="h2-500920c04-0008">Relative Imports</h3>
<p class="BodyFirst">You can also import from a module in the same package or subpackage. This is known as a <em>relative import</em> or an <em>intrapackage reference</em>. In practice, intra-package references are easy to do wrong. If some developer wanted to import <code>GameMode</code> (which is provided by <em>omission/common/game_enums.py</em>) into <em>omission/data/game_round_settings.py</em>, they might incorrectly attempt to use something like the following:</p>
<pre><code>from common.game_enums import GameMode</code></pre>
<p class="CodeListingCaption"><a id="listing4-10">Listing 4-10</a>: <em>game_round_settings.py:1b</em></p>
<p>This fails, leaving the developer wondering why it doesn’t work. The <em>data</em> package (where <em>game_round_settings.py</em> lives) has no knowledge of its sibling packages, such as <em>common</em>.</p>
<p>A module knows what package it belongs to, and a package knows its parent package (if it has one). Because of this, relative imports can start the search from the current package and move up and down through the project structure.</p>
<p>Within <em>omission/data/game_round_settings.py</em>, I can use the following import statement:</p>
<pre><code>from <b>..</b>common.game_enums import GameMode</code></pre>
<p class="CodeListingCaption"><a id="listing4-11">Listing 4-11</a>: <em>game_round_settings.py:1c</em></p>
<p><span epub:type="pagebreak" title="84" id="Page_84"/>The two dots (<code>..</code>) mean “the current package’s direct parent package,” which, in this case, is <em>omission</em>. The import steps up one level, walks down into <em>common</em>, and finds <em>game_enums.py</em>.</p>
<p>There’s some difference of opinion among Python developers about whether to use absolute or relative imports. Personally, I prefer to use absolute imports whenever possible, because I feel it makes the code a lot more readable. You can make up your own mind. The only important factor is that the result should be <em>obvious</em>—there should be no mystery about where anything comes from.</p>
<h3 id="h2-500920c04-0009">Importing from the Same Package</h3>
<p class="BodyFirst">There is one other lurking gotcha here. In <em>omission/data/settings.py</em>, I have this statement for importing a class from the module <em>omission/data/game_round_settings.py</em>:</p>
<pre><code>from omission.data.game_round_settings import GameRoundSettings</code></pre>
<p class="CodeListingCaption"><a id="listing4-12">Listing 4-12</a>: <em>settings.py:1a</em></p>
<p>You might think that since both <em>settings.py</em> and <em>game_round_settings.py</em> are in the same package, <em>data</em>, I should be able to just use this:</p>
<pre><code>from game_round_settings import GameRoundSettings</code></pre>
<p class="CodeListingCaption"><a id="listing4-13">Listing 4-13</a>: <em>settings.py:1b</em></p>
<p>However, that will not work. It will fail to locate the <em>game_round_settings.py</em> module because I am running the top-level package (<code>python3 -m omission</code>), and absolute imports for anything within the package being executed (<em>omission</em>) have to start from the top.</p>
<p>I can instead use a relative import, which looks much simpler than the absolute import:</p>
<pre><code>from <b>.</b>game_round_settings import GameRoundSettings</code></pre>
<p class="CodeListingCaption"><a id="listing4-14">Listing 4-14</a>: <em>settings.py:1c</em></p>
<p>In this case, the single dot (<code>.</code>) means “this package.”</p>
<p>This probably feels familiar if you’re used to the typical UNIX filesystem, although Python takes the concept a bit further:</p>
<ol class="none">
<li>One dot (<code>.</code>) means the current package.</li>
<li>Two dots (<code>..</code>) takes you back one level, to the parent package.</li>
<li>Three dots (<code>...</code>) takes you back two levels, to the parent of the parent package.</li>
<li>Four dots (<code>....</code>) takes you back three levels.</li>
</ol>
<p>And so on, and so forth.</p>
<p><span epub:type="pagebreak" title="85" id="Page_85"/>Keep in mind that those “levels” aren’t just plain directories; they’re packages. If you have two distinct packages in a plain directory that isn’t a package, you can’t use relative imports to jump from one to another. You’ll have to work with the Python search path for that. I’ll talk more about that later in this chapter.</p>
<h2 id="h1-500920c04-0006">Entry Points</h2>
<p class="BodyFirst">So far, you’ve learned how to create modules, packages, and projects, and how to make full use of the import system. The last piece of this puzzle is gaining the ability to control what happens when a package is imported or executed. The parts of the project that are run first when importing or executing are called <em>entry points</em>.</p>
<h3 id="h2-500920c04-0010">Module Entry Points</h3>
<p class="BodyFirst">When you import a Python module or package, it is given a special variable called <code>__name__</code>. This contains the <em>fully qualified name</em> of the module or package, which is the name as the import system sees it. For example, the fully qualified name of the module <em>omission/common/game_enums.py</em> would be <code>omission.common.game_enums</code>. There is one exception: when a module or package is run directly, its <code>__name__</code> is set to the value <code>"__main__"</code>.</p>
<p>To demonstrate this, assume I have a package called <em>testpkg</em>, which contains the module <em>awesome.py</em>. It defines a function, <code>greet()</code>:</p>
<pre><code>def greet():
    print("Hello, world!")</code></pre>
<p class="CodeListingCaption"><a id="listing4-15">Listing 4-15</a>: <em>awesome.py:1</em></p>
<p>The bottom of that same file also contains a <code>print</code> message:</p>
<pre><code>print("Awesome module was run.")</code></pre>
<p class="CodeListingCaption"><a id="listing4-16">Listing 4-16</a>: <em>awesome.py:2a</em></p>
<p>In another module in the same directory as <em>testpkg</em>, I have this module (<em>example.py</em>), which I run directly with <code>python3 example.py</code>:</p>
<pre><code>from testpkg import awesome

print(__name__)          # prints "__main__"
print(awesome.__name__)  # prints "testpkg.awesome"</code></pre>
<p class="CodeListingCaption"><a id="listing4-17">Listing 4-17</a>: <em>example.py</em></p>
<p>If I look at the <code>_name_</code> local variable—which is the <code>__name__</code> presently assigned to the current module, <em>example.py</em>—I’ll see the value is <code>"__main__"</code> because I executed <em>example.py</em> directly.</p>
<p><span epub:type="pagebreak" title="86" id="Page_86"/>The package <code>awesome</code> I imported also has a <code>__name__</code> variable, which has the value <code>"testpkg.awesome"</code>, representing where the package came from in the import system.</p>
<p>If you ran that module, you’d get the following output:</p>
<pre><code>Awesome module was run.
__main__
testpkg.awesome</code></pre>
<p>That first line is coming from <em>testpkg/awesome.py</em>, which is run by the import command. The rest is coming from the two print commands in <em>example.py</em>. </p>
<p>But what if I want that first message to appear only if <em>awesome.py</em> is executed directly, and <em>not</em> when the module is only imported? To accomplish that, I’d check the value of <code>__name__</code> variable in a conditional statement. I’ve rewritten my <em>awesome.py</em> file to do exactly that:</p>
<pre><code><b>if __name__ == "__main__":</b>
    print("Awesome module was run.")</code></pre>
<p class="CodeListingCaption"><a id="listing4-18">Listing 4-18</a>: <em>awesome.py:2b</em></p>
<p>If <em>awesome.py</em> is executed directly, <code>__name__</code> will have the value <code>"__main__"</code>, so the print statement will run. Otherwise, if <em>awesome.py</em> is being imported (or otherwise run indirectly), the conditional will fail.</p>
<p>While you’ll frequently see this pattern in Python, some Python experts consider it an anti-pattern, because it can encourage you to both execute and import a module at the same time. While I don’t agree that using <code>if__name__ == "__main__"</code> is an anti-pattern, you often don’t need it. In any case, be certain you never import your main module from anywhere else in your package.</p>
<h3 id="h2-500920c04-0011">Package Entry Points</h3>
<p class="BodyFirst">Notice that my <em>omission</em> project has a file called <code>__main__</code> in the top-level package. This file is automatically run when a package is executed directly, but never when importing the package.</p>
<p>So, when executing <em>omission</em> via <code>python3 -m omission</code>, Python first runs the <em>__init__.py</em> module (as always), followed by its <em>__main__.py</em> module. Otherwise, if the package is imported instead, only <em>__init__.py</em> is executed.</p>
<p>If you omit <em>__main__.py</em> from a package, it cannot be executed directly.</p>
<p>A good <em>__main__.py</em> for a top-level package would look something like the following:</p>
<pre><code>def main():
    # Code to start/run your package.

if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing4-19">Listing 4-19</a>: <em>__main__.py</em></p>
<p><span epub:type="pagebreak" title="87" id="Page_87"/>All the logic for starting the package belongs in the <code>main()</code> function. Then, the <code>if</code> statement checks the <code>__name__</code> assigned to the <em>__main__.py</em> module. Since this package is being executed directly, the value of <code>__name__</code> is <code>"__main__"</code>, and the code within the <code>if</code> statement, being the call to the <code>main()</code> function, is run. Otherwise, if <em>__main__.py</em> were only being imported, its fully qualified name would include its containing package (for example, <code>omission.__main__</code>), the condition would fail, and the code wouldn’t run.</p>
<h3 id="h2-500920c04-0012">Controlling Package Imports</h3>
<p class="BodyFirst">A package’s <em>__init__.py</em> file can come in handy when you want to change what is available for import and how it can be used. The most common uses for this file are to simplify imports and to control the behavior of import-all (<code>import *</code>).</p>
<h4 id="h3-500920c04-0001">Simplifying Imports</h4>
<p class="BodyFirst">Imagine I have a particularly complicated package, <code>rockets</code>, which is made up of dozens of subpackages and hundreds of modules. I can safely assume that many developers using the package won’t want to know about most of that functionality. They only want one thing: to define a rocket and then launch it! Instead of expecting all the users of my package to know where those few basic bits of functionality exist in the package structure, I can use <em>__init__.py</em> to expose said functionality directly, making the bits easier to import later:</p>
<pre><code>from .smallrocket.rocket import SmallRocket
from .largerocket.rocket import LargeRocket
from .launchpad.pad import Launchpad</code></pre>
<p class="CodeListingCaption"><a id="listing4-20">Listing 4-20</a>: <em>__init__.py:1</em></p>
<p>This greatly simplifies the usage of the package. I no longer need to remember where things like the <code>SmallRocket</code> and <code>Launchpad</code> classes live in the <code>rockets</code> package structure. I can import them directly from the top-level package and use them:</p>
<pre><code>from rockets import SmallRocket, Launchpad

pad = Launchpad(SmallRocket())
pad.launch()</code></pre>
<p class="CodeListingCaption"><a id="listing4-21">Listing 4-21</a>: <em>rocket_usage.py</em></p>
<p>Beautifully simple, isn’t it? Still, nothing is actually <em>preventing</em> me from importing things the long-form way (such as <code>from rockets.smallrocket.rocket import SmallRocket</code>) if I need to. The shortcut is there, but it’s optional.</p>
<p>Because simplicity is such an essential part of the Python philosophy, it is also an essential component of package design. If you can anticipate the most common ways a user might interact with your package, you can greatly simplify their code by adding a few lines to <em>__init__.py</em>.</p>
<h4 id="h3-500920c04-0002"><span epub:type="pagebreak" title="88" id="Page_88"/>Controlling Import-All</h4>
<p class="BodyFirst">By default, import-all doesn’t work with a package. You use <em>__init__.py</em> to enable and control the behavior of <code>import *</code>, even though such an import statement is generally discouraged. This can be done by assigning a list of strings to <code>__all__</code>, with each string containing something (such as a package or module) to import from the current package.</p>
<p>This works well with the previous trick (<a href="#listing4-20" id="listinganchor4-20">Listing 4-20</a>):</p>
<pre><code>__all__ = ["SmallRocket", "LargeRocket", "Launchpad"]</code></pre>
<p class="CodeListingCaption"><a id="listing4-22">Listing 4-22</a>: <em>__init__.py:2a</em></p>
<p>When Python encounters a line like <code>from rockets import *</code>, that list from <code>__all__</code> (seen as <code>rockets.__all__</code>) is unpacked in place of the asterisk (<code>*</code>). This is important in figuring out what you can include in <code>__all__</code>: each item in my list should make sense when substituted for the asterisk in <code>from rockets import *</code>.</p>
<p>In other words, I could change the last line of my <em>__init__.py</em> to this, and there would be no error in the code:</p>
<pre><code>__all__ = ["smallrocket"]</code></pre>
<p class="CodeListingCaption"><a id="listing4-23">Listing 4-23</a>: <em>__init__.py:2b</em></p>
<p>This works because, as you already know, the line <code>from rockets import smallrocket</code> is a valid import statement.</p>
<p>On the other hand, this example would <em>not</em> work:</p>
<pre><code>__all__ = ["smallrocket.rocket"]</code></pre>
<p class="CodeListingCaption"><a id="listing4-24">Listing 4-24</a>: <em>__init__.py:2c</em></p>
<p>It fails because <code>from rockets import smallrocket.rocket</code> does not make sense. You’ll have to consider this principle when defining <code>__all__</code>.</p>
<p>If <code>__all__</code> is not defined in <em>__init__.py</em>, then <code>from rockets import *</code> will behave the same as <code>import rockets</code>.</p>
<h3 id="h2-500920c04-0013">Program Entry Points</h3>
<p class="BodyFirst">If you’ve applied all the concepts in this chapter to your project’s structure,  you can run <code>python3 -m yourproject</code> to start your program.</p>
<p>However, you (or your eventual end user) may want to run the program merely by double-clicking or directly executing some single Python file. With everything else in place, this is trivial to implement.</p>
<p>To make my <em>omission</em> project easy to run, I created a single script file <em>outside the top-level package</em>, named <em>omission.py</em>:</p>
<pre><code>from omission.__main__ import main
main()</code></pre>
<p class="CodeListingCaption"><a id="listing4-25">Listing 4-25</a>: <em>omission.py</em></p>
<p><span epub:type="pagebreak" title="89" id="Page_89"/>I import the <code>main()</code> function from <em>omission/__main__.py</em> and then execute that function. This is effectively the same as executing that package directly with <code>python3 -m omission</code>.</p>
<p>There are better ways to create a program entry point, but I’ll cover those in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, once I’ve created the all-important <em>setup.cfg</em> file. Again, what you have so far will be enough for development.</p>
<h2 id="h1-500920c04-0007">The Python Module Search Path</h2>
<p class="BodyFirst">The <em>module search path</em>, or <em>import path</em>, defines where Python looks for packages and modules and what order it searches in. When you first start the Python interpreter, the module search path is assembled in order, from the directory of the module being executed, the system variable <code>PYTHONPATH</code>, and the default path for the Python instance being used.</p>
<p>You can view the resulting module search path with the following commands:</p>
<pre><code>import sys
print(sys.path)</code></pre>
<p>Running that code within the context of a virtual environment (in my case, <em>/home/jason/.venvs/venv310</em>) on my system gives me the following output:</p>
<pre><code>[ <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> '/home/jason/DeadSimplePython/Code/ch4', <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> '/usr/lib/python310.zip', <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> '/usr/lib/python3.10', <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> '/usr/lib/python3.10/lib-dynload', <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> '/home/jason/.venvs/venv310/lib/python3.10/site-packages']</code></pre>
<p>The import system looks through each of the locations in the module search path <em>in order</em>. As soon as it finds a match for the module or package being imported, it stops. You can see here that it searches the directory containing the module or script I’m running <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the standard libraries <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and then everything installed with pip in the virtual environment <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>
<p>If you need to add locations to the module search path, the best way is to use a virtual environment and add a file ending in <em>.pth</em> to the <em>lib/python3.x/site-packages</em> directory. The name of the file doesn’t matter, as long as the file extension is <em>.pth</em>.</p>
<p>For example, consider the following:</p>
<pre><code>/home/jason/bunch_of_code
../../../awesomesauce</code></pre>
<p class="CodeListingCaption"><a id="listing4-26">Listing 4-26</a>: <em>venv/lib/python3.10/site-packages/stuff.pth</em></p>
<p>Each line must contain exactly one path to be appended. The absolute path <em>/home/jason/bunch_of_code</em> will be appended to the module search path. The relative path <em>../../../awesomesauce</em> is relative to the .<em>pth</em> file, so it will point to <em>venv/awesomesauce</em>.</p>
<p>Because these are appended to the module search path, this technique cannot be used to replace any packages or modules installed on the system or virtual environment. However, any new modules or packages in <span epub:type="pagebreak" title="90" id="Page_90"/>my <em>bunch_of_code/</em> or <em>awesomesauce/</em> directories will be available for import within the virtual environment.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">It is possible to modify the variable <code>sys.path</code> or your system’s <code>PYTHONPATH</code> variable, but you almost certainly shouldn’t be doing this directly! Not only is it an indicator that you’re probably handling imports wrong, but it can also break stuff outside of your project. In this regard, <code>sys.path</code> is the worst offender; if someone imports a module where you modify <code>sys.path</code>, it will mangle their module search path!</p>
<div class="bottom hr"><hr/></div>
</section>
</aside><h2 id="h1-500920c04-0008">What Really Happens</h2>
<p class="BodyFirst">Let’s look at what really happens under the hood when you import a module. Most of the time, those details won’t matter, but every now and then (such as when the wrong module seems to be imported instead of the one you expect), the technical details leak to the surface. It never hurts to know what’s going on.</p>
<p>The <code>import</code> statement calls the built-in<code>__import__()</code> function.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">If you ever want to manually perform an import, use the <code>importlib</code> module instead of calling <code>__import__()</code>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To import a module, Python uses two special objects: a <em>finder</em> and a <em>loader</em>. In some cases, it uses an <em>importer</em> object, which serves as both a finder and a loader.</p>
<p>The <em>finder</em> is responsible for locating the module being imported. There are many places to look for modules—they aren’t even necessarily files—and a number of special situations exist that must be handled. Python has several types of finders to handle these different situations, and it gives each one an opportunity to locate a module with a given name.</p>
<p>First, Python uses <em>meta path finders</em>, which are stored in the <code>sys.meta_path</code> list. By default, there are three meta path finders:</p>
<ul>
<li>The <em>built-in importer</em> finds and loads built-in modules.</li>
<li>The <em>frozen importer</em> finds and loads <em>frozen</em> modules, meaning modules that have been converted to compiled bytecode (see <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>).</li>
<li>The <em>path-based finder</em> looks in the filesystem for the module.</li>
</ul>
<p>This search order is the reason why you cannot globally shadow a built-in module; the built-in importer runs before the path-based finder. If you need some additional meta path finder, such as if you were importing a module from a novel location not already supported, you can add it as a <em>meta hook</em> by appending it to the <code>sys.meta_path</code> list.</p>
<p>There’s some additional complexity to the path-based finder that is worth breaking down. The path-based finder tries each of the <em>path entry finders </em>in turn. These path entry finders, also known as <em>path entry hooks</em>, are stored in <code>sys.path_hooks</code>. Each one searches every location (known as a <em>path </em><span epub:type="pagebreak" title="91" id="Page_91"/>entry) listed on the import path, as specified by <code>sys.path</code> or the <code>__path__</code> attribute of the current package.</p>
<p>If any of the finders locates the module, it returns a <em>module spec</em> object with all the information about how to load the module. However, if all the meta path finders return <code>None</code>, you’ll get a <code>ModuleNotFoundError</code>.</p>
<p>Once the module is found, the module spec goes to the <em>loader</em>, which is responsible for actually loading the module.</p>
<p>There’s a lot of technical detail regarding loading that’s beyond the scope of this book, but one thing worth noting is how the loader deals with <em>cached bytecode</em>. Ordinarily, once a Python module has been run, a <em>.pyc</em> file is generated. The file contains the bytecode, which from then on is <em>cached</em>. You’ll often see these <em>.pyc</em> files hanging out in your project directories. The loader always needs to be sure that the cached bytecode is not out of date before loading it, by using one of two strategies. The first strategy is for the bytecode to also store the timestamp from the last time the source code file was modified. When loading the module, the timestamp of the source code is checked against this cached timestamp. If it doesn’t match, the bytecode is out of date, and the source will be recompiled. The second strategy, introduced in Python 3.7, instead stores a <em>hash</em>, which is a short and (relatively) unique value algorithmically generated from the source code itself. If the source code changes, the hash will be different from the one stored in the cached bytecode. Python bytecode files that contain this hash are appropriately called <em>hash-based .pyc</em> files.</p>
<p>Regardless of how the loader is loading the module, it will add the module object to <code>sys.modules</code>—adding it, in fact, just before actually loading, to prevent an import loop if the module being loaded imports itself. Finally, the loader will bind the imported module object to a name in the module importing it, so the imported module can be referenced. (I’ll cover name binding in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.)</p>
<p>Once the module has been imported, it’s cached in <code>sys.path_importer_cache</code>, along with the importer object used to import it. This is actually the first place the import system will check for an imported module, even before running through the finders, so importing a module multiple times in a project will still only go through the finding-and-loading process once.</p>
<p>This is a very broad overview of the import system, but most of the time, it’s all you’ll need to know. To learn all the intricate details, you can read the official documentation at <a href="https://docs.python.org/3/reference/import.html" class="LinkURL">https://docs.python.org/3/reference/import.html</a>.</p>
<h2 id="h1-500920c04-0009">Wrapping Up</h2>
<p class="BodyFirst">The Python import system is often overlooked when learning the language, leading to many headaches for new users. By understanding how to use and import modules and packages, you will greatly reduce the roadblocks between you and a viable project. A little effort now will save you countless hours of confusion and trouble later!</p>
</section>
</div></body></html>