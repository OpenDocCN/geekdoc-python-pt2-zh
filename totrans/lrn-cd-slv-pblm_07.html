<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_171"/><span class="big">7</span><br/>READING AND WRITING FILES</h2>&#13;&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="150" height="150"/></div>&#13;&#13;
<p class="noindents">To this point, we’ve read all input using the <code>input</code> function and written all output using the <code>print</code> function. These functions read from standard input (defaulting to the keyboard) and write to standard output (defaulting to the screen), respectively. While we can change these defaults using input and output redirection, sometimes a program needs more control over its files. For example, your word processor allows you to open whichever document file you like and save a file with whatever name you like, without you messing around with standard input and standard output.</p>&#13;&#13;
<p class="indent">In this chapter, we’ll learn how to write programs that manipulate text files. We’ll solve two problems using files: correctly formatting an essay and seeding a farm to feed cows.</p>&#13;&#13;
<h3 class="h3a" id="ch07lev1sec1"><span epub:type="pagebreak" id="page_172"/><span class="h3aa">Problem #16: Essay Formatting</span></h3>&#13;&#13;
<p class="noindent">There’s one important difference between this problem and all the problems we’ve solved to this point: this one requires us to read from and write to specific files! Look out for this as you read the problem description.</p>&#13;&#13;
<p class="indent">This is USACO 2020 January Bronze Contest problem Word Processor. This is the first problem in the book from the USACO (USA Computing Olympiad) judge. To find the problem, go to <em><a href="http://usaco.org/">http://usaco.org/</a></em>, click <strong>Contests</strong>, click <strong>2020 January Contest Results</strong>, and then click <strong>View problem</strong> under Word Processor.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec1">The Challenge</h4>&#13;&#13;
<p class="noindent">Bessie the cow is writing an essay. Each word in the essay contains only lowercase or uppercase characters. Her teacher has specified the maximum number of characters, not counting spaces, that can occur per line. To satisfy this requirement, Bessie writes down the words of the essay using the following rules:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">If the next word fits on the current line, add it to the current line. Include a space between each pair of words on the line.</li>&#13;&#13;
<li class="noindent">Otherwise, put this word on a new line; this line becomes the new current line.</li>&#13;&#13;
</ul>&#13;&#13;
<p class="indent">Output the essay with the correct words on each line.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec2">Input</h4>&#13;&#13;
<p class="noindent">Read input from the file named <em>word.in</em>.</p>&#13;&#13;
<p class="indent">The input consists of two lines.</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">The first line contains two integers separated by a space. The first integer is <em>n</em>, the number of words in the essay; it’s between 1 and 100. The second integer is <em>k</em>, the maximum number of characters (not counting spaces) that can occur per line; it’s between 1 and 80.</li>&#13;&#13;
<li class="noindent">The second line contains <em>n</em> words, with a space between each pair of words. Each word has at most <em>k</em> characters.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch07lev2sec3">Output</h4>&#13;&#13;
<p class="noindent">Write output to the file named <em>word.out</em>.</p>&#13;&#13;
<p class="indent">Output the properly formatted essay.</p>&#13;&#13;
<h3 class="h3" id="ch07lev1sec2">Working with Files</h3>&#13;&#13;
<p class="noindent">The Essay Formatting problem requires that we read from file <em>word.in</em> and write to file <em>word.out</em>. Before we can do those things, though, we need to learn how to open files in our programs.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec4"><span epub:type="pagebreak" id="page_173"/>Opening a File</h4>&#13;&#13;
<p class="noindent">Using your text editor, create a new file called <em>word.in</em>. Put that file in the same directory that you’ve been using for your <em>.py</em> Python programs.</p>&#13;&#13;
<p class="indent">This is the first time that we’re creating a file that doesn’t end with <em>.py</em>. Instead, it ends with <em>.in</em>. Be sure to name the file <em>word.in</em>, not <em>word.py</em>. The <em>in</em> is short for input; you’ll see it used often for files that contain input for a program.</p>&#13;&#13;
<p class="indent">In that file, let’s place valid input for the Essay Formatting problem. Enter the following into the file:</p>&#13;&#13;
<pre>12 13<br/>&#13;&#13;
perhaps better poetry will be written in the language of digital computers</pre>&#13;&#13;
<p class="indent">Save the file.</p>&#13;&#13;
<p class="indent">To open the file in Python, we use the <code>open</code> function. We pass two arguments: the first is the filename, and the second is the mode in which to open the file. The mode determines how we can interact with the file.</p>&#13;&#13;
<p class="indent">Here’s how we can open <em>word.in</em>:</p>&#13;&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">open('word.in', 'r')</span><br/>&#13;&#13;
<span class="ent">❶</span> &lt;_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'&gt;</pre>&#13;&#13;
<p class="indent">In this function call, we’ve provided a mode of <code>'r'</code>. The <code>r</code> stands for “read” and opens the file so that we can read from it. The mode happens to be an optional parameter whose default is <code>'r'</code>, so we can leave it out if we like. But I’ll explicitly include the <code>'r'</code> throughout the book for consistency.</p>&#13;&#13;
<p class="indent">When we use <code>open</code>, Python gives us some information about how the file was opened <span class="ent">❶</span>. For example, it confirms the filename and mode. The bit about <code>encoding</code> indicates how the file was decoded from its state on disk into a form that we can read. Files can be encoded using a variety of encodings, but we don’t need to worry about encodings in this book.</p>&#13;&#13;
<p class="indent">If we try to open a file for reading that doesn’t exist, we get an error:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">open('blah.in', 'r')</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
FileNotFoundError: [Errno 2] No such file or directory: 'blah.in'</pre>&#13;&#13;
<p class="indent">If you’re getting this error when opening <em>word.in</em>, double-check that the file is named correctly and in the directory from which you started Python.</p>&#13;&#13;
<p class="indent">In addition to mode <code>'r'</code> for reading, there’s mode <code>'w'</code> for writing. If we use <code>'w'</code>, then we’re opening a file so that we can put text in it.</p>&#13;&#13;
<p class="indent">Be careful with mode <code>'w'</code>. If you use <code>'w'</code> with a file that already exists, the contents of that file will be deleted. I just accidentally did that with my <em>word.in</em> file. No big deal, because it was easy to re-create. But no one would be happy if we accidentally overwrote an important file.</p>&#13;&#13;
<p class="indent">If you use <code>'w'</code> with a filename that doesn’t exist, it creates an empty file.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>Let’s use mode <code>'w'</code> to create an empty file called <em>blah.in</em>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">open('blah.in', 'w')</span><br/>&#13;&#13;
&lt;_io.TextIOWrapper name='blah.in' mode='w' encoding='cp1252'&gt;</pre>&#13;&#13;
<p class="indent">Now that <em>blah.in</em> exists, we can open it for reading without getting an error:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">open('blah.in', 'r')</span><br/>&#13;&#13;
&lt;_io.TextIOWrapper name='blah.in' mode='r' encoding='cp1252'&gt;</pre>&#13;&#13;
<p class="indent">What’s that <code>_io.TextIOWrapper</code> that we keep seeing? That’s the type of the value that <code>open</code> returns:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">type(open('word.in', 'r'))</span><br/>&#13;&#13;
&lt;class '_io.TextIOWrapper'&gt;</pre>&#13;&#13;
<p class="indent">Think of this type as a file type. Its values represent open files, and you’ll see shortly that it has methods that we can call.</p>&#13;&#13;
<p class="indent">As with any function, if we don’t assign what <code>open</code> returns to a variable, then its return value is lost. The way we’ve been calling <code>open</code> so far doesn’t give us any way to refer to the file that we’ve opened!</p>&#13;&#13;
<p class="indent">Here’s how we can make a variable refer to an open file:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file = open('word.in', 'r')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file</span><br/>&#13;&#13;
&lt;_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'&gt;</pre>&#13;&#13;
<p class="indent">We’ll be able to use <code>input_file</code> to read from <code>'word.in'</code>.</p>&#13;&#13;
<p class="indent">When solving Essay Formatting, we’ll also need a way to write to file <code>'word.out'</code>. Here’s a variable that will help us do that:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">output_file = open('word.out', 'w')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file</span><br/>&#13;&#13;
&lt;_io.TextIOWrapper name='word.out' mode='w' encoding='cp1252'&gt;</pre>&#13;&#13;
<h4 class="h4" id="ch07lev2sec5">Reading from a File</h4>&#13;&#13;
<p class="noindent">To read a line from an open file, we use the file’s <code>readline</code> method. That method returns a string containing the contents of the next line of the file. In that way, it’s similar to the <code>input</code> function. Unlike <code>input</code>, however, <code>readline</code> reads from a file rather than from standard input.</p>&#13;&#13;
<p class="indent">Let’s open <em>word.in</em> and read its two lines:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file = open('word.in', 'r')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file.readline()</span><br/>&#13;&#13;
'12 13\n'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file.readline()</span><br/>&#13;&#13;
'perhaps better poetry will be written in the language of digital computers\n'</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_175"/>What’s unexpected here is the <code>\n</code> at the end of each string. We certainly didn’t see that when using <code>input</code> to read a line. The <code>\</code> symbol in a string is an <em>escape character</em>. It escapes from the standard interpretation of characters and changes their meaning. We don’t treat <code>\n</code> as the two separate characters <code>\</code> and <code>n</code>. Instead, <code>\n</code> is just one character: a newline character. All lines in a file, perhaps except for the last, end with a newline character. If they didn’t, then everything would be on a single line! The <code>readline</code> method is literally giving us the entire line, including its terminating newline character.</p>&#13;&#13;
<p class="indent">Here’s how we can embed newlines in our own strings:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'one\ntwo\nthree'</span><br/>&#13;&#13;
'one\ntwo\nthree'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">print('one\ntwo\nthree')</span><br/>&#13;&#13;
one<br/>&#13;&#13;
two<br/>&#13;&#13;
three</pre>&#13;&#13;
<p class="indent">The Python shell doesn’t process the effects of escape characters, but <code>print</code> does.</p>&#13;&#13;
<p class="indent">The <code>\n</code> sequence is useful in strings because it helps us add multiple lines. But we rarely want those newlines in the lines that we read from files. To get rid of them, we can use the string <code>rstrip</code> method. This method is like <code>strip</code> except that it removes whitespace only from the right of a string (not the left). As far as it’s concerned, newlines are whitespace just like spaces:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'hello\nthere\n\n'</span><br/>&#13;&#13;
'hello\nthere\n\n'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">'hello\nthere\n\n'.rstrip()</span><br/>&#13;&#13;
'hello\nthere'</pre>&#13;&#13;
<p class="indent">Let’s try reading from the file again, this time stripping out the newlines:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file = open('word.in', 'r')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file.readline().rstrip()</span><br/>&#13;&#13;
'12 13'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file.readline().rstrip()</span><br/>&#13;&#13;
'perhaps better poetry will be written in the language of digital computers'</pre>&#13;&#13;
<p class="indent">At this point, we’ve read the two lines, so there’s nothing left to read from the file. The <code>readline</code> method signals this by returning an empty string.</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file.readline().rstrip()</span><br/>&#13;&#13;
''</pre>&#13;&#13;
<p class="indent">The empty string means that we’ve reached the end of the file. If we want to read the lines again, we must reopen the file to start at its beginning.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>Let’s do that, this time saving each line using variables:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file = open('word.in', 'r')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">first = input_file.readline().rstrip()</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">second = input_file.readline().rstrip()</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">first</span><br/>&#13;&#13;
'12 13'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">second</span><br/>&#13;&#13;
'perhaps better poetry will be written in the language of digital computers'</pre>&#13;&#13;
<p class="indent">If we need to read all of the lines from a file, no matter how many there are, we can use a <code>for</code> loop. Files in Python act as sequences of lines, so we can loop over them just like we loop over strings and lists:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file = open('word.in', 'r')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for line in input_file:</span><br/>&#13;&#13;
...     <span class="codestrong1">print(line.rstrip())</span><br/>&#13;&#13;
...<br/>&#13;&#13;
12 13<br/>&#13;&#13;
perhaps better poetry will be written in the language of digital computers</pre>&#13;&#13;
<p class="indent">Unlike a string or loop, though, we can’t loop over the file a second time, because the first one takes us to its end. If we try, we get nothing:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for line in input_file:</span><br/>&#13;&#13;
...     <span class="codestrong1">print(line.rstrip())</span><br/>&#13;&#13;
...</pre>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">We want to use a <code>while</code> loop to output each line of the open file <code>input_file</code>. (The file could be any file; I’m not assuming that it’s related to Essay Formatting.) Which of the following pieces of code correctly does this?</p>&#13;&#13;
<p class="alpha">A.</p>&#13;&#13;
<p class="programs1">while input_file.readline() != '':<br/>&#13;&#13;
    print(input_file.readline().rstrip())</p>&#13;&#13;
<p class="alpha">B.</p>&#13;&#13;
<p class="programs1">line = 'x'<br/>&#13;&#13;
while line != '':<br/>&#13;&#13;
    line = input_file.readline()<br/>&#13;&#13;
    print(line.rstrip())</p>&#13;&#13;
<p class="alpha"><span epub:type="pagebreak" id="page_177"/>C.</p>&#13;&#13;
<p class="programs1">line = input_file.readline()<br/>&#13;&#13;
while line != '':<br/>&#13;&#13;
    line = input_file.readline()<br/>&#13;&#13;
    print(line.rstrip())</p>&#13;&#13;
<p class="alpha">D. All of the above</p>&#13;&#13;
<p class="alpha">E. None of the above</p>&#13;&#13;
<p class="sidebarp">Before looking at the answer, I encourage you to create a file with four or five lines in it and try each piece of code on the file. You might also consider adding a character like <code>*</code> to the beginning of each line that’s output so that you can see any otherwise blank lines.</p>&#13;&#13;
<p class="sb-noindent1">Answer: E. Each piece of code has a subtle error.</p>&#13;&#13;
<p class="sidebarp">Code A outputs only every other line of the file. For example, the <code>while</code> loop’s Boolean expression causes the first line to be read . . . and lost, because it isn’t assigned to a variable. The first iteration of the loop therefore outputs the second line of the file.</p>&#13;&#13;
<p class="sidebarp">Code B comes very close to doing the right thing. It outputs all the lines of the file, but also outputs an extraneous blank line at the end.</p>&#13;&#13;
<p class="sidebarp">Code C fails to print the first line of the file. That’s because the first line is read before the loop, but then the loop reads the second line without having printed the first. It also produces an extraneous blank line at the end, just like code B.</p>&#13;&#13;
<p class="sidebarp">Here’s correct code to read and print each line:</p>&#13;&#13;
<pre>line = input_file.readline()<br/>&#13;&#13;
while line != '':<br/>&#13;&#13;
    print(line.rstrip())<br/>&#13;&#13;
    line = input_file.readline()</pre>&#13;&#13;
</div>&#13;&#13;
<h4 class="h4" id="ch07lev2sec6">Writing to a File</h4>&#13;&#13;
<p class="noindent">To write a line to an open file, we use the file’s <code>write</code> method. We pass it a string, and that string is added to the end of the file.</p>&#13;&#13;
<p class="indent">To solve Essay Formatting, we’ll write to <em>word.out</em>. We’re not ready to solve that problem yet, so let’s instead write to <em>blah.out</em>. Here’s how we can write one line to that file:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">output_file = open('blah.out', 'w')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('hello')</span><br/>&#13;&#13;
5</pre>&#13;&#13;
<p class="indent">What’s that <code>5</code> doing there? The <code>write</code> method returns the number of characters written. It’s good confirmation that we’ve written the quantity of text that we expected to write.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/>If you open <em>blah.out</em> in your text editor, you should see the text <code>hello</code> in there.</p>&#13;&#13;
<p class="indent">Let’s try writing three lines to the file. Here goes:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">output_file = open('blah.out', 'w')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('sq')</span><br/>&#13;&#13;
2<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('ui')</span><br/>&#13;&#13;
2<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('sh')</span><br/>&#13;&#13;
2</pre>&#13;&#13;
<p class="indent">Based on what I’ve told you so far, you might expect <em>blah.out</em> to look like this:</p>&#13;&#13;
<pre>sq<br/>&#13;&#13;
ui<br/>&#13;&#13;
sh</pre>&#13;&#13;
<p class="indent">But if you open <em>blah.out</em> in your text editor, you should instead see the following:</p>&#13;&#13;
<pre>squish</pre>&#13;&#13;
<p class="indent">The characters are on a single line like that because <code>write</code> doesn’t add newlines for us! If we want separate lines, we need to be explicit, like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">output_file = open('blah.out', 'w')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('sq\n')</span><br/>&#13;&#13;
3<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('ui\n')</span><br/>&#13;&#13;
3<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write('sh\n')</span><br/>&#13;&#13;
3</pre>&#13;&#13;
<p class="indent">Notice in each case that <code>write</code> writes three characters, not two. The newline counts as a character. Now if you open <em>blah.out</em> in your text editor, you should see the text spread across three lines:</p>&#13;&#13;
<pre>sq<br/>&#13;&#13;
ui<br/>&#13;&#13;
sh</pre>&#13;&#13;
<p class="indent">Unlike <code>print</code>, <code>write</code> works only if you call it with a string. To write a number to a file, convert it to a string first:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">num = 7788</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file = open('blah.out', 'w')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">output_file.write(str(num) + '\n')</span><br/>&#13;&#13;
5</pre>&#13;&#13;
<h5 class="h5" id="ch07lev3sec1"><span epub:type="pagebreak" id="page_179"/>Closing Files</h5>&#13;&#13;
<p class="noindent">It’s good practice to close a file once you’re done with it. It signals to readers of your code that the file is no longer being used.</p>&#13;&#13;
<p class="indent">Closing files also helps your operating system manage your computer’s resources. When you use the <code>write</code> method, what you write may not end up in the file immediately. Rather, Python or your operating system might wait until it has a bunch of <code>write</code> requests and then write them all at once. Closing a file that you wrote to guarantees that what you wrote to the file is safely stored in the file.</p>&#13;&#13;
<p class="indent">To close a file, call its <code>close</code> method. Here’s an example of opening a file, reading a line, and closing it:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file = open('word.in', 'r')</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file.readline()</span><br/>&#13;&#13;
'12 13\n'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">input_file.close()</span></pre>&#13;&#13;
<p class="indent">Once you’ve closed a file, you can no longer read from or write to the file:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">input_file.readline()</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
ValueError: I/O operation on closed file.</pre>&#13;&#13;
<h3 class="h3" id="ch07lev1sec3">Solving the Problem</h3>&#13;&#13;
<p class="noindent">Back to Essay Formatting. Now we know how to read from <em>word.in</em> and write to <em>word.out</em>. That takes care of the input and output requirements. It’s time to tackle the problem itself.</p>&#13;&#13;
<p class="indent">Let’s start by exploring a test case to make sure we know how to solve this problem. Then we’ll see the code.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec7">Exploring a Test Case</h4>&#13;&#13;
<p class="noindent">Here’s the <em>word.in</em> file I’ve been using:</p>&#13;&#13;
<pre>12 13<br/>&#13;&#13;
perhaps better poetry will be written in the language of digital computers</pre>&#13;&#13;
<p class="indent">There are 12 words, and the maximum number of characters on a line (not counting spaces) is 13. We should add words to the current line as long as they fit; once a word doesn’t fit, we’ll start a new line with that word.</p>&#13;&#13;
<p class="indent">The word <code>perhaps</code> contains seven characters, so it fits on the first line. The word <code>better</code> contains six characters. We can put that on the first line, too; with <code>perhaps</code> already there, we’re at a total of 13 characters (not including the space between the two words).</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_180"/>The word <code>poetry</code> can’t go on the first line, so we start a new line with <code>poetry</code> as its first word. The word <code>will</code> fits next to <code>poetry</code> on the second line. Similarly, <code>be</code> fits next to <code>will</code>. We’re at 12 nonspace characters so far. Now we have the word <code>written</code>, and with only one character of room on line 2, we’re forced to start the next line with <code>written</code> as its first word.</p>&#13;&#13;
<p class="indent">Following this process to the end, the full essay that we need to write to <em>word.out</em> is this:</p>&#13;&#13;
<pre>perhaps better<br/>&#13;&#13;
poetry will be<br/>&#13;&#13;
written in the<br/>&#13;&#13;
language of<br/>&#13;&#13;
digital<br/>&#13;&#13;
computers</pre>&#13;&#13;
<h4 class="h4" id="ch07lev2sec8">The Code</h4>&#13;&#13;
<p class="noindent">Our solution is in <a href="ch07.xhtml#ch07ex01">Listing 7-1</a>.</p>&#13;&#13;
<pre><span class="ent">❶</span> input_file = open('word.in', 'r')<br/>&#13;&#13;
<span class="ent">❷</span> output_file = open('word.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❸</span> lst = input_file.readline().split()<br/>&#13;&#13;
   n = int(lst[0])  # n not needed<br/>&#13;&#13;
   k = int(lst[1])<br/>&#13;&#13;
   words = input_file.readline().split()<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❹</span> line = ''<br/>&#13;&#13;
   chars_on_line = 0<br/>&#13;&#13;
<br/>&#13;&#13;
   for word in words:<br/>&#13;&#13;
    <span class="ent">❺</span> if chars_on_line + len(word) &lt;= k:<br/>&#13;&#13;
           line = line + word + ' '<br/>&#13;&#13;
           chars_on_line = chars_on_line + len(word)<br/>&#13;&#13;
       else:<br/>&#13;&#13;
        <span class="ent">❻</span> output_file.write(line[:-1] + '\n')<br/>&#13;&#13;
           line = word + ' '<br/>&#13;&#13;
           chars_on_line = len(word)<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❼</span> output_file.write(line[:-1] + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch07ex01"><em>Listing 7-1: Solving Essay Formatting</em></p>&#13;&#13;
<p class="indent">To begin, we open the input file <span class="ent">❶</span> and output file <span class="ent">❷</span>. Notice the modes: we open the input file with mode <code>'r'</code> (for reading) and open the output file <span epub:type="pagebreak" id="page_181"/>with mode <code>'w'</code> (for writing). We could have opened the output file a little later, right before we use it, but I’ve chosen to open both files here to simplify the organization of the program. Similarly, we could close a file as soon as we no longer need it, but in this book, I’ve chosen to close all files together at the end of the program. For long-running programs that manipulate many files, you likely want to keep files open only when needed.</p>&#13;&#13;
<p class="indent">Next, we read the first line of the input file <span class="ent">❸</span>. This line contains two space-separated integers: <code>n</code>, the number of words, and <code>k</code>, the maximum number of allowed characters (not counting spaces) per line. As always with space-separated values, we use <code>split</code> to separate them. We then read the second line, which contains the essay words. Again we use <code>split</code>, this time to split the string of words into a list of words. That takes care of the input.</p>&#13;&#13;
<p class="indent">Two variables drive the main portion of the program: <code>line</code> and <code>chars_on_line</code>. The <code>line</code> variable refers to the current line; we start out with it referring to the empty string <span class="ent">❹</span>. The <code>chars_on_line</code> variable refers to the number of characters, not counting spaces, on the current line.</p>&#13;&#13;
<p class="indent">You may wonder why I’m maintaining <code>chars_on_line</code> at all. Couldn’t we just use <code>len(line)</code> instead? Well, if we did that, we’d be including spaces in our count, and spaces don’t count toward the number of characters allowed per line. We could fix that by subtracting the count of spaces, and I encourage you to try that on your own if you find it more intuitive than keeping the <code>chars_on_line</code> variable in there.</p>&#13;&#13;
<p class="indent">Now it’s time to loop through all of the words. For each word, we have to determine whether it goes on the current line or next line.</p>&#13;&#13;
<p class="indent">If the number of nonspace characters on the current line plus the number of characters in the current word is at most <code>k</code>, then the current word fits on the current line <span class="ent">❺</span>. In that case, we add the word plus a space to the current line and update the number of nonspace characters on the line.</p>&#13;&#13;
<p class="indent">Otherwise, the current word doesn’t fit on the current line. The current line is done! We therefore write the line to the output file <span class="ent">❻</span> and update the <code>line</code> and <code>chars_on_line</code> variables to reflect that this is the only word on the now-current line.</p>&#13;&#13;
<p class="indent">There are two things to note about the <code>write</code> call <span class="ent">❻</span>. First, the <code>[:-1]</code> slice is in there to prevent us from outputting the space that follows the last word on the line. Second, you may have expected me to use an f-string here, like this:</p>&#13;&#13;
<pre>        output_file.write(f'{line[:-1]}\n')</pre>&#13;&#13;
<p class="indent">However, at the time of writing, the USACO judge is running an older version of Python that doesn’t support f-strings.</p>&#13;&#13;
<p class="indent">Why are we outputting <code>line</code> after the loop ends <span class="ent">❼</span>? The reason is that each iteration of the <code>for</code> loop is guaranteed to leave <code>line</code> with one or more words that we have not output yet. Consider what happens with each word that we process. If the current word fits on the current line, we don’t output anything. If the current word doesn’t fit on the current line, then we output the current line, but not the word on the next line. We therefore need to <span epub:type="pagebreak" id="page_182"/>write <code>line</code> to the output file <em>after</em> the loop <span class="ent">❼</span>; otherwise, the last line in the essay will be lost.</p>&#13;&#13;
<p class="indent">The final thing we do is close both files.</p>&#13;&#13;
<p class="indent">One annoying aspect of writing to a file rather than the screen is that we aren’t shown the output when we run the program. To see the output, we have to open the output file in our text editor.</p>&#13;&#13;
<p class="indent">Here’s a tip: develop the program using <code>print</code> calls rather than <code>write</code> calls so that all output goes to the screen. That should make it easier to find errors in your program and avoid having to switch back and forth between your code and the output file. Once you’re happy with the code, you can change the <code>print</code> calls back to <code>write</code> calls. Then be sure to do a little more testing, just to make sure that everything ends up in the file as it should.</p>&#13;&#13;
<p class="indent">We’re ready to submit to the USACO judge. Send it our code! All test cases should pass.</p>&#13;&#13;
<h3 class="h3a" id="ch07lev1sec4"><span class="h3aa">Problem #17: Farm Seeding</span></h3>&#13;&#13;
<p class="noindent">We can use a loop to read a specified number of lines from a file. We’ll do that in this problem, and we’ll see that it’s similar to using a loop with <code>input</code> to read from standard input.</p>&#13;&#13;
<p class="indent">In <a href="ch06.xhtml#ch06">Chapter 6</a>, when we solved Action Figures, we learned about top-down design using functions. It’s an important skill, composing multiple functions to solve a problem. And since there isn’t much more to say about files, I’ve chosen a problem that doubles as a site for top-down design.</p>&#13;&#13;
<p class="indent">This is a challenging problem. We’ll first need to understand exactly what we’re being asked to do. After that, we’ll need to develop a way to solve the problem and think carefully about why our solution is correct.</p>&#13;&#13;
<p class="indent">This is USACO 2019 February Bronze Contest problem The Great Revegetation.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec9">The Challenge</h4>&#13;&#13;
<p class="noindent">Farmer John has <em>n</em> pastures, all of which he would like to seed with grass. The pastures are numbered 1, 2, . . ., <em>n</em>.</p>&#13;&#13;
<p class="indent">Farmer John has four different types of grass seed, numbered 1, 2, 3, and 4. He’ll choose one of these grass types for each pasture.</p>&#13;&#13;
<p class="indent">Farmer John also has <em>m</em> cows. Each cow has two favorite pastures in which it eats grass. Each cow cares only about its two favorite pastures, no others. For a healthy diet, each cow requires that its two pastures have different types of grass. For example, for some given cow, it would be okay if one of its pastures had grass type 1 and the other had grass type 4. But it would not be okay if both of its pastures had grass type 1.</p>&#13;&#13;
<p class="indent">A pasture might be the favorite of more than one cow. But it’s guaranteed that a pasture is the favorite of no more than three cows.</p>&#13;&#13;
<p class="indent">Determine the grass type to use in each pasture. Each pasture is required to use a grass type between 1 and 4, and each cow’s two favorite pastures must have different grass types.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec10"><span epub:type="pagebreak" id="page_183"/>Input</h4>&#13;&#13;
<p class="noindent">Read input from the file named <em>revegetate.in</em>.</p>&#13;&#13;
<p class="indent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing two integers separated by a space. The first integer is <em>n</em>, the number of pastures; it’s between 2 and 100. The second integer is <em>m</em>, the number of cows; it’s between 1 and 150.</li>&#13;&#13;
<li class="noindent"><em>m</em> lines, each of which gives the two favorite pasture numbers for a cow. These pasture numbers are integers between 1 and <em>n</em> and are separated by a space.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch07lev2sec11">Output</h4>&#13;&#13;
<p class="noindent">Write output to the file named <em>revegetate.out</em>.</p>&#13;&#13;
<p class="indent">Output a valid way to seed the pastures. The output is a line of <em>n</em> characters, each of which is a <code>'1'</code>, <code>'2'</code>, <code>'3'</code>, or <code>'4'</code>. The first character is the grass type for pasture 1, the second is the grass type for pasture 2, and so on.</p>&#13;&#13;
<p class="indent">We can interpret these <em>n</em> characters as an integer with <em>n</em> digits. For example, if we have the five grass types <code>'11123'</code>, then we can interpret this as the integer <code>11123</code>.</p>&#13;&#13;
<p class="indent">This integer interpretation comes into play when we have a choice of what to output. If there are multiple valid ways to seed the pastures, we must output the one that’s smallest when interpreted as an integer. For example, if both <code>'11123'</code> and <code>'22123'</code> are valid, we output the string <code>'11123'</code> because <code>11123</code> is less than <code>22123</code>.</p>&#13;&#13;
<h3 class="h3" id="ch07lev1sec5">Exploring a Test Case</h3>&#13;&#13;
<p class="noindent">We’re going to use top-down design to arrive at a solution for this problem. Working through a test case will help us sift the tasks.</p>&#13;&#13;
<p class="indent">Here’s the test case:</p>&#13;&#13;
<pre>8 6<br/>&#13;&#13;
5 4<br/>&#13;&#13;
2 4<br/>&#13;&#13;
3 5<br/>&#13;&#13;
4 1<br/>&#13;&#13;
2 1<br/>&#13;&#13;
5 2</pre>&#13;&#13;
<p class="indent">The first line of the test case tells us that we have eight pastures. They’re numbered from 1 to 8. The first line also tells us that we have six cows. The problem doesn’t specify a numbering for the cows, so I’ll just number them starting at 0. The two favorite pastures of each cow are in <a href="ch07.xhtml#ch07tab01">Table 7-1</a> for easy reference.</p>&#13;&#13;
<p class="tabcap" id="ch07tab01"><span epub:type="pagebreak" id="page_184"/><strong>Table 7-1:</strong> Farm Seeding Example, Cows</p>&#13;&#13;
<table class="bordertb1">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:30%"/>&#13;&#13;
<col style="width:30%"/>&#13;&#13;
<col style="width:40%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Cow</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture 1</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture 2</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr class="bg-g">&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr class="bg-g">&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr class="bg-g">&#13;&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">In this problem, we’re being asked to make <em>n</em> decisions. What grass type should we use for pasture 1? What grass type should we use for pasture 2? Pasture 3? Pasture 4? And so on, all the way up to pasture <em>n</em>. One strategy for these kinds of problems is to make one decision at a time, without making a mistake on any of them. If we manage to finish with decision <em>n</em> and haven’t made any mistakes along the way, then our solution must be correct.</p>&#13;&#13;
<p class="indent">Let’s go through the pastures from 1 to 8 and see if we can assign a grass type to each of them. We need to prioritize choosing small-numbered grass types so that we end with the smallest grass types when interpreted as a number.</p>&#13;&#13;
<p class="indent">What grass type should we choose for pasture 1? The only cows that care about pasture 1 are cows 3 and 4, so we focus only on those two. If we had already chosen grass types for some of these cows’ pastures, then we’d have to be careful with our choice for pasture 1. We wouldn’t want to give some cow two pastures with the same grass type, because that would break the rules! We haven’t chosen any grass types yet, so nothing can go wrong no matter what we choose for pasture 1. Since we want the smallest grass types, though, we’ll choose grass type 1.</p>&#13;&#13;
<p class="indent">I’ll collect our grass-type decisions in tables. Here’s the decision we just made, grass type 1 for pasture 1:</p>&#13;&#13;
<table class="bordertb">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Grass type</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">Let’s move on. What grass type should we choose for pasture 2? The cows that care about pasture 2 are cows 1, 4, and 5, so we focus on those. One of cow 4’s pastures is pasture 1, and we chose grass type 1 for that pasture, so grass type 1 is eliminated as a grass type for pasture 2. If we used grass type 1 for pasture 2, then we’d be giving cow 4 two pastures with the same grass type, and that would break the rules. Cows 1 and 5, however, don’t eliminate any other grass types, because we haven’t chosen grass types <span epub:type="pagebreak" id="page_185"/>for their pastures yet. We therefore choose grass type 2, the smallest-numbered grass type that’s available. Here’s where we stand:</p>&#13;&#13;
<table class="bordertb">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Grass type</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">What grass type should we choose for pasture 3? The only cow that cares about pasture 3 is cow 2. Cow 2’s pastures are pastures 3 and 5. That cow doesn’t eliminate any grass types, however, because we haven’t assigned a grass type to pasture 5! To get the smallest number, we’ll use grass type 1 for pasture 3. Here’s our next snapshot:</p>&#13;&#13;
<table class="bordertb">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Grass type</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">I can see three tasks in our top-down design crystallizing here. First, we need to obtain the cows that care about the current pasture. Second, we need to determine which grass types those cows eliminate from consideration. Third, we need to choose the smallest-numbered grass type that wasn’t eliminated. Each of those is a prime candidate for a function.</p>&#13;&#13;
<p class="indent">Let’s keep going. We have three cows that care about pasture 4: cows 0, 1, and 3. Cow 0 doesn’t eliminate any grass types, because we haven’t assigned grass types to its pastures yet. Cow 1 eliminates grass type 2 because we assigned grass type 2 to pasture 2 (its other pasture). And cow 3 eliminates grass type 1 because we assigned grass type 1 to pasture 1 (its other pasture). The smallest available grass type, then, is 3, so that’s what we use for pasture 4:</p>&#13;&#13;
<table class="bordertb">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Grass type</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">On to pasture 5. The cows that care about pasture 5 are cows 0, 2, and 5. Cow 0 eliminates grass type 3; cow 2 eliminates grass type 1; and cow 5 <span epub:type="pagebreak" id="page_186"/>eliminates grass type 2. So grass types 1, 2, and 3 are out. Our only choice is grass type 4.</p>&#13;&#13;
<p class="indent">That was close! We almost ran out of grass types there. Lucky for us, there was no other cow that cared about pasture 5 and eliminated grass type 4.</p>&#13;&#13;
<p class="indent">Or, wait. This wasn’t luck at all, because of this bit from the problem description: “It’s guaranteed that a pasture is the favorite of no more than three cows.” This means that at most three grass types can be eliminated for each pasture. We’ll never be stuck! And we don’t even have to worry about the ramifications of past choices on our next decision. No matter what we did in the past, we’ll always have at least one available grass type.</p>&#13;&#13;
<p class="indent">Let’s add pasture 5 to our table:</p>&#13;&#13;
<table class="bordertb">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Grass type</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td></tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">There are three pastures to go. But no cow cares about any of them, so we can just use grass type 1 in each case. That gives us this:</p>&#13;&#13;
<table class="bordertb">&#13;&#13;
<colgroup>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
<col style="width:50%"/>&#13;&#13;
</colgroup>&#13;&#13;
<thead>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Pasture</strong></p></td>&#13;&#13;
<td style="vertical-align: top" class="table-h"><p class="tab"><strong>Grass type</strong></p></td>&#13;&#13;
</tr>&#13;&#13;
</thead>&#13;&#13;
<tbody>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td></tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">6</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">7</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
<tr>&#13;&#13;
<td style="vertical-align: top"><p class="tab">8</p></td>&#13;&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;&#13;
</tr>&#13;&#13;
</tbody>&#13;&#13;
</table>&#13;&#13;
<p class="indent">We can read the grass types from top to bottom to obtain the correct output for this example. The output is as follows:</p>&#13;&#13;
<pre>12134111</pre>&#13;&#13;
<h3 class="h3" id="ch07lev1sec6"><span epub:type="pagebreak" id="page_187"/>Top-Down Design</h3>&#13;&#13;
<p class="noindent">With a good understanding of the tasks that we’ll need to complete, we’ll turn to a top-down design of this problem.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec12">The Top Level</h4>&#13;&#13;
<p class="noindent">We discovered three tasks in the previous section as we worked through a test case. Before our program can solve any of those tasks, we need to read the input, so that’s a fourth task. We also need to write the output. That will take some thought and a few lines of code, so let’s call that our fifth task.</p>&#13;&#13;
<p class="indent">Here are our five main tasks:</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">Read input.</li>&#13;&#13;
<li class="noindent">Identify cows that care about current pasture.</li>&#13;&#13;
<li class="noindent">Eliminate grass types for current pasture.</li>&#13;&#13;
<li class="noindent">Choose smallest-numbered grass type for current pasture.</li>&#13;&#13;
<li class="noindent">Write output.</li>&#13;&#13;
</ol>&#13;&#13;
<p class="indent">As we did when solving Action Figures in <a href="ch06.xhtml#ch06">Chapter 6</a>, we’ll start with a framework of <code>TODO</code> comments and remove each <code>TODO</code> as we solve it.</p>&#13;&#13;
<p class="indent">We begin with mostly comments. Since we’ll need to open the files at the start and close them at the end, I’ve also added that code.</p>&#13;&#13;
<p class="indent">Here’s where we begin:</p>&#13;&#13;
<pre># Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Read input<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Identify cows that care about pasture<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Eliminate grass types for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Write output<br/>&#13;&#13;
<br/>&#13;&#13;
input_file.close()<br/>&#13;&#13;
output_file.close()</pre>&#13;&#13;
<h4 class="h4" id="ch07lev2sec13"><span epub:type="pagebreak" id="page_188"/>Task 1: Read Input</h4>&#13;&#13;
<p class="noindent">Reading the first line of input, with the integers <em>n</em> and <em>m</em>, is something we know how to do. It’s straightforward enough that I don’t think we need a function for it, so let’s do it directly. Next we need to read the pasture information for the <em>m</em> cows, and here a function seems warranted. Let’s remove the <code>TODO</code> in the <code>Read input</code> comment, handle the first line of input, and call the <code>read_cows</code> function, which we’ll write shortly:</p>&#13;&#13;
<pre>   # Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
   output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   # Read input<br/>&#13;&#13;
   lst = input_file.readline().split()<br/>&#13;&#13;
   num_pastures = int(lst[0])<br/>&#13;&#13;
   num_cows = int(lst[1])<br/>&#13;&#13;
<span class="ent">❶</span> favorites = read_cows(input_file, num_cows)<br/>&#13;&#13;
<br/>&#13;&#13;
   # TODO: Identify cows that care about pasture<br/>&#13;&#13;
<br/>&#13;&#13;
   # TODO: Eliminate grass types for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
   # TODO: Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
   # TODO: Write output<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="indent">The <code>read_cows</code> function that we’re calling <span class="ent">❶</span> will take a file that’s already open for reading, and read the two favorite pastures for each cow. It’ll return a list of lists, where each inner list contains the two pasture numbers for a given cow. Here’s the code:</p>&#13;&#13;
<pre>def read_cows(input_file, num_cows):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    input_file is a file open for reading; cow information is next to read.<br/>&#13;&#13;
    num_cows is the number of cows in the file.<br/>&#13;&#13;
<br/>&#13;&#13;
    Read the cows' favorite pastures from input_file.<br/>&#13;&#13;
    Return a list of each cow's two favorite pastures;<br/>&#13;&#13;
    each value in the list is a list of two values giving the<br/>&#13;&#13;
    favorite pastures for one cow.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    favorites = []<br/>&#13;&#13;
    for i in range(num_cows):<br/>&#13;&#13;
     <span class="ent">❶</span> lst = input_file.readline().split()<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_189"/>        lst[0] = int(lst[0])<br/>&#13;&#13;
        lst[1] = int(lst[1])<br/>&#13;&#13;
     <span class="ent">❷</span> favorites.append(lst)<br/>&#13;&#13;
    return favorites</pre>&#13;&#13;
<p class="indent">This function accumulates the cows’ favorite pastures into the <code>favorites</code> list. It does that using a range <code>for</code> loop that loops <code>num_cows</code> times, once for each cow. We need the loop because the number of lines to read depends on the number of cows in the file.</p>&#13;&#13;
<p class="indent">On each iteration of the loop, we read the next line and split it into its two components <span class="ent">❶</span>. We then use <code>int</code> to convert the components from strings to integers. When we append this list to <code>favorites</code> <span class="ent">❷</span>, we’re therefore appending a list of two integers.</p>&#13;&#13;
<p class="indent">The last thing we do is return the list of favorite pastures.</p>&#13;&#13;
<p class="indent">Before we continue, let’s make sure that we know how to call this function. We’ll practice calling it on its own, independent from the larger program that we’re building. It’s useful to test functions like this so that we can fix any errors that we might find along the way.</p>&#13;&#13;
<p class="indent">Use your text editor to create a file named <em>revegetate.in</em> with the following contents (the same as the test case we studied earlier):</p>&#13;&#13;
<pre>8 6<br/>&#13;&#13;
5 4<br/>&#13;&#13;
2 4<br/>&#13;&#13;
3 5<br/>&#13;&#13;
4 1<br/>&#13;&#13;
2 1<br/>&#13;&#13;
5 2</pre>&#13;&#13;
<p class="indent">Now, in the Python shell, enter the code for our <code>read_cows</code> function.</p>&#13;&#13;
<p class="indent">Here’s what we do to call <code>read_cows</code>:</p>&#13;&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">input_file = open('revegetate.in', 'r')</span><br/>&#13;&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">input_file.readline()</span><br/>&#13;&#13;
   '8 6\n'<br/>&#13;&#13;
<span class="ent">❷</span> &gt;&gt;&gt; <span class="codestrong1">read_cows(input_file, 6)</span><br/>&#13;&#13;
   [[5, 4], [2, 4], [3, 5], [4, 1], [2, 1], [5, 2]]</pre>&#13;&#13;
<p class="indent">The <code>read_cows</code> function reads only the information for the cows. Since we’re testing this function in isolation, outside of our program, we need to read the first line of the file ourselves before we call it <span class="ent">❶</span>. When we then call <code>read_cows</code>, we get back a list giving the favorite pastures for each cow. Also notice that we’re calling <code>read_cows</code> with an open file, <em>not</em> a filename <span class="ent">❷</span>.</p>&#13;&#13;
<p class="indent">Be sure to include our <code>read_cows</code> function, along with the functions we’ll write for other tasks, before our <code># Main Program</code> comment. Then we can move on to Task 2.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec14"><span epub:type="pagebreak" id="page_190"/>Task 2: Identify Cows</h4>&#13;&#13;
<p class="noindent">Our overall strategy for solving this problem is to consider each pasture in turn, deciding which grass type to use. We’ll organize this work inside a loop, with each iteration of the loop responsible for seeding one pasture. For each pasture, we need to identify the cows that care about the pasture, eliminate the used grass types, and choose the smallest-numbered available grass type. These three tasks must run for each pasture, so we’ll indent them inside the loop.</p>&#13;&#13;
<p class="indent">We’ll write a function called <code>cows_with_favorite</code> that tells us the cows who care about the current pasture.</p>&#13;&#13;
<p class="indent">Here’s what we’ve got now for our main program:</p>&#13;&#13;
<pre># Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
# Read input<br/>&#13;&#13;
lst = input_file.readline().split()<br/>&#13;&#13;
num_pastures = int(lst[0])<br/>&#13;&#13;
num_cows = int(lst[1])<br/>&#13;&#13;
favorites = read_cows(input_file, num_cows)<br/>&#13;&#13;
<br/>&#13;&#13;
for i in range(1, num_pastures + 1):<br/>&#13;&#13;
<br/>&#13;&#13;
    # Identify cows that care about pasture<br/>&#13;&#13;
 <span class="ent">❶</span> cows = cows_with_favorite(favorites, i)<br/>&#13;&#13;
<br/>&#13;&#13;
    # TODO: Eliminate grass types for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
    # TODO: Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Write output<br/>&#13;&#13;
<br/>&#13;&#13;
input_file.close()<br/>&#13;&#13;
output_file.close()</pre>&#13;&#13;
<p class="indent">The <code>cows_with_favorite</code> function that we’re calling <span class="ent">❶</span> takes a list of the cows’ favorite pastures and a pasture number and returns the cows that care about that pasture. Here’s the code:</p>&#13;&#13;
<pre>def cows_with_favorite(favorites, pasture):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    favorites is a list of favorite pastures, as returned by read_cows.<br/>&#13;&#13;
    pasture is a pasture number.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return list of cows that care about pasture.<br/>&#13;&#13;
    """<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_191"/>    cows = []<br/>&#13;&#13;
    for i in range(len(favorites)):<br/>&#13;&#13;
        if favorites[i][0] == pasture or favorites[i][1] == pasture:<br/>&#13;&#13;
            cows.append(i)<br/>&#13;&#13;
    return cows</pre>&#13;&#13;
<p class="indent">The function loops through <code>favorites</code>, looking for cows that care about pasture number <code>pasture</code>. Each cow that cares about the pasture is added to the <code>cows</code> list that is ultimately returned.</p>&#13;&#13;
<p class="indent">Let’s do a little test. Enter our <code>cows_with_favorite</code> function into the Python shell. Here’s the call that we’ll try:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">cows_with_favorite([[5, 4], [2, 4], [3, 5]], 5)</span></pre>&#13;&#13;
<p class="indent">We have three cows here, and we’re asking which ones care about pasture <code>5</code>. The cows at indices <code>0</code> and <code>2</code> care about pasture <code>5</code>, and that’s exactly what the function tells us:</p>&#13;&#13;
<pre>[0, 2]</pre>&#13;&#13;
<h4 class="h4" id="ch07lev2sec15">Task 3: Eliminate Grass Types</h4>&#13;&#13;
<p class="noindent">Now we know the cows that care about the current pasture. Our next step is to figure out which grass types these cows eliminate from consideration for the current pasture. We eliminate the grass types that are used in a pasture associated with one or more of these cows. We’ll write a function called <code>types_used</code> that tells us the grass types that have already been used (and are therefore eliminated for the current pasture).</p>&#13;&#13;
<p class="indent">Here is our main program, updated with a call to this function:</p>&#13;&#13;
<pre>   # Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
   output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   # Read input<br/>&#13;&#13;
   lst = input_file.readline().split()<br/>&#13;&#13;
   num_pastures = int(lst[0])<br/>&#13;&#13;
   num_cows = int(lst[1])<br/>&#13;&#13;
   favorites = read_cows(input_file, num_cows)<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> pasture_types = [0]<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(1, num_pastures + 1):<br/>&#13;&#13;
<br/>&#13;&#13;
       # Identify cows that care about pasture<br/>&#13;&#13;
       cows = cows_with_favorite(favorites, i)<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_192"/>       # Eliminate grass types for pasture<br/>&#13;&#13;
    <span class="ent">❷</span> eliminated = types_used(favorites, cows, pasture_types)<br/>&#13;&#13;
<br/>&#13;&#13;
       # TODO: Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
<br/>&#13;&#13;
   # TODO: Write output<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="indent">In addition to calling the <code>types_used</code> function <span class="ent">❷</span>, I’ve also added a variable called <code>pasture_types</code> <span class="ent">❶</span>. The list referred to by this variable will keep track of the grass type for each pasture.</p>&#13;&#13;
<p class="indent">Recall that the pastures are numbered starting from 1. Python lists, on the other hand, are indexed starting from 0. I don’t like this discrepancy; if we simply started adding grass types to <code>pasture_types</code>, then the grass type for pasture 1 would be at index 0, the grass type for pasture 2 would be at index 1, and so on, always off by one. That’s why I added a bogus <code>0</code> at the beginning of the list <span class="ent">❶</span>; when we later add the grass type for pasture 1, it’ll be placed at index 1 to match.</p>&#13;&#13;
<p class="indent">Suppose we’ve figured out the grass types for the first four pastures. Here’s how <code>pasture_types</code> might look at that point:</p>&#13;&#13;
<pre>[0, 1, 2, 1, 3]</pre>&#13;&#13;
<p class="indent">If we want the grass type for pasture 1, we look at index 1; if we want the grass type for pasture 2, we look at index 2; and so on. If we want the grass type for pasture 5? Well, no, we can’t have that, because we haven’t figured it out yet. If the length of <code>pasture_types</code> is <code>5</code>, it means that we’ve figured out the grass types for only the first four pastures. In general, the number of grass types that we’ve figured out is one less than the list’s length.</p>&#13;&#13;
<p class="indent">Now we’re ready for the <code>types_used</code> function. It takes three parameters: the list of favorite pastures for each cow, the cows that care about the current pasture, and the grass types chosen for pastures so far. It returns the list of grass types that are already used and therefore eliminated for the current pasture. Here goes:</p>&#13;&#13;
<pre>def types_used(favorites, cows, pasture_types):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    favorites is a list of favorite pastures, as returned by read_cows.<br/>&#13;&#13;
    cows is a list of cows.<br/>&#13;&#13;
    pasture_types is a list of grass types.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return a list of the grass types already used by cows.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    used = []<br/>&#13;&#13;
    for cow in cows:<br/>&#13;&#13;
        pasture_a = favorites[cow][0]<br/>&#13;&#13;
        pasture_b = favorites[cow][1]<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_193"/>&#13;&#13;
     <span class="ent">❶</span> if pasture_a &lt; len(pasture_types):<br/>&#13;&#13;
            used.append(pasture_types[pasture_a])<br/>&#13;&#13;
     <span class="ent">❷</span> if pasture_b &lt; len(pasture_types):<br/>&#13;&#13;
            used.append(pasture_types[pasture_b])<br/>&#13;&#13;
    return used</pre>&#13;&#13;
<p class="indent">Each cow has two favorite pastures, which I refer to by <code>pasture_a</code> and <code>pasture_b</code>. For each of these pastures, we check whether a grass type has already been chosen for it at <span class="ent">❶</span> and <span class="ent">❷</span>. A grass type has already been chosen if that pasture is already an index in <code>pasture_types</code>. These grass types are all added to the <code>used</code> list, which the function returns after looping through all of the relevant cows.</p>&#13;&#13;
<p class="indent">What if more than one cow uses the same pasture—what does our code do then? Let’s come up with a simple test case to answer that question.</p>&#13;&#13;
<p class="indent">Enter our <code>types_used</code> function into the Python shell. Here’s a call of that function; let’s predict what it returns:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">types_used([[5, 4], [2, 4], [3, 5]], [0, 1], [0, 1, 2, 1, 3])</span></pre>&#13;&#13;
<p class="indent">Let’s be careful so we don’t get lost. The first argument gives the favorite pastures for three cows. The second argument gives the cows that care about a particular pasture; these are cows <code>0</code> and <code>1</code>. And the third argument gives the grass types that we’ve decided on so far.</p>&#13;&#13;
<p class="indent">Now, what are the grass types already used, and therefore eliminated, by cows <code>0</code> and <code>1</code>? Cow <code>0</code> cares about pasture <code>4</code>, and pasture <code>4</code> uses grass type <code>3</code>, so grass type <code>3</code> is eliminated. Cow <code>1</code> cares about pasture <code>2</code>, and pasture <code>2</code> uses grass type <code>2</code>, so grass type <code>2</code> is eliminated. Cow <code>1</code> also cares about pasture <code>4</code>—but we already know, from cow <code>0</code>, that pasture <code>4</code>’s grass type <code>3</code> is eliminated.</p>&#13;&#13;
<p class="indent">The return value of our function is this:</p>&#13;&#13;
<pre>[3, 2, 3]</pre>&#13;&#13;
<p class="indent">Two <code>3</code>s in there, one coming from cow <code>0</code> and the other from cow <code>1</code>.</p>&#13;&#13;
<p class="indent">It may seem tidier to have just one <code>3</code> in there, but what we have—with the duplicate—is just fine. If a grass type is in that list, then it’s eliminated, no matter whether it’s in there once, twice, or three times.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec16">Task 4: Choose Smallest-Numbered Grass Type</h4>&#13;&#13;
<p class="noindent">Having obtained the grass types that are eliminated, we can move onto our next task: choosing the smallest-numbered available grass type for the current pasture. To solve this one, we’ll call a new function, <code>smallest_available</code>. It will return the grass type that we should use for the current pasture.</p>&#13;&#13;
<p class="indent">Here’s the main program, updated with a call to the <code>smallest_available</code> function:</p>&#13;&#13;
<pre># Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_194"/>output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
# Read input<br/>&#13;&#13;
lst = input_file.readline().split()<br/>&#13;&#13;
num_pastures = int(lst[0])<br/>&#13;&#13;
num_cows = int(lst[1])<br/>&#13;&#13;
favorites = read_cows(input_file, num_cows)<br/>&#13;&#13;
<br/>&#13;&#13;
pasture_types = [0]<br/>&#13;&#13;
<br/>&#13;&#13;
for i in range(1, num_pastures + 1):<br/>&#13;&#13;
<br/>&#13;&#13;
    # Identify cows that care about pasture<br/>&#13;&#13;
    cows = cows_with_favorite(favorites, i)<br/>&#13;&#13;
<br/>&#13;&#13;
    # Eliminate grass types for pasture<br/>&#13;&#13;
    eliminated = types_used(favorites, cows, pasture_types)<br/>&#13;&#13;
<br/>&#13;&#13;
    # Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
 <span class="ent">❶</span> pasture_type = smallest_available(eliminated)<br/>&#13;&#13;
 <span class="ent">❷</span> pasture_types.append(pasture_type)<br/>&#13;&#13;
<br/>&#13;&#13;
# TODO: Write output<br/>&#13;&#13;
<br/>&#13;&#13;
input_file.close()<br/>&#13;&#13;
output_file.close()</pre>&#13;&#13;
<p class="indent">Once we obtain the smallest-numbered grass type for the current pasture <span class="ent">❶</span>, we add it to our list of chosen grass types <span class="ent">❷</span>.</p>&#13;&#13;
<p class="indent">Here’s the <code>smallest_available</code> function itself:</p>&#13;&#13;
<pre>def smallest_available(used):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    used is a list of used grass types.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return the smallest-numbered grass type that is not in used.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    grass_type = 1<br/>&#13;&#13;
    while grass_type in used:<br/>&#13;&#13;
        grass_type = grass_type + 1<br/>&#13;&#13;
    return grass_type</pre>&#13;&#13;
<p class="indent">The function begins with grass type <code>1</code>. It then loops until it finds a grass type that isn’t already used, increasing the grass type by one on each iteration. Once a free grass type is found, the function returns it. And remember, there are at most three grass types that have been used out of the four available, so this function is guaranteed to be successful.</p>&#13;&#13;
<h4 class="h4" id="ch07lev2sec17"><span epub:type="pagebreak" id="page_195"/>Task 5: Write Output</h4>&#13;&#13;
<p class="noindent">We’ve got our answer, right there in <code>pasture_types</code>! Now all we have to do is output it. Here’s the main program a final time:</p>&#13;&#13;
<pre>   # Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
   output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   # Read input<br/>&#13;&#13;
   lst = input_file.readline().split()<br/>&#13;&#13;
   num_pastures = int(lst[0])<br/>&#13;&#13;
   num_cows = int(lst[1])<br/>&#13;&#13;
   favorites = read_cows(input_file, num_cows)<br/>&#13;&#13;
<br/>&#13;&#13;
   pasture_types = [0]<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(1, num_pastures + 1):<br/>&#13;&#13;
<br/>&#13;&#13;
       # Identify cows that care about pasture<br/>&#13;&#13;
       cows = cows_with_favorite(favorites, i)<br/>&#13;&#13;
<br/>&#13;&#13;
       # Eliminate grass types for pasture<br/>&#13;&#13;
       eliminated = types_used(favorites, cows, pasture_types)<br/>&#13;&#13;
<br/>&#13;&#13;
       # Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
       pasture_type = smallest_available(eliminated)<br/>&#13;&#13;
       pasture_types.append(pasture_type)<br/>&#13;&#13;
<br/>&#13;&#13;
   # Write output<br/>&#13;&#13;
<span class="ent">❶</span> pasture_types.pop(0)<br/>&#13;&#13;
<span class="ent">❷</span> write_pastures(output_file, pasture_types)<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="indent">Before writing the output, we remove the bogus <code>0</code> at the beginning of <code>pasture_types</code> <span class="ent">❶</span>. We don’t want to output that <code>0</code>, as it isn’t a real grass type. Then, we call <code>write_pastures</code> to actually write the output <span class="ent">❷</span>.</p>&#13;&#13;
<p class="indent">All we need now is the <code>write_pastures</code> function. It takes a file open for writing, and a list of grass types, and outputs the grass types to the file. Here’s the code:</p>&#13;&#13;
<pre>   def write_pastures(output_file, pasture_types):<br/>&#13;&#13;
       """<br/>&#13;&#13;
       output_file is a file open for writing.<br/>&#13;&#13;
       pasture_types is a list of integer grass types.<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_196"/>       Output pasture_types to output_file.<br/>&#13;&#13;
       """<br/>&#13;&#13;
       pasture_types_str = []<br/>&#13;&#13;
    <span class="ent">❶</span> for pasture_type in pasture_types:<br/>&#13;&#13;
           pasture_types_str.append(str(pasture_type))<br/>&#13;&#13;
    <span class="ent">❷</span> output = ''.join(pasture_types_str)<br/>&#13;&#13;
    <span class="ent">❸</span> output_file.write(output + '\n')</pre>&#13;&#13;
<p class="indent">Right now, <code>pasture_types</code> is a list of integers. As we’ll see in a second, it’s more convenient to work with a list of strings here, so I create a new list with each integer as a string <span class="ent">❶</span>. I don’t modify the <code>pasture_types</code> list itself, because that could shock the caller of this function. The caller calls this function expecting only that output gets written to <code>output_file</code>, not that its <code>pasture_types</code> list is modified. The function has no business modifying its list parameter.</p>&#13;&#13;
<p class="indent">To produce the output, we need to call <code>write</code> with a string, not a list. And we need to output the strings from the list with no spaces between them. The string <code>join</code> method works wonderfully here. As we learned in “Joining a List into a String” in <a href="ch05.xhtml#ch05">Chapter 5</a>, the string that we call <code>join</code> on serves as the separator that’s placed between values in the list. Since we don’t want any separator between the values, we use an empty string as the separator <span class="ent">❷</span>. The <code>join</code> method works only on a list of strings, not a list of integers, which is why I converted the list of integers to a list of strings at the start of this function <span class="ent">❶</span>.</p>&#13;&#13;
<p class="indent">With the output as a single string, we can write it to the file <span class="ent">❸</span>.</p>&#13;&#13;
<h5 class="h5" id="ch07lev3sec2">Putting It All Together</h5>&#13;&#13;
<p class="noindent">The complete program is in <a href="ch07.xhtml#ch07ex02">Listing 7-2</a>.</p>&#13;&#13;
<pre>def read_cows(input_file, num_cows):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    input_file is a file open for reading; cow information is next to read.<br/>&#13;&#13;
    num_cows is the number of cows in the file.<br/>&#13;&#13;
<br/>&#13;&#13;
    Read the cows' favorite pastures from input_file.<br/>&#13;&#13;
    Return a list of each cow's two favorite pastures;<br/>&#13;&#13;
    each value in the list is a list of two values giving the<br/>&#13;&#13;
    favorite pastures for one cow.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    favorites = []<br/>&#13;&#13;
    for i in range(num_cows):<br/>&#13;&#13;
        lst = input_file.readline().split()<br/>&#13;&#13;
        lst[0] = int(lst[0])<br/>&#13;&#13;
        lst[1] = int(lst[1])<br/>&#13;&#13;
        favorites.append(lst)<br/>&#13;&#13;
    return favorites<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_197"/><br/>&#13;&#13;
<br/>&#13;&#13;
def cows_with_favorite(favorites, pasture):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    favorites is a list of favorite pastures, as returned by read_cows.<br/>&#13;&#13;
    pasture is a pasture number.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return list of cows that care about pasture.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    cows = []<br/>&#13;&#13;
    for i in range(len(favorites)):<br/>&#13;&#13;
        if favorites[i][0] == pasture or favorites[i][1] == pasture:<br/>&#13;&#13;
            cows.append(i)<br/>&#13;&#13;
    return cows<br/>&#13;&#13;
<br/>&#13;&#13;
<br/>&#13;&#13;
def types_used(favorites, cows, pasture_types):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    favorites is a list of favorite pastures, as returned by read_cows.<br/>&#13;&#13;
    cows is a list of cows.<br/>&#13;&#13;
    pasture_types is a list of grass types.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return a list of the grass types already used by cows.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    used = []<br/>&#13;&#13;
    for cow in cows:<br/>&#13;&#13;
        pasture_a = favorites[cow][0]<br/>&#13;&#13;
        pasture_b = favorites[cow][1]<br/>&#13;&#13;
        if pasture_a &lt; len(pasture_types):<br/>&#13;&#13;
            used.append(pasture_types[pasture_a])<br/>&#13;&#13;
        if pasture_b &lt; len(pasture_types):<br/>&#13;&#13;
            used.append(pasture_types[pasture_b])<br/>&#13;&#13;
    return used<br/>&#13;&#13;
<br/>&#13;&#13;
<br/>&#13;&#13;
def smallest_available(used):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    used is a list of used grass types.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return the smallest-numbered grass type that is not in used.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    grass_type = 1<br/>&#13;&#13;
    while grass_type in used:<br/>&#13;&#13;
        grass_type = grass_type + 1<br/>&#13;&#13;
    return grass_type<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_198"/><br/>&#13;&#13;
<br/>&#13;&#13;
def write_pastures(output_file, pasture_types):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    output_file is a file open for writing.<br/>&#13;&#13;
    pasture_types is a list of integer grass types.<br/>&#13;&#13;
<br/>&#13;&#13;
    Output pasture_types to output_file.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    pasture_types_str = []<br/>&#13;&#13;
    for pasture_type in pasture_types:<br/>&#13;&#13;
        pasture_types_str.append(str(pasture_type))<br/>&#13;&#13;
    output = ''.join(pasture_types_str)<br/>&#13;&#13;
    output_file.write(output + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
# Main Program<br/>&#13;&#13;
<br/>&#13;&#13;
input_file = open('revegetate.in', 'r')<br/>&#13;&#13;
output_file = open('revegetate.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
# Read input<br/>&#13;&#13;
lst = input_file.readline().split()<br/>&#13;&#13;
num_pastures = int(lst[0])<br/>&#13;&#13;
num_cows = int(lst[1])<br/>&#13;&#13;
favorites = read_cows(input_file, num_cows)<br/>&#13;&#13;
<br/>&#13;&#13;
pasture_types = [0]<br/>&#13;&#13;
<br/>&#13;&#13;
for i in range(1, num_pastures + 1):<br/>&#13;&#13;
<br/>&#13;&#13;
    # Identify cows that care about pasture<br/>&#13;&#13;
    cows = cows_with_favorite(favorites, i)<br/>&#13;&#13;
<br/>&#13;&#13;
    # Eliminate grass types for pasture<br/>&#13;&#13;
    eliminated = types_used(favorites, cows, pasture_types)<br/>&#13;&#13;
<br/>&#13;&#13;
    # Choose smallest-numbered grass type for pasture<br/>&#13;&#13;
    pasture_type = smallest_available(eliminated)<br/>&#13;&#13;
    pasture_types.append(pasture_type)<br/>&#13;&#13;
<br/>&#13;&#13;
# Write output<br/>&#13;&#13;
pasture_types.pop(0)<br/>&#13;&#13;
write_pastures(output_file, pasture_types)<br/>&#13;&#13;
<br/>&#13;&#13;
input_file.close()<br/>&#13;&#13;
output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch07ex02"><em>Listing 7-2: Solving Farm Seeding</em></p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_199"/>We did it! An intimidating problem, made more manageable by the application of top-down design. Feel free to submit our work to the USACO judge.</p>&#13;&#13;
<p class="indent">It’s easy to be overwhelmed by a problem when you first read it. But remember that you don’t need to tackle it in one huge step. Break it down, solve each task that you can solve, and you’ll be well on your way to a solution for the overall problem. You’ve made huge strides in the amount of Python that you know and your ability to design programs and solve problems. Solving these problems is within your grasp!</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Let’s think about a new version of Farm Seeding where there’s no restriction on the number of cows that care about a pasture. A pasture might be the favorite of four cows, five cows, or even more. We’re still not allowed to give a cow two pastures with the same grass type.</p>&#13;&#13;
<p class="sidebarp">Suppose that we’re solving this new version of the problem and have a test case where a pasture is the favorite of more than three cows. Which of the following is true of that test case?</p>&#13;&#13;
<p class="alpha">A. It’s <em>guaranteed</em> that there’s <em>no way</em> to solve it with only four grass types.</p>&#13;&#13;
<p class="alpha">B. There might be a way to solve it. If there is, it’s <em>possible</em> that our original solution (<a href="ch07.xhtml#ch07ex02">Listing 7-2</a>) <em>will</em> do so.</p>&#13;&#13;
<p class="alpha">C. There might be a way to solve it. If there is, it’s <em>guaranteed</em> that our original solution (<a href="ch07.xhtml#ch07ex02">Listing 7-2</a>) <em>will</em> do so.</p>&#13;&#13;
<p class="alpha">D. There might be a way to solve it. If there is, it’s <em>guaranteed</em> that our original solution (<a href="ch07.xhtml#ch07ex02">Listing 7-2</a>) <em>won’t</em> do so.</p>&#13;&#13;
<p class="sb-noindent1">Answer: B. We can find a test case that is correctly solved by our program, and we can find a test case that can be solved but not by our program. The former eliminates A and D as correct responses; the latter eliminates C as the correct response.</p>&#13;&#13;
<p class="sidebarp">Here’s a test case that is correctly solved by our program:</p>&#13;&#13;
<pre>2 4<br/>&#13;&#13;
1 2<br/>&#13;&#13;
1 2<br/>&#13;&#13;
1 2<br/>&#13;&#13;
1 2</pre>&#13;&#13;
<p class="sidebarp">Each pasture is the favorite of four cows. Nevertheless, we can solve this test case using only two grass types. Try our program, and you should see that it correctly solves this test case.</p>&#13;&#13;
<p class="sidebarp"><span epub:type="pagebreak" id="page_200"/>Now here’s a test case that can be solved, but not by our program:</p>&#13;&#13;
<pre>6 10<br/>&#13;&#13;
2 3<br/>&#13;&#13;
2 4<br/>&#13;&#13;
3 4<br/>&#13;&#13;
2 5<br/>&#13;&#13;
3 5<br/>&#13;&#13;
4 5<br/>&#13;&#13;
1 6<br/>&#13;&#13;
3 6<br/>&#13;&#13;
4 6<br/>&#13;&#13;
5 6</pre>&#13;&#13;
<p class="sidebarp">The mistake that our program makes is to use grass type 1 for pasture 1. In so doing, it’s forced to use grass type 5—which isn’t allowed!—for pasture 6. Our program fails, but don’t conclude that there isn’t a way to solve this test case. In particular, use grass type 2 for pasture 1, and you should be able to find a way to solve this test case using only four grass types. It’s possible to solve these kinds of test cases with a more sophisticated program, and I encourage you to think about this on your own if you’re interested.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch07lev1sec7">Summary</h3>&#13;&#13;
<p class="noindent">In this chapter, we learned how to open, read from, write to, and close files. Files are useful whenever you need to store information and use it as input later. They’re also useful for communicating information to your users. We also learned that we process files similarly to how we process standard input and standard output.</p>&#13;&#13;
<p class="indent">In the next chapter, we’ll learn how to store a collection of values in a Python set or dictionary. Storing a collection of values—that sounds like what a list does. We’ll see, though, that sets and dictionaries can make it easier for us to solve some kinds of problems.</p>&#13;&#13;
<h3 class="h3" id="ch07lev1sec8">Chapter Exercises</h3>&#13;&#13;
<p class="noindent">Here are some exercises for you to try. All of them are from the USACO judge and require reading and writing files. They’ll also require you to dust the cobwebs off material from previous chapters.</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">USACO 2018 December Bronze Contest problem Mixing Milk</li>&#13;&#13;
<li class="noindent">USACO 2017 February Bronze Contest problem Why Did the Cow Cross the Road</li>&#13;&#13;
<li class="noindent">USACO 2017 US Open Bronze Contest problem The Lost Cow</li>&#13;&#13;
<li class="noindent">USACO 2019 December Bronze Contest problem Cow Gymnastics</li>&#13;&#13;
<li class="noindent">USACO 2017 US Open Bronze Contest problem Bovine Genomics&#13;&#13;
<span epub:type="pagebreak" id="page_201"/>&#13;&#13;
</li>&#13;&#13;
<li class="noindent">USACO 2018 US Open Bronze Contest problem Team Tic Tac Toe</li>&#13;&#13;
<li class="noindent">USACO 2019 February Bronze Contest problem Sleepy Cow Herding</li>&#13;&#13;
</ol>&#13;&#13;
<h3 class="h3" id="ch07lev1sec9">Notes</h3>&#13;&#13;
<p class="noindent">Essay Formatting is originally from the USACO 2020 January Bronze Contest. Farm Seeding is originally from the USACO 2019 February Bronze Contest.</p>&#13;&#13;
<p class="indent">There are many types of files besides text files. You might like to work with HTML files, Excel spreadsheets, PDF files, Word documents, or image files. Python can help! See <em>Automate the Boring Stuff with Python</em>, 2nd edition by Al Sweigart (No Starch Press, 2019) for much more information.</p>&#13;&#13;
<p class="indent">The “perhaps better poetry” line is from J. C. R. Licklider, as quoted in <em>Computers and the World of the Future</em>, edited by Martin Greenberger (MIT Press, 1962):</p>&#13;&#13;
<p class="blockquote-c">But some people write poetry in the language we speak. Perhaps better poetry will be written in the language of digital computers of the future than has ever been written in English.</p>&#13;&#13;
<span epub:type="pagebreak" id="page_202"/>&#13;&#13;
</div></body></html>