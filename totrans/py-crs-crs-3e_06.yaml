- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scoring
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll finish building *Alien Invasion*. We’ll add a Play button
    to start the game on demand and to restart the game once it ends. We’ll also change
    the game so it speeds up when the player moves up a level, and we’ll implement
    a scoring system. By the end of the chapter, you’ll know enough to start writing
    games that increase in difficulty as a player progresses and that feature complete
    scoring systems.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Play Button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll add a Play button that appears before a game begins and
    reappears when the game ends so the player can play again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the game begins as soon as you run *alien_invasion.py*. Let’s start
    the game in an inactive state and then prompt the player to click a Play button
    to begin. To do this, modify the `__init__()` method of `AlienInvasion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now the game should start in an inactive state, with no way for the player to
    start it until we make a Play button.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Button Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because Pygame doesn’t have a built-in method for making buttons, we’ll write
    a `Button` class to create a filled rectangle with a label. You can use this code
    to make any button in a game. Here’s the first part of the `Button` class; save
    it as *button.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**button.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `pygame.font` module, which lets Pygame render text to
    the screen. The `__init__()` method takes the parameters `self`, the `ai_game`
    object, and `msg`, which contains the button’s text ❶. We set the button dimensions
    ❷, set `button_color` to color the button’s `rect` object dark green, and set
    `text_color` to render the text in white.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we prepare a `font` attribute for rendering text ❸. The `None` argument
    tells Pygame to use the default font, and `48` specifies the size of the text.
    To center the button on the screen, we create a `rect` for the button ❹ and set
    its `center` attribute to match that of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame works with text by rendering the string you want to display as an image.
    Finally, we call `_prep_msg()` to handle this rendering ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for `_prep_msg()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**button.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `_prep_msg()` method needs a `self` parameter and the text to be rendered
    as an image (`msg`). The call to `font.render()` turns the text stored in `msg`
    into an image, which we then store in `self.msg_image` ❶. The `font.render()`
    method also takes a Boolean value to turn antialiasing on or off (*antialiasing*
    makes the edges of the text smoother). The remaining arguments are the specified
    font color and background color. We set antialiasing to `True` and set the text
    background to the same color as the button. (If you don’t include a background
    color, Pygame will try to render the font with a transparent background.)
  prefs: []
  type: TYPE_NORMAL
- en: We center the text image on the button by creating a `rect` from the image and
    setting its `center` attribute to match that of the button ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a `draw_button()` method that we can call to display the
    button onscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**button.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We call `screen.fill()` to draw the rectangular portion of the button. Then
    we call `screen.blit()` to draw the text image to the screen, passing it an image
    and the `rect` object associated with the image. This completes the `Button` class.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Button to the Screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll use the `Button` class to create a Play button in `AlienInvasion`. First,
    we’ll update the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we need only one Play button, we’ll create the button in the `__init__()`
    method of `AlienInvasion`. We can place this code at the very end of `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates an instance of `Button` with the label `Play`, but it doesn’t
    draw the button to the screen. To do this, we’ll call the button’s `draw_button()`
    method in `_update_screen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To make the Play button visible above all other elements on the screen, we draw
    it after all the other elements have been drawn but before flipping to a new screen.
    We include it in an `if` block, so the button only appears when the game is inactive.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run *Alien Invasion*, you should see a Play button in the center
    of the screen, as shown in [Figure 14-1](#figure14-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c14/f14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: A Play button appears when the game is inactive.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start a new game when the player clicks Play, add the following `elif` block
    to the end of `_check_events()` to monitor mouse events over the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pygame detects a `MOUSEBUTTONDOWN` event when the player clicks anywhere on
    the screen ❶, but we want to restrict our game to respond to mouse clicks only
    on the Play button. To accomplish this, we use `pygame.mouse.get_pos()`, which
    returns a tuple containing the mouse cursor’s *x*- and *y*-coordinates when the
    mouse button is clicked ❷. We send these values to the new method `_check_play_button()`
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `_check_play_button()`, which I chose to place after `_check_events()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the `rect` method `collidepoint()` to check whether the point of the
    mouse click overlaps the region defined by the Play button’s `rect` ❶. If so,
    we set `game_active` to `True`, and the game begins!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to start and play a full game. When the game
    ends, the value of `game_active` should become `False` and the Play button should
    reappear.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the Game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Play button code we just wrote works the first time the player clicks Play.
    But it doesn’t work after the first game ends, because the conditions that caused
    the game to end haven’t been reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reset the game each time the player clicks Play, we need to reset the game
    statistics, clear out the old aliens and bullets, build a new fleet, and center
    the ship, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We reset the game statistics ❶, which gives the player three new ships. Then
    we set `game_active` to `True` so the game will begin as soon as the code in this
    function finishes running. We empty the `aliens` and `bullets` groups ❷, and then
    we create a new fleet and center the ship ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Now the game will reset properly each time you click Play, allowing you to play
    it as many times as you want!
  prefs: []
  type: TYPE_NORMAL
- en: Deactivating the Play Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One issue with our Play button is that the button region on the screen will
    continue to respond to clicks even when the Play button isn’t visible. If you
    click the Play button area by accident after a game begins, the game will restart!
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, set the game to start only when `game_active` is `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The flag `button_clicked` stores a `True` or `False` value ❶, and the game will
    restart only if Play is clicked *and* the game is not currently active ❷. To test
    this behavior, start a new game and repeatedly click where the Play button should
    be. If everything works as expected, clicking the Play button area should have
    no effect on the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the Mouse Cursor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want the mouse cursor to be visible when the game is inactive, but once
    play begins, it just gets in the way. To fix this, we’ll make it invisible when
    the game becomes active. We can do this at the end of the `if` block in `_check_play_button()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Passing `False` to `set_visible()` tells Pygame to hide the cursor when the
    mouse is over the game window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll make the cursor reappear once the game ends so the player can click Play
    again to begin a new game. Here’s the code to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We make the cursor visible again as soon as the game becomes inactive, which
    happens in `_ship_hit()`. Attention to details like this makes your game more
    professional looking and allows the player to focus on playing, rather than figuring
    out the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Leveling Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our current game, once a player shoots down the entire alien fleet, the player
    reaches a new level, but the game difficulty doesn’t change. Let’s liven things
    up a bit and make the game more challenging by increasing the game’s speed each
    time a player clears the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Speed Settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll first reorganize the `Settings` class to group the game settings into
    static and dynamic ones. We’ll also make sure any settings that change during
    the game reset when we start a new game. Here’s the `__init__()` method for *settings.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue to initialize settings that stay constant in the `__init__()` method.
    We add a `speedup_scale` setting ❶ to control how quickly the game speeds up:
    a value of 2 will double the game speed every time the player reaches a new level;
    a value of 1 will keep the speed constant. A value like `1.1` should increase
    the speed enough to make the game challenging but not impossible. Finally, we
    call the `initialize_dynamic_settings()` method to initialize the values for attributes
    that need to change throughout the game ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for `initialize_dynamic_settings()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method sets the initial values for the ship, bullet, and alien speeds.
    We’ll increase these speeds as the player progresses in the game and reset them
    each time the player starts a new game. We include `fleet_direction` in this method
    so the aliens always move right at the beginning of a new game. We don’t need
    to increase the value of `fleet_drop_speed`, because when the aliens move faster
    across the screen, they’ll also come down the screen faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To increase the speeds of the ship, bullets, and aliens each time the player
    reaches a new level, we’ll write a new method called `increase_speed()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To increase the speed of these game elements, we multiply each speed setting
    by the value of `speedup_scale`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We increase the game’s tempo by calling `increase_speed()` in `_check_bullet_alien_collisions()`
    when the last alien in a fleet has been shot down:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Changing the values of the speed settings `ship_speed`, `alien_speed`, and `bullet_speed`
    is enough to speed up the entire game!
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to return any changed settings to their initial values each time
    the player starts a new game; otherwise, each new game would start with the increased
    speed settings of the previous game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Playing *Alien Invasion* should be more fun and challenging now. Each time you
    clear the screen, the game should speed up and become slightly more difficult.
    If the game becomes too difficult too quickly, decrease the value of `settings.speedup_scale`.
    Or if the game isn’t challenging enough, increase the value slightly. Find a sweet
    spot by ramping up the difficulty in a reasonable amount of time. The first couple
    of screens should be easy, the next few should be challenging but doable, and
    subsequent screens should be almost impossibly difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Scoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s implement a scoring system to track the game’s score in real time and
    display the high score, level, and number of ships remaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'The score is a game statistic, so we’ll add a `score` attribute to `GameStats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**game_stats.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To reset the score each time a new game starts, we initialize `score` in `reset_stats()`
    rather than `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Score
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To display the score on the screen, we first create a new class, `Scoreboard`.
    For now, this class will just display the current score. Eventually, we’ll use
    it to report the high score, level, and number of ships remaining as well. Here’s
    the first part of the class; save it as *scoreboard.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because `Scoreboard` writes text to the screen, we begin by importing the `pygame.font`
    module. Next, we give `__init__()` the `ai_game` parameter so it can access the
    `settings`, `screen`, and `stats` objects, which it will need to report the values
    we’re tracking ❶. Then we set a text color ❷ and instantiate a font object ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn the text to be displayed into an image, we call `prep_score()` ❹, which
    we define here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In `prep_score()`, we turn the numerical value `stats.score` into a string ❶
    and then pass this string to `render()`, which creates the image ❷. To display
    the score clearly onscreen, we pass the screen’s background color and the text
    color to `render()`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll position the score in the upper-right corner of the screen and have it
    expand to the left as the score increases and the width of the number grows. To
    make sure the score always lines up with the right side of the screen, we create
    a `rect` called `score_rect` ❸ and set its right edge 20 pixels from the right
    edge of the screen ❹. We then place the top edge 20 pixels down from the top of
    the screen ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we create a `show_score()` method to display the rendered score image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This method draws the score image onscreen at the location `score_rect` specifies.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Scoreboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To display the score, we’ll create a `Scoreboard` instance in `AlienInvasion`.
    First, let’s update the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we make an instance of `Scoreboard` in `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we draw the scoreboard onscreen in `_update_screen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We call `show_score()` just before we draw the Play button.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *Alien Invasion* now, a 0 should appear at the top right of the
    screen. (At this point, we just want to make sure the score appears in the right
    place before developing the scoring system further.) [Figure 14-2](#figure14-2)
    shows the score as it appears before the game starts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll assign point values to each alien!
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c14/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: The score appears at the top-right corner of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Score as Aliens Are Shot Down
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write a live score onscreen, we update the value of `stats.score` whenever
    an alien is hit, and then call `prep_score()` to update the score image. But first,
    let’s determine how many points a player gets each time they shoot down an alien:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We’ll increase each alien’s point value as the game progresses. To make sure
    this point value is reset each time a new game starts, we set the value in `initialize_dynamic_settings()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the score in `_check_bullet_alien_collisions()` each time an alien
    is shot down:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When a bullet hits an alien, Pygame returns a `collisions` dictionary. We check
    whether the dictionary exists, and if it does, the alien’s value is added to the
    score. We then call `prep_score()` to create a new image for the updated score.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you play *Alien Invasion*, you should be able to rack up points!
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the Score
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now, we’re only prepping a new score *after* an alien has been hit, which
    works for most of the game. But when we start a new game, we’ll still see our
    score from the old game until the first alien is hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this by prepping the score when starting a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We call `prep_score()` after resetting the game stats when starting a new game.
    This preps the scoreboard with a score of 0.
  prefs: []
  type: TYPE_NORMAL
- en: Making Sure to Score All Hits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As currently written, our code could miss scoring for some aliens. For example,
    if two bullets collide with aliens during the same pass through the loop or if
    we make an extra-wide bullet to hit multiple aliens, the player will only receive
    points for hitting one of the aliens. To fix this, let’s refine the way that bullet-alien
    collisions are detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_check_bullet_alien_collisions()`, any bullet that collides with an alien
    becomes a key in the `collisions` dictionary. The value associated with each bullet
    is a list of aliens it has collided with. We loop through the values in the `collisions`
    dictionary to make sure we award points for each alien hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the `collisions` dictionary has been defined, we loop through all values
    in the dictionary. Remember that each value is a list of aliens hit by a single
    bullet. We multiply the value of each alien by the number of aliens in each list
    and add this amount to the current score. To test this, change the width of a
    bullet to 300 pixels and verify that you receive points for each alien you hit
    with your extra-wide bullets; then return the bullet width to its normal value.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing Point Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the game gets more difficult each time a player reaches a new level,
    aliens in later levels should be worth more points. To implement this functionality,
    we’ll add code to increase the point value when the game’s speed increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We define a rate at which points increase, which we call `score_scale` ❶. A
    small increase in speed (`1.1`) makes the game more challenging quickly. But to
    see a more notable difference in scoring, we need to change the alien point value
    by a larger amount (`1.5`). Now when we increase the game’s speed, we also increase
    the point value of each hit ❷. We use the `int()` function to increase the point
    value by whole integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the value of each alien, add a `print()` call to the `increase_speed()`
    method in `Settings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The new point value should appear in the terminal every time you reach a new
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding the Score
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most arcade-style shooting games report scores as multiples of 10, so let’s
    follow that lead with our scores. Also, let’s format the score to include comma
    separators in large numbers. We’ll make this change in `Scoreboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `round()` function normally rounds a float to a set number of decimal places
    given as the second argument. However, when you pass a negative number as the
    second argument, `round()` will round the value to the nearest 10, 100, 1,000,
    and so on. This code tells Python to round the value of `stats.score` to the nearest
    10 and assign it to `rounded_score`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use a format specifier in the f-string for the score. A *format specifier*
    is a special sequence of characters that modifies the way a variable’s value is
    presented. In this case the sequence `:,` tells Python to insert commas at appropriate
    places in the numerical value that’s provided. This results in strings like `1,000,000`
    instead of `1000000`.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run the game, you should see a neatly formatted, rounded score
    even when you rack up lots of points, as shown in [Figure 14-3](#figure14-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c14/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: A rounded score with comma separators'
  prefs: []
  type: TYPE_NORMAL
- en: High Scores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every player wants to beat a game’s high score, so let’s track and report high
    scores to give players something to work toward. We’ll store high scores in `GameStats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**game_stats.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because the high score should never be reset, we initialize `high_score` in
    `__init__()` rather than in `reset_stats()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll modify `Scoreboard` to display the high score. Let’s start with
    the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The high score will be displayed separately from the score, so we need a new
    method, `prep_high_score()`, to prepare the high-score image ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `prep_high_score()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We round the high score to the nearest 10 and format it with commas ❶. We then
    generate an image from the high score ❷, center the high score `rect` horizontally
    ❸, and set its `top` attribute to match the top of the score image ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show_score()` method now draws the current score at the top right and
    the high score at the top center of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To check for high scores, we’ll write a new method, `check_high_score()`, in
    `Scoreboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The method `check_high_score()` checks the current score against the high score.
    If the current score is greater, we update the value of `high_score` and call
    `prep_high_score()` to update the high score’s image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to call `check_high_score()` each time an alien is hit after updating
    the score in `_check_bullet_alien_collisions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We call `check_high_score()` when the `collisions` dictionary is present, and
    we do so after updating the score for all the aliens that have been hit.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you play *Alien Invasion*, your score will be the high score,
    so it will be displayed as the current score and the high score. But when you
    start a second game, your high score should appear in the middle and your current
    score should appear at the right, as shown in [Figure 14-4](#figure14-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c14/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: The high score is shown at the top center of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To display the player’s level in the game, we first need an attribute in `GameStats`
    representing the current level. To reset the level at the start of each new game,
    initialize it in `reset_stats()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**game_stats.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To have `Scoreboard` display the current level, we call a new method, `prep_level()`,
    from `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s `prep_level()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `prep_level()` method creates an image from the value stored in `stats.level`
    ❶ and sets the image’s `right` attribute to match the score’s `right` attribute
    ❷. It then sets the `top` attribute 10 pixels beneath the bottom of the score
    image to leave space between the score and the level ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update `show_score()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This new line draws the level image to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll increment `stats.level` and update the level image in `_check_bullet_alien_collisions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If a fleet is destroyed, we increment the value of `stats.level` and call `prep_level()`
    to make sure the new level displays correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure the level image updates properly at the start of a new game, we also
    call `prep_level()` when the player clicks the Play button:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We call `prep_level()` right after calling `prep_score()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ll see how many levels you’ve completed, as shown in [Figure 14-5](#figure14-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c14/f14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: The current level appears just below the current score.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Number of Ships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let’s display the number of ships the player has left, but this time,
    let’s use a graphic. To do so, we’ll draw ships in the upper-left corner of the
    screen to represent how many ships are left, just as many classic arcade games
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make `Ship` inherit from `Sprite` so we can create a group
    of ships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here we import `Sprite`, make sure `Ship` inherits from `Sprite` ❶, and call
    `super()` at the beginning of `__init__()` ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify `Scoreboard` to create a group of ships we can display.
    Here are the `import` statements for `Scoreboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re making a group of ships, we import the `Group` and `Ship` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We assign the game instance to an attribute, because we’ll need it to create
    some ships. We call `prep_ships()` after the call to `prep_level()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `prep_ships()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `prep_ships()` method creates an empty group, `self.ships`, to hold the
    ship instances ❶. To fill this group, a loop runs once for every ship the player
    has left ❷. Inside the loop, we create a new ship and set each ship’s *x*-coordinate
    value so the ships appear next to each other with a 10-pixel margin on the left
    side of the group of ships ❸. We set the *y*-coordinate value 10 pixels down from
    the top of the screen so the ships appear in the upper-left corner of the screen
    ❹. Then we add each new ship to the group `ships` ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to draw the ships to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scoreboard.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To display the ships on the screen, we call `draw()` on the group, and Pygame
    draws each ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the player how many ships they have to start with, we call `prep_ships()`
    when a new game starts. We do this in `_check_play_button()` in `AlienInvasion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We also call `prep_ships()` when a ship is hit, to update the display of ship
    images when the player loses a ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We call `prep_ships()` after decreasing the value of `ships_left`, so the correct
    number of remaining ships displays each time a ship is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-6](#figure14-6) shows the complete scoring system, with the remaining
    ships displayed at the top left of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c14/f14006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: The complete scoring system for *Alien Invasion*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to implement a Play button to start a new game.
    You also learned how to detect mouse events and hide the cursor in active games.
    You can use what you’ve learned to create other buttons, like a Help button to
    display instructions on how to play your games. You also learned how to modify
    the speed of a game as it progresses, implement a progressive scoring system,
    and display information in textual and nontextual ways.
  prefs: []
  type: TYPE_NORMAL
