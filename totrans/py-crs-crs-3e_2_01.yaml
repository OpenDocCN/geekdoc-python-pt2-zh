- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Files and Exceptions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件与异常
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that you’ve mastered the basic skills you need to write organized programs
    that are easy to use, it’s time to think about making your programs even more
    relevant and usable. In this chapter, you’ll learn to work with files so your
    programs can quickly analyze lots of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了编写结构化、易用程序的基本技能，是时候考虑如何使你的程序更具相关性和实用性了。在本章中，你将学习如何处理文件，这样你的程序就能快速分析大量数据。
- en: You’ll learn to handle errors so your programs don’t crash when they encounter
    unexpected situations. You’ll learn about *exceptions*, which are special objects
    Python creates to manage errors that arise while a program is running. You’ll
    also learn about the `json` module, which allows you to save user data so it isn’t
    lost when your program stops running.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学会如何处理错误，以确保当程序遇到意外情况时不会崩溃。你将了解*异常*，它是 Python 创建的特殊对象，用来管理程序运行时发生的错误。你还将学习
    `json` 模块，它可以帮助你保存用户数据，以防程序停止运行时数据丢失。
- en: Learning to work with files and save data will make your programs easier for
    people to use. Users will be able to choose what data to enter and when to enter
    it. People will be able to run your program, do some work, and then close the
    program and pick up where they left off. Learning to handle exceptions will help
    you deal with situations in which files don’t exist and deal with other problems
    that can cause your programs to crash. This will make your programs more robust
    when they encounter bad data, whether it comes from innocent mistakes or from
    malicious attempts to break your programs. With the skills you’ll learn in this
    chapter, you’ll make your programs more applicable, usable, and stable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 学会处理文件和保存数据将使你的程序更易于使用。用户将能够选择何时输入哪些数据。人们可以运行你的程序，完成一些工作，然后关闭程序，并从上次离开的地方继续。学习如何处理异常将帮助你处理文件不存在的情况，并应对其他可能导致程序崩溃的问题。这将使你的程序在遇到坏数据时更具稳健性，无论数据是来自无心的错误，还是恶意企图破坏程序。通过本章你将学到的技能，你将使你的程序更具适用性、可用性和稳定性。
- en: Reading from a File
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: An incredible amount of data is available in text files. Text files can contain
    weather data, traffic data, socioeconomic data, literary works, and more. Reading
    from a file is particularly useful in data analysis applications, but it’s also
    applicable to any situation in which you want to analyze or modify information
    stored in a file. For example, you can write a program that reads in the contents
    of a text file and rewrites the file with formatting that allows a browser to
    display it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的数据可以通过文本文件获取。文本文件可以包含天气数据、交通数据、社会经济数据、文学作品等内容。从文件中读取数据在数据分析应用中尤为重要，但它同样适用于任何需要分析或修改存储在文件中的信息的情况。例如，你可以编写一个程序，读取文本文件的内容，并重新编写文件，添加格式以便浏览器能够显示。
- en: When you want to work with the information in a text file, the first step is
    to read the file into memory. You can then work through all of the file’s contents
    at once or work through the contents line by line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想处理文本文件中的信息时，第一步是将文件读取到内存中。然后，你可以一次性处理整个文件的内容，或者逐行处理内容。
- en: Reading the Contents of a File
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: 'To begin, we need a file with a few lines of text in it. Let’s start with a
    file that contains *pi* to 30 decimal places, with 10 decimal places per line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个包含几行文本的文件。让我们从一个包含 *pi* 到 30 位小数的文件开始，每行包含 10 位小数：
- en: '**pi_digits.txt**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**pi_digits.txt**'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To try the following examples yourself, you can enter these lines in an editor
    and save the file as *pi_digits.txt*, or you can download the file from the book’s
    resources through [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    Save the file in the same directory where you’ll store this chapter’s programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自尝试以下示例，你可以在编辑器中输入这些行并将文件保存为 *pi_digits.txt*，或者你可以通过 [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e)
    下载该文件。将文件保存在与你存储本章程序相同的目录中。
- en: 'Here’s a program that opens this file, reads it, and prints the contents of
    the file to the screen:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个程序，它打开文件，读取文件内容，并将文件内容打印到屏幕上：
- en: '**file_reader.py**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**file_reader.py**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To work with the contents of a file, we need to tell Python the path to the
    file. A *path* is the exact location of a file or folder on a system. Python provides
    a module called `pathlib` that makes it easier to work with files and directories,
    no matter which operating system you or your program’s users are working with.
    A module that provides specific functionality like this is often called a *library*,
    hence the name `pathlib`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理文件内容，我们需要告诉 Python 文件的路径。*路径*是系统中一个文件或文件夹的确切位置。Python 提供了一个叫 `pathlib` 的模块，使得无论你或你的程序用户使用的是哪个操作系统，都能更轻松地处理文件和目录。像这样提供特定功能的模块通常被称为
    *库*，因此命名为 `pathlib`。
- en: We start by importing the `Path` class from `pathlib`. There’s a lot you can
    do with a `Path` object that points to a file. For example, you can check that
    the file exists before working with it, read the file’s contents, or write new
    data to the file. Here, we build a `Path` object representing the file *pi_digits.txt*,
    which we assign to the variable `path` ❶. Since this file is saved in the same
    directory as the *.py* file we’re writing, the filename is all that `Path` needs
    to access the file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `pathlib` 导入 `Path` 类。使用 `Path` 对象指向文件后，你可以做很多事情。例如，在操作文件之前，你可以检查文件是否存在，读取文件内容，或者向文件写入新数据。在这里，我们构建了一个表示文件
    *pi_digits.txt* 的 `Path` 对象，并将其赋值给变量 `path` ❶。因为这个文件保存在与我们编写的 *.py* 文件相同的目录中，所以
    `Path` 只需要文件名就能访问该文件。
- en: 'Once we have a `Path` object representing *pi_digits.txt*, we use the `read_text()`
    method to read the entire contents of the file ❷. The contents of the file are
    returned as a single string, which we assign to the variable `contents`. When
    we print the value of `contents`, we see the entire contents of the text file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个表示 *pi_digits.txt* 的 `Path` 对象，我们就可以使用 `read_text()` 方法读取文件的全部内容 ❷。文件的内容会作为一个字符串返回，我们将其赋值给变量
    `contents`。当我们打印 `contents` 的值时，看到的就是文件的全部内容：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only difference between this output and the original file is the extra blank
    line at the end of the output. The blank line appears because `read_text()` returns
    an empty string when it reaches the end of the file; this empty string shows up
    as a blank line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这段输出与原始文件的唯一区别是输出末尾多了一行空白行。空白行出现是因为 `read_text()` 在到达文件末尾时返回了一个空字符串；这个空字符串显示为一行空白。
- en: 'We can remove the extra blank line by using `rstrip()` on the `contents` string:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对 `contents` 字符串使用 `rstrip()` 来去除多余的空白行：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Recall from Chapter 2 that Python’s `rstrip()` method removes, or strips, any
    whitespace characters from the right side of a string. Now the output matches
    the contents of the original file exactly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第二章，Python 的 `rstrip()` 方法会移除字符串右侧的所有空白字符。现在输出的内容与原始文件完全一致：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can strip the trailing newline character when we read the contents of the
    file, by applying the `rstrip()` method immediately after calling `read_text()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在调用 `read_text()` 后立即应用 `rstrip()` 方法来去掉读取文件内容时的末尾换行符：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line tells Python to call the `read_text()` method on the file we’re working
    with. Then it applies the `rstrip()` method to the string that `read_text()` returns.
    The cleaned-up string is then assigned to the variable `contents`. This approach
    is called *method chaining*, and you’ll see it used often in programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码告诉 Python 调用我们正在处理的文件的 `read_text()` 方法。然后它将 `read_text()` 返回的字符串应用 `rstrip()`
    方法。清理后的字符串随后被赋值给变量 `contents`。这种方法称为 *方法链*，在编程中你会经常看到它。
- en: Relative and Absolute File Paths
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对路径和绝对路径
- en: When you pass a simple filename like *pi_digits.txt* to `Path`, Python looks
    in the directory where the file that’s currently being executed (that is, your
    *.py* program file) is stored.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个简单的文件名，比如 *pi_digits.txt*，传递给 `Path` 时，Python 会在当前执行的文件所在的目录中查找该文件（也就是你的
    *.py* 程序文件）。
- en: Sometimes, depending on how you organize your work, the file you want to open
    won’t be in the same directory as your program file. For example, you might store
    your program files in a folder called *python_work*; inside *python_work*, you
    might have another folder called *text_files* to distinguish your program files
    from the text files they’re manipulating. Even though *text_files* is in *python_work*,
    just passing `Path` the name of a file in *text_files* won’t work, because Python
    will only look in *python_work* and stop there; it won’t go on and look in *text_files.*
    To get Python to open files from a directory other than the one where your program
    file is stored, you need to provide the correct path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，取决于你如何组织工作，你想要打开的文件可能不在与你的程序文件相同的目录中。例如，你可能将程序文件存储在名为*python_work*的文件夹中；在*python_work*文件夹内，你可能会有另一个名为*text_files*的文件夹，用以区分程序文件和它们所操作的文本文件。即使*text_files*在*python_work*中，直接传递文件名给`Path`也无法正常工作，因为
    Python 只会在*python_work*中查找，并且在那停止；它不会继续查找*text_files*中的文件。为了让 Python 从与你的程序文件存储位置不同的目录打开文件，你需要提供正确的路径。
- en: 'There are two main ways to specify paths in programming. A *relative file path*
    tells Python to look for a given location relative to the directory where the
    currently running program file is stored. Since *text_files* is inside *python_work*,
    we need to build a path that starts with the directory *text_files*, and ends
    with the filename. Here’s how to build this path:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中指定路径有两种主要方法。*相对文件路径*告诉 Python 从当前正在运行的程序文件所在目录的位置查找给定位置。由于*text_files*位于*python_work*内，我们需要构建一个从*text_files*文件夹开始，并以文件名结束的路径。以下是如何构建这个路径的示例：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also tell Python exactly where the file is on your computer, regardless
    of where the program that’s being executed is stored. This is called an *absolute
    file path*. You can use an absolute path if a relative path doesn’t work. For
    instance, if you’ve put *text_files* in some folder other than *python_work*,
    then just passing `Path` the path `'text_files/``filename``.txt'` won’t work because
    Python will only look for that location inside *python_work*. You’ll need to write
    out an absolute path to clarify where you want Python to look.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以告诉 Python 文件在你电脑上的确切位置，无论正在执行的程序存储在哪里。这称为*绝对文件路径*。如果相对路径不起作用，你可以使用绝对路径。例如，如果你把*text_files*放在了与*python_work*不同的文件夹中，那么直接传递路径`Path`
    `'text_files/``filename``.txt'` 是行不通的，因为 Python 只会在*python_work*中查找该位置。你需要写出绝对路径来明确指定
    Python 应该查找的位置。
- en: 'Absolute paths are usually longer than relative paths, because they start at
    your system’s root folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径通常比相对路径长，因为它们是从系统的根文件夹开始的：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using absolute paths, you can read files from any location on your system. For
    now it’s easiest to store files in the same directory as your program files, or
    in a folder such as *text_files* within the directory that stores your program
    files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绝对路径，你可以从系统上的任何位置读取文件。现在，最简单的做法是将文件存储在与你的程序文件相同的目录中，或存储在一个名为*text_files*的文件夹内，该文件夹位于存储程序文件的目录中。
- en: Accessing a File’s Lines
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问文件的行
- en: When you’re working with a file, you’ll often want to examine each line of the
    file. You might be looking for certain information in the file, or you might want
    to modify the text in the file in some way. For example, you might want to read
    through a file of weather data and work with any line that includes the word *sunny*
    in the description of that day’s weather. In a news report, you might look for
    any line with the tag `<headline>` and rewrite that line with a specific kind
    of formatting.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理文件时，你通常需要检查文件的每一行。你可能在文件中查找特定的信息，或者你可能想以某种方式修改文件中的文本。例如，你可能希望阅读一份天气数据文件，并处理包含*sunny*（晴天）字样的所有描述该日天气的行。在新闻报道中，你可能需要查找任何带有标签`<headline>`的行，并以特定格式重新写入该行。
- en: 'You can use the `splitlines()` method to turn a long string into a set of lines,
    and then use a `for` loop to examine each line from a file, one at a time:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`splitlines()`方法将一长串字符串转换为一组行，然后使用`for`循环逐行检查文件中的内容：
- en: '**file_reader.py**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**file_reader.py**'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start out by reading the entire contents of the file, as we did earlier
    ❶. If you’re planning to work with the individual lines in a file, you don’t need
    to strip any whitespace when reading the file. The `splitlines()` method returns
    a list of all lines in the file, and we assign this list to the variable `lines`
    ❷. We then loop over these lines and print each one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we haven’t modified any of the lines, the output matches the original
    text file exactly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Working with a File’s Contents
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After you’ve read the contents of a file into memory, you can do whatever you
    want with that data, so let’s briefly explore the digits of *pi*. First, we’ll
    attempt to build a single string containing all the digits in the file with no
    whitespace in it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_string.py**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We start by reading the file and storing each line of digits in a list, just
    as we did in the previous example. We then create a variable, `pi_string`, to
    hold the digits of *pi*. We write a loop that adds each line of digits to `pi_string`
    ❶. We print this string, and also show how long the string is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The variable `pi_string` contains the whitespace that was on the left side
    of the digits in each line, but we can get rid of that by using `lstrip()` on
    each line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we have a string containing *pi* to 30 decimal places. The string is 32
    characters long because it also includes the leading `3` and a decimal point:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Large Files: One Million Digits'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve focused on analyzing a text file that contains only three lines,
    but the code in these examples would work just as well on much larger files. If
    we start with a text file that contains *pi* to 1,000,000 decimal places, instead
    of just 30, we can create a single string containing all these digits. We don’t
    need to change our program at all, except to pass it a different file. We’ll also
    print just the first 50 decimal places, so we don’t have to watch a million digits
    scroll by in the terminal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_string.py**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output shows that we do indeed have a string containing *pi* to 1,000,000
    decimal places:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Python has no inherent limit to how much data you can work with; you can work
    with as much data as your system’s memory can handle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Is Your Birthday Contained in Pi?
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve always been curious to know if my birthday appears anywhere in the digits
    of *pi*. Let’s use the program we just wrote to find out if someone’s birthday
    appears anywhere in the first million digits of *pi*. We can do this by expressing
    each birthday as a string of digits and seeing if that string appears anywhere
    in `pi_string`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_birthday.py**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We first prompt for the user’s birthday, and then check if that string is in
    `pi_string`. Let’s try it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: My birthday does appear in the digits of *pi*! Once you’ve read from a file,
    you can analyze its contents in just about any way you can imagine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a File
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest ways to save data is to write it to a file. When you write
    text to a file, the output will still be available after you close the terminal
    containing your program’s output. You can examine output after a program finishes
    running, and you can share the output files with others as well. You can also
    write programs that read the text back into memory and work with it again later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保存数据的最简单方法之一就是将其写入文件。当你将文本写入文件时，输出在你关闭包含程序输出的终端后仍然可用。你可以在程序运行完毕后检查输出，也可以将输出文件分享给他人。你还可以编写读取文本并重新加载到内存中的程序，以便以后继续使用。
- en: Writing a Single Line
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入单行
- en: 'Once you have a path defined, you can write to a file using the `write_text()`
    method. To see how this works, let’s write a simple message and store it in a
    file instead of printing it to the screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了路径，你就可以使用 `write_text()` 方法向文件写入内容。为了演示这一过程，让我们写一个简单的消息并将其存储到文件中，而不是直接输出到屏幕：
- en: '**write_message.py**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**write_message.py**'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `write_text()` method takes a single argument: the string that you want
    to write to the file. This program has no terminal output, but if you open the
    file *programming.txt*, you’ll see one line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_text()` 方法接受一个参数：你想写入文件的字符串。这个程序没有终端输出，但如果你打开 *programming.txt* 文件，你会看到一行内容：'
- en: '**programming.txt**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**programming.txt**'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This file behaves like any other file on your computer. You can open it, write
    new text in it, copy from it, paste to it, and so forth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的行为就像你电脑上的任何其他文件。你可以打开它，写入新文本，复制其中的内容，粘贴到其他地方，等等。
- en: Writing Multiple Lines
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入多行
- en: The `write_text()` method does a few things behind the scenes. If the file that
    `path` points to doesn’t exist, it creates that file. Also, after writing the
    string to the file, it makes sure the file is closed properly. Files that aren’t
    closed properly can lead to missing or corrupted data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_text()` 方法在后台做了几件事。如果 `path` 指向的文件不存在，它会创建该文件。而且，在将字符串写入文件后，它会确保文件被正确关闭。没有正确关闭的文件可能会导致数据丢失或损坏。'
- en: 'To write more than one line to a file, you need to build a string containing
    the entire contents of the file, and then call `write_text()` with that string.
    Let’s write several lines to the *programming.txt* file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要向文件写入多行，你需要构建一个包含文件所有内容的字符串，然后使用该字符串调用 `write_text()`。让我们写几行内容到 *programming.txt*
    文件中：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We define a variable called `contents` that will hold the entire contents of
    the file. On the next line, we use the `+=` operator to add to this string. You
    can do this as many times as you need, to build strings of any length. In this
    case we include newline characters at the end of each line, to make sure each
    statement appears on its own line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `contents` 的变量，用来保存文件的全部内容。在下一行，我们使用 `+=` 运算符将新的内容添加到这个字符串中。你可以根据需要多次执行此操作，构建任意长度的字符串。在这个例子中，我们在每一行的末尾添加了换行符，以确保每条语句都出现在单独的一行上。
- en: 'If you run this and then open *programming.txt*, you’ll see each of these lines
    in the text file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序并打开 *programming.txt* 文件，你会看到每一行内容都出现在文本文件中：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can also use spaces, tab characters, and blank lines to format your output,
    just as you’ve been doing with terminal-based output. There’s no limit to the
    length of your strings, and this is how many computer-generated documents are
    created.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用空格、制表符和空白行来格式化输出，就像你在终端输出中所做的那样。字符串的长度没有限制，这也是许多计算机生成文档的创建方式。
- en: Exceptions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Python uses special objects called *exceptions* to manage errors that arise
    during a program’s execution. Whenever an error occurs that makes Python unsure
    of what to do next, it creates an exception object. If you write code that handles
    the exception, the program will continue running. If you don’t handle the exception,
    the program will halt and show a *traceback*, which includes a report of the exception
    that was raised.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用名为 *exceptions*（异常）的特殊对象来处理程序执行过程中发生的错误。当发生一个错误时，导致 Python 不确定下一步该做什么，它会创建一个异常对象。如果你编写了处理异常的代码，程序将继续运行。如果你没有处理异常，程序会停止并显示
    *traceback*（追踪信息），其中包含已引发的异常报告。
- en: Exceptions are handled with `try`-`except` blocks. A *try*-*except* block asks
    Python to do something, but it also tells Python what to do if an exception is
    raised. When you use `try`-`except` blocks, your programs will continue running
    even if things start to go wrong. Instead of tracebacks, which can be confusing
    for users to read, users will see friendly error messages that you’ve written.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Handling the ZeroDivisionError Exception
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a simple error that causes Python to raise an exception. You
    probably know that it’s impossible to divide a number by zero, but let’s ask Python
    to do it anyway:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**division_calculator.py**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Python can’t do this, so we get a traceback:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The error reported in the traceback, `ZeroDivisionError`, is an exception object
    ❶. Python creates this kind of object in response to a situation where it can’t
    do what we ask it to. When this happens, Python stops the program and tells us
    the kind of exception that was raised. We can use this information to modify our
    program. We’ll tell Python what to do when this kind of exception occurs; that
    way, if it happens again, we’ll be prepared.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Using try-except Blocks
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you think an error may occur, you can write a `try`-`except` block to handle
    the exception that might be raised. You tell Python to try running some code,
    and you tell it what to do if the code results in a particular kind of exception.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what a `try`-`except` block for handling the `ZeroDivisionError` exception
    looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We put `print(5/0)`, the line that caused the error, inside a `try` block. If
    the code in a `try` block works, Python skips over the `except` block. If the
    code in the `try` block causes an error, Python looks for an `except` block whose
    error matches the one that was raised, and runs the code in that block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the code in the `try` block produces a `ZeroDivisionError`,
    so Python looks for an `except` block telling it how to respond. Python then runs
    the code in that block, and the user sees a friendly error message instead of
    a traceback:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If more code followed the `try`-`except` block, the program would continue running
    because we told Python how to handle the error. Let’s look at an example where
    catching an error can allow a program to continue running.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Using Exceptions to Prevent Crashes
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handling errors correctly is especially important when the program has more
    work to do after the error occurs. This happens often in programs that prompt
    users for input. If the program responds to invalid input appropriately, it can
    prompt for more valid input instead of crashing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple calculator that does only division:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**division_calculator.py**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This program prompts the user to input a `first_number` ❶ and, if the user
    does not enter `q` to quit, a `second_number` ❷. We then divide these two numbers
    to get an `answer` ❸. This program does nothing to handle errors, so asking it
    to divide by zero causes it to crash:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It’s bad that the program crashed, but it’s also not a good idea to let users
    see tracebacks. Nontechnical users will be confused by them, and in a malicious
    setting, attackers will learn more than you want them to. For example, they’ll
    know the name of your program file, and they’ll see a part of your code that isn’t
    working properly. A skilled attacker can sometimes use this information to determine
    which kind of attacks to use against your code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃虽然不好，但让用户看到追踪信息也不是一个好主意。非技术用户会被这些信息弄得很困惑，而在恶意环境中，攻击者会通过这些信息学到你不希望他们知道的内容。例如，他们会知道你的程序文件名，还会看到某个无法正常工作的代码部分。一个有经验的攻击者有时可以利用这些信息来确定攻击代码的方式。
- en: The else Block
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`else` 块'
- en: 'We can make this program more error resistant by wrapping the line that might
    produce errors in a `try`-`except` block. The error occurs on the line that performs
    the division, so that’s where we’ll put the `try`-`except` block. This example
    also includes an `else` block. Any code that depends on the `try` block executing
    successfully goes in the `else` block:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将可能产生错误的行包装在`try`-`except`块中，使程序更具抗错能力。错误发生在执行除法的那一行，所以我们将在那里放置`try`-`except`块。这个例子还包括了一个`else`块。任何依赖于`try`块成功执行的代码都会放入`else`块中：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We ask Python to try to complete the division operation in a `try` block ❶,
    which includes only the code that might cause an error. Any code that depends
    on the `try` block succeeding is added to the `else` block. In this case, if the
    division operation is successful, we use the `else` block to print the result
    ❸.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求Python在`try`块中尝试完成除法操作❶，该块只包含可能引发错误的代码。任何依赖于`try`块成功的代码都放入`else`块。在这种情况下，如果除法操作成功，我们使用`else`块来打印结果❸。
- en: 'The `except` block tells Python how to respond when a `ZeroDivisionError` arises
    ❷. If the `try` block doesn’t succeed because of a division-by-zero error, we
    print a friendly message telling the user how to avoid this kind of error. The
    program continues to run, and the user never sees a traceback:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`except`块告诉Python在遇到`ZeroDivisionError`时如何响应❷。如果`try`块因为除零错误而未能成功执行，我们会打印一条友好的消息，告诉用户如何避免这种错误。程序会继续运行，用户也看不到追踪信息：'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only code that should go in a `try` block is code that might cause an exception
    to be raised. Sometimes you’ll have additional code that should run only if the
    `try` block was successful; this code goes in the `else` block. The `except` block
    tells Python what to do in case a certain exception arises when it tries to run
    the code in the `try` block.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只有可能引发异常的代码应该放入`try`块中。有时你还会有一些额外的代码，只有在`try`块成功执行后才应该运行，这些代码会放在`else`块中。`except`块告诉Python在`try`块运行代码时遇到特定异常时应该怎么做。
- en: By anticipating likely sources of errors, you can write robust programs that
    continue to run even when they encounter invalid data and missing resources. Your
    code will be resistant to innocent user mistakes and malicious attacks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预测可能出现的错误来源，你可以编写出更加健壮的程序，即使遇到无效数据或缺失资源时也能继续运行。你的代码将能抵抗无心的用户错误和恶意攻击。
- en: Handling the FileNotFoundError Exception
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理FileNotFoundError异常
- en: One common issue when working with files is handling missing files. The file
    you’re looking for might be in a different location, the filename might be misspelled,
    or the file might not exist at all. You can handle all of these situations with
    a `try`-`except` block.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件时，一个常见的问题是如何处理丢失的文件。你要找的文件可能在不同的位置，文件名可能拼写错误，或者文件根本不存在。你可以通过`try`-`except`块来处理所有这些情况。
- en: 'Let’s try to read a file that doesn’t exist. The following program tries to
    read in the contents of *Alice in Wonderland*, but I haven’t saved the file *alice.txt*
    in the same directory as *alice.py*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试读取一个不存在的文件。以下程序尝试读取*爱丽丝梦游仙境*的内容，但我没有将文件*alice.txt*保存在与*alice.py*相同的目录下：
- en: '**alice.py**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**alice.py**'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we’re using `read_text()` in a slightly different way here than what
    you saw earlier. The `encoding` argument is needed when your system’s default
    encoding doesn’t match the encoding of the file that’s being read. This is most
    likely to happen when reading from a file that wasn’t created on your system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用`read_text()`的方式与之前所见的稍有不同。当你的系统默认编码与正在读取的文件编码不匹配时，需要使用`encoding`参数。这种情况最常见于读取来自非本地系统创建的文件时。
- en: 'Python can’t read from a missing file, so it raises an exception:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python无法从丢失的文件中读取数据，因此会引发异常：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is a longer traceback than the ones we’ve seen previously, so let’s look
    at how you can make sense of more complex tracebacks. It’s often best to start
    at the very end of the traceback. On the last line, we can see that a `FileNotFoundError`
    exception was raised ❸. This is important because it tells us what kind of exception
    to use in the `except` block that we’ll write.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比我们之前见过的回溯信息更长的回溯，所以让我们来看看如何理解更复杂的回溯。通常最好从回溯的最后一行开始查看。在最后一行，我们可以看到引发了`FileNotFoundError`异常
    ❸。这很重要，因为它告诉我们在`except`块中使用哪种类型的异常。
- en: Looking back near the beginning of the traceback ❶, we can see that the error
    occurred at line 4 in the file *alice.py*. The next line shows the line of code
    that caused the error ❷. The rest of the traceback shows some code from the libraries
    that are involved in opening and reading from files. You don’t usually need to
    read through or understand all of these lines in a traceback.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯信息的开头附近 ❶，我们可以看到错误发生在文件*alice.py*的第4行。下一行显示了导致错误的代码 ❷。其余的回溯信息展示了涉及打开和读取文件的库中的一些代码。通常，你不需要逐行阅读或理解回溯中的所有这些内容。
- en: 'To handle the error that’s being raised, the `try` block will begin with the
    line that was identified as problematic in the traceback. In our example, this
    is the line that contains `read_text()`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理引发的错误，`try`块将从回溯中标识为问题行的那一行开始。在我们的示例中，这一行包含了`read_text()`：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, the code in the `try` block produces a `FileNotFoundError`,
    so we write an `except` block that matches that error ❶. Python then runs the
    code in that block when the file can’t be found, and the result is a friendly
    error message instead of a traceback:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`try`块中的代码会产生`FileNotFoundError`，因此我们编写一个匹配该错误的`except`块 ❶。当找不到文件时，Python会运行该块中的代码，结果是显示一个友好的错误信息，而不是回溯信息：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The program has nothing more to do if the file doesn’t exist, so this is all
    the output we see. Let’s build on this example and see how exception handling
    can help when you’re working with more than one file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，程序没有其他操作要做，因此我们只会看到这些输出。让我们基于这个例子继续，看看异常处理如何帮助你处理多个文件时的问题。
- en: Analyzing Text
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析文本
- en: You can analyze text files containing entire books. Many classic works of literature
    are available as simple text files because they are in the public domain. The
    texts used in this section come from Project Gutenberg ([https://gutenberg.org](https://gutenberg.org)).
    Project Gutenberg maintains a collection of literary works that are available
    in the public domain, and it’s a great resource if you’re interested in working
    with literary texts in your programming projects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以分析包含整本书的文本文件。许多经典文学作品作为简单的文本文件可供使用，因为它们属于公有领域。本节使用的文本来自古腾堡计划（[https://gutenberg.org](https://gutenberg.org)）。古腾堡计划维护着一系列公有领域的文学作品，如果你有兴趣在编程项目中使用文学文本，这是一个很好的资源。
- en: 'Let’s pull in the text of *Alice in Wonderland* and try to count the number
    of words in the text. To do this, we’ll use the string method `split()`, which
    by default splits a string wherever it finds any whitespace:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入*爱丽丝梦游仙境*的文本并尝试统计其中的单词数。为此，我们将使用字符串方法`split()`，它默认在任何空白字符处将字符串拆分：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I moved the file *alice.txt* to the correct directory, so the `try` block will
    work this time. We take the string `contents`, which now contains the entire text
    of *Alice in Wonderland* as one long string, and use `split()` to produce a list
    of all the words in the book ❶. Using `len()` on this list ❷ gives us a good approximation
    of the number of words in the original text. Lastly, we print a statement that
    reports how many words were found in the file. This code is placed in the `else`
    block because it only works if the code in the `try` block was executed successfully.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我将文件*alice.txt*移动到了正确的目录，因此这次`try`块会正常工作。我们获取包含*爱丽丝梦游仙境*全文的字符串`contents`，并使用`split()`方法将其转换为一本书中所有单词的列表
    ❶。使用`len()`函数计算该列表的长度 ❷，可以很好地估算出原始文本中的单词数。最后，我们打印一条报告，显示文件中找到的单词数。此代码放在`else`块中，因为只有在`try`块中的代码成功执行时，它才会执行。
- en: 'The output tells us how many words are in *alice.txt*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们*alice.txt*中有多少个单词：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The count is a little high because extra information is provided by the publisher
    in the text file used here, but it’s a good approximation of the length of *Alice
    in Wonderland*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计数有点偏高，因为出版商在此处使用的文本文件中提供了额外的信息，但它大致上可以反映出*爱丽丝梦游仙境*的字数。
- en: Working with Multiple Files
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个文件
- en: 'Let’s add more books to analyze, but before we do, let’s move the bulk of this
    program to a function called `count_words()`. This will make it easier to run
    the analysis for multiple books:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**word_count.py**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Most of this code is unchanged. It’s only been indented, and moved into the
    body of `count_words()`. It’s a good habit to keep comments up to date when you’re
    modifying a program, so the comment has also been changed to a docstring and reworded
    slightly ❶.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write a short loop to count the words in any text we want to analyze.
    We do this by storing the names of the files we want to analyze in a list, and
    then we call `count_words()` for each file in the list. We’ll try to count the
    words for *Alice in Wonderland*, *Siddhartha*, *Moby Dick*, and *Little Women*,
    which are all available in the public domain. I’ve intentionally left *siddhartha.txt*
    out of the directory containing *word_count.py*, so we can see how well our program
    handles a missing file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The names of the files are stored as simple strings. Each string is then converted
    to a `Path` object ❶, before the call to `count_words()`. The missing *siddhartha.txt*
    file has no effect on the rest of the program’s execution:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using the `try`-`except` block in this example provides two significant advantages.
    We prevent our users from seeing a traceback, and we let the program continue
    analyzing the texts it’s able to find. If we don’t catch the `FileNotFoundError`
    that *siddhartha.txt* raises, the user would see a full traceback, and the program
    would stop running after trying to analyze *Siddhartha*. It would never analyze
    *Moby Dick* or *Little Women*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Failing Silently
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, we informed our users that one of the files was unavailable.
    But you don’t need to report every exception you catch. Sometimes, you’ll want
    the program to fail silently when an exception occurs and continue on as if nothing
    happened. To make a program fail silently, you write a `try` block as usual, but
    you explicitly tell Python to do nothing in the `except` block. Python has a `pass`
    statement that tells it to do nothing in a block:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The only difference between this listing and the previous one is the `pass`
    statement in the `except` block. Now when a `FileNotFoundError` is raised, the
    code in the `except` block runs, but nothing happens. No traceback is produced,
    and there’s no output in response to the error that was raised. Users see the
    word counts for each file that exists, but they don’t see any indication that
    a file wasn’t found:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `pass` statement also acts as a placeholder. It’s a reminder that you’re
    choosing to do nothing at a specific point in your program’s execution and that
    you might want to do something there later. For example, in this program we might
    decide to write any missing filenames to a file called *missing_files.txt*. Our
    users wouldn’t see this file, but we’d be able to read the file and deal with
    any missing texts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Deciding Which Errors to Report
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you know when to report an error to your users and when to let your program
    fail silently? If users know which texts are supposed to be analyzed, they might
    appreciate a message informing them why some texts were not analyzed. If users
    expect to see some results but don’t know which books are supposed to be analyzed,
    they might not need to know that some texts were unavailable. Giving users information
    they aren’t looking for can decrease the usability of your program. Python’s error-handling
    structures give you fine-grained control over how much to share with users when
    things go wrong; it’s up to you to decide how much information to share.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Well-written, properly tested code is not very prone to internal errors, such
    as syntax or logical errors. But every time your program depends on something
    external such as user input, the existence of a file, or the availability of a
    network connection, there is a possibility of an exception being raised. A little
    experience will help you know where to include exception-handling blocks in your
    program and how much to report to users about errors that arise.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Storing Data
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of your programs will ask users to input certain kinds of information.
    You might allow users to store preferences in a game or provide data for a visualization.
    Whatever the focus of your program is, you’ll store the information users provide
    in data structures such as lists and dictionaries. When users close a program,
    you’ll almost always want to save the information they entered. A simple way to
    do this involves storing your data using the `json` module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `json` module allows you to convert simple Python data structures into JSON-formatted
    strings, and then load the data from that file the next time the program runs.
    You can also use `json` to share data between different Python programs. Even
    better, the JSON data format is not specific to Python, so you can share data
    you store in the JSON format with people who work in many other programming languages.
    It’s a useful and portable format, and it’s easy to learn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Using json.dumps() and json.loads()
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write a short program that stores a set of numbers and another program
    that reads these numbers back into memory. The first program will use `json.dumps()`
    to store the set of numbers, and the second program will use `json.loads()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The `json.dumps()` function takes one argument: a piece of data that should
    be converted to the JSON format. The function returns a string, which we can then
    write to a data file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**number_writer.py**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We first import the `json` module, and then create a list of numbers to work
    with. Then we choose a filename in which to store the list of numbers ❶. It’s
    customary to use the file extension *.json* to indicate that the data in the file
    is stored in the JSON format. Next, we use the `json.dumps()` ❷ function to generate
    a string containing the JSON representation of the data we’re working with. Once
    we have this string, we write it to the file using the same `write_text()` method
    we used earlier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'This program has no output, but let’s open the file *numbers.json* and look
    at it. The data is stored in a format that looks just like Python:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we’ll write a separate program that uses `json.loads()` to read the list
    back into memory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**number_reader.py**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We make sure to read from the same file we wrote to ❶. Since the data file
    is just a text file with specific formatting, we can read it with the `read_text()`
    method ❷. We then pass the contents of the file to `json.loads()` ❸. This function
    takes in a JSON-formatted string and returns a Python object (in this case, a
    list), which we assign to `numbers`. Finally, we print the recovered list of numbers
    and see that it’s the same list created in *number_writer.py*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is a simple way to share data between two programs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Saving and Reading User-Generated Data
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saving data with `json` is useful when you’re working with user-generated data,
    because if you don’t store your user’s information somehow, you’ll lose it when
    the program stops running. Let’s look at an example where we prompt the user for
    their name the first time they run a program and then remember their name when
    they run the program again.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by storing the user’s name:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**remember_me.py**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We first prompt for a username to store ❶. Next, we write the data we just
    collected to a file called *username.json* ❷. Then we print a message informing
    the user that we’ve stored their information ❸:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let’s write a new program that greets a user whose name has already been
    stored:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**greet_user.py**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We read the contents of the data file ❶ and then use `json.loads()` to assign
    the recovered data to the variable `username` ❷. Since we’ve recovered the username,
    we can welcome the user back with a personalized greeting:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We need to combine these two programs into one file. When someone runs *remember_me.py*,
    we want to retrieve their username from memory if possible; if not, we’ll prompt
    for a username and store it in *username.json* for next time. We could write a
    `try`-`except` block here to respond appropriately if *username.json* doesn’t
    exist, but instead we’ll use a handy method from the `pathlib` module:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**remember_me.py**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are many helpful methods you can use with `Path` objects. The `exists()`
    method returns `True` if a file or folder exists and `False` if it doesn’t. Here
    we use `path.exists()` to find out if a username has already been stored ❶. If
    *username.json* exists, we load the username and print a personalized greeting
    to the user.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If the file *username.json* doesn’t exist ❷, we prompt for a username and store
    the value that the user enters. We also print the familiar message that we’ll
    remember them when they come back.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever block executes, the result is a username and an appropriate greeting.
    If this is the first time the program runs, this is the output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Otherwise:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the output you see if the program was already run at least once. Even
    though the data in this section is just a single string, the program would work
    just as well with any data that can be converted to a JSON-formatted string.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you’ll come to a point where your code will work, but you’ll recognize
    that you could improve the code by breaking it up into a series of functions that
    have specific jobs. This process is called *refactoring*. Refactoring makes your
    code cleaner, easier to understand, and easier to extend.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor *remember_me.py* by moving the bulk of its logic into one or
    more functions. The focus of *remember_me.py* is on greeting the user, so let’s
    move all of our existing code into a function called `greet_user()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**remember_me.py**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Because we’re using a function now, we rewrite the comments as a docstring that
    reflects how the program currently works ❶. This file is a little cleaner, but
    the function `greet_user()` is doing more than just greeting the user—it’s also
    retrieving a stored username if one exists and prompting for a new username if
    one doesn’t.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor `greet_user()` so it’s not doing so many different tasks. We’ll
    start by moving the code for retrieving a stored username to a separate function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The new function `get_stored_username()` ❶ has a clear purpose, as stated in
    the docstring. This function retrieves a stored username and returns the username
    if it finds one. If the path that’s passed to `get_stored_username()` doesn’t
    exist, the function returns `None` ❷. This is good practice: a function should
    either return the value you’re expecting, or it should return `None`. This allows
    us to perform a simple test with the return value of the function. We print a
    welcome back message to the user if the attempt to retrieve a username is successful
    ❸, and if it isn’t, we prompt for a new username.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'We should factor one more block of code out of `greet_user()`. If the username
    doesn’t exist, we should move the code that prompts for a new username to a function
    dedicated to that purpose:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Each function in this final version of *remember_me.py* has a single, clear
    purpose. We call `greet_user()`, and that function prints an appropriate message:
    it either welcomes back an existing user or greets a new user. It does this by
    calling `get_stored_username()` ❶, which is responsible only for retrieving a
    stored username if one exists. Finally, if necessary, `greet_user()` calls `get_new_username()`❷,
    which is responsible only for getting a new username and storing it. This compartmentalization
    of work is an essential part of writing clear code that will be easy to maintain
    and extend.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with files. You learned to read the
    entire contents of a file, and then work through the contents one line at a time
    if you need to. You learned to write as much text as you want to a file. You also
    read about exceptions and how to handle the exceptions you’re likely to see in
    your programs. Finally, you learned how to store Python data structures so you
    can save information your users provide, preventing them from having to start
    over each time they run a program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 11, you’ll learn efficient ways to test your code. This will help
    you trust that the code you develop is correct, and it will help you identify
    bugs that are introduced as you continue to build on the programs you’ve written.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
