<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0301" class="chapter" epub:type="chapter" id="ch03" role="doc-chapter">
<header id="header0301">
<h1 class="cn"><span aria-label=" Page 44. " class="page" epub:type="pagebreak" id="p44" role="doc-pagebreak"/><span aria-label=" Page 45. " class="page" epub:type="pagebreak" id="p45" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch03">3</a></h1>
<h1 class="ct"><span class="idx" data-term="CONWAY'S GAME OF LIFE"/><span class="idx" data-term="GAME OF LIFE"/><span class="idx" data-term="ARTIFICIAL LIFE"/>Conway’s Game of Life</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">You can use a computer to study a system by creating a mathematical model for that system, writing a program to represent the model, and then letting the model evolve over time. There are many kinds of computer simulations, but I’ll focus on a famous one called Conway’s Game of Life, the work of the British mathematician <span class="idx" data-term="Conway, John"/>John Conway. The Game of Life is an example of a <span class="idx" data-term="cellular automaton"/><i>cellular automaton</i>, a collection of colored cells on a grid that evolve through a number of time steps according to a set of rules defining the states of neighboring cells.</p>
<p>In this project, you’ll create an <i>N</i>×<i>N</i> grid of cells and simulate the evolution of the system over time by applying the rules of Conway’s Game of <span aria-label=" Page 46. " class="page" epub:type="pagebreak" id="p46" role="doc-pagebreak"/>Life. You’ll display the state of the game at each time step and provide ways to save the output to a file. You’ll set the initial condition of the system to either a random distribution or a predesigned pattern.</p>
<p>This simulation consists of the following components:</p>
<ul style="list-style-type:none">
<li class="blf">• A property defined in one- or two-dimensional space</li>
<li class="bl">• A mathematical rule to change this property for each step in the simulation</li>
<li class="bll">• A way to display or capture the state of the system as it evolves</li>
</ul>
<p>The cells in Conway’s Game of Life can be either ON or OFF. The game starts with an initial condition, in which each cell is assigned one of these states. Then, mathematical rules determine how each cell’s state will change over time. The amazing thing about Conway’s Game of Life is that with just four simple rules the system evolves to produce patterns that behave in incredibly complex ways, almost as if they were alive. Patterns include “gliders” that slide across the grid, “blinkers” that flash on and off, and even replicating patterns.</p>
<p>Of course, the philosophical implications of this game are also significant because they suggest that complex structures can evolve from simple rules without following any sort of preset pattern.</p>
<p>Here are some of the main concepts covered in this project:</p>
<ul style="list-style-type:none">
<li class="blf">• Using <code>matplotlib imshow</code> to represent a 2D grid of data</li>
<li class="bl">• Using <code>matplotlib</code> for animation</li>
<li class="bl">• Using the <code>numpy</code> array</li>
<li class="bl">• Using the <code>%</code> operator for boundary conditions</li>
<li class="bl">• Setting up a random distribution of values</li>
</ul>
<section>
<h2 class="ah" id="ah0501"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0501">How It Works</a></h2>
<p class="paft">Because the Game of Life is built on a grid of nine squares, every cell has eight neighboring cells, as shown in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-1">Figure 3-1</a>. A given cell (<i>i</i>, <i>j</i>) in the simulation is accessed on a grid [<i>i</i>][<i>j</i>], where <i>i</i> and <i>j</i> are the row and column indices, respectively. The value of a given cell at a given instant of time depends on the state of its neighbors at the previous time step.</p>
<figure class="figure" id="fig3-1">
<p class="fig"><span aria-label=" Page 47. " class="page" epub:type="pagebreak" id="p47" role="doc-pagebreak"/><img alt="" height="750" src="images/nsp-venkitachalam503045-f03001.jpg" style="width:95%; height:auto;" width="750"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-1:</span> A central cell (<i>i</i>, <i>j</i>) with eight neighboring cells</p>
</figcaption>
</figure>
<p>Conway’s Game of Life has four <span class="idx" data-level1="rules of" data-term="Conway's Game of Life"/>rules:</p>
<ol style="list-style-type:none">
<li class="nlf">1. If a cell is ON and has fewer than two neighbors that are ON, it turns OFF.</li>
<li class="nl">2. If a cell is ON and has either two or three neighbors that are ON, it remains ON.</li>
<li class="nl">3. If a cell is ON and has more than three neighbors that are ON, it turns OFF.</li>
<li class="nll">4. If a cell is OFF and has exactly three neighbors that are ON, it turns ON.</li>
</ol>
<p>These rules are meant to mirror some basic ways that a group of organisms might fare over time: underpopulation and overpopulation kill cells by turning a cell OFF when it has fewer than two neighbors or more than three, but when the population is balanced, cells stay ON and reproduce by turning another cell from OFF to ON.</p>
<p>I said that each cell has eight neighboring cells, but what about cells at the edge of the grid? Which cells are their neighbors? To answer this question, you need to think about <span class="idx" data-level1="boundary conditions" data-term="Conway's Game of Life"/><i>boundary conditions</i>, the rules that govern what happens to cells at the edges or boundaries of the grid. I’ll address this question by using <span class="idx" data-level1="boundary conditions" data-term="computer simulation"/><span class="idx" data-level1="toroidal boundary conditions" data-term="Conway's Game of Life"/><i>toroidal boundary conditions</i>, meaning that the square grid wraps around as if its shape were a torus. As shown in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-2">Figure 3-2</a>, the grid is first warped so that its horizontal edges (A and B) join to form a cylinder, and then the cylinder’s vertical edges (C and D) are joined to form a torus. Once the torus has been formed, all cells have neighbors because the whole space has no edge.</p>
<figure class="figure" id="fig3-2">
<p class="fig"><span aria-label=" Page 48. " class="page" epub:type="pagebreak" id="p48" role="doc-pagebreak"/><img alt="" height="965" src="images/nsp-venkitachalam503045-f03002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-2:</span> A conceptual visualization of toroidal boundary conditions</p>
</figcaption>
</figure>
<p>Toroidal boundary conditions are common in 2D simulations and games. For example, the game <i>Pac-Man</i> uses them. If you go off the top of the screen, you reappear on the bottom. If you go off the left side of the screen, you reappear on the right side. You’ll follow the same logic for the Game of Life simulation: for the cell in the top-left corner of the grid, for example, the neighbor directly above it will be the cell in the bottom-left corner, and the neighbor directly to the left of it will be in the cell in the top-right corner.</p>
<p>Here’s a description of the algorithm you’ll use to apply the <span class="idx" data-level1="rules" data-term="Conway's Game of Life"/>four rules and run the simulation:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Initialize the cells in the grid.</li>
<li class="nl">2. At each time step in the simulation, for each cell (<i>i</i>, <i>j</i>) in the grid, do the following:
            <ol style="list-style-type:none">
<li class="nl1">a. Update the value of cell (<i>i</i>, <i>j</i>) based on its neighbors, taking into account the boundary conditions.</li>
<li class="nl1">b. Update the display of grid values.</li>
</ol>
</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0502"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0502">Requirements</a></h2>
<p class="paft">You’ll use <code>numpy</code> arrays and the <span class="idx" data-term="matplotlib library"/><code>matplotlib</code> library to display the simulation output, and you’ll use the <code>matplotlib</code> <span class="idx" data-level1="animation" data-term="matplotlib library"/><code>animation</code> module to update the simulation.</p>
</section>
<section>
<h2 class="ah" id="ah0503"><span aria-label=" Page 49. " class="page" epub:type="pagebreak" id="p49" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0503">The Code</a></h2>
<p class="paft">We’ll examine key aspects of the program piece by piece, including how to represent the simulation grid using <code>numpy</code> and <code>matplotlib</code>, how to set the initial conditions for the simulation, how to account for toroidal boundary conditions, and how to implement the Game of Life rules. We’ll also look at the program’s <code>main()</code> function, which sends command line arguments to the program and sets the simulation into motion. To see the full project code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ah0507">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#p56">page 56</a>. You can also download the code from <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/conway">https://github.com/mkvenkit/pp2e/tree/main/conway</a>.</p>
<section>
<h3 class="bh" id="bh0501"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0501">Representing the Grid</a></h3>
<p class="paft">To represent whether a cell is alive (ON) or dead (OFF) on the grid, you’ll use the values <code>255</code> and <code>0</code> for ON and OFF, respectively. You’ll display the current state of the grid using the <span class="idx" data-level1="imshow" data-term="matplotlib library"/><code>imshow()</code> method in <code>matplotlib</code>, which represents a matrix of numbers as an image. To get a feel for how it works, let’s try a simple example inside the Python interpreter. Enter the following:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">import numpy as np</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">import matplotlib.pyplot as plt</code></p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ &gt;&gt;&gt; <code class="b">x = np.array([[0, 0, 255], [255, 255, 0], [0, 255, 0]])</code></p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ &gt;&gt;&gt; <code class="b">plt.imshow(x, interpolation='nearest')</code></p>
<p class="cll">&gt;&gt;&gt; <code class="b">plt.show()</code></p>
</div>
<p>You define a 2D <span class="idx" data-level1="array" data-term="numpy"/><code>numpy</code> array of <span class="idx" data-level1="array" data-term="numpy"/>shape (3, 3) <!--<ccust1>1</ccust1>-->❶, meaning the array has three rows and three columns. Each element of the array is an integer value. You then use the <code>plt.imshow()</code> method to display this matrix of values as an image <!--<ccust1>2</ccust1>-->❷, passing in the <span class="idx" data-level1="interpolation" data-term="matplotlib library"/>interpolation option as <code>'nearest'</code> to get sharp edges for the cells (otherwise, they’d be fuzzy). <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-3">Figure 3-3</a> shows the output of this code.</p>
<figure class="figure" id="fig3-3">
<p class="fig"><img alt="" height="421" src="images/nsp-venkitachalam503045-f03003.jpg" width="432"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-3:</span> Displaying a grid of values</p>
</figcaption>
</figure>
<p>Notice that squares with a value of <code>0</code> (OFF) are given a darker color, while squares with a value of <code>255</code> (ON) are given a lighter color.</p>
</section>
<section>
<h3 class="bh" id="bh0502"><span aria-label=" Page 50. " class="page" epub:type="pagebreak" id="p50" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0502">Setting the Initial Conditions</a></h3>
<p class="paft">To begin the simulation, set an <span class="idx" data-level1="initial conditions" data-term="Conway's Game of Life"/>initial state for each cell in the 2D grid. You can use a random distribution of ON and OFF cells and see what kinds of patterns emerge, or you can add some specific patterns and see how they evolve. We’ll look at both approaches.</p>
<p>For a random initial state, use the <span class="idx" data-level1="random module" data-term="numpy"/><code>choice()</code> method from the <code>random</code> module in <code>numpy</code>. Enter the following in the Python interpreter to see how it works:</p>
<div class="codeline">
<p class="cls">&gt;&gt;&gt; <code class="b">np.random.choice([0, 255], 4*4, p=[0.1, 0.9]).reshape(4, 4)</code></p>
</div>
<p>The output will be something like this:</p>
<div class="codeline">
<p class="clf">array([[255, 255, 255, 255],</p>
<p class="cl">       [255, 255, 255, 255],</p>
<p class="cl">       [255, 255, 255, 255],</p>
<p class="cll">       [255, 255, 255, 0]])</p>
</div>
<p><code>np.random.choice()</code> chooses a value from the given list <code>[0, 255]</code>, with the probability of the appearance of each value given in the parameter <code>p=[0.1, 0.9]</code>. Here you ask for 0 to appear with a probability of 0.1 (or 10 percent) and for 255 to appear with a probability of 90 percent. (The two values in <code>p</code> must add up to 1.) The <code>choice()</code> method creates a one-dimensional array, in this case with 16 values (specified with <code>4*4</code>). You use <code>reshape()</code> to make it a two-dimensional array with four rows and four columns.</p>
<p>To set up the initial condition to match a particular pattern instead of just filling in a random set of values, first use <code>np.zeros()</code> to initialize the grid with all zeros:</p>
<div class="codeline">
<p class="cls">grid = np.zeros(N*N).reshape(N, N)</p>
</div>
<p>This creates an <i>N</i>×<i>N</i> array of zeros. Now define a function to add a pattern at a particular row and column in the grid:</p>
<div class="codeline">
<p class="clf">def addGlider(i, j, grid):</p>
<p class="cl">    """adds a glider with top left cell at (i, j)"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ glider = np.array([[0, 0, 255],</p>
<p class="cl">                       [255, 0, 255],</p>
<p class="cl">                       [0, 255, 255]])</p>
<p class="cll">  <!--<ccust1>2</ccust1>-->❷ grid[i:i+3, j:j+3] = glider</p>
</div>
<p>You define the <span class="idx" data-level1="glider" data-term="Conway's Game of Life"/>glider pattern (an observed pattern that moves steadily across the grid) using a <code>numpy</code> array of shape (3, 3) <!--<ccust1>1</ccust1>-->❶. Then you use the <code>numpy</code> <span class="idx" data-level1="array" data-term="numpy"/>slice operation to copy the <code>glider</code> array into the simulation’s two-dimensional grid <!--<ccust1>2</ccust1>-->❷, with the pattern’s top-left corner placed at the coordinates you specify as <code>i</code> and <code>j</code>.</p>
<p>Now you can add a glider pattern to the grid of zeros with a call to the <code>addGlider()</code> function you just defined:</p>
<div class="codeline">
<p class="cls">addGlider(1, 1, grid)</p>
</div>
<p><span aria-label=" Page 51. " class="page" epub:type="pagebreak" id="p51" role="doc-pagebreak"/>You specify coordinates of (1, 1) to add the glider near the top-left corner of the grid, which is (0, 0). Note that for <code>grid[i, j]</code>, <code>i</code> starts at <code>0</code> and runs from top to bottom, and <code>j</code> starts at <code>0</code> and runs from left to right.</p>
</section>
<section>
<h3 class="bh" id="bh0503"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0503">Enforcing the Boundary Conditions</a></h3>
<p class="paft">Now we can think about how to implement the <span class="idx" data-level1="toroidal boundary conditions" data-term="Conway's Game of Life"/>toroidal boundary conditions. First, let’s see what happens at the right edge of a grid of size <i>N</i>×<i>N</i>. The cell at the end of row <i>i</i> is accessed as <code>grid[i, N-1]</code>. Its neighbor to the right is <code>grid[i, N]</code>, but according to the toroidal boundary conditions, the value accessed as <code>grid[i, N]</code> should be replaced by <code>grid[i, 0]</code>. Here’s one way to do that:</p>
<div class="codeline">
<p class="clf">if j == N-1:</p>
<p class="cl">    right = grid[i, 0]</p>
<p class="cl">else:</p>
<p class="cll">    right = grid[i, j+1]</p>
</div>
<p>Of course, you’d need to apply similar boundary conditions to the left, top, and bottom sides of the grid, but doing so would require adding a lot more code because each of the four edges of the grid would need to be tested. A much more compact way to implement the boundary conditions is with Python’s <span class="idx" data-term="modulus (%) operator"/><span class="idx" data-term="% (modulus operator)"/>modulus (<code>%</code>) operator, demonstrated here in the Python interpreter:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">N = 16</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">i1 = 14</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">i2 = 15</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">(i1+1)%N</code></p>
<p class="cl">15</p>
<p class="cl">&gt;&gt;&gt; <code class="b">(i2+1)%N</code></p>
<p class="cll">0</p>
</div>
<p>As you can see, the <code>%</code> operator gives the remainder for the integer division by <code>N</code>. In this example, <code>15%16</code> yields <code>15</code>, but <code>16%16</code> yields <code>0</code>. You can use the <code>%</code> operator to make the values wrap around at the right edge by rewriting the grid access code like this:</p>
<div class="codeline">
<p class="cls">right = grid[i, (j+1)%N]</p>
</div>
<p>Now when a cell is on the edge of the grid (in other words, when <code>j = N-1</code>), asking for the cell to the right with this method will give you <code>(j+1)%N</code>, which sets <code>j</code> back to <code>0</code>, making the right side of the grid wrap to the left side. When you do the same for the bottom of the grid, it wraps around to the top:</p>
<div class="codeline">
<p class="clf">bottom = grid[(i+1)%N, j]</p>
</div>
</section>
<section>
<h3 class="bh" id="bh0504"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0504">Implementing the Rules</a></h3>
<p class="paft">The rules of the Game of Life are based on the number of neighboring cells that are ON or OFF. To simplify the application of these rules, you can just calculate the total number of neighboring cells in the ON state. <span aria-label=" Page 52. " class="page" epub:type="pagebreak" id="p52" role="doc-pagebreak"/>Because ON corresponds to a value of 255, simply sum the values of all the neighbors and divide by 255 to get the number of ON cells. Here’s the relevant code:</p>
<div class="codeline">
<p class="clf">total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +</p>
<p class="cl">             grid[(i-1)%N, j] + grid[(i+1)%N, j] +</p>
<p class="cl">             grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +</p>
<p class="cll">             grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)</p>
</div>
<p>For any given cell (<i>i</i>, <i>j</i>), you sum the value of its eight neighbors, using the <code>%</code> operator to account for toroidal boundary conditions. Dividing the result by 255 gives you the number of neighbors that are ON, which you store in the variable <code>total</code>. Now you can use <code>total</code> to apply the Game of Life rules:</p>
<div class="codeline">
<p class="clf"># apply Conway's rules</p>
<p class="cl">if grid[i, j] == ON:</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if (total &lt; 2) or (total &gt; 3):</p>
<p class="cl">        newGrid[i, j] = OFF</p>
<p class="cl">else:</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ if total == 3:</p>
<p class="cll">        newGrid[i, j] = ON</p>
</div>
<p>Any cell that is ON is turned OFF if it has fewer than two neighbors that are ON or if it has more than three neighbors that are ON <!--<ccust1>1</ccust1>-->❶. The code in the <code>else</code> branch applies only to OFF cells: a cell is turned ON if exactly three neighbors are ON <!--<ccust1>2</ccust1>-->❷. The changes are applied to the corresponding cells in <code>newGrid</code>, which starts as a copy of <code>grid</code>. Once every cell has been evaluated and updated, <code>newGrid</code> contains the data for displaying the next time step in the simulation. You can’t make changes directly to <code>grid</code>, or the states of the cells would keep changing as you try to evaluate them.</p>
</section>
<section>
<h3 class="bh" id="bh0505"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0505">Sending Command Line Arguments to the Program</a></h3>
<p class="paft">Now you can begin writing the <code>main()</code> function of the simulation, which starts by sending command line arguments to the program:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    # command line arguments are in sys.argv[1], sys.argv[2], ...</p>
<p class="cl">    # sys.argv[0] is the script name and can be ignored</p>
<p class="cl">    # parse arguments</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser = argparse.ArgumentParser(description="Runs Conway's Game of Life</p>
<p class="cl">                                     simulation.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ parser.add_argument('--grid-size', dest='N', required=False)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ parser.add_argument('--interval', dest='interval', required=False)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ parser.add_argument('--glider', action='store_true', required=False)</p>
<p class="cll">    args = parser.parse_args()</p>
</div>
<p>You create an <span class="idx" data-term="argparse module"/><code>argparse.ArgumentParser</code> object to add command line options to the code <!--<ccust1>1</ccust1>-->❶, and then you add various options to it in the following lines. The option at <!--<ccust1>2</ccust1>-->❷ specifies the simulation grid size <i>N</i>, and the <span aria-label=" Page 53. " class="page" epub:type="pagebreak" id="p53" role="doc-pagebreak"/>option at <!--<ccust1>3</ccust1>-->❸ sets the animation update interval in milliseconds. You also create an option to start the simulation with a glider pattern <!--<ccust1>4</ccust1>-->❹. If this option isn’t set, the simulation will start with random ON and OFF values.</p>
</section>
<section>
<h3 class="bh" id="bh0506"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0506">Initializing the Simulation</a></h3>
<p class="paft">Continuing through the <code>main()</code> function, you come to the following section, which initializes the simulation:</p>
<div class="codeline">
<p class="clf">    # set grid size</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ N = 100</p>
<p class="clf">    # set animation update interval</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ updateInterval = 50</p>
<p class="cl">    if args.interval:</p>
<p class="cl">        updateInterval = int(args.interval)</p>
<p class="clf">    # declare grid</p>
<p class="cl">    grid = np.<span class="idx" data-level1="array" data-term="numpy"/>array([])</p>
<p class="cl">    # check if "glider" demo flag is specified</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ if args.glider:</p>
<p class="cl">        grid = np.<span class="idx" data-level1="array" data-term="numpy"/>zeros(N*N).reshape(N, N)</p>
<p class="cl">        addGlider(1, 1, grid)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ else:</p>
<p class="cl">        # set N if specified and valid</p>
<p class="cl">        if args.N and int(args.N) &gt; 8:</p>
<p class="cl">            N = int(args.N)</p>
<p class="cl">        # populate grid with random on/off - more off than on</p>
<p class="cll">        grid = randomGrid(N)</p>
</div>
<p>This portion of the code applies any parameters called at the command line, once the command line options have been parsed. First, a default grid size of 100×100 cells <!--<ccust1>1</ccust1>-->❶ and an update interval of 50 milliseconds <!--<ccust1>2</ccust1>-->❷ are set, in case these options aren’t set at the command line. Then you set up the initial conditions, either a random pattern by default <!--<ccust1>4</ccust1>-->❹ or a glider pattern <!--<ccust1>3</ccust1>-->❸.</p>
<p>Finally, you set up the animation:</p>
<div class="codeline">
<p class="clf">    # set up the animation</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ fig, ax = plt.subplots()</p>
<p class="cl">    img = ax.imshow(grid, interpolation='nearest')</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ ani = <span class="idx" data-level1="animation" data-term="matplotlib library"/>animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),</p>
<p class="cl">                                  interval=updateInterval,</p>
<p class="cl">                                  save_count=50)</p>
<p class="cll">    plt.show()</p>
</div>
<p>Still within the <code>main()</code> function, you configure the <code>matplotlib</code> plot and animation parameters <!--<ccust1>1</ccust1>-->❶. Then you set <code>animation.FuncAnimation()</code> to regularly call the function <code>update()</code>, defined earlier in the program, which updates the grid according to the rules of Conway’s Game of Life using toroidal boundary conditions <!--<ccust1>2</ccust1>-->❷.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0504"><span aria-label=" Page 54. " class="page" epub:type="pagebreak" id="p54" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0504">Running the Game of Life Simulation</a></h2>
<p class="paft">Now run the code:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python conway.py</code></p>
</div>
<p>This uses the default parameters for the simulation: a grid of 100×100 cells and an update interval of 50 milliseconds. As you watch the simulation, you’ll see how it progresses to create and sustain various patterns over time, as in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-4">Figure 3-4 (a) and (b)</a>.</p>
<figure class="figure" id="fig3-4">
<p class="fig"><img alt="" height="649" src="images/nsp-venkitachalam503045-f03004a.jpg" style="width:95%; height:auto;" width="643"/></p>
<p class="figh1">(a)</p>
<p class="fig"><img alt="" height="650" src="images/nsp-venkitachalam503045-f03004b.jpg" style="width:95%; height:auto;" width="646"/></p>
<p class="figh1">(b)</p>
<p class="figh"><span class="fighn">Figure 3-4:</span> The Game of Life in progress</p>
</figure>
<p><a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-5">Figure 3-5</a> shows some of the patterns to look for in the simulation. Besides the glider, look for a three-cell <span class="idx" data-level1="patterns" data-term="Conway's Game of Life"/>blinker and static patterns such as a <span class="idx" data-level1="patterns" data-term="Conway's Game of Life"/>block or <span class="idx" data-level1="patterns" data-term="Conway's Game of Life"/>loaf shape.</p>
<figure class="figure" id="fig3-5">
<p class="fig"><img alt="" height="866" src="images/nsp-venkitachalam503045-f03005.jpg" style="width:95%; height:auto;" width="772"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-5:</span> Some patterns<span class="idx" data-level1="patterns" data-term="Conway's Game of Life"/><span class="idx" data-level1="patterns" data-term="Conway's Game of Life"/><span class="idx" data-level1="patterns" data-term="Conway's Game of Life"/> in the Game of Life</p>
</figcaption>
</figure>
<p><span aria-label=" Page 55. " class="page" epub:type="pagebreak" id="p55" role="doc-pagebreak"/>Now change things up a bit by running the simulation with these parameters:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python conway.py --grid-size 32 --interval 500 --glider</code></p>
</div>
<p>This creates a simulation grid of 32×32, updates the animation every 500 milliseconds, and uses the initial glider pattern shown in the bottom right of <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-5">Figure 3-5</a>.</p>
</section>
<section>
<h2 class="ah" id="ah0505"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0505">Summary</a></h2>
<p class="paft">In this project, you explored Conway’s Game of Life. You learned how to set up a basic computer simulation based on some rules and how to use <code>matplotlib</code> to visualize the state of the system as it evolves.</p>
<p>My implementation of Conway’s Game of Life emphasizes simplicity over performance. You can speed up the computations in the Game of Life in many different ways, and a tremendous amount of research has been done on how to do this. You’ll find a lot of this research through a quick internet search.</p>
</section>
<section>
<h2 class="ah" id="ah0506"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0506">Experiments!</a></h2>
<p class="paft">Here are some ways to experiment further with Conway’s Game of Life:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Write an <code>addGosperGun()</code> method to add the pattern shown in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-6">Figure 3-6</a> to the grid. This pattern is called the <span class="idx" data-level1="Gosper Glider Gun" data-term="Conway's Game of Life"/><i>Gosper Glider Gun</i>. Run the simulation and observe what the gun does.
            <figure class="figure" id="fig3-6">
<p class="fig"><img alt="" height="178" src="images/nsp-venkitachalam503045-f03006.jpg" style="width:95%; height:auto;" width="610"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-6:</span> The Gosper Glider Gun</p>
</figcaption>
</figure>
</li>
<li class="nl">2. Write a <code>readPattern()</code> method that reads in an initial pattern from a text file and uses it to set the initial conditions for the simulation. You can use Python methods such as <code>open</code> and <code>file.read</code> to do this. Here’s a suggested format for the input file:
            <div class="codeline">
<p class="cl3f">8</p>
<p class="cl3l">0 0 0 255...</p>
</div>
<p class="nlp">The first line of the file defines <i>N</i>, and the rest of the file is just <i>N</i>×<i>N</i> integers (0 or 255) separated by whitespace. This exploration will help <span aria-label=" Page 56. " class="page" epub:type="pagebreak" id="p56" role="doc-pagebreak"/>you study how any given pattern evolves with the rules of the Game of Life. Add a <code>--pattern-file</code> command line option to use this file while running the program.</p>
</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0507"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0507">The Complete Code</a></h2>
<p class="paft">Here’s the complete code for the Game of Life project:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">conway.py</p>
<p class="clf">A simple Python/matplotlib implementation of Conway's Game of Life.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import sys, argparse</p>
<p class="cl">import numpy as np</p>
<p class="cl">import matplotlib.pyplot as plt</p>
<p class="cl">import matplotlib.animation as animation</p>
<p class="clf">def randomGrid(N):</p>
<p class="cl">    """returns a grid of NxN random values"""</p>
<p class="cl">    return np.random.choice([255, 0], N*N, p=[0.2, 0.8]).reshape(N, N)</p>
<p class="clf">def addGlider(i, j, grid):</p>
<p class="cl">    """adds a glider with top left cell at (i, j)"""</p>
<p class="cl">    glider = np.array([[0,    0, 255],</p>
<p class="cl">                       [255,  0, 255],</p>
<p class="cl">                       [0,  255, 255]])</p>
<p class="cl">    grid[i:i+3, j:j+3] = glider</p>
<p class="clf">def update(frameNum, img, grid, N):</p>
<p class="cl">    # copy grid since we require 8 neighbors for calculation</p>
<p class="cl">    # and we go line by line</p>
<p class="cl">    newGrid = grid.copy()</p>
<p class="cl">    for i in range(N):</p>
<p class="cl">        for j in range(N):</p>
<p class="cl">            # compute 8-neighbor sum</p>
<p class="cl">            # using toroidal boundary conditions - x and y wrap around</p>
<p class="cl">            # so that the simulation takes place on a toroidal surface</p>
<p class="cl">            total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +</p>
<p class="cl">                         grid[(i-1)%N, j] + grid[(i+1)%N, j] +</p>
<p class="cl">                         grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +</p>
<p class="cl">                         grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)</p>
<p class="cl">            # apply Conway's rules</p>
<p class="cl">            if grid[i, j]  == 255:</p>
<p class="cl">                if (total &lt; 2) or (total &gt; 3):</p>
<p class="cl">                    newGrid[i, j] = 0</p>
<p class="cl">            else:</p>
<p class="cl">                if total == 3:</p>
<p class="cl">                    newGrid[i, j] = 255</p>
<p class="cl">    # update data</p>
<p class="cl">    img.set_data(newGrid)</p>
<p class="cl"><span aria-label=" Page 57. " class="page" epub:type="pagebreak" id="p57" role="doc-pagebreak"/>    grid[:] = newGrid[:]</p>
<p class="cl">    # need to return a tuple here, since this callback</p>
<p class="cl">    # function needs to return an iterable</p>
<p class="cl">    return img,</p>
<p class="clf"># main() function</p>
<p class="cl">def main():</p>
<p class="cl">    # command line args are in sys.argv[1], sys.argv[2]...</p>
<p class="cl">    # sys.argv[0] is the script name itself and can be ignored</p>
<p class="cl">    # parse arguments</p>
<p class="cl">    parser = argparse.ArgumentParser(description="Runs Conway's Game of Life</p>
<p class="cl">                                     simulation.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">    parser.add_argument('--grid-size', dest='N', required=False)</p>
<p class="cl">    parser.add_argument('--interval', dest='interval', required=False)</p>
<p class="cl">    parser.add_argument('--glider', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--gosper', action='store_true', required=False)</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # set grid size</p>
<p class="cl">    N = 100</p>
<p class="clf">    # set animation update interval</p>
<p class="cl">    updateInterval = 50</p>
<p class="cl">    if args.interval:</p>
<p class="cl">        updateInterval = int(args.interval)</p>
<p class="clf">    # declare grid</p>
<p class="cl">    grid = np.array([])</p>
<p class="cl">    # check if "glider" demo flag is specified</p>
<p class="cl">    if args.glider:</p>
<p class="cl">        grid = np.zeros(N*N).reshape(N, N)</p>
<p class="cl">        addGlider(1, 1, grid)</p>
<p class="cl">    elif args.gosper:</p>
<p class="cl">        grid = np.zeros(N*N).reshape(N, N)</p>
<p class="cl">        addGosperGliderGun(10, 10, grid)</p>
<p class="cl">    else:</p>
<p class="cl">        # set N if specified and valid</p>
<p class="cl">        if args.N and int(args.N) &gt; 8:</p>
<p class="cl">            N = int(args.N)</p>
<p class="cl">        # populate grid with random on/off - more off than on</p>
<p class="cl">        grid = randomGrid(N)</p>
<p class="clf">    # set up animation</p>
<p class="cl">    fig, ax = plt.subplots()</p>
<p class="cl">    img = ax.imshow(grid, interpolation='nearest')</p>
<p class="cl">    ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),</p>
<p class="cl">                                  frames = 10,</p>
<p class="cl">                                  interval=updateInterval)</p>
<p class="clf">    plt.show()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>