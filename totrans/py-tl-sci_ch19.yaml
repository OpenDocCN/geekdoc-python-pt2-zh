- en: '**19'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DEMYSTIFYING MATPLOTLIB**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even among the large number of plotting packages available in Python, Matplotlib
    stands out. Launched in 2003 to provide a MATLAB-like graphing interface for science
    and engineering, it now dominates plotting in Python. It has spawned numerous
    visualization add-ons, like seaborn, and provides the underlying plotting functionality
    for popular analytical tools like pandas. With knowledge of Matplotlib, you can
    generate quick and simple plots as well as elaborate, complex charts while controlling
    every aspect of the display.
  prefs: []
  type: TYPE_NORMAL
- en: The Matplotlib library comes preinstalled with Anaconda. Thanks to its maturity,
    popularity, and open source status, it has a large supporting community ready
    to offer you advice and code samples. The best resource is the famous Matplotlib
    gallery (*[https://matplotlib.org/stable/gallery/index.html](https://matplotlib.org/stable/gallery/index.html)*),
    which contains code “recipes” for making just about any kind of plot you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Like any powerful piece of software, Matplotlib can be, as one author put it,
    “syntactically tedious.” The simplest plots are easy, but difficulty ramps up
    quickly. And even though resources like the Matplotlib gallery provide helpful
    code examples, if you want something slightly different than what’s provided,
    you might find yourself scratching your head. In fact, many people use Matplotlib
    by copying and pasting other people’s code and then hacking at the edges until
    they get something they like. As a user once told me, “No matter how many times
    I use Matplotlib, it always feels like the first time!”
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can greatly alleviate this pain by taking the time to learn
    some key aspects of the package. So, in this chapter, we’ll study the fundamentals
    of Matplotlib plots, including its two plotting interfaces and methods for making
    multipanel, animated, and customized plots. Armed with this knowledge, you may
    find Matplotlib a tool to embrace instead of to avoid or use reluctantly.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you don’t aspire to be a plotting warrior, take a look at the easier
    seaborn wrapper in the next chapter. And if seaborn is more than you need, there’s
    also the easier—though less flexible—pandas plotting option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Anatomy of a Plot**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in understanding Matplotlib is mastering the sometimes-awkward
    nomenclature used for its plots. To that end, let’s dissect a plot and its components.
  prefs: []
  type: TYPE_NORMAL
- en: Plots in Matplotlib are held within a `Figure` object (on left in [Figure 19-1](ch19.xhtml#ch019fig1)).
    This is a blank canvas that represents the top-level container for all plot elements.
    Besides providing the canvas on which the plot is drawn, the `Figure` object also
    controls things like the size of the plot, its aspect ratio, the spacing between
    multiple plots drawn on the same canvas, and the ability to output the plot as
    an image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-1: The Figure, Axes, and Axis components of a Matplotlib plot*'
  prefs: []
  type: TYPE_NORMAL
- en: The plots themselves—that is, the things that you and I think of as *figures*—are
    represented by the `Axes` class ([Figure 19-1](ch19.xhtml#ch019fig1), center).
    This class includes most of the figure *elements*, such as lines, polygons, markers
    (points), text, titles, and so on, as well as the methods that act *on* them.
    It also sets the coordinate system. A `Figure` can contain multiple `Axes` objects,
    but each `Axes` object can belong to only one `Figure`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Axes` object should not be confused with the `Axis` element that represents
    the numerical values on, say, the x- or y-axis of a chart ([Figure 19-1](ch19.xhtml#ch019fig1),
    right). This includes the tick marks, labels, and limits. All these elements are
    contained within the `Axes` class.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the components in [Figure 19-1](ch19.xhtml#ch019fig1) exists within
    a hierarchical structure ([Figure 19-2](ch19.xhtml#ch019fig2)). The lowest layer
    includes elements in [Figure 19-1](ch19.xhtml#ch019fig1) such as each axis, the
    axis tick marks, and labels, and the curve (`Line2D`). The highest level is the
    `Figure` object, which serves as a container for everything below it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-2: The hierarchy of the plot components in [Figure 19-1](ch19.xhtml#ch019fig1)*'
  prefs: []
  type: TYPE_NORMAL
- en: Because a `Figure` object can hold multiple `Axes` objects, you could have more
    than one `Axes` object point to the `Figure` in [Figure 19-2](ch19.xhtml#ch019fig2).
    The common example is subplots, in which one `Figure` canvas holds two or more
    different plots side by side.
  prefs: []
  type: TYPE_NORMAL
- en: '**The pyplot and Object-Oriented Approaches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two primary interfaces for plotting with Matplotlib. Using the first,
    referred to as the *pyplot approach*, you rely on Matplotlib’s internal `pyplot`
    module to *automatically* create and manage `Figure` and `Axes` objects, which
    you then manipulate with `pyplot` methods for plotting. Designed mainly for dealing
    with single plots, the `pyplot` approach reduces the amount of code that you need
    to know and write. It’s a MATLAB-like API that can be very convenient for quick,
    interactive work.
  prefs: []
  type: TYPE_NORMAL
- en: Using the second approach, called the *object-oriented style*, you *explicitly*
    create `Figure` and `Axes` objects and then call methods on the resulting objects.
    This gives you the most control over customizing your plots and keeping track
    of multiple plots in a large program. It’s also easier to understand interactions
    with other libraries if you first create an `Axes` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we’ll look at both approaches. However, according
    to the Matplotlib documentation, to maintain consistency you should *choose one
    approach and stick to it*. They suggest using the object-oriented style, particularly
    for complicated plots as well as for methods and scripts that are intended to
    be reused as part of a larger project.
  prefs: []
  type: TYPE_NORMAL
- en: It can certainly be argued that one of the reasons beginners find Matplotlib
    intimidating is that they see a mixture of these approaches in existing code,
    such as on question-and-answer sites like Stack Overflow. Because this is unavoidable,
    I suggest that you read over the descriptions for both approaches so that you
    can make an informed decision on which one to choose for yourself and you’ll have
    an awareness of the alternate approach when you encounter it in legacy code or
    in tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the pyplot Approach**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To generate a simple plot using the `pyplot` approach, let’s use the Jupyter
    Qt console. To launch a console from your base environment, open an Anaconda prompt
    (in Windows) or a terminal (in macOS or Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following (you can ignore this command if your prompt includes
    “base” in the name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, import Matplotlib’s `pyplot` module into the console. For convenience
    and by convention, you should use the alias `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By default, plots in the console will display *inline* (within the console).
    To enable plot interactivity, such as zooming and panning, you can use the magic
    command `%matplotlib qt`. Subsequent plots will render in an external Qt window,
    which comes with a toolbar. To restore inline plotting, use the `%matplotlib inline`
    magic command.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In Jupyter Notebook, you can also use %matplotlib notebook to enable in-cell
    interactivity. This can cause some latency in drawing plots, however, as rendering
    is done on the server side.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, import NumPy and use it to generate a simple 1D array for plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot the data, pass it to the aptly named `plot()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The semicolon at the end of the line suppresses display of the `Figure` object’s
    name, which you don’t need. You should now see [Figure 19-3](ch19.xhtml#ch019fig3)
    in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-3: A simple autogenerated line plot*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are worth noting here: we didn’t explicitly refer to `Figure` or
    `Axes` objects in the code, as `pyplot` took care of these behind the scenes.
    Nor did we specify what elements to show in the plot, including the ticks and
    values displayed along the x- and y-axes. Instead, Matplotlib looked at your data
    and made intelligent choices about the type of plot you wanted and how to annotate
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Along these lines, the `plot()` method makes line charts, `scatter()` makes
    scatterplots, `bar()` makes bar charts, `hist()` makes histograms, `pie()` makes
    pie charts, and so on. We’ll look at many of these in the sections to come, and
    you can also visit *[https://matplotlib.org/stable/plot_types/index](https://matplotlib.org/stable/plot_types/index)*.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic nature of these methods is useful when you want to quickly explore
    a dataset, but the resulting plots are generally too plain for presentations or
    reports. One issue is that the default configuration of methods like `plt.plot()`
    assumes that you want the size of each axis to match the range of the input data
    (such as x from 5 to 8, rather than 0 to 10, if the data is limited to values
    between 5 and 8). It also assumes that you don’t want a legend, title, or axis
    labels, and that you want lines and markers drawn in blue. This isn’t always the
    case, so `pyplot` provides many methods to embellish charts with titles, axis
    labels, grids, and so on. We’ll look at these next.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating and Manipulating Plots with pyplot Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Despite being considered a simpler approach than the object-oriented style,
    `pyplot` can still produce some very elaborate plots. To demonstrate, let’s use
    some `pyplot` methods to create a more sophisticated plot than the one shown in
    [Figure 19-3](ch19.xhtml#ch019fig3).
  prefs: []
  type: TYPE_NORMAL
- en: 'A *catenary* is the shape that a chain assumes when it’s hung from both of
    its ends. It’s a common shape in nature and architecture, examples being a square
    sail under wind pressure and the famous Gateway Arch in St. Louis, Missouri. You
    can generate a catenary by entering the following code in the console window,
    where `cosh(x)` represents the hyperbolic cosine of the `x` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s plot the catenary using a black line with a width of 3 and add a
    title, axis labels, limits to the axis values, and a background grid. Be sure
    to use CTRL-ENTER after the first six lines to prevent premature generation of
    the plot. After the last line, you can press ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the line color, `'k'` represents the single character shorthand notation
    for “black.” You can see more color choices at *[https://matplotlib.org/stable/tutorials/colors/colors.html](https://matplotlib.org/stable/tutorials/colors/colors.html)*
    and more on `plot()` parameters at *[https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html)*.
    Your output should look like [Figure 19-4](ch19.xhtml#ch019fig4).
  prefs: []
  type: TYPE_NORMAL
- en: In Matplotlib, the elements rendered on a figure canvas, such as a title, legend,
    or line, are called `Artist` objects. Standard graphical objects, like rectangles
    circles, and text, are referred to as *primitive* `Artists`. The objects that
    hold the primitives, like the `Figure`, `Axes`, and `Axis` objects, are called
    *container* `Artists`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-4: A line plot of a catenary*'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more common `pyplot` methods for making plots and working with `Artists`
    are listed in [Tables 19-1](ch19.xhtml#ch019tab1) and [19-2](ch19.xhtml#ch019tab2),
    respectively. To see the full list, visit *[https://matplotlib.org/stable/api/pyplot_summary.html](https://matplotlib.org/stable/api/pyplot_summary.html)*.
    Clicking the method names in this online list will take you to detailed information
    on the method parameters, along with example applications. To read more about
    `Artists` in general, visit *[https://matplotlib.org/stable/tutorials/intermediate/artists.html](https://matplotlib.org/stable/tutorials/intermediate/artists.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-1:** Useful `pyplot` Methods for Creating Plots'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bar` | Make a bar chart | `plt.bar(x, height, width=0.8)` |'
  prefs: []
  type: TYPE_TB
- en: '| `barh` | Make a horizontal bar chart | `plt.barh(x, height)` |'
  prefs: []
  type: TYPE_TB
- en: '| `contour` | Draw a contour map | `plt.contour(X, Y, Z)` |'
  prefs: []
  type: TYPE_TB
- en: '| `contourf` | Draw a filled contour map | `plt.contourf(X, Y, Z, cmap=''Greys'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hist` | Make a 2D histogram | `plt.hist(x, bins)` |'
  prefs: []
  type: TYPE_TB
- en: '| `pie` | Display a pie chart | `plt.pie(x=[8, 80, 9], labels=[''A'', ''B'',
    ''C''])` |'
  prefs: []
  type: TYPE_TB
- en: '| `plot` | Plot data as lines/markers | `plt.plot(x, y, ''r+'') # Red crosses`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Polar` | Make a polar plot | `plt.polar(theta, r, ''bo'') # Blue dots` |'
  prefs: []
  type: TYPE_TB
- en: '| `Scatter` | Make a scatterplot | `plt.scatter(x, y, marker=''o'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `stem` | Plot vertical lines to y coordinate | `plt.stem(x, y)` |'
  prefs: []
  type: TYPE_TB
- en: '**Table 19-2:** Useful `pyplot` Methods for Manipulating Plots'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `annotate` | Add text, arrows to `Axes` | `plt.annotate(''text'', (x, y))`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Set axis properties (min, max) | `plt.axis([xmin, xmax, ymin, ymax])`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `axhline` | Add a horizontal line | `plt.axhline(y_loc, lw=5)` |'
  prefs: []
  type: TYPE_TB
- en: '| `axvline` | Add a vertical line | `plt.axvline(x_loc, lw=3, c=''red'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | Close a plot | `plt.close()` |'
  prefs: []
  type: TYPE_TB
- en: '| `draw` | Update if interactive mode off | `plt.draw()` |'
  prefs: []
  type: TYPE_TB
- en: '| `figure` | Create or activate a figure | `plt.figure(figsize=(4.0, 6.0))`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `grid` | Add grid lines | `plt.grid()` |'
  prefs: []
  type: TYPE_TB
- en: '| `imshow` | Display data as an image | `pic = plt.imread(''img.png'')``plt.imshow(pic,
    cmap=''gray''))` |'
  prefs: []
  type: TYPE_TB
- en: '| `legend` | Place a legend on the Axes | `plt.plot(data, label=''Data'')``plt.legend()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `loglog` | Use log scaling on each axis | `plt.loglog()` |'
  prefs: []
  type: TYPE_TB
- en: '| `minorticks_off` | Remove minor ticks from axis | `plt.minorticks_off()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `minorticks_on` | Display minor ticks on axis | `plt.minorticks_on()` |'
  prefs: []
  type: TYPE_TB
- en: '| `savefig` | Save as *.jpg*, *.png*, *.pdf*, and so on | `plt.savefig(''filename.jpg'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `semilogx` | Use log scaling on x-axis | `plt.semilogx()` |'
  prefs: []
  type: TYPE_TB
- en: '| `semiology` | Use log scaling on y-axis | `plt.semilogy()` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_cmap` | Set colormap | `plt.set_cmap(''Greens'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `show` | Show plot run from terminal or when interactive mode is off | `plt.show()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `subplot` | Create subplots on a figure | `plt.subplot(nrows, ncols, index)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | Add text to the `Axes` | `plt.text(x, y, ''text'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `tight_layout` | Adjust padding in subplots | `plt.tight_layout(pad=3)` |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | Add a title to the `Axes` | `plt.title(''text'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `xkcd` | Turn on xkcd sketch-style* | `plt.xkcd()` |'
  prefs: []
  type: TYPE_TB
- en: '| `xlabel` | Set the x-axis label | `plt.xlabel(''text'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `xlim` | Set x-axis limits | `plt.xlim(xmin, xmax)` |'
  prefs: []
  type: TYPE_TB
- en: '| `xticks` | Set tick information | `plt.xticks([0, 2], rotation=30)` |'
  prefs: []
  type: TYPE_TB
- en: '| `ylabel` | Set the y-axis label | `plt.ylabel(''text'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `ylim` | Set y-axis limits | `plt.ylim(ymin, ymax)` |'
  prefs: []
  type: TYPE_TB
- en: '| `yticks` | Set tick information | `plt.yticks([0, 2], rotation=30)` |'
  prefs: []
  type: TYPE_TB
- en: '| *For best results, the Humor Sans font should be installed. |'
  prefs: []
  type: TYPE_TB
- en: Note that the code examples in the tables represent simple cases. Most methods
    take many arguments, letting you fine tune your plots with respect to properties
    like font style and size, line widths and colors, rotation angles, exploded views,
    and much more (see *[https://matplotlib.org/stable/api/pyplot_summary.html](https://matplotlib.org/stable/api/pyplot_summary.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Subplots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we’ve been working with single figures, but there’ll be times when you’ll
    want to compare two plots side by side, or bundle several charts into a summary
    display. For these occasions, Matplotlib provides the `subplot()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let’s begin by generating data for two different sine
    waves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to compare these waveforms is to plot them in the same `Axes`, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This produces the output in [Figure 19-5](ch19.xhtml#ch019fig5). By default,
    the curves plot with different colors in the Qt console, but because this is a
    black-and-white book, we used a different line width (`lw`) and line style (`ls`)
    for the `amplitude_halved` data to distinguish it from the `amplitude` data. The
    `label` parameter in `plt.plot()` also permits the use of a legend. For the list
    of characters available for marker and line styles, visit *[https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-5: Two sine waves drawn in the same Axes object*'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comparing more than a few curves, a single plot can become cluttered
    and difficult to read. In those cases, you’ll want to use separate stacked plots
    created by the `subplot()` method. [Figure 19-6](ch19.xhtml#ch019fig6) describes
    the syntax for this method, in which four subplots (`Axes`) are placed in a single
    `Figure` container.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-6: Understanding the subplot() method*'
  prefs: []
  type: TYPE_NORMAL
- en: The subplots will be arranged in a grid, and the first two arguments passed
    to the `subplot()` method specify the dimensions of this grid. The first argument
    represents the number of rows in the grid, the second, the number of columns,
    and the third argument is the index of the *active* subplot (highlighted in gray
    in the figure).
  prefs: []
  type: TYPE_NORMAL
- en: The active subplot is the one you are currently plotting in when you call a
    method like `plot()` or `scatter()`. Unlike most things in Python, the first index
    is 1, not 0.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib uses a concept called the *current figure* to keep track of which
    `Axes` is currently being worked. For example, when you call `plt.plot()`, `pyplot`
    creates a new “current figure” `Axes` to plot on. That’s why you must press CTRL-ENTER
    in the console when working on a plot. As soon as you press ENTER, the plot is
    complete, and a new “current figure” is queued up. When you’re working with multiple
    subplots, the `index` argument tells `pyplot` which subplot represents the “current
    figure.”
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For convenience, you don’t need to use commas with the subplot() arguments.
    For example, plt.subplot(223) works the same as plt.subplot(2, 2, 3), although
    it’s arguably less readable.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s plot our sine waves as two separate stacked plots. The process will
    be to call the `subplot()` method and alter its active subplot argument to change
    the current subplot. For each current subplot, the `plot()` method will post the
    data specific to that subplot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you don’t set the `y` limits on the second plot, `pyplot` will
    automatically scale the graph so that the two subplots look identical. Because
    we manually set the scale using the `ylim()` method, it’s clear that the second
    sine wave has half the amplitude of the first ([Figure 19-7](ch19.xhtml#ch019fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-7: Sine waves displayed in two horizontal subplots*'
  prefs: []
  type: TYPE_NORMAL
- en: These plots appear a bit cramped. Let’s give them some breathing room by calling
    the `tight_layout()` method and passing it a `pad` value. The larger the `pad`
    value, the larger the space between plots, though there is a limit to how much
    space can be accommodated. Additional arguments are available that let you fine
    tune the display; for example, by padding the height and width between edges of
    adjacent subplots using `h_pad` and `w_pad`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the arrow keys to bring up the previous code and add the `tight_layout()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 19-8](ch19.xhtml#ch019fig8). Now it’s clear
    which x-axis goes with which subplot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-8: The result of calling tight_layout() on the figure*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just seen how the `subplot()` method lets you subdivide a figure into
    different drawing areas and then focus the plotting commands on a single subplot.
    To help you manage even more sophisticated plots, Matplotlib provides the `GridSpec`
    class, which we’ll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  An `Axes` object represents:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  The x-, y-, and z-axes of a plot
  prefs: []
  type: TYPE_NORMAL
- en: b.  Individual elements of a plot, such as titles and legends
  prefs: []
  type: TYPE_NORMAL
- en: c.  The container for individual figure elements
  prefs: []
  type: TYPE_NORMAL
- en: d.  A blank canvas
  prefs: []
  type: TYPE_NORMAL
- en: '2.  True or False: For complicated plots, and for methods and scripts that
    are intended to be reused as part of a larger project, the Matplotlib documentation
    recommends that you use the object-oriented style.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Which code produces a grid of subplots four columns wide, three rows high,
    and with the second subplot active?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `plt.subplot(3, 4, 1)`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `plt.subplots(3, 4, 2)`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `plt.subplot(4, 3, 2)`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `plt.subplot(342)`
  prefs: []
  type: TYPE_NORMAL
- en: '4.  The `%matplotlib qt` magic command is used to:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Enable graphics within the console
  prefs: []
  type: TYPE_NORMAL
- en: b.  Allow interactive graphics within Jupyter Notebook
  prefs: []
  type: TYPE_NORMAL
- en: c.  Open an external window with interactive controls
  prefs: []
  type: TYPE_NORMAL
- en: d.  Restore inline graphics after using an external window
  prefs: []
  type: TYPE_NORMAL
- en: '5.  Make a Python dictionary of rocket heights using this data: Atlas: 57,
    Falcon9: 70, Saturn V: 111, Starship: 120\. Plot a bar chart of the data, label
    the y-axis to indicate height in meters, and set the bar width to 0.3.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Building Multipanel Displays Using GridSpec***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `matplotlib.gridspec` module includes a `GridSpec` class that lets you split
    a `Figure` into a grid of subareas. This, in turn, helps you to create subplots
    that have different widths and heights. The resulting *multipanel* displays are
    useful for summarizing information in presentations and reports.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing a Martian Multipanel Display**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s work through an example: imagine that you’re studying an ancient lakebed
    on Mars. You want to summarize some of your findings about hematite, goethite,
    and jarosite, three iron-bearing minerals associated with aqueous environments.
    You’ve sketched a layout for a compilation figure ([Figure 19-9](ch19.xhtml#ch019fig9)),
    and now you want to create it using Matplotlib.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-9: A sketch of the summary figure for a Mars study (generated with
    the xkdc() method from [Table 19-2](ch19.xhtml#ch019tab2))*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to save the code, you can create this project in the Spyder text
    editor or Jupyter Notebook rather than in the console. You’ve already played with
    Matplotlib in these applications in [Chapters 4](ch04.xhtml), [5](ch05.xhtml),
    and [6](ch06.xhtml). If you’re working in Jupyter Notebook, all of the code that
    defines a plot should be contained in the same cell.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, if you haven’t done so already, import NumPy and Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call `GridSpec` to create a 3×3 grid and assign the resulting object to
    a variable named `gs`, for *grid spec*. In the console, use CTRL-ENTER after this
    statement, as we’ll now start defining the subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates a grid with three rows and three columns. To place
    a subplot within this grid, you index the `gs` object. Unlike with the `subplot()`
    method, indexes start with 0, rather than 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-10](ch19.xhtml#ch019fig10) shows the subplot locations along with
    their grid indexes. To place the upper-left subplot (to hold the histogram, as
    illustrated in [Figure 19-9](ch19.xhtml#ch019fig9)), use `gs[0, :2]`. This references
    the first row `[0]` and columns one and two `[:2]`. Thus, the subplot spans the
    first two columns of row one. Likewise, `gs[:2, 2]` spans the first two rows of
    column three, and `gs[2, 1]` places that subplot in the center of row three.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-10: Subplots for the sketch in [Figure 19-9](ch19.xhtml#ch019fig9)
    with their GridSpec indexes annotated*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before building a subplot in the summary figure, you’ll need to specify its
    grid location using the indexes in [Figure 19-10](ch19.xhtml#ch019fig10). Let’s
    do this now for the histogram. Because we don’t have any real Mars data, we’ll
    use a dummy dataset drawn from a normal distribution (using the NumPy `random.normal()`
    method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The arguments for the `np.random.normal()` method are the mean, standard deviation,
    and number of draws from the normal distribution. The `plt.hist()` method takes
    this output, along with the number of bins for the histogram.
  prefs: []
  type: TYPE_NORMAL
- en: This will produce the chart in [Figure 19-11](ch19.xhtml#ch019fig11), though
    you won’t see this until the entire plot is finished. Your view might look slightly
    different given that the histogram data is generated randomly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-11: The histogram subplot*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll build the contour map below the histogram. Note that we can build
    the subplots in whatever order we want, but following a logical order makes it
    easier to go back and edit the code later. As always, start by locating the subplot
    on the grid using `plt.subplot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate placing text on plots, add an annotation identifying the location
    of Sample A ➊. The `text()` method used to do this needs at least an x, y location
    and a text string. The circle and line part of the string (`o--`) represents a
    pointer to the sample location. Many other arguments are available for the `text()`
    method, including ones for `fontsize`, `color`, and `rotation`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, generate some dummy coordinates and a *mesh grid* ➋ using NumPy. The `meshgrid()`
    method creates a rectangular grid out of two given one-dimensional arrays representing
    Cartesian or matrix indexing. From this grid we can use an equation to generate
    corresponding `Z` values. Calling the `pyplot` `contourf()` method and passing
    it the coordinates and a gray colormap generates filled contours. Finish by posting
    the colorbar.
  prefs: []
  type: TYPE_NORMAL
- en: This code will produce a map like the one presented in [Figure 19-12](ch19.xhtml#ch019fig12).
    If you want to get fancy, you can use an arrow artist to point to the sample location
    (see *[https://matplotlib.org/stable/tutorials/text/annotations.html#annotating-with-arrow/](https://matplotlib.org/stable/tutorials/text/annotations.html#annotating-with-arrow/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-12: The contour map subplot*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll generate the scatterplot in the upper-right corner of [Figure 19-9](ch19.xhtml#ch019fig9).
    This will plot the concentration of hematite versus goethite at Location 1\. Start
    by assigning the grid location, and then add a title and labels for the x-axis
    and y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To generate scatterplots, you pass the `plt.scatter()` method a sequence of
    x, y values. In this case, we’ll randomly generate these on the fly using NumPy’s
    normal and uniform distribution methods, respectively. For the normal method,
    the arguments are the mean, standard deviation, and number of draws. For the uniform
    method, they represent the low and high values and number of draws.
  prefs: []
  type: TYPE_NORMAL
- en: This will ultimately produce the subplot in [Figure 19-13](ch19.xhtml#ch019fig13).
    Again, because the data is randomly generated, every scatterplot will look different.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For datasets with more than a few thousand points, passing a marker type to
    plt.plot() can be much more efficient than using plt.scatter(). The reason for
    this is because plt.plot() renders points as clones, whereas plt.scatter() renders
    each point individually, to permit altering marker sizes to reflect data values
    or to differentiate datasets.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-13: The scatterplot subplot*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s build three pie charts that record the percentage of hematite, goethite,
    and jarosite in samples A, B, and C. We’ll string these along the bottom of the
    summary figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each pie chart will use the same wedge labels (representing the categories
    in the chart), so these should be assigned at the outset to avoid repeating code.
    In addition, we’ll use the `plt.pie()` method’s `explode` parameter to separate
    the pie wedges. To specify the size of the gap between the wedges, we’ll use a
    list named `explode`, which emphasizes the jarosite wedge by pulling it slightly
    out of the rest of the pie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a pie chart, pass the `plt.pie()` method the `labels` (representing
    the categories in the chart), the `sizes` (representing the percentages of each
    category), and the `explode` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Complete the figure by calling the `tight_layout()` method to add some space
    between the subplots. After this last line, if you’re in the console, press ENTER
    or SHIFT-ENTER to generate the final multipanel plot, which you can see in [Figure
    19-14](ch19.xhtml#ch019fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/19fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-14: The final multipanel summary plot*'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to `GridSpec`, the summary display contains subplots that span multiple
    rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the Width and Height of the Subplots**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Within certain bounds, you can set the width and height of the rows and columns
    produced by `GridSpec`. You can do this through the `width_ratios` and `height_ratios`
    parameters, which each accept a list of numbers. Only the *ratios* between these
    numbers matter. For example, to set the width ratios for each column in our 3×3
    grid, `[1, 2, 4]` is the same as `[2, 4, 8]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, enter the following code to alter our Martian multipanel display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `widths` list addresses column widths, starting at index 0\. The `heights`
    list repeats this for row heights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, bring up the code from the previous section (using the arrow key if in
    the console) and edit the call to `plt.GridSpec`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the code and you should see the plot in [Figure 19-15](ch19.xhtml#ch019fig15).
    Note the changes such as the shorter histogram and the taller contour map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-15: The multipanel display with new row and column widths and heights*'
  prefs: []
  type: TYPE_NORMAL
- en: To read more about `GridSpec` and see some example use cases, visit *[https://matplotlib.org/stable/api/_as_gen/matplotlib.gridspec.GridSpec.html](https://matplotlib.org/stable/api/_as_gen/matplotlib.gridspec.GridSpec.html)*.
    For a tutorial on the `pyplot` approach, see *[https://matplotlib.org/stable/tutorials/introductory/pyplot.html](https://matplotlib.org/stable/tutorials/introductory/pyplot.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Object-Oriented Style**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object-oriented plotting style generally requires a bit more code than the
    previously described `pyplot` approach, but it lets you get the absolute most
    out of Matplotlib. By explicitly creating `Figure` and `Axes` objects, you’ll
    be able to more easily control your plots, better understand interactions with
    other libraries, create plots with multiple x- and y-axes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll appreciate the object-oriented style more if you’re familiar with object-oriented
    programming. This programming paradigm is covered in [Chapter 13](ch13.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: To familiarize ourselves with the object-oriented style, let’s re-create the
    simple plot from [Figure 19-3](ch19.xhtml#ch019fig3). If you’re using the Qt console,
    restart it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Matplotlib `import` statement stays the same regardless of the plotting
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, regenerate the dataset with NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To start using the object-oriented style, enter the following and press CTRL-ENTER
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you see this line of code in a program, you know you’re dealing with
    the object-oriented style. The `plt.subplots()` method creates a `Figure` instance
    and a set of subplots (a NumPy array of `Axes` objects). If a number of subplots
    is not specified, a single subplot is returned by default. Because two objects
    are returned, you need to unpack the results to two variables, called `fig` and
    `ax` by convention. Remember that, with the `pyplot` approach, these two entities
    are created behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the plot, add the following line and then press ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 19-16](ch19.xhtml#ch019fig16), which is identical
    to the one in [Figure 19-3](ch19.xhtml#ch019fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-16: A simple line plot generated using the object-oriented style*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you assigned the plot to a `fig` variable, you can regenerate it by
    simply entering `fig` in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The object-oriented plotting style really isn’t mysterious. The key is to assign
    the `Figure` and `Axes` objects created by `pyplot` to variables. You’ll no longer
    get the benefit of the automated features of `pyplot`, but in return you open
    the door to a host of object attributes and methods for customizing plots.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating and Manipulating Plots with the Object-Oriented Style***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To better understand the object-oriented style, let’s use it to re-create the
    catenary example from “Creating and Manipulating Plots with pyplot Methods” on
    [page 542](ch19.xhtml#ch00lev2sec252). To demonstrate some of the style’s enhanced
    functionality, we’ll force the y-axis to pass through the center of the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using the Qt console, restart the kernel now. Then, import NumPy
    and Matplotlib and regenerate the catenary data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a single plot, enter the following and then press CTRL-ENTER (in
    the console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, call the `AXES` object’s `set()` method and pass it keyword arguments
    for a title, axis labels, and axis limits. This is a convenience method that lets
    you set multiple properties at once rather than calling specific methods for each.
    You can use either a single line that wraps, or press ENTER after each comma to
    produce a more readable vertical stack, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s move the y-axis to the center of the chart instead of along the side.
    In Matplotlib, *spines* are the lines connecting the axis tick marks and noting
    the boundaries of the area containing the plotted data. The default position for
    these is around a plot with the ticks and labels along the left and bottom margins
    (see [Figure 19-16](ch19.xhtml#ch019fig16)). But spines can also be placed at
    arbitrary positions. With the object-oriented style, we can accomplish this using
    the `set_position()` method of the `Spine` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code first moves the left (y) axis to the 0 value on the x-axis.
    Then, the line width is set to `2` so that the axis stands out a bit from the
    background grid that we’re going to use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line turns off the right boundary of the plot by setting its
    color to none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three lines repeat this overall process for the bottom axis and top
    axis, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish the plot, add the background grid and call the plot method, passing
    it the x and y data and setting the line width to `3` and the color to black (`''k''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 19-17](ch19.xhtml#ch019fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-17: The line plot of a catenary built using the object-oriented
    style*'
  prefs: []
  type: TYPE_NORMAL
- en: If you omit the code related to the spines, you can reproduce the plot in [Figure
    19-4](ch19.xhtml#ch019fig4) with essentially the same amount of code as used by
    the `pyplot` approach. Thus, the verbosity of the object-oriented style has much
    to do with the fact that you can do more with it, and people generally take advantage
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: Methods available in the `pyplot` approach have an equivalent in the object-oriented
    style. Unfortunately, the method names are often different. For example, `title()`
    in `pyplot` becomes `set_title()`, and `xticks()` becomes `set_xticks()`. This
    is one reason why it’s good to pick one approach and stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more common methods for making object-oriented plots are listed
    in [Table 19-3](ch19.xhtml#ch019tab3). You can find additional methods, such as
    for making box plots, violin plots, and more, at *[https://matplotlib.org/stable/plot_types/index.html](https://matplotlib.org/stable/plot_types/index.html)*
    and in the Matplotlib gallery, referenced previously in this chapter on [page
    538](ch19.xhtml#page_538).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-3:** Useful Object-Oriented Methods for Creating Plots'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bar` | Make a bar chart | `ax.bar(x, height)` |'
  prefs: []
  type: TYPE_TB
- en: '| `barh` | Make a horizontal bar chart | `ax.barh(x, height)` |'
  prefs: []
  type: TYPE_TB
- en: '| `contour` | Draw a contour map | `ax.contour(X, Y, Z)` |'
  prefs: []
  type: TYPE_TB
- en: '| `contourf` | Draw a filled contour map | `ax.contourf(X, Y, Z, cmap=''Greys'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hist` | Make a 2D histogram | `ax.hist(x, bins)` |'
  prefs: []
  type: TYPE_TB
- en: '| `pie` | Display a pie chart | `ax.pie(x=[8, 80, 9], labels=[''A'', ''B'',
    ''C''])` |'
  prefs: []
  type: TYPE_TB
- en: '| `plot` | Plot data as lines/markers | `ax.plot(x, y, ''r+'') # Red crosses`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `polar` | Make a polar plot | `fig, ax = plt.subplots(subplot_kw={''projection'':
    ''polar''})``ax.plot(theta, r, ''bo'') # Blue dots` |'
  prefs: []
  type: TYPE_TB
- en: '| `scatter` | Make a scatterplot | `ax.scatter(x, y, marker=''o'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `stem` | Plot vertical lines to y coordinate | `ax.stem(x, y)` |'
  prefs: []
  type: TYPE_TB
- en: Common methods for working with `Figure` and `Axes` objects are listed in [Tables
    19-4](ch19.xhtml#ch019tab4) and [19-5](ch19.xhtml#ch019tab5), respectively. In
    many cases, these work like the `pyplot` methods in [Table 19-2](ch19.xhtml#ch019tab2),
    though the method names might be different.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-4:** Useful Object-Oriented Methods for Working with `Figure` Objects'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add_subplot` | Add or retrieve an `Axes` | `ax = fig.add_subplot(2, 2, 1)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `close()` | Close a figure | `plt.close(fig2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `colorbar` | Add a colorbar to an `Axes` | `fig.colorbar(image, ax=ax)` |'
  prefs: []
  type: TYPE_TB
- en: '| `constrained_layout` | Auto-adjust fit of subplots | `fig, ax = plt.subplots(constrained_layout=True)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gca` | Get the current `Axes` instance on the current figure | `fig.gca()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `savefig` | Save as *.jpg*, *.png*, *.pdf*, and so on | `fig.savefig(''filename.jpg'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `set_size_inches` | Set `Figure` size in inches | `fig.set_size_inches(6,
    4)` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_dpi` | Set `Figure` dots per inch | `fig.set_dpi(200) # Default is 100.`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `show` | Show plot run from terminal or when interactive mode is off | `plt.show()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `subplots` | Create `Figure` with `Axes` | `fig, ax = plt.subplots(2, 2)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `suptitle` | Add a super title to a `Figure` | `fig.suptitle(''text'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `tight_layout` | Auto-adjust subplots fit | `fig.tight_layout()` |'
  prefs: []
  type: TYPE_TB
- en: '**Table 19-5:** Useful Object-Oriented Methods for Working with `Axes` Objects'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `annotate` | Add text and arrows to `Axes` | `ax.annotate(''text'', xy=(5,
    2))` |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Get or set axis properties | `ax.axis([xmin, xmax, ymin, ymax])`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `axhline` | Add a horizontal line | `ax.axhline(y_loc, lw=5)` |'
  prefs: []
  type: TYPE_TB
- en: '| `axvline` | Add a vertical line | `ax.axvline(x_loc, lw=3, c=''red'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `grid` | Add grid lines | `ax.grid()` |'
  prefs: []
  type: TYPE_TB
- en: '| `imshow` | Display data as an image | `pic = plt.imread(''img.png'')``ax.imshow(pic,
    cmap=''gray''))` |'
  prefs: []
  type: TYPE_TB
- en: '| `legend` | Place a legend on the `Axes` | `ax.plot(data, label=''Data'')``ax.legend()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `loglog` | Use log scaling on each axis | `ax.loglog()` |'
  prefs: []
  type: TYPE_TB
- en: '| `minorticks_on` | Display minor ticks on axis | `ax.yaxis.get_ticklocs(minor=True)``ax.minorticks_on()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `minorticks_off` | Remove minor ticks from axis | `plt.minorticks_off()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `semilogx` | Use log scaling on x-axis | `ax.semilogx()` |'
  prefs: []
  type: TYPE_TB
- en: '| `semiology` | Use log scaling on y-axis | `ax.semilogy()` |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | Set multiple properties at once | `ax.set(title, ylabel, xlim, alpha)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `set_title()` | Set the `Axes` title | `ax.set_title(''text'', loc=''center'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `set_xticks()` | Set x-axis tick marks | `xticks = np.arange(0, 100, 10)
    ax.set_xticks(xticks)` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_yticks()` | Set y-axis tick marks | `yticks = np.arange(0, 100, 10)
    ax.set_yticks(yticks)` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_xticklabels` | Set x-axis labels after calling `set_xticks()` | `labels
    = [a'', ''b'', ''c'', ''d'']``ax.set_xticklabels(labels)` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_yticklabels` | Set y-axis labels after calling `set_yticks()` | `ax.set_yticklabels([1,
    2, 3, 4])` |'
  prefs: []
  type: TYPE_TB
- en: '| `tick_params` | Change ticks, labels, and grid | `ax.tick_params(labelcolor=
    ''red'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `twinx` | New y-axis with shared x-axis | `ax.twinx()` |'
  prefs: []
  type: TYPE_TB
- en: '| `twiny` | New x-axis with shared y-axis | `ax.twiny()` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_xlabel()` | Set label for x-axis | `ax.set_xlabel(''text'', loc=''left'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `set_ylabel()` | Set label for y-axis | `ax.set_ylabel(''text'', loc=''top'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `set_xlim()` | Set limits of x-axis | `ax.set_xlim(-5, 5)` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_ylim()` | Set limits of y-axis | `ax.set_ylim(0, 10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_xscale()` | Set the x-axis scale | `ax.set_xscale(''log'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `set_yscale()` | Set the y-axis scale | `ax.set_yscale(''linear'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | Add text to the `Axes` | `ax.text(x, y, ''text'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `xaxis.grid()` | Add x-axis grid lines | `ax.xaxis.grid(True, which=''major'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yaxis.grid()` | Add y-axis grid lines | `ax.yaxis.grid(True, which=''minor'')`
    |'
  prefs: []
  type: TYPE_TB
- en: As mentioned in the `pyplot` section, the code examples in all these tables
    represent simple cases. Most methods take many arguments, letting you fine tune
    your plots with respect to properties like font style and size, line widths and
    colors, rotation angles, exploded views, and much more. To learn more, visit the
    Matplotlib documentation at *[https://matplotlib.org/](https://matplotlib.org/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Subplots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like the `pyplot` approach, the object-oriented style supports the use of subplots
    (see “Working with Subplots” on [page 545](ch19.xhtml#ch00lev2sec253)). Although
    there are multiple ways to assign subplots to `Figure` and `Axes` objects, the
    `plt.subplots()` method is convenient and returns a NumPy array that lets you
    select subplots using standard indexing or with unique names such as `axs[0, 0]`
    or `ax1`. Another benefit is that you can preview the subplots’ geometry prior
    to plotting any data.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The object-oriented method for creating subplots is spelled subplots, whereas
    the pyplot approach uses subplot.*'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `plt.subplots()` with no arguments generates a single empty plot ([Figure
    19-18](ch19.xhtml#ch019fig18)). Technically, this produced a 1×1 `AxesSubplot`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/19fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-18: Empty plot produced using the subplots()method of the object-oriented
    style*'
  prefs: []
  type: TYPE_NORMAL
- en: Producing multiple subplots is like the `plt.subplot()` method, only without
    an index argument for the active subplot. The first argument indicates the number
    of rows; the second specifies the number of columns. By convention, multiple `Axes`
    are given the plural name, `axs`, rather than `axes` so as to avoid confusion
    with a single instance of `Axes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the `plt.subplots()` method two arguments lets you control the number
    of subplots and their geometry. The following code generates the 2×2 grid of subplots
    shown in [Figure 19-19](ch19.xhtml#ch019fig19) and stores a list of two `AxesSubplot`
    objects in the `axs` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/19fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-19: Four subplots in a 2×2 arrangement*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate a subplot, you can use its index. In this example, we plot on the
    second subplot in the first row, producing [Figure 19-20](ch19.xhtml#ch019fig20):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/19fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-20: Plotting using subplot index [0, 1]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can name and store the subplots individually by using tuple
    unpacking for multiple `Axes`. Each row of subplots will need to be in its own
    tuple. You can then select a subplot using a name, versus a less-readable index.
    The following code reproduces [Figure 19-20](ch19.xhtml#ch019fig20):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `subplots()` method takes additional keywords, including figure
    keywords, that let you do things like share an axis among plots, adjust the figure
    size and layout, and so on ([Figure 19-21](ch19.xhtml#ch019fig21)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For more on these keywords, see the method’s documentation at *[https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplots.html](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplots.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-21: A 2×2 grid of subplots that share x- and y-axes*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Building Multipanel Displays Using GridSpec***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `matplotlib.gridspec` module (described in “Building Multipanel Displays
    Using GridSpec” on [page 549](ch19.xhtml#ch00lev2sec254)) also works with the
    object-oriented style. Let’s use it now to reproduce the Martian multipanel display
    in [Figure 19-14](ch19.xhtml#ch019fig14). This will let you directly compare the
    `pyplot` and object-oriented approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reconstructing the Martian Multipanel Display**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To start fresh, restart the kernel in an open console (**Kernel** ▸ **Restart
    Current Kernel**) or exit and reopen the console. If you’re restarting, use CTRL-L
    to clear the window. To restart in Jupyter Notebook, use **Kernel** ▸ **Restart
    & Clear Output**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, import NumPy and Matplotlib and set up a 3×3 grid using `GridSpec`. In
    the console, press CTRL-ENTER after line `In [39]` to prevent generation of the
    plot (in Notebook, use ENTER):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, build the histogram subplot. Name it `ax1` and position it using the
    grid indexes in [Figure 19-10](ch19.xhtml#ch019fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing to use CTRL-ENTER in the console, build the contour map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll build the scatterplot located in the upper-right corner of the
    display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the code for the pie wedge labels and the gaps between pie wedges. This
    reduces code duplication because these variables are the same for all the charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the charts and then call the `Figure` object’s `tight_layout()` method
    to prevent the plots from crowding one another. Generate the display by pressing
    ENTER or SHIFT-ENTER in the console, and CTRL-ENTER in Jupyter Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that the main changes from the `pyplot` approach are some method names,
    such as `set_title()` for `title()`, and the use of subplot names. The resulting
    display should be identical to [Figure 19-14](ch19.xhtml#ch019fig14), except for
    some variations in the randomly generated data.
  prefs: []
  type: TYPE_NORMAL
- en: To change the width and height of the subplots, refer to the section “Changing
    the Width and Height of the Subplots” on [page 554](ch19.xhtml#ch00lev3sec81).
    This task works the same for both plotting approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The `matplotlib.gridspec` module gives you a lot of control over the placement
    of subplots in multipanel displays. As always with Python, however, there are
    multiple ways to do the same thing, and we’ll look at one of these alternatives
    next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Higher-Level Alternatives to GridSpec**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Matplotlib library includes some higher-level alternatives to using `GridSpec`.
    With the `subplot_mosaic()` method, for example, you can lay out your grid using
    logical names like `upper_left` and `right`. You then can use these to index the
    `axs` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This produces the display in [Figure 19-22](ch19.xhtml#ch019fig22). The subplots
    are laid out in the order in which they are assigned in line `In [40]`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-22: Subplots created using the plt.subplot_mosaic() method*'
  prefs: []
  type: TYPE_NORMAL
- en: To read more about `subplot_mosaic()` and other multipaneling options, see the
    sections “Working with Multiple Figures and Axes” at *[https://matplotlib.org/stable/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py/](https://matplotlib.org/stable/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py/)*
    and “Arranging Multiple Axes in a Figure” at *[https://matplotlib.org/stable/tutorials/intermediate/arranging_axes.html](https://matplotlib.org/stable/tutorials/intermediate/arranging_axes.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Insetting Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *inset* plot—that is, a plot within a plot—is useful for showing greater
    detail in part of an enclosing plot, a different treatment of the same data, the
    geographical location of the data, and so on. An inset plot is like a subplot,
    but it’s built using a different technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an inset, you first make a `Figure` object and then add `Axes` to it
    using the `add_axes()` method. Enter the following code in the console or in Notebook;
    ignore the imports if you’ve already executed them in your current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set up the `Figure` and `Axes` objects. In this case, `ax2` represents
    the inset plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The arcane-looking list passed to the `add_axes()` method represents the `Axes`
    `rect` parameter. This defines the dimensions of the rectangular `Axes` object.
    The values range from 0 to 1 and represent, respectively, the left, bottom, width,
    and height of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now make the main plot and the inset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You should get a plot like the one depicted in [Figure 19-23](ch19.xhtml#ch019fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-23: A plot with an inset plot*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting in 3D***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although designed primarily for 2D plotting, Matplotlib includes an `Axes3D`
    class that supports 3D scatterplots, histograms, surfaces, contour maps, and more.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is to pass the `projection=''3d''` keyword when creating an `Axes`
    object ➊. You can also use this alternate two-line syntax if you find it easier
    to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Both will yield the plot shown in [Figure 19-24](ch19.xhtml#ch019fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-24: A 3D line plot*'
  prefs: []
  type: TYPE_NORMAL
- en: To read more about 3D plotting, visit *[https://matplotlib.org/stable/tutorials/toolkits/mplot3d.html](https://matplotlib.org/stable/tutorials/toolkits/mplot3d.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Animating Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scientists commonly study dynamic phenomena such as ocean currents and caribou
    migrations. Whether based on actual observations or simulated behavior, the ability
    to visualize movement in plots, a process called *animation*, can lead to insights
    and better understanding of the phenomena. Animations also enhance presentations,
    helping your audience to better understand the points you’re trying to convey.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, Matplotlib provides numerous ways for animating plots.
    For simple animations, you can manually update and plot variables by iterating
    in a loop. For convenience and for working with more complicated animations, you
    can use the `matplotlib.animation` module (*[https://matplotlib.org/stable/api/animation_api.html](https://matplotlib.org/stable/api/animation_api.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: The `animation` module contains the `FuncAnimation` class, which animates a
    visualization by repeatedly calling a function. The `ArtistAnimation` class makes
    an animation using a fixed set of `Artist` objects such as a precomputed list
    of images. In general, `FuncAnimation` is simpler to use and more efficient. We
    won’t cover `ArtistAnimation` here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Animating Plots Using a for Loop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Perhaps the simplest way to animate a plot is to use a `for` loop. Let’s give
    this a try using the sine wave example from “Working with Subplots” on [page 545](ch19.xhtml#ch00lev2sec253).
    In the console, enter the following code, using CTRL-ENTER after the first line
    and ENTER after the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Start by importing NumPy and Matplotlib, as usual, but this time, add the Standard
    Library’s `time` module ➊. The `time.sleep()` method will let us control the speed
    of the animation later.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show the animation in the external Qt window, so call the `%matplotlib`
    `qt` magic command. If you’re working in Jupyter Notebook, you can use the `%matplotlib
    notebook` command to show the animation within the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Next, reproduce the time (`t`) and `amplitude` data from before and then assign
    the `fig` and `ax` variables. To animate plots using a `for` loop, you need to
    update the displayed data before each iteration of the loop. Because we’re plotting
    a line, assign a `line` variable to the plot ➋. Note the comma after `line`, which
    indicates that this is a tuple unpacking process.
  prefs: []
  type: TYPE_NORMAL
- en: Start a `for` loop that runs 30 times. With each loop, shift the time series
    one second by adding the loop number (`i`) to the y data using the equation `np.sin(t
    + i)`. Assign the result to the `updated_amp` variable. To update the `line` object
    prior to plotting, call its `set_ydata()`method and pass it the `updated_amp`
    variable ➌.
  prefs: []
  type: TYPE_NORMAL
- en: To update a `Figure` object that has been altered but not automatically redrawn,
    call `canvas.draw()`. Follow this with the `canvas_flush_events()`method, which
    clears the plot so that the next iteration can start with a blank screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by calling the `time.sleep()` method and passing it `0.1`. This is the
    number of seconds to suspend program execution. Feel free to play around with
    this number to see the effect on the animation; the larger the number, the slower
    it will proceed.
  prefs: []
  type: TYPE_NORMAL
- en: To run the animation, in the console, press ENTER; in Jupyter Notebook, press
    CTRL-ENTER. To return to inline plotting, remember to use the `%matplotlib inline`
    magic command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can accomplish this type of real-time animation by using the `pyplot`
    approach. Here’s an example in which we continuously update a scatterplot by adding
    a new point calculated with the quadratic equation. Run it in the Qt console or
    the Spyder text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `plt.pause()` in place of `time.sleep()`. The `plt.pause()`
    method takes seconds as an argument and runs the GUI event loop for this time
    interval. An active figure will be updated and displayed before the pause, and
    the GUI event loop (if any) will run during the pause.
  prefs: []
  type: TYPE_NORMAL
- en: As the animation runs, the x- and y-axes automatically adjust to accommodate
    the expanding plot limits. When the animation finishes, you should see a plot
    like the one shown in [Figure 19-25](ch19.xhtml#ch019fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-25: The finished pyplot animation*'
  prefs: []
  type: TYPE_NORMAL
- en: For complex animations, the Matplotlib documentation recommends using the `matplotlib.animation`
    module rather than a `for` loop. We’ll cover this technique next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Animating Plots Using the FuncAnimation Class**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `FuncAnimation` class makes an animation by repeatedly calling a function.
    It provides a more formal and flexible approach than the `for` loop process used
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s animate two lines in the same plot using the object-oriented style. Enter
    the following in the console or Jupyter Notebook (if you’re using Notebook, replace
    the `%matplotlib qt` magic with `%matplotlib notebook`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Add `FuncAnimation` from the `matplotlib.animation` module to the imports ➊.
    Next, use NumPy to generate some data for plotting. The `scaler` array will let
    you alter the `x` and `y` data, giving you something new to print as the animation
    runs ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the `fig` and `ax` objects and then make a plot for each line, setting
    the color for the first to black and the second to red. Also set the line width
    of the first line to 2, and the line style for the second to dashed.
  prefs: []
  type: TYPE_NORMAL
- en: For both lines, add a zero index `[0]` to the end of the plotting code ➌. The
    plot command returns a sequence of line objects, and we want only the first item
    in the sequence. This represents an alternative to the tuple unpacking approach
    (`line, = ax.plot(t, amplitude)`) used to animate the sine wave in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to define a function that will update the data to create each
    frame of the animation. We’ll call this function `animate`, with a parameter named
    `frame`. The argument for this parameter will be the `scalar` array, which will
    be passed by the `frames` parameter in the `FuncAnimation()` class.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `set_ydata()` method on each line and pass it the `y` data divided by
    the `scaler` array. For the second line, multiply `scaler` by a negative scalar
    so that `line2` will look different than `line1`.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the code, call `FuncAnimation()` and pass it the `Figure` object
    on which it will draw (`fig`), the user-defined function (`animate`), and a `frames`
    and `interval` argument. The frames argument represents the source of the data
    passed to the user-defined function for each frame of the animation. It can be
    either an iterable, an integer, a generator function, or `None`. The `interval`
    argument sets the delay time between frames in milliseconds. Increasing this number
    will slow down the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can assign the scalar NumPy array directly to the frames parameter, like
    so: FuncAnimation(fig, animate, frames=np.arange(1, 10, 0.1), interval=20). Although
    this removes the need for the scalar variable, the code is arguably less readable.*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code by pressing ENTER in the console, or CTRL-ENTER in Jupyter Notebook.
    You should see two animated line plots, as shown in [Figure 19-26](ch19.xhtml#ch019fig26).
    To stop the animation, click the **Close** button at the upper right of the plot
    window. Otherwise, when calling `FuncAnimation()`, set `repeat=False` to stop
    the animation after a single run-through.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-26: A screen capture from the functional animation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An optional parameter in `FuncAnimation()` worth mentioning is `fargs`. Short
    for *functional arguments*, you use this when your user-defined function takes
    multiple arguments. The first parameter is always reserved for the `frames` parameter
    in `FuncAnimation()`, but you can pass subsequent parameters (those that follow
    `frames`) as an ordered tuple of arguments, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to save the animation as a .*gif*, use the `save()` method with optional
    frames per second (`fps`) and dots-per-inch (`dpi`) arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Other supported file formats include *.avi*, *.mp4*, *.mov*, and other save
    options include the methods `to_html5_video()` and `to_jshtml()`. To learn more
    about the methods and parameters of `FuncAnimation`, visit *[https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html](https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until now, you’ve changed the default settings for a plot, such as the line
    width or marker color, by passing new values as you made the plot. But what if
    you want to set these values for multiple plots *at the same time* so that all
    your lines are colored black? Or what if you’d like to *cycle through* a defined
    order of colors?
  prefs: []
  type: TYPE_NORMAL
- en: Well, one way to do this is to set the parameters at runtime, using an instance
    of the `RcParams` class. The name of this class stands for *runtime configuration
    parameters*, and you run it from a notebook, script, or console using either the
    `pyplot` approach or the object-oriented style. It stores settings in the `matplotlib.rcParams`
    variable, which is a dictionary-like object.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a very long list of configurable parameters, which you can view in multiple
    ways. To see a list of valid parameters, visit *[https://matplotlib.org/stable/api/matplotlib_configuration_api.html?highlight=rcparams/](https://matplotlib.org/stable/api/matplotlib_configuration_api.html?highlight=rcparams/)*.
    To see more details about the parameters, run `import matplotlib as mpl` followed
    by `print(mpl.matplotlib_fname())`. This will reveal the path to the *matplotlibrc*
    file on your computer, which you then can open and view.
  prefs: []
  type: TYPE_NORMAL
- en: '***Changing Runtime Configuration Parameters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at a `pyplot` example in which we standardize the size of figures,
    use black for all plotted lines, and cycle through two different line styles.
    This means that the first line plotted will always have a certain consistent style,
    and that the second plotted will have another consistent style. In the console,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that we import Matplotlib as `mpl`. Importing Matplotlib in this
    manner gives us access to more features than in the `pyplot` module alone. We
    also import `cycler`. The `Cycler` class will let us specify which colors and
    other style properties we want to cycle through when making multidata plots. You
    can read about it at *[https://matplotlib.org/stable/tutorials/intermediate/color_cycle.html](https://matplotlib.org/stable/tutorials/intermediate/color_cycle.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a property in `rcParams`, treat it like a dictionary key. You can
    find the valid parameter names by entering `mpl.rcParams.keys()` or by visiting
    the sources listed in the previous section. In the next three lines, we set the
    figure size, line color, and line styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also set parameters through pyplot, using syntax like plt.rcParams[''lines.color'']
    = ''black''.*'
  prefs: []
  type: TYPE_NORMAL
- en: To cycle through the line styles, use the `axes.prop_cycle` key and then pass
    the `cycler` factory function the parameter (`'linestyle'`) and a list of the
    styles (solid and dotted). These defaults have now been reset for all plots that
    you will make in the current session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish by generating some data and plotting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Normally, this code would produce a plot with two solid lines, one blue and
    one orange. Now, however, you get two black lines distinguished by different line
    styles ([Figure 19-27](ch19.xhtml#ch019fig27)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-27: A plot built with global figure size, line color, and line style
    parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you were to plot *three* lines in the previous plot, the third
    line would cycle back to using the solid line style, and you’d have one dotted
    and two solid lines. If you want three different styles, you’ll need to add the
    extra style to the cycler.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, Matplotlib comes with functions for simultaneously modifying
    multiple settings in a single group using keyword arguments. Here’s an example,
    using the previous plotting data, in which we start by resetting the Matplotlib
    “factory defaults”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s use the `rc()` convenience function to change the default line width
    to `5` and the line style to dash-dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 19-28](ch19.xhtml#ch019fig28).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-28: The new plotting parameters set with a convenience function*'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a style for only a specific block of code, the style package
    provides a context manager for limiting your changes to a specific scope. For
    more on this, see “Temporary Styling” at *[https://matplotlib.org/stable/tutorials/introductory/customizing.html](https://matplotlib.org/stable/tutorials/introductory/customizing.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating and Using a Style File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can save changes to the Matplotlib default style in a file. This lets you
    standardize plots for a report or presentation and share the customization within
    a project team. It also reduces code redundancy and complexity by letting you
    preset certain plot parameters and encapsulate them in an external file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple style file that sets some standards for plots, such as
    the figure size and resolution, use of a background grid, and the typeface and
    size to use for titles, axes labels, and tick labels. In the Spyder text editor,
    or any text editor, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For guidance on creating style files, use the matplotlibrc file on your computer,
    mentioned previously. You can also find a copy at [https://matplotlib.org/stable/tutorials/introductory/customizing.html](https://matplotlib.org/stable/tutorials/introductory/customizing.html).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Matplotlib to easily find this file, you need to save it in a specific
    location. First, find the location of the *matplotlibrc* file by entering the
    following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This shows you the path to the *mpl-data* folder, which contains the *matplotlibrc*
    file and a folder named *stylelib*, among others. Save your style file into the
    *stylelib* folder as *scientific_style.mplstyle* (replacing the .*txt* extension).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If Matplotlib has trouble finding this file later, you might need to restart
    the kernel. In the console, click ***Kernel*** ▸ ***Restart Current Kernel***.
    In Jupyter Notebook, click ***Kernel*** ▸ ***Restart***.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use this file to create a standardized plot. After importing `pyplot`,
    use its `style.use()` method to load the style file *without* its file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Next, generate an empty figure using the object-oriented style. You should see
    a plot like [Figure 19-29](ch19.xhtml#ch019fig29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/19fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-29: An empty standardized plot generated by the style file*'
  prefs: []
  type: TYPE_NORMAL
- en: When you saved your style file, you might have noticed that the *stylelib* folder
    was full of preexisting *mplstyle* files. These files create many different plot
    formats, and you can look through them for clues on how to write your own style
    files. In the next section, we’ll use one of these files to override some of Matplotlib’s
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: '***Applying Style Sheets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides letting you customize your own plots, Matplotlib provides predefined
    *style sheets* that you can import by using `style.use()`. Style sheets look the
    same as the *matplotlibrc* file, but within one, you can set only `rcParams` that
    are related to the actual style of the plot. This makes style sheets portable
    between different machines because there’s no need to worry about uninstalled
    dependencies. Only a few `rcParams` can’t be reset, and you can view a list of
    these at *[https://matplotlib.org/stable/api/style_api.html#matplotlib.style.use/](https://matplotlib.org/stable/api/style_api.html#matplotlib.style.use/)*.
  prefs: []
  type: TYPE_NORMAL
- en: You can see examples of the available style sheets at *[https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html)*.
    These take the form of a strip of thumbnails, as shown in [Figure 19-30](ch19.xhtml#ch019fig30).
    Some of the style sheets emulate popular plotting libraries like seaborn and ggplot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-30: Example of the grayscale style sheet*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An important style sheet to be aware of is the *s*eaborn-colorblind sheet.
    This style sheet uses “colorblind-safe” colors designed for the 5 to 10 percent
    of the population that suffers from color blindness.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out a scatterplot using the grayscale style sheet that ships with
    Matplotlib. First, in either the console or Jupyter Notebook, import NumPy and
    Matplotlib and then call the grayscale file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, generate some dummy data for making two different point clouds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Finish by setting up and executing the plot using the `pyplot` approach. Use
    log scales for both axes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You should see a plot similar to the one in [Figure 19-31](ch19.xhtml#ch019fig31).
    The point locations might differ due to the use of randomly generated data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/19fig31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-31: A scatterplot made using the grayscale style sheet*'
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `alpha` keyword when calling `plt.scatter()` ➊. The `alpha`
    attribute controls opacity, letting you regulate the transparency of a line or
    marker. A value of `1` is completely opaque.
  prefs: []
  type: TYPE_NORMAL
- en: Making one dataset slightly transparent helps to resolve *over-posting*, wherein
    markers from one dataset plot on top of markers from other datasets, obscuring
    the over-posted markers. Semi-transparent markers also become darker as they stack
    on top of one another, letting you visualize data density (such as the blacker
    circles in [Figure 19-31](ch19.xhtml#ch019fig31)).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To control the plot order of markers, use the zorder parameter (such as zorder=2)
    when calling plt.scatter(). Artists with higher zorder values will post over those
    with lower values.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our style sheet: if you open the *grayscale.mplstyle*, you’ll see that
    it looks a lot like the *scientific_style.mplstyle* file that we made in “Creating
    and Using a Style File” on [page 576](ch19.xhtml#ch00lev2sec262). So, if an existing
    style sheet is not quite right for your purposes, you can always copy the file,
    edit it, and save it as a new style sheet!'
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '6.  True or False: The ability to manipulate spines is an advantage of the
    `pyplot` approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Add the summary title “Martian Goethite, Hematite, and Jarosite Distributions”
    to the display in [Figure 19-14](ch19.xhtml#ch019fig14). Use whichever plotting
    approach you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '8.  Use the following code to produce three datasets for plotting: `np.random.normal(0,
    1, 50).cumsum()`. Generate three subplots in a row and use a `for` loop to populate
    each with a different dataset. Give each subplot a unique title and plot the data
    using black crosses.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Generate a 2D NumPy array of randomized data using `np.random.rand(4, 4)`.
    Then, plot a heatmap using `heat = ax.imshow(data)`. Animate the heatmap using
    a `for` loop and a `range` of 30.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Use the equation `velocity = 9.81 * time` to calculate the speed of a falling
    object. Let the object fall for 15 seconds, and for every second, post its position
    and velocity in a single plot, using a different y-axis for each.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this chapter was to introduce the powerful Matplotlib plotting library
    and (hopefully) address some of its more frustrating aspects. A major source of
    confusion is that there are two main interfaces for making plots; for consistency,
    you should choose one and stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: The `pyplot` approach works with implicit, “currently active,” `Figure` and
    `Axes` objects, in which the `Figure` is a blank canvas, and the `Axes` holds
    plot elements like lines, legends, titles, and so on. To simplify plotting, `pyplot`
    creates these objects behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The `pyplot` approach works well when using Matplotlib interactively and in
    small scripts, but when building larger applications, the object-oriented style
    is preferred. Explicitly assigning `Figure` and `Axes` objects to variables will
    help you keep track of multiple plots and ensure that the code producing them
    is as clear as possible. You’ll also have more control over certain plot elements.
  prefs: []
  type: TYPE_NORMAL
- en: For simpler, more automated plotting than the `pyplot` approach, you can use
    the seaborn package, which is a wrapper around Matplotlib. Additionally, the pandas
    data analysis package wraps Matplotlib for even easier, though less sophisticated,
    plotting. [Chapter 16](ch16.xhtml) included overviews of seaborn and pandas plotting,
    and we’ll look at them again in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For further study and to learn advanced Matplotlib features, check out the tutorials
    and user guide at the official website (*[https://matplotlib.org/](https://matplotlib.org/)*)
    and at Real Python (*[https://realpython.com/python-matplotlib-guide/](https://realpython.com/python-matplotlib-guide/)*).
    You can find useful cheat sheets at *[https://matplotlib.org/cheatsheets/](https://matplotlib.org/cheatsheets/)*.
  prefs: []
  type: TYPE_NORMAL
