- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: BREEDING GIANT RATS WITH GENETIC ALGORITHMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用遗传算法培育超级大老鼠**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: '*Genetic algorithms* are general-purpose optimization programs designed to
    solve complex problems. Invented in the 1970s, they belong to the class of *evolutionary
    algorithms*, so named because they mimic the Darwinian process of natural selection.
    They are especially useful when little is known about a problem, when you’re dealing
    with a nonlinear problem, or when searching for brute-force-type solutions in
    a large search space. Best of all, they are easy algorithms to grasp and implement.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*遗传算法*是通用优化程序，旨在解决复杂问题。它们发明于1970年代，属于*进化算法*类，因为它们模拟了达尔文的自然选择过程。遗传算法特别适用于当问题的背景知识较少时，处理非线性问题时，或在大搜索空间中寻找暴力破解型解决方案时。最棒的是，它们是容易理解和实现的算法。'
- en: In this chapter, you’ll use genetic algorithms to breed a race of super-rats
    that can terrorize the world. After that, you’ll switch sides and help James Bond
    crack a high-tech safe in a matter of seconds. These two projects should give
    you a good appreciation for the mechanics and power of genetic algorithms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用遗传算法培育一群超级大老鼠，让它们横扫世界。之后，你将换个身份，帮助詹姆斯·邦德在几秒钟内破解一个高科技保险箱。这两个项目将让你更好地理解遗传算法的原理和强大功能。
- en: '**Finding the Best of All Possible Solutions**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**找到所有可能解中的最佳解**'
- en: Genetic algorithms *optimize*, which means that they select the best solution
    (with regard to some criteria) from a set of available alternatives. For example,
    if you’re looking for the fastest route to drive from New York to Los Angeles,
    a genetic algorithm will never suggest you fly. It can choose only from within
    an allowed set of conditions that *you* provide. As optimizers, these algorithms
    are faster than traditional methods and can avoid premature convergence to a suboptimal
    answer. In other words, they efficiently search the solution space yet do so thoroughly
    enough to avoid picking a good answer when a better one is available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法通过**优化**，意味着它们从一组可选的替代方案中选择最佳解（根据某些标准）。例如，如果你想找出从纽约到洛杉矶的最快驾驶路线，遗传算法绝不会建议你飞行。它只能从你提供的允许条件中做出选择。作为优化器，这些算法比传统方法更快，并能避免过早收敛到一个次优解。换句话说，它们能高效地搜索解空间，同时又足够彻底，避免在有更好的答案时选出一个较好的答案。
- en: 'Unlike *exhaustive* search engines, which use pure brute force, genetic algorithms
    don’t try every possible solution. Instead, they continuously grade solutions
    and then use them to make “informed guesses” going forward. A simple example is
    the “warmer-colder” game, where you search for a hidden item as someone tells
    you whether you are getting warmer or colder based on your proximity or search
    direction. Genetic algorithms use a fitness function, analogous to natural selection,
    to discard “colder” solutions and build on the “warmer” ones. The basic process
    is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与*穷举*搜索引擎不同，后者依靠纯粹的暴力破解，遗传算法并不会尝试所有可能的解决方案。相反，它们会不断地对解决方案进行评分，然后用这些评分来进行“有根据的猜测”。一个简单的例子是“温暖-寒冷”游戏，在这个游戏中，你寻找一个隐藏物品，有人会告诉你根据你的接近程度或搜索方向你是变得更温暖还是更寒冷。遗传算法使用适应度函数，类似于自然选择，用来丢弃“寒冷”的解，并在“温暖”的解上进行改进。基本过程如下：
- en: Randomly generate a population of solutions.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机生成一个解决方案群体。
- en: Measure the fitness of each solution.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量每个解决方案的适应度。
- en: Select the best (warmest) solutions and discard the rest.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最佳（最温暖的）解决方案，丢弃其他的。
- en: Cross over (recombine) elements in the best solutions to make new solutions.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最佳解决方案中交叉（重组）元素，生成新解决方案。
- en: Mutate a small number of elements in the solutions by changing their value.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过改变其值来突变解决方案中的少数元素。
- en: Return to step 2 and repeat.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回步骤2并重复。
- en: The select–cross over–mutate loop continues until it reaches a *stop condition*,
    like finding a known answer, finding a “good enough” answer (based on a minimum
    threshold), completing a set number of iterations, or reaching a time deadline.
    Because these steps closely resemble the process of evolution, complete with survival
    of the fittest, the terminology used with genetic algorithms is often more biological
    than computational.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择–交叉–变异循环继续进行，直到达到*停止条件*，例如找到已知答案、找到一个“足够好的”答案（根据最低阈值）、完成一定次数的迭代或达到时间限制。因为这些步骤与进化过程非常相似，完全符合“适者生存”的原则，所以在遗传算法中使用的术语往往更具生物学性质，而非计算机科学性质。
- en: '**Project #13: Breeding an Army of Super-Rats**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #13：培育超级大老鼠军团**'
- en: Here’s your chance to be a mad scientist with a secret lab full of boiling beakers,
    bubbling test tubes, and machines that go “BZZZTTT.” So pull on some black rubber
    gloves and get busy turning nimble trash-eating scavengers into massive man-eating
    monsters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你成为疯狂科学家的机会，拥有一个充满沸腾烧瓶、冒泡试管和“BZZZTTT”声响的机器的秘密实验室。所以，戴上黑色橡胶手套，开始将灵活的垃圾食腐 scavenger
    变成巨大的食人怪物吧。
- en: '**THE OBJECTIVE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use a genetic algorithm to simulate breeding rats to an average weight of 110
    pounds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法模拟老鼠繁殖至平均体重110磅。
- en: '***Strategy***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Your dream is to breed a race of rats the size of bullmastiffs (we’ve already
    established that you’re mad). You’ll start with *Rattus norvegicus*, the brown
    rat, then add some artificial sweeteners, some atomic radiation from the 1950s,
    a lot of patience, and a pinch of Python, but no genetic engineering—you’re old-school,
    baby! The rats will grow from less than a pound to a terrifying 110 pounds, about
    the size of a female bullmastiff (see [Figure 7-1](ch07.xhtml#ch07fig1)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你的梦想是繁殖出一种体型和公牛獒犬差不多的老鼠（我们已经确认你疯了）。你将从*Rattus norvegicus*（褐色老鼠）开始，然后加入一些人造甜味剂、1950年代的辐射、足够的耐心和一点Python代码，但绝不做基因工程——你是老派的，宝贝！这些老鼠会从不到一磅长成令人恐惧的110磅，差不多是母公牛獒犬的体型（见[图
    7-1](ch07.xhtml#ch07fig1)）。
- en: '![image](../images/f0127-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0127-01.jpg)'
- en: '*Figure 7-1: Size comparison of a brown rat, a female bullmastiff, and a human*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：褐色老鼠、母公牛獒犬和人类的体型比较*'
- en: Before you embark on such a huge undertaking, it’s prudent to simulate the results
    in Python. And you’ve drawn up something better than a plan—you’ve drawn some
    graphical pseudocode (see [Figure 7-2](ch07.xhtml#ch07fig2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始这样一个巨大的项目之前，最好先在Python中模拟一下结果。而你做的不仅仅是一个计划——你已经绘制了比计划更好的东西——一些图形化的伪代码（见[图
    7-2](ch07.xhtml#ch07fig2)）。
- en: '![image](../images/f0128-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0128-01.jpg)'
- en: '*Figure 7-2: Genetic algorithm approach to breeding super-rats*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：遗传算法在繁殖超级老鼠中的应用*'
- en: The process shown in [Figure 7-2](ch07.xhtml#ch07fig2) outlines how a genetic
    algorithm works. Your goal is to produce a population of rats with an average
    weight of 110 pounds from an initial population weighing much less than that.
    Going forward, each population (or *generation*) of rats represents a candidate
    solution to the problem. Like any animal breeder, you cull undesirable males and
    females, which you humanely send to—for you *Austin Powers* fans—an evil petting
    zoo. You then mate and breed the remaining rats, a process known as *crossover*
    in genetic programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch07fig2)所示的过程概述了遗传算法是如何工作的。你的目标是通过遗传算法从一个体重远低于110磅的初始老鼠种群中，繁殖出一个平均体重为110磅的老鼠种群。之后，每一代（或称*世代*）的老鼠都代表着解决问题的一个候选方案。就像任何动物繁殖者一样，你会淘汰那些不理想的雄性和雌性，并将它们人道地送到——对于你这些*奥斯汀·鲍尔斯*影迷来说——一个邪恶的宠物乐园。然后，你会让剩余的老鼠交配和繁殖，这一过程在遗传编程中被称为*交叉*。'
- en: The offspring of the remaining rats will be essentially the same size as their
    parents, so you need to mutate a few. While mutation is rare and usually results
    in a neutral-to-nonbeneficial trait (low weight, in this case), sometimes you’ll
    successfully produce a bigger rat.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余老鼠的后代将基本与它们的父母体型相同，因此你需要进行一些变异。虽然变异较为罕见，通常会导致中性或无益的特征（在这种情况下是低体重），但有时你会成功地繁殖出更大的老鼠。
- en: The whole process then becomes a big repeating loop, whether done organically
    or programmatically, making me wonder whether we really *are* just virtual beings
    in an alien simulation. At any rate, the end of the loop—the stop condition—is
    when the rats reach the desired size or you just can’t stand dealing with rats
    anymore.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会变成一个大重复循环，无论是有机的还是程序化的，这让我不禁想，是否我们真的是外星人模拟中的虚拟生命。无论如何，循环的终点——停止条件——是当老鼠达到所需的体型，或者你再也忍受不了与老鼠打交道时。
- en: For input to your simulation, you’ll need some statistics. Use the metric system
    since you’re a scientist, mad or not. You already know that the average weight
    of a female bullmastiff is 50,000 grams, and you can find useful rat statistics
    in [Table 7-1](ch07.xhtml#ch07tab1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的模拟输入，你需要一些统计数据。使用公制系统，因为你是个科学家，无论是否疯狂。你已经知道母公牛獒犬的平均体重是50,000克，而有用的老鼠统计数据可以在[表
    7-1](ch07.xhtml#ch07tab1)中找到。
- en: '**Table 7-1:** Brown Rat Weight and Breeding Statistics'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：褐色老鼠的体重与繁殖统计**'
- en: '| **Parameter** | **Published values** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **已发布值** |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Minimum weight | 200 grams |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 最低体重 | 200 克 |'
- en: '| Average weight (female) | 250 grams |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 平均体重（雌性） | 250 克 |'
- en: '| Average weight (male) | 300–350 grams |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 平均体重（雄性） | 300–350 克 |'
- en: '| Maximum weight | 600 grams* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 最大体重 | 600 克* |'
- en: '| Number of pups per litter | 8–12 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 每窝小鼠数量 | 8-12 |'
- en: '| Litters per year | 4–13 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 每年窝数 | 4-13 |'
- en: '| Life span (wild, captivity) | 1–3 years, 4–6 years |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 寿命（野生，圈养） | 1-3年，4-6年 |'
- en: '| *Exceptional individuals may reach 1,000 grams in captivity. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| *在圈养条件下，特殊个体可能达到 1,000 克。 |'
- en: Because both domestic and wild brown rats exist, there may be wide variation
    in some of the stats. Rats in captivity tend to be better cared for than wild
    rats, so they weigh more, breed more, and have more pups. So you can choose from
    the higher end when a range is available. For this project, start with the assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于家鼠和野生棕色大鼠都存在，因此某些统计数据可能会有较大的差异。圈养大鼠通常得到比野生大鼠更好的照料，因此它们体重大、繁殖多、窝数也多。所以当有范围选择时，可以选择较高的值。对于这个项目，参考[表7-2](ch07.xhtml#ch07tab2)中的假设开始。
- en: '**Table 7-2:** Input Assumptions for the Super-Rats Genetic Algorithm'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 超级大鼠遗传算法的输入假设'
- en: '| **Variable and value** | **Comments** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **变量和数值** | **注释** |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GOAL = 50000 | Target weight in grams (female bullmastiff) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| GOAL = 50000 | 目标体重（雌性牛头犬，单位：克） |'
- en: '| NUM_RATS = 20 | Total number of *adult* rats your lab can support |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| NUM_RATS = 20 | 实验室可支持的成鼠总数 |'
- en: '| INITIAL_MIN_WT = 200 | Minimum weight of adult rat, in grams, in initial
    population |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| INITIAL_MIN_WT = 200 | 初始种群中成鼠的最小体重（单位：克） |'
- en: '| INITIAL_MAX_WT = 600 | Maximum weight of adult rat, in grams, in initial
    population |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| INITIAL_MAX_WT = 600 | 初始种群中成鼠的最大体重（单位：克） |'
- en: '| INITIAL_MODE_WT = 300 | Most common adult rat weight, in grams, in initial
    population |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| INITIAL_MODE_WT = 300 | 初始种群中最常见的成鼠体重（单位：克） |'
- en: '| MUTATE_ODDS = 0.01 | Probability of a mutation occurring in a rat |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| MUTATE_ODDS = 0.01 | 大鼠发生突变的概率 |'
- en: '| MUTATE_MIN = 0.5 | Scalar on rat weight of least beneficial mutation |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| MUTATE_MIN = 0.5 | 对大鼠体重的最小变异因子 |'
- en: '| MUTATE_MAX = 1.2 | Scalar on rat weight of most beneficial mutation |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| MUTATE_MAX = 1.2 | 对大鼠体重的最大变异因子 |'
- en: '| LITTER_SIZE = 8 | Number of pups per pair of mating rats |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| LITTER_SIZE = 8 | 每对交配大鼠每窝的小鼠数量 |'
- en: '| LITTERS_PER_YEAR = 10 | Number of litters per year per pair of mating rats
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| LITTERS_PER_YEAR = 10 | 每对交配大鼠每年的窝数 |'
- en: '| GENERATION_LIMIT = 500 | Generational cutoff to stop breeding program |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| GENERATION_LIMIT = 500 | 停止繁殖程序的代数上限 |'
- en: Since rats breed so frequently, you shouldn’t have to factor in life span. Even
    though you will retain some of the parents from a previous generation, they will
    be culled out quickly as their offspring increase in weight from generation to
    generation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大鼠繁殖频繁，因此不需要考虑寿命。即使你保留上一代的一些父母，它们会随着后代体重的增加而很快被淘汰。
- en: '***The Super-Rats Code***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***超级大鼠代码***'
- en: The *super_rats.py* code follows the general workflow in [Figure 7-2](ch07.xhtml#ch07fig2).
    You can also download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py* 代码遵循[图7-2](ch07.xhtml#ch07fig2)中的一般工作流程。你也可以从* [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载代码。'
- en: '**Entering the Data and Assumptions**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输入数据和假设**'
- en: '[Listing 7-1](ch07.xhtml#ch07list1), in the global space at the start of the
    program, imports modules and assigns the statistics, scalars, and assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2) as constants. Once the program is complete
    and working, feel free to experiment with the values in that table and see how
    they affect your results.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-1](ch07.xhtml#ch07list1)，在程序开始时的全局空间中，导入模块并将[表7-2](ch07.xhtml#ch07tab2)中的统计信息、标量和假设分配为常量。程序完成并正常工作后，可以尝试更改该表中的数值，并观察它们如何影响结果。'
- en: '*super_rats.py,* part 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第1部分'
- en: ➊ import time
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import time
- en: import random
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: import statistics
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: import statistics
- en: '➋ # CONSTANTS (weights in grams)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ # 常量（单位：克）'
- en: ➌ GOAL = 50000
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ GOAL = 50000
- en: NUM_RATS = 20
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: NUM_RATS = 20
- en: INITIAL_MIN_WT = 200
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: INITIAL_MIN_WT = 200
- en: INITIAL_MAX_WT = 600
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: INITIAL_MAX_WT = 600
- en: INITIAL_MODE_WT = 300
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: INITIAL_MODE_WT = 300
- en: MUTATE_ODDS = 0.01
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: MUTATE_ODDS = 0.01
- en: MUTATE_MIN = 0.5
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MUTATE_MIN = 0.5
- en: MUTATE_MAX = 1.2
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MUTATE_MAX = 1.2
- en: LITTER_SIZE = 8
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: LITTER_SIZE = 8
- en: LITTERS_PER_YEAR = 10
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: LITTERS_PER_YEAR = 10
- en: GENERATION_LIMIT = 500
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: GENERATION_LIMIT = 500
- en: '# ensure even-number of rats for breeding pairs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '# 确保繁殖对的数量为偶数：'
- en: '➍ if NUM_RATS % 2 != 0:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ 如果 NUM_RATS % 2 != 0:'
- en: NUM_RATS += 1
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: NUM_RATS += 1
- en: '*Listing 7-1: Imports modules and assigns constants*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：导入模块并分配常量*'
- en: Start by importing the time, random, and statistics modules ➊. You’ll use the
    time module to record the runtime of your genetic algorithm. It’s interesting
    to time genetic algorithms, if only to be awed by how quickly they can find a
    solution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入时间、随机和统计模块 ➊。你将使用时间模块记录你的遗传算法的运行时间。对遗传算法进行计时很有意思，哪怕只是为了惊叹它们能多快找到解决方案。
- en: The random module will satisfy the stochastic needs of the algorithm, and you’ll
    use the statistics module to get mean values. This is a weak use for statistics,
    but I want you to be aware of the module, since it can be quite handy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随机模块将满足算法的随机需求，你将使用统计模块来获取均值。这是统计学的一个简单用法，但我希望你了解这个模块，因为它非常实用。
- en: Next, assign the input variables described in [Table 7-2](ch07.xhtml#ch07tab2)
    and be sure to note that the units are grams ➋. Use uppercase letters for the
    names, as these represent constants ➌.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配[表7-2](ch07.xhtml#ch07tab2)中描述的输入变量，并确保注意单位是克 ➋。使用大写字母作为变量名，因为这些表示常量 ➌。
- en: Right now, we’re going to assume the use of breeding *pairs*, so check that
    the user input an even number of rats and, if not, add a rat ➍. Later, in “[Challenge
    Projects](ch07.xhtml#lev167)” on [page 144](ch07.xhtml#page_144), you’ll get to
    experiment with alternative gender distributions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们假设使用繁殖的*配对*，所以检查用户输入的老鼠数量是否为偶数，如果不是，则添加一只老鼠 ➍。稍后，在“[挑战项目](ch07.xhtml#lev167)”中的[第144页](ch07.xhtml#page_144)，你将可以尝试不同性别分布的实验。
- en: '**Initializing the Population**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化种群**'
- en: '[Listing 7-2](ch07.xhtml#ch07list2) is the program’s shopping representative.
    It goes to a pet shop and picks out the rats for an initial breeding population.
    Since you want mating pairs, it should choose an even number of rats. And since
    you can’t afford one of those fancy volcano lairs with unlimited space, you’ll
    need to maintain a constant number of adult rats through each generation—though
    the number can swell temporarily to accommodate litters. Remember, the rats will
    need more and more space as they grow to the size of big dogs!'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7-2](ch07.xhtml#ch07list2)是程序的“购物代表”。它去宠物店挑选老鼠，作为初始繁殖种群。因为你需要配对交配，所以它应该选择偶数数量的老鼠。并且由于你不能负担一个空间无限大的火山巢穴，你需要在每一代之间维持恒定数量的成年老鼠——尽管数量可以暂时增加，以容纳一窝窝仔。记住，随着它们长大到像大狗一样大，老鼠需要越来越多的空间！'
- en: '*super_rats.py,* part 2'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第2部分'
- en: '➊ def populate(num_rats, min_wt, max_wt, mode_wt):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def populate(num_rats, min_wt, max_wt, mode_wt):'
- en: '"""Initialize a population with a triangular distribution of weights."""'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用三角分布初始化体重的种群。"""'
- en: ➋ return [int(random.triangular(min_wt, max_wt, mode_wt))\
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ return [int(random.triangular(min_wt, max_wt, mode_wt))\
- en: for i in range(num_rats)]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: for i in range(num_rats)]
- en: '*Listing 7-2: Defines the function that creates the initial rat population*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-2：定义了创建初始老鼠种群的函数*'
- en: The populate() function needs to know the amount of adult rats you want, the
    minimum and maximum weights for the rats, and the most commonly occurring weight
    ➊. Note that all of these arguments will use constants found in the global space.
    You don’t have to pass these as arguments for the function to access them. But
    I do so here and in the functions that follow, for clarity and because local variables
    are accessed more efficiently.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: populate()函数需要知道你想要的成年老鼠数量、老鼠的最小体重和最大体重，以及最常见的体重 ➊。请注意，这些参数将使用在全局空间中找到的常量。你不需要将它们作为参数传递给函数以便访问。但我在这里和后面的函数中这样做了，以便于理解，并且局部变量的访问效率更高。
- en: You’ll use the four arguments above with the random module, which includes different
    types of distributions. You’ll use a triangular distribution here, because it
    gives you firm control of the minimum and maximum sizes and lets you model skewness
    in the statistics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用上述四个参数与随机模块，这些参数包括不同类型的分布。在这里你会使用三角分布，因为它能让你很好地控制最小值和最大值，并能在统计中模拟偏斜。
- en: Because brown rats exist both in the wild and in captivity—in zoos, labs, and
    as pets—their weights are skewed to the high side. Wild rats tend to be smaller
    as their lives are nasty, brutish, and short, though lab rats may contest that
    point! Use list comprehension to loop through the number of rats and assign each
    one a weight. Bundle it all together with the return statement ➋.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于棕色老鼠既存在于野外，也存在于圈养环境中——如动物园、实验室以及作为宠物——它们的体重大多偏高。野生老鼠通常较小，因为它们的生活环境恶劣且寿命短，尽管实验室里的老鼠可能会对此提出异议！使用列表推导式来遍历老鼠数量，并为每只老鼠分配一个体重。将这一切通过返回语句打包在一起
    ➋。
- en: '**Measuring the Fitness of the Population**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**衡量种群的适应度**'
- en: Measuring the fitness of the rats is a two-step process. First, grade the whole
    population by comparing the average weight of all the rats to the bullmastiff
    target. Then, grade each individual rat. Only rats whose weight ranks in the upper
    *n* percent, as determined by the NUM_RATS variable, get to breed again. Although
    the average weight of the population is a valid fitness measurement, its primary
    role here is to determine whether it’s time to stop looping and declare success.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测量老鼠的适应度是一个两步过程。首先，通过将所有老鼠的平均体重与公牛獒犬的目标体重进行比较，对整个种群进行评分。然后，单独对每只老鼠进行评分。只有体重排在前*n*百分比的老鼠，按照NUM_RATS变量确定，才能再次繁殖。虽然种群的平均体重是一个有效的适应度测量，但它在这里的主要作用是确定是否该停止循环并宣布成功。
- en: '[Listing 7-3](ch07.xhtml#ch07list3) defines the fitness() and select() functions,
    which together form the measurement portion of your genetic algorithm.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-3](ch07.xhtml#ch07list3)定义了fitness()和select()函数，它们一起构成了遗传算法中的测量部分。'
- en: '*super_rats.py,* part 3'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第3部分'
- en: '➊ def fitness(population, goal):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def fitness(population, goal):'
- en: '"""Measure population fitness based on an attribute mean vs target."""'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '"""根据属性均值与目标进行种群适应度测量。"""'
- en: ave = statistics.mean(population)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ave = statistics.mean(population)
- en: return ave / goal
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: return ave / goal
- en: '➋ def select(population, to_retain):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def select(population, to_retain):'
- en: '"""Cull a population to retain only a specified number of members."""'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"""筛选种群，仅保留指定数量的成员。"""'
- en: ➌ sorted_population = sorted(population)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ sorted_population = sorted(population)
- en: ➍ to_retain_by_sex = to_retain//2
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ to_retain_by_sex = to_retain//2
- en: ➎ members_per_sex = len(sorted_population)//2
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ members_per_sex = len(sorted_population)//2
- en: ➏ females = sorted_population[:members_per_sex]
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ females = sorted_population[:members_per_sex]
- en: males = sorted_population[members_per_sex:]
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: males = sorted_population[members_per_sex:]
- en: ➐ selected_females = females[-to_retain_by_sex:]
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ selected_females = females[-to_retain_by_sex:]
- en: selected_males = males[-to_retain_by_sex:]
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: selected_males = males[-to_retain_by_sex:]
- en: ➑ return selected_males, selected_females
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ return selected_males, selected_females
- en: '*Listing 7-3: Defines the measurement step of the genetic algorithm*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：定义了遗传算法的测量步骤*'
- en: Define a function to grade the fitness of the current generation ➊. Use the
    statistics module to get the mean of the population and return this value divided
    by the target weight. When this value is equal to or greater than 1, you’ll know
    it’s time to stop breeding.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数来评估当前代的适应度➊。使用statistics模块获取种群的均值，并返回该值除以目标体重。当该值大于或等于1时，你就知道该停止繁殖了。
- en: Next, define a function that culls a population of rats, based on weight, down
    to the NUM_RATS value, represented here by the to_retain parameter ➋. It will
    also take a population argument, which will be the parents of each generation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数，该函数根据体重将老鼠种群筛选，直到达到NUM_RATS的数量，这里由to_retain参数➋表示。该函数还将接受一个种群参数，该参数代表每一代的父母。
- en: Now, sort the population so you can distinguish large from small ➌. Take the
    number of rats you want to retain and divide it by 2 using floor division so that
    the result is an integer ➍. Do this step so you can keep the biggest male and
    female rats. If you choose only the largest rats in the population, you will theoretically
    be choosing only males. You obtain the total members of the current population,
    by sex, by dividing the sorted_population by 2, again using floor division ➎.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对种群进行排序，这样你就可以区分大个和小个的老鼠➌。然后，取你想保留的老鼠数量，并用整除法将其除以2，使结果为整数➍。这样做是为了保留最大的雄性和雌性老鼠。如果你只选择种群中最大的一些老鼠，理论上你只会选择雄性老鼠。你可以通过将sorted_population除以2，再次使用整除法来获得当前种群按性别划分的总成员数➎。
- en: 'Male rats tend to be larger than females, so make two simplifying assumptions:
    first, assume that exactly half of the population is female and, second, that
    the largest female rat is no heavier than the smallest male rat. This means that
    the first half of the sorted population list represents females and the last half
    represents males. Then create two new lists by splitting sorted_population in
    half, taking the bottom half for females ➏ and the upper half for males. Now all
    that’s left to do is take the biggest rats from the end of each of these lists
    ➐—using negative slicing—and return them ➑. These two lists contain the parents
    of the next generation.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 雄性老鼠通常比雌性老鼠大，因此做两个简化假设：首先，假设种群中恰好一半是雌性；其次，假设最大雌性老鼠的体重不超过最小雄性老鼠的体重。这意味着，排序后的种群列表的前一半代表雌性，后一半代表雄性。然后，通过将sorted_population分成两半，分别取下半部分作为雌性老鼠➏，上半部分作为雄性老鼠，创建两个新的列表。接下来要做的就是从这两个列表的末尾取出最大的老鼠➐——使用负切片——并返回它们➑。这两个列表包含下一代的父母。
- en: The first time you run this function, all it will do is sort the rats by sex,
    as the initial number of rats already equals the NUM_RATS constant. After that,
    the incoming population argument will include both parents and children, and its
    value will exceed NUM_RATS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行这个函数时，它做的只是按性别对老鼠进行排序，因为初始的老鼠数量已经等于NUM_RATS常量。之后，传入的种群参数将包括父母和子代，它的值将超过NUM_RATS。
- en: '**Breeding a New Generation**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**繁殖新一代**'
- en: '[Listing 7-4](ch07.xhtml#ch07list4) defines the program’s “crossover” step,
    which means it breeds the next generation. A key assumption is that the weight
    of every child will be greater than or equal to the weight of the mother and less
    than or equal to the weight of the father. Exceptions to that rule will be handled
    in the “mutation” function.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出 7-4](ch07.xhtml#ch07list4)定义了程序的“交叉”步骤，这意味着它繁殖了下一代。一个关键假设是每个子代的体重将大于或等于母鼠的体重，并且小于或等于父鼠的体重。违反此规则的情况将在“突变”函数中处理。'
- en: '*super_rats.py,* part 4'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第4部分'
- en: '➊ def breed(males, females, litter_size):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def breed(males, females, litter_size):'
- en: '"""Crossover genes among members (weights) of a population."""'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在群体成员（体重）之间交叉基因。"""'
- en: ➋ random.shuffle(males)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ random.shuffle(males)
- en: random.shuffle(females)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: random.shuffle(females)
- en: ➌ children = []
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ children = []
- en: '➍ for male, female in zip(males, females):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for male, female in zip(males, females):'
- en: '➎ for child in range(litter_size):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for child in range(litter_size):'
- en: ➏ child = random.randint(female, male)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ child = random.randint(female, male)
- en: ➐ children.append(child)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ children.append(child)
- en: ➑ return children
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ return children
- en: '*Listing 7-4: Defines the function that breeds a new generation of rats*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 7-4：定义了一个繁殖新一代老鼠的函数*'
- en: The breed() function takes as arguments the lists of weights of selected males
    and females returned from the select() function along with the size of a litter
    ➊. Next, randomly shuffle the two lists ➋, because you sorted them in the select()
    function and iterating over them without shuffling would result in the smallest
    male being paired with the smallest female, and so on. You need to allow for love
    and romance; the largest male may be drawn to the most petite female!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: breed()函数的参数是通过select()函数返回的雄鼠和雌鼠的体重列表，以及窝重的大小 ➊。接下来，随机打乱这两个列表 ➋，因为你已经在select()函数中对它们进行了排序，不打乱它们就直接迭代会导致最小的雄鼠和最小的雌鼠配对，依此类推。你需要考虑到爱情与浪漫；最大的雄鼠可能会被最娇小的雌鼠吸引！
- en: Start an empty list to hold their children ➌. Now for the hanky-panky. Go through
    the shuffled lists using zip() to pair a male and female from each list ➍. Each
    pair of rats can have multiple children, so start another loop that uses the litter
    size as a range ➎. The litter size is a constant, called LITTER_SIZE, that you
    provided in the input parameters, so if the value is 8, you’ll get eight children.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表来保存它们的子代 ➌。现在进入难度较高的部分。使用zip()函数遍历打乱后的列表，将每对雄性和雌性配对 ➍。每对老鼠可以有多个子代，因此开始另一个循环，使用窝重作为范围
    ➎。窝重是一个常量，名为LITTER_SIZE，是你在输入参数中提供的，因此如果该值为8，你将得到八只小鼠。
- en: For each child, choose a weight at random between the mother’s and father’s
    weights ➏. Note that you don’t need to use male + 1, because randint() uses *all*
    the numbers in the supplied range. Note also that the two values can be the same,
    but the first value (the mother’s weight) can never be larger than the second
    (the father’s weight). This is another reason for the simplifying assumption that
    females must be no larger than the smallest male. End the loop by appending each
    child to the list of children ➐, then return children ➑.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个子代，随机选择一个体重，介于母鼠和父鼠的体重之间 ➏。请注意，你不需要使用male + 1，因为randint()会使用所提供范围内的*所有*数字。还需要注意，两个值可以相同，但第一个值（母鼠的体重）永远不能大于第二个值（父鼠的体重）。这也是假设雌鼠体型不大于最小雄鼠的简化假设的另一个原因。结束循环时，将每个子代附加到子代列表中
    ➐，然后返回子代 ➑。
- en: '**Mutating the Population**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**突变种群**'
- en: A small percentage of the children should experience mutations, and most of
    these should result in traits that are nonbeneficial. That means lower-than-expected
    weights, including “runts” that would not survive. But every so often, a beneficial
    mutation will result in a heavier rat.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一小部分子代应经历突变，其中大多数突变会导致不利的特征。这意味着体重低于预期，包括“弱鼠”，这些鼠无法生存。但偶尔，某些有益的突变会导致较重的老鼠。
- en: '[Listing 7-5](ch07.xhtml#ch07list5) defines the mutate() function, which applies
    the mutation assumptions you supplied in the list of constants. After mutate()
    is called, it will be time to check the fitness of the new population and start
    the loop over if the target weight hasn’t been reached.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 7-5](ch07.xhtml#ch07list5) 定义了 mutate() 函数，该函数应用了你在常量列表中提供的突变假设。在调用
    mutate() 之后，如果目标体重尚未达到，就需要检查新种群的适应度，并重新开始循环。'
- en: '*super_rats.py,* part 5'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第5部分'
- en: '➊ def mutate(children, mutate_odds, mutate_min, mutate_max):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def mutate(children, mutate_odds, mutate_min, mutate_max):'
- en: '"""Randomly alter rat weights using input odds & fractional changes."""'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用输入的几率和变化范围随机改变老鼠体重。"""'
- en: '➋ for index, rat in enumerate(children):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for index, rat in enumerate(children):'
- en: 'if mutate_odds >= random.random():'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 mutate_odds 大于或等于随机生成的数字，那么该索引处的老鼠（体重）就会发生突变。从最小和最大突变值定义的均匀分布中选择一个突变值；这基本上是从最小值和最大值范围中随机选择一个值。由于这些值偏向最小值，结果更有可能是体重减少而非增加。将当前体重乘以这个突变标量，并将结果四舍五入为整数
    ➌。最后返回突变后的子代列表。
- en: ➌ children[index] = round(rat * random.uniform(mutate_min,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ children[index] = round(rat * random.uniform(mutate_min,
- en: mutate_max))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: mutate_max))
- en: return children
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: return children
- en: '*Listing 7-5: Defines the function that mutates a small portion of the population*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-5：定义了突变部分种群的函数*'
- en: The function needs the list of children, the odds of a mutation occurring, and
    the minimum and maximum impacts of a mutation ➊. The impacts are scalars that
    you’ll apply to the weight of a rat. In your list of constants at the start of
    the program (and in [Table 7-2](ch07.xhtml#ch07tab2)), they are skewed to the
    minimum side, as most mutations do not result in beneficial traits.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要子代列表、突变发生的几率，以及突变的最小和最大影响 ➊。这些影响是标量，你将应用于老鼠的体重。在程序开始时的常量列表中（以及[表7-2](ch07.xhtml#ch07tab2)），它们偏向于最小值，因为大多数突变不会带来有益的特征。
- en: Loop through the list of children and use enumerate()—a handy built-in function
    that acts as an automatic counter—to get an index ➋. Then use the random() method
    to generate a random number between 0 and 1 and compare it to the odds of a mutation
    occurring.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历子代列表，使用 enumerate() —— 一个方便的内置函数，充当自动计数器 —— 来获取索引 ➋。然后使用 random() 方法生成一个介于
    0 和 1 之间的随机数，并与突变发生的几率进行比较。
- en: If the mutate_odds variable is greater than or equal to the randomly generated
    number, the rat (weight) at that index is mutated. Choose a mutation value from
    a uniform distribution defined by the minimum and maximum mutation values; this
    basically selects a value at random from the min-max range. As these values are
    skewed to the minimum, the outcome is more likely to be a loss in weight than
    a gain. Multiply the current weight by this mutation scalar and round it to an
    integer ➌. Finish by returning the mutated children list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 mutate_odds 变量大于或等于随机生成的数字，则该索引处的老鼠（体重）会发生突变。从最小和最大突变值定义的均匀分布中选择一个突变值；这基本上是从最小值和最大值范围中随机选择一个值。由于这些值偏向最小值，结果更可能是体重减少而非增加。将当前体重乘以这个突变标量，并四舍五入为整数
    ➌。最后返回突变后的子代列表。
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With regard to the validity of mutation statistics, you can find studies that
    suggest beneficial mutations are very rare and others that suggest they are more
    common than we realize. The breeding of dogs has shown that achieving drastic
    variations in size (for example, Chihuahuas vs. Great Danes) doesn’t require millions
    of years of evolution. In a famous 20th-century study, Russian geneticist Dmitry
    Belyayev started with 130 silver foxes and, over a 40-year period, succeeded in
    achieving dramatic physiological changes by simply selecting the tamest foxes
    in each generation.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于突变统计的有效性，你可以找到一些研究表明有益突变非常罕见，也有研究表明它们比我们想象的更常见。狗的繁育表明，实现体型的巨大变化（例如，吉娃娃与大丹犬）并不需要数百万年的进化。在20世纪的一项著名研究中，俄罗斯遗传学家德米特里·别利亚耶夫从130只银狐开始，通过40年的时间，通过简单地选择每代最温顺的狐狸，成功实现了显著的生理变化。*'
- en: '**Defining the main() Function**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 7-6](ch07.xhtml#ch07list6) defines the main() function, which manages
    the other functions and determines when you’ve met the stop condition. It will
    also display all the important results.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 7-6](ch07.xhtml#ch07list6) 定义了 main() 函数，该函数管理其他函数并确定何时满足停止条件。它还将显示所有重要结果。'
- en: '*super_rats.py,* part 6'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第6部分'
- en: 'def main():'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Initialize population, select, breed, and mutate, display results."""'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化种群，选择，繁殖和突变，显示结果。"""'
- en: ➊ generations = 0
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ generations = 0
- en: ➋ parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,
- en: INITIAL_MODE_WT)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: INITIAL_MODE_WT)
- en: print("initial population weights = {}".format(parents))
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: print("初始种群体重 = {}".format(parents))
- en: popl_fitness = fitness(parents, GOAL)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: popl_fitness = fitness(parents, GOAL)
- en: print("initial population fitness = {}".format(popl_fitness))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: print("initial population fitness = {}".format(popl_fitness))
- en: print("number to retain = {}".format(NUM_RATS))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: print("number to retain = {}".format(NUM_RATS))
- en: ➌ ave_wt = []
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ ave_wt = []
- en: '➍ while popl_fitness < 1 and generations < GENERATION_LIMIT:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ while popl_fitness < 1 and generations < GENERATION_LIMIT:'
- en: selected_males, selected_females = select(parents, NUM_RATS)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: selected_males, selected_females = select(parents, NUM_RATS)
- en: children = breed(selected_males, selected_females, LITTER_SIZE)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: children = breed(selected_males, selected_females, LITTER_SIZE)
- en: children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)
- en: ➎ parents = selected_males + selected_females + children
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ parents = selected_males + selected_females + children
- en: popl_fitness = fitness(parents, GOAL)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: popl_fitness = fitness(parents, GOAL)
- en: ➏ print("Generation {} fitness = {:.4f}".format(generations,
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ print("Generation {} fitness = {:.4f}".format(generations,
- en: popl_fitness))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: popl_fitness))
- en: ➐ ave_wt.append(int(statistics.mean(parents)))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ ave_wt.append(int(statistics.mean(parents)))
- en: generations += 1
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: generations += 1
- en: ➑ print("average weight per generation = {}".format(ave_wt))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ print("average weight per generation = {}".format(ave_wt))
- en: print("\nnumber of generations = {}".format(generations))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: print("\nnumber of generations = {}".format(generations))
- en: print("number of years = {}".format(int(generations / LITTERS_PER_YEAR)))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print("number of years = {}".format(int(generations / LITTERS_PER_YEAR)))
- en: '*Listing 7-6: Defines the* main() *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-6：定义了* main() *函数*'
- en: Start the function by initializing an empty list to hold the number of generations.
    You’ll eventually use this to figure out how many years it took to achieve your
    goal ➊.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过初始化一个空列表来启动函数，用于保存代数。你最终将使用这个列表来计算实现目标所需的年数 ➊。
- en: Next, call the populate() function ➋ and immediately print the results. Then,
    get the fitness of your initial population and print this along with the number
    of rats to retain each generation, which is the NUM_RATS constant.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`populate()`函数➋并立即打印结果。然后，获取初始种群的适应度，并将其与每代保留的老鼠数量一起打印，这个数量是`NUM_RATS`常量。
- en: For fun, initialize a list to hold the average weight of each generation so
    you can view it at the end ➌. If you plot these weights against the number of
    years, you’ll see that the trend is exponential.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，初始化一个列表来保存每代的平均体重，这样你可以在最后查看它 ➌。如果你将这些体重与年数进行绘图，你会看到它们呈指数增长趋势。
- en: Now, start the big genetic loop of select-mate-mutate. This is in the form of
    a while loop, with the stop conditions being either reaching the target weight
    or reaching a large number of generations without achieving the target weight
    ➍. Note that after mutating the children, you need to combine them with their
    parents to make a new parents list ➎. It takes the pups about five weeks to mature
    and start breeding, but you can account for this by adjusting the LITTERS_PER_YEAR
    constant down from the maximum possible value (see [Table 7-1](ch07.xhtml#ch07tab1)),
    as we’ve done here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始大的遗传循环，进行选择-配对-突变。这以`while`循环的形式出现，停止条件是达到目标体重或在没有达到目标体重的情况下经过了大量代数 ➍。请注意，在突变孩子们之后，需要将它们与父母结合，形成新的父母列表
    ➎。小鼠大约需要五周才能成熟并开始繁殖，但你可以通过将`LITTERS_PER_YEAR`常量从最大可能值调整下来（见[表7-1](ch07.xhtml#ch07tab1)），就像我们在这里做的一样，来考虑这一点。
- en: At the end of each loop, display the results of the fitness() function to four
    decimal places so you can monitor the algorithm and ensure it is progressing as
    expected ➏. Get the average weight of the generation, append it to the ave_wt
    list ➐, and then advance the generation count by 1.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环结束时，显示`fitness()`函数的结果，保留四位小数，以便你可以监控算法并确保它按预期进行 ➏。获取该代的平均体重，将其添加到`ave_wt`列表中
    ➐，然后将代数计数加1。
- en: Complete the main() function by displaying the list of average weights per generation,
    the number of generations, and the number of years—calculated using the LITTERS_PER_YEAR
    variable ➑.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完成main()函数，显示每代的平均体重列表、代数和年数——通过`LITTERS_PER_YEAR`变量计算得出 ➑。
- en: Running the main() Function
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行main()函数
- en: Finish up with the familiar conditional statement for running the program either
    stand-alone or as a module. Get the ending time and print how long it took the
    program to run. The performance information should print only when the module
    is run in stand-alone mode, so be sure to place it under the if clause. See [Listing
    7-7](ch07.xhtml#ch07list7).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用熟悉的条件语句来运行程序，无论是独立运行还是作为模块运行。获取结束时间并打印程序运行所花费的时间。性能信息仅应在模块以独立模式运行时打印，因此务必将其放在`if`语句块内。参见[清单7-7](ch07.xhtml#ch07list7)。
- en: '*super_rats.py,* part 7'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py*，第7部分'
- en: 'if __name__ == ''__main__'':'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: start_time = time.time()
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: main()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: end_time = time.time()
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: end_time = time.time()
- en: duration = end_time - start_time
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: duration = end_time - start_time
- en: print("\nRuntime for this program was {} seconds.".format(duration))
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n此程序的运行时间为 {} 秒。".format(duration))
- en: '*Listing 7-7: Runs the* main() *function and* time *module if the program isn’t
    imported*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-7：如果程序未被导入，则运行* main() *函数和* time *模块*'
- en: '***Summary***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: With the parameters in [Table 7-2](ch07.xhtml#ch07tab2), the *super_rats.py*
    program will take about two seconds to run. On average, it will take the rats
    about 345 generations, or 34.5 years, to reach the target weight of 110 pounds.
    That’s a long time for a mad scientist to stay mad! But armed with your program,
    you can look for ways to reduce the time to target.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表 7-2](ch07.xhtml#ch07tab2)中的参数，*super_rats.py* 程序大约需要两秒钟运行。平均来说，老鼠们大约需要
    345 代，或者 34.5 年，才能达到 110 磅的目标体重。对一个疯狂的科学家来说，这样的时间实在太长了！不过，借助你的程序，你可以寻找减少目标达成时间的方法。
- en: '*Sensitivity studies* work by making multiple changes to a *single* variable
    and judging the results. You should take care in the event some variables are
    dependent on one another. And since the results are stochastic (random), you should
    make multiple runs with each parameter change in order to capture the range of
    possible outcomes.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*敏感性研究*通过对*单个*变量进行多次更改并评估结果来工作。你应该小心，如果一些变量彼此依赖的话。由于结果是随机的（stochastic），你应该在每个参数更改时进行多次运行，以便捕捉可能的结果范围。'
- en: Two things you can control in your breeding program are the number of breeding
    rats (NUM_RATS) and the odds of a mutation occurring (MUTATE_ODDS). The mutation
    odds are influenced by factors like diet and exposure to radiation. If you change
    these variables one at a time and rerun *super_rats.py*, you can judge the impact
    of each variable on the project timeline.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的繁殖计划中，你可以控制的两个因素是繁殖老鼠的数量（NUM_RATS）和突变发生的概率（MUTATE_ODDS）。突变概率受到饮食和辐射暴露等因素的影响。如果你逐一更改这些变量并重新运行
    *super_rats.py*，你就可以评估每个变量对项目时间表的影响。
- en: An immediate observation is that, if you start with small values for each variable
    and slowly increase them, you get dramatic initial results (see [Figure 7-3](ch07.xhtml#ch07fig3)).
    After that, both curves decline rapidly and flatten out in a classic example of
    diminishing returns. The point where each curve flattens is the key to optimally
    saving money and reducing work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接的观察是，如果你从每个变量的小值开始，并逐渐增加它们，你会看到初期有显著的效果（参见[图 7-3](ch07.xhtml#ch07fig3)）。之后，两个曲线会迅速下降并趋于平坦，典型的递减回报现象。每个曲线变平的点是优化节省资金和减少工作量的关键。
- en: For example, you get very little benefit from retaining more than about 300
    rats. You’d just be feeding and caring for a lot of superfluous rats. Likewise,
    trying to boost the odds of a mutation above 0.3 gains you little.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，保留超过 300 只老鼠几乎不会带来太大好处。你只是在喂养和照顾大量不必要的老鼠。同样，将突变概率提高到 0.3 以上也几乎没有收益。
- en: With charts like these, it’s easy to plan a path forward. The horizontal dotted
    line marked “Baseline” represents the average result of using the input in [Table
    7-2](ch07.xhtml#ch07tab2). You can potentially reduce this time by over 10 years
    just by retaining 50 rats rather than 20\. You should also focus on increasing
    the number of beneficial mutations. This will be more rewarding, but riskier and
    harder to control.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的图表让你轻松规划前进的道路。标记为“基线”的水平虚线表示使用[表 7-2](ch07.xhtml#ch07tab2)中输入的平均结果。你可以通过保留
    50 只老鼠而不是 20 只，潜在地将时间缩短超过 10 年。你还应该专注于增加有益突变的数量。这样会更有回报，但也更具风险且更难控制。
- en: '![image](../images/f0137-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0137-01.jpg)'
- en: '*Figure 7-3: Impact of two parameters on the time required to reach the target
    weight*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：两个参数对达到目标体重所需时间的影响*'
- en: If you rerun the simulation using 50 rats and bumping the odds of mutation up
    to 0.05, you can theoretically complete the project in 14 years, an improvement
    of 246 percent over the initial baseline. Now *that’s* optimization!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 50 只老鼠并将突变概率提高到 0.05 重新运行模拟，理论上你可以在 14 年内完成项目，相比初始基线提高了 246%。现在，*这才是*优化！
- en: Breeding super-rats was a fun and simple way to understand the basics of genetic
    algorithms. But to truly appreciate their power, you need to attempt something
    harder. You need a brute-force problem that’s too big to brute-force, and the
    next project is that kind of problem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 繁殖超级老鼠是理解遗传算法基本原理的一个有趣且简单的方法。但要真正理解它们的强大，你需要尝试一些更难的挑战。你需要一个无法通过蛮力解决的问题，接下来的项目正是这样的难题。
- en: '**Project #14: Cracking a High-Tech Safe**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #14：破解高科技保险箱**'
- en: 'You are Q, and James Bond has a problem. He has to attend an elegant dinner
    party at a villain’s mansion, slip away to the man’s private office, and crack
    his wall safe. Child’s play for 007, except for one thing: it’s a Humperdink BR549
    digital safe that takes 10 digits, yielding 10 billion possible combinations.
    And the lock wheels don’t start turning until *after* all the numbers have been
    entered. There’ll be no putting a stethoscope to this safe and slowly turning
    a dial!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你是 Q，詹姆斯·邦德有一个问题。他必须参加一个邪恶反派家族的优雅晚宴，偷偷溜进男子的私人办公室，破解他的墙壁保险箱。对于 007 来说，这只是小菜一碟，除了一个问题：这是一个
    Humperdink BR549 数字保险箱，需要输入 10 位数字，总共有 100 亿种可能的组合。而且，锁轮只有在输入完所有数字后才会开始转动。你不能通过听诊器慢慢转动拨盘来破解它！
- en: As Q, you already have an autodialer device that can brute-force its way through
    all possible solutions, but Bond simply won’t have time to use it. Here’s why.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Q，你已经有了一个自动拨号器，可以暴力破解所有可能的解决方案，但邦德根本没有时间使用它。原因如下。
- en: A combination lock should really be called a *permutation* lock, because it
    requires *ordered* combinations, which are, by definition, permutations. More
    specifically, locks rely on *permutations with repetition*. For example, a valid—though
    insecure—combination could be 999999999.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 组合锁其实应该叫做*排列*锁，因为它需要*有序*的组合，而排列本身就是*有序*的定义。更具体地说，锁依赖于*带有重复的排列*。例如，一个有效的——尽管不安全——组合可能是
    999999999。
- en: 'You used the itertools module’s permutations() iterator when working with anagrams
    in [Chapter 3](ch03.xhtml#ch03) and in “[Practice Projects](ch04.xhtml#lev106)”
    on [page 87](ch04.xhtml#page_87) in [Chapter 4](ch04.xhtml#ch04), but that won’t
    help here because permutations() returns permutations *without* repetition. To
    generate the right kind of permutation for a lock, you need to use itertools’s
    product() iterator, which calculates the Cartesian product from multiple sets
    of numbers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml#ch03)的字谜部分和[第4章](ch04.xhtml#ch04)中 “[练习项目](ch04.xhtml#lev106)”
    的[第87页](ch04.xhtml#page_87)，你使用了 itertools 模块的 permutations() 迭代器处理字谜，但这里行不通，因为
    permutations() 返回的排列是*无重复*的。为了生成适合锁的排列，你需要使用 itertools 的 product() 迭代器，它会计算多个数字集合的笛卡尔积：
- en: '>>> from itertools import product'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从 itertools 模块导入 product'
- en: '>>> combo = (1, 2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> combo = (1, 2)'
- en: '>>> for perm in product(combo, repeat=2):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for perm in product(combo, repeat=2):'
- en: print(perm)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: print(perm)
- en: (1, 1)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 1)
- en: (1, 2)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 2)
- en: (2, 1)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 1)
- en: (2, 2)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 2)
- en: The optional repeat keyword argument lets you take the product of an iterable
    multiplied by itself, as you need to do in this case. Note that the product()
    function returns all the possible combinations, whereas the permutations() function
    would return only (1, 2) and (2, 1). You can read more about product() at *[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 repeat 关键字参数允许你对一个可迭代对象进行重复的笛卡尔积运算，就像在这种情况下需要的那样。请注意，product() 函数会返回所有可能的组合，而
    permutations() 函数只会返回 (1, 2) 和 (2, 1)。你可以在 *[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)*
    阅读更多关于 product() 的内容。
- en: '[Listing 7-8](ch07.xhtml#ch07list8) is a Python program, called *brute_force_cracker.py*,
    that uses product() to brute-force its way to the right combination:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-8](ch07.xhtml#ch07list8) 是一个 Python 程序，叫做 *brute_force_cracker.py*，它使用
    product() 函数暴力破解找到正确的组合：'
- en: '*brute_force_cracker.py*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*brute_force_cracker.py*'
- en: ➊ import time
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 导入 time 模块
- en: from itertools import product
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从 itertools 模块导入 product
- en: start_time = time.time()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: ➋ combo = (9, 9, 7, 6, 5, 4, 3)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ combo = (9, 9, 7, 6, 5, 4, 3)
- en: '# use Cartesian product to generate permutations with repetition'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用笛卡尔积生成带有重复的排列'
- en: '➌ for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):'
- en: '➍ if perm == combo:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if perm == combo:'
- en: print("Cracked! {} {}".format(combo, perm))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: print("破解成功! {} {}".format(combo, perm))
- en: end_time = time.time()
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: end_time = time.time()
- en: ➎ print("\nRuntime for this program was {} seconds.".format
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ print("\n该程序的运行时间是 {} 秒.".format
- en: (end_time - start_time))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (end_time - start_time))
- en: '*Listing 7-8: Uses a brute-force method to find a safe’s combination*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-8：使用暴力破解法找到保险箱的组合*'
- en: Import time and the product iterator from itertools ➊. Get the start time, and
    then enter the safe combination as a tuple ➋. Next use product(), which returns
    tuples of all the permutations with repetition for a given sequence. The sequence
    contains all the valid single-digit entries (0–9). You should set the repeat argument
    to the number of digits in the combination ➌. Compare each result to the combination
    and print "Cracked!" if they match, along with the combination and matching permutation
    ➍. Finish by displaying the runtime ➎.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从 itertools 导入时间和产品迭代器 ➊。获取开始时间，然后将保险箱的组合作为元组输入 ➋。接下来使用 product()，它返回给定序列的所有排列（包括重复）元组。该序列包含所有有效的单数字输入（0–9）。你应将
    repeat 参数设置为组合中的数字个数 ➌。比较每个结果与组合，如果匹配，则打印“破解！”并显示组合和匹配的排列 ➍。最后，显示运行时间 ➎。
- en: This works great for combinations up to eight digits long. After that, the wait
    becomes increasingly uncomfortable. [Table 7-3](ch07.xhtml#ch07tab3) is a record
    of runtimes for the program versus number of digits in the combination.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于最多八位数的组合效果很好。之后，等待时间变得越来越不舒服。[表 7-3](ch07.xhtml#ch07tab3)记录了程序运行时间与组合中数字个数的关系。
- en: '**Table 7-3:** Runtimes Versus Digits in Combination (2.3 GHz Processor)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3：** 运行时间与组合中数字的关系（2.3 GHz 处理器）'
- en: '| **Number of digits** | **Runtime in seconds** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **数字位数** | **运行时间（秒）** |'
- en: '| --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 5 | 0.035 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.035 |'
- en: '| 6 | 0.147 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0.147 |'
- en: '| 7 | 1.335 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1.335 |'
- en: '| 8 | 12.811 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 12.811 |'
- en: '| 9 | 133.270 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 133.270 |'
- en: '| 10 | 1396.955 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1396.955 |'
- en: Notice that adding a number to the combination increases the runtime by an order
    of magnitude. This is an exponential increase. With 9 digits, you’d wait over
    2 minutes for an answer. With 10 digits, over 20 minutes! That’s a long time for
    Bond to take an unnoticed “bathroom break.”
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，向组合中添加一个数字会使运行时间增加一个数量级。这是一个指数级的增长。对于 9 位数字，你将需要等待超过 2 分钟才能得到答案；对于 10 位数字，则需要超过
    20 分钟！对于邦德来说，这是一个长时间的“上厕所”休息。
- en: Fortunately, you’re Q, and you know about genetic algorithms. All you need is
    some way to judge the fitness of each candidate combination. Options include monitoring
    fluctuations in power consumption, measuring time delays in operations, and listening
    for sounds. Let’s assume use of a sound-amplifying tool, along with a tool to
    prevent lockouts after a few incorrect combinations have been entered. Because
    of the safeguards in the BR549 safe, a sound tool can initially tell you only
    *how many* digits are correct, not *which* digits, but with very little time,
    your algorithm can zero in on the solution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你是 Q，你了解遗传算法。你需要做的就是找到一种方法来评估每个候选组合的适应度。可选的方式包括监控功耗波动、测量操作中的时间延迟以及监听声音。假设我们使用一种声音放大工具，以及一个防止在输入几个错误组合后被锁定的工具。由于
    BR549 保管箱的安全措施，声音工具最初只能告诉你*有多少个*数字是正确的，而不能告诉你*哪个*数字正确，但用不了多少时间，你的算法就能锁定解决方案。
- en: '**THE OBJECTIVE**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use a genetic algorithm to quickly find a safe’s combination in a large search
    space.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法在一个大的搜索空间中快速找到保险箱的组合。
- en: '***Strategy***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: The strategy here is straightforward. You’ll generate a sequence of 10 numbers
    at random and compare it to the real combination, grading the result based on
    matches; in the real world, you’d find the number of matches using the sound detector
    clamped to the door of the safe. You then change one value in your solution and
    compare again. If another match is found, you throw away the old sequence and
    move forward with the new; otherwise, you keep the old sequence and try again.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的策略很简单。你将随机生成一个由 10 个数字组成的序列，并将其与真实的组合进行比较，根据匹配的情况进行评分；在现实中，你可以使用固定在保险箱门上的声音探测器来找到匹配的数量。然后你会改变解中的一个值，再次进行比较。如果找到另一个匹配，你就丢弃旧的序列并继续前进；否则，你保持旧的序列并再试一次。
- en: Since one solution completely replaces the other, this represents 100 percent
    crossover of genetic material, so you are essentially using just selection and
    mutation. Selection plus mutation alone generates a robust *hill-climbing* algorithm.
    Hill climbing is an optimization technique that starts with an arbitrary solution
    and changes (mutates) a single value in the solution. If the result is an improvement,
    the new solution is kept and the process repeats.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个解完全替代另一个解，这代表了遗传物质的 100% 交叉，因此你实际上只在使用选择和突变。仅使用选择加突变就能生成一个强大的*爬山*算法。爬山是一种优化技术，它从一个任意的解开始，并在解中更改（突变）一个值。如果结果有所改进，就保留新的解，并重复这个过程。
- en: A problem with hill climbing is that the algorithm can get stuck in *local*
    minima or maxima and not find the optimal *global* value. Imagine you are looking
    for the lowest value in the wavelike function in [Figure 7-4](ch07.xhtml#ch07fig4).
    The current best guess is marked by the large black dot. If the magnitude of the
    change you are making (mutation) is too small to “escape” the local trough, the
    algorithm won’t find the true low point. From the algorithm’s point of view, because
    every direction results in a worse answer, it must have found the true answer.
    So it prematurely converges on a solution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0140-01.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Example of a hill-climbing algorithm “stuck” in a local minimum*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Using crossover in genetic algorithms helps to avoid premature convergence problems,
    as does allowing for relatively large mutations. Because you’re not worried about
    honoring biological realism here, the mutation space can encompass every possible
    value in the combination. That way you can’t get stuck, and hill climbing is an
    acceptable approach.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '***The Safecracker Code***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *safe_cracker.py* code takes a combination of *n* digits and uses hill climbing
    to reach the combination from a random starting point. The code can be downloaded
    from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up and Defining the fitness() Function**'
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-9](ch07.xhtml#ch07list9) imports the necessary modules and defines
    the fitness() function.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '*safe_cracker.py,* part 1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: from random import randint, randrange
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def fitness(combo, attempt):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '"""Compare items in two lists and count number of matches."""'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: grade = 0
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for i, j in zip(combo, attempt):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'if i == j:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: grade += 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: return grade
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-9: Imports modules and defines the* fitness() *function*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: After importing some familiar modules ➊, define a fitness() function that takes
    the true combination and an attempted solution as arguments ➋. Name a variable
    grade and set it to 0. Then use zip() to iterate through each element in the combination
    and your attempt ➌. If they’re the same, add 1 to grade and return it. Note that
    you aren’t recording the index that matches, just that the function has found
    a match. This emulates output from the sound detection device. All it can tell
    you initially is how many lock wheels turned, not their locations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining and Running the main() Function**'
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since this is a short and simple program, most of the algorithm is run in the
    main() function, [Listing 7-10](ch07.xhtml#ch07list10), rather than in multiple
    functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*safe_cracker.py,* part 2'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '"""Use hill-climbing algorithm to solve lock combination."""'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: ➊ combination = '6822858902'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: print("Combination = {}".format(combination))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '# convert combination to list:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ➋ combo = [int(i) for i in combination]
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '# generate guess & grade fitness:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: ➌ best_attempt = [0] * len(combo)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt_grade = fitness(combo, best_attempt)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ➍ count = 0
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '# evolve guess'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '➎ while best_attempt != combo:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ while best_attempt != combo:'
- en: '# crossover'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '# 交叉'
- en: ➏ next_try = best_attempt[:]
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ next_try = best_attempt[:]
- en: '# mutate'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '# 变异'
- en: lock_wheel = randrange(0, len(combo))
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: lock_wheel = randrange(0, len(combo))
- en: ➐ next_try[lock_wheel] = randint(0, 9)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ next_try[lock_wheel] = randint(0, 9)
- en: '# grade & select'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '# 评分与选择'
- en: ➑ next_try_grade = fitness(combo, next_try)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ next_try_grade = fitness(combo, next_try)
- en: 'if next_try_grade > best_attempt_grade:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'if next_try_grade > best_attempt_grade:'
- en: best_attempt = next_try[:]
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: best_attempt = next_try[:]
- en: best_attempt_grade = next_try_grade
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: best_attempt_grade = next_try_grade
- en: print(next_try, best_attempt)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: print(next_try, best_attempt)
- en: count += 1
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: print()
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: ➒ print("Cracked! {}".format(best_attempt), end=' ')
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ print("破解成功！{}".format(best_attempt), end=' ')
- en: print("in {} tries!".format(count))
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: print("在{}次尝试中完成！".format(count))
- en: 'if __name__ == ''__main__'':'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: start_time = time.time()
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: main()
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: end_time = time.time()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: end_time = time.time()
- en: duration = end_time - start_time
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: duration = end_time - start_time
- en: ➓ print("\nRuntime for this program was {:.5f} seconds.".format(duration))
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ print("\n该程序的运行时间为{:.5f}秒。".format(duration))
- en: '*Listing 7-10: Defines the* main() *function and runs and times the program
    if it hasn’t been imported*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-10: 定义了* main() *函数，并在未被导入的情况下运行和计时程序*'
- en: Provide the true combination as a variable ➊ and use list comprehension to convert
    it into a list for convenience going forward ➋. Generate a list of zeros equal
    in length to the combination and name it best_attempt ➌. At this point, any combination
    is as good as any other. You should retain this name—best_attempt—because you
    need to preserve only the best solution as you climb the hill. Once you’ve generated
    the initial attempt, grade it with the fitness() function and then assign the
    value to a variable, called best_attempt_grade.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将真实的密码组合作为一个变量 ➊，并使用列表推导式将其转换为一个列表，以便后续使用 ➋。生成一个与密码组合长度相等的零列表，并命名为`best_attempt`
    ➌。此时，任何组合都与其他组合一样好。你应该保留这个名字—`best_attempt`—因为在爬坡过程中只需要保留最佳的解。一旦生成了初始尝试，使用`fitness()`函数进行评分，然后将该值赋给一个变量，命名为`best_attempt_grade`。
- en: Start a count variable at zero. The program will use this variable to record
    how many attempts it took to crack the code ➍.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始初始化一个计数变量。程序将使用这个变量记录破解密码所花费的尝试次数 ➍。
- en: Now, start a while loop that continues until you’ve found the combination ➎.
    Assign a *copy* of best_attempt to a next_try variable ➏. You copy it so you don’t
    run into aliasing problems; when you alter an element in next_try, you don’t want
    to accidentally change best_attempt, because you may continue to use it in the
    event next_try fails the fitness test.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个`while`循环，直到找到密码 ➎。将`best_attempt`的*副本*赋给`next_try`变量 ➏。复制它是为了避免别名问题；当你在`next_try`中更改一个元素时，你不希望不小心更改`best_attempt`，因为在`next_try`未通过适应性测试时，可能还会继续使用它。
- en: It’s now time to mutate the copy. Each digit in the combination turns a lock
    wheel in the safe, so name a variable lock_wheel and randomly set it equal to
    an index location in the combination. This represents the location of the single
    element to change in this iteration. Next, randomly choose a digit and use it
    to replace the value at the location indexed by lock_wheel ➐.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候变更密码了。组合中的每个数字都会转动保险箱中的一个锁轮，所以命名一个变量`lock_wheel`并随机设置其值为组合中的一个索引位置。这代表了在这一轮迭代中需要更改的单个元素的位置。接下来，随机选择一个数字，用它替换`lock_wheel`所索引位置的值
    ➐。
- en: Grade next_try, and if it’s fitter than the previous attempt, reset both best_attempt
    and best_attempt_grade to the new values ➑. Otherwise, best_attempt will remain
    unchanged for the next iteration. Print both next_try and best_attempt, side by
    side, so you can scroll through the attempts when the program ends and see how
    they evolved. Finish the loop by advancing the counter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对`next_try`进行评分，如果它比之前的尝试更适合，则将`best_attempt`和`best_attempt_grade`重置为新值 ➑。否则，`best_attempt`将在下一轮迭代中保持不变。打印`next_try`和`best_attempt`，并排显示，这样你可以在程序结束时滚动查看这些尝试，观察它们的变化。通过递增计数器来结束循环。
- en: When the program finds the combination, display the best_attempt value and the
    number of tries it took to find it ➒. Remember, the end=' ' argument prevents
    a carriage return at the end of the printed line and places a space between the
    end of the current line and the beginning of the next line.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序找到密码时，显示`best_attempt`的值以及找到密码所需的尝试次数 ➒。记住，`end=' '`参数防止打印行末的换行符，并在当前行末与下一行的开始之间添加空格。
- en: Complete the program with the conditional statement for running main() stand-alone
    and display the runtime to five decimal places ➓. Note that the timing code comes
    after the conditional, and thus will not run if the program is imported as a module.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last few lines of output from the *safe_cracker.py* program are shown here.
    I’ve omitted most of the evolving comparisons for brevity. The run was for a 10-digit
    combination.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 6, 2, 0, 5, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 0, 9, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 8, 5, 8, 9, 0, 0] [6, 8, 2, 2, 8, 5, 8, 9, 0, 0]'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 8, 5, 8, 9, 0, 2] [6, 8, 2, 2, 8, 5, 8, 9, 0, 2]'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Cracked! [6, 8, 2, 2, 8, 5, 8, 9, 0, 2] in 78 tries!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Runtime for this program was 0.69172 seconds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Ten billion possible combinations, and the program found a solution in only
    78 tries and in less than a second. Even James Bond would be impressed with that.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'That does it for genetic algorithms. You’ve used an example workflow to breed
    gigantic rodents, then trimmed it to hill climb through a brute-force problem
    in no time flat. If you want to continue to play digital Darwin and experiment
    with genetic algorithms, a long list of example applications can be found on Wikipedia
    (*[https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)*).
    Examples include:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Modeling global temperature changes
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-loading optimization
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery vehicle–routing optimization
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groundwater-monitoring networks
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning robot behavior
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protein folding
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rare-event analysis
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code breaking
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering for fit functions
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and signal processing
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Genetic Algorithms with Python* (Amazon Digital Services LLC, 2016) by Clinton
    Sheppard is a beginner-level introduction to genetic algorithms using Python.
    It is available in paperback or as an inexpensive ebook from *[https://leanpub.com/genetic_algorithms_with_python/](https://leanpub.com/genetic_algorithms_with_python/)*.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continue to breed super-rats and crack super-safes with these suggested projects.
    As usual with challenge projects, you’re on your own; no solutions are provided.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Rat Harem***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since a single male rat can mate with multiple females, there is no need to
    have an equal number of male and female rats. Rewrite the *super_rats.py* code
    to accommodate a variable number of male and female individuals. Then rerun the
    program with the same total number of rats as before, but use 4 males and 16 females.
    How does this impact the number of years required to reach the target weight of
    50,000 grams?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a More Efficient Safecracker***'
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As currently written, when a lock wheel match is found by the *safe_cracker.py*
    code, that match is not explicitly preserved. As long as the while loop is running,
    there’s nothing to stop a correct match from being stochastically overwritten.
    Alter the code so that the indexes for correct guesses are excluded from future
    changes. Do timing comparisons between the two versions of the code to judge the
    impact of the change.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 按照当前的写法，当*safe_cracker.py*代码找到一个锁轮匹配时，该匹配并没有被显式保存。只要`while`循环在运行，就没有什么能够阻止正确的匹配被随机覆盖。修改代码，使得正确猜测的索引在未来的更改中被排除。对比两种版本的代码的执行时间，以评估该更改的影响。
