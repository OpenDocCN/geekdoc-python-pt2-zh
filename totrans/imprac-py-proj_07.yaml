- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: BREEDING GIANT RATS WITH GENETIC ALGORITHMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用遗传算法培育超级大老鼠**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: '*Genetic algorithms* are general-purpose optimization programs designed to
    solve complex problems. Invented in the 1970s, they belong to the class of *evolutionary
    algorithms*, so named because they mimic the Darwinian process of natural selection.
    They are especially useful when little is known about a problem, when you’re dealing
    with a nonlinear problem, or when searching for brute-force-type solutions in
    a large search space. Best of all, they are easy algorithms to grasp and implement.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*遗传算法*是通用优化程序，旨在解决复杂问题。它们发明于1970年代，属于*进化算法*类，因为它们模拟了达尔文的自然选择过程。遗传算法特别适用于当问题的背景知识较少时，处理非线性问题时，或在大搜索空间中寻找暴力破解型解决方案时。最棒的是，它们是容易理解和实现的算法。'
- en: In this chapter, you’ll use genetic algorithms to breed a race of super-rats
    that can terrorize the world. After that, you’ll switch sides and help James Bond
    crack a high-tech safe in a matter of seconds. These two projects should give
    you a good appreciation for the mechanics and power of genetic algorithms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用遗传算法培育一群超级大老鼠，让它们横扫世界。之后，你将换个身份，帮助詹姆斯·邦德在几秒钟内破解一个高科技保险箱。这两个项目将让你更好地理解遗传算法的原理和强大功能。
- en: '**Finding the Best of All Possible Solutions**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**找到所有可能解中的最佳解**'
- en: Genetic algorithms *optimize*, which means that they select the best solution
    (with regard to some criteria) from a set of available alternatives. For example,
    if you’re looking for the fastest route to drive from New York to Los Angeles,
    a genetic algorithm will never suggest you fly. It can choose only from within
    an allowed set of conditions that *you* provide. As optimizers, these algorithms
    are faster than traditional methods and can avoid premature convergence to a suboptimal
    answer. In other words, they efficiently search the solution space yet do so thoroughly
    enough to avoid picking a good answer when a better one is available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法通过**优化**，意味着它们从一组可选的替代方案中选择最佳解（根据某些标准）。例如，如果你想找出从纽约到洛杉矶的最快驾驶路线，遗传算法绝不会建议你飞行。它只能从你提供的允许条件中做出选择。作为优化器，这些算法比传统方法更快，并能避免过早收敛到一个次优解。换句话说，它们能高效地搜索解空间，同时又足够彻底，避免在有更好的答案时选出一个较好的答案。
- en: 'Unlike *exhaustive* search engines, which use pure brute force, genetic algorithms
    don’t try every possible solution. Instead, they continuously grade solutions
    and then use them to make “informed guesses” going forward. A simple example is
    the “warmer-colder” game, where you search for a hidden item as someone tells
    you whether you are getting warmer or colder based on your proximity or search
    direction. Genetic algorithms use a fitness function, analogous to natural selection,
    to discard “colder” solutions and build on the “warmer” ones. The basic process
    is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与*穷举*搜索引擎不同，后者依靠纯粹的暴力破解，遗传算法并不会尝试所有可能的解决方案。相反，它们会不断地对解决方案进行评分，然后用这些评分来进行“有根据的猜测”。一个简单的例子是“温暖-寒冷”游戏，在这个游戏中，你寻找一个隐藏物品，有人会告诉你根据你的接近程度或搜索方向你是变得更温暖还是更寒冷。遗传算法使用适应度函数，类似于自然选择，用来丢弃“寒冷”的解，并在“温暖”的解上进行改进。基本过程如下：
- en: Randomly generate a population of solutions.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机生成一个解决方案群体。
- en: Measure the fitness of each solution.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量每个解决方案的适应度。
- en: Select the best (warmest) solutions and discard the rest.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最佳（最温暖的）解决方案，丢弃其他的。
- en: Cross over (recombine) elements in the best solutions to make new solutions.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最佳解决方案中交叉（重组）元素，生成新解决方案。
- en: Mutate a small number of elements in the solutions by changing their value.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过改变其值来突变解决方案中的少数元素。
- en: Return to step 2 and repeat.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回步骤2并重复。
- en: The select–cross over–mutate loop continues until it reaches a *stop condition*,
    like finding a known answer, finding a “good enough” answer (based on a minimum
    threshold), completing a set number of iterations, or reaching a time deadline.
    Because these steps closely resemble the process of evolution, complete with survival
    of the fittest, the terminology used with genetic algorithms is often more biological
    than computational.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择–交叉–变异循环继续进行，直到达到*停止条件*，例如找到已知答案、找到一个“足够好的”答案（根据最低阈值）、完成一定次数的迭代或达到时间限制。因为这些步骤与进化过程非常相似，完全符合“适者生存”的原则，所以在遗传算法中使用的术语往往更具生物学性质，而非计算机科学性质。
- en: '**Project #13: Breeding an Army of Super-Rats**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #13：培育超级大老鼠军团**'
- en: Here’s your chance to be a mad scientist with a secret lab full of boiling beakers,
    bubbling test tubes, and machines that go “BZZZTTT.” So pull on some black rubber
    gloves and get busy turning nimble trash-eating scavengers into massive man-eating
    monsters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Use a genetic algorithm to simulate breeding rats to an average weight of 110
    pounds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your dream is to breed a race of rats the size of bullmastiffs (we’ve already
    established that you’re mad). You’ll start with *Rattus norvegicus*, the brown
    rat, then add some artificial sweeteners, some atomic radiation from the 1950s,
    a lot of patience, and a pinch of Python, but no genetic engineering—you’re old-school,
    baby! The rats will grow from less than a pound to a terrifying 110 pounds, about
    the size of a female bullmastiff (see [Figure 7-1](ch07.xhtml#ch07fig1)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0127-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Size comparison of a brown rat, a female bullmastiff, and a human*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Before you embark on such a huge undertaking, it’s prudent to simulate the results
    in Python. And you’ve drawn up something better than a plan—you’ve drawn some
    graphical pseudocode (see [Figure 7-2](ch07.xhtml#ch07fig2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0128-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Genetic algorithm approach to breeding super-rats*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The process shown in [Figure 7-2](ch07.xhtml#ch07fig2) outlines how a genetic
    algorithm works. Your goal is to produce a population of rats with an average
    weight of 110 pounds from an initial population weighing much less than that.
    Going forward, each population (or *generation*) of rats represents a candidate
    solution to the problem. Like any animal breeder, you cull undesirable males and
    females, which you humanely send to—for you *Austin Powers* fans—an evil petting
    zoo. You then mate and breed the remaining rats, a process known as *crossover*
    in genetic programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The offspring of the remaining rats will be essentially the same size as their
    parents, so you need to mutate a few. While mutation is rare and usually results
    in a neutral-to-nonbeneficial trait (low weight, in this case), sometimes you’ll
    successfully produce a bigger rat.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The whole process then becomes a big repeating loop, whether done organically
    or programmatically, making me wonder whether we really *are* just virtual beings
    in an alien simulation. At any rate, the end of the loop—the stop condition—is
    when the rats reach the desired size or you just can’t stand dealing with rats
    anymore.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: For input to your simulation, you’ll need some statistics. Use the metric system
    since you’re a scientist, mad or not. You already know that the average weight
    of a female bullmastiff is 50,000 grams, and you can find useful rat statistics
    in [Table 7-1](ch07.xhtml#ch07tab1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Brown Rat Weight and Breeding Statistics'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Published values** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| Minimum weight | 200 grams |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| Average weight (female) | 250 grams |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Average weight (male) | 300–350 grams |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| Maximum weight | 600 grams* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| Number of pups per litter | 8–12 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| Litters per year | 4–13 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| Life span (wild, captivity) | 1–3 years, 4–6 years |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| *Exceptional individuals may reach 1,000 grams in captivity. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: Because both domestic and wild brown rats exist, there may be wide variation
    in some of the stats. Rats in captivity tend to be better cared for than wild
    rats, so they weigh more, breed more, and have more pups. So you can choose from
    the higher end when a range is available. For this project, start with the assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** Input Assumptions for the Super-Rats Genetic Algorithm'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable and value** | **Comments** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| GOAL = 50000 | Target weight in grams (female bullmastiff) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| NUM_RATS = 20 | Total number of *adult* rats your lab can support |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| INITIAL_MIN_WT = 200 | Minimum weight of adult rat, in grams, in initial
    population |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| INITIAL_MAX_WT = 600 | Maximum weight of adult rat, in grams, in initial
    population |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| INITIAL_MODE_WT = 300 | Most common adult rat weight, in grams, in initial
    population |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| MUTATE_ODDS = 0.01 | Probability of a mutation occurring in a rat |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| MUTATE_MIN = 0.5 | Scalar on rat weight of least beneficial mutation |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| MUTATE_MAX = 1.2 | Scalar on rat weight of most beneficial mutation |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| LITTER_SIZE = 8 | Number of pups per pair of mating rats |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| LITTERS_PER_YEAR = 10 | Number of litters per year per pair of mating rats
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| GENERATION_LIMIT = 500 | Generational cutoff to stop breeding program |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: Since rats breed so frequently, you shouldn’t have to factor in life span. Even
    though you will retain some of the parents from a previous generation, they will
    be culled out quickly as their offspring increase in weight from generation to
    generation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '***The Super-Rats Code***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *super_rats.py* code follows the general workflow in [Figure 7-2](ch07.xhtml#ch07fig2).
    You can also download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Entering the Data and Assumptions**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.xhtml#ch07list1), in the global space at the start of the
    program, imports modules and assigns the statistics, scalars, and assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2) as constants. Once the program is complete
    and working, feel free to experiment with the values in that table and see how
    they affect your results.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: import statistics
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '➋ # CONSTANTS (weights in grams)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: ➌ GOAL = 50000
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: NUM_RATS = 20
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MIN_WT = 200
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MAX_WT = 600
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MODE_WT = 300
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: MUTATE_ODDS = 0.01
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: MUTATE_MIN = 0.5
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: MUTATE_MAX = 1.2
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: LITTER_SIZE = 8
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: LITTERS_PER_YEAR = 10
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: GENERATION_LIMIT = 500
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '# ensure even-number of rats for breeding pairs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if NUM_RATS % 2 != 0:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: NUM_RATS += 1
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-1: Imports modules and assigns constants*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the time, random, and statistics modules ➊. You’ll use the
    time module to record the runtime of your genetic algorithm. It’s interesting
    to time genetic algorithms, if only to be awed by how quickly they can find a
    solution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The random module will satisfy the stochastic needs of the algorithm, and you’ll
    use the statistics module to get mean values. This is a weak use for statistics,
    but I want you to be aware of the module, since it can be quite handy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign the input variables described in [Table 7-2](ch07.xhtml#ch07tab2)
    and be sure to note that the units are grams ➋. Use uppercase letters for the
    names, as these represent constants ➌.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we’re going to assume the use of breeding *pairs*, so check that
    the user input an even number of rats and, if not, add a rat ➍. Later, in “[Challenge
    Projects](ch07.xhtml#lev167)” on [page 144](ch07.xhtml#page_144), you’ll get to
    experiment with alternative gender distributions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing the Population**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-2](ch07.xhtml#ch07list2) is the program’s shopping representative.
    It goes to a pet shop and picks out the rats for an initial breeding population.
    Since you want mating pairs, it should choose an even number of rats. And since
    you can’t afford one of those fancy volcano lairs with unlimited space, you’ll
    need to maintain a constant number of adult rats through each generation—though
    the number can swell temporarily to accommodate litters. Remember, the rats will
    need more and more space as they grow to the size of big dogs!'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 2'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def populate(num_rats, min_wt, max_wt, mode_wt):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '"""Initialize a population with a triangular distribution of weights."""'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: ➋ return [int(random.triangular(min_wt, max_wt, mode_wt))\
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: for i in range(num_rats)]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-2: Defines the function that creates the initial rat population*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The populate() function needs to know the amount of adult rats you want, the
    minimum and maximum weights for the rats, and the most commonly occurring weight
    ➊. Note that all of these arguments will use constants found in the global space.
    You don’t have to pass these as arguments for the function to access them. But
    I do so here and in the functions that follow, for clarity and because local variables
    are accessed more efficiently.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the four arguments above with the random module, which includes different
    types of distributions. You’ll use a triangular distribution here, because it
    gives you firm control of the minimum and maximum sizes and lets you model skewness
    in the statistics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Because brown rats exist both in the wild and in captivity—in zoos, labs, and
    as pets—their weights are skewed to the high side. Wild rats tend to be smaller
    as their lives are nasty, brutish, and short, though lab rats may contest that
    point! Use list comprehension to loop through the number of rats and assign each
    one a weight. Bundle it all together with the return statement ➋.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Measuring the Fitness of the Population**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Measuring the fitness of the rats is a two-step process. First, grade the whole
    population by comparing the average weight of all the rats to the bullmastiff
    target. Then, grade each individual rat. Only rats whose weight ranks in the upper
    *n* percent, as determined by the NUM_RATS variable, get to breed again. Although
    the average weight of the population is a valid fitness measurement, its primary
    role here is to determine whether it’s time to stop looping and declare success.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-3](ch07.xhtml#ch07list3) defines the fitness() and select() functions,
    which together form the measurement portion of your genetic algorithm.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 3'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def fitness(population, goal):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '"""Measure population fitness based on an attribute mean vs target."""'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: ave = statistics.mean(population)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: return ave / goal
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def select(population, to_retain):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '"""Cull a population to retain only a specified number of members."""'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: ➌ sorted_population = sorted(population)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: ➍ to_retain_by_sex = to_retain//2
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: ➎ members_per_sex = len(sorted_population)//2
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: ➏ females = sorted_population[:members_per_sex]
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: males = sorted_population[members_per_sex:]
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: ➐ selected_females = females[-to_retain_by_sex:]
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: selected_males = males[-to_retain_by_sex:]
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: ➑ return selected_males, selected_females
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-3: Defines the measurement step of the genetic algorithm*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to grade the fitness of the current generation ➊. Use the
    statistics module to get the mean of the population and return this value divided
    by the target weight. When this value is equal to or greater than 1, you’ll know
    it’s time to stop breeding.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function that culls a population of rats, based on weight, down
    to the NUM_RATS value, represented here by the to_retain parameter ➋. It will
    also take a population argument, which will be the parents of each generation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Now, sort the population so you can distinguish large from small ➌. Take the
    number of rats you want to retain and divide it by 2 using floor division so that
    the result is an integer ➍. Do this step so you can keep the biggest male and
    female rats. If you choose only the largest rats in the population, you will theoretically
    be choosing only males. You obtain the total members of the current population,
    by sex, by dividing the sorted_population by 2, again using floor division ➎.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Male rats tend to be larger than females, so make two simplifying assumptions:
    first, assume that exactly half of the population is female and, second, that
    the largest female rat is no heavier than the smallest male rat. This means that
    the first half of the sorted population list represents females and the last half
    represents males. Then create two new lists by splitting sorted_population in
    half, taking the bottom half for females ➏ and the upper half for males. Now all
    that’s left to do is take the biggest rats from the end of each of these lists
    ➐—using negative slicing—and return them ➑. These two lists contain the parents
    of the next generation.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run this function, all it will do is sort the rats by sex,
    as the initial number of rats already equals the NUM_RATS constant. After that,
    the incoming population argument will include both parents and children, and its
    value will exceed NUM_RATS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行这个函数时，它做的只是按性别对老鼠进行排序，因为初始的老鼠数量已经等于NUM_RATS常量。之后，传入的种群参数将包括父母和子代，它的值将超过NUM_RATS。
- en: '**Breeding a New Generation**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**繁殖新一代**'
- en: '[Listing 7-4](ch07.xhtml#ch07list4) defines the program’s “crossover” step,
    which means it breeds the next generation. A key assumption is that the weight
    of every child will be greater than or equal to the weight of the mother and less
    than or equal to the weight of the father. Exceptions to that rule will be handled
    in the “mutation” function.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出 7-4](ch07.xhtml#ch07list4)定义了程序的“交叉”步骤，这意味着它繁殖了下一代。一个关键假设是每个子代的体重将大于或等于母鼠的体重，并且小于或等于父鼠的体重。违反此规则的情况将在“突变”函数中处理。'
- en: '*super_rats.py,* part 4'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第4部分'
- en: '➊ def breed(males, females, litter_size):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def breed(males, females, litter_size):'
- en: '"""Crossover genes among members (weights) of a population."""'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在群体成员（体重）之间交叉基因。"""'
- en: ➋ random.shuffle(males)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ random.shuffle(males)
- en: random.shuffle(females)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: random.shuffle(females)
- en: ➌ children = []
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ children = []
- en: '➍ for male, female in zip(males, females):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for male, female in zip(males, females):'
- en: '➎ for child in range(litter_size):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for child in range(litter_size):'
- en: ➏ child = random.randint(female, male)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ child = random.randint(female, male)
- en: ➐ children.append(child)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ children.append(child)
- en: ➑ return children
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ return children
- en: '*Listing 7-4: Defines the function that breeds a new generation of rats*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 7-4：定义了一个繁殖新一代老鼠的函数*'
- en: The breed() function takes as arguments the lists of weights of selected males
    and females returned from the select() function along with the size of a litter
    ➊. Next, randomly shuffle the two lists ➋, because you sorted them in the select()
    function and iterating over them without shuffling would result in the smallest
    male being paired with the smallest female, and so on. You need to allow for love
    and romance; the largest male may be drawn to the most petite female!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: breed()函数的参数是通过select()函数返回的雄鼠和雌鼠的体重列表，以及窝重的大小 ➊。接下来，随机打乱这两个列表 ➋，因为你已经在select()函数中对它们进行了排序，不打乱它们就直接迭代会导致最小的雄鼠和最小的雌鼠配对，依此类推。你需要考虑到爱情与浪漫；最大的雄鼠可能会被最娇小的雌鼠吸引！
- en: Start an empty list to hold their children ➌. Now for the hanky-panky. Go through
    the shuffled lists using zip() to pair a male and female from each list ➍. Each
    pair of rats can have multiple children, so start another loop that uses the litter
    size as a range ➎. The litter size is a constant, called LITTER_SIZE, that you
    provided in the input parameters, so if the value is 8, you’ll get eight children.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表来保存它们的子代 ➌。现在进入难度较高的部分。使用zip()函数遍历打乱后的列表，将每对雄性和雌性配对 ➍。每对老鼠可以有多个子代，因此开始另一个循环，使用窝重作为范围
    ➎。窝重是一个常量，名为LITTER_SIZE，是你在输入参数中提供的，因此如果该值为8，你将得到八只小鼠。
- en: For each child, choose a weight at random between the mother’s and father’s
    weights ➏. Note that you don’t need to use male + 1, because randint() uses *all*
    the numbers in the supplied range. Note also that the two values can be the same,
    but the first value (the mother’s weight) can never be larger than the second
    (the father’s weight). This is another reason for the simplifying assumption that
    females must be no larger than the smallest male. End the loop by appending each
    child to the list of children ➐, then return children ➑.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个子代，随机选择一个体重，介于母鼠和父鼠的体重之间 ➏。请注意，你不需要使用male + 1，因为randint()会使用所提供范围内的*所有*数字。还需要注意，两个值可以相同，但第一个值（母鼠的体重）永远不能大于第二个值（父鼠的体重）。这也是假设雌鼠体型不大于最小雄鼠的简化假设的另一个原因。结束循环时，将每个子代附加到子代列表中
    ➐，然后返回子代 ➑。
- en: '**Mutating the Population**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**突变种群**'
- en: A small percentage of the children should experience mutations, and most of
    these should result in traits that are nonbeneficial. That means lower-than-expected
    weights, including “runts” that would not survive. But every so often, a beneficial
    mutation will result in a heavier rat.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一小部分子代应经历突变，其中大多数突变会导致不利的特征。这意味着体重低于预期，包括“弱鼠”，这些鼠无法生存。但偶尔，某些有益的突变会导致较重的老鼠。
- en: '[Listing 7-5](ch07.xhtml#ch07list5) defines the mutate() function, which applies
    the mutation assumptions you supplied in the list of constants. After mutate()
    is called, it will be time to check the fitness of the new population and start
    the loop over if the target weight hasn’t been reached.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 5'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def mutate(children, mutate_odds, mutate_min, mutate_max):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '"""Randomly alter rat weights using input odds & fractional changes."""'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '➋ for index, rat in enumerate(children):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'if mutate_odds >= random.random():'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: ➌ children[index] = round(rat * random.uniform(mutate_min,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: mutate_max))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: return children
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-5: Defines the function that mutates a small portion of the population*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The function needs the list of children, the odds of a mutation occurring, and
    the minimum and maximum impacts of a mutation ➊. The impacts are scalars that
    you’ll apply to the weight of a rat. In your list of constants at the start of
    the program (and in [Table 7-2](ch07.xhtml#ch07tab2)), they are skewed to the
    minimum side, as most mutations do not result in beneficial traits.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Loop through the list of children and use enumerate()—a handy built-in function
    that acts as an automatic counter—to get an index ➋. Then use the random() method
    to generate a random number between 0 and 1 and compare it to the odds of a mutation
    occurring.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If the mutate_odds variable is greater than or equal to the randomly generated
    number, the rat (weight) at that index is mutated. Choose a mutation value from
    a uniform distribution defined by the minimum and maximum mutation values; this
    basically selects a value at random from the min-max range. As these values are
    skewed to the minimum, the outcome is more likely to be a loss in weight than
    a gain. Multiply the current weight by this mutation scalar and round it to an
    integer ➌. Finish by returning the mutated children list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*With regard to the validity of mutation statistics, you can find studies that
    suggest beneficial mutations are very rare and others that suggest they are more
    common than we realize. The breeding of dogs has shown that achieving drastic
    variations in size (for example, Chihuahuas vs. Great Danes) doesn’t require millions
    of years of evolution. In a famous 20th-century study, Russian geneticist Dmitry
    Belyayev started with 130 silver foxes and, over a 40-year period, succeeded in
    achieving dramatic physiological changes by simply selecting the tamest foxes
    in each generation.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-6](ch07.xhtml#ch07list6) defines the main() function, which manages
    the other functions and determines when you’ve met the stop condition. It will
    also display all the important results.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 6'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '"""Initialize population, select, breed, and mutate, display results."""'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: ➊ generations = 0
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: ➋ parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MODE_WT)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: print("initial population weights = {}".format(parents))
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: popl_fitness = fitness(parents, GOAL)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: print("initial population fitness = {}".format(popl_fitness))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: print("number to retain = {}".format(NUM_RATS))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: ➌ ave_wt = []
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '➍ while popl_fitness < 1 and generations < GENERATION_LIMIT:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: selected_males, selected_females = select(parents, NUM_RATS)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: children = breed(selected_males, selected_females, LITTER_SIZE)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: ➎ parents = selected_males + selected_females + children
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: popl_fitness = fitness(parents, GOAL)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: ➏ print("Generation {} fitness = {:.4f}".format(generations,
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: popl_fitness))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: ➐ ave_wt.append(int(statistics.mean(parents)))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: generations += 1
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: ➑ print("average weight per generation = {}".format(ave_wt))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: print("\nnumber of generations = {}".format(generations))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: print("number of years = {}".format(int(generations / LITTERS_PER_YEAR)))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-6: Defines the* main() *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Start the function by initializing an empty list to hold the number of generations.
    You’ll eventually use this to figure out how many years it took to achieve your
    goal ➊.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the populate() function ➋ and immediately print the results. Then,
    get the fitness of your initial population and print this along with the number
    of rats to retain each generation, which is the NUM_RATS constant.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: For fun, initialize a list to hold the average weight of each generation so
    you can view it at the end ➌. If you plot these weights against the number of
    years, you’ll see that the trend is exponential.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the big genetic loop of select-mate-mutate. This is in the form of
    a while loop, with the stop conditions being either reaching the target weight
    or reaching a large number of generations without achieving the target weight
    ➍. Note that after mutating the children, you need to combine them with their
    parents to make a new parents list ➎. It takes the pups about five weeks to mature
    and start breeding, but you can account for this by adjusting the LITTERS_PER_YEAR
    constant down from the maximum possible value (see [Table 7-1](ch07.xhtml#ch07tab1)),
    as we’ve done here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: At the end of each loop, display the results of the fitness() function to four
    decimal places so you can monitor the algorithm and ensure it is progressing as
    expected ➏. Get the average weight of the generation, append it to the ave_wt
    list ➐, and then advance the generation count by 1.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Complete the main() function by displaying the list of average weights per generation,
    the number of generations, and the number of years—calculated using the LITTERS_PER_YEAR
    variable ➑.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Running the main() Function
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finish up with the familiar conditional statement for running the program either
    stand-alone or as a module. Get the ending time and print how long it took the
    program to run. The performance information should print only when the module
    is run in stand-alone mode, so be sure to place it under the if clause. See [Listing
    7-7](ch07.xhtml#ch07list7).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 7'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: duration = end_time - start_time
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: print("\nRuntime for this program was {} seconds.".format(duration))
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-7: Runs the* main() *function and* time *module if the program isn’t
    imported*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the parameters in [Table 7-2](ch07.xhtml#ch07tab2), the *super_rats.py*
    program will take about two seconds to run. On average, it will take the rats
    about 345 generations, or 34.5 years, to reach the target weight of 110 pounds.
    That’s a long time for a mad scientist to stay mad! But armed with your program,
    you can look for ways to reduce the time to target.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '*Sensitivity studies* work by making multiple changes to a *single* variable
    and judging the results. You should take care in the event some variables are
    dependent on one another. And since the results are stochastic (random), you should
    make multiple runs with each parameter change in order to capture the range of
    possible outcomes.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Two things you can control in your breeding program are the number of breeding
    rats (NUM_RATS) and the odds of a mutation occurring (MUTATE_ODDS). The mutation
    odds are influenced by factors like diet and exposure to radiation. If you change
    these variables one at a time and rerun *super_rats.py*, you can judge the impact
    of each variable on the project timeline.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: An immediate observation is that, if you start with small values for each variable
    and slowly increase them, you get dramatic initial results (see [Figure 7-3](ch07.xhtml#ch07fig3)).
    After that, both curves decline rapidly and flatten out in a classic example of
    diminishing returns. The point where each curve flattens is the key to optimally
    saving money and reducing work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: For example, you get very little benefit from retaining more than about 300
    rats. You’d just be feeding and caring for a lot of superfluous rats. Likewise,
    trying to boost the odds of a mutation above 0.3 gains you little.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: With charts like these, it’s easy to plan a path forward. The horizontal dotted
    line marked “Baseline” represents the average result of using the input in [Table
    7-2](ch07.xhtml#ch07tab2). You can potentially reduce this time by over 10 years
    just by retaining 50 rats rather than 20\. You should also focus on increasing
    the number of beneficial mutations. This will be more rewarding, but riskier and
    harder to control.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0137-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Impact of two parameters on the time required to reach the target
    weight*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: If you rerun the simulation using 50 rats and bumping the odds of mutation up
    to 0.05, you can theoretically complete the project in 14 years, an improvement
    of 246 percent over the initial baseline. Now *that’s* optimization!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Breeding super-rats was a fun and simple way to understand the basics of genetic
    algorithms. But to truly appreciate their power, you need to attempt something
    harder. You need a brute-force problem that’s too big to brute-force, and the
    next project is that kind of problem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #14: Cracking a High-Tech Safe**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You are Q, and James Bond has a problem. He has to attend an elegant dinner
    party at a villain’s mansion, slip away to the man’s private office, and crack
    his wall safe. Child’s play for 007, except for one thing: it’s a Humperdink BR549
    digital safe that takes 10 digits, yielding 10 billion possible combinations.
    And the lock wheels don’t start turning until *after* all the numbers have been
    entered. There’ll be no putting a stethoscope to this safe and slowly turning
    a dial!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As Q, you already have an autodialer device that can brute-force its way through
    all possible solutions, but Bond simply won’t have time to use it. Here’s why.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: A combination lock should really be called a *permutation* lock, because it
    requires *ordered* combinations, which are, by definition, permutations. More
    specifically, locks rely on *permutations with repetition*. For example, a valid—though
    insecure—combination could be 999999999.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'You used the itertools module’s permutations() iterator when working with anagrams
    in [Chapter 3](ch03.xhtml#ch03) and in “[Practice Projects](ch04.xhtml#lev106)”
    on [page 87](ch04.xhtml#page_87) in [Chapter 4](ch04.xhtml#ch04), but that won’t
    help here because permutations() returns permutations *without* repetition. To
    generate the right kind of permutation for a lock, you need to use itertools’s
    product() iterator, which calculates the Cartesian product from multiple sets
    of numbers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from itertools import product'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '>>> combo = (1, 2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for perm in product(combo, repeat=2):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: print(perm)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: (1, 1)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: (1, 2)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: (2, 1)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: (2, 2)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The optional repeat keyword argument lets you take the product of an iterable
    multiplied by itself, as you need to do in this case. Note that the product()
    function returns all the possible combinations, whereas the permutations() function
    would return only (1, 2) and (2, 1). You can read more about product() at *[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-8](ch07.xhtml#ch07list8) is a Python program, called *brute_force_cracker.py*,
    that uses product() to brute-force its way to the right combination:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*brute_force_cracker.py*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import product
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ➋ combo = (9, 9, 7, 6, 5, 4, 3)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '# use Cartesian product to generate permutations with repetition'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if perm == combo:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: print("Cracked! {} {}".format(combo, perm))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: ➎ print("\nRuntime for this program was {} seconds.".format
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: (end_time - start_time))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-8: Uses a brute-force method to find a safe’s combination*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Import time and the product iterator from itertools ➊. Get the start time, and
    then enter the safe combination as a tuple ➋. Next use product(), which returns
    tuples of all the permutations with repetition for a given sequence. The sequence
    contains all the valid single-digit entries (0–9). You should set the repeat argument
    to the number of digits in the combination ➌. Compare each result to the combination
    and print "Cracked!" if they match, along with the combination and matching permutation
    ➍. Finish by displaying the runtime ➎.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: This works great for combinations up to eight digits long. After that, the wait
    becomes increasingly uncomfortable. [Table 7-3](ch07.xhtml#ch07tab3) is a record
    of runtimes for the program versus number of digits in the combination.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** Runtimes Versus Digits in Combination (2.3 GHz Processor)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number of digits** | **Runtime in seconds** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0.035 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0.147 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1.335 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| 8 | 12.811 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| 9 | 133.270 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1396.955 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: Notice that adding a number to the combination increases the runtime by an order
    of magnitude. This is an exponential increase. With 9 digits, you’d wait over
    2 minutes for an answer. With 10 digits, over 20 minutes! That’s a long time for
    Bond to take an unnoticed “bathroom break.”
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you’re Q, and you know about genetic algorithms. All you need is
    some way to judge the fitness of each candidate combination. Options include monitoring
    fluctuations in power consumption, measuring time delays in operations, and listening
    for sounds. Let’s assume use of a sound-amplifying tool, along with a tool to
    prevent lockouts after a few incorrect combinations have been entered. Because
    of the safeguards in the BR549 safe, a sound tool can initially tell you only
    *how many* digits are correct, not *which* digits, but with very little time,
    your algorithm can zero in on the solution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Use a genetic algorithm to quickly find a safe’s combination in a large search
    space.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The strategy here is straightforward. You’ll generate a sequence of 10 numbers
    at random and compare it to the real combination, grading the result based on
    matches; in the real world, you’d find the number of matches using the sound detector
    clamped to the door of the safe. You then change one value in your solution and
    compare again. If another match is found, you throw away the old sequence and
    move forward with the new; otherwise, you keep the old sequence and try again.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Since one solution completely replaces the other, this represents 100 percent
    crossover of genetic material, so you are essentially using just selection and
    mutation. Selection plus mutation alone generates a robust *hill-climbing* algorithm.
    Hill climbing is an optimization technique that starts with an arbitrary solution
    and changes (mutates) a single value in the solution. If the result is an improvement,
    the new solution is kept and the process repeats.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: A problem with hill climbing is that the algorithm can get stuck in *local*
    minima or maxima and not find the optimal *global* value. Imagine you are looking
    for the lowest value in the wavelike function in [Figure 7-4](ch07.xhtml#ch07fig4).
    The current best guess is marked by the large black dot. If the magnitude of the
    change you are making (mutation) is too small to “escape” the local trough, the
    algorithm won’t find the true low point. From the algorithm’s point of view, because
    every direction results in a worse answer, it must have found the true answer.
    So it prematurely converges on a solution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0140-01.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Example of a hill-climbing algorithm “stuck” in a local minimum*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Using crossover in genetic algorithms helps to avoid premature convergence problems,
    as does allowing for relatively large mutations. Because you’re not worried about
    honoring biological realism here, the mutation space can encompass every possible
    value in the combination. That way you can’t get stuck, and hill climbing is an
    acceptable approach.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '***The Safecracker Code***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *safe_cracker.py* code takes a combination of *n* digits and uses hill climbing
    to reach the combination from a random starting point. The code can be downloaded
    from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up and Defining the fitness() Function**'
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-9](ch07.xhtml#ch07list9) imports the necessary modules and defines
    the fitness() function.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '*safe_cracker.py,* part 1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: from random import randint, randrange
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def fitness(combo, attempt):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '"""Compare items in two lists and count number of matches."""'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: grade = 0
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for i, j in zip(combo, attempt):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'if i == j:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: grade += 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: return grade
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-9: Imports modules and defines the* fitness() *function*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: After importing some familiar modules ➊, define a fitness() function that takes
    the true combination and an attempted solution as arguments ➋. Name a variable
    grade and set it to 0. Then use zip() to iterate through each element in the combination
    and your attempt ➌. If they’re the same, add 1 to grade and return it. Note that
    you aren’t recording the index that matches, just that the function has found
    a match. This emulates output from the sound detection device. All it can tell
    you initially is how many lock wheels turned, not their locations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining and Running the main() Function**'
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since this is a short and simple program, most of the algorithm is run in the
    main() function, [Listing 7-10](ch07.xhtml#ch07list10), rather than in multiple
    functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*safe_cracker.py,* part 2'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '"""Use hill-climbing algorithm to solve lock combination."""'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: ➊ combination = '6822858902'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: print("Combination = {}".format(combination))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '# convert combination to list:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ➋ combo = [int(i) for i in combination]
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '# generate guess & grade fitness:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: ➌ best_attempt = [0] * len(combo)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt_grade = fitness(combo, best_attempt)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ➍ count = 0
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '# evolve guess'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '➎ while best_attempt != combo:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '# crossover'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: ➏ next_try = best_attempt[:]
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '# mutate'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: lock_wheel = randrange(0, len(combo))
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: ➐ next_try[lock_wheel] = randint(0, 9)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '# grade & select'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: ➑ next_try_grade = fitness(combo, next_try)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'if next_try_grade > best_attempt_grade:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt = next_try[:]
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt_grade = next_try_grade
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: print(next_try, best_attempt)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ➒ print("Cracked! {}".format(best_attempt), end=' ')
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: print("in {} tries!".format(count))
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: duration = end_time - start_time
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: ➓ print("\nRuntime for this program was {:.5f} seconds.".format(duration))
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-10: Defines the* main() *function and runs and times the program
    if it hasn’t been imported*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Provide the true combination as a variable ➊ and use list comprehension to convert
    it into a list for convenience going forward ➋. Generate a list of zeros equal
    in length to the combination and name it best_attempt ➌. At this point, any combination
    is as good as any other. You should retain this name—best_attempt—because you
    need to preserve only the best solution as you climb the hill. Once you’ve generated
    the initial attempt, grade it with the fitness() function and then assign the
    value to a variable, called best_attempt_grade.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Start a count variable at zero. The program will use this variable to record
    how many attempts it took to crack the code ➍.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Now, start a while loop that continues until you’ve found the combination ➎.
    Assign a *copy* of best_attempt to a next_try variable ➏. You copy it so you don’t
    run into aliasing problems; when you alter an element in next_try, you don’t want
    to accidentally change best_attempt, because you may continue to use it in the
    event next_try fails the fitness test.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to mutate the copy. Each digit in the combination turns a lock
    wheel in the safe, so name a variable lock_wheel and randomly set it equal to
    an index location in the combination. This represents the location of the single
    element to change in this iteration. Next, randomly choose a digit and use it
    to replace the value at the location indexed by lock_wheel ➐.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Grade next_try, and if it’s fitter than the previous attempt, reset both best_attempt
    and best_attempt_grade to the new values ➑. Otherwise, best_attempt will remain
    unchanged for the next iteration. Print both next_try and best_attempt, side by
    side, so you can scroll through the attempts when the program ends and see how
    they evolved. Finish the loop by advancing the counter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: When the program finds the combination, display the best_attempt value and the
    number of tries it took to find it ➒. Remember, the end=' ' argument prevents
    a carriage return at the end of the printed line and places a space between the
    end of the current line and the beginning of the next line.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Complete the program with the conditional statement for running main() stand-alone
    and display the runtime to five decimal places ➓. Note that the timing code comes
    after the conditional, and thus will not run if the program is imported as a module.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last few lines of output from the *safe_cracker.py* program are shown here.
    I’ve omitted most of the evolving comparisons for brevity. The run was for a 10-digit
    combination.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 6, 2, 0, 5, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 0, 9, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 8, 5, 8, 9, 0, 0] [6, 8, 2, 2, 8, 5, 8, 9, 0, 0]'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 8, 5, 8, 9, 0, 2] [6, 8, 2, 2, 8, 5, 8, 9, 0, 2]'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Cracked! [6, 8, 2, 2, 8, 5, 8, 9, 0, 2] in 78 tries!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Runtime for this program was 0.69172 seconds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Ten billion possible combinations, and the program found a solution in only
    78 tries and in less than a second. Even James Bond would be impressed with that.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'That does it for genetic algorithms. You’ve used an example workflow to breed
    gigantic rodents, then trimmed it to hill climb through a brute-force problem
    in no time flat. If you want to continue to play digital Darwin and experiment
    with genetic algorithms, a long list of example applications can be found on Wikipedia
    (*[https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)*).
    Examples include:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Modeling global temperature changes
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-loading optimization
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery vehicle–routing optimization
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groundwater-monitoring networks
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning robot behavior
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protein folding
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rare-event analysis
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code breaking
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering for fit functions
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and signal processing
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Genetic Algorithms with Python* (Amazon Digital Services LLC, 2016) by Clinton
    Sheppard is a beginner-level introduction to genetic algorithms using Python.
    It is available in paperback or as an inexpensive ebook from *[https://leanpub.com/genetic_algorithms_with_python/](https://leanpub.com/genetic_algorithms_with_python/)*.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continue to breed super-rats and crack super-safes with these suggested projects.
    As usual with challenge projects, you’re on your own; no solutions are provided.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Rat Harem***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since a single male rat can mate with multiple females, there is no need to
    have an equal number of male and female rats. Rewrite the *super_rats.py* code
    to accommodate a variable number of male and female individuals. Then rerun the
    program with the same total number of rats as before, but use 4 males and 16 females.
    How does this impact the number of years required to reach the target weight of
    50,000 grams?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a More Efficient Safecracker***'
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As currently written, when a lock wheel match is found by the *safe_cracker.py*
    code, that match is not explicitly preserved. As long as the while loop is running,
    there’s nothing to stop a correct match from being stochastically overwritten.
    Alter the code so that the indexes for correct guesses are excluded from future
    changes. Do timing comparisons between the two versions of the code to judge the
    impact of the change.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
