- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BREEDING GIANT RATS WITH GENETIC ALGORITHMS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Genetic algorithms* are general-purpose optimization programs designed to
    solve complex problems. Invented in the 1970s, they belong to the class of *evolutionary
    algorithms*, so named because they mimic the Darwinian process of natural selection.
    They are especially useful when little is known about a problem, when you’re dealing
    with a nonlinear problem, or when searching for brute-force-type solutions in
    a large search space. Best of all, they are easy algorithms to grasp and implement.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use genetic algorithms to breed a race of super-rats
    that can terrorize the world. After that, you’ll switch sides and help James Bond
    crack a high-tech safe in a matter of seconds. These two projects should give
    you a good appreciation for the mechanics and power of genetic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Best of All Possible Solutions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Genetic algorithms *optimize*, which means that they select the best solution
    (with regard to some criteria) from a set of available alternatives. For example,
    if you’re looking for the fastest route to drive from New York to Los Angeles,
    a genetic algorithm will never suggest you fly. It can choose only from within
    an allowed set of conditions that *you* provide. As optimizers, these algorithms
    are faster than traditional methods and can avoid premature convergence to a suboptimal
    answer. In other words, they efficiently search the solution space yet do so thoroughly
    enough to avoid picking a good answer when a better one is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike *exhaustive* search engines, which use pure brute force, genetic algorithms
    don’t try every possible solution. Instead, they continuously grade solutions
    and then use them to make “informed guesses” going forward. A simple example is
    the “warmer-colder” game, where you search for a hidden item as someone tells
    you whether you are getting warmer or colder based on your proximity or search
    direction. Genetic algorithms use a fitness function, analogous to natural selection,
    to discard “colder” solutions and build on the “warmer” ones. The basic process
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Randomly generate a population of solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the fitness of each solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the best (warmest) solutions and discard the rest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cross over (recombine) elements in the best solutions to make new solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mutate a small number of elements in the solutions by changing their value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to step 2 and repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The select–cross over–mutate loop continues until it reaches a *stop condition*,
    like finding a known answer, finding a “good enough” answer (based on a minimum
    threshold), completing a set number of iterations, or reaching a time deadline.
    Because these steps closely resemble the process of evolution, complete with survival
    of the fittest, the terminology used with genetic algorithms is often more biological
    than computational.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #13: Breeding an Army of Super-Rats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s your chance to be a mad scientist with a secret lab full of boiling beakers,
    bubbling test tubes, and machines that go “BZZZTTT.” So pull on some black rubber
    gloves and get busy turning nimble trash-eating scavengers into massive man-eating
    monsters.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Use a genetic algorithm to simulate breeding rats to an average weight of 110
    pounds.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your dream is to breed a race of rats the size of bullmastiffs (we’ve already
    established that you’re mad). You’ll start with *Rattus norvegicus*, the brown
    rat, then add some artificial sweeteners, some atomic radiation from the 1950s,
    a lot of patience, and a pinch of Python, but no genetic engineering—you’re old-school,
    baby! The rats will grow from less than a pound to a terrifying 110 pounds, about
    the size of a female bullmastiff (see [Figure 7-1](ch07.xhtml#ch07fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0127-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Size comparison of a brown rat, a female bullmastiff, and a human*'
  prefs: []
  type: TYPE_NORMAL
- en: Before you embark on such a huge undertaking, it’s prudent to simulate the results
    in Python. And you’ve drawn up something better than a plan—you’ve drawn some
    graphical pseudocode (see [Figure 7-2](ch07.xhtml#ch07fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0128-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Genetic algorithm approach to breeding super-rats*'
  prefs: []
  type: TYPE_NORMAL
- en: The process shown in [Figure 7-2](ch07.xhtml#ch07fig2) outlines how a genetic
    algorithm works. Your goal is to produce a population of rats with an average
    weight of 110 pounds from an initial population weighing much less than that.
    Going forward, each population (or *generation*) of rats represents a candidate
    solution to the problem. Like any animal breeder, you cull undesirable males and
    females, which you humanely send to—for you *Austin Powers* fans—an evil petting
    zoo. You then mate and breed the remaining rats, a process known as *crossover*
    in genetic programming.
  prefs: []
  type: TYPE_NORMAL
- en: The offspring of the remaining rats will be essentially the same size as their
    parents, so you need to mutate a few. While mutation is rare and usually results
    in a neutral-to-nonbeneficial trait (low weight, in this case), sometimes you’ll
    successfully produce a bigger rat.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process then becomes a big repeating loop, whether done organically
    or programmatically, making me wonder whether we really *are* just virtual beings
    in an alien simulation. At any rate, the end of the loop—the stop condition—is
    when the rats reach the desired size or you just can’t stand dealing with rats
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: For input to your simulation, you’ll need some statistics. Use the metric system
    since you’re a scientist, mad or not. You already know that the average weight
    of a female bullmastiff is 50,000 grams, and you can find useful rat statistics
    in [Table 7-1](ch07.xhtml#ch07tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Brown Rat Weight and Breeding Statistics'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Published values** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Minimum weight | 200 grams |'
  prefs: []
  type: TYPE_TB
- en: '| Average weight (female) | 250 grams |'
  prefs: []
  type: TYPE_TB
- en: '| Average weight (male) | 300–350 grams |'
  prefs: []
  type: TYPE_TB
- en: '| Maximum weight | 600 grams* |'
  prefs: []
  type: TYPE_TB
- en: '| Number of pups per litter | 8–12 |'
  prefs: []
  type: TYPE_TB
- en: '| Litters per year | 4–13 |'
  prefs: []
  type: TYPE_TB
- en: '| Life span (wild, captivity) | 1–3 years, 4–6 years |'
  prefs: []
  type: TYPE_TB
- en: '| *Exceptional individuals may reach 1,000 grams in captivity. |'
  prefs: []
  type: TYPE_TB
- en: Because both domestic and wild brown rats exist, there may be wide variation
    in some of the stats. Rats in captivity tend to be better cared for than wild
    rats, so they weigh more, breed more, and have more pups. So you can choose from
    the higher end when a range is available. For this project, start with the assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** Input Assumptions for the Super-Rats Genetic Algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable and value** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GOAL = 50000 | Target weight in grams (female bullmastiff) |'
  prefs: []
  type: TYPE_TB
- en: '| NUM_RATS = 20 | Total number of *adult* rats your lab can support |'
  prefs: []
  type: TYPE_TB
- en: '| INITIAL_MIN_WT = 200 | Minimum weight of adult rat, in grams, in initial
    population |'
  prefs: []
  type: TYPE_TB
- en: '| INITIAL_MAX_WT = 600 | Maximum weight of adult rat, in grams, in initial
    population |'
  prefs: []
  type: TYPE_TB
- en: '| INITIAL_MODE_WT = 300 | Most common adult rat weight, in grams, in initial
    population |'
  prefs: []
  type: TYPE_TB
- en: '| MUTATE_ODDS = 0.01 | Probability of a mutation occurring in a rat |'
  prefs: []
  type: TYPE_TB
- en: '| MUTATE_MIN = 0.5 | Scalar on rat weight of least beneficial mutation |'
  prefs: []
  type: TYPE_TB
- en: '| MUTATE_MAX = 1.2 | Scalar on rat weight of most beneficial mutation |'
  prefs: []
  type: TYPE_TB
- en: '| LITTER_SIZE = 8 | Number of pups per pair of mating rats |'
  prefs: []
  type: TYPE_TB
- en: '| LITTERS_PER_YEAR = 10 | Number of litters per year per pair of mating rats
    |'
  prefs: []
  type: TYPE_TB
- en: '| GENERATION_LIMIT = 500 | Generational cutoff to stop breeding program |'
  prefs: []
  type: TYPE_TB
- en: Since rats breed so frequently, you shouldn’t have to factor in life span. Even
    though you will retain some of the parents from a previous generation, they will
    be culled out quickly as their offspring increase in weight from generation to
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Super-Rats Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *super_rats.py* code follows the general workflow in [Figure 7-2](ch07.xhtml#ch07fig2).
    You can also download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entering the Data and Assumptions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.xhtml#ch07list1), in the global space at the start of the
    program, imports modules and assigns the statistics, scalars, and assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2) as constants. Once the program is complete
    and working, feel free to experiment with the values in that table and see how
    they affect your results.'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: import statistics
  prefs: []
  type: TYPE_NORMAL
- en: '➋ # CONSTANTS (weights in grams)'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ GOAL = 50000
  prefs: []
  type: TYPE_NORMAL
- en: NUM_RATS = 20
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MIN_WT = 200
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MAX_WT = 600
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MODE_WT = 300
  prefs: []
  type: TYPE_NORMAL
- en: MUTATE_ODDS = 0.01
  prefs: []
  type: TYPE_NORMAL
- en: MUTATE_MIN = 0.5
  prefs: []
  type: TYPE_NORMAL
- en: MUTATE_MAX = 1.2
  prefs: []
  type: TYPE_NORMAL
- en: LITTER_SIZE = 8
  prefs: []
  type: TYPE_NORMAL
- en: LITTERS_PER_YEAR = 10
  prefs: []
  type: TYPE_NORMAL
- en: GENERATION_LIMIT = 500
  prefs: []
  type: TYPE_NORMAL
- en: '# ensure even-number of rats for breeding pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if NUM_RATS % 2 != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: NUM_RATS += 1
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-1: Imports modules and assigns constants*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the time, random, and statistics modules ➊. You’ll use the
    time module to record the runtime of your genetic algorithm. It’s interesting
    to time genetic algorithms, if only to be awed by how quickly they can find a
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The random module will satisfy the stochastic needs of the algorithm, and you’ll
    use the statistics module to get mean values. This is a weak use for statistics,
    but I want you to be aware of the module, since it can be quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign the input variables described in [Table 7-2](ch07.xhtml#ch07tab2)
    and be sure to note that the units are grams ➋. Use uppercase letters for the
    names, as these represent constants ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we’re going to assume the use of breeding *pairs*, so check that
    the user input an even number of rats and, if not, add a rat ➍. Later, in “[Challenge
    Projects](ch07.xhtml#lev167)” on [page 144](ch07.xhtml#page_144), you’ll get to
    experiment with alternative gender distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing the Population**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-2](ch07.xhtml#ch07list2) is the program’s shopping representative.
    It goes to a pet shop and picks out the rats for an initial breeding population.
    Since you want mating pairs, it should choose an even number of rats. And since
    you can’t afford one of those fancy volcano lairs with unlimited space, you’ll
    need to maintain a constant number of adult rats through each generation—though
    the number can swell temporarily to accommodate litters. Remember, the rats will
    need more and more space as they grow to the size of big dogs!'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def populate(num_rats, min_wt, max_wt, mode_wt):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Initialize a population with a triangular distribution of weights."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ return [int(random.triangular(min_wt, max_wt, mode_wt))\
  prefs: []
  type: TYPE_NORMAL
- en: for i in range(num_rats)]
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-2: Defines the function that creates the initial rat population*'
  prefs: []
  type: TYPE_NORMAL
- en: The populate() function needs to know the amount of adult rats you want, the
    minimum and maximum weights for the rats, and the most commonly occurring weight
    ➊. Note that all of these arguments will use constants found in the global space.
    You don’t have to pass these as arguments for the function to access them. But
    I do so here and in the functions that follow, for clarity and because local variables
    are accessed more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the four arguments above with the random module, which includes different
    types of distributions. You’ll use a triangular distribution here, because it
    gives you firm control of the minimum and maximum sizes and lets you model skewness
    in the statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Because brown rats exist both in the wild and in captivity—in zoos, labs, and
    as pets—their weights are skewed to the high side. Wild rats tend to be smaller
    as their lives are nasty, brutish, and short, though lab rats may contest that
    point! Use list comprehension to loop through the number of rats and assign each
    one a weight. Bundle it all together with the return statement ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**Measuring the Fitness of the Population**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Measuring the fitness of the rats is a two-step process. First, grade the whole
    population by comparing the average weight of all the rats to the bullmastiff
    target. Then, grade each individual rat. Only rats whose weight ranks in the upper
    *n* percent, as determined by the NUM_RATS variable, get to breed again. Although
    the average weight of the population is a valid fitness measurement, its primary
    role here is to determine whether it’s time to stop looping and declare success.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-3](ch07.xhtml#ch07list3) defines the fitness() and select() functions,
    which together form the measurement portion of your genetic algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def fitness(population, goal):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Measure population fitness based on an attribute mean vs target."""'
  prefs: []
  type: TYPE_NORMAL
- en: ave = statistics.mean(population)
  prefs: []
  type: TYPE_NORMAL
- en: return ave / goal
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def select(population, to_retain):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Cull a population to retain only a specified number of members."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ sorted_population = sorted(population)
  prefs: []
  type: TYPE_NORMAL
- en: ➍ to_retain_by_sex = to_retain//2
  prefs: []
  type: TYPE_NORMAL
- en: ➎ members_per_sex = len(sorted_population)//2
  prefs: []
  type: TYPE_NORMAL
- en: ➏ females = sorted_population[:members_per_sex]
  prefs: []
  type: TYPE_NORMAL
- en: males = sorted_population[members_per_sex:]
  prefs: []
  type: TYPE_NORMAL
- en: ➐ selected_females = females[-to_retain_by_sex:]
  prefs: []
  type: TYPE_NORMAL
- en: selected_males = males[-to_retain_by_sex:]
  prefs: []
  type: TYPE_NORMAL
- en: ➑ return selected_males, selected_females
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-3: Defines the measurement step of the genetic algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to grade the fitness of the current generation ➊. Use the
    statistics module to get the mean of the population and return this value divided
    by the target weight. When this value is equal to or greater than 1, you’ll know
    it’s time to stop breeding.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function that culls a population of rats, based on weight, down
    to the NUM_RATS value, represented here by the to_retain parameter ➋. It will
    also take a population argument, which will be the parents of each generation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, sort the population so you can distinguish large from small ➌. Take the
    number of rats you want to retain and divide it by 2 using floor division so that
    the result is an integer ➍. Do this step so you can keep the biggest male and
    female rats. If you choose only the largest rats in the population, you will theoretically
    be choosing only males. You obtain the total members of the current population,
    by sex, by dividing the sorted_population by 2, again using floor division ➎.
  prefs: []
  type: TYPE_NORMAL
- en: 'Male rats tend to be larger than females, so make two simplifying assumptions:
    first, assume that exactly half of the population is female and, second, that
    the largest female rat is no heavier than the smallest male rat. This means that
    the first half of the sorted population list represents females and the last half
    represents males. Then create two new lists by splitting sorted_population in
    half, taking the bottom half for females ➏ and the upper half for males. Now all
    that’s left to do is take the biggest rats from the end of each of these lists
    ➐—using negative slicing—and return them ➑. These two lists contain the parents
    of the next generation.'
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run this function, all it will do is sort the rats by sex,
    as the initial number of rats already equals the NUM_RATS constant. After that,
    the incoming population argument will include both parents and children, and its
    value will exceed NUM_RATS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Breeding a New Generation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-4](ch07.xhtml#ch07list4) defines the program’s “crossover” step,
    which means it breeds the next generation. A key assumption is that the weight
    of every child will be greater than or equal to the weight of the mother and less
    than or equal to the weight of the father. Exceptions to that rule will be handled
    in the “mutation” function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 4'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def breed(males, females, litter_size):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Crossover genes among members (weights) of a population."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ random.shuffle(males)
  prefs: []
  type: TYPE_NORMAL
- en: random.shuffle(females)
  prefs: []
  type: TYPE_NORMAL
- en: ➌ children = []
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for male, female in zip(males, females):'
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for child in range(litter_size):'
  prefs: []
  type: TYPE_NORMAL
- en: ➏ child = random.randint(female, male)
  prefs: []
  type: TYPE_NORMAL
- en: ➐ children.append(child)
  prefs: []
  type: TYPE_NORMAL
- en: ➑ return children
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-4: Defines the function that breeds a new generation of rats*'
  prefs: []
  type: TYPE_NORMAL
- en: The breed() function takes as arguments the lists of weights of selected males
    and females returned from the select() function along with the size of a litter
    ➊. Next, randomly shuffle the two lists ➋, because you sorted them in the select()
    function and iterating over them without shuffling would result in the smallest
    male being paired with the smallest female, and so on. You need to allow for love
    and romance; the largest male may be drawn to the most petite female!
  prefs: []
  type: TYPE_NORMAL
- en: Start an empty list to hold their children ➌. Now for the hanky-panky. Go through
    the shuffled lists using zip() to pair a male and female from each list ➍. Each
    pair of rats can have multiple children, so start another loop that uses the litter
    size as a range ➎. The litter size is a constant, called LITTER_SIZE, that you
    provided in the input parameters, so if the value is 8, you’ll get eight children.
  prefs: []
  type: TYPE_NORMAL
- en: For each child, choose a weight at random between the mother’s and father’s
    weights ➏. Note that you don’t need to use male + 1, because randint() uses *all*
    the numbers in the supplied range. Note also that the two values can be the same,
    but the first value (the mother’s weight) can never be larger than the second
    (the father’s weight). This is another reason for the simplifying assumption that
    females must be no larger than the smallest male. End the loop by appending each
    child to the list of children ➐, then return children ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutating the Population**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A small percentage of the children should experience mutations, and most of
    these should result in traits that are nonbeneficial. That means lower-than-expected
    weights, including “runts” that would not survive. But every so often, a beneficial
    mutation will result in a heavier rat.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](ch07.xhtml#ch07list5) defines the mutate() function, which applies
    the mutation assumptions you supplied in the list of constants. After mutate()
    is called, it will be time to check the fitness of the new population and start
    the loop over if the target weight hasn’t been reached.'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 5'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def mutate(children, mutate_odds, mutate_min, mutate_max):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Randomly alter rat weights using input odds & fractional changes."""'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ for index, rat in enumerate(children):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if mutate_odds >= random.random():'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ children[index] = round(rat * random.uniform(mutate_min,
  prefs: []
  type: TYPE_NORMAL
- en: mutate_max))
  prefs: []
  type: TYPE_NORMAL
- en: return children
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-5: Defines the function that mutates a small portion of the population*'
  prefs: []
  type: TYPE_NORMAL
- en: The function needs the list of children, the odds of a mutation occurring, and
    the minimum and maximum impacts of a mutation ➊. The impacts are scalars that
    you’ll apply to the weight of a rat. In your list of constants at the start of
    the program (and in [Table 7-2](ch07.xhtml#ch07tab2)), they are skewed to the
    minimum side, as most mutations do not result in beneficial traits.
  prefs: []
  type: TYPE_NORMAL
- en: Loop through the list of children and use enumerate()—a handy built-in function
    that acts as an automatic counter—to get an index ➋. Then use the random() method
    to generate a random number between 0 and 1 and compare it to the odds of a mutation
    occurring.
  prefs: []
  type: TYPE_NORMAL
- en: If the mutate_odds variable is greater than or equal to the randomly generated
    number, the rat (weight) at that index is mutated. Choose a mutation value from
    a uniform distribution defined by the minimum and maximum mutation values; this
    basically selects a value at random from the min-max range. As these values are
    skewed to the minimum, the outcome is more likely to be a loss in weight than
    a gain. Multiply the current weight by this mutation scalar and round it to an
    integer ➌. Finish by returning the mutated children list.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*With regard to the validity of mutation statistics, you can find studies that
    suggest beneficial mutations are very rare and others that suggest they are more
    common than we realize. The breeding of dogs has shown that achieving drastic
    variations in size (for example, Chihuahuas vs. Great Danes) doesn’t require millions
    of years of evolution. In a famous 20th-century study, Russian geneticist Dmitry
    Belyayev started with 130 silver foxes and, over a 40-year period, succeeded in
    achieving dramatic physiological changes by simply selecting the tamest foxes
    in each generation.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-6](ch07.xhtml#ch07list6) defines the main() function, which manages
    the other functions and determines when you’ve met the stop condition. It will
    also display all the important results.'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Initialize population, select, breed, and mutate, display results."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ generations = 0
  prefs: []
  type: TYPE_NORMAL
- en: ➋ parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,
  prefs: []
  type: TYPE_NORMAL
- en: INITIAL_MODE_WT)
  prefs: []
  type: TYPE_NORMAL
- en: print("initial population weights = {}".format(parents))
  prefs: []
  type: TYPE_NORMAL
- en: popl_fitness = fitness(parents, GOAL)
  prefs: []
  type: TYPE_NORMAL
- en: print("initial population fitness = {}".format(popl_fitness))
  prefs: []
  type: TYPE_NORMAL
- en: print("number to retain = {}".format(NUM_RATS))
  prefs: []
  type: TYPE_NORMAL
- en: ➌ ave_wt = []
  prefs: []
  type: TYPE_NORMAL
- en: '➍ while popl_fitness < 1 and generations < GENERATION_LIMIT:'
  prefs: []
  type: TYPE_NORMAL
- en: selected_males, selected_females = select(parents, NUM_RATS)
  prefs: []
  type: TYPE_NORMAL
- en: children = breed(selected_males, selected_females, LITTER_SIZE)
  prefs: []
  type: TYPE_NORMAL
- en: children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)
  prefs: []
  type: TYPE_NORMAL
- en: ➎ parents = selected_males + selected_females + children
  prefs: []
  type: TYPE_NORMAL
- en: popl_fitness = fitness(parents, GOAL)
  prefs: []
  type: TYPE_NORMAL
- en: ➏ print("Generation {} fitness = {:.4f}".format(generations,
  prefs: []
  type: TYPE_NORMAL
- en: popl_fitness))
  prefs: []
  type: TYPE_NORMAL
- en: ➐ ave_wt.append(int(statistics.mean(parents)))
  prefs: []
  type: TYPE_NORMAL
- en: generations += 1
  prefs: []
  type: TYPE_NORMAL
- en: ➑ print("average weight per generation = {}".format(ave_wt))
  prefs: []
  type: TYPE_NORMAL
- en: print("\nnumber of generations = {}".format(generations))
  prefs: []
  type: TYPE_NORMAL
- en: print("number of years = {}".format(int(generations / LITTERS_PER_YEAR)))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-6: Defines the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start the function by initializing an empty list to hold the number of generations.
    You’ll eventually use this to figure out how many years it took to achieve your
    goal ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the populate() function ➋ and immediately print the results. Then,
    get the fitness of your initial population and print this along with the number
    of rats to retain each generation, which is the NUM_RATS constant.
  prefs: []
  type: TYPE_NORMAL
- en: For fun, initialize a list to hold the average weight of each generation so
    you can view it at the end ➌. If you plot these weights against the number of
    years, you’ll see that the trend is exponential.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the big genetic loop of select-mate-mutate. This is in the form of
    a while loop, with the stop conditions being either reaching the target weight
    or reaching a large number of generations without achieving the target weight
    ➍. Note that after mutating the children, you need to combine them with their
    parents to make a new parents list ➎. It takes the pups about five weeks to mature
    and start breeding, but you can account for this by adjusting the LITTERS_PER_YEAR
    constant down from the maximum possible value (see [Table 7-1](ch07.xhtml#ch07tab1)),
    as we’ve done here.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of each loop, display the results of the fitness() function to four
    decimal places so you can monitor the algorithm and ensure it is progressing as
    expected ➏. Get the average weight of the generation, append it to the ave_wt
    list ➐, and then advance the generation count by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Complete the main() function by displaying the list of average weights per generation,
    the number of generations, and the number of years—calculated using the LITTERS_PER_YEAR
    variable ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Running the main() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finish up with the familiar conditional statement for running the program either
    stand-alone or as a module. Get the ending time and print how long it took the
    program to run. The performance information should print only when the module
    is run in stand-alone mode, so be sure to place it under the if clause. See [Listing
    7-7](ch07.xhtml#ch07list7).
  prefs: []
  type: TYPE_NORMAL
- en: '*super_rats.py,* part 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: duration = end_time - start_time
  prefs: []
  type: TYPE_NORMAL
- en: print("\nRuntime for this program was {} seconds.".format(duration))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-7: Runs the* main() *function and* time *module if the program isn’t
    imported*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the parameters in [Table 7-2](ch07.xhtml#ch07tab2), the *super_rats.py*
    program will take about two seconds to run. On average, it will take the rats
    about 345 generations, or 34.5 years, to reach the target weight of 110 pounds.
    That’s a long time for a mad scientist to stay mad! But armed with your program,
    you can look for ways to reduce the time to target.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sensitivity studies* work by making multiple changes to a *single* variable
    and judging the results. You should take care in the event some variables are
    dependent on one another. And since the results are stochastic (random), you should
    make multiple runs with each parameter change in order to capture the range of
    possible outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: Two things you can control in your breeding program are the number of breeding
    rats (NUM_RATS) and the odds of a mutation occurring (MUTATE_ODDS). The mutation
    odds are influenced by factors like diet and exposure to radiation. If you change
    these variables one at a time and rerun *super_rats.py*, you can judge the impact
    of each variable on the project timeline.
  prefs: []
  type: TYPE_NORMAL
- en: An immediate observation is that, if you start with small values for each variable
    and slowly increase them, you get dramatic initial results (see [Figure 7-3](ch07.xhtml#ch07fig3)).
    After that, both curves decline rapidly and flatten out in a classic example of
    diminishing returns. The point where each curve flattens is the key to optimally
    saving money and reducing work.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you get very little benefit from retaining more than about 300
    rats. You’d just be feeding and caring for a lot of superfluous rats. Likewise,
    trying to boost the odds of a mutation above 0.3 gains you little.
  prefs: []
  type: TYPE_NORMAL
- en: With charts like these, it’s easy to plan a path forward. The horizontal dotted
    line marked “Baseline” represents the average result of using the input in [Table
    7-2](ch07.xhtml#ch07tab2). You can potentially reduce this time by over 10 years
    just by retaining 50 rats rather than 20\. You should also focus on increasing
    the number of beneficial mutations. This will be more rewarding, but riskier and
    harder to control.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0137-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Impact of two parameters on the time required to reach the target
    weight*'
  prefs: []
  type: TYPE_NORMAL
- en: If you rerun the simulation using 50 rats and bumping the odds of mutation up
    to 0.05, you can theoretically complete the project in 14 years, an improvement
    of 246 percent over the initial baseline. Now *that’s* optimization!
  prefs: []
  type: TYPE_NORMAL
- en: Breeding super-rats was a fun and simple way to understand the basics of genetic
    algorithms. But to truly appreciate their power, you need to attempt something
    harder. You need a brute-force problem that’s too big to brute-force, and the
    next project is that kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #14: Cracking a High-Tech Safe**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You are Q, and James Bond has a problem. He has to attend an elegant dinner
    party at a villain’s mansion, slip away to the man’s private office, and crack
    his wall safe. Child’s play for 007, except for one thing: it’s a Humperdink BR549
    digital safe that takes 10 digits, yielding 10 billion possible combinations.
    And the lock wheels don’t start turning until *after* all the numbers have been
    entered. There’ll be no putting a stethoscope to this safe and slowly turning
    a dial!'
  prefs: []
  type: TYPE_NORMAL
- en: As Q, you already have an autodialer device that can brute-force its way through
    all possible solutions, but Bond simply won’t have time to use it. Here’s why.
  prefs: []
  type: TYPE_NORMAL
- en: A combination lock should really be called a *permutation* lock, because it
    requires *ordered* combinations, which are, by definition, permutations. More
    specifically, locks rely on *permutations with repetition*. For example, a valid—though
    insecure—combination could be 999999999.
  prefs: []
  type: TYPE_NORMAL
- en: 'You used the itertools module’s permutations() iterator when working with anagrams
    in [Chapter 3](ch03.xhtml#ch03) and in “[Practice Projects](ch04.xhtml#lev106)”
    on [page 87](ch04.xhtml#page_87) in [Chapter 4](ch04.xhtml#ch04), but that won’t
    help here because permutations() returns permutations *without* repetition. To
    generate the right kind of permutation for a lock, you need to use itertools’s
    product() iterator, which calculates the Cartesian product from multiple sets
    of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from itertools import product'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> combo = (1, 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for perm in product(combo, repeat=2):'
  prefs: []
  type: TYPE_NORMAL
- en: print(perm)
  prefs: []
  type: TYPE_NORMAL
- en: (1, 1)
  prefs: []
  type: TYPE_NORMAL
- en: (1, 2)
  prefs: []
  type: TYPE_NORMAL
- en: (2, 1)
  prefs: []
  type: TYPE_NORMAL
- en: (2, 2)
  prefs: []
  type: TYPE_NORMAL
- en: The optional repeat keyword argument lets you take the product of an iterable
    multiplied by itself, as you need to do in this case. Note that the product()
    function returns all the possible combinations, whereas the permutations() function
    would return only (1, 2) and (2, 1). You can read more about product() at *[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-8](ch07.xhtml#ch07list8) is a Python program, called *brute_force_cracker.py*,
    that uses product() to brute-force its way to the right combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '*brute_force_cracker.py*'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import product
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: ➋ combo = (9, 9, 7, 6, 5, 4, 3)
  prefs: []
  type: TYPE_NORMAL
- en: '# use Cartesian product to generate permutations with repetition'
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):'
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if perm == combo:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Cracked! {} {}".format(combo, perm))
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: ➎ print("\nRuntime for this program was {} seconds.".format
  prefs: []
  type: TYPE_NORMAL
- en: (end_time - start_time))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-8: Uses a brute-force method to find a safe’s combination*'
  prefs: []
  type: TYPE_NORMAL
- en: Import time and the product iterator from itertools ➊. Get the start time, and
    then enter the safe combination as a tuple ➋. Next use product(), which returns
    tuples of all the permutations with repetition for a given sequence. The sequence
    contains all the valid single-digit entries (0–9). You should set the repeat argument
    to the number of digits in the combination ➌. Compare each result to the combination
    and print "Cracked!" if they match, along with the combination and matching permutation
    ➍. Finish by displaying the runtime ➎.
  prefs: []
  type: TYPE_NORMAL
- en: This works great for combinations up to eight digits long. After that, the wait
    becomes increasingly uncomfortable. [Table 7-3](ch07.xhtml#ch07tab3) is a record
    of runtimes for the program versus number of digits in the combination.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** Runtimes Versus Digits in Combination (2.3 GHz Processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number of digits** | **Runtime in seconds** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0.035 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0.147 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1.335 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 12.811 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 133.270 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1396.955 |'
  prefs: []
  type: TYPE_TB
- en: Notice that adding a number to the combination increases the runtime by an order
    of magnitude. This is an exponential increase. With 9 digits, you’d wait over
    2 minutes for an answer. With 10 digits, over 20 minutes! That’s a long time for
    Bond to take an unnoticed “bathroom break.”
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you’re Q, and you know about genetic algorithms. All you need is
    some way to judge the fitness of each candidate combination. Options include monitoring
    fluctuations in power consumption, measuring time delays in operations, and listening
    for sounds. Let’s assume use of a sound-amplifying tool, along with a tool to
    prevent lockouts after a few incorrect combinations have been entered. Because
    of the safeguards in the BR549 safe, a sound tool can initially tell you only
    *how many* digits are correct, not *which* digits, but with very little time,
    your algorithm can zero in on the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Use a genetic algorithm to quickly find a safe’s combination in a large search
    space.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The strategy here is straightforward. You’ll generate a sequence of 10 numbers
    at random and compare it to the real combination, grading the result based on
    matches; in the real world, you’d find the number of matches using the sound detector
    clamped to the door of the safe. You then change one value in your solution and
    compare again. If another match is found, you throw away the old sequence and
    move forward with the new; otherwise, you keep the old sequence and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Since one solution completely replaces the other, this represents 100 percent
    crossover of genetic material, so you are essentially using just selection and
    mutation. Selection plus mutation alone generates a robust *hill-climbing* algorithm.
    Hill climbing is an optimization technique that starts with an arbitrary solution
    and changes (mutates) a single value in the solution. If the result is an improvement,
    the new solution is kept and the process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: A problem with hill climbing is that the algorithm can get stuck in *local*
    minima or maxima and not find the optimal *global* value. Imagine you are looking
    for the lowest value in the wavelike function in [Figure 7-4](ch07.xhtml#ch07fig4).
    The current best guess is marked by the large black dot. If the magnitude of the
    change you are making (mutation) is too small to “escape” the local trough, the
    algorithm won’t find the true low point. From the algorithm’s point of view, because
    every direction results in a worse answer, it must have found the true answer.
    So it prematurely converges on a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0140-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Example of a hill-climbing algorithm “stuck” in a local minimum*'
  prefs: []
  type: TYPE_NORMAL
- en: Using crossover in genetic algorithms helps to avoid premature convergence problems,
    as does allowing for relatively large mutations. Because you’re not worried about
    honoring biological realism here, the mutation space can encompass every possible
    value in the combination. That way you can’t get stuck, and hill climbing is an
    acceptable approach.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Safecracker Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *safe_cracker.py* code takes a combination of *n* digits and uses hill climbing
    to reach the combination from a random starting point. The code can be downloaded
    from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up and Defining the fitness() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-9](ch07.xhtml#ch07list9) imports the necessary modules and defines
    the fitness() function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*safe_cracker.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import time
  prefs: []
  type: TYPE_NORMAL
- en: from random import randint, randrange
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def fitness(combo, attempt):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Compare items in two lists and count number of matches."""'
  prefs: []
  type: TYPE_NORMAL
- en: grade = 0
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for i, j in zip(combo, attempt):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if i == j:'
  prefs: []
  type: TYPE_NORMAL
- en: grade += 1
  prefs: []
  type: TYPE_NORMAL
- en: return grade
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-9: Imports modules and defines the* fitness() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: After importing some familiar modules ➊, define a fitness() function that takes
    the true combination and an attempted solution as arguments ➋. Name a variable
    grade and set it to 0. Then use zip() to iterate through each element in the combination
    and your attempt ➌. If they’re the same, add 1 to grade and return it. Note that
    you aren’t recording the index that matches, just that the function has found
    a match. This emulates output from the sound detection device. All it can tell
    you initially is how many lock wheels turned, not their locations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining and Running the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since this is a short and simple program, most of the algorithm is run in the
    main() function, [Listing 7-10](ch07.xhtml#ch07list10), rather than in multiple
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '*safe_cracker.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Use hill-climbing algorithm to solve lock combination."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ combination = '6822858902'
  prefs: []
  type: TYPE_NORMAL
- en: print("Combination = {}".format(combination))
  prefs: []
  type: TYPE_NORMAL
- en: '# convert combination to list:'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ combo = [int(i) for i in combination]
  prefs: []
  type: TYPE_NORMAL
- en: '# generate guess & grade fitness:'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ best_attempt = [0] * len(combo)
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt_grade = fitness(combo, best_attempt)
  prefs: []
  type: TYPE_NORMAL
- en: ➍ count = 0
  prefs: []
  type: TYPE_NORMAL
- en: '# evolve guess'
  prefs: []
  type: TYPE_NORMAL
- en: '➎ while best_attempt != combo:'
  prefs: []
  type: TYPE_NORMAL
- en: '# crossover'
  prefs: []
  type: TYPE_NORMAL
- en: ➏ next_try = best_attempt[:]
  prefs: []
  type: TYPE_NORMAL
- en: '# mutate'
  prefs: []
  type: TYPE_NORMAL
- en: lock_wheel = randrange(0, len(combo))
  prefs: []
  type: TYPE_NORMAL
- en: ➐ next_try[lock_wheel] = randint(0, 9)
  prefs: []
  type: TYPE_NORMAL
- en: '# grade & select'
  prefs: []
  type: TYPE_NORMAL
- en: ➑ next_try_grade = fitness(combo, next_try)
  prefs: []
  type: TYPE_NORMAL
- en: 'if next_try_grade > best_attempt_grade:'
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt = next_try[:]
  prefs: []
  type: TYPE_NORMAL
- en: best_attempt_grade = next_try_grade
  prefs: []
  type: TYPE_NORMAL
- en: print(next_try, best_attempt)
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: ➒ print("Cracked! {}".format(best_attempt), end=' ')
  prefs: []
  type: TYPE_NORMAL
- en: print("in {} tries!".format(count))
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: duration = end_time - start_time
  prefs: []
  type: TYPE_NORMAL
- en: ➓ print("\nRuntime for this program was {:.5f} seconds.".format(duration))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-10: Defines the* main() *function and runs and times the program
    if it hasn’t been imported*'
  prefs: []
  type: TYPE_NORMAL
- en: Provide the true combination as a variable ➊ and use list comprehension to convert
    it into a list for convenience going forward ➋. Generate a list of zeros equal
    in length to the combination and name it best_attempt ➌. At this point, any combination
    is as good as any other. You should retain this name—best_attempt—because you
    need to preserve only the best solution as you climb the hill. Once you’ve generated
    the initial attempt, grade it with the fitness() function and then assign the
    value to a variable, called best_attempt_grade.
  prefs: []
  type: TYPE_NORMAL
- en: Start a count variable at zero. The program will use this variable to record
    how many attempts it took to crack the code ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start a while loop that continues until you’ve found the combination ➎.
    Assign a *copy* of best_attempt to a next_try variable ➏. You copy it so you don’t
    run into aliasing problems; when you alter an element in next_try, you don’t want
    to accidentally change best_attempt, because you may continue to use it in the
    event next_try fails the fitness test.
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to mutate the copy. Each digit in the combination turns a lock
    wheel in the safe, so name a variable lock_wheel and randomly set it equal to
    an index location in the combination. This represents the location of the single
    element to change in this iteration. Next, randomly choose a digit and use it
    to replace the value at the location indexed by lock_wheel ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Grade next_try, and if it’s fitter than the previous attempt, reset both best_attempt
    and best_attempt_grade to the new values ➑. Otherwise, best_attempt will remain
    unchanged for the next iteration. Print both next_try and best_attempt, side by
    side, so you can scroll through the attempts when the program ends and see how
    they evolved. Finish the loop by advancing the counter.
  prefs: []
  type: TYPE_NORMAL
- en: When the program finds the combination, display the best_attempt value and the
    number of tries it took to find it ➒. Remember, the end=' ' argument prevents
    a carriage return at the end of the printed line and places a space between the
    end of the current line and the beginning of the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Complete the program with the conditional statement for running main() stand-alone
    and display the runtime to five decimal places ➓. Note that the timing code comes
    after the conditional, and thus will not run if the program is imported as a module.
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last few lines of output from the *safe_cracker.py* program are shown here.
    I’ve omitted most of the evolving comparisons for brevity. The run was for a 10-digit
    combination.
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 6, 2, 0, 5, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 0, 9, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 8, 5, 8, 9, 0, 0] [6, 8, 2, 2, 8, 5, 8, 9, 0, 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 8, 2, 2, 8, 5, 8, 9, 0, 2] [6, 8, 2, 2, 8, 5, 8, 9, 0, 2]'
  prefs: []
  type: TYPE_NORMAL
- en: Cracked! [6, 8, 2, 2, 8, 5, 8, 9, 0, 2] in 78 tries!
  prefs: []
  type: TYPE_NORMAL
- en: Runtime for this program was 0.69172 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Ten billion possible combinations, and the program found a solution in only
    78 tries and in less than a second. Even James Bond would be impressed with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'That does it for genetic algorithms. You’ve used an example workflow to breed
    gigantic rodents, then trimmed it to hill climb through a brute-force problem
    in no time flat. If you want to continue to play digital Darwin and experiment
    with genetic algorithms, a long list of example applications can be found on Wikipedia
    (*[https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)*).
    Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling global temperature changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-loading optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery vehicle–routing optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groundwater-monitoring networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning robot behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protein folding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rare-event analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code breaking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering for fit functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and signal processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Genetic Algorithms with Python* (Amazon Digital Services LLC, 2016) by Clinton
    Sheppard is a beginner-level introduction to genetic algorithms using Python.
    It is available in paperback or as an inexpensive ebook from *[https://leanpub.com/genetic_algorithms_with_python/](https://leanpub.com/genetic_algorithms_with_python/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continue to breed super-rats and crack super-safes with these suggested projects.
    As usual with challenge projects, you’re on your own; no solutions are provided.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Rat Harem***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since a single male rat can mate with multiple females, there is no need to
    have an equal number of male and female rats. Rewrite the *super_rats.py* code
    to accommodate a variable number of male and female individuals. Then rerun the
    program with the same total number of rats as before, but use 4 males and 16 females.
    How does this impact the number of years required to reach the target weight of
    50,000 grams?
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a More Efficient Safecracker***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As currently written, when a lock wheel match is found by the *safe_cracker.py*
    code, that match is not explicitly preserved. As long as the while loop is running,
    there’s nothing to stop a correct match from being stochastically overwritten.
    Alter the code so that the indexes for correct guesses are excluded from future
    changes. Do timing comparisons between the two versions of the code to judge the
    impact of the change.
  prefs: []
  type: TYPE_NORMAL
