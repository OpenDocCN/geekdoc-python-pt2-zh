- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: BREEDING GIANT RATS WITH GENETIC ALGORITHMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用遗传算法培育巨型大鼠**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: '*Genetic algorithms* are general-purpose optimization programs designed to
    solve complex problems. Invented in the 1970s, they belong to the class of *evolutionary
    algorithms*, so named because they mimic the Darwinian process of natural selection.
    They are especially useful when little is known about a problem, when you’re dealing
    with a nonlinear problem, or when searching for brute-force-type solutions in
    a large search space. Best of all, they are easy algorithms to grasp and implement.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*遗传算法*是一种通用的优化程序，旨在解决复杂问题。它们于1970年代发明，属于*进化算法*的一类，因其模仿达尔文自然选择的过程而得名。它们特别适用于当问题了解不多、面对非线性问题或需要在大型搜索空间中寻找暴力解决方案时。最棒的是，它们是易于理解和实现的算法。'
- en: In this chapter, you’ll use genetic algorithms to breed a race of super-rats
    that can terrorize the world. After that, you’ll switch sides and help James Bond
    crack a high-tech safe in a matter of seconds. These two projects should give
    you a good appreciation for the mechanics and power of genetic algorithms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用遗传算法培育一种超级大鼠军队，来让它们在世界范围内造成恐慌。之后，你将转换角色，帮助詹姆斯·邦德在几秒钟内破解一个高科技保险箱。这两个项目将帮助你很好地理解遗传算法的机制和强大之处。
- en: '**Finding the Best of All Possible Solutions**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找所有可能解中的最佳解**'
- en: Genetic algorithms *optimize*, which means that they select the best solution
    (with regard to some criteria) from a set of available alternatives. For example,
    if you’re looking for the fastest route to drive from New York to Los Angeles,
    a genetic algorithm will never suggest you fly. It can choose only from within
    an allowed set of conditions that *you* provide. As optimizers, these algorithms
    are faster than traditional methods and can avoid premature convergence to a suboptimal
    answer. In other words, they efficiently search the solution space yet do so thoroughly
    enough to avoid picking a good answer when a better one is available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法*优化*，意味着它们从一组可用的备选方案中选择最佳解（根据某些标准）。例如，如果你在寻找从纽约到洛杉矶的最快驾车路线，遗传算法永远不会建议你飞行。它只能从你提供的条件中选择。在优化过程中，这些算法比传统方法更快，并能避免过早收敛到次优解。换句话说，它们高效地搜索解空间，同时又足够全面，以避免选择一个好的答案而错过更好的答案。
- en: 'Unlike *exhaustive* search engines, which use pure brute force, genetic algorithms
    don’t try every possible solution. Instead, they continuously grade solutions
    and then use them to make “informed guesses” going forward. A simple example is
    the “warmer-colder” game, where you search for a hidden item as someone tells
    you whether you are getting warmer or colder based on your proximity or search
    direction. Genetic algorithms use a fitness function, analogous to natural selection,
    to discard “colder” solutions and build on the “warmer” ones. The basic process
    is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与*穷举*搜索引擎不同，后者通过纯粹的暴力方式尝试每一个可能的解，遗传算法并不会尝试所有可能的解。相反，它们会不断地对解进行评分，然后利用这些评分来进行“有根据的猜测”。一个简单的例子是“温暖-寒冷”游戏，在游戏中你通过别人根据你接近或搜索方向的提示，告诉你是越来越接近目标（温暖）还是远离目标（寒冷）。遗传算法使用适应度函数，类似于自然选择的过程，来丢弃“寒冷”的解，并在“温暖”的解上进行改进。基本过程如下：
- en: Randomly generate a population of solutions.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机生成一组解的种群。
- en: Measure the fitness of each solution.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 衡量每个解的适应度。
- en: Select the best (warmest) solutions and discard the rest.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最佳（最温暖）的解并丢弃其他解。
- en: Cross over (recombine) elements in the best solutions to make new solutions.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交叉（重组）最佳解中的元素，生成新的解。
- en: Mutate a small number of elements in the solutions by changing their value.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过改变解中一些元素的值来进行突变。
- en: Return to step 2 and repeat.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回第2步并重复。
- en: The select–cross over–mutate loop continues until it reaches a *stop condition*,
    like finding a known answer, finding a “good enough” answer (based on a minimum
    threshold), completing a set number of iterations, or reaching a time deadline.
    Because these steps closely resemble the process of evolution, complete with survival
    of the fittest, the terminology used with genetic algorithms is often more biological
    than computational.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择-交叉-突变的循环会继续，直到达到一个*停止条件*，比如找到已知的答案，找到一个“足够好”的答案（基于最低阈值），完成指定的迭代次数，或达到时间截止。由于这些步骤与进化过程非常相似，完全符合适者生存的原则，因此遗传算法中使用的术语通常比计算术语更加生物学化。
- en: '**Project #13: Breeding an Army of Super-Rats**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #13：培育超级大鼠军团**'
- en: Here’s your chance to be a mad scientist with a secret lab full of boiling beakers,
    bubbling test tubes, and machines that go “BZZZTTT.” So pull on some black rubber
    gloves and get busy turning nimble trash-eating scavengers into massive man-eating
    monsters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你成为疯狂科学家的机会，拥有一个充满沸腾烧瓶、冒泡试管和发出“BZZZTTT”声音的机器的秘密实验室。所以，戴上黑色橡胶手套，开始把灵活的垃圾清道夫变成庞大的食人怪物吧。
- en: '**THE OBJECTIVE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use a genetic algorithm to simulate breeding rats to an average weight of 110
    pounds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法模拟繁殖出平均体重为110磅的老鼠。
- en: '***Strategy***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Your dream is to breed a race of rats the size of bullmastiffs (we’ve already
    established that you’re mad). You’ll start with *Rattus norvegicus*, the brown
    rat, then add some artificial sweeteners, some atomic radiation from the 1950s,
    a lot of patience, and a pinch of Python, but no genetic engineering—you’re old-school,
    baby! The rats will grow from less than a pound to a terrifying 110 pounds, about
    the size of a female bullmastiff (see [Figure 7-1](ch07.xhtml#ch07fig1)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你的梦想是培育出一种体型与公獒犬相当的老鼠（我们已经确定你是疯了）。你将从*Rattus norvegicus*，即棕色老鼠开始，然后加入一些人造甜味剂、1950年代的原子辐射、很多耐心和一点点Python，但不涉及基因工程——你是老派的，宝贝！这些老鼠将从不到一磅长大到可怕的110磅，差不多是雌性公獒犬的体型（见[图
    7-1](ch07.xhtml#ch07fig1)）。
- en: '![image](../images/f0127-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0127-01.jpg)'
- en: '*Figure 7-1: Size comparison of a brown rat, a female bullmastiff, and a human*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：棕色老鼠、雌性公獒犬和人类的体型比较*'
- en: Before you embark on such a huge undertaking, it’s prudent to simulate the results
    in Python. And you’ve drawn up something better than a plan—you’ve drawn some
    graphical pseudocode (see [Figure 7-2](ch07.xhtml#ch07fig2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始进行这样一项庞大的任务之前，明智的做法是先在Python中模拟结果。而且你已经画出了比计划更好的东西——你画出了图形伪代码（见[图 7-2](ch07.xhtml#ch07fig2)）。
- en: '![image](../images/f0128-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0128-01.jpg)'
- en: '*Figure 7-2: Genetic algorithm approach to breeding super-rats*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：利用遗传算法培育超级老鼠的方式*'
- en: The process shown in [Figure 7-2](ch07.xhtml#ch07fig2) outlines how a genetic
    algorithm works. Your goal is to produce a population of rats with an average
    weight of 110 pounds from an initial population weighing much less than that.
    Going forward, each population (or *generation*) of rats represents a candidate
    solution to the problem. Like any animal breeder, you cull undesirable males and
    females, which you humanely send to—for you *Austin Powers* fans—an evil petting
    zoo. You then mate and breed the remaining rats, a process known as *crossover*
    in genetic programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch07fig2)展示了遗传算法是如何工作的。你的目标是从一个初始体重大大低于110磅的老鼠种群中，培育出一个平均体重为110磅的种群。往后，每一代（或*世代*）的老鼠都代表着该问题的一个候选解。就像任何动物饲养员一样，你会筛除那些不理想的雄性和雌性，它们会被人道地送去——对于*Austin
    Powers*迷来说——一个邪恶的宠物园。然后，你会让剩下的老鼠交配繁殖，这一过程在遗传编程中被称为*交叉*。'
- en: The offspring of the remaining rats will be essentially the same size as their
    parents, so you need to mutate a few. While mutation is rare and usually results
    in a neutral-to-nonbeneficial trait (low weight, in this case), sometimes you’ll
    successfully produce a bigger rat.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的老鼠的后代基本上会和它们的父母一样大，因此你需要对一些老鼠进行突变。虽然突变很少发生，而且通常会导致中性或无益的特征（在这种情况下是低体重），但有时你会成功地培育出更大的老鼠。
- en: The whole process then becomes a big repeating loop, whether done organically
    or programmatically, making me wonder whether we really *are* just virtual beings
    in an alien simulation. At any rate, the end of the loop—the stop condition—is
    when the rats reach the desired size or you just can’t stand dealing with rats
    anymore.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后整个过程变成了一个大循环，无论是有机进行还是通过程序化进行，这让我不禁怀疑我们是否真的是外星模拟中的虚拟存在。不管怎么说，这个循环的结束——停止条件——是当老鼠达到了预期的体型，或者你实在受不了再和老鼠打交道时。
- en: For input to your simulation, you’ll need some statistics. Use the metric system
    since you’re a scientist, mad or not. You already know that the average weight
    of a female bullmastiff is 50,000 grams, and you can find useful rat statistics
    in [Table 7-1](ch07.xhtml#ch07tab1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要输入到你的仿真中，你需要一些统计数据。因为你是科学家，所以使用公制系统，无论你是不是疯子。你已经知道雌性公獒犬的平均体重大约是50,000克，你可以在[表
    7-1](ch07.xhtml#ch07tab1)中找到有用的老鼠统计数据。
- en: '**Table 7-1:** Brown Rat Weight and Breeding Statistics'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 棕色老鼠体重和繁殖统计数据'
- en: '| **Parameter** | **Published values** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **已发布值** |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Minimum weight | 200 grams |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 最小体重 | 200 克 |'
- en: '| Average weight (female) | 250 grams |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 平均体重（雌性） | 250 克 |'
- en: '| Average weight (male) | 300–350 grams |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 平均体重（雄性） | 300–350 克 |'
- en: '| Maximum weight | 600 grams* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 最大体重 | 600 克* |'
- en: '| Number of pups per litter | 8–12 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 每窝幼鼠数量 | 8–12 |'
- en: '| Litters per year | 4–13 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 每年窝数 | 4–13 |'
- en: '| Life span (wild, captivity) | 1–3 years, 4–6 years |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 寿命（野生，圈养） | 1–3年，4–6年 |'
- en: '| *Exceptional individuals may reach 1,000 grams in captivity. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| *在圈养情况下，个别老鼠可能达到 1,000 克。 |'
- en: Because both domestic and wild brown rats exist, there may be wide variation
    in some of the stats. Rats in captivity tend to be better cared for than wild
    rats, so they weigh more, breed more, and have more pups. So you can choose from
    the higher end when a range is available. For this project, start with the assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在家养和野生的棕色老鼠，因此某些统计数据可能会有较大差异。圈养的老鼠通常比野生老鼠得到更好的照料，因此它们的体重更大，繁殖更多，幼鼠也更多。所以当有范围数据时，你可以选择较高的值。对于这个项目，首先可以从[表
    7-2](ch07.xhtml#ch07tab2)中的假设开始。
- en: '**Table 7-2:** Input Assumptions for the Super-Rats Genetic Algorithm'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：** 超级老鼠遗传算法的输入假设'
- en: '| **Variable and value** | **Comments** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **变量和值** | **注释** |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GOAL = 50000` | Target weight in grams (female bullmastiff) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `GOAL = 50000` | 目标体重（雌性牛头獒，单位：克） |'
- en: '| `NUM_RATS = 20` | Total number of *adult* rats your lab can support |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `NUM_RATS = 20` | 实验室可容纳的成年老鼠总数 |'
- en: '| `INITIAL_MIN_WT = 200` | Minimum weight of adult rat, in grams, in initial
    population |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `INITIAL_MIN_WT = 200` | 初始种群中成年老鼠的最小体重（单位：克） |'
- en: '| `INITIAL_MAX_WT = 600` | Maximum weight of adult rat, in grams, in initial
    population |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `INITIAL_MAX_WT = 600` | 初始种群中成年老鼠的最大体重（单位：克） |'
- en: '| `INITIAL_MODE_WT = 300` | Most common adult rat weight, in grams, in initial
    population |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `INITIAL_MODE_WT = 300` | 初始种群中最常见的成年老鼠体重（单位：克） |'
- en: '| `MUTATE_ODDS = 0.01` | Probability of a mutation occurring in a rat |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `MUTATE_ODDS = 0.01` | 老鼠发生突变的概率 |'
- en: '| `MUTATE_MIN = 0.5` | Scalar on rat weight of least beneficial mutation |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `MUTATE_MIN = 0.5` | 最少有利突变对老鼠体重的影响因子 |'
- en: '| `MUTATE_MAX = 1.2` | Scalar on rat weight of most beneficial mutation |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `MUTATE_MAX = 1.2` | 最有利突变对老鼠体重的影响因子 |'
- en: '| `LITTER_SIZE = 8` | Number of pups per pair of mating rats |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `LITTER_SIZE = 8` | 每对交配老鼠每窝的幼鼠数量 |'
- en: '| `LITTERS_PER_YEAR = 10` | Number of litters per year per pair of mating rats
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `LITTERS_PER_YEAR = 10` | 每对交配老鼠每年繁殖的窝数 |'
- en: '| `GENERATION_LIMIT = 500` | Generational cutoff to stop breeding program |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `GENERATION_LIMIT = 500` | 停止繁殖程序的代数上限 |'
- en: Since rats breed so frequently, you shouldn’t have to factor in life span. Even
    though you will retain some of the parents from a previous generation, they will
    be culled out quickly as their offspring increase in weight from generation to
    generation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于老鼠繁殖非常频繁，你不需要考虑寿命。尽管你会保留上一代的一些父母，但随着后代体重的逐代增加，这些父母将很快被淘汰。
- en: '***The Super-Rats Code***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***超级老鼠代码***'
- en: The *super_rats.py* code follows the general workflow in [Figure 7-2](ch07.xhtml#ch07fig2).
    You can also download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py* 代码遵循了[图 7-2](ch07.xhtml#ch07fig2)中的一般工作流程。你也可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载代码。'
- en: '**Entering the Data and Assumptions**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输入数据和假设**'
- en: '[Listing 7-1](ch07.xhtml#ch07list1), in the global space at the start of the
    program, imports modules and assigns the statistics, scalars, and assumptions
    in [Table 7-2](ch07.xhtml#ch07tab2) as constants. Once the program is complete
    and working, feel free to experiment with the values in that table and see how
    they affect your results.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-1](ch07.xhtml#ch07list1)，在程序开始时的全局空间中，导入模块并将[表 7-2](ch07.xhtml#ch07tab2)中的统计数据、因子和假设作为常量进行分配。程序完成并正常工作后，可以自由地修改表中的值，看看它们如何影响你的结果。'
- en: '*super_rats.py,* part 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py*，第一部分'
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: Imports modules and assigns constants*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：导入模块并分配常量*'
- en: Start by importing the `time`, `random`, and `statistics` modules ➊. You’ll
    use the `time` module to record the runtime of your genetic algorithm. It’s interesting
    to time genetic algorithms, if only to be awed by how quickly they can find a
    solution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 `time`、`random` 和 `statistics` 模块 ➊。你将使用 `time` 模块来记录遗传算法的运行时间。为遗传算法计时是非常有趣的，即使只是为了惊叹于它们能如此迅速找到解决方案。
- en: The `random` module will satisfy the stochastic needs of the algorithm, and
    you’ll use the `statistics` module to get mean values. This is a weak use for
    `statistics`, but I want you to be aware of the module, since it can be quite
    handy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块将满足算法的随机需求，你将使用 `statistics` 模块来获取平均值。虽然这是 `statistics` 的一个较弱用途，但我希望你能了解这个模块，因为它在许多情况下非常有用。'
- en: Next, assign the input variables described in [Table 7-2](ch07.xhtml#ch07tab2)
    and be sure to note that the units are grams ➋. Use uppercase letters for the
    names, as these represent constants ➌.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配 [表7-2](ch07.xhtml#ch07tab2) 中描述的输入变量，并确保注意单位是克 ➋。使用大写字母来命名这些变量，因为它们表示常量
    ➌。
- en: Right now, we’re going to assume the use of breeding *pairs*, so check that
    the user input an even number of rats and, if not, add a rat ➍. Later, in “[Challenge
    Projects](ch07.xhtml#lev167)” on [page 144](ch07.xhtml#page_144), you’ll get to
    experiment with alternative gender distributions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们假设使用繁殖*配对*，因此需要检查用户输入的是偶数只大鼠，如果不是，就添加一只大鼠 ➍。稍后，在 “[挑战项目](ch07.xhtml#lev167)”
    的 [第144页](ch07.xhtml#page_144)，你将有机会尝试不同的性别分布。
- en: '**Initializing the Population**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化种群**'
- en: '[Listing 7-2](ch07.xhtml#ch07list2) is the program’s shopping representative.
    It goes to a pet shop and picks out the rats for an initial breeding population.
    Since you want mating pairs, it should choose an even number of rats. And since
    you can’t afford one of those fancy volcano lairs with unlimited space, you’ll
    need to maintain a constant number of adult rats through each generation—though
    the number can swell temporarily to accommodate litters. Remember, the rats will
    need more and more space as they grow to the size of big dogs!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单7-2](ch07.xhtml#ch07list2) 是程序的购物代表。它去宠物店挑选初始的繁殖大鼠种群。由于你需要配对繁殖，它应该选择偶数只大鼠。由于你不能负担一个那种无限空间的火山巢穴，你需要在每一代中维持一个固定的成年大鼠数量——尽管数量可以临时增加以容纳窝内的小鼠。记住，随着大鼠长大到像大狗那样大，它们需要更多的空间！'
- en: '*super_rats.py,* part 2'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py*，第2部分'
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: Defines the function that creates the initial rat population*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-2：定义了创建初始大鼠种群的函数*'
- en: The `populate()` function needs to know the amount of adult rats you want, the
    minimum and maximum weights for the rats, and the most commonly occurring weight
    ➊. Note that all of these arguments will use constants found in the global space.
    You don’t have to pass these as arguments for the function to access them. But
    I do so here and in the functions that follow, for clarity and because local variables
    are accessed more efficiently.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`populate()` 函数需要知道你想要的成年大鼠数量、大鼠的最小和最大体重，以及最常见的体重 ➊。请注意，这些参数都将使用在全局空间中找到的常量。你不需要将它们作为参数传递给函数，以便函数能够访问它们。但为了清晰起见，我在这里以及后续的函数中都这样做，并且因为局部变量的访问效率更高。'
- en: You’ll use the four arguments above with the `random` module, which includes
    different types of distributions. You’ll use a triangular distribution here, because
    it gives you firm control of the minimum and maximum sizes and lets you model
    skewness in the statistics.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用上述四个参数和 `random` 模块，后者包括不同类型的分布。你将在这里使用三角分布，因为它能让你牢牢控制最小值和最大值，并允许你在统计中建模偏斜性。
- en: Because brown rats exist both in the wild and in captivity—in zoos, labs, and
    as pets—their weights are skewed to the high side. Wild rats tend to be smaller
    as their lives are nasty, brutish, and short, though lab rats may contest that
    point! Use list comprehension to loop through the number of rats and assign each
    one a weight. Bundle it all together with the `return` statement ➋.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于棕色大鼠在野外、动物园、实验室和作为宠物中都有分布，它们的体重偏向较高。野生大鼠通常较小，因为它们的生活条件恶劣、残酷且短暂，尽管实验室里的大鼠可能会反驳这一点！使用列表推导式来循环遍历大鼠的数量，并为每只大鼠分配一个体重。将这一切通过
    `return` 语句捆绑在一起 ➋。
- en: '**Measuring the Fitness of the Population**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**衡量种群的适应度**'
- en: Measuring the fitness of the rats is a two-step process. First, grade the whole
    population by comparing the average weight of all the rats to the bullmastiff
    target. Then, grade each individual rat. Only rats whose weight ranks in the upper
    *n* percent, as determined by the `NUM_RATS` variable, get to breed again. Although
    the average weight of the population is a valid fitness measurement, its primary
    role here is to determine whether it’s time to stop looping and declare success.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量大鼠的适应度是一个两步过程。首先，通过比较所有大鼠的平均体重与斗牛獒目标体重来对整个种群进行评分。然后，对每只大鼠进行评分。只有体重排名在前 *n*
    百分比的大鼠（由 `NUM_RATS` 变量确定）才能再次繁殖。虽然种群的平均体重是一个有效的适应度衡量标准，但它的主要作用是在这里是确定是否该停止循环并宣布成功。
- en: '[Listing 7-3](ch07.xhtml#ch07list3) defines the `fitness()` and `select()`
    functions, which together form the measurement portion of your genetic algorithm.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单7-3](ch07.xhtml#ch07list3) 定义了 `fitness()` 和 `select()` 函数，这两个函数共同构成了遗传算法的测量部分。'
- en: '*super_rats.py,* part 3'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py*，第3部分'
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: Defines the measurement step of the genetic algorithm*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：定义了遗传算法的测量步骤*'
- en: Define a function to grade the fitness of the current generation ➊. Use the
    `statistics` module to get the mean of the population and return this value divided
    by the target weight. When this value is equal to or greater than 1, you’ll know
    it’s time to stop breeding.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数来评估当前一代的适应度 ➊。使用`statistics`模块获取种群的平均值，并将其除以目标体重返回。当这个值等于或大于1时，你就知道是时候停止繁殖了。
- en: Next, define a function that culls a population of rats, based on weight, down
    to the `NUM_RATS` value, represented here by the `to_retain` parameter ➋. It will
    also take a `population` argument, which will be the parents of each generation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数，根据体重将老鼠种群减少到`NUM_RATS`值，这里用`to_retain`参数表示 ➋。它还将接受一个`population`参数，表示每一代的父母。
- en: Now, sort the population so you can distinguish large from small ➌. Take the
    number of rats you want to retain and divide it by 2 using floor division so that
    the result is an integer ➍. Do this step so you can keep the biggest male and
    female rats. If you choose only the largest rats in the population, you will theoretically
    be choosing only males. You obtain the total members of the current population,
    by sex, by dividing the `sorted_population` by 2, again using floor division ➎.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，排序种群，以便你能区分大鼠和小鼠 ➌。取你想要保留的老鼠数量，并使用地板除法将其除以2，确保结果是一个整数 ➍。执行此步骤是为了保留最大的公鼠和母鼠。如果你只选择种群中最大的老鼠，理论上你会只选择公鼠。通过对`sorted_population`使用地板除法将其除以2，可以得到当前种群按性别分组的总人数
    ➎。
- en: 'Male rats tend to be larger than females, so make two simplifying assumptions:
    first, assume that exactly half of the population is female and, second, that
    the largest female rat is no heavier than the smallest male rat. This means that
    the first half of the sorted population list represents females and the last half
    represents males. Then create two new lists by splitting `sorted_population` in
    half, taking the bottom half for females ➏ and the upper half for males. Now all
    that’s left to do is take the biggest rats from the end of each of these lists
    ➐—using negative slicing—and return them ➑. These two lists contain the parents
    of the next generation.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 公鼠通常比母鼠大，因此做出两个简化假设：首先，假设种群中恰好一半是雌性，其次，假设最大的母鼠体重大于或等于最小的公鼠体重。这意味着排序后的种群列表的前一半是母鼠，后一半是公鼠。接着，通过将`sorted_population`分为两半，取下半部分作为母鼠
    ➏，上半部分作为公鼠，创建两个新列表。现在，只需从这两个列表的末尾取出最大体重的老鼠 ➐——使用负切片——并返回它们 ➑。这两份列表包含了下一代的父母。
- en: The first time you run this function, all it will do is sort the rats by sex,
    as the initial number of rats already equals the `NUM_RATS` constant. After that,
    the incoming population argument will include both parents and children, and its
    value will exceed `NUM_RATS`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行这个函数时，它所做的就是按照性别排序老鼠，因为初始的老鼠数量已经等于`NUM_RATS`常量。之后，传入的种群参数将包括父母和孩子，其值将超过`NUM_RATS`。
- en: '**Breeding a New Generation**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**培养新一代**'
- en: '[Listing 7-4](ch07.xhtml#ch07list4) defines the program’s “crossover” step,
    which means it breeds the next generation. A key assumption is that the weight
    of every child will be greater than or equal to the weight of the mother and less
    than or equal to the weight of the father. Exceptions to that rule will be handled
    in the “mutation” function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-4](ch07.xhtml#ch07list4)定义了程序的“交叉”步骤，意味着它将培育下一代。一个关键假设是，每只幼鼠的体重大于或等于母鼠的体重，并且小于或等于父鼠的体重。违反此规则的情况将在“突变”函数中处理。'
- en: '*super_rats.py,* part 4'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py*，第 4 部分'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-4: Defines the function that breeds a new generation of rats*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-4：定义了一个培养新一代老鼠的函数*'
- en: The `breed()` function takes as arguments the lists of weights of selected males
    and females returned from the `select()` function along with the size of a litter
    ➊. Next, randomly shuffle the two lists ➋, because you sorted them in the `select()`
    function and iterating over them without shuffling would result in the smallest
    male being paired with the smallest female, and so on. You need to allow for love
    and romance; the largest male may be drawn to the most petite female!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`breed()`函数的参数包括从`select()`函数返回的已选择公鼠和母鼠的体重列表，以及一窝幼鼠的数量 ➊。接下来，随机打乱这两个列表 ➋，因为你在`select()`函数中已经对它们进行了排序，如果不打乱直接迭代，最小的公鼠会和最小的母鼠配对，以此类推。你需要考虑到爱情和浪漫；最大的公鼠可能会被最娇小的母鼠吸引！'
- en: Start an empty list to hold their children ➌. Now for the hanky-panky. Go through
    the shuffled lists using `zip()` to pair a male and female from each list ➍. Each
    pair of rats can have multiple children, so start another loop that uses the litter
    size as a range ➎. The litter size is a constant, called `LITTER_SIZE`, that you
    provided in the input parameters, so if the value is `8`, you’ll get eight children.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个空列表来存储子代 ➌。现在进入细节。使用 `zip()` 函数遍历打乱的列表，将每对雄性和雌性配对 ➍。每对老鼠可以有多个后代，所以开始另一个循环，以出生窝大小作为范围
    ➎。出生窝大小是一个常量，名为 `LITTER_SIZE`，你在输入参数中提供的值，如果值为 `8`，则会得到八个子代。
- en: For each child, choose a weight at random between the mother’s and father’s
    weights ➏. Note that you don’t need to use `male` + 1, because `randint()` uses
    *all* the numbers in the supplied range. Note also that the two values can be
    the same, but the first value (the mother’s weight) can never be larger than the
    second (the father’s weight). This is another reason for the simplifying assumption
    that females must be no larger than the smallest male. End the loop by appending
    each child to the list of children ➐, then return `children` ➑.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个子代，在母鼠和父鼠的体重之间随机选择一个体重 ➏。请注意，你不需要使用 `male + 1`，因为 `randint()` 会使用提供范围内的*所有*数字。还要注意，两个值可以相同，但第一个值（母鼠的体重）永远不能大于第二个值（父鼠的体重）。这是简化假设的另一个原因，假设雌性必须不大于最小的雄性。通过将每个子代添加到子代列表中
    ➐ 来结束循环，然后返回 `children` ➑。
- en: '**Mutating the Population**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**变异种群**'
- en: A small percentage of the children should experience mutations, and most of
    these should result in traits that are nonbeneficial. That means lower-than-expected
    weights, including “runts” that would not survive. But every so often, a beneficial
    mutation will result in a heavier rat.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一小部分子代应该会经历变异，其中大多数变异将导致不利的特征。这意味着体重低于预期，包括那些无法生存的“小个子”。但偶尔会有一次有益的变异，结果会使老鼠变得更重。
- en: '[Listing 7-5](ch07.xhtml#ch07list5) defines the `mutate()` function, which
    applies the mutation assumptions you supplied in the list of constants. After
    `mutate()` is called, it will be time to check the fitness of the new population
    and start the loop over if the target weight hasn’t been reached.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-5](ch07.xhtml#ch07list5) 定义了 `mutate()` 函数，它应用你在常量列表中提供的变异假设。调用 `mutate()`
    后，应该检查新种群的适应度，如果目标体重没有达到，就重新开始循环。'
- en: '*super_rats.py,* part 5'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py*，第5部分'
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-5: Defines the function that mutates a small portion of the population*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-5：定义了变异一小部分种群的函数*'
- en: The function needs the list of children, the odds of a mutation occurring, and
    the minimum and maximum impacts of a mutation ➊. The impacts are scalars that
    you’ll apply to the weight of a rat. In your list of constants at the start of
    the program (and in [Table 7-2](ch07.xhtml#ch07tab2)), they are skewed to the
    minimum side, as most mutations do not result in beneficial traits.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要子代列表、变异发生的几率以及变异的最小和最大影响 ➊。这些影响是你应用于老鼠体重的因子。在程序开始时的常量列表中（以及在[表格 7-2](ch07.xhtml#ch07tab2)中），它们偏向最小值，因为大多数变异不会导致有益的特征。
- en: Loop through the list of children and use `enumerate()`—a handy built-in function
    that acts as an automatic counter—to get an index ➋. Then use the `random()` method
    to generate a random number between 0 and 1 and compare it to the odds of a mutation
    occurring.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历子代列表，并使用 `enumerate()`——一个很方便的内置函数，作为自动计数器——来获取索引 ➋。然后使用 `random()` 方法生成一个
    0 到 1 之间的随机数，并将其与变异发生的几率进行比较。
- en: If the `mutate_odds` variable is greater than or equal to the randomly generated
    number, the rat (weight) at that index is mutated. Choose a mutation value from
    a uniform distribution defined by the minimum and maximum mutation values; this
    basically selects a value at random from the min-max range. As these values are
    skewed to the minimum, the outcome is more likely to be a loss in weight than
    a gain. Multiply the current weight by this mutation scalar and round it to an
    integer ➌. Finish by returning the mutated `children` list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `mutate_odds` 变量大于或等于随机生成的数字，则该索引处的老鼠（体重）会发生变异。从一个由最小和最大变异值定义的均匀分布中选择一个变异值；这基本上是在最小-最大范围内随机选择一个值。由于这些值偏向最小值，因此结果更可能是体重减少而不是增加。将当前体重乘以这个变异因子，并将其四舍五入为整数
    ➌。最后返回变异后的 `children` 列表。
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With regard to the validity of mutation statistics, you can find studies that
    suggest beneficial mutations are very rare and others that suggest they are more
    common than we realize. The breeding of dogs has shown that achieving drastic
    variations in size (for example, Chihuahuas vs. Great Danes) doesn’t require millions
    of years of evolution. In a famous 20th-century study, Russian geneticist Dmitry
    Belyayev started with 130 silver foxes and, over a 40-year period, succeeded in
    achieving dramatic physiological changes by simply selecting the tamest foxes
    in each generation.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于突变统计的有效性，你可以找到一些研究表明有益突变非常稀有，也有一些研究认为它们比我们想象的更常见。狗的繁殖显示，实现体型的巨大变化（例如，吉娃娃与大丹犬）并不需要数百万年的进化。在20世纪的一个著名研究中，俄罗斯遗传学家德米特里·贝利亚耶夫从130只银狐开始，在40年的时间里，仅通过选择每一代中最温顺的狐狸，成功地实现了显著的生理变化。*'
- en: '**Defining the main() Function**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义`main()`函数**'
- en: '[Listing 7-6](ch07.xhtml#ch07list6) defines the `main()` function, which manages
    the other functions and determines when you’ve met the stop condition. It will
    also display all the important results.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-6](ch07.xhtml#ch07list6)定义了`main()`函数，该函数管理其他函数并决定何时满足停止条件。它还将显示所有重要结果。'
- en: '*super_rats.py,* part 6'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第6部分'
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-6: Defines the* main() *function*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：定义了* main() *函数*'
- en: Start the function by initializing an empty list to hold the number of generations.
    You’ll eventually use this to figure out how many years it took to achieve your
    goal ➊.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过初始化一个空列表来存储代数。最终你会用它来计算实现目标所需的年数 ➊。
- en: Next, call the `populate()` function ➋ and immediately print the results. Then,
    get the fitness of your initial population and print this along with the number
    of rats to retain each generation, which is the `NUM_RATS` constant.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`populate()`函数 ➋并立即打印结果。然后，获取初始种群的适应度，并打印该值以及每代保留的小鼠数量，即`NUM_RATS`常量。
- en: For fun, initialize a list to hold the average weight of each generation so
    you can view it at the end ➌. If you plot these weights against the number of
    years, you’ll see that the trend is exponential.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加趣味，初始化一个列表来存储每代的平均体重，以便在最后查看 ➌。如果你将这些体重与年份数进行对比，你会发现趋势是指数型的。
- en: Now, start the big genetic loop of select-mate-mutate. This is in the form of
    a `while` loop, with the stop conditions being either reaching the target weight
    or reaching a large number of generations without achieving the target weight
    ➍. Note that after mutating the children, you need to combine them with their
    parents to make a new `parents` list ➎. It takes the pups about five weeks to
    mature and start breeding, but you can account for this by adjusting the `LITTERS_PER_YEAR`
    constant down from the maximum possible value (see [Table 7-1](ch07.xhtml#ch07tab1)),
    as we’ve done here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始大的遗传循环——选择、配对、突变。这是一个`while`循环，停止条件是达到目标体重或在没有达到目标体重的情况下达到大量的代数 ➍。注意，突变子代之后，你需要将它们与父代合并，生成一个新的`parents`列表
    ➎。小鼠大约需要五周时间成熟并开始繁殖，但你可以通过调整`LITTERS_PER_YEAR`常量，从最大可能值减少来考虑这一点（参见[表7-1](ch07.xhtml#ch07tab1)），就像我们在这里所做的那样。
- en: At the end of each loop, display the results of the `fitness()` function to
    four decimal places so you can monitor the algorithm and ensure it is progressing
    as expected ➏. Get the average weight of the generation, append it to the `ave_wt`
    list ➐, and then advance the generation count by 1.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环结束时，显示`fitness()`函数的结果，精确到四位小数，以便你监控算法并确保其按预期进行 ➏。获取这一代的平均体重，将其添加到`ave_wt`列表中
    ➐，然后将代数加1。
- en: Complete the `main()` function by displaying the list of average weights per
    generation, the number of generations, and the number of years—calculated using
    the `LITTERS_PER_YEAR` variable ➑.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`main()`函数，显示每一代的平均体重列表、代数以及通过`LITTERS_PER_YEAR`变量计算出的年数 ➑。
- en: Running the main() Function
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行`main()`函数
- en: Finish up with the familiar conditional statement for running the program either
    stand-alone or as a module. Get the ending time and print how long it took the
    program to run. The performance information should print only when the module
    is run in stand-alone mode, so be sure to place it under the `if` clause. See
    [Listing 7-7](ch07.xhtml#ch07list7).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序时，使用熟悉的条件语句来决定程序是独立运行还是作为模块运行。获取结束时间并打印程序运行所用的时间。性能信息应该仅在模块作为独立程序运行时打印，因此确保将其放置在`if`语句中。参见[列表
    7-7](ch07.xhtml#ch07list7)。
- en: '*super_rats.py,* part 7'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_rats.py,* 第7部分'
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-7: Runs the* main() *function and* time *module if the program isn’t
    imported*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：运行* main() *函数和* time *模块，如果程序没有被导入*'
- en: '***Summary***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: With the parameters in [Table 7-2](ch07.xhtml#ch07tab2), the *super_rats.py*
    program will take about two seconds to run. On average, it will take the rats
    about 345 generations, or 34.5 years, to reach the target weight of 110 pounds.
    That’s a long time for a mad scientist to stay mad! But armed with your program,
    you can look for ways to reduce the time to target.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表 7-2](ch07.xhtml#ch07tab2)中的参数，*super_rats.py*程序大约需要两秒钟才能运行。平均而言，大鼠需要约345代，或34.5年，才能达到目标体重110磅。这对于一个疯狂的科学家来说，时间实在太长了！但有了你的程序，你可以寻找减少目标时间的方法。
- en: '*Sensitivity studies* work by making multiple changes to a *single* variable
    and judging the results. You should take care in the event some variables are
    dependent on one another. And since the results are stochastic (random), you should
    make multiple runs with each parameter change in order to capture the range of
    possible outcomes.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*灵敏度研究*通过对*单一*变量进行多次更改并判断结果来工作。在某些变量相互依赖的情况下，你应该小心操作。而且，由于结果是随机的（即不确定的），你应该在每次改变参数时进行多次运行，以捕捉可能的结果范围。'
- en: Two things you can control in your breeding program are the number of breeding
    rats (`NUM_RATS`) and the odds of a mutation occurring (`MUTATE_ODDS`). The mutation
    odds are influenced by factors like diet and exposure to radiation. If you change
    these variables one at a time and rerun *super_rats.py*, you can judge the impact
    of each variable on the project timeline.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的繁殖计划中，你可以控制的两个因素是繁殖大鼠的数量（`NUM_RATS`）和突变发生的几率（`MUTATE_ODDS`）。突变几率受到饮食和辐射暴露等因素的影响。如果你一次只改变一个变量并重新运行*super_rats.py*，你就可以判断每个变量对项目时间表的影响。
- en: An immediate observation is that, if you start with small values for each variable
    and slowly increase them, you get dramatic initial results (see [Figure 7-3](ch07.xhtml#ch07fig3)).
    After that, both curves decline rapidly and flatten out in a classic example of
    diminishing returns. The point where each curve flattens is the key to optimally
    saving money and reducing work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接的观察是，如果你从每个变量的小值开始，慢慢增加它们，你会得到显著的初步结果（参见[图 7-3](ch07.xhtml#ch07fig3)）。之后，两条曲线迅速下降并趋于平稳，这是递减收益的经典例子。每条曲线平稳化的点就是优化节省成本和减少工作量的关键。
- en: For example, you get very little benefit from retaining more than about 300
    rats. You’d just be feeding and caring for a lot of superfluous rats. Likewise,
    trying to boost the odds of a mutation above 0.3 gains you little.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，保留超过300只大鼠几乎不会带来太大好处。你只是在喂养和照顾一大堆多余的大鼠。同样，试图将突变几率提高到0.3以上也几乎没有任何收获。
- en: With charts like these, it’s easy to plan a path forward. The horizontal dotted
    line marked “Baseline” represents the average result of using the input in [Table
    7-2](ch07.xhtml#ch07tab2). You can potentially reduce this time by over 10 years
    just by retaining 50 rats rather than 20\. You should also focus on increasing
    the number of beneficial mutations. This will be more rewarding, but riskier and
    harder to control.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的图表，使得规划前进的道路变得容易。标记为“基线”的水平虚线表示使用[表 7-2](ch07.xhtml#ch07tab2)中的输入数据所得到的平均结果。你只需保留50只大鼠而不是20只，就能将这个时间减少超过10年。你还应该集中精力增加有益突变的数量。这将更有回报，但风险更大，且更难控制。
- en: '![image](../images/f0137-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0137-01.jpg)'
- en: '*Figure 7-3: Impact of two parameters on the time required to reach the target
    weight*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：两个参数对达到目标体重所需时间的影响*'
- en: If you rerun the simulation using 50 rats and bumping the odds of mutation up
    to 0.05, you can theoretically complete the project in 14 years, an improvement
    of 246 percent over the initial baseline. Now *that’s* optimization!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行模拟，使用50只大鼠并将突变几率提高到0.05，你理论上可以在14年内完成项目，比最初的基线提高了246%。现在，*这才是*优化！
- en: Breeding super-rats was a fun and simple way to understand the basics of genetic
    algorithms. But to truly appreciate their power, you need to attempt something
    harder. You need a brute-force problem that’s too big to brute-force, and the
    next project is that kind of problem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 繁殖超级大鼠是理解遗传算法基本原理的一种有趣且简单的方法。但要真正理解它们的强大，你需要尝试一些更困难的任务。你需要一个计算量庞大到无法通过暴力破解解决的问题，而下一个项目正是这样的难题。
- en: '**Project #14: Cracking a High-Tech Safe**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #14: 破解高科技保险箱**'
- en: 'You are Q, and James Bond has a problem. He has to attend an elegant dinner
    party at a villain’s mansion, slip away to the man’s private office, and crack
    his wall safe. Child’s play for 007, except for one thing: it’s a Humperdink BR549
    digital safe that takes 10 digits, yielding 10 billion possible combinations.
    And the lock wheels don’t start turning until *after* all the numbers have been
    entered. There’ll be no putting a stethoscope to this safe and slowly turning
    a dial!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你是Q，詹姆斯·邦德遇到了一个问题。他必须参加一个恶棍的豪华晚宴，悄悄溜到那个恶棍的私人办公室，破解他的墙面保险箱。对于007来说，这简直是小菜一碟，除了一个问题：这是一个Humperdink
    BR549数字保险箱，需要10位数字，共有100亿种可能的组合。而且，只有*所有*数字输入完毕后，锁轮才会开始转动。你不能把听诊器放到保险箱上，慢慢转动旋钮！
- en: As Q, you already have an autodialer device that can brute-force its way through
    all possible solutions, but Bond simply won’t have time to use it. Here’s why.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Q，你已经拥有一台自动拨号设备，可以通过暴力破解所有可能的解决方案，但邦德根本没有时间使用它。原因如下。
- en: A combination lock should really be called a *permutation* lock, because it
    requires *ordered* combinations, which are, by definition, permutations. More
    specifically, locks rely on *permutations with repetition*. For example, a valid—though
    insecure—combination could be 999999999.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 组合锁应该真正被称为*排列*锁，因为它需要*有序*的组合，而根据定义，这些组合是排列。更具体地说，锁依赖于*带重复的排列*。例如，一个有效的——尽管不安全——组合可能是999999999。
- en: 'You used the `itertools` module’s `permutations()` iterator when working with
    anagrams in [Chapter 3](ch03.xhtml#ch03) and in “[Practice Projects](ch04.xhtml#lev106)”
    on [page 87](ch04.xhtml#page_87) in [Chapter 4](ch04.xhtml#ch04), but that won’t
    help here because `permutations()` returns permutations *without* repetition.
    To generate the right kind of permutation for a lock, you need to use `itertools`’s
    `product()` iterator, which calculates the Cartesian product from multiple sets
    of numbers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理[第3章](ch03.xhtml#ch03)中的字谜和[第4章](ch04.xhtml#ch04)中[第87页](ch04.xhtml#page_87)的“[实践项目](ch04.xhtml#lev106)”时，你使用了`itertools`模块的`permutations()`迭代器，但在这里它无法提供帮助，因为`permutations()`返回的是*无*重复的排列。要生成适合锁的排列，你需要使用`itertools`的`product()`迭代器，它计算多个数字集合的笛卡尔积：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The optional `repeat` keyword argument lets you take the product of an iterable
    multiplied by itself, as you need to do in this case. Note that the `product()`
    function returns all the possible combinations, whereas the `permutations()` function
    would return only `(1, 2)` and `(2, 1)`. You can read more about `product()` at
    *[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`repeat`关键字参数允许你获取一个可迭代对象与自身相乘的笛卡尔积，这正是你在此情况下需要做的。注意，`product()`函数返回所有可能的组合，而`permutations()`函数仅返回`(1,
    2)`和`(2, 1)`。你可以在*[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)*阅读更多关于`product()`的信息。
- en: '[Listing 7-8](ch07.xhtml#ch07list8) is a Python program, called *brute_force_cracker.py*,
    that uses `product()` to brute-force its way to the right combination:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-8](ch07.xhtml#ch07list8)是一个Python程序，名为*brute_force_cracker.py*，它使用`product()`来暴力破解正确的组合：'
- en: '*brute_force_cracker.py*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*brute_force_cracker.py*'
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-8: Uses a brute-force method to find a safe’s combination*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-8：使用暴力破解方法找到保险箱的组合*'
- en: Import `time` and the `product` iterator from `itertools` ➊. Get the start time,
    and then enter the safe combination as a tuple ➋. Next use `product()`, which
    returns tuples of all the permutations with repetition for a given sequence. The
    sequence contains all the valid single-digit entries (0–9). You should set the
    `repeat` argument to the number of digits in the combination ➌. Compare each result
    to the combination and print `"Cracked!"` if they match, along with the combination
    and matching permutation ➍. Finish by displaying the runtime ➎.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`time`和来自`itertools`的`product`迭代器 ➊。获取开始时间，然后将保险箱组合输入为一个元组 ➋。接下来使用`product()`，它返回给定序列的所有带重复的排列的元组。序列包含所有有效的单数字输入（0–9）。你应该将`repeat`参数设置为组合中的数字位数
    ➌。比较每个结果与组合是否匹配，如果匹配，则打印`"Cracked!"`，并显示组合和匹配的排列 ➍。最后显示运行时间 ➎。
- en: This works great for combinations up to eight digits long. After that, the wait
    becomes increasingly uncomfortable. [Table 7-3](ch07.xhtml#ch07tab3) is a record
    of runtimes for the program versus number of digits in the combination.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最多八位数字的组合，这种方式非常有效。之后，等待的过程变得越来越不舒适。[表 7-3](ch07.xhtml#ch07tab3)是程序运行时间与组合中数字个数的记录。
- en: '**Table 7-3:** Runtimes Versus Digits in Combination (2.3 GHz Processor)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-3：** 密码组合与运行时间对比（2.3 GHz 处理器）'
- en: '| **Number of digits** | **Runtime in seconds** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **数字位数** | **运行时间（秒）** |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 5 | 0.035 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.035 |'
- en: '| 6 | 0.147 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0.147 |'
- en: '| 7 | 1.335 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1.335 |'
- en: '| 8 | 12.811 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 12.811 |'
- en: '| 9 | 133.270 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 133.270 |'
- en: '| 10 | 1396.955 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1396.955 |'
- en: Notice that adding a number to the combination increases the runtime by an order
    of magnitude. This is an exponential increase. With 9 digits, you’d wait over
    2 minutes for an answer. With 10 digits, over 20 minutes! That’s a long time for
    Bond to take an unnoticed “bathroom break.”
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向组合中添加一个数字会将运行时间增加一个数量级。这是指数级增长。对于9位数字，你需要等待超过2分钟才能得到答案。对于10位数字，则需要超过20分钟！对邦德来说，这可真是个漫长的时间，足以让他悄悄去“上厕所”。
- en: Fortunately, you’re Q, and you know about genetic algorithms. All you need is
    some way to judge the fitness of each candidate combination. Options include monitoring
    fluctuations in power consumption, measuring time delays in operations, and listening
    for sounds. Let’s assume use of a sound-amplifying tool, along with a tool to
    prevent lockouts after a few incorrect combinations have been entered. Because
    of the safeguards in the BR549 safe, a sound tool can initially tell you only
    *how many* digits are correct, not *which* digits, but with very little time,
    your algorithm can zero in on the solution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你是Q，你了解遗传算法。你所需要做的就是评估每个候选组合的适应度。可以选择监测功率消耗的波动，测量操作的时间延迟，或者监听声音。假设你使用了一个声音放大工具，并且还有一个防止多次输入错误密码后被锁定的工具。由于BR549保险箱的安全措施，声音工具一开始只能告诉你*多少个*数字是正确的，而不能告诉你*哪些*数字正确，但只需一点时间，你的算法就能锁定正确答案。
- en: '**THE OBJECTIVE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use a genetic algorithm to quickly find a safe’s combination in a large search
    space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法在庞大的搜索空间中快速找到保险箱的密码组合。
- en: '***Strategy***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: The strategy here is straightforward. You’ll generate a sequence of 10 numbers
    at random and compare it to the real combination, grading the result based on
    matches; in the real world, you’d find the number of matches using the sound detector
    clamped to the door of the safe. You then change one value in your solution and
    compare again. If another match is found, you throw away the old sequence and
    move forward with the new; otherwise, you keep the old sequence and try again.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的策略很简单。你将随机生成一个10位数字的序列，并与真实密码组合进行比较，根据匹配情况进行评分；在现实世界中，你会使用固定在保险箱门上的声音探测器来找到匹配的数字。然后，你会改变解决方案中的一个值，再次进行比较。如果找到另一个匹配，你就丢弃旧的序列，继续使用新的序列；否则，保留旧的序列，重新尝试。
- en: Since one solution completely replaces the other, this represents 100 percent
    crossover of genetic material, so you are essentially using just selection and
    mutation. Selection plus mutation alone generates a robust *hill-climbing* algorithm.
    Hill climbing is an optimization technique that starts with an arbitrary solution
    and changes (mutates) a single value in the solution. If the result is an improvement,
    the new solution is kept and the process repeats.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个解决方案完全替代了另一个解决方案，这表示遗传物质的交叉达到了100%，所以你基本上只在使用选择和变异。单独使用选择和变异就可以生成一个强大的*爬山*算法。爬山是一种优化技术，它从一个任意的解决方案开始，并在解决方案中改变（变异）一个值。如果结果有改善，就保留新的解决方案，过程继续重复。
- en: A problem with hill climbing is that the algorithm can get stuck in *local*
    minima or maxima and not find the optimal *global* value. Imagine you are looking
    for the lowest value in the wavelike function in [Figure 7-4](ch07.xhtml#ch07fig4).
    The current best guess is marked by the large black dot. If the magnitude of the
    change you are making (mutation) is too small to “escape” the local trough, the
    algorithm won’t find the true low point. From the algorithm’s point of view, because
    every direction results in a worse answer, it must have found the true answer.
    So it prematurely converges on a solution.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 爬山算法的一个问题是，它可能会陷入*局部*最小值或最大值，从而找不到最优的*全局*值。想象一下，你正在寻找[图7-4](ch07.xhtml#ch07fig4)中波动函数的最低点。当前的最佳猜测由大黑点标记。如果你所做的变化（变异）的幅度太小，无法“跳出”局部低谷，算法就无法找到真正的低点。从算法的角度看，因为每个方向都会导致更差的结果，它就认为自己已经找到了正确的答案。因此，它会过早地收敛到一个解。
- en: '![image](../images/f0140-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0140-01.jpg)'
- en: '*Figure 7-4: Example of a hill-climbing algorithm “stuck” in a local minimum*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：爬山算法“卡住”在局部最小值的示例*'
- en: Using crossover in genetic algorithms helps to avoid premature convergence problems,
    as does allowing for relatively large mutations. Because you’re not worried about
    honoring biological realism here, the mutation space can encompass every possible
    value in the combination. That way you can’t get stuck, and hill climbing is an
    acceptable approach.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗传算法中使用交叉操作有助于避免过早收敛的问题，允许相对较大的变异也能起到同样的作用。因为你不必担心遵循生物学现实，这里可以让变异空间涵盖组合中的所有可能值。这样你就不会卡住，而爬山算法也变得可接受。
- en: '***The Safecracker Code***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开锁器代码***'
- en: The *safe_cracker.py* code takes a combination of *n* digits and uses hill climbing
    to reach the combination from a random starting point. The code can be downloaded
    from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*safe_cracker.py*代码接受一个由*n*个数字组成的组合，并通过爬山算法从随机起点开始达到目标组合。该代码可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载。'
- en: '**Setting Up and Defining the fitness() Function**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置并定义fitness()函数**'
- en: '[Listing 7-9](ch07.xhtml#ch07list9) imports the necessary modules and defines
    the `fitness()` function.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-9](ch07.xhtml#ch07list9)导入了必要的模块并定义了`fitness()`函数。'
- en: '*safe_cracker.py,* part 1'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*safe_cracker.py,* 第1部分'
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-9: Imports modules and defines the* fitness() *function*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-9：导入模块并定义* fitness() *函数*'
- en: After importing some familiar modules ➊, define a `fitness()` function that
    takes the true combination and an attempted solution as arguments ➋. Name a variable
    `grade` and set it to `0`. Then use `zip()` to iterate through each element in
    the combination and your attempt ➌. If they’re the same, add 1 to `grade` and
    return it. Note that you aren’t recording the index that matches, just that the
    function has found a match. This emulates output from the sound detection device.
    All it can tell you initially is how many lock wheels turned, not their locations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入一些熟悉的模块 ➊ 之后，定义一个`fitness()`函数，它将真实组合和尝试的解作为参数 ➋。定义一个变量`grade`并将其设置为`0`。然后使用`zip()`同时遍历组合和你的尝试
    ➌。若它们相同，则将`grade`加1并返回。注意，你并没有记录匹配的索引，只是函数找到了匹配。这模拟了声音检测设备的输出。它最初只能告诉你有多少锁轮转动，而不能告诉你它们的位置。
- en: '**Defining and Running the main() Function**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义并运行main()函数**'
- en: Since this is a short and simple program, most of the algorithm is run in the
    `main()` function, [Listing 7-10](ch07.xhtml#ch07list10), rather than in multiple
    functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简短且简单的程序，大部分算法都运行在`main()`函数中，而不是多个函数中，[清单 7-10](ch07.xhtml#ch07list10)。
- en: '*safe_cracker.py,* part 2'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*safe_cracker.py,* 第2部分'
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 7-10: Defines the* main() *function and runs and times the program
    if it hasn’t been imported*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：定义* main() *函数，并在未导入时运行和计时程序*'
- en: Provide the true combination as a variable ➊ and use list comprehension to convert
    it into a list for convenience going forward ➋. Generate a list of zeros equal
    in length to the combination and name it `best_attempt` ➌. At this point, any
    combination is as good as any other. You should retain this name—`best_attempt`—because
    you need to preserve only the best solution as you climb the hill. Once you’ve
    generated the initial attempt, grade it with the `fitness()` function and then
    assign the value to a variable, called `best_attempt_grade`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 提供真实的组合作为一个变量 ➊，并使用列表推导将其转换为列表，方便后续使用 ➋。生成一个与组合长度相等的零列表，并将其命名为`best_attempt`
    ➌。此时，任何组合都与其他组合一样好。你应该保留这个名字——`best_attempt`——因为在你爬山的过程中，只需要保留最好的解。生成初始尝试后，用`fitness()`函数对其进行评分，然后将结果赋值给一个名为`best_attempt_grade`的变量。
- en: Start a `count` variable at zero. The program will use this variable to record
    how many attempts it took to crack the code ➍.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将`count`变量初始化为零。程序将使用此变量记录破解代码所需的尝试次数➍。
- en: Now, start a `while` loop that continues until you’ve found the combination
    ➎. Assign a *copy* of `best_attempt` to a `next_try` variable ➏. You copy it so
    you don’t run into aliasing problems; when you alter an element in `next_try`,
    you don’t want to accidentally change `best_attempt`, because you may continue
    to use it in the event `next_try` fails the fitness test.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个`while`循环，直到你找到正确的组合 ➎。将`best_attempt`的*副本*赋值给一个`next_try`变量 ➏。你复制它是为了避免别名问题；当你修改`next_try`中的元素时，你不希望不小心更改`best_attempt`，因为如果`next_try`未通过适应度测试，你可能还需要继续使用`best_attempt`。
- en: It’s now time to mutate the copy. Each digit in the combination turns a lock
    wheel in the safe, so name a variable `lock_wheel` and randomly set it equal to
    an index location in the combination. This represents the location of the single
    element to change in this iteration. Next, randomly choose a digit and use it
    to replace the value at the location indexed by `lock_wheel` ➐.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候突变副本了。组合中的每个数字都旋转保险箱中的一个锁轮，因此命名一个变量 `lock_wheel` 并随机设置它等于组合中的一个索引位置。这代表了在此迭代中要更改的单个元素的位置。接下来，随机选择一个数字，并用它替换
    `lock_wheel` 索引位置的值 ➐。
- en: Grade `next_try`, and if it’s fitter than the previous attempt, reset both `best_attempt`
    and `best_attempt_grade` to the new values ➑. Otherwise, `best_attempt` will remain
    unchanged for the next iteration. Print both `next_try` and `best_attempt`, side
    by side, so you can scroll through the attempts when the program ends and see
    how they evolved. Finish the loop by advancing the counter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `next_try` 进行评分，如果它比上次尝试更优，则将 `best_attempt` 和 `best_attempt_grade` 重置为新值
    ➑。否则，`best_attempt` 将在下一次迭代中保持不变。并排打印 `next_try` 和 `best_attempt`，这样你可以在程序结束时滚动查看尝试过程，观察它们是如何演变的。通过增加计数器完成循环。
- en: When the program finds the combination, display the `best_attempt` value and
    the number of tries it took to find it ➒. Remember, the `end=' '` argument prevents
    a carriage return at the end of the printed line and places a space between the
    end of the current line and the beginning of the next line.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序找到组合时，显示 `best_attempt` 值以及找到该值所需的尝试次数 ➒。记住，`end=' '` 参数会防止打印行末尾换行，并在当前行的结尾和下一行的开始之间放置一个空格。
- en: Complete the program with the conditional statement for running `main()` stand-alone
    and display the runtime to five decimal places ➓. Note that the timing code comes
    after the conditional, and thus will not run if the program is imported as a module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序的条件语句，使 `main()` 独立运行，并显示精确到五位小数的运行时间 ➓。注意，计时代码放在条件语句之后，因此如果程序作为模块导入，则不会运行。
- en: '***Summary***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: The last few lines of output from the *safe_cracker.py* program are shown here.
    I’ve omitted most of the evolving comparisons for brevity. The run was for a 10-digit
    combination.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*safe_cracker.py* 程序的最后几行输出如下所示。为了简洁起见，我省略了大部分演化比较。此运行是针对一个10位数的组合。'
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ten billion possible combinations, and the program found a solution in only
    78 tries and in less than a second. Even James Bond would be impressed with that.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 十亿种可能的组合，程序仅在78次尝试内并且不到一秒的时间内找到了解决方案。即使是詹姆斯·邦德也会对这个结果印象深刻。
- en: 'That does it for genetic algorithms. You’ve used an example workflow to breed
    gigantic rodents, then trimmed it to hill climb through a brute-force problem
    in no time flat. If you want to continue to play digital Darwin and experiment
    with genetic algorithms, a long list of example applications can be found on Wikipedia
    (*[https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)*).
    Examples include:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了遗传算法的部分。你已经使用一个示例工作流培养了巨型啮齿动物，然后将其调整为通过暴力算法解决爬坡问题。如果你想继续玩数字达尔文并实验遗传算法，可以在维基百科上找到一个长长的示例应用列表
    (*[https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)*)。示例包括：
- en: Modeling global temperature changes
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球气温变化建模
- en: Container-loading optimization
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集装箱装载优化
- en: Delivery vehicle–routing optimization
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付车辆路线优化
- en: Groundwater-monitoring networks
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地下水监测网络
- en: Learning robot behavior
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习机器人行为
- en: Protein folding
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋白质折叠
- en: Rare-event analysis
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀有事件分析
- en: Code breaking
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破译代码
- en: Clustering for fit functions
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拟合函数的聚类
- en: Filtering and signal processing
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤和信号处理
- en: '**Further Reading**'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Genetic Algorithms with Python* (Amazon Digital Services LLC, 2016) by Clinton
    Sheppard is a beginner-level introduction to genetic algorithms using Python.
    It is available in paperback or as an inexpensive ebook from *[https://leanpub.com/genetic_algorithms_with_python/](https://leanpub.com/genetic_algorithms_with_python/)*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*《Python中的遗传算法》（Genetic Algorithms with Python）*（亚马逊数字服务有限公司，2016）由克林顿·谢泼德（Clinton
    Sheppard）编写，是一本使用Python介绍遗传算法的初学者入门书籍。它有纸质版或作为便宜的电子书可以从 *[https://leanpub.com/genetic_algorithms_with_python/](https://leanpub.com/genetic_algorithms_with_python/)*
    获取。'
- en: '**Challenge Projects**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: Continue to breed super-rats and crack super-safes with these suggested projects.
    As usual with challenge projects, you’re on your own; no solutions are provided.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过这些建议的项目培养超级老鼠并破解超级保险箱。像往常一样，挑战项目没有提供解决方案，你需要自己解决问题。
- en: '***Building a Rat Harem***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***建立一群老鼠后宫***'
- en: Since a single male rat can mate with multiple females, there is no need to
    have an equal number of male and female rats. Rewrite the *super_rats.py* code
    to accommodate a variable number of male and female individuals. Then rerun the
    program with the same total number of rats as before, but use 4 males and 16 females.
    How does this impact the number of years required to reach the target weight of
    50,000 grams?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单只雄性老鼠可以与多只雌性老鼠交配，因此不需要雄性和雌性老鼠的数量相等。重写*super_rats.py*代码，以适应不等数量的雄性和雌性个体。然后使用与之前相同的老鼠总数重新运行程序，但使用4只雄性和16只雌性。这将如何影响达到目标体重50,000克所需的年数？
- en: '***Creating a More Efficient Safecracker***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建一个更高效的开锁器***'
- en: As currently written, when a lock wheel match is found by the *safe_cracker.py*
    code, that match is not explicitly preserved. As long as the `while` loop is running,
    there’s nothing to stop a correct match from being stochastically overwritten.
    Alter the code so that the indexes for correct guesses are excluded from future
    changes. Do timing comparisons between the two versions of the code to judge the
    impact of the change.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如当前代码所示，当*safe_cracker.py*代码找到一个锁轮匹配时，该匹配并没有被显式保存。只要`while`循环在运行，就没有任何东西可以阻止一个正确的匹配被随机覆盖。修改代码，使正确猜测的索引不再受到未来的更改影响。对比两版代码的运行时间，以评估此更改的影响。
