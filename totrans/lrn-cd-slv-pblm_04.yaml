- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: 'REPEATING CODE: INDEFINITE LOOPS'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码：无限循环
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: The for loops and range for loops that you learned in [Chapter 3](ch03.xhtml#ch03)
    are convenient for looping through a string or range of indices. But what do we
    do when we have no string or when the indices do not follow a fixed pattern? We
    use a while loop, the topic of this chapter. while loops are more general than
    for loops and can handle situations that a for loop cannot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第3章](ch03.xhtml#ch03)中学习的for循环和range循环非常适合用来遍历字符串或索引范围。但是，当我们没有字符串或者索引不遵循固定模式时该怎么办呢？我们使用while循环，这是本章的主题。while循环比for循环更为通用，可以处理for循环无法应对的情况。
- en: 'We’ll solve three problems where for loops fall short: determining the number
    of times slot machines can be played, organizing a song playlist until the user
    wants to stop, and decoding an encoded message.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决三个for循环无法胜任的问题：确定老虎机可以玩多少次、组织播放列表直到用户希望停止以及解码一个编码的消息。
- en: 'Problem #8: Slot Machines'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #8：老虎机'
- en: How many times can slot machines be played before we run out of money? This
    is a subtle question that depends not only on our starting money but also on the
    pattern of winnings as we play. We’ll see that we need a while loop, not a for
    loop, for this situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有钱的情况下，老虎机可以玩多少次？这是一个微妙的问题，不仅依赖于我们最初的资金，还依赖于玩游戏时的中奖模式。我们会发现，这种情况需要使用while循环，而不是for循环。
- en: This is DMOJ problem ccc00s1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题ccc00s1。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Martha goes to a casino and brings *n* quarters. The casino has three slot machines,
    and she plays them in order until she has no quarters left. That is, she plays
    the first slot machine, then the second, then the third, then back to the first,
    then the second, and so on. Each play costs one quarter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎去赌场并带来了*n*个硬币。赌场有三台老虎机，她按顺序玩它们，直到没有硬币为止。也就是说，她先玩第一台老虎机，再玩第二台，再玩第三台，然后再回到第一台，依此类推。每次玩需要一个硬币。
- en: 'The slot machines operate according to the following rules:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎机的运行规则如下：
- en: The first slot machine pays 30 quarters every 35th time it is played.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一台老虎机每玩第35次支付30个硬币。
- en: The second slot machine pays 60 quarters every 100th time it is played.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二台老虎机每玩第100次支付60个硬币。
- en: The third slot machine pays 9 quarters every 10th time it is played.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三台老虎机每玩第10次会支付9个硬币。
- en: No other plays pay anything.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他游戏没有任何奖励。
- en: Determine the number of times Martha plays before she has no quarters left.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确定玛莎在没有硬币时玩多少次。
- en: Input
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of four lines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由四行组成。
- en: The first line contains an integer *n*, the number of quarters that Martha brings
    to the casino. *n* is between 1 and 1,000.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含一个整数*n*，即玛莎带到赌场的硬币数。*n*的范围是1到1000之间。
- en: The second line contains an integer indicating the number of times that the
    first slot machine has been played since it last paid. These plays occurred prior
    to Martha arriving, and Martha’s plays continue from there. For example, suppose
    that the first slot machine has been played 34 times since it last paid. Then,
    Martha will win 30 quarters the first time she plays it.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含一个整数，表示自上次支付以来第一台老虎机已被玩过的次数。这些游戏发生在玛莎到达之前，玛莎的游戏从这里开始。例如，假设第一台老虎机自上次支付以来已玩了34次。那么，玛莎第一次玩时将赢得30个硬币。
- en: The third line contains an integer indicating the number of times that the second
    slot machine has been played since it last paid.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行包含一个整数，表示自上次支付以来第二台老虎机已被玩过的次数。
- en: The fourth line contains an integer indicating the number of times that the
    third slot machine has been played since it last paid.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行包含一个整数，表示自上次支付以来第三台老虎机已被玩过的次数。
- en: Output
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'Output the following sentence, where x is the number of times Martha plays
    before she has no quarters left:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以下句子，其中 x 是玛莎在没有硬币时玩多少次：
- en: Martha plays x times before going broke.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎玩x次后破产。
- en: Exploring a Test Case
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索测试用例
- en: 'Let’s run through an example, just to make sure that everything in this problem
    is clear. Here’s the test case we’ll use:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示，确保这个问题中的每个细节都清楚明了。这里是我们使用的测试用例：
- en: '7'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '28'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '0'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'To carefully trace Martha’s plays, we’ll need to keep track of six pieces of
    information. It’s convenient to use a table to do this, since a row can tell us
    the state after each play. Here are our columns:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仔细追踪玛莎的游戏，我们需要跟踪六个信息点。使用表格来记录这些信息很方便，因为每一行可以告诉我们每次游戏后的状态。这里是我们的列：
- en: '**Plays** the number of slot machines that Martha has played'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩** 玛莎已经玩过的老虎机数量'
- en: '**Quarters** the number of quarters that Martha has'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**代币** 玛莎拥有的代币数量'
- en: '**Next play** the slot machine that Martha would play next'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一个游戏** 玛莎接下来要玩的老虎机'
- en: '**First plays** the number of times that the first machine has been played
    since it last paid'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一次游戏** 自上次支付以来，第一个老虎机已经被玩了多少次'
- en: '**Second plays** the number of times that the second machine has been played
    since it last paid'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二次游戏** 自上次支付以来，第二个老虎机已经被玩了多少次'
- en: '**Third plays** the number of times that the third machine has been played
    since it last paid'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三次游戏** 自上次支付以来，第三个老虎机已经被玩了多少次'
- en: 'To start, Martha has played zero slot machines, she has seven quarters, and
    she’ll next play the first slot machine. The first slot machine has been played
    28 times since it last paid, the second has been played 0 times since it last
    paid, and the third has been played 8 times since it last paid. Our state looks
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，玛莎已经玩过零次老虎机，她有七个代币，接下来她会玩第一个老虎机。自上次支付以来，第一个老虎机已经被玩了28次，第二个老虎机已经被玩了0次，第三个老虎机已经被玩了8次。我们的状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 7 | first | 28 | 0 | 8 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 7 | 第一个 | 28 | 0 | 8 |'
- en: 'Martha starts by playing the first slot machine. That costs one quarter. Because
    this is the 29th time this machine has been played since it last paid, not the
    35th, the slot machine pays Martha nothing. Martha will play the second slot machine
    next. This is our new state:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎从玩第一个老虎机开始。那需要一个代币。因为这是自上次支付以来，这台机器被玩过的第29次，而不是第35次，所以老虎机不会支付玛莎任何奖励。玛莎接下来会玩第二个老虎机。我们的新状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 6 | second | 29 | 0 | 8 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 6 | 第二次 | 29 | 0 | 8 |'
- en: 'Playing the second slot machine costs one quarter. Because this is the first
    time this machine has been played since it last paid, not the 100th, the slot
    machine pays Martha nothing. Martha will play the third slot machine next. This
    is our new state:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 玩第二个老虎机需要一个代币。因为这是自上次支付以来，这台机器被玩过的第一次，而不是第100次，所以老虎机不会支付玛莎任何奖励。玛莎接下来会玩第三个老虎机。我们的新状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 2 | 5 | third | 29 | 1 | 8 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 5 | 第三次 | 29 | 1 | 8 |'
- en: 'Playing the third slot machine costs one quarter. Because this is the 9th time
    this machine has been played since it last paid, not the 10th, the slot machine
    pays Martha nothing. Next, Martha will cycle back to the first slot machine. This
    is our new state:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 玩第三个老虎机需要一个代币。因为这是自上次支付以来，这台机器被玩过的第九次，而不是第十次，所以老虎机不会支付玛莎任何奖励。接下来，玛莎将回到第一个老虎机。我们新的状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 3 | 4 | first | 29 | 1 | 9 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | 第一个 | 29 | 1 | 9 |'
- en: 'Now Martha plays the first slot machine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玛莎玩第一个老虎机：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 4 | 3 | second | 30 | 1 | 9 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | second | 30 | 1 | 9 |'
- en: 'Then Martha plays the second slot machine:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，玛莎玩第二个老虎机：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 5 | 2 | third | 30 | 2 | 9 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | 第三次 | 30 | 2 | 9 |'
- en: 'Martha is almost out of quarters! But there’s good news coming, because she’s
    next going to play the third slot machine. It has been played nine times since
    it last paid. The next play is therefore its 10th, which pays Martha nine quarters.
    She had two quarters, pays one to play this machine, and then gets paid nine,
    so she’ll have 2 – 1 + 9 = 10 quarters after this play:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎几乎没有剩余的硬币了！但有好消息，因为接下来她将玩第三台老虎机。自从上次支付以来，它已经进行了九次游戏。因此，下一次游戏是它的第十次，这次将支付玛莎九个硬币。她原本有两个硬币，支付一个来玩这个机器，然后得到了九个硬币，所以她这次游戏后将有
    2 – 1 + 9 = 10 个硬币：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **播放次数** | **硬币数** | **下一次播放** | **第一次播放** | **第二次播放** | **第三次播放** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 6 | 10 | first | 30 | 2 | 0 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 10 | first | 30 | 2 | 0 |'
- en: Notice that the third slot machine has now been played zero times since it last
    paid.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到第三台老虎机自上次支付以来，已经进行了零次游戏。
- en: That’s six plays so far. I encourage you to keep tracing. You should see that
    Martha never gets paid again and that after 10 more plays (for a total of 16),
    Martha is broke.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止已经进行过六次播放。我鼓励你继续追踪。你应该会看到玛莎再也没有得到报酬，并且在再进行 10 次播放后（总共 16 次），玛莎破产了。
- en: A Limitation of for loops
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环的局限性
- en: In [Chapter 3](ch03.xhtml#ch03), we studied for loops. Standard for loops loop
    through a sequence, such as a string. We certainly have no string in the Slot
    Machines problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml#ch03)中，我们学习了 for 循环。标准的 for 循环会遍历一个序列，比如字符串。在老虎机问题中，我们当然没有字符串。
- en: Range for loops loop through a range of integers and can be used to loop a specified
    number of times. But how many times should we loop for Slot Machines? Ten? Fifty?
    Who knows. It depends on the number of plays that Martha can make before she’s
    out of quarters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Range for 循环遍历一个整数范围，可以用于指定次数的循环。但对于老虎机问题，我们应该循环多少次呢？十次？五十次？谁知道呢。这取决于玛莎能玩多少次，直到她用完硬币。
- en: We have no string and don’t know how many iterations are required. If all we
    had were for loops, we’d be stuck.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有字符串，也不知道需要多少次迭代。如果我们只有 for 循环，我们就会被卡住。
- en: Enter the *while loop*, the most general looping structure that Python offers.
    We can write while loops that have nothing to do with strings or sequences of
    integers. In return for this added flexibility, we’ll need to be a little more
    careful and take a little more responsibility with writing our loops. Let’s dig
    in!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 *while 循环*，这是 Python 提供的最通用的循环结构。我们可以编写与字符串或整数序列无关的 while 循环。为了获得这种额外的灵活性，我们需要更加小心，并对编写循环负更多责任。让我们深入了解一下！
- en: while loops
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: To write a while loop, we use Python’s while statement. A while loop is controlled
    by a Boolean expression. If the Boolean expression is True, then Python executes
    one iteration of the while loop. If the expression is still True, then Python
    executes another iteration of the while loop, and so on, until the Boolean expression
    is False. If the Boolean expression is False at the outset, then the loop does
    not run at all.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个 while 循环，我们使用 Python 的 while 语句。while 循环由一个布尔表达式控制。如果布尔表达式为 True，则 Python
    执行一次 while 循环的迭代。如果表达式仍为 True，则 Python 执行另一次迭代，以此类推，直到布尔表达式为 False。如果布尔表达式在开始时就是
    False，那么循环根本不会执行。
- en: 'while loops are *indefinite loops*: the number of iterations may not be known
    in advance.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环是 *不确定循环*：迭代次数可能事先无法知道。
- en: Using while loops
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 while 循环
- en: 'Let’s start with the following example of a while loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下的 while 循环示例开始：
- en: ❶ >>> num = 0
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> num = 0
- en: '❷ >>> while num < 5:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ >>> while num < 5:'
- en: '...      print(num)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '...      print(num)'
- en: ❸ ...     num = num + 1
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ...      num = num + 1
- en: '...'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: In a for loop, the loop variable is created for us; we don’t have to use an
    assignment statement to create the variable prior to the loop. But in a while
    loop, we get nothing for free. If we need a variable to loop through values in
    a while loop, then we have to create that variable ourselves. We do that here
    by making num refer to 0 prior to the loop ❶.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 循环中，循环变量是由系统自动创建的；我们不需要在循环前使用赋值语句创建变量。但在 while 循环中，我们什么都不免费获得。如果我们需要一个变量来遍历
    while 循环中的值，那么我们必须自己创建这个变量。我们在这里通过在循环之前让 num 等于 0 来实现这一点 ❶。
- en: The while loop itself is controlled by the Boolean expression num < 5 ❷. If
    num < 5 is True, then the code in the loop block will run. Right now, num refers
    to 0, so the Boolean expression is True. We therefore run the loop block, which
    outputs 0 and then increases num to 1 ❸.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We jump back to the top of the loop and evaluate the num < 5 Boolean expression
    again. As num refers to 1, the expression is True. We therefore run the loop block
    again, which outputs 1 and then increases num to 2.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the top of the loop: is num < 5 still True? It is, because num is only
    2. That kicks off another iteration of the loop, which outputs 2 and increases
    num to 3.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern continues, with two more iterations of the loop: one when num
    refers to 3 and one when num refers to 4. When num refers to 5, the num < 5 Boolean
    expression is finally False, which terminates the loop.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important that we remember to increase num ❸. A for loop automatically
    steps our loop variable through the appropriate values. But, again, we get nothing
    for free in a while loop and must update variables ourselves to bring us closer
    and closer to loop termination. If we forget to increase num, this happens:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = 0'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while num < 5:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '... forever'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If you run this code on your computer, your screen will fill up with zeros,
    and you’ll have to terminate your program. You can do that by pressing CTRL-C
    or by closing the Python window.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that num < 5 stays True forever; nothing in the loop can ever
    make it False. This situation, where a loop never terminates, is called an *infinite
    loop*. It’s surprisingly easy to inadvertently produce infinite while loops. If
    you see the same values repeating or your program appears to be doing nothing
    at all, it’s likely that you’re stuck in an infinite loop. Carefully check the
    while loop’s Boolean expression and that the loop block is making progress toward
    termination.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do whatever we like with the num variable. Here’s a while loop counting
    up by three:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = 0'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while num < 10:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '...     num = num + 3'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s a while loop counting down from 4 to 0:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = 4'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '❶ >>> while num >= 0:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '...     num = num - 1'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’ve used >= here rather than > ❶. This way, the while loop runs
    when num refers to 0, as desired.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: n = 3
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'while n > 0:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'if n == 5:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: n = -100
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: print(n)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: n = n + 1
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: A.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: B.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: C.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '-100'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: D.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '-100'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. A while loop’s Boolean expression is checked only at the start of
    each iteration. Even if it becomes False at some point during the iteration, the
    remainder of the iteration completes.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: As 3 is greater than 0, an iteration of the loop runs. The if statement block
    is skipped (because its Boolean expression is False), so this iteration outputs
    3 and sets n to 4. As 4 is greater than 0, we have another iteration of the loop,
    this one outputting 4 and setting n to 5. As 5 is greater than 0, we have yet
    another iteration of the loop. This time, the if statement block runs, which sets
    n to -100. Next, -100 is output, and n is set to -99. And here we stop, because
    n > 0 is False.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: x = 6
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'while x > 4:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: x = x - 1
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: A.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: B.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: C.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: D.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: E.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. Many while loops do something and then update the loop variable,
    but not this one. This one first decrements the loop variable x and *then* outputs
    it. As 6 is greater than 4, an iteration of the loop runs, which assigns 5 to
    x and then outputs 5. Next, 5 is greater than 4, so we have another iteration,
    this one assigning 4 to x and outputting 4. And that’s it: 4 is not greater than
    4, so the loop terminates.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Loops in Loops
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can nest loops inside of while loops, much as we can nest loops inside of
    for loops. In “Nesting” in [Chapter 3](ch03.xhtml#ch03), I noted that the inner
    for loop completes all of its iterations before the next iteration of the outer
    loop begins. The same holds for while loops. Here’s an example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < 3:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '...     j = 8'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '...     while j < 11:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '...         print(i, j)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '...         j = j + 1'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 0 8
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 0 9
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 0 10
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 1 8
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 1 9
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 1 10
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 2 8
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 2 9
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 2 10
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Each value of i is involved in three lines of output, one for each iteration
    of the inner j loop.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: How many lines are output by the following nested loop?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: y = 1
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'while x < 3:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'while y < 3:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: print(x, y)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: y = y + 1
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: x = x + 1
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: A. 2
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: B. 3
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: C. 6
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: D. 8
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: E. 9
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The outer loop’s Boolean expression, x < 3, is True, so we perform
    an iteration of the outer loop. That leads to two iterations of the inner loop:
    one when y is 1 and one when y is 2, each of which prints a line of output. So
    that’s two lines of output so far.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: But nothing in the code resets y’s value! Therefore, y < 3 will never be True
    again, and there won’t be any further iterations of the inner loop.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to reset a loop variable is a common mistake when dealing with nested
    while loops.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Adding Boolean Operators
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To solve Slot Machines, we want to loop while Martha has at least one quarter.
    That looks like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'while quarters >= 1:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'That simple Boolean expression will suffice for this problem. But just like
    for if statements, the Boolean expression following the word while can include
    relational or Boolean operators. Here’s an example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = 4'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = 10'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while x <= 10 and y <= 13:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(x, y)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '...     x = x + 1'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '...     y = y + 1'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 4 10
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 5 11
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 6 12
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 7 13
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The while loop is controlled by the Boolean expression x <= 10 and y <= 13.
    As with any and operator, both of its operands must be True for the whole expression
    to be True. When x refers to 8 and y refers to 14, the loop terminates because
    the y <= 13 operand is False.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环由布尔表达式 x <= 10 和 y <= 13 控制。与任何 `and` 运算符一样，只有当两个操作数都为 `True` 时，整个表达式才为
    `True`。当 x 为 8，y 为 14 时，循环终止，因为 y <= 13 操作数为 `False`。'
- en: Solving the Problem
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: To solve Slot Machines, we know that we need a while loop, not a for loop, because
    we can’t predict the number of iterations in advance. Each iteration of the loop
    will play the current slot machine. When the loop terminates, Martha will have
    no quarters left, and we will output the number of times she played.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决老虎机问题，我们知道需要使用 `while` 循环，而不是 `for` 循环，因为我们无法预先预测迭代次数。每次循环迭代将玩当前的老虎机。当循环结束时，Martha
    将没有硬币，我们将输出她玩了多少次。
- en: 'Here’s what we need to do on each iteration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每次迭代时需要做的事情：
- en: Decrease Martha’s quarters by one (since it costs one quarter to play a slot
    machine).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Martha 的硬币数量减少一（因为玩一次老虎机需要一枚硬币）。
- en: If Martha is currently on the first slot machine, play that machine. This involves
    increasing the number of times this machine has been played. If this is the 35th
    play, then pay Martha and reset the number of times that this machine has been
    played to 0.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Martha 当前正在玩第一台老虎机，则玩该机器。这涉及到增加该机器的游戏次数。如果这是第 35 次游戏，则支付 Martha，并将该机器的游戏次数重置为
    0。
- en: If Martha is currently on the second slot machine, play that machine (similar
    to how we played the first machine).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Martha 当前正在玩第二台老虎机，则玩该机器（类似于我们玩第一台机器的方式）。
- en: If Martha is currently on the third slot machine, play that machine (similar
    to how we played the first machine).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Martha 当前正在玩第三台老虎机，则玩该机器（类似于我们玩第一台机器的方式）。
- en: Increase the number of Martha’s plays (since we just played a machine).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 Martha 的游戏次数（因为我们刚刚玩了一台机器）。
- en: Move to the next machine. If Martha just played the first machine, we want to
    move to the second; if she just played the second, we want to move to the third;
    and if she just played the third, we want to cycle back to the first.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动到下一台机器。如果 Martha 刚玩过第一台机器，我们要移动到第二台；如果她刚玩过第二台，我们要移动到第三台；如果她刚玩过第三台，我们要回到第一台。
- en: Our programs are getting longer now, so outlining the plan as I just did is
    a useful technique for keeping the complexity under control and guiding us toward
    correct code. We can use the outline to make sure we’re following the plan and
    not forgetting anything.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序现在变得更长了，因此像我刚才做的那样列出计划是一种有效的技术，有助于控制复杂性并引导我们写出正确的代码。我们可以使用这个大纲来确保我们在按照计划执行，且没有遗漏任何步骤。
- en: Our code is in [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码在[清单 4-1](ch04.xhtml#ch04ex01)中。
- en: quarters = int(input())
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = int(input())
- en: first = int(input())
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: first = int(input())
- en: second = int(input())
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: second = int(input())
- en: third = int(input())
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: third = int(input())
- en: plays = 0
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: plays = 0
- en: ❶ machine = 0
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ machine = 0
- en: '❷ while quarters >= 1:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ while quarters >= 1:'
- en: ❸ quarters = quarters - 1
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ quarters = quarters - 1
- en: '❹ if machine == 0:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ if machine == 0:'
- en: first = first + 1
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: first = first + 1
- en: '❺ if first == 35:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ if first == 35:'
- en: first = 0
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: first = 0
- en: quarters = quarters + 30
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 30
- en: 'elif machine == 1:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif machine == 1:'
- en: second = second + 1
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: second = second + 1
- en: 'if second == 100:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'if second == 100:'
- en: second = 0
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: second = 0
- en: quarters = quarters + 60
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 60
- en: 'elif machine == 2:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif machine == 2:'
- en: third = third + 1
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: third = third + 1
- en: 'if third == 10:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'if third == 10:'
- en: third = 0
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: third = 0
- en: quarters = quarters + 9
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 9
- en: ❻ plays = plays + 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ plays = plays + 1
- en: ❼ machine = machine + 1
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ machine = machine + 1
- en: '❽ if machine == 3:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '❽ if machine == 3:'
- en: machine = 0
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: machine = 0
- en: print('Martha plays', plays, 'times before going broke.')
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: print('Martha plays', plays, 'times before going broke.')
- en: '*Listing 4-1: Solving Slot Machines*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：解决老虎机问题*'
- en: The quarters variable tracks the number of quarters that Martha has. The first,
    second, and third variables track the number of plays since the last payment for
    the first, second, and third slot machines, respectively.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: quarters 变量跟踪 Martha 拥有的硬币数量。first、second 和 third 变量分别跟踪自上次支付以来，第一个、第二个和第三个老虎机的游戏次数。
- en: The machine variable tracks the slot machine that Martha will play next. The
    first slot machine is referred to by the number 0, the second by the number 1,
    and the third by 2. Making machine refer to 0 therefore indicates that the first
    slot machine will be played next ❶.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: machine 变量跟踪 Martha 将要玩的下一台老虎机。第一台老虎机用数字 0 表示，第二台用数字 1 表示，第三台用数字 2 表示。因此，将 machine
    设置为 0 表示下一台要玩的老虎机是第一台 ❶。
- en: 'We could have referred to the slot machines using 1, 2, and 3 instead of 0,
    1, and 2. Or we could have used strings: ''first'', ''second'', and ''third''.
    But numbering items starting from zero is customary, so that’s what I’ve done
    here.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以用 1、2 和 3 来代替 0、1 和 2 来表示老虎机。或者我们也可以使用字符串：'first'、'second' 和 'third'。但从零开始编号是惯例，因此我在这里采用了这种方式。
- en: The final variable in this program is plays, which tracks the number of slot
    machines that Martha has played. We’ll output this once Martha is out of quarters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的最终变量是 plays，它跟踪玛莎玩过的老虎机次数。等玛莎的硬币用完时，我们会输出这个值。
- en: The bulk of the program consists of a while loop that loops as long as Martha
    has quarters ❷.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主体部分是一个 while 循环，它在玛莎有硬币的情况下不断循环 ❷。
- en: Each iteration of the loop plays one slot machine. As such, the first thing
    we do is decrease Martha’s quarters by one ❸. Next, we play the current slot machine.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环都会玩一个老虎机。因此，首先我们会将玛莎的硬币减少 1 ❸。接着，我们玩当前的老虎机。
- en: Are we on slot machine 0? Slot machine 1? Slot machine 2? We need an if statement
    to answer that.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在老虎机 0 上吗？老虎机 1 上吗？老虎机 2 上吗？我们需要一个 if 语句来回答这个问题。
- en: We first check whether we’re on slot machine 0 ❹. If we are, then we increase
    the number of plays since this slot machine paid by one. To determine whether
    Martha gets paid, we then check whether this machine has been played exactly 35
    times since it last paid ❺. If it has, then we reset this machine’s plays to 0
    and increase Martha’s quarters by 30.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否在老虎机 0 上 ❹。如果是，那么我们增加游戏次数，因为这个老虎机支付了玛莎一个硬币。接下来，我们检查玛莎是否会获得支付，方法是检查自上次支付以来这个机器是否已被玩了
    35 次 ❺。如果是，那么我们将这个机器的游戏次数重置为 0，并增加玛莎 30 个硬币。
- en: There are several levels of nesting here, so take some time to convince yourself
    that the logic of the code is correct. In particular, note that every time we
    play the first machine, we increase its number of plays by one. But we only pay
    Martha after every 35 plays—that’s why we have the inner if statement ❺!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个层次的嵌套，因此花点时间确认代码逻辑是正确的。特别注意，每次我们玩第一个机器时，我们都会将它的游戏次数增加 1。但我们只在每 35 次游戏后才支付玛莎——这就是为什么我们需要内层的
    if 语句 ❺！
- en: We handle the second and third slot machines just as we handled the first. The
    only difference is that each slot machine pays Martha after its own number of
    plays and pays Martha its own amount of quarters.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理第二和第三个老虎机的方式与处理第一个老虎机一样。唯一的区别是每个老虎机在它自己规定的次数后支付玛莎，并支付她对应数量的硬币。
- en: Having played a slot machine, we increase Martha’s number of plays by one ❻.
    Now all that’s left is to move to the next machine so that we’ll be at the right
    machine if there’s a next iteration of the loop.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 玩过老虎机后，我们将玛莎的游戏次数增加了 1 ❻。现在只剩下移动到下一个机器，如果有下一次循环的话，我们就能在正确的机器上。
- en: To move to the next machine, we increase machine by one ❼. If we were on machine
    0, this would move us to machine 1. If we were on machine 1, this would move us
    to machine 2. If we were on machine 2, this would move us to machine 3.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动到下一个机器，我们将 machine 增加 1 ❼。如果我们在机器 0 上，这将把我们移到机器 1。如果我们在机器 1 上，这将把我们移到机器
    2。如果我们在机器 2 上，这将把我们移到机器 3。
- en: '*. . .* Machine 3? There’s no machine 3! If we just played machine 2, then
    we want to start over at machine 0\. To do that, we add a check: if we just moved
    to machine 3 ❽, then we know that we just played machine 2, so we reset machine
    to machine 0.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*. . .* 机器 3？没有机器 3！如果我们刚刚玩过机器 2，那么我们希望从机器 0 开始重新来过。为此，我们添加了一个检查：如果我们刚刚移动到机器
    3 ❽，那么我们知道我们刚才玩过机器 2，因此将 machine 重置为机器 0。'
- en: When the loop terminates, we know that Martha has no quarters left. As a last
    step, we output the required sentence, including Martha’s number of plays.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环终止时，我们知道玛莎已经没有硬币了。最后，我们输出所需的句子，包括玛莎的游戏次数。
- en: 'This code has a lot going on: stopping when Martha has no quarters left, keeping
    track of the current machine, paying Martha when appropriate, and counting Martha’s
    plays. Feel free to submit this code now, but also to consider whether you’d have
    written parts of it in a different way. What happens if you increase plays by
    1 at the top of the loop instead of the bottom? Does it matter whether you decrease
    quarters by 1 at the top of the loop or the bottom? Would you have used new variables
    to keep track of the number of times that Martha played each slot machine, rather
    than modifying first, second, and third? I strongly encourage you to experiment
    with variations of what we’ve done here. If you make changes and the code no longer
    passes the tests, great! Now you have a new learning opportunity to fix the code
    and learn why your changes led to undesired behavior.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了很多内容：当玛莎没有硬币时停止，跟踪当前的机器，适时支付玛莎，并计算玛莎的游戏次数。现在你可以提交这段代码，但也可以考虑是否会以不同的方式编写其中的部分代码。如果你在循环顶部增加plays的值而不是底部会发生什么？你是否认为在循环顶部或底部减少硬币数有区别？你会不会使用新的变量来跟踪玛莎玩过每台老虎机的次数，而不是修改first、second和third？我强烈鼓励你尝试不同的实现方式。如果你做了修改，并且代码不再通过测试，那太好了！现在你有了新的学习机会，去修复代码并了解为什么你的修改导致了不期望的行为。
- en: The next two sections offer further refinement of the code. We’ll use the %
    operator to reduce the number of variables that we need and learn about f-strings
    to streamline how we build strings.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将进一步改进代码。我们将使用%运算符来减少所需的变量数量，并学习如何使用f-strings来简化字符串的构建。
- en: The Mod Operator
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模运算符
- en: 'In “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01), I
    introduced the mod (%) operator for calculating the remainder of an integer division.
    For example, 16 divided by 5 has a remainder of 1:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.xhtml#ch01)的“整数和浮点数”一节中，我介绍了用于计算整数除法余数的模（%）运算符。例如，16除以5的余数是1：
- en: '>>> 16 % 5'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 16 % 5'
- en: '1'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'And 15 divided by 5 has a remainder of 0 (because 5 divides 15 exactly):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 而15除以5的余数是0（因为5恰好能除尽15）：
- en: '>>> 15 % 5'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 15 % 5'
- en: '0'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'The second operand dictates the range of values that % can possibly return.
    The possible return values are 0 up to but not including the second operand. For
    example, if the second operand is 3, then the only values that can be returned
    by % are 0, 1, and 2\. In addition, as we increase the first operand, we cycle
    through all possible return values. Here’s an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作数决定了%运算符可能返回的值的范围。可能的返回值是从0开始，直到但不包括第二个操作数。例如，如果第二个操作数是3，那么%运算符可能返回的值只有0、1和2。另外，随着第一个操作数的增加，我们会在所有可能的返回值之间循环。下面是一个示例：
- en: '>>> 0 % 3'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 0 % 3'
- en: '0'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> 1 % 3'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1 % 3'
- en: '1'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> 2 % 3'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2 % 3'
- en: '2'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> 3 % 3'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 3 % 3'
- en: '0'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> 4 % 3'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 % 3'
- en: '1'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> 5 % 3'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 % 3'
- en: '2'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> 6 % 3'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 6 % 3'
- en: '0'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> 7 % 3'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 7 % 3'
- en: '1'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'Notice the pattern: 0, 1, 2, 0, 1, 2, and so on.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个模式：0，1，2，0，1，2，如此循环。
- en: 'This behavior is useful for counting up to a specified number and then cycling
    back to 0\. It’s exactly the behavior that we need when playing the slot machines:
    we play slot machine 0, then 1, then 2, then 0, then 1, then 2, then 0, then 1,
    and so on. (This is another reason why I used 0, 1, and 2, rather than other values,
    to refer to the slot machines.)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于计算达到指定数量后再返回0非常有用。它正是我们玩老虎机时需要的行为：我们先玩老虎机0，然后是1，再是2，然后回到0，再是1，再是2，如此循环。（这也是为什么我用0、1、2，而不是其他值，来代表老虎机的原因。）
- en: 'Suppose that variable plays refers to the number of times that Martha has played.
    To determine the next machine to play (0, 1, or 2), we can use the % operator.
    For example, suppose that Martha has played one slot machine so far, and we want
    to know which she will play next. She’ll play slot machine 1 next, and the % operator
    tells us that:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量plays表示玛莎已经玩的次数。为了确定下一个她将玩的机器（0、1或2），我们可以使用%运算符。例如，假设玛莎到目前为止只玩了一台老虎机，我们想知道她接下来会玩哪一台。她接下来会玩老虎机1，而%运算符告诉我们：
- en: '>>> plays = 1'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays = 1'
- en: '>>> plays % 3'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays % 3'
- en: '1'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'If Martha has played six times so far, then she’s played slot machines 0, 1,
    2, 0, 1, 2\. The next slot machine she’ll play is machine 0\. And, as she’s played
    all three machines twice, with no other plays beyond that, the % operator gives
    us 0:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玛莎到目前为止玩了六次，那么她玩过老虎机0、1、2、0、1、2。接下来她将玩的是老虎机0。而且，由于她已经玩过这三台机器两次，且没有其他额外的游戏，%运算符给出的结果是0：
- en: '>>> plays = 6'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays = 6'
- en: '>>> plays % 3'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays % 3'
- en: '0'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'As a final example, suppose that Martha has played 11 times so far. She’s done
    three complete cycles: 0, 1, 2, 0, 1, 2, 0, 1, 2\. That’s nine of the plays. The
    remaining two plays put Martha on slot machine 2 for her next play:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plays = 11'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plays % 3'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: That is, we can figure out the slot machine to play without explicitly maintaining
    a machine variable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use % to simplify the logic of determining whether the next play
    on the current slot machine pays Martha. Consider the first slot machine. In [Listing
    4-1](ch04.xhtml#ch04ex01), we counted the number of plays since the slot machine
    paid. If that number is 35, then we pay Martha and reset the count to 0\. But
    there’s no need to reset the count if we’re using the % operator. We can just
    check whether the slot machine has been played a multiple of 35 times and pay
    Martha if so. To test whether a number is a multiple of 35, we can use the % operator.
    A number is a multiple of 35 if dividing it by 35 yields no remainder:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first = 35'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first % 35'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first = 48'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first % 35'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first = 70'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first % 35'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first = 175'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first % 35'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: We can just check first % 35 == 0 to determine whether to pay Martha.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: I’ve updated [Listing 4-1](ch04.xhtml#ch04ex01) to use the % operator. The new
    code is in [Listing 4-2](ch04.xhtml#ch04ex02).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: quarters = int(input())
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: first = int(input())
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: second = int(input())
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: third = int(input())
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: plays = 0
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'while quarters >= 1:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: ❶ machine = plays % 3
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: quarters = quarters - 1
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'if machine == 0:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: first = first + 1
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if first % 35 == 0:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: quarters = quarters + 30
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'elif machine == 1:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: second = second + 1
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'if second % 100 == 0:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: quarters = quarters + 60
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'elif machine == 2:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: third = third + 1
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'if third % 10 == 0:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: quarters = quarters + 9
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: plays = plays + 1
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: print('Martha plays', plays, 'times before going broke.')
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-2: Solving Slot Machines using* %'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve used % in the two ways described in this section: to determine the current
    machine based on the number of plays ❶ and to determine whether Martha gets paid
    on a play (for example, at ❷).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Associating % with returning the remainder of a division belies its flexibility.
    Whenever you need to count in a cycle (0, 1, 2, 0, 1, 2), consider whether you
    can use % to simplify your code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: F-Strings
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final thing we do in our solution to Slot Machines is output the required
    sentence, like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: print('Martha plays', plays, 'times before going broke.')
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to remember to end the first string so that we can output the number
    of plays and then start a new string for the second half of the sentence. In addition,
    we’re using multiple arguments to print to avoid having to convert plays to a
    string. If we were storing the resulting string rather than printing it, we’d
    need the str conversion:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plays = 6'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '>>> result = ''Martha plays '' + str(plays) + '' times before going broke.'''
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '>>> result'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '''Martha plays 6 times before going broke.'''
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Gluing strings and integers together is fine for a simple sentence like this,
    but it doesn’t scale. Here’s how it looks when we try to embed three integers
    instead of one:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串和整数拼接在一起对于像这样的简单句子来说是可以的，但它不具备可扩展性。以下是我们尝试嵌入三个整数而不是一个时的样子：
- en: '>>> num1 = 7'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num1 = 7'
- en: '>>> num2 = 82'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num2 = 82'
- en: '>>> num3 = 11'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num3 = 11'
- en: '>>> ''We have '' + str(num1) + '', '' + str(num2) + '', and '' + str(num3)
    + ''.'''
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''We have '' + str(num1) + '', '' + str(num2) + '', and '' + str(num3)
    + ''.'''
- en: '''We have 7, 82, and 11.'''
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '''We have 7, 82, and 11.'''
- en: We don’t want to have to keep track of all of those quotes, pluses, and spaces.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次都要追踪所有的引号、加号和空格。
- en: 'The most flexible way to build a string consisting of strings and numbers is
    to use an *f-string*. Here’s how the previous example looks with an f-string:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包含字符串和数字的字符串最灵活的方法是使用 *f-string*。下面是前一个示例使用 f-string 的样子：
- en: '>>> num1 = 7'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num1 = 7'
- en: '>>> num2 = 82'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num2 = 82'
- en: '>>> num3 = 11'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num3 = 11'
- en: '>>> f''We have {num1}, {num2}, and {num3}.'''
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f''We have {num1}, {num2}, and {num3}.'''
- en: '''We have 7, 82, and 11.'''
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '''We have 7, 82, and 11.'''
- en: 'Notice the f before the opening quote of the string. The f stands for format,
    because f-strings allow you to format the contents of a string. Inside of an f-string,
    we can place expressions inside curly brackets. As the string is being built,
    each expression is replaced by its value and inserted into the string. The result
    is just a regular old string—there’s no new type here:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串的开头有一个 f。这个 f 代表格式化，因为 f-strings 允许你格式化字符串的内容。在 f-string 中，我们可以将表达式放入花括号中。当字符串构建时，每个表达式都会被其值替换并插入到字符串中。结果只是一个普通的字符串——这里没有新的类型：
- en: '>>> type(f''hello'')'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(f''hello'')'
- en: <class 'str'>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'str'>
- en: '>>> type(f''{num1} days'')'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(f''{num1} days'')'
- en: <class 'str'>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'str'>
- en: 'The expressions in the curly brackets can be more complex than bare variable
    names:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号中的表达式可以比简单的变量名更复杂：
- en: '>>> f''The sum is {num1 + num2 + num3}'''
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f''The sum is {num1 + num2 + num3}'''
- en: '''The sum is 100'''
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '''The sum is 100'''
- en: 'We can use f-strings in the final line of Slot Machines. Here’s how that would
    look:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Slot Machines 的最后一行使用 f-strings。下面是它的样子：
- en: print(f'Martha plays {plays} times before going broke.')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: print(f'Martha plays {plays} times before going broke.')
- en: Even in this simplest of string-formatting contexts, I think f-strings add clarity.
    Keep them in the back of your mind for whenever you catch yourself building a
    string from smaller pieces.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个最简单的字符串格式化上下文中，我认为 f-strings 增加了清晰度。每当你发现自己在将多个部分拼接成一个字符串时，记得使用它们。
- en: 'One warning about f-strings: they were added in Python 3.6, which at the time
    of writing is still a reasonably recent version of Python. In older versions of
    Python, f-strings cause syntax errors.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 f-strings 的一个警告：它们是在 Python 3.6 中加入的，而在本文写作时，Python 3.6 仍然是相对较新的版本。在 Python
    的旧版本中，f-strings 会导致语法错误。
- en: If you use f-strings, be sure to check that the judge you’re submitting to is
    using Python 3.6 or newer to test your code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 f-strings，请确保检查你提交的评测环境是否使用 Python 3.6 或更高版本来测试你的代码。
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决《章节练习》中的第 1 题，位于 [第 99 页](ch04.xhtml#ch04lev1sec17)。
- en: 'Problem #9: Song Playlist'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #9：歌曲播放列表'
- en: Sometimes we don’t know in advance how much input will be provided. We’ll see
    in this problem that a while loop is what we need in such cases.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们无法提前知道会提供多少输入。在这个问题中，我们将看到在这种情况下，while 循环是我们所需要的。
- en: This is DMOJ problem ccc08j2.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 ccc08j2。
- en: The Challenge
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'We have five favorite songs named A, B, C, D, and E. We’ve created a playlist
    of these songs and are using an app to manage the playlist. The songs start off
    in the order A, B, C, D, E. The app has four buttons:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五首最喜欢的歌，分别是 A、B、C、D 和 E。我们已经创建了一个包含这些歌曲的播放列表，并使用一个应用程序来管理这个播放列表。歌曲最初的顺序是
    A、B、C、D、E。应用程序有四个按钮：
- en: 'Button 1: Moves the first song of the playlist to the end of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to B,
    C, D, E, A.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 1：将播放列表中的第一首歌移到播放列表的末尾。例如，如果播放列表目前是 A, B, C, D, E，那么它将变成 B, C, D, E, A。
- en: 'Button 2: Moves the last song of the playlist to the beginning of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to E,
    A, B, C, D.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 2：将播放列表中的最后一首歌移到播放列表的最前面。例如，如果播放列表目前是 A, B, C, D, E，那么它将变成 E, A, B, C, D。
- en: 'Button 3: Swaps the first two songs of the playlist. For example, if the playlist
    is currently A, B, C, D, E, then it changes to be B, A, C, D, E.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 3：交换播放列表中的前两首歌曲。例如，如果播放列表目前是 A, B, C, D, E，那么它将变成 B, A, C, D, E。
- en: 'Button 4: Plays the playlist!'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 4：播放播放列表！
- en: We’re provided a user’s button presses. When the user presses button 4, output
    the order of songs in the playlist.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of pairs of lines, where the first line of a pair gives
    the number of a button (1, 2, 3, or 4), and the second gives the number of times
    that the user pressed this button (between 1 and 10). That is, the first line
    is the number of a button, the second line is the number of times it is pressed,
    the third line is the number of a button, the fourth line is the number of times
    it is pressed, and so on. The input ends with these two lines:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: indicating that the user pressed button 4 once.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the order of songs in the playlist after all button presses. The output
    must be on one line, with a space separating each pair of songs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: String Slicing
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The high-level plan of our solution to Song Playlist will be a while loop that
    keeps going as long as we haven’t found the press of button 4. On each iteration,
    we’ll read two lines of input and process them. That leads to this structure:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: ❶ button = 0
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'while button != 4:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '# Read button'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '# Read number of presses'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '# Process button presses'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the while loop, we create the variable button and make it refer to
    the number 0 ❶. Without this, the button variable would not exist, and we’d get
    a NameError in the while loop’s Boolean expression. Any number besides 4 would
    work here to trigger the first iteration of the loop.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Within this while loop, we’ll use a for loop to process the button presses.
    For each press, we’ll use an if statement to check which button was pressed. We’ll
    need four indented blocks of statements in the if statement, one for each of the
    four buttons.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about how to handle each of the buttons. Button 1 moves the first
    song of the playlist to the end of the playlist. Because we have a small, known
    number of songs, we can get away with using string indexing to concatenate each
    character. Remember that the first character of a string is at index 0, not 1\.
    We can put that character at the end of the string like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '>>> songs = ''ABCDE'''
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '>>> songs = songs[1] + songs[2] + songs[3] + songs[4] + songs[0]'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '>>> songs'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '''BCDEA'''
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: This is rather unwieldy and is specific to having exactly five songs. We can
    use string slicing to write more general and less error-prone code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '*Slicing* is a Python feature that lets us refer to a substring of a string.
    (In fact, it works on any sequence, as we’ll see later in the book.) It takes
    two indices: the index where we want to start, and the index one to the right
    of where we want to end. If we use indices 4 and 8, for example, then we get the
    characters at indices 4, 5, 6, and 7\. Slicing uses square brackets, with a colon
    between the two indices:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''abcdefghijk'''
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[4:8]'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '''efgh'''
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'The slicing doesn’t change what s refers to. We can make s refer to the slice
    by using an assignment statement:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '''abcdefghijk'''
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = s[4:8]'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '''efgh'''
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to make an off-by-one error here and think that s[4:8] includes the
    character at index 8\. But it doesn’t, just like range(4, 8) doesn’t include the
    8. So while this behavior may be a little counterintuitive, it’s applied consistently
    in both range and slicing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'We must always include the colon when performing string slicing, but the start
    and end indices are optional. If we leave off the start index, Python starts slicing
    at index 0:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''abcdefghijk'''
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[:4]'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '''abcd'''
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'If we leave off the end index, Python slices until the end of the string:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[4:]'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '''efghijk'''
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'And leaving out both indices? That gives us a slice consisting of the entire
    string:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[:]'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '''abcdefghijk'''
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use negative indices in a slice. Here’s an example:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[-4:]'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '''hijk'''
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: The start index refers to the fourth character from the right, which is 'h',
    and the end index is omitted. We therefore get a slice from the 'h' to the end
    of the string.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike indexing, slicing never produces an index error. If we use indices that
    are outside of the string, Python slices to the appropriate end of the string:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[8:20]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '''ijk'''
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[-50:2]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '''ab'''
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use string slicing to implement the behaviors of buttons 1, 2, and 3.
    Here’s what the code looks like for button 1:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '>>> songs = ''ABCDE'''
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '>>> songs = songs[1:] + songs[0]'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '>>> songs'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '''BCDEA'''
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The slice gives us the entire string except for the character at index 0\. (There’s
    nothing specific to a string of length 5 here; this code would work on a nonempty
    string of any length.) Appending that missing character results in the first song
    moving to the end of the playlist. The slicing for the other buttons is similar;
    you’ll see that code next.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: game = 'Lost Vikings'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: print(game[2:-6])
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: A. st V
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: B. ost V
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: C. iking
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: D. st Vi
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: E. Viking
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The character at index 2 is the ''s'' in ''Lost''. The character
    at index -6 is the first ''i'' in ''Vikings''. Since we go from index 2 up to
    but not including index -6, we get the slice ''st V''.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Which password gets us out of the following loop?
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: valid = False
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'while not valid:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: s = input()
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: valid = len(s) == 5 and s[:2] == 'xy'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: A. xyz
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: B. xyabc
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: C. abcxy
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: D. More than one of the above passwords get us out of the loop
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: E. None; the loop never executes and no passwords are obtained
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The while loop terminates when valid is True (because then not valid
    is False). The only one of the given passwords whose length is 5 and whose first
    two characters are ''xy'' is xyabc. This is therefore the only given password
    that sets valid to True and ends the loop.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have some practice using while loops to loop as long as there are
    more buttons to handle, and using slicing for string manipulation, we’re ready
    to solve Song Playlist. See [Listing 4-3](ch04.xhtml#ch04ex03) for the code.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: songs = 'ABCDE'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: button = 0
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '❶ while button != 4:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: button = int(input())
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: presses = int(input())
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(presses):'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'if button == 1:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: ❸ songs = songs[1:] + songs[0]
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'elif button == 2:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: ❹ songs = songs[-1] + songs[:-1]
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'elif button == 3:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: ❺ songs = songs[1] + songs[0] + songs[2:]
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: ❻ output = ''
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'for song in songs:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: output = output + song + ' '
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: ❼ print(output[:-1])
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-3: Solving Song Playlist*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The while loop continues as long as button 4 hasn’t been pressed ❶. On each
    iteration of the while loop, we read the button number and then read the number
    of times that this button was pressed.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Now, nested in the outer while loop, we need to loop once per button press.
    Keep all of the loop types in mind as you decide which to use. Here, a range for
    loop is the best choice ❷, since it’s the easiest way to loop exactly the number
    of times we specify.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The behavior inside the range for loop depends on which button is pressed. We
    therefore use an if statement to check the button number and modify the playlist
    accordingly. If button 1 is pressed, we use slicing to move the first song to
    the end of the playlist ❸. If button 2 is pressed, we use slicing to move the
    last song to the beginning of the playlist ❹. To do that, we start with the character
    at the right end of the string and then use slicing to append all other characters.
    For button 3, we need to modify the playlist so that the first two songs swap
    positions. We build a new string with the character at index 1, then the character
    at index 0, and then all of the characters starting at index 2 ❺.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Once we escape the while loop, we need to output the songs, with a space between
    each pair of songs. We can’t just output songs, because that doesn’t have spaces.
    Instead, we build an output string that has the appropriate spaces. To do that,
    we start with the empty string ❻ and then use a for loop to concatenate each song
    and a space. One small annoyance is that this adds a space to the end of the string,
    after the last song, and we don’t want that. We therefore use slicing to remove
    that final space character ❼.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to submit to the judge.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 3 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #10: Secret Sentence'
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if we have a string and even if we know how much input will be provided,
    a while loop may still be the required type of loop. This problem demonstrates
    why this can be the case.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem coci08c3p2.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Luka is writing a secret sentence in class. He doesn’t want the teacher to be
    able to read it, so instead of writing down the original sentence, he writes down
    an encoded version. After each vowel in the sentence (*a*, *e*, *i*, *o*, or *u*),
    he adds the letter *p* and that vowel again. For example, rather than write down
    the sentence *i like you*, he would write *ipi lipikepe yopoupu*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: The teacher acquires Luka’s encoded sentence. Recover Luka’s original sentence
    for the teacher.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input is one line of text, Luka’s encoded sentence. It consists of lowercase
    letters and spaces. There is exactly one space between each pair of words. The
    maximum length of the line is 100 characters.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output Luka’s original sentence.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Another Limitation of for loops
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch03), we learned how for loops can be used to process
    strings. A for loop plods through the string, from beginning to end, one character
    at a time. In many cases, that’s precisely what we want. In Three Cups, for example,
    we needed to look at each swap from left to right, so we used a for loop over
    the string of swaps.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'In other cases, that’s too restrictive, and a range for loop may be more appropriate.
    A range for loop gives us access to indices rather than characters. It also allows
    us to skip through a sequence with whatever step size we choose. For example,
    we can use a range for loop to visit every third character of a string:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''zephyr'''
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(0, len(s), 3):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(s[i])'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: z
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: h
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a range for loop to process a string from right to left instead
    of left to right:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(s) - 1, -1, -1):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(s[i])'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: r
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: y
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: h
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: p
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: e
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: z
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: All of this assumes that we want to step by a fixed amount on each iteration.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: What if sometimes we want to move one character to the right and other times
    we want to move three characters to the right? That’s not at all farfetched. In
    fact, if we could do that, then we’d be well on our way to solving Secret Sentence.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'To see why, consider this test case:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: ipi lipikepe yopoupu
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we’re reconstructing Luka’s original sentence by copying characters
    to it. The first character in the encoded sentence is the vowel i. This is the
    first character of Luka’s original sentence, too. Based on how Luka encodes sentences,
    we know that the next two characters will be p and i. We don’t want to include
    those in Luka’s original sentence, so we need to skip over them. That is, after
    processing index 0, we want to jump to index 3.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Index 3 is a space character. Since it isn’t a vowel, we copy this character
    as is to Luka’s original sentence and then move to index 4\. Index 4 is l, another
    nonvowel, so we copy that too and move to index 5\. Here at index 5 we have a
    vowel; after copying it, we want to jump to index 8.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: What’s the step size here? Sometimes we jump by three, but not always. And sometimes
    we jump by one, but not always. It’s a mix of threes and ones. for loops are not
    designed for this kind of processing.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: With a while loop, we can zip around a string however we please, unencumbered
    by predefined step sizes.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: while Loops Through Indices
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing a while loop that loops through string indices isn’t any different
    from writing any other kind of while loop. We just need to incorporate the string’s
    length. Here’s how we can loop through each character of a string from left to
    right:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''zephyr'''
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '❶ >>> while i < len(s):'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''We have '' + s[i])'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: We have z
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: We have e
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: We have p
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: We have h
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: We have y
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: We have r
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: The variable i allows us to access each character of the string. It begins at
    0 and increases by one each time through the loop.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'I used < in the loop’s Boolean expression ❶ to continue as long as we haven’t
    reached the length of the string. Had I used <= instead of <, we’d have received
    an IndexError:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i <= len(s):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''We have '' + s[i])'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: We have z
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: We have e
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: We have p
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: We have h
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: We have y
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: We have r
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 2, in <module>
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 'IndexError: string index out of range'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: The length of the string is 6\. We get this error because the loop tries to
    access s[6], which is not a valid index in the string.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to loop through the string jumping by three characters at a time instead
    of one? No problem; just increase i by 3 instead of 1:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < len(s):'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''We have '' + s[i])'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 3'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: We have z
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: We have h
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also go from right to left instead of left to right. We have to start
    at len(s) - 1 instead of 0, and we have to decrease i on each iteration rather
    than increase it. We also have to change the loop’s Boolean expression to detect
    when we’re at the beginning of the string rather than the end. Here’s how we go
    from right to left, looping through each character:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = len(s) - 1'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i >= 0:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''We have '' + s[i])'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i - 1'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: We have r
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: We have y
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: We have h
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: We have p
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: We have e
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: We have z
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'A final use case for a while loop on a string: stopping at the first index
    that meets some criterion.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy is to use the Boolean and operator to continue while there are
    more characters to check and we haven’t yet met our criterion. For example, here
    is how we can find the index of the first ''y'' in a string:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < len(s) and s[i] != ''y'':'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(i)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'If there’s no ''y'' anywhere in the string, the loop stops when i equals the
    string length:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''breeze'''
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < len(s) and s[i] != ''y'':'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(i)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: When i refers to 6, the first operand of and is False, so the loop terminates.
    You might wonder why the second operand of and doesn’t cause an error here, since
    index 6 is not a valid index in the string. The reason is that the Boolean operators
    use *short-circuiting evaluation*, which means that they stop evaluating their
    operands if the result of the operator is already known. For and, if the first
    operand is False, then we know that, no matter what the second operand is, and
    will return False; Python therefore doesn’t evaluate the second operand. Similarly,
    for or, if the first operand is True, then or is guaranteed to return True, so
    Python doesn’t evaluate the second operand.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we know how to use a while loop to loop through a string.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: For Secret Sentence, we need to do something different depending on whether
    we’re looking at a vowel or a nonvowel. If we’re looking at a vowel, then we need
    to copy the character and jump ahead by three characters (to skip over the p and
    the second occurrence of this vowel). If we’re looking at a nonvowel, then we
    need to copy the character and move to the next character. So, we always copy
    the current character but then move by three or one based on whether the current
    character is a vowel. We can use an if statement inside the while loop to make
    this decision for each character that we see.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: A solution for Secret Sentence is in [Listing 4-4](ch04.xhtml#ch04ex04).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: sentence = input()
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: ❶ result = ''
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '❷ while i < len(sentence):'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: result = result + sentence[i]
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if sentence[i] in ''aeiou'':'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: i = i + 3
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: i = i + 1
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: print(result)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-4: Solving Secret Sentence*'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: The result variable ❶ is used to build the original sentence, one character
    at a time.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: The while loop’s Boolean expression is the standard one for looping until we
    reach the end of a string ❷. In that loop, we first concatenate the current character
    to the end of the result. Then we check whether the current character is a vowel
    ❸. Recall from “Relational Operators” in [Chapter 2](ch02.xhtml#ch02) that the
    in operator can be used to check whether the first string occurs in the second.
    If the current character is found in the string of vowels, we jump ahead by three
    characters; if not, we move to the next character.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop terminates, we have gone through the entire encoded sentence and
    copied the correct characters into result. The last thing to do is therefore to
    output this variable.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: You’re ready to submit our code to the judge. Grepeapat wopork!
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: break and continue
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, I’ll show you two other loop keywords that Python supports:
    break and continue. It’s my experience that introducing these keywords leads learners
    to overuse them to the detriment of the clarity of their loops, so I’ve decided
    to avoid them elsewhere in the book. Nonetheless, they are occasionally useful,
    and you’re likely to see them in other Python code, so let’s have a brief discussion.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The break keyword immediately terminates a loop, no questions asked.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: Back when we solved Song Playlist, we used a while loop that looped while the
    button was not 4. We could also solve that problem using break; see [Listing 4-5](ch04.xhtml#ch04ex05)
    for the code.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: songs = 'ABCDE'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '❶ while True:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: button = int(input())
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if button == 4:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: ❸ break
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: presses = int(input())
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(presses):'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'if button == 1:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: songs = songs[1:] + songs[0]
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'elif button == 2:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: songs = songs[-1] + songs[:-1]
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 'elif button == 3:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: songs = songs[1] + songs[0] + songs[2:]
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: output = ''
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'for song in songs:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: output = output + song + ' '
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: print(output[:-1])
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-5: Solving Song Playlist using* break'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop’s Boolean expression ❶ looks suspicious: True is always True, so at
    first glance it seems that this loop never terminates. (That’s the downside to
    break. We can’t just look at the Boolean expression to understand what must happen
    for the loop to terminate.) But it can terminate, because of our use of break.
    If button 4 is pressed ❷, then we hit a break ❸, which terminates the loop.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see one more example of using break. In “while Loops Through Indices”
    in this chapter, we wrote code to find the index of the first ''y'' in a string.
    Here’s how that looks using break:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''zephyr'''
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < len(s):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '...     if s[i] == ''y'':'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '...         break'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(i)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, notice that the loop’s Boolean expression is misleading: it suggests
    that the loop always runs until the end of the string, but further scrutiny reveals
    that a break is lurking and can influence termination.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: 'A break terminates only its own loop, not any outer loops. Here’s an example:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < 3:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '...     j = 10'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '...     while j <= 50:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '...         print(j)'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '...         if j == 30:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: ❶ ...             break
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '...         j = j + 10'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the break ❶ cuts the j loop short. But it doesn’t affect the i loop:
    there are three iterations of that loop, exactly as there would be without the
    break ❶.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: continue
  id: totrans-701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The continue keyword ends the current iteration of the loop without running
    any more of its code. Unlike break, it does not end the loop altogether. If the
    loop condition is True, then further iterations of the loop occur.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses continue to print each vowel and its index in a
    string:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''zephyr'''
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < len(s):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '❶ ...     if not s[i] in ''aeiou'':'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '...         i = i + 1'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: ❷ ...         continue
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: ❸ ...     print(s[i], i)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: e 1
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: If the current character is not a vowel ❶, then we don’t want to print it. So,
    we increase i by 1 to take us past this character and then use continue ❷ to end
    the current iteration. If we get below the if statement ❸, then it must mean that
    we’re looking at a vowel (otherwise continue would have prevented us from getting
    here). We therefore output that character and increase i by 1 to take us past
    this character.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'The continue keyword is enticing because it seems to give us a way to get us
    out of an iteration that we don’t want to be in. “This isn’t a vowel. I’m out
    of here!” But an if statement can also be used to obtain the same behavior, and
    the logic is often clearer:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''zephyr'''
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '>>> i = 0'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '>>> while i < len(s):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '...     if s[i] in ''aeiou'':'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '...         print(s[i], i)'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '...     i = i + 1'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: e 1
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: Rather than skip the iteration when the current character is not a vowel, the
    if statement processes it when it *is* a vowel.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unifying feature of the problems in this chapter is that we don’t know in
    advance how many iterations of a loop will be required.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '**Slot Machines** The number of iterations depends on the initial number of
    quarters and the payouts of the slot machines.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '**Song Playlist** The number of iterations depends on how many buttons were
    pressed.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '**Secret Sentence** The number of iterations, and what to do on each iteration,
    depends on where vowels are located in a string.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: When the number of iterations is unknown, we turn to the while loop, which runs
    as long as needed. Using a while loop is more error-prone than code that uses
    a for loop. It’s also more flexible, as we are freed from the for loop constraint
    of systematically looping through a sequence.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll learn about lists, which allow us to store large
    amounts of numeric or string data. And how do you suppose we’ll process all of
    that data? Yes: loops! Practice the following exercises to hone your loop skills.
    You’ll be using them a lot when we solve problems using lists.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You now have three types of loops at your disposal: for loops, range for loops,
    and while loops. Part of the challenge of solving problems using loops is knowing
    which loop to use! For each of the following exercises, experiment with using
    different types of loops to arrive at the solution that you like best.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 1.  DMOJ problem ccc20j2, Epidemiology
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem coci08c1p2, Ptice
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc02j2, AmeriCanadian
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo13r1p1, Take a Number
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo15r1p1, When You Eat Your Smarties
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc19j3, Cold Compress
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slot Machines is originally from the 2000 Canadian Computing Competition, Junior/Senior
    Level. Song Playlist is originally from the 2008 Canadian Computing Competition,
    Junior Level. Secret Sentence is originally from the 2008/2009 Croatian Open Competition
    in Informatics, Contest 3.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
