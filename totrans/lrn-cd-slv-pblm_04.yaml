- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REPEATING CODE: INDEFINITE LOOPS'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `for` loops and range `for` loops that you learned in [Chapter 3](ch03.xhtml#ch03)
    are convenient for looping through a string or range of indices. But what do we
    do when we have no string or when the indices do not follow a fixed pattern? We
    use a `while` loop, the topic of this chapter. `while` loops are more general
    than `for` loops and can handle situations that a `for` loop cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll solve three problems where `for` loops fall short: determining the number
    of times slot machines can be played, organizing a song playlist until the user
    wants to stop, and decoding an encoded message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #8: Slot Machines'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How many times can slot machines be played before we run out of money? This
    is a subtle question that depends not only on our starting money but also on the
    pattern of winnings as we play. We’ll see that we need a `while` loop, not a `for`
    loop, for this situation.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc00s1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Martha goes to a casino and brings *n* quarters. The casino has three slot machines,
    and she plays them in order until she has no quarters left. That is, she plays
    the first slot machine, then the second, then the third, then back to the first,
    then the second, and so on. Each play costs one quarter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The slot machines operate according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The first slot machine pays 30 quarters every 35th time it is played.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second slot machine pays 60 quarters every 100th time it is played.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third slot machine pays 9 quarters every 10th time it is played.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No other plays pay anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the number of times Martha plays before she has no quarters left.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input consists of four lines.
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains an integer *n*, the number of quarters that Martha brings
    to the casino. *n* is between 1 and 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains an integer indicating the number of times that the
    first slot machine has been played since it last paid. These plays occurred prior
    to Martha arriving, and Martha’s plays continue from there. For example, suppose
    that the first slot machine has been played 34 times since it last paid. Then,
    Martha will win 30 quarters the first time she plays it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains an integer indicating the number of times that the second
    slot machine has been played since it last paid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth line contains an integer indicating the number of times that the
    third slot machine has been played since it last paid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Output the following sentence, where x is the number of times Martha plays
    before she has no quarters left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s run through an example, just to make sure that everything in this problem
    is clear. Here’s the test case we’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To carefully trace Martha’s plays, we’ll need to keep track of six pieces of
    information. It’s convenient to use a table to do this, since a row can tell us
    the state after each play. Here are our columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plays** the number of slot machines that Martha has played'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quarters** the number of quarters that Martha has'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next play** the slot machine that Martha would play next'
  prefs: []
  type: TYPE_NORMAL
- en: '**First plays** the number of times that the first machine has been played
    since it last paid'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second plays** the number of times that the second machine has been played
    since it last paid'
  prefs: []
  type: TYPE_NORMAL
- en: '**Third plays** the number of times that the third machine has been played
    since it last paid'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, Martha has played zero slot machines, she has seven quarters, and
    she’ll next play the first slot machine. The first slot machine has been played
    28 times since it last paid, the second has been played 0 times since it last
    paid, and the third has been played 8 times since it last paid. Our state looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 7 | first | 28 | 0 | 8 |'
  prefs: []
  type: TYPE_TB
- en: 'Martha starts by playing the first slot machine. That costs one quarter. Because
    this is the 29th time this machine has been played since it last paid, not the
    35th, the slot machine pays Martha nothing. Martha will play the second slot machine
    next. This is our new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 6 | second | 29 | 0 | 8 |'
  prefs: []
  type: TYPE_TB
- en: 'Playing the second slot machine costs one quarter. Because this is the first
    time this machine has been played since it last paid, not the 100th, the slot
    machine pays Martha nothing. Martha will play the third slot machine next. This
    is our new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5 | third | 29 | 1 | 8 |'
  prefs: []
  type: TYPE_TB
- en: 'Playing the third slot machine costs one quarter. Because this is the 9th time
    this machine has been played since it last paid, not the 10th, the slot machine
    pays Martha nothing. Next, Martha will cycle back to the first slot machine. This
    is our new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4 | first | 29 | 1 | 9 |'
  prefs: []
  type: TYPE_TB
- en: 'Now Martha plays the first slot machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 | second | 30 | 1 | 9 |'
  prefs: []
  type: TYPE_TB
- en: 'Then Martha plays the second slot machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2 | third | 30 | 2 | 9 |'
  prefs: []
  type: TYPE_TB
- en: 'Martha is almost out of quarters! But there’s good news coming, because she’s
    next going to play the third slot machine. It has been played nine times since
    it last paid. The next play is therefore its 10th, which pays Martha nine quarters.
    She had two quarters, pays one to play this machine, and then gets paid nine,
    so she’ll have 2 – 1 + 9 = 10 quarters after this play:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 10 | first | 30 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Notice that the third slot machine has now been played zero times since it last
    paid.
  prefs: []
  type: TYPE_NORMAL
- en: That’s six plays so far. I encourage you to keep tracing. You should see that
    Martha never gets paid again and that after 10 more plays (for a total of 16),
    Martha is broke.
  prefs: []
  type: TYPE_NORMAL
- en: A Limitation of for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch03), we studied `for` loops. Standard `for` loops
    loop through a sequence, such as a string. We certainly have no string in the
    Slot Machines problem.
  prefs: []
  type: TYPE_NORMAL
- en: Range `for` loops loop through a range of integers and can be used to loop a
    specified number of times. But how many times should we loop for Slot Machines?
    Ten? Fifty? Who knows. It depends on the number of plays that Martha can make
    before she’s out of quarters.
  prefs: []
  type: TYPE_NORMAL
- en: We have no string and don’t know how many iterations are required. If all we
    had were `for` loops, we’d be stuck.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the *while loop*, the most general looping structure that Python offers.
    We can write `while` loops that have nothing to do with strings or sequences of
    integers. In return for this added flexibility, we’ll need to be a little more
    careful and take a little more responsibility with writing our loops. Let’s dig
    in!
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write a `while` loop, we use Python’s `while` statement. A `while` loop is
    controlled by a Boolean expression. If the Boolean expression is `True`, then
    Python executes one iteration of the `while` loop. If the expression is still
    `True`, then Python executes another iteration of the `while` loop, and so on,
    until the Boolean expression is `False`. If the Boolean expression is `False`
    at the outset, then the loop does not run at all.
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loops are *indefinite loops*: the number of iterations may not be known
    in advance.'
  prefs: []
  type: TYPE_NORMAL
- en: Using while loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the following example of a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In a `for` loop, the loop variable is created for us; we don’t have to use an
    assignment statement to create the variable prior to the loop. But in a `while`
    loop, we get nothing for free. If we need a variable to loop through values in
    a `while` loop, then we have to create that variable ourselves. We do that here
    by making `num` refer to `0` prior to the loop ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop itself is controlled by the Boolean expression `num < 5` ❷.
    If `num < 5` is `True`, then the code in the loop block will run. Right now, `num`
    refers to `0`, so the Boolean expression is `True`. We therefore run the loop
    block, which outputs `0` and then increases `num` to `1` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: We jump back to the top of the loop and evaluate the `num < 5` Boolean expression
    again. As `num` refers to `1`, the expression is `True`. We therefore run the
    loop block again, which outputs `1` and then increases `num` to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the top of the loop: is `num < 5` still `True`? It is, because `num`
    is only `2`. That kicks off another iteration of the loop, which outputs `2` and
    increases `num` to `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern continues, with two more iterations of the loop: one when `num`
    refers to `3` and one when `num` refers to `4`. When `num` refers to `5`, the
    `num < 5` Boolean expression is finally `False`, which terminates the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important that we remember to increase `num` ❸. A `for` loop automatically
    steps our loop variable through the appropriate values. But, again, we get nothing
    for free in a `while` loop and must update variables ourselves to bring us closer
    and closer to loop termination. If we forget to increase `num`, this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code on your computer, your screen will fill up with zeros,
    and you’ll have to terminate your program. You can do that by pressing CTRL-C
    or by closing the Python window.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that `num < 5` stays `True` forever; nothing in the loop can
    ever make it `False`. This situation, where a loop never terminates, is called
    an *infinite loop*. It’s surprisingly easy to inadvertently produce infinite `while`
    loops. If you see the same values repeating or your program appears to be doing
    nothing at all, it’s likely that you’re stuck in an infinite loop. Carefully check
    the `while` loop’s Boolean expression and that the loop block is making progress
    toward termination.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do whatever we like with the `num` variable. Here’s a `while` loop counting
    up by three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s a `while` loop counting down from `4` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I’ve used `>=` here rather than `>` ❶. This way, the while loop
    runs when `num` refers to `0`, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: B.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: C.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '-100'
  prefs: []
  type: TYPE_NORMAL
- en: D.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '-100'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. A `while` loop’s Boolean expression is checked only at the start
    of each iteration. Even if it becomes `False` at some point during the iteration,
    the remainder of the iteration completes.'
  prefs: []
  type: TYPE_NORMAL
- en: As `3` is greater than `0`, an iteration of the loop runs. The `if` statement
    block is skipped (because its Boolean expression is `False`), so this iteration
    outputs `3` and sets `n` to `4`. As `4` is greater than `0`, we have another iteration
    of the loop, this one outputting `4` and setting `n` to `5`. As `5` is greater
    than `0`, we have yet another iteration of the loop. This time, the `if` statement
    block runs, which sets `n` to `-100`. Next, `-100` is output, and `n` is set to
    `-99`. And here we stop, because `n > 0` is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A.
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: B.
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: C.
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: D.
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: E.
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. Many `while` loops do something and then update the loop variable,
    but not this one. This one first decrements the loop variable `x` and *then* outputs
    it. As `6` is greater than `4`, an iteration of the loop runs, which assigns `5`
    to `x` and then outputs `5`. Next, `5` is greater than `4`, so we have another
    iteration, this one assigning `4` to `x` and outputting `4`. And that’s it: `4`
    is not greater than `4`, so the loop terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Loops in Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can nest loops inside of `while` loops, much as we can nest loops inside
    of `for` loops. In “Nesting” in [Chapter 3](ch03.xhtml#ch03), I noted that the
    inner `for` loop completes all of its iterations before the next iteration of
    the outer loop begins. The same holds for `while` loops. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each value of `i` is involved in three lines of output, one for each iteration
    of the inner `j` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: How many lines are output by the following nested loop?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A. 2
  prefs: []
  type: TYPE_NORMAL
- en: B. 3
  prefs: []
  type: TYPE_NORMAL
- en: C. 6
  prefs: []
  type: TYPE_NORMAL
- en: D. 8
  prefs: []
  type: TYPE_NORMAL
- en: E. 9
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The outer loop’s Boolean expression, `x < 3`, is `True`, so we perform
    an iteration of the outer loop. That leads to two iterations of the inner loop:
    one when `y` is `1` and one when `y` is `2`, each of which prints a line of output.
    So that’s two lines of output so far.'
  prefs: []
  type: TYPE_NORMAL
- en: But nothing in the code resets `y`’s value! Therefore, `y < 3` will never be
    `True` again, and there won’t be any further iterations of the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to reset a loop variable is a common mistake when dealing with nested
    `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Boolean Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To solve Slot Machines, we want to loop while Martha has at least one quarter.
    That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That simple Boolean expression will suffice for this problem. But just like
    for `if` statements, the Boolean expression following the word `while` can include
    relational or Boolean operators. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop is controlled by the Boolean expression `x <= 10 and y <= 13`.
    As with any `and` operator, both of its operands must be `True` for the whole
    expression to be `True`. When `x` refers to `8` and `y` refers to `14`, the loop
    terminates because the `y <= 13` operand is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To solve Slot Machines, we know that we need a `while` loop, not a `for` loop,
    because we can’t predict the number of iterations in advance. Each iteration of
    the loop will play the current slot machine. When the loop terminates, Martha
    will have no quarters left, and we will output the number of times she played.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we need to do on each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrease Martha’s quarters by one (since it costs one quarter to play a slot
    machine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Martha is currently on the first slot machine, play that machine. This involves
    increasing the number of times this machine has been played. If this is the 35th
    play, then pay Martha and reset the number of times that this machine has been
    played to 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Martha is currently on the second slot machine, play that machine (similar
    to how we played the first machine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Martha is currently on the third slot machine, play that machine (similar
    to how we played the first machine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the number of Martha’s plays (since we just played a machine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move to the next machine. If Martha just played the first machine, we want to
    move to the second; if she just played the second, we want to move to the third;
    and if she just played the third, we want to cycle back to the first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our programs are getting longer now, so outlining the plan as I just did is
    a useful technique for keeping the complexity under control and guiding us toward
    correct code. We can use the outline to make sure we’re following the plan and
    not forgetting anything.
  prefs: []
  type: TYPE_NORMAL
- en: Our code is in [Listing 4-1](ch04.xhtml#ch04ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Solving Slot Machines*'
  prefs: []
  type: TYPE_NORMAL
- en: The `quarters` variable tracks the number of quarters that Martha has. The `first`,
    `second`, and `third` variables track the number of plays since the last payment
    for the first, second, and third slot machines, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `machine` variable tracks the slot machine that Martha will play next. The
    first slot machine is referred to by the number `0`, the second by the number
    `1`, and the third by `2`. Making `machine` refer to `0` therefore indicates that
    the first slot machine will be played next ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have referred to the slot machines using `1`, `2`, and `3` instead
    of `0`, `1`, and `2`. Or we could have used strings: `''first''`, `''second''`,
    and `''third''`. But numbering items starting from zero is customary, so that’s
    what I’ve done here.'
  prefs: []
  type: TYPE_NORMAL
- en: The final variable in this program is `plays`, which tracks the number of slot
    machines that Martha has played. We’ll output this once Martha is out of quarters.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the program consists of a `while` loop that loops as long as Martha
    has quarters ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration of the loop plays one slot machine. As such, the first thing
    we do is decrease Martha’s quarters by one ❸. Next, we play the current slot machine.
  prefs: []
  type: TYPE_NORMAL
- en: Are we on slot machine 0? Slot machine 1? Slot machine 2? We need an `if` statement
    to answer that.
  prefs: []
  type: TYPE_NORMAL
- en: We first check whether we’re on slot machine 0 ❹. If we are, then we increase
    the number of plays since this slot machine paid by one. To determine whether
    Martha gets paid, we then check whether this machine has been played exactly 35
    times since it last paid ❺. If it has, then we reset this machine’s plays to `0`
    and increase Martha’s quarters by 30.
  prefs: []
  type: TYPE_NORMAL
- en: There are several levels of nesting here, so take some time to convince yourself
    that the logic of the code is correct. In particular, note that every time we
    play the first machine, we increase its number of plays by one. But we only pay
    Martha after every 35 plays—that’s why we have the inner `if` statement ❺!
  prefs: []
  type: TYPE_NORMAL
- en: We handle the second and third slot machines just as we handled the first. The
    only difference is that each slot machine pays Martha after its own number of
    plays and pays Martha its own amount of quarters.
  prefs: []
  type: TYPE_NORMAL
- en: Having played a slot machine, we increase Martha’s number of plays by one ❻.
    Now all that’s left is to move to the next machine so that we’ll be at the right
    machine if there’s a next iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: To move to the next machine, we increase `machine` by one ❼. If we were on machine
    `0`, this would move us to machine `1`. If we were on machine `1`, this would
    move us to machine `2`. If we were on machine `2`, this would move us to machine
    `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '*. . .* Machine 3? There’s no machine 3! If we just played machine 2, then
    we want to start over at machine 0\. To do that, we add a check: if we just moved
    to machine `3` ❽, then we know that we just played machine `2`, so we reset `machine`
    to machine `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: When the loop terminates, we know that Martha has no quarters left. As a last
    step, we output the required sentence, including Martha’s number of plays.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code has a lot going on: stopping when Martha has no quarters left, keeping
    track of the current machine, paying Martha when appropriate, and counting Martha’s
    plays. Feel free to submit this code now, but also to consider whether you’d have
    written parts of it in a different way. What happens if you increase `plays` by
    `1` at the top of the loop instead of the bottom? Does it matter whether you decrease
    `quarters` by `1` at the top of the loop or the bottom? Would you have used new
    variables to keep track of the number of times that Martha played each slot machine,
    rather than modifying `first`, `second`, and `third`? I strongly encourage you
    to experiment with variations of what we’ve done here. If you make changes and
    the code no longer passes the tests, great! Now you have a new learning opportunity
    to fix the code and learn why your changes led to undesired behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: The next two sections offer further refinement of the code. We’ll use the `%`
    operator to reduce the number of variables that we need and learn about f-strings
    to streamline how we build strings.
  prefs: []
  type: TYPE_NORMAL
- en: The Mod Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01), I
    introduced the mod (`%`) operator for calculating the remainder of an integer
    division. For example, 16 divided by 5 has a remainder of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And 15 divided by 5 has a remainder of 0 (because 5 divides 15 exactly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second operand dictates the range of values that `%` can possibly return.
    The possible return values are 0 up to but not including the second operand. For
    example, if the second operand is `3`, then the only values that can be returned
    by `%` are 0, 1, and 2\. In addition, as we increase the first operand, we cycle
    through all possible return values. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the pattern: 0, 1, 2, 0, 1, 2, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is useful for counting up to a specified number and then cycling
    back to 0\. It’s exactly the behavior that we need when playing the slot machines:
    we play slot machine 0, then 1, then 2, then 0, then 1, then 2, then 0, then 1,
    and so on. (This is another reason why I used `0`, `1`, and `2`, rather than other
    values, to refer to the slot machines.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that variable `plays` refers to the number of times that Martha has
    played. To determine the next machine to play (`0`, `1`, or `2`), we can use the
    `%` operator. For example, suppose that Martha has played one slot machine so
    far, and we want to know which she will play next. She’ll play slot machine `1`
    next, and the `%` operator tells us that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If Martha has played six times so far, then she’s played slot machines 0, 1,
    2, 0, 1, 2\. The next slot machine she’ll play is machine 0\. And, as she’s played
    all three machines twice, with no other plays beyond that, the `%` operator gives
    us `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final example, suppose that Martha has played 11 times so far. She’s done
    three complete cycles: 0, 1, 2, 0, 1, 2, 0, 1, 2\. That’s nine of the plays. The
    remaining two plays put Martha on slot machine 2 for her next play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That is, we can figure out the slot machine to play without explicitly maintaining
    a `machine` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `%` to simplify the logic of determining whether the next play
    on the current slot machine pays Martha. Consider the first slot machine. In [Listing
    4-1](ch04.xhtml#ch04ex01), we counted the number of plays since the slot machine
    paid. If that number is 35, then we pay Martha and reset the count to 0\. But
    there’s no need to reset the count if we’re using the `%` operator. We can just
    check whether the slot machine has been played a multiple of 35 times and pay
    Martha if so. To test whether a number is a multiple of 35, we can use the `%`
    operator. A number is a multiple of 35 if dividing it by 35 yields no remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can just check `first % 35 == 0` to determine whether to pay Martha.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve updated [Listing 4-1](ch04.xhtml#ch04ex01) to use the `%` operator. The
    new code is in [Listing 4-2](ch04.xhtml#ch04ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: Solving Slot Machines using* %'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve used `%` in the two ways described in this section: to determine the current
    machine based on the number of plays ❶ and to determine whether Martha gets paid
    on a play (for example, at ❷).'
  prefs: []
  type: TYPE_NORMAL
- en: Associating `%` with returning the remainder of a division belies its flexibility.
    Whenever you need to count in a cycle (0, 1, 2, 0, 1, 2), consider whether you
    can use `%` to simplify your code.
  prefs: []
  type: TYPE_NORMAL
- en: F-Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final thing we do in our solution to Slot Machines is output the required
    sentence, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to remember to end the first string so that we can output the number
    of plays and then start a new string for the second half of the sentence. In addition,
    we’re using multiple arguments to `print` to avoid having to convert `plays` to
    a string. If we were storing the resulting string rather than printing it, we’d
    need the `str` conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Gluing strings and integers together is fine for a simple sentence like this,
    but it doesn’t scale. Here’s how it looks when we try to embed three integers
    instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We don’t want to have to keep track of all of those quotes, pluses, and spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most flexible way to build a string consisting of strings and numbers is
    to use an *f-string*. Here’s how the previous example looks with an f-string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `f` before the opening quote of the string. The `f` stands for format,
    because f-strings allow you to format the contents of a string. Inside of an f-string,
    we can place expressions inside curly brackets. As the string is being built,
    each expression is replaced by its value and inserted into the string. The result
    is just a regular old string—there’s no new type here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The expressions in the curly brackets can be more complex than bare variable
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use f-strings in the final line of Slot Machines. Here’s how that would
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Even in this simplest of string-formatting contexts, I think f-strings add clarity.
    Keep them in the back of your mind for whenever you catch yourself building a
    string from smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'One warning about f-strings: they were added in Python 3.6, which at the time
    of writing is still a reasonably recent version of Python. In older versions of
    Python, f-strings cause syntax errors.'
  prefs: []
  type: TYPE_NORMAL
- en: If you use f-strings, be sure to check that the judge you’re submitting to is
    using Python 3.6 or newer to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #9: Song Playlist'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we don’t know in advance how much input will be provided. We’ll see
    in this problem that a `while` loop is what we need in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc08j2`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have five favorite songs named A, B, C, D, and E. We’ve created a playlist
    of these songs and are using an app to manage the playlist. The songs start off
    in the order A, B, C, D, E. The app has four buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Button 1: Moves the first song of the playlist to the end of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to B,
    C, D, E, A.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Button 2: Moves the last song of the playlist to the beginning of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to E,
    A, B, C, D.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Button 3: Swaps the first two songs of the playlist. For example, if the playlist
    is currently A, B, C, D, E, then it changes to be B, A, C, D, E.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Button 4: Plays the playlist!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re provided a user’s button presses. When the user presses button 4, output
    the order of songs in the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of pairs of lines, where the first line of a pair gives
    the number of a button (`1`, `2`, `3`, or `4`), and the second gives the number
    of times that the user pressed this button (between 1 and 10). That is, the first
    line is the number of a button, the second line is the number of times it is pressed,
    the third line is the number of a button, the fourth line is the number of times
    it is pressed, and so on. The input ends with these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: indicating that the user pressed button `4` once.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the order of songs in the playlist after all button presses. The output
    must be on one line, with a space separating each pair of songs.
  prefs: []
  type: TYPE_NORMAL
- en: String Slicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The high-level plan of our solution to Song Playlist will be a `while` loop
    that keeps going as long as we haven’t found the press of button `4`. On each
    iteration, we’ll read two lines of input and process them. That leads to this
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Prior to the `while` loop, we create the variable `button` and make it refer
    to the number `0` ❶. Without this, the `button` variable would not exist, and
    we’d get a `NameError` in the `while` loop’s Boolean expression. Any number besides
    `4` would work here to trigger the first iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Within this `while` loop, we’ll use a `for` loop to process the button presses.
    For each press, we’ll use an `if` statement to check which button was pressed.
    We’ll need four indented blocks of statements in the `if` statement, one for each
    of the four buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about how to handle each of the buttons. Button `1` moves the first
    song of the playlist to the end of the playlist. Because we have a small, known
    number of songs, we can get away with using string indexing to concatenate each
    character. Remember that the first character of a string is at index 0, not 1\.
    We can put that character at the end of the string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is rather unwieldy and is specific to having exactly five songs. We can
    use string slicing to write more general and less error-prone code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Slicing* is a Python feature that lets us refer to a substring of a string.
    (In fact, it works on any sequence, as we’ll see later in the book.) It takes
    two indices: the index where we want to start, and the index one to the right
    of where we want to end. If we use indices 4 and 8, for example, then we get the
    characters at indices 4, 5, 6, and 7\. Slicing uses square brackets, with a colon
    between the two indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The slicing doesn’t change what `s` refers to. We can make `s` refer to the
    slice by using an assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It’s easy to make an off-by-one error here and think that `s[4:8]` includes
    the character at index 8\. But it doesn’t, just like `range(4, 8)` doesn’t include
    the `8`. So while this behavior may be a little counterintuitive, it’s applied
    consistently in both `range` and slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must always include the colon when performing string slicing, but the start
    and end indices are optional. If we leave off the start index, Python starts slicing
    at index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we leave off the end index, Python slices until the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And leaving out both indices? That gives us a slice consisting of the entire
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use negative indices in a slice. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The start index refers to the fourth character from the right, which is `'h'`,
    and the end index is omitted. We therefore get a slice from the `'h'` to the end
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike indexing, slicing never produces an index error. If we use indices that
    are outside of the string, Python slices to the appropriate end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use string slicing to implement the behaviors of buttons `1`, `2`, and
    `3`. Here’s what the code looks like for button `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The slice gives us the entire string except for the character at index 0\. (There’s
    nothing specific to a string of length 5 here; this code would work on a nonempty
    string of any length.) Appending that missing character results in the first song
    moving to the end of the playlist. The slicing for the other buttons is similar;
    you’ll see that code next.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A. `st V`
  prefs: []
  type: TYPE_NORMAL
- en: B. `ost V`
  prefs: []
  type: TYPE_NORMAL
- en: C. `iking`
  prefs: []
  type: TYPE_NORMAL
- en: D. `st Vi`
  prefs: []
  type: TYPE_NORMAL
- en: E. `Viking`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The character at index `2` is the `''s''` in `''Lost''`. The character
    at index `-6` is the first `''i''` in `''Vikings''`. Since we go from index `2`
    up to but not including index `-6`, we get the slice `''st V''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Which password gets us out of the following loop?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A. `xyz`
  prefs: []
  type: TYPE_NORMAL
- en: B. `xyabc`
  prefs: []
  type: TYPE_NORMAL
- en: C. `abcxy`
  prefs: []
  type: TYPE_NORMAL
- en: D. More than one of the above passwords get us out of the loop
  prefs: []
  type: TYPE_NORMAL
- en: E. None; the loop never executes and no passwords are obtained
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The `while` loop terminates when `valid` is `True` (because then
    `not valid` is `False`). The only one of the given passwords whose length is 5
    and whose first two characters are `''xy''` is `xyabc`. This is therefore the
    only given password that sets `valid` to `True` and ends the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have some practice using `while` loops to loop as long as there
    are more buttons to handle, and using slicing for string manipulation, we’re ready
    to solve Song Playlist. See [Listing 4-3](ch04.xhtml#ch04ex03) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: Solving Song Playlist*'
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop continues as long as button `4` hasn’t been pressed ❶. On each
    iteration of the `while` loop, we read the button number and then read the number
    of times that this button was pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, nested in the outer `while` loop, we need to loop once per button press.
    Keep all of the loop types in mind as you decide which to use. Here, a range `for`
    loop is the best choice ❷, since it’s the easiest way to loop exactly the number
    of times we specify.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior inside the range `for` loop depends on which button is pressed.
    We therefore use an `if` statement to check the button number and modify the playlist
    accordingly. If button `1` is pressed, we use slicing to move the first song to
    the end of the playlist ❸. If button `2` is pressed, we use slicing to move the
    last song to the beginning of the playlist ❹. To do that, we start with the character
    at the right end of the string and then use slicing to append all other characters.
    For button `3`, we need to modify the playlist so that the first two songs swap
    positions. We build a new string with the character at index `1`, then the character
    at index `0`, and then all of the characters starting at index `2` ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Once we escape the `while` loop, we need to output the songs, with a space between
    each pair of songs. We can’t just output `songs`, because that doesn’t have spaces.
    Instead, we build an output string that has the appropriate spaces. To do that,
    we start with the empty string ❻ and then use a `for` loop to concatenate each
    song and a space. One small annoyance is that this adds a space to the end of
    the string, after the last song, and we don’t want that. We therefore use slicing
    to remove that final space character ❼.
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to submit to the judge.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 3 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #10: Secret Sentence'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if we have a string and even if we know how much input will be provided,
    a `while` loop may still be the required type of loop. This problem demonstrates
    why this can be the case.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `coci08c3p2`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Luka is writing a secret sentence in class. He doesn’t want the teacher to be
    able to read it, so instead of writing down the original sentence, he writes down
    an encoded version. After each vowel in the sentence (*a*, *e*, *i*, *o*, or *u*),
    he adds the letter *p* and that vowel again. For example, rather than write down
    the sentence *i like you*, he would write *ipi lipikepe yopoupu*.
  prefs: []
  type: TYPE_NORMAL
- en: The teacher acquires Luka’s encoded sentence. Recover Luka’s original sentence
    for the teacher.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input is one line of text, Luka’s encoded sentence. It consists of lowercase
    letters and spaces. There is exactly one space between each pair of words. The
    maximum length of the line is 100 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output Luka’s original sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Another Limitation of for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch03), we learned how `for` loops can be used to process
    strings. A `for` loop plods through the string, from beginning to end, one character
    at a time. In many cases, that’s precisely what we want. In Three Cups, for example,
    we needed to look at each swap from left to right, so we used a `for` loop over
    the string of swaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other cases, that’s too restrictive, and a range `for` loop may be more
    appropriate. A range `for` loop gives us access to indices rather than characters.
    It also allows us to skip through a sequence with whatever step size we choose.
    For example, we can use a range `for` loop to visit every third character of a
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use a range `for` loop to process a string from right to left instead
    of left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: All of this assumes that we want to step by a fixed amount on each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: What if sometimes we want to move one character to the right and other times
    we want to move three characters to the right? That’s not at all farfetched. In
    fact, if we could do that, then we’d be well on our way to solving Secret Sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see why, consider this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Imagine that we’re reconstructing Luka’s original sentence by copying characters
    to it. The first character in the encoded sentence is the vowel `i`. This is the
    first character of Luka’s original sentence, too. Based on how Luka encodes sentences,
    we know that the next two characters will be `p` and `i`. We don’t want to include
    those in Luka’s original sentence, so we need to skip over them. That is, after
    processing index 0, we want to jump to index 3.
  prefs: []
  type: TYPE_NORMAL
- en: Index 3 is a space character. Since it isn’t a vowel, we copy this character
    as is to Luka’s original sentence and then move to index 4\. Index 4 is `l`, another
    nonvowel, so we copy that too and move to index 5\. Here at index 5 we have a
    vowel; after copying it, we want to jump to index 8.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the step size here? Sometimes we jump by three, but not always. And sometimes
    we jump by one, but not always. It’s a mix of threes and ones. `for` loops are
    not designed for this kind of processing.
  prefs: []
  type: TYPE_NORMAL
- en: With a `while` loop, we can zip around a string however we please, unencumbered
    by predefined step sizes.
  prefs: []
  type: TYPE_NORMAL
- en: while Loops Through Indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing a `while` loop that loops through string indices isn’t any different
    from writing any other kind of `while` loop. We just need to incorporate the string’s
    length. Here’s how we can loop through each character of a string from left to
    right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The variable `i` allows us to access each character of the string. It begins
    at `0` and increases by one each time through the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used `<` in the loop’s Boolean expression ❶ to continue as long as we haven’t
    reached the length of the string. Had I used `<=` instead of `<`, we’d have received
    an `IndexError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The length of the string is 6\. We get this error because the loop tries to
    access `s[6]`, which is not a valid index in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to loop through the string jumping by three characters at a time instead
    of one? No problem; just increase `i` by `3` instead of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also go from right to left instead of left to right. We have to start
    at `len(s) - 1` instead of `0`, and we have to decrease `i` on each iteration
    rather than increase it. We also have to change the loop’s Boolean expression
    to detect when we’re at the beginning of the string rather than the end. Here’s
    how we go from right to left, looping through each character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A final use case for a `while` loop on a string: stopping at the first index
    that meets some criterion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy is to use the Boolean `and` operator to continue while there are
    more characters to check and we haven’t yet met our criterion. For example, here
    is how we can find the index of the first `''y''` in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If there’s no `''y''` anywhere in the string, the loop stops when `i` equals
    the string length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When `i` refers to `6`, the first operand of `and` is `False`, so the loop terminates.
    You might wonder why the second operand of `and` doesn’t cause an error here,
    since index `6` is not a valid index in the string. The reason is that the Boolean
    operators use *short-circuiting evaluation*, which means that they stop evaluating
    their operands if the result of the operator is already known. For `and`, if the
    first operand is `False`, then we know that, no matter what the second operand
    is, `and` will return `False`; Python therefore doesn’t evaluate the second operand.
    Similarly, for `or`, if the first operand is `True`, then `or` is guaranteed to
    return `True`, so Python doesn’t evaluate the second operand.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we know how to use a `while` loop to loop through a string.
  prefs: []
  type: TYPE_NORMAL
- en: For Secret Sentence, we need to do something different depending on whether
    we’re looking at a vowel or a nonvowel. If we’re looking at a vowel, then we need
    to copy the character and jump ahead by three characters (to skip over the `p`
    and the second occurrence of this vowel). If we’re looking at a nonvowel, then
    we need to copy the character and move to the next character. So, we always copy
    the current character but then move by three or one based on whether the current
    character is a vowel. We can use an `if` statement inside the `while` loop to
    make this decision for each character that we see.
  prefs: []
  type: TYPE_NORMAL
- en: A solution for Secret Sentence is in [Listing 4-4](ch04.xhtml#ch04ex04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: Solving Secret Sentence*'
  prefs: []
  type: TYPE_NORMAL
- en: The `result` variable ❶ is used to build the original sentence, one character
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop’s Boolean expression is the standard one for looping until
    we reach the end of a string ❷. In that loop, we first concatenate the current
    character to the end of the result. Then we check whether the current character
    is a vowel ❸. Recall from “Relational Operators” in [Chapter 2](ch02.xhtml#ch02)
    that the `in` operator can be used to check whether the first string occurs in
    the second. If the current character is found in the string of vowels, we jump
    ahead by three characters; if not, we move to the next character.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop terminates, we have gone through the entire encoded sentence and
    copied the correct characters into `result`. The last thing to do is therefore
    to output this variable.
  prefs: []
  type: TYPE_NORMAL
- en: You’re ready to submit our code to the judge. Grepeapat wopork!
  prefs: []
  type: TYPE_NORMAL
- en: break and continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, I’ll show you two other loop keywords that Python supports:
    `break` and `continue`. It’s my experience that introducing these keywords leads
    learners to overuse them to the detriment of the clarity of their loops, so I’ve
    decided to avoid them elsewhere in the book. Nonetheless, they are occasionally
    useful, and you’re likely to see them in other Python code, so let’s have a brief
    discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `break` keyword immediately terminates a loop, no questions asked.
  prefs: []
  type: TYPE_NORMAL
- en: Back when we solved Song Playlist, we used a `while` loop that looped while
    the button was not `4`. We could also solve that problem using `break`; see [Listing
    4-5](ch04.xhtml#ch04ex05) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: Solving Song Playlist using* break'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop’s Boolean expression ❶ looks suspicious: `True` is always `True`,
    so at first glance it seems that this loop never terminates. (That’s the downside
    to `break`. We can’t just look at the Boolean expression to understand what must
    happen for the loop to terminate.) But it can terminate, because of our use of
    `break`. If button `4` is pressed ❷, then we hit a `break` ❸, which terminates
    the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see one more example of using `break`. In “while Loops Through Indices”
    in this chapter, we wrote code to find the index of the first `''y''` in a string.
    Here’s how that looks using `break`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, notice that the loop’s Boolean expression is misleading: it suggests
    that the loop always runs until the end of the string, but further scrutiny reveals
    that a `break` is lurking and can influence termination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `break` terminates only its own loop, not any outer loops. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the `break` ❶ cuts the `j` loop short. But it doesn’t affect the
    `i` loop: there are three iterations of that loop, exactly as there would be without
    the `break` ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `continue` keyword ends the current iteration of the loop without running
    any more of its code. Unlike `break`, it does not end the loop altogether. If
    the loop condition is `True`, then further iterations of the loop occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses `continue` to print each vowel and its index in
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the current character is not a vowel ❶, then we don’t want to print it. So,
    we increase `i` by `1` to take us past this character and then use `continue`
    ❷ to end the current iteration. If we get below the `if` statement ❸, then it
    must mean that we’re looking at a vowel (otherwise `continue` would have prevented
    us from getting here). We therefore output that character and increase `i` by
    `1` to take us past this character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `continue` keyword is enticing because it seems to give us a way to get
    us out of an iteration that we don’t want to be in. “This isn’t a vowel. I’m out
    of here!” But an `if` statement can also be used to obtain the same behavior,
    and the logic is often clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Rather than skip the iteration when the current character is not a vowel, the
    `if` statement processes it when it *is* a vowel.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unifying feature of the problems in this chapter is that we don’t know in
    advance how many iterations of a loop will be required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slot Machines** The number of iterations depends on the initial number of
    quarters and the payouts of the slot machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Song Playlist** The number of iterations depends on how many buttons were
    pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secret Sentence** The number of iterations, and what to do on each iteration,
    depends on where vowels are located in a string.'
  prefs: []
  type: TYPE_NORMAL
- en: When the number of iterations is unknown, we turn to the `while` loop, which
    runs as long as needed. Using a `while` loop is more error-prone than code that
    uses a `for` loop. It’s also more flexible, as we are freed from the `for` loop
    constraint of systematically looping through a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll learn about lists, which allow us to store large
    amounts of numeric or string data. And how do you suppose we’ll process all of
    that data? Yes: loops! Practice the following exercises to hone your loop skills.
    You’ll be using them a lot when we solve problems using lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You now have three types of loops at your disposal: `for` loops, range `for`
    loops, and `while` loops. Part of the challenge of solving problems using loops
    is knowing which loop to use! For each of the following exercises, experiment
    with using different types of loops to arrive at the solution that you like best.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  DMOJ problem `ccc20j2`, Epidemiology
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem `coci08c1p2`, Ptice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc02j2`, AmeriCanadian
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ecoo13r1p1`, Take a Number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ecoo15r1p1`, When You Eat Your Smarties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc19j3`, Cold Compress
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slot Machines is originally from the 2000 Canadian Computing Competition, Junior/Senior
    Level. Song Playlist is originally from the 2008 Canadian Computing Competition,
    Junior Level. Secret Sentence is originally from the 2008/2009 Croatian Open Competition
    in Informatics, Contest 3.
  prefs: []
  type: TYPE_NORMAL
