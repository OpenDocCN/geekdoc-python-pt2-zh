- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: 'REPEATING CODE: INDEFINITE LOOPS'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码：无限循环
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: The `for` loops and range `for` loops that you learned in [Chapter 3](ch03.xhtml#ch03)
    are convenient for looping through a string or range of indices. But what do we
    do when we have no string or when the indices do not follow a fixed pattern? We
    use a `while` loop, the topic of this chapter. `while` loops are more general
    than `for` loops and can handle situations that a `for` loop cannot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml#ch03)中你学到的`for`循环和范围`for`循环对于循环遍历字符串或索引范围非常方便。但如果我们没有字符串，或者索引不遵循固定的模式，该怎么办？我们使用`while`循环，这是本章的主题。`while`循环比`for`循环更通用，能够处理`for`循环无法处理的情况。
- en: 'We’ll solve three problems where `for` loops fall short: determining the number
    of times slot machines can be played, organizing a song playlist until the user
    wants to stop, and decoding an encoded message.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决三个`for`循环不适用的问题：确定老虎机可以玩多少次，组织一个歌曲播放列表直到用户想停止，以及解码一个编码消息。
- en: 'Problem #8: Slot Machines'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #8：老虎机'
- en: How many times can slot machines be played before we run out of money? This
    is a subtle question that depends not only on our starting money but also on the
    pattern of winnings as we play. We’ll see that we need a `while` loop, not a `for`
    loop, for this situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎机最多能玩多少次，直到我们没有钱了？这是一个微妙的问题，它不仅取决于我们最初的资金，还取决于我们玩游戏时的中奖模式。我们会看到，在这种情况下，我们需要使用`while`循环，而不是`for`循环。
- en: This is DMOJ problem `ccc00s1`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ题目`ccc00s1`。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Martha goes to a casino and brings *n* quarters. The casino has three slot machines,
    and she plays them in order until she has no quarters left. That is, she plays
    the first slot machine, then the second, then the third, then back to the first,
    then the second, and so on. Each play costs one quarter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎去赌场并带了*n*个硬币。赌场有三台老虎机，她按顺序玩它们，直到她没有硬币为止。也就是说，她先玩第一台老虎机，然后是第二台，再是第三台，然后回到第一台，接着是第二台，依此类推。每次游戏消耗一个硬币。
- en: 'The slot machines operate according to the following rules:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎机的规则如下：
- en: The first slot machine pays 30 quarters every 35th time it is played.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一台老虎机每玩第35次就会支付30个币。
- en: The second slot machine pays 60 quarters every 100th time it is played.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二台老虎机每玩第100次就会支付60个币。
- en: The third slot machine pays 9 quarters every 10th time it is played.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三台老虎机每玩第10次就会支付9个币。
- en: No other plays pay anything.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有其他的游戏会支付任何奖金。
- en: Determine the number of times Martha plays before she has no quarters left.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确定玛莎在没有硬币之前玩了多少次。
- en: Input
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of four lines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由四行组成。
- en: The first line contains an integer *n*, the number of quarters that Martha brings
    to the casino. *n* is between 1 and 1,000.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含一个整数*n*，表示玛莎带到赌场的硬币数量。*n*在1和1000之间。
- en: The second line contains an integer indicating the number of times that the
    first slot machine has been played since it last paid. These plays occurred prior
    to Martha arriving, and Martha’s plays continue from there. For example, suppose
    that the first slot machine has been played 34 times since it last paid. Then,
    Martha will win 30 quarters the first time she plays it.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含一个整数，表示第一台老虎机自上次支付以来已经被玩了多少次。这些游戏发生在玛莎到达之前，玛莎的游戏从那里开始。例如，假设第一台老虎机自上次支付以来已经被玩了34次。那么玛莎第一次玩时将获得30个币。
- en: The third line contains an integer indicating the number of times that the second
    slot machine has been played since it last paid.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行包含一个整数，表示第二台老虎机自上次支付以来已经被玩了多少次。
- en: The fourth line contains an integer indicating the number of times that the
    third slot machine has been played since it last paid.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行包含一个整数，表示自上次支付以来第三台老虎机已经被玩了多少次。
- en: Output
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'Output the following sentence, where x is the number of times Martha plays
    before she has no quarters left:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以下句子，其中x是玛莎在没有硬币之前玩了多少次：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Exploring a Test Case
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索测试用例
- en: 'Let’s run through an example, just to make sure that everything in this problem
    is clear. Here’s the test case we’ll use:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来确保这个问题中的所有内容都清楚。以下是我们将使用的测试用例：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To carefully trace Martha’s plays, we’ll need to keep track of six pieces of
    information. It’s convenient to use a table to do this, since a row can tell us
    the state after each play. Here are our columns:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仔细追踪玛莎的游戏，我们需要记录六个信息。使用表格来做这件事非常方便，因为每一行都可以告诉我们每次游戏后的状态。下面是我们的列：
- en: '**Plays** the number of slot machines that Martha has played'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏次数** 是指玛莎已经玩过多少台老虎机'
- en: '**Quarters** the number of quarters that Martha has'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬币数量** 是指玛莎拥有的硬币数'
- en: '**Next play** the slot machine that Martha would play next'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一次游戏** 是玛莎将要玩的老虎机'
- en: '**First plays** the number of times that the first machine has been played
    since it last paid'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一次游戏** 是指自上次支付以来，第一台老虎机被玩了多少次'
- en: '**Second plays** the number of times that the second machine has been played
    since it last paid'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二次游戏** 是指自上次支付以来，第二台老虎机被玩了多少次'
- en: '**Third plays** the number of times that the third machine has been played
    since it last paid'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三次游戏** 是指自上次支付以来，第三台老虎机被玩了多少次'
- en: 'To start, Martha has played zero slot machines, she has seven quarters, and
    she’ll next play the first slot machine. The first slot machine has been played
    28 times since it last paid, the second has been played 0 times since it last
    paid, and the third has been played 8 times since it last paid. Our state looks
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，玛莎没有玩过任何老虎机，她有七枚硬币，接下来她将玩第一台老虎机。第一台老虎机自上次支付以来已经被玩了28次，第二台已经被玩了0次，第三台已经被玩了8次。我们的状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 7 | first | 28 | 0 | 8 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 7 | first | 28 | 0 | 8 |'
- en: 'Martha starts by playing the first slot machine. That costs one quarter. Because
    this is the 29th time this machine has been played since it last paid, not the
    35th, the slot machine pays Martha nothing. Martha will play the second slot machine
    next. This is our new state:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎开始玩第一台老虎机，花费一枚硬币。因为这是自上次支付以来，这台机器已经被玩了29次，而不是第35次，所以下这台老虎机并不会给玛莎任何奖励。接下来，玛莎将玩第二台老虎机。这是我们的新状态：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 6 | second | 29 | 0 | 8 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 6 | second | 29 | 0 | 8 |'
- en: 'Playing the second slot machine costs one quarter. Because this is the first
    time this machine has been played since it last paid, not the 100th, the slot
    machine pays Martha nothing. Martha will play the third slot machine next. This
    is our new state:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 玩第二台老虎机需要花费一枚硬币。因为这是自上次支付以来，这台机器第一次被玩，而不是第100次，所以下这台老虎机并不会给玛莎任何奖励。接下来，玛莎将玩第三台老虎机。这是我们的新状态：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 2 | 5 | third | 29 | 1 | 8 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 5 | third | 29 | 1 | 8 |'
- en: 'Playing the third slot machine costs one quarter. Because this is the 9th time
    this machine has been played since it last paid, not the 10th, the slot machine
    pays Martha nothing. Next, Martha will cycle back to the first slot machine. This
    is our new state:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 玩第三台老虎机需要花费一枚硬币。因为这是自上次支付以来，这台机器已经被玩了9次，而不是第10次，所以下这台老虎机并不会给玛莎任何奖励。接下来，玛莎将返回到第一台老虎机。
    这是我们的新状态：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 3 | 4 | first | 29 | 1 | 9 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | first | 29 | 1 | 9 |'
- en: 'Now Martha plays the first slot machine:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玛莎玩第一台老虎机：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 4 | 3 | second | 30 | 1 | 9 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | second | 30 | 1 | 9 |'
- en: 'Then Martha plays the second slot machine:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后玛莎玩第二台老虎机：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 5 | 2 | third | 30 | 2 | 9 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | third | 30 | 2 | 9 |'
- en: 'Martha is almost out of quarters! But there’s good news coming, because she’s
    next going to play the third slot machine. It has been played nine times since
    it last paid. The next play is therefore its 10th, which pays Martha nine quarters.
    She had two quarters, pays one to play this machine, and then gets paid nine,
    so she’ll have 2 – 1 + 9 = 10 quarters after this play:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎快没硬币了！但好消息来了，因为她接下来要玩第三个老虎机。自从上次支付以来，这台机器已经被玩了九次。因此，下次游戏是它的第十次，这次会支付玛莎九个硬币。她原本有两个硬币，支付一个硬币来玩这台机器，然后获得九个硬币，所以这次游戏后她将有
    2 – 1 + 9 = 10 个硬币：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **游戏次数** | **投币次数** | **下次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 6 | 10 | first | 30 | 2 | 0 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 10 | 第一次 | 30 | 2 | 0 |'
- en: Notice that the third slot machine has now been played zero times since it last
    paid.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第三台老虎机自上次支付以来，已经玩了零次。
- en: That’s six plays so far. I encourage you to keep tracing. You should see that
    Martha never gets paid again and that after 10 more plays (for a total of 16),
    Martha is broke.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止已经进行了六次游戏。我鼓励你继续追踪。你应该能看到玛莎再也没有拿到任何报酬，而且在再进行10次游戏（共16次）后，玛莎破产了。
- en: A Limitation of for loops
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for` 循环的局限性'
- en: In [Chapter 3](ch03.xhtml#ch03), we studied `for` loops. Standard `for` loops
    loop through a sequence, such as a string. We certainly have no string in the
    Slot Machines problem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3章](ch03.xhtml#ch03)中，我们学习了 `for` 循环。标准的 `for` 循环是遍历一个序列，比如字符串。但在老虎机问题中，我们显然没有字符串。
- en: Range `for` loops loop through a range of integers and can be used to loop a
    specified number of times. But how many times should we loop for Slot Machines?
    Ten? Fifty? Who knows. It depends on the number of plays that Martha can make
    before she’s out of quarters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Range `for` 循环遍历一系列整数，并且可以用于循环指定次数。但我们应该为老虎机循环多少次呢？十次？五十次？谁知道呢。这取决于玛莎在破产前能玩多少次。
- en: We have no string and don’t know how many iterations are required. If all we
    had were `for` loops, we’d be stuck.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有字符串，也不知道需要多少次迭代。如果我们只有 `for` 循环，那就会卡住。
- en: Enter the *while loop*, the most general looping structure that Python offers.
    We can write `while` loops that have nothing to do with strings or sequences of
    integers. In return for this added flexibility, we’ll need to be a little more
    careful and take a little more responsibility with writing our loops. Let’s dig
    in!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 *while 循环*，Python 提供的最通用的循环结构。我们可以编写与字符串或整数序列无关的 `while` 循环。为了获得这种灵活性，我们需要更加小心，并且在编写循环时承担更多责任。让我们深入了解吧！
- en: while loops
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: To write a `while` loop, we use Python’s `while` statement. A `while` loop is
    controlled by a Boolean expression. If the Boolean expression is `True`, then
    Python executes one iteration of the `while` loop. If the expression is still
    `True`, then Python executes another iteration of the `while` loop, and so on,
    until the Boolean expression is `False`. If the Boolean expression is `False`
    at the outset, then the loop does not run at all.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个 `while` 循环，我们使用 Python 的 `while` 语句。`while` 循环由一个布尔表达式控制。如果布尔表达式为 `True`，Python
    就会执行一次 `while` 循环。如果该表达式仍然为 `True`，Python 将执行另一次循环，以此类推，直到布尔表达式为 `False`。如果一开始布尔表达式为
    `False`，则循环根本不会执行。
- en: '`while` loops are *indefinite loops*: the number of iterations may not be known
    in advance.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是 *不定次循环*：循环的次数可能事先无法知道。'
- en: Using while loops
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 while 循环
- en: 'Let’s start with the following example of a `while` loop:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下 `while` 循环的例子开始：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In a `for` loop, the loop variable is created for us; we don’t have to use an
    assignment statement to create the variable prior to the loop. But in a `while`
    loop, we get nothing for free. If we need a variable to loop through values in
    a `while` loop, then we have to create that variable ourselves. We do that here
    by making `num` refer to `0` prior to the loop ❶.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环中，循环变量是由 Python 自动创建的；我们不需要在循环之前使用赋值语句来创建变量。但在 `while` 循环中，我们什么也得不到。如果我们需要一个变量来遍历
    `while` 循环中的值，那么我们必须自己创建这个变量。我们通过在循环之前让 `num` 指向 `0` 来做到这一点 ❶。
- en: The `while` loop itself is controlled by the Boolean expression `num < 5` ❷.
    If `num < 5` is `True`, then the code in the loop block will run. Right now, `num`
    refers to `0`, so the Boolean expression is `True`. We therefore run the loop
    block, which outputs `0` and then increases `num` to `1` ❸.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环本身由布尔表达式 `num < 5` ❷ 控制。如果 `num < 5` 为 `True`，那么循环体中的代码将执行。现在，`num`
    为 `0`，所以布尔表达式为 `True`。因此，我们运行循环体，输出 `0`，然后将 `num` 增加到 `1` ❸。'
- en: We jump back to the top of the loop and evaluate the `num < 5` Boolean expression
    again. As `num` refers to `1`, the expression is `True`. We therefore run the
    loop block again, which outputs `1` and then increases `num` to `2`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳回循环的顶部，再次评估`num < 5`的布尔表达式。由于`num`为`1`，表达式为`True`。因此我们再次执行循环块，输出`1`，并将`num`增加到`2`。
- en: 'Back to the top of the loop: is `num < 5` still `True`? It is, because `num`
    is only `2`. That kicks off another iteration of the loop, which outputs `2` and
    increases `num` to `3`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回到循环的开始：`num < 5`还为`True`吗？是的，因为`num`现在是`2`。这会启动循环的另一次迭代，输出`2`，并将`num`增加到`3`。
- en: 'This pattern continues, with two more iterations of the loop: one when `num`
    refers to `3` and one when `num` refers to `4`. When `num` refers to `5`, the
    `num < 5` Boolean expression is finally `False`, which terminates the loop.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式会继续下去，循环还有两次迭代：一次当`num`为`3`时，一次当`num`为`4`时。当`num`为`5`时，`num < 5`的布尔表达式最终为`False`，循环结束。
- en: 'It’s important that we remember to increase `num` ❸. A `for` loop automatically
    steps our loop variable through the appropriate values. But, again, we get nothing
    for free in a `while` loop and must update variables ourselves to bring us closer
    and closer to loop termination. If we forget to increase `num`, this happens:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记得增加`num` ❸。`for`循环会自动将我们的循环变量推进到适当的值。然而，在`while`循环中，我们没有免费的“进展”，必须自己更新变量，以便逐渐接近循环终止。如果忘记增加`num`，会发生如下情况：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run this code on your computer, your screen will fill up with zeros,
    and you’ll have to terminate your program. You can do that by pressing CTRL-C
    or by closing the Python window.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在电脑上运行这段代码，屏幕将被零填满，程序会一直运行下去，直到你终止它。你可以按CTRL-C或关闭Python窗口来终止程序。
- en: The problem is that `num < 5` stays `True` forever; nothing in the loop can
    ever make it `False`. This situation, where a loop never terminates, is called
    an *infinite loop*. It’s surprisingly easy to inadvertently produce infinite `while`
    loops. If you see the same values repeating or your program appears to be doing
    nothing at all, it’s likely that you’re stuck in an infinite loop. Carefully check
    the `while` loop’s Boolean expression and that the loop block is making progress
    toward termination.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是`num < 5`永远为`True`；循环中的任何东西都无法让它变为`False`。这种循环永不终止的情况叫做*无限循环*。意外地产生无限`while`循环其实非常容易。如果你看到相同的值不断重复，或者程序似乎什么都没做，那可能是你陷入了一个无限循环。仔细检查`while`循环的布尔表达式，确保循环块正在朝着终止的方向推进。
- en: 'We can do whatever we like with the `num` variable. Here’s a `while` loop counting
    up by three:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`num`变量进行任何操作。以下是一个`while`循环，每次增加三：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here’s a `while` loop counting down from `4` to `0`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`while`循环，从`4`倒数到`0`：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that I’ve used `>=` here rather than `>` ❶. This way, the while loop
    runs when `num` refers to `0`, as desired.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里使用了`>=`而不是`>` ❶。这样，`while`循环会在`num`为`0`时执行，正是我们想要的效果。
- en: '**CONCEPT CHECK**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: '3'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: B.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: '3'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: C.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: '3'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '-100'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '-100'
- en: D.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: D.
- en: '3'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '-100'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '-100'
- en: 'Answer: C. A `while` loop’s Boolean expression is checked only at the start
    of each iteration. Even if it becomes `False` at some point during the iteration,
    the remainder of the iteration completes.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。`while`循环的布尔表达式只在每次迭代开始时检查。即使在迭代过程中某个时刻它变为`False`，迭代的剩余部分仍会完成。
- en: As `3` is greater than `0`, an iteration of the loop runs. The `if` statement
    block is skipped (because its Boolean expression is `False`), so this iteration
    outputs `3` and sets `n` to `4`. As `4` is greater than `0`, we have another iteration
    of the loop, this one outputting `4` and setting `n` to `5`. As `5` is greater
    than `0`, we have yet another iteration of the loop. This time, the `if` statement
    block runs, which sets `n` to `-100`. Next, `-100` is output, and `n` is set to
    `-99`. And here we stop, because `n > 0` is `False`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`3`大于`0`，循环执行一次。`if`语句块被跳过（因为它的布尔表达式为`False`），所以这次迭代输出`3`，并将`n`设为`4`。由于`4`大于`0`，我们再次执行循环，这次输出`4`并将`n`设为`5`。由于`5`大于`0`，我们再次执行循环。这时，`if`语句块执行，将`n`设为`-100`。接下来，输出`-100`，并将`n`设为`-99`。我们在这里停止，因为`n
    > 0`为`False`。
- en: '**CONCEPT CHECK**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: '6'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: B.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: '6'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: C.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: '5'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: D.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: D.
- en: '5'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: E.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: E.
- en: '6'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'Answer: C. Many `while` loops do something and then update the loop variable,
    but not this one. This one first decrements the loop variable `x` and *then* outputs
    it. As `6` is greater than `4`, an iteration of the loop runs, which assigns `5`
    to `x` and then outputs `5`. Next, `5` is greater than `4`, so we have another
    iteration, this one assigning `4` to `x` and outputting `4`. And that’s it: `4`
    is not greater than `4`, so the loop terminates.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C. 许多`while`循环会执行一些操作然后更新循环变量，但这个循环不是这样。这个循环首先递减循环变量`x`，*然后*输出它。由于`6`大于`4`，循环执行了一次，`x`被赋值为`5`并输出`5`。接着，`5`大于`4`，所以我们又进行了一次迭代，这次将`x`赋值为`4`并输出`4`。就这样：`4`不大于`4`，所以循环终止。
- en: Nesting Loops in Loops
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环中的嵌套循环
- en: 'We can nest loops inside of `while` loops, much as we can nest loops inside
    of `for` loops. In “Nesting” in [Chapter 3](ch03.xhtml#ch03), I noted that the
    inner `for` loop completes all of its iterations before the next iteration of
    the outer loop begins. The same holds for `while` loops. Here’s an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`while`循环中嵌套循环，就像我们可以在`for`循环中嵌套循环一样。在[第3章](ch03.xhtml#ch03)的“嵌套”中，我提到过，内部`for`循环在外部循环的下一次迭代开始之前完成所有的迭代。`while`循环也一样。这里有一个例子：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each value of `i` is involved in three lines of output, one for each iteration
    of the inner `j` loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`i`值涉及到三行输出，每行对应内部`j`循环的一次迭代。
- en: '**CONCEPT CHECK**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: How many lines are output by the following nested loop?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下嵌套循环会输出多少行？
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A. 2
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: A. 2
- en: B. 3
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: B. 3
- en: C. 6
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C. 6
- en: D. 8
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: D. 8
- en: E. 9
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: E. 9
- en: 'Answer: A. The outer loop’s Boolean expression, `x < 3`, is `True`, so we perform
    an iteration of the outer loop. That leads to two iterations of the inner loop:
    one when `y` is `1` and one when `y` is `2`, each of which prints a line of output.
    So that’s two lines of output so far.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 外部循环的布尔表达式`x < 3`为`True`，所以我们执行一次外部循环的迭代。这导致内部循环进行了两次迭代：一次当`y`为`1`时，另一次当`y`为`2`时，每次都会打印一行输出。所以到目前为止，输出了两行。
- en: But nothing in the code resets `y`’s value! Therefore, `y < 3` will never be
    `True` again, and there won’t be any further iterations of the inner loop.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但代码中没有任何内容重置`y`的值！因此，`y < 3`将再也不会为`True`，也不会有更多的内部循环迭代。
- en: Forgetting to reset a loop variable is a common mistake when dealing with nested
    `while` loops.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记重置循环变量是处理嵌套`while`循环时常见的错误。
- en: Adding Boolean Operators
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加布尔运算符
- en: 'To solve Slot Machines, we want to loop while Martha has at least one quarter.
    That looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决老虎机问题，我们希望在玛莎至少有一枚硬币的情况下继续循环。像这样：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That simple Boolean expression will suffice for this problem. But just like
    for `if` statements, the Boolean expression following the word `while` can include
    relational or Boolean operators. Here’s an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的布尔表达式足以解决这个问题。但就像`if`语句一样，跟在`while`后面的布尔表达式可以包含关系运算符或布尔运算符。这里有一个例子：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `while` loop is controlled by the Boolean expression `x <= 10 and y <= 13`.
    As with any `and` operator, both of its operands must be `True` for the whole
    expression to be `True`. When `x` refers to `8` and `y` refers to `14`, the loop
    terminates because the `y <= 13` operand is `False`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环由布尔表达式`x <= 10 and y <= 13`控制。与任何`and`运算符一样，只有当两个操作数都为`True`时，整个表达式才为`True`。当`x`为`8`，`y`为`14`时，循环终止，因为`y
    <= 13`的操作数为`False`。'
- en: Solving the Problem
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: To solve Slot Machines, we know that we need a `while` loop, not a `for` loop,
    because we can’t predict the number of iterations in advance. Each iteration of
    the loop will play the current slot machine. When the loop terminates, Martha
    will have no quarters left, and we will output the number of times she played.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决老虎机问题，我们知道我们需要一个`while`循环，而不是`for`循环，因为我们无法预先预测迭代次数。每次循环将玩当前的老虎机。当循环终止时，玛莎将没有任何硬币，我们将输出她玩过的次数。
- en: 'Here’s what we need to do on each iteration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次迭代中执行以下操作：
- en: Decrease Martha’s quarters by one (since it costs one quarter to play a slot
    machine).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玛莎的硬币减去一个（因为玩老虎机需要一个硬币）。
- en: If Martha is currently on the first slot machine, play that machine. This involves
    increasing the number of times this machine has been played. If this is the 35th
    play, then pay Martha and reset the number of times that this machine has been
    played to 0.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玛莎当前在第一个老虎机上，玩这个机器。这涉及到增加该机器的游戏次数。如果这是第35次游戏，那么支付玛莎并将该机器的游戏次数重置为0。
- en: If Martha is currently on the second slot machine, play that machine (similar
    to how we played the first machine).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玛莎当前在第二个老虎机上，玩这个机器（与我们玩第一个机器的方式类似）。
- en: If Martha is currently on the third slot machine, play that machine (similar
    to how we played the first machine).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玛莎目前在第三个老虎机上，就玩这个机器（类似于我们玩第一个机器的方式）。
- en: Increase the number of Martha’s plays (since we just played a machine).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加玛莎的游戏次数（因为我们刚刚玩了一个机器）。
- en: Move to the next machine. If Martha just played the first machine, we want to
    move to the second; if she just played the second, we want to move to the third;
    and if she just played the third, we want to cycle back to the first.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到下一个机器。如果玛莎刚刚玩了第一个老虎机，我们要转到第二个；如果她刚刚玩了第二个，我们要转到第三个；如果她刚刚玩了第三个，我们要重新回到第一个。
- en: Our programs are getting longer now, so outlining the plan as I just did is
    a useful technique for keeping the complexity under control and guiding us toward
    correct code. We can use the outline to make sure we’re following the plan and
    not forgetting anything.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序现在变得更长了，所以像我刚才那样列出计划是一个有用的技巧，可以帮助我们保持复杂性可控，并引导我们编写正确的代码。我们可以使用这个大纲来确保我们遵循计划，并没有遗漏任何步骤。
- en: Our code is in [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码在[清单 4-1](ch04.xhtml#ch04ex01)中。
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-1: Solving Slot Machines*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：解决老虎机问题*'
- en: The `quarters` variable tracks the number of quarters that Martha has. The `first`,
    `second`, and `third` variables track the number of plays since the last payment
    for the first, second, and third slot machines, respectively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarters`变量跟踪玛莎拥有的硬币数量。`first`、`second`和`third`变量分别跟踪第一个、第二个和第三个老虎机自上次支付以来的游戏次数。'
- en: The `machine` variable tracks the slot machine that Martha will play next. The
    first slot machine is referred to by the number `0`, the second by the number
    `1`, and the third by `2`. Making `machine` refer to `0` therefore indicates that
    the first slot machine will be played next ❶.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`machine`变量跟踪玛莎接下来将玩的老虎机。第一个老虎机用数字`0`表示，第二个用数字`1`表示，第三个用数字`2`表示。因此，将`machine`设置为`0`意味着接下来会玩第一个老虎机
    ❶。'
- en: 'We could have referred to the slot machines using `1`, `2`, and `3` instead
    of `0`, `1`, and `2`. Or we could have used strings: `''first''`, `''second''`,
    and `''third''`. But numbering items starting from zero is customary, so that’s
    what I’ve done here.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以用`1`、`2`和`3`来表示老虎机，而不是`0`、`1`和`2`。或者我们可以使用字符串：`'first'`、`'second'`和`'third'`。但是从零开始编号是惯例，因此我这里使用的是这种方式。
- en: The final variable in this program is `plays`, which tracks the number of slot
    machines that Martha has played. We’ll output this once Martha is out of quarters.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序中的最后一个变量是`plays`，它跟踪玛莎玩过的老虎机数量。当玛莎的硬币用完后，我们将输出这个变量。
- en: The bulk of the program consists of a `while` loop that loops as long as Martha
    has quarters ❷.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主体部分是一个`while`循环，循环条件是玛莎还有硬币 ❷。
- en: Each iteration of the loop plays one slot machine. As such, the first thing
    we do is decrease Martha’s quarters by one ❸. Next, we play the current slot machine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的每次迭代都会玩一个老虎机。因此，首先我们要做的事情是减少玛莎的硬币数量 ❸。接下来，我们玩当前的老虎机。
- en: Are we on slot machine 0? Slot machine 1? Slot machine 2? We need an `if` statement
    to answer that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是在老虎机 0 上吗？老虎机 1？老虎机 2？我们需要一个`if`语句来回答这个问题。
- en: We first check whether we’re on slot machine 0 ❹. If we are, then we increase
    the number of plays since this slot machine paid by one. To determine whether
    Martha gets paid, we then check whether this machine has been played exactly 35
    times since it last paid ❺. If it has, then we reset this machine’s plays to `0`
    and increase Martha’s quarters by 30.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否在老虎机 0 上 ❹。如果是，那么我们增加这个老虎机的游戏次数，因为它已经支付给玛莎。接着，我们检查这个机器自上次支付以来是否已经玩了恰好
    35 次 ❺。如果是，那么我们将该机器的游戏次数重置为`0`，并增加玛莎的硬币数量 30。
- en: There are several levels of nesting here, so take some time to convince yourself
    that the logic of the code is correct. In particular, note that every time we
    play the first machine, we increase its number of plays by one. But we only pay
    Martha after every 35 plays—that’s why we have the inner `if` statement ❺!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有好几层嵌套，所以请花些时间确保代码的逻辑是正确的。特别是要注意，每次我们玩第一个老虎机时，我们都会将其游戏次数增加 1。但我们只有在每玩 35 次后才会支付玛莎——这就是为什么我们有内层的`if`语句
    ❺！
- en: We handle the second and third slot machines just as we handled the first. The
    only difference is that each slot machine pays Martha after its own number of
    plays and pays Martha its own amount of quarters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理第二和第三个老虎机的方式与处理第一个老虎机相同。唯一的区别是每个老虎机在其自有的游戏次数后支付给玛莎，并支付给她相应的硬币数量。
- en: Having played a slot machine, we increase Martha’s number of plays by one ❻.
    Now all that’s left is to move to the next machine so that we’ll be at the right
    machine if there’s a next iteration of the loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 玩过老虎机后，我们将玛莎的游戏次数增加 1 ❻。现在只剩下移动到下一个机器，以确保如果循环有下一次迭代，我们能在正确的机器上。
- en: To move to the next machine, we increase `machine` by one ❼. If we were on machine
    `0`, this would move us to machine `1`. If we were on machine `1`, this would
    move us to machine `2`. If we were on machine `2`, this would move us to machine
    `3`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动到下一个机器，我们将 `machine` 增加 1 ❼。如果我们在机器 `0` 上，这将使我们移到机器 `1`。如果我们在机器 `1` 上，这将使我们移到机器
    `2`。如果我们在机器 `2` 上，这将使我们移到机器 `3`。
- en: '*. . .* Machine 3? There’s no machine 3! If we just played machine 2, then
    we want to start over at machine 0\. To do that, we add a check: if we just moved
    to machine `3` ❽, then we know that we just played machine `2`, so we reset `machine`
    to machine `0`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*...* 机器 3？没有机器 3！如果我们刚玩过机器 2，那么我们希望从机器 0 开始重新开始。为此，我们添加了一个检查：如果我们刚移到机器 `3`
    ❽，那么我们知道我们刚玩过机器 `2`，所以我们将 `machine` 重置为机器 `0`。'
- en: When the loop terminates, we know that Martha has no quarters left. As a last
    step, we output the required sentence, including Martha’s number of plays.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环终止时，我们知道玛莎已经没有硬币了。最后一步，我们输出所需的句子，包括玛莎玩了多少次。
- en: 'This code has a lot going on: stopping when Martha has no quarters left, keeping
    track of the current machine, paying Martha when appropriate, and counting Martha’s
    plays. Feel free to submit this code now, but also to consider whether you’d have
    written parts of it in a different way. What happens if you increase `plays` by
    `1` at the top of the loop instead of the bottom? Does it matter whether you decrease
    `quarters` by `1` at the top of the loop or the bottom? Would you have used new
    variables to keep track of the number of times that Martha played each slot machine,
    rather than modifying `first`, `second`, and `third`? I strongly encourage you
    to experiment with variations of what we’ve done here. If you make changes and
    the code no longer passes the tests, great! Now you have a new learning opportunity
    to fix the code and learn why your changes led to undesired behavior.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了很多内容：在玛莎没有硬币时停止，跟踪当前机器，适时支付玛莎，并计算玛莎的游戏次数。现在可以提交这段代码，但也可以考虑是否有其他方式编写部分代码。如果你将
    `plays` 在循环顶部增加 1，而不是底部，会发生什么？将 `quarters` 在循环顶部或底部减 1 有区别吗？你是否会使用新变量来跟踪玛莎玩过每台老虎机的次数，而不是修改
    `first`、`second` 和 `third`？我强烈建议你尝试不同的变体。如果你做了修改，代码不再通过测试，太好了！现在你有了一个新的学习机会来修复代码，并了解为什么你的修改导致了不期望的行为。
- en: The next two sections offer further refinement of the code. We’ll use the `%`
    operator to reduce the number of variables that we need and learn about f-strings
    to streamline how we build strings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将进一步完善代码。我们将使用 `%` 运算符来减少需要的变量数量，并学习 f-string 以简化字符串构建。
- en: The Mod Operator
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模运算符
- en: 'In “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01), I
    introduced the mod (`%`) operator for calculating the remainder of an integer
    division. For example, 16 divided by 5 has a remainder of 1:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.xhtml#ch01)的“整数与浮点数”中，我介绍了用于计算整数除法余数的模运算符（`%`）。例如，16 除以 5 的余数是 1：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And 15 divided by 5 has a remainder of 0 (because 5 divides 15 exactly):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 15 除以 5 的余数是 0（因为 5 恰好能整除 15）：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second operand dictates the range of values that `%` can possibly return.
    The possible return values are 0 up to but not including the second operand. For
    example, if the second operand is `3`, then the only values that can be returned
    by `%` are 0, 1, and 2\. In addition, as we increase the first operand, we cycle
    through all possible return values. Here’s an example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作数决定了 `%` 操作符可能返回的值的范围。可能返回的值是从 0 到但不包括第二个操作数。例如，如果第二个操作数是 `3`，那么 `%` 只能返回
    0、1 和 2。此外，当我们增加第一个操作数时，我们会依次循环所有可能的返回值。这里有一个例子：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice the pattern: 0, 1, 2, 0, 1, 2, and so on.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个模式：0, 1, 2, 0, 1, 2，以此类推。
- en: 'This behavior is useful for counting up to a specified number and then cycling
    back to 0\. It’s exactly the behavior that we need when playing the slot machines:
    we play slot machine 0, then 1, then 2, then 0, then 1, then 2, then 0, then 1,
    and so on. (This is another reason why I used `0`, `1`, and `2`, rather than other
    values, to refer to the slot machines.)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于计算到指定次数并且然后循环回 0 非常有用。这正是我们玩老虎机时所需的行为：我们先玩老虎机 0，然后是 1，然后是 2，然后是 0，再是 1，再是
    2，然后是 0，再是 1，依此类推。（这也是为什么我使用 `0`、`1` 和 `2` 来表示老虎机，而不是其他值的原因。）
- en: 'Suppose that variable `plays` refers to the number of times that Martha has
    played. To determine the next machine to play (`0`, `1`, or `2`), we can use the
    `%` operator. For example, suppose that Martha has played one slot machine so
    far, and we want to know which she will play next. She’ll play slot machine `1`
    next, and the `%` operator tells us that:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量 `plays` 表示玛莎已玩游戏的次数。为了确定下一个要玩的机器（`0`、`1`或`2`），我们可以使用`%`运算符。例如，假设玛莎至今已经玩了一个老虎机，我们想知道她接下来会玩哪个。她将接着玩老虎机
    `1`，而`%`运算符告诉我们：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If Martha has played six times so far, then she’s played slot machines 0, 1,
    2, 0, 1, 2\. The next slot machine she’ll play is machine 0\. And, as she’s played
    all three machines twice, with no other plays beyond that, the `%` operator gives
    us `0`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玛莎迄今为止玩了六次，那么她玩了老虎机 0、1、2、0、1、2。接下来她要玩的老虎机是机器 0。而且，由于她已经玩了三台机器两次，并且没有其他额外的游戏，`%`
    运算符给我们带来了 `0`：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a final example, suppose that Martha has played 11 times so far. She’s done
    three complete cycles: 0, 1, 2, 0, 1, 2, 0, 1, 2\. That’s nine of the plays. The
    remaining two plays put Martha on slot machine 2 for her next play:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，假设玛莎已经玩了 11 次。她完成了三次完整的循环：0、1、2、0、1、2、0、1、2。那是九次游戏。剩下的两次游戏使得玛莎接下来的游戏是老虎机
    2：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is, we can figure out the slot machine to play without explicitly maintaining
    a `machine` variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以在不显式维护 `machine` 变量的情况下确定要玩的老虎机。
- en: 'We can also use `%` to simplify the logic of determining whether the next play
    on the current slot machine pays Martha. Consider the first slot machine. In [Listing
    4-1](ch04.xhtml#ch04ex01), we counted the number of plays since the slot machine
    paid. If that number is 35, then we pay Martha and reset the count to 0\. But
    there’s no need to reset the count if we’re using the `%` operator. We can just
    check whether the slot machine has been played a multiple of 35 times and pay
    Martha if so. To test whether a number is a multiple of 35, we can use the `%`
    operator. A number is a multiple of 35 if dividing it by 35 yields no remainder:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`%`来简化逻辑，判断当前老虎机的下一次游戏是否支付玛莎。考虑第一个老虎机。在[清单 4-1](ch04.xhtml#ch04ex01)中，我们计算了自上次老虎机支付以来的游戏次数。如果这个数字是
    35，那么我们就支付玛莎并将计数重置为 0。但是，如果我们使用`%`运算符，就不需要重置计数。我们只需检查老虎机是否已经玩了 35 的倍数次，如果是，就支付玛莎。为了测试一个数字是否是
    35 的倍数，我们可以使用`%`运算符。如果一个数字能被 35 除尽，且没有余数，那么它就是 35 的倍数：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can just check `first % 35 == 0` to determine whether to pay Martha.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需检查`first % 35 == 0`来确定是否支付玛莎。
- en: I’ve updated [Listing 4-1](ch04.xhtml#ch04ex01) to use the `%` operator. The
    new code is in [Listing 4-2](ch04.xhtml#ch04ex02).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经更新了[清单 4-1](ch04.xhtml#ch04ex01)，使用了`%`运算符。新代码见[清单 4-2](ch04.xhtml#ch04ex02)。
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-2: Solving Slot Machines using* %'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-2：使用* % *解决老虎机问题*'
- en: 'I’ve used `%` in the two ways described in this section: to determine the current
    machine based on the number of plays ❶ and to determine whether Martha gets paid
    on a play (for example, at ❷).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在本节中以两种方式使用了`%`：一种是根据已玩次数确定当前机器❶，另一种是确定玛莎是否在某次游戏中获得奖励（例如，在❷处）。
- en: Associating `%` with returning the remainder of a division belies its flexibility.
    Whenever you need to count in a cycle (0, 1, 2, 0, 1, 2), consider whether you
    can use `%` to simplify your code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将`%`与返回除法余数的功能联系起来掩盖了它的灵活性。每当你需要按周期计数（0, 1, 2, 0, 1, 2）时，可以考虑是否可以使用`%`来简化代码。
- en: F-Strings
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F-字符串
- en: 'The final thing we do in our solution to Slot Machines is output the required
    sentence, like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在解决老虎机问题时的最后一步是输出所需的句子，如下所示：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have to remember to end the first string so that we can output the number
    of plays and then start a new string for the second half of the sentence. In addition,
    we’re using multiple arguments to `print` to avoid having to convert `plays` to
    a string. If we were storing the resulting string rather than printing it, we’d
    need the `str` conversion:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记得结束第一个字符串，这样我们就可以输出播放次数，然后开始新的字符串来表示句子的后半部分。此外，我们使用多个参数来调用`print`，以避免将`plays`转换为字符串。如果我们是存储结果字符串而不是直接打印出来，我们将需要进行`str`转换：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Gluing strings and integers together is fine for a simple sentence like this,
    but it doesn’t scale. Here’s how it looks when we try to embed three integers
    instead of one:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串和整数拼接在一起对于像这样的简单句子是可以的，但它不能扩展。当我们尝试嵌入三个整数而不是一个时，它会变成这样：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We don’t want to have to keep track of all of those quotes, pluses, and spaces.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想一直跟踪那些引号、加号和空格。
- en: 'The most flexible way to build a string consisting of strings and numbers is
    to use an *f-string*. Here’s how the previous example looks with an f-string:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包含字符串和数字的字符串最灵活的方式是使用*f-string*。以下是使用f-string的前一个示例：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice the `f` before the opening quote of the string. The `f` stands for format,
    because f-strings allow you to format the contents of a string. Inside of an f-string,
    we can place expressions inside curly brackets. As the string is being built,
    each expression is replaced by its value and inserted into the string. The result
    is just a regular old string—there’s no new type here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串开头的`f`。`f`代表格式化，因为f-strings允许你格式化字符串的内容。在f-string内部，我们可以将表达式放在大括号中。随着字符串的构建，每个表达式都会被其值替换并插入到字符串中。结果仍然是一个普通的字符串——这里没有新的类型：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The expressions in the curly brackets can be more complex than bare variable
    names:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号中的表达式可以比单纯的变量名更复杂：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can use f-strings in the final line of Slot Machines. Here’s how that would
    look:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在“老虎机”问题的最后一行中使用f-strings。以下是它的表现方式：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even in this simplest of string-formatting contexts, I think f-strings add clarity.
    Keep them in the back of your mind for whenever you catch yourself building a
    string from smaller pieces.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个最简单的字符串格式化上下文中，我认为f-strings也能增加清晰度。随时记住它们，当你发现自己在从小块拼接字符串时，可以使用它们。
- en: 'One warning about f-strings: they were added in Python 3.6, which at the time
    of writing is still a reasonably recent version of Python. In older versions of
    Python, f-strings cause syntax errors.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于f-strings的一个警告：它们是在Python 3.6中添加的，而在写作时，Python 3.6仍然是一个相对较新的版本。在旧版本的Python中，f-strings会导致语法错误。
- en: If you use f-strings, be sure to check that the judge you’re submitting to is
    using Python 3.6 or newer to test your code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用f-strings，请确保检查你提交的评测系统是否使用Python 3.6或更高版本来测试你的代码。
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决“章节练习”中的练习1，位于[第99页](ch04.xhtml#ch04lev1sec17)。
- en: 'Problem #9: Song Playlist'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题#9：歌曲播放列表
- en: Sometimes we don’t know in advance how much input will be provided. We’ll see
    in this problem that a `while` loop is what we need in such cases.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们无法预先知道会提供多少输入。我们将在这个问题中看到，`while`循环正是我们在这种情况下需要的。
- en: This is DMOJ problem `ccc08j2`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ccc08j2`。
- en: The Challenge
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'We have five favorite songs named A, B, C, D, and E. We’ve created a playlist
    of these songs and are using an app to manage the playlist. The songs start off
    in the order A, B, C, D, E. The app has four buttons:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五首最喜欢的歌曲，分别是A、B、C、D和E。我们已经创建了一个包含这些歌曲的播放列表，并使用一个应用程序来管理这个播放列表。歌曲的顺序是A、B、C、D、E。这个应用程序有四个按钮：
- en: 'Button 1: Moves the first song of the playlist to the end of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to B,
    C, D, E, A.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮1：将播放列表中的第一首歌移动到播放列表的末尾。例如，如果当前的播放列表是A、B、C、D、E，那么它将变为B、C、D、E、A。
- en: 'Button 2: Moves the last song of the playlist to the beginning of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to E,
    A, B, C, D.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮2：将播放列表中的最后一首歌移动到播放列表的开头。例如，如果当前的播放列表是A、B、C、D、E，那么它将变为E、A、B、C、D。
- en: 'Button 3: Swaps the first two songs of the playlist. For example, if the playlist
    is currently A, B, C, D, E, then it changes to be B, A, C, D, E.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮3：交换播放列表中的前两首歌曲。例如，如果当前的播放列表是A、B、C、D、E，那么它将变为B、A、C、D、E。
- en: 'Button 4: Plays the playlist!'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮4：播放播放列表！
- en: We’re provided a user’s button presses. When the user presses button 4, output
    the order of songs in the playlist.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到用户的按钮按压信息。当用户按下按钮4时，输出播放列表中歌曲的顺序。
- en: Input
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of pairs of lines, where the first line of a pair gives
    the number of a button (`1`, `2`, `3`, or `4`), and the second gives the number
    of times that the user pressed this button (between 1 and 10). That is, the first
    line is the number of a button, the second line is the number of times it is pressed,
    the third line is the number of a button, the fourth line is the number of times
    it is pressed, and so on. The input ends with these two lines:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由成对的行组成，其中每对的第一行给出一个按钮的编号（`1`、`2`、`3`或`4`），第二行给出用户按下该按钮的次数（介于1和10之间）。也就是说，第一行是按钮编号，第二行是按下次数，第三行是按钮编号，第四行是按下次数，依此类推。输入以这两行结束：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: indicating that the user pressed button `4` once.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表示用户按下按钮`4`一次。
- en: Output
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the order of songs in the playlist after all button presses. The output
    must be on one line, with a space separating each pair of songs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输出播放列表中所有按钮按下后的歌曲顺序。输出必须在一行内，歌曲对之间用空格隔开。
- en: String Slicing
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串切片
- en: 'The high-level plan of our solution to Song Playlist will be a `while` loop
    that keeps going as long as we haven’t found the press of button `4`. On each
    iteration, we’ll read two lines of input and process them. That leads to this
    structure:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决“歌曲播放列表”问题的高层次方案将是一个`while`循环，只要我们没有找到按下按钮`4`，循环就会继续进行。每次循环，我们会读取两行输入并处理它们。这导致了如下结构：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Prior to the `while` loop, we create the variable `button` and make it refer
    to the number `0` ❶. Without this, the `button` variable would not exist, and
    we’d get a `NameError` in the `while` loop’s Boolean expression. Any number besides
    `4` would work here to trigger the first iteration of the loop.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环之前，我们创建变量`button`并将其初始化为数字`0` ❶。没有这个，`button`变量将不存在，我们在`while`循环的布尔表达式中会出现`NameError`。除了`4`以外的任何数字都可以触发循环的第一次迭代。
- en: Within this `while` loop, we’ll use a `for` loop to process the button presses.
    For each press, we’ll use an `if` statement to check which button was pressed.
    We’ll need four indented blocks of statements in the `if` statement, one for each
    of the four buttons.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`while`循环中，我们将使用`for`循环来处理按钮按下的操作。对于每一次按下，我们将使用`if`语句来检查按下的是哪个按钮。我们需要在`if`语句中为四个按钮分别创建四个缩进的语句块。
- en: 'Let’s talk about how to handle each of the buttons. Button `1` moves the first
    song of the playlist to the end of the playlist. Because we have a small, known
    number of songs, we can get away with using string indexing to concatenate each
    character. Remember that the first character of a string is at index 0, not 1\.
    We can put that character at the end of the string like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何处理每个按钮。按钮`1`将播放列表中的第一首歌移到播放列表的末尾。由于我们知道歌曲的数量很小且固定，我们可以通过字符串索引来连接每个字符。记住，字符串的第一个字符的索引是0，而不是1。我们可以像这样将这个字符移到字符串的末尾：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is rather unwieldy and is specific to having exactly five songs. We can
    use string slicing to write more general and less error-prone code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法比较繁琐，而且仅适用于正好有五首歌的情况。我们可以使用字符串切片来编写更加通用且不易出错的代码。
- en: '*Slicing* is a Python feature that lets us refer to a substring of a string.
    (In fact, it works on any sequence, as we’ll see later in the book.) It takes
    two indices: the index where we want to start, and the index one to the right
    of where we want to end. If we use indices 4 and 8, for example, then we get the
    characters at indices 4, 5, 6, and 7\. Slicing uses square brackets, with a colon
    between the two indices:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片*是Python的一项特性，允许我们引用字符串的子字符串。（实际上，它也适用于任何序列类型，稍后在本书中我们将看到。）切片需要两个索引：开始的索引和结束索引右边的一个位置。如果我们使用索引4和8，举例来说，我们将获得索引4、5、6和7的字符。切片使用方括号，两个索引之间用冒号分隔：'
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The slicing doesn’t change what `s` refers to. We can make `s` refer to the
    slice by using an assignment statement:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作不会改变`s`所指向的内容。我们可以通过赋值语句使`s`指向切片：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s easy to make an off-by-one error here and think that `s[4:8]` includes
    the character at index 8\. But it doesn’t, just like `range(4, 8)` doesn’t include
    the `8`. So while this behavior may be a little counterintuitive, it’s applied
    consistently in both `range` and slicing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里很容易犯下越界错误，以为`s[4:8]`包含了索引8处的字符。但实际上并不包括，就像`range(4, 8)`不包含`8`一样。所以虽然这个行为可能有点反直觉，但它在`range`和切片中是一致应用的。
- en: 'We must always include the colon when performing string slicing, but the start
    and end indices are optional. If we leave off the start index, Python starts slicing
    at index 0:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行字符串切片时，我们必须始终包括冒号，但起始和结束索引是可选的。如果我们省略起始索引，Python 会从索引 0 开始切片：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we leave off the end index, Python slices until the end of the string:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略结束索引，Python 会一直切片到字符串的末尾：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And leaving out both indices? That gives us a slice consisting of the entire
    string:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略两个索引呢？这会给我们一个包含整个字符串的切片：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can even use negative indices in a slice. Here’s an example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在切片中使用负索引。这里有一个示例：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The start index refers to the fourth character from the right, which is `'h'`,
    and the end index is omitted. We therefore get a slice from the `'h'` to the end
    of the string.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 起始索引指的是从右侧数第四个字符，即 `'h'`，并且省略了结束索引。因此，我们得到一个从 `'h'` 到字符串末尾的切片。
- en: 'Unlike indexing, slicing never produces an index error. If we use indices that
    are outside of the string, Python slices to the appropriate end of the string:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与索引不同，切片永远不会引发索引错误。如果我们使用超出字符串范围的索引，Python 会切片到字符串的适当末端：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll use string slicing to implement the behaviors of buttons `1`, `2`, and
    `3`. Here’s what the code looks like for button `1`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字符串切片来实现按钮 `1`、`2` 和 `3` 的行为。以下是按钮 `1` 的代码：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The slice gives us the entire string except for the character at index 0\. (There’s
    nothing specific to a string of length 5 here; this code would work on a nonempty
    string of any length.) Appending that missing character results in the first song
    moving to the end of the playlist. The slicing for the other buttons is similar;
    you’ll see that code next.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该切片给我们除了索引 0 处的字符以外的整个字符串。（这里没有特定于长度为 5 的字符串的内容；这段代码适用于任何非空字符串。）如果补上丢失的字符，第一个歌曲就会移到播放列表的末尾。其他按钮的切片类似；你将在下一段代码中看到。
- en: '**CONCEPT CHECK**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A. `st V`
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: A. `st V`
- en: B. `ost V`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: B. `ost V`
- en: C. `iking`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: C. `iking`
- en: D. `st Vi`
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: D. `st Vi`
- en: E. `Viking`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: E. `Viking`
- en: 'Answer: A. The character at index `2` is the `''s''` in `''Lost''`. The character
    at index `-6` is the first `''i''` in `''Vikings''`. Since we go from index `2`
    up to but not including index `-6`, we get the slice `''st V''`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 索引 `2` 处的字符是 `'Lost'` 中的 `'s'`。索引 `-6` 处的字符是 `'Vikings'` 中的第一个 `'i'`。由于我们从索引
    `2` 开始，到但不包括索引 `-6`，所以我们得到切片 `'st V'`。
- en: '**CONCEPT CHECK**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Which password gets us out of the following loop?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个密码可以让我们退出以下循环？
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A. `xyz`
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: A. `xyz`
- en: B. `xyabc`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: B. `xyabc`
- en: C. `abcxy`
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: C. `abcxy`
- en: D. More than one of the above passwords get us out of the loop
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上多个密码可以让我们退出循环
- en: E. None; the loop never executes and no passwords are obtained
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: E. 无；循环从未执行，且没有获得任何密码
- en: 'Answer: B. The `while` loop terminates when `valid` is `True` (because then
    `not valid` is `False`). The only one of the given passwords whose length is 5
    and whose first two characters are `''xy''` is `xyabc`. This is therefore the
    only given password that sets `valid` to `True` and ends the loop.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. `while` 循环在 `valid` 为 `True` 时终止（因为此时 `not valid` 为 `False`）。给定的密码中，唯一一个长度为
    5 且前两个字符为 `'xy'` 的密码是 `xyabc`。因此，这个密码是唯一一个将 `valid` 设置为 `True` 并结束循环的密码。
- en: Solving the Problem
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Now that we have some practice using `while` loops to loop as long as there
    are more buttons to handle, and using slicing for string manipulation, we’re ready
    to solve Song Playlist. See [Listing 4-3](ch04.xhtml#ch04ex03) for the code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经练习了如何使用 `while` 循环来处理多个按钮，并利用切片进行字符串操作，接下来我们准备解决歌曲播放列表问题。请参见 [清单 4-3](ch04.xhtml#ch04ex03)
    了解代码。
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 4-3: Solving Song Playlist*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：解决歌曲播放列表*'
- en: The `while` loop continues as long as button `4` hasn’t been pressed ❶. On each
    iteration of the `while` loop, we read the button number and then read the number
    of times that this button was pressed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会一直继续，直到按钮 `4` 被按下 ❶。在每次执行 `while` 循环时，我们读取按钮编号，然后读取该按钮被按下的次数。'
- en: Now, nested in the outer `while` loop, we need to loop once per button press.
    Keep all of the loop types in mind as you decide which to use. Here, a range `for`
    loop is the best choice ❷, since it’s the easiest way to loop exactly the number
    of times we specify.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在外部的 `while` 循环中，我们需要在每次按钮按下时执行一次循环。在选择使用哪种循环时，请记住所有循环类型。这里，使用 `for` 循环范围是最好的选择
    ❷，因为它是以我们指定的次数精确循环的最简单方法。
- en: The behavior inside the range `for` loop depends on which button is pressed.
    We therefore use an `if` statement to check the button number and modify the playlist
    accordingly. If button `1` is pressed, we use slicing to move the first song to
    the end of the playlist ❸. If button `2` is pressed, we use slicing to move the
    last song to the beginning of the playlist ❹. To do that, we start with the character
    at the right end of the string and then use slicing to append all other characters.
    For button `3`, we need to modify the playlist so that the first two songs swap
    positions. We build a new string with the character at index `1`, then the character
    at index `0`, and then all of the characters starting at index `2` ❺.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环中的行为取决于按下的按钮。我们因此使用 `if` 语句来检查按钮号码并相应地修改播放列表。如果按下的是按钮 `1`，我们使用切片将第一首歌移到播放列表的末尾
    ❸。如果按下的是按钮 `2`，我们使用切片将最后一首歌移到播放列表的开头 ❹。为了做到这一点，我们从字符串的右端开始，然后使用切片将所有其他字符追加上去。对于按钮
    `3`，我们需要修改播放列表，使得前两首歌交换位置。我们构建一个新的字符串，其中包含索引 `1` 处的字符，然后是索引 `0` 处的字符，再加上从索引 `2`
    开始的所有字符 ❺。'
- en: Once we escape the `while` loop, we need to output the songs, with a space between
    each pair of songs. We can’t just output `songs`, because that doesn’t have spaces.
    Instead, we build an output string that has the appropriate spaces. To do that,
    we start with the empty string ❻ and then use a `for` loop to concatenate each
    song and a space. One small annoyance is that this adds a space to the end of
    the string, after the last song, and we don’t want that. We therefore use slicing
    to remove that final space character ❼.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们跳出 `while` 循环，我们需要输出歌曲，每对歌曲之间用一个空格分隔。我们不能仅仅输出 `songs`，因为那没有空格。相反，我们构建一个输出字符串，里面有适当的空格。为了做到这一点，我们从空字符串
    ❻ 开始，然后使用 `for` 循环将每首歌和一个空格连接起来。有一个小麻烦是，这会在字符串的末尾添加一个空格，在最后一首歌后面，而我们不想要那个空格。因此，我们使用切片来去掉最后的空格字符
    ❼。
- en: You’re now ready to submit to the judge.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在准备好提交给评委了。
- en: Before continuing, you might like to try solving exercise 3 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想试着解决“章节练习”中[第99页](ch04.xhtml#ch04lev1sec17)的第3题。
- en: 'Problem #10: Secret Sentence'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #10：秘密句子'
- en: Even if we have a string and even if we know how much input will be provided,
    a `while` loop may still be the required type of loop. This problem demonstrates
    why this can be the case.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们有一个字符串，甚至知道将提供多少输入，`while` 循环仍然可能是所需的循环类型。这个问题演示了为什么会是这种情况。
- en: This is DMOJ problem `coci08c3p2`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`coci08c3p2`。
- en: The Challenge
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Luka is writing a secret sentence in class. He doesn’t want the teacher to be
    able to read it, so instead of writing down the original sentence, he writes down
    an encoded version. After each vowel in the sentence (*a*, *e*, *i*, *o*, or *u*),
    he adds the letter *p* and that vowel again. For example, rather than write down
    the sentence *i like you*, he would write *ipi lipikepe yopoupu*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 卢卡在课堂上写下了一句秘密句子。他不希望老师能读懂它，因此他没有写下原始句子，而是写下了一个编码版本。在句子中的每个元音字母（*a*, *e*, *i*,
    *o*, 或 *u*）后面，他都会加上字母 *p*，然后再加上那个元音字母。例如，他不会写下句子 *i like you*，而是写成 *ipi lipikepe
    yopoupu*。
- en: The teacher acquires Luka’s encoded sentence. Recover Luka’s original sentence
    for the teacher.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 老师获得了卢卡的编码句子。为老师恢复卢卡的原始句子。
- en: Input
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input is one line of text, Luka’s encoded sentence. It consists of lowercase
    letters and spaces. There is exactly one space between each pair of words. The
    maximum length of the line is 100 characters.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一行文本，卢卡的编码句子。它由小写字母和空格组成。每对单词之间有且只有一个空格。该行的最大长度为100个字符。
- en: Output
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output Luka’s original sentence.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出卢卡的原始句子。
- en: Another Limitation of for loops
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for` 循环的另一个限制'
- en: In [Chapter 3](ch03.xhtml#ch03), we learned how `for` loops can be used to process
    strings. A `for` loop plods through the string, from beginning to end, one character
    at a time. In many cases, that’s precisely what we want. In Three Cups, for example,
    we needed to look at each swap from left to right, so we used a `for` loop over
    the string of swaps.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml#ch03)中，我们学习了如何使用 `for` 循环处理字符串。`for` 循环逐个字符地遍历字符串，从头到尾。在许多情况下，这正是我们想要的。例如，在“三杯”问题中，我们需要从左到右查看每次交换，所以我们在交换字符串上使用了
    `for` 循环。
- en: 'In other cases, that’s too restrictive, and a range `for` loop may be more
    appropriate. A range `for` loop gives us access to indices rather than characters.
    It also allows us to skip through a sequence with whatever step size we choose.
    For example, we can use a range `for` loop to visit every third character of a
    string:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，这样的限制太严苛了，`for` 循环可能会更合适。`for` 循环让我们能够访问索引，而不是字符。它还允许我们根据需要选择步长来跳跃遍历序列。例如，我们可以使用
    `for` 循环访问字符串中的每三个字符：
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can also use a range `for` loop to process a string from right to left instead
    of left to right:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `for` 循环从右到左处理字符串，而不是从左到右：
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All of this assumes that we want to step by a fixed amount on each iteration.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都假设我们希望在每次迭代中步长固定。
- en: What if sometimes we want to move one character to the right and other times
    we want to move three characters to the right? That’s not at all farfetched. In
    fact, if we could do that, then we’d be well on our way to solving Secret Sentence.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有时我们希望向右移动一个字符，而其他时候我们希望向右移动三个字符呢？这完全不是不可能的。事实上，如果我们能做到这一点，那么我们就能很接近解决“秘密句子”问题了。
- en: 'To see why, consider this test case:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下测试案例：
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Imagine that we’re reconstructing Luka’s original sentence by copying characters
    to it. The first character in the encoded sentence is the vowel `i`. This is the
    first character of Luka’s original sentence, too. Based on how Luka encodes sentences,
    we know that the next two characters will be `p` and `i`. We don’t want to include
    those in Luka’s original sentence, so we need to skip over them. That is, after
    processing index 0, we want to jump to index 3.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在通过复制字符来重构 Luka 的原始句子。编码句子的第一个字符是元音字母 `i`。这也是 Luka 原始句子的第一个字符。根据 Luka 编码句子的方式，我们知道接下来的两个字符将是
    `p` 和 `i`。我们不希望将它们包含在 Luka 的原始句子中，所以我们需要跳过它们。也就是说，在处理完索引 0 后，我们要跳到索引 3。
- en: Index 3 is a space character. Since it isn’t a vowel, we copy this character
    as is to Luka’s original sentence and then move to index 4\. Index 4 is `l`, another
    nonvowel, so we copy that too and move to index 5\. Here at index 5 we have a
    vowel; after copying it, we want to jump to index 8.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 索引 3 是一个空格字符。由于它不是元音字母，我们将这个字符原样复制到 Luka 的原始句子中，然后跳到索引 4。索引 4 是 `l`，另一个非元音字母，所以我们也复制它并跳到索引
    5。这里在索引 5 是一个元音字母；复制它后，我们要跳到索引 8。
- en: What’s the step size here? Sometimes we jump by three, but not always. And sometimes
    we jump by one, but not always. It’s a mix of threes and ones. `for` loops are
    not designed for this kind of processing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的步长是多少？有时我们跳跃三个字符，但并不总是如此。有时我们跳跃一个字符，但也不总是如此。它是三和一的混合。`for` 循环并不适合这种处理方式。
- en: With a `while` loop, we can zip around a string however we please, unencumbered
    by predefined step sizes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `while` 循环，我们可以随心所欲地跳跃遍历字符串，不受预定义步长的限制。
- en: while Loops Through Indices
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while` 循环遍历索引'
- en: 'Writing a `while` loop that loops through string indices isn’t any different
    from writing any other kind of `while` loop. We just need to incorporate the string’s
    length. Here’s how we can loop through each character of a string from left to
    right:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个 `while` 循环来遍历字符串索引，与写任何其他类型的 `while` 循环没有区别。我们只需要结合字符串的长度。以下是我们如何从左到右遍历字符串的每个字符：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The variable `i` allows us to access each character of the string. It begins
    at `0` and increases by one each time through the loop.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `i` 允许我们访问字符串的每个字符。它从 `0` 开始，每次循环增加 1。
- en: 'I used `<` in the loop’s Boolean expression ❶ to continue as long as we haven’t
    reached the length of the string. Had I used `<=` instead of `<`, we’d have received
    an `IndexError`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我在循环的布尔表达式 ❶ 中使用了 `<`，以便在没有达到字符串长度时继续。如果我使用的是 `<=` 而不是 `<`，我们会收到一个 `IndexError`
    错误：
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The length of the string is 6\. We get this error because the loop tries to
    access `s[6]`, which is not a valid index in the string.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的长度是 6。我们之所以会遇到这个错误，是因为循环试图访问 `s[6]`，而这是一个无效的索引。
- en: 'Want to loop through the string jumping by three characters at a time instead
    of one? No problem; just increase `i` by `3` instead of `1`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 想要每次跳跃三个字符而不是一个字符吗？没问题；只需将 `i` 增加 `3` 而不是 `1`：
- en: '[PRE47]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also go from right to left instead of left to right. We have to start
    at `len(s) - 1` instead of `0`, and we have to decrease `i` on each iteration
    rather than increase it. We also have to change the loop’s Boolean expression
    to detect when we’re at the beginning of the string rather than the end. Here’s
    how we go from right to left, looping through each character:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从右往左遍历，而不是从左往右。我们必须从`len(s) - 1`开始，而不是从`0`开始，并且在每次迭代时减少`i`，而不是增加它。我们还必须改变循环的布尔表达式，以便检测到我们到达字符串的开头，而不是结尾。以下是如何从右往左遍历，每次处理一个字符：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A final use case for a `while` loop on a string: stopping at the first index
    that meets some criterion.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串上使用`while`循环的一个最终应用：在满足某些条件时停止在第一个索引处。
- en: 'The strategy is to use the Boolean `and` operator to continue while there are
    more characters to check and we haven’t yet met our criterion. For example, here
    is how we can find the index of the first `''y''` in a string:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略是使用布尔`and`运算符，在仍有字符需要检查并且我们还没有满足条件的情况下继续循环。例如，下面是如何找到字符串中第一个`'y'`的索引：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If there’s no `''y''` anywhere in the string, the loop stops when `i` equals
    the string length:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串中没有`'y'`，循环会在`i`等于字符串长度时停止：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When `i` refers to `6`, the first operand of `and` is `False`, so the loop terminates.
    You might wonder why the second operand of `and` doesn’t cause an error here,
    since index `6` is not a valid index in the string. The reason is that the Boolean
    operators use *short-circuiting evaluation*, which means that they stop evaluating
    their operands if the result of the operator is already known. For `and`, if the
    first operand is `False`, then we know that, no matter what the second operand
    is, `and` will return `False`; Python therefore doesn’t evaluate the second operand.
    Similarly, for `or`, if the first operand is `True`, then `or` is guaranteed to
    return `True`, so Python doesn’t evaluate the second operand.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当`i`为`6`时，`and`的第一个操作数为`False`，因此循环终止。你可能会想，为什么`and`的第二个操作数不会导致错误，因为索引`6`在字符串中不是一个有效的索引。原因是布尔运算符使用*短路求值*，这意味着它们在结果已经确定时会停止评估其操作数。对于`and`，如果第一个操作数为`False`，我们就知道无论第二个操作数是什么，`and`都会返回`False`；因此，Python不会评估第二个操作数。同样地，对于`or`，如果第一个操作数为`True`，那么`or`保证返回`True`，因此Python不会评估第二个操作数。
- en: Solving the Problem
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Now we know how to use a `while` loop to loop through a string.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用`while`循环来遍历一个字符串。
- en: For Secret Sentence, we need to do something different depending on whether
    we’re looking at a vowel or a nonvowel. If we’re looking at a vowel, then we need
    to copy the character and jump ahead by three characters (to skip over the `p`
    and the second occurrence of this vowel). If we’re looking at a nonvowel, then
    we need to copy the character and move to the next character. So, we always copy
    the current character but then move by three or one based on whether the current
    character is a vowel. We can use an `if` statement inside the `while` loop to
    make this decision for each character that we see.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密句（Secret Sentence），我们需要根据我们查看的是元音（vowel）还是非元音（nonvowel）来采取不同的处理方式。如果我们查看的是元音，那么我们需要复制该字符，并跳过三个字符（跳过`p`和该元音的第二次出现）。如果我们查看的是非元音，那么我们需要复制该字符并移动到下一个字符。因此，我们总是复制当前字符，然后根据当前字符是否为元音，跳过三个字符或一个字符。我们可以在`while`循环中使用`if`语句来为我们看到的每个字符做出决定。
- en: A solution for Secret Sentence is in [Listing 4-4](ch04.xhtml#ch04ex04).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 密句的解决方案在[清单 4-4](ch04.xhtml#ch04ex04)中。
- en: '[PRE51]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 4-4: Solving Secret Sentence*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：解决密句问题*'
- en: The `result` variable ❶ is used to build the original sentence, one character
    at a time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`变量❶用于逐个字符地构建原始句子。'
- en: The `while` loop’s Boolean expression is the standard one for looping until
    we reach the end of a string ❷. In that loop, we first concatenate the current
    character to the end of the result. Then we check whether the current character
    is a vowel ❸. Recall from “Relational Operators” in [Chapter 2](ch02.xhtml#ch02)
    that the `in` operator can be used to check whether the first string occurs in
    the second. If the current character is found in the string of vowels, we jump
    ahead by three characters; if not, we move to the next character.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的布尔表达式是用于遍历字符串直到到达末尾的标准表达式❷。在这个循环中，我们首先将当前字符连接到结果的末尾。然后，我们检查当前字符是否为元音❸。请回顾[第2章](ch02.xhtml#ch02)中的“关系运算符”部分，`in`运算符可以用来检查第一个字符串是否出现在第二个字符串中。如果当前字符出现在元音的字符串中，我们就跳过三个字符；如果没有，我们就移动到下一个字符。'
- en: Once the loop terminates, we have gone through the entire encoded sentence and
    copied the correct characters into `result`. The last thing to do is therefore
    to output this variable.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环终止，我们已经遍历了整个编码后的句子，并将正确的字符复制到`result`中。因此，最后要做的就是输出这个变量。
- en: You’re ready to submit our code to the judge. Grepeapat wopork!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好将我们的代码提交给评审了。Grepeapat wopork!
- en: break and continue
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: break 和 continue
- en: 'In this section, I’ll show you two other loop keywords that Python supports:
    `break` and `continue`. It’s my experience that introducing these keywords leads
    learners to overuse them to the detriment of the clarity of their loops, so I’ve
    decided to avoid them elsewhere in the book. Nonetheless, they are occasionally
    useful, and you’re likely to see them in other Python code, so let’s have a brief
    discussion.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我将向你展示 Python 支持的另外两个循环关键字：`break`和`continue`。根据我的经验，引入这些关键字会导致学习者过度使用它们，从而影响循环的清晰度，因此我决定在书中的其他部分避免使用它们。尽管如此，它们偶尔还是有用的，你很可能会在其他
    Python 代码中看到它们，所以让我们简要讨论一下。
- en: break
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: break
- en: The `break` keyword immediately terminates a loop, no questions asked.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`关键字会立即终止一个循环，不做任何询问。'
- en: Back when we solved Song Playlist, we used a `while` loop that looped while
    the button was not `4`. We could also solve that problem using `break`; see [Listing
    4-5](ch04.xhtml#ch04ex05) for the code.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解决歌曲播放列表问题时，我们使用了一个`while`循环，条件是按钮没有按下`4`。我们也可以使用`break`来解决这个问题；请参见[列表 4-5](ch04.xhtml#ch04ex05)中的代码。
- en: '[PRE52]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 4-5: Solving Song Playlist using* break'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-5：使用* break *解决歌曲播放列表问题*'
- en: 'The loop’s Boolean expression ❶ looks suspicious: `True` is always `True`,
    so at first glance it seems that this loop never terminates. (That’s the downside
    to `break`. We can’t just look at the Boolean expression to understand what must
    happen for the loop to terminate.) But it can terminate, because of our use of
    `break`. If button `4` is pressed ❷, then we hit a `break` ❸, which terminates
    the loop.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的布尔表达式❶看起来很可疑：`True`总是`True`，所以乍一看似乎这个循环永远不会终止。（这就是`break`的弊端。我们不能仅通过布尔表达式来理解循环何时终止。）但是它是可以终止的，因为我们使用了`break`。如果按钮`4`被按下❷，那么我们会遇到一个`break`❸，从而终止循环。
- en: 'Let’s see one more example of using `break`. In “while Loops Through Indices”
    in this chapter, we wrote code to find the index of the first `''y''` in a string.
    Here’s how that looks using `break`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个使用`break`的例子。在本章的“`while`循环通过索引”中，我们编写了代码来查找字符串中第一个`'y'`的索引。以下是使用`break`的实现：
- en: '[PRE53]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Again, notice that the loop’s Boolean expression is misleading: it suggests
    that the loop always runs until the end of the string, but further scrutiny reveals
    that a `break` is lurking and can influence termination.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，循环的布尔表达式具有误导性：它暗示循环总是一直运行直到字符串的末尾，但仔细审查后会发现有一个`break`存在，它可以影响终止条件。
- en: 'A `break` terminates only its own loop, not any outer loops. Here’s an example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`只会终止它自身的循环，而不会影响外部的循环。这里有一个例子：'
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Notice how the `break` ❶ cuts the `j` loop short. But it doesn’t affect the
    `i` loop: there are three iterations of that loop, exactly as there would be without
    the `break` ❶.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`break`❶是如何缩短`j`循环的。但它不会影响`i`循环：该循环有三个迭代，正如没有`break`❶时的情况一样。
- en: continue
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: continue
- en: The `continue` keyword ends the current iteration of the loop without running
    any more of its code. Unlike `break`, it does not end the loop altogether. If
    the loop condition is `True`, then further iterations of the loop occur.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`关键字结束当前的循环迭代，而不会运行更多的代码。与`break`不同，它不会终止整个循环。如果循环条件为`True`，那么循环将继续进行下一次迭代。'
- en: 'Here’s an example that uses `continue` to print each vowel and its index in
    a string:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`continue`打印每个元音字母及其在字符串中的索引的例子：
- en: '[PRE55]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the current character is not a vowel ❶, then we don’t want to print it. So,
    we increase `i` by `1` to take us past this character and then use `continue`
    ❷ to end the current iteration. If we get below the `if` statement ❸, then it
    must mean that we’re looking at a vowel (otherwise `continue` would have prevented
    us from getting here). We therefore output that character and increase `i` by
    `1` to take us past this character.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前字符不是元音字母❶，那么我们不想打印它。因此，我们将`i`增加`1`，跳过这个字符，然后使用`continue`❷结束当前的迭代。如果我们进入`if`语句之后❸，那就意味着我们看到的是元音字母（否则`continue`会阻止我们到达这里）。因此，我们输出这个字符，并将`i`增加`1`，跳过这个字符。
- en: 'The `continue` keyword is enticing because it seems to give us a way to get
    us out of an iteration that we don’t want to be in. “This isn’t a vowel. I’m out
    of here!” But an `if` statement can also be used to obtain the same behavior,
    and the logic is often clearer:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 关键字具有诱惑力，因为它看似提供了一种方法，让我们退出我们不想参与的迭代。“这不是元音，我走！”但也可以使用 `if` 语句实现相同的行为，并且逻辑通常更清晰：'
- en: '[PRE56]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Rather than skip the iteration when the current character is not a vowel, the
    `if` statement processes it when it *is* a vowel.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前字符不是元音时，`if` 语句会在字符 *是* 元音时进行处理，而不是跳过该次迭代。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The unifying feature of the problems in this chapter is that we don’t know in
    advance how many iterations of a loop will be required.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本章问题的共同特点是我们事先不知道循环需要迭代多少次。
- en: '**Slot Machines** The number of iterations depends on the initial number of
    quarters and the payouts of the slot machines.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**老虎机** 迭代次数取决于初始的硬币数量和老虎机的支付比例。'
- en: '**Song Playlist** The number of iterations depends on how many buttons were
    pressed.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**歌曲播放列表** 迭代次数取决于按下了多少个按钮。'
- en: '**Secret Sentence** The number of iterations, and what to do on each iteration,
    depends on where vowels are located in a string.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**秘密句子** 迭代次数及每次迭代要做的操作，取决于元音在字符串中的位置。'
- en: When the number of iterations is unknown, we turn to the `while` loop, which
    runs as long as needed. Using a `while` loop is more error-prone than code that
    uses a `for` loop. It’s also more flexible, as we are freed from the `for` loop
    constraint of systematically looping through a sequence.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代次数未知时，我们使用 `while` 循环，它会根据需要执行。使用 `while` 循环比使用 `for` 循环的代码更容易出错，但它也更灵活，因为我们不再受制于
    `for` 循环必须依次遍历序列的限制。
- en: 'In the next chapter, we’ll learn about lists, which allow us to store large
    amounts of numeric or string data. And how do you suppose we’ll process all of
    that data? Yes: loops! Practice the following exercises to hone your loop skills.
    You’ll be using them a lot when we solve problems using lists.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习列表，它可以让我们存储大量的数字或字符串数据。你猜我们如何处理这些数据呢？没错：使用循环！通过做以下练习来锻炼你的循环技能。在用列表解决问题时，你会频繁用到它们。
- en: Chapter Exercises
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: 'You now have three types of loops at your disposal: `for` loops, range `for`
    loops, and `while` loops. Part of the challenge of solving problems using loops
    is knowing which loop to use! For each of the following exercises, experiment
    with using different types of loops to arrive at the solution that you like best.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用三种类型的循环：`for` 循环、范围 `for` 循环和 `while` 循环。解决问题时的一个挑战是知道使用哪种循环！在接下来的练习中，试着使用不同类型的循环，找到你最喜欢的解决方案。
- en: 1.  DMOJ problem `ccc20j2`, Epidemiology
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 1. DMOJ 问题 `ccc20j2`，流行病学
- en: DMOJ problem `coci08c1p2`, Ptice
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci08c1p2`，Ptice
- en: DMOJ problem `ccc02j2`, AmeriCanadian
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc02j2`，美加之战
- en: DMOJ problem `ecoo13r1p1`, Take a Number
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ecoo13r1p1`，取一个数字
- en: DMOJ problem `ecoo15r1p1`, When You Eat Your Smarties
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ecoo15r1p1`，当你吃掉你的巧克力豆时
- en: DMOJ problem `ccc19j3`, Cold Compress
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc19j3`，冷敷
- en: Notes
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Slot Machines is originally from the 2000 Canadian Computing Competition, Junior/Senior
    Level. Song Playlist is originally from the 2008 Canadian Computing Competition,
    Junior Level. Secret Sentence is originally from the 2008/2009 Croatian Open Competition
    in Informatics, Contest 3.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎机最初来自2000年加拿大计算机竞赛，初级/高级水平。歌曲播放列表最初来自2008年加拿大计算机竞赛，初级水平。秘密句子最初来自2008/2009年克罗地亚信息学公开赛，第3场比赛。
