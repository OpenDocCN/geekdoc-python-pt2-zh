- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: 'REPEATING CODE: INDEFINITE LOOPS'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码：无限循环
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: The for loops and range for loops that you learned in [Chapter 3](ch03.xhtml#ch03)
    are convenient for looping through a string or range of indices. But what do we
    do when we have no string or when the indices do not follow a fixed pattern? We
    use a while loop, the topic of this chapter. while loops are more general than
    for loops and can handle situations that a for loop cannot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第3章](ch03.xhtml#ch03)中学习的for循环和range循环非常适合用来遍历字符串或索引范围。但是，当我们没有字符串或者索引不遵循固定模式时该怎么办呢？我们使用while循环，这是本章的主题。while循环比for循环更为通用，可以处理for循环无法应对的情况。
- en: 'We’ll solve three problems where for loops fall short: determining the number
    of times slot machines can be played, organizing a song playlist until the user
    wants to stop, and decoding an encoded message.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决三个for循环无法胜任的问题：确定老虎机可以玩多少次、组织播放列表直到用户希望停止以及解码一个编码的消息。
- en: 'Problem #8: Slot Machines'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #8：老虎机'
- en: How many times can slot machines be played before we run out of money? This
    is a subtle question that depends not only on our starting money but also on the
    pattern of winnings as we play. We’ll see that we need a while loop, not a for
    loop, for this situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有钱的情况下，老虎机可以玩多少次？这是一个微妙的问题，不仅依赖于我们最初的资金，还依赖于玩游戏时的中奖模式。我们会发现，这种情况需要使用while循环，而不是for循环。
- en: This is DMOJ problem ccc00s1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题ccc00s1。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Martha goes to a casino and brings *n* quarters. The casino has three slot machines,
    and she plays them in order until she has no quarters left. That is, she plays
    the first slot machine, then the second, then the third, then back to the first,
    then the second, and so on. Each play costs one quarter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎去赌场并带来了*n*个硬币。赌场有三台老虎机，她按顺序玩它们，直到没有硬币为止。也就是说，她先玩第一台老虎机，再玩第二台，再玩第三台，然后再回到第一台，依此类推。每次玩需要一个硬币。
- en: 'The slot machines operate according to the following rules:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎机的运行规则如下：
- en: The first slot machine pays 30 quarters every 35th time it is played.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一台老虎机每玩第35次支付30个硬币。
- en: The second slot machine pays 60 quarters every 100th time it is played.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二台老虎机每玩第100次支付60个硬币。
- en: The third slot machine pays 9 quarters every 10th time it is played.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三台老虎机每玩第10次会支付9个硬币。
- en: No other plays pay anything.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他游戏没有任何奖励。
- en: Determine the number of times Martha plays before she has no quarters left.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确定玛莎在没有硬币时玩多少次。
- en: Input
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of four lines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由四行组成。
- en: The first line contains an integer *n*, the number of quarters that Martha brings
    to the casino. *n* is between 1 and 1,000.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含一个整数*n*，即玛莎带到赌场的硬币数。*n*的范围是1到1000之间。
- en: The second line contains an integer indicating the number of times that the
    first slot machine has been played since it last paid. These plays occurred prior
    to Martha arriving, and Martha’s plays continue from there. For example, suppose
    that the first slot machine has been played 34 times since it last paid. Then,
    Martha will win 30 quarters the first time she plays it.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含一个整数，表示自上次支付以来第一台老虎机已被玩过的次数。这些游戏发生在玛莎到达之前，玛莎的游戏从这里开始。例如，假设第一台老虎机自上次支付以来已玩了34次。那么，玛莎第一次玩时将赢得30个硬币。
- en: The third line contains an integer indicating the number of times that the second
    slot machine has been played since it last paid.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行包含一个整数，表示自上次支付以来第二台老虎机已被玩过的次数。
- en: The fourth line contains an integer indicating the number of times that the
    third slot machine has been played since it last paid.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行包含一个整数，表示自上次支付以来第三台老虎机已被玩过的次数。
- en: Output
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'Output the following sentence, where x is the number of times Martha plays
    before she has no quarters left:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以下句子，其中 x 是玛莎在没有硬币时玩多少次：
- en: Martha plays x times before going broke.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎玩x次后破产。
- en: Exploring a Test Case
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索测试用例
- en: 'Let’s run through an example, just to make sure that everything in this problem
    is clear. Here’s the test case we’ll use:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示，确保这个问题中的每个细节都清楚明了。这里是我们使用的测试用例：
- en: '7'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '28'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '0'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'To carefully trace Martha’s plays, we’ll need to keep track of six pieces of
    information. It’s convenient to use a table to do this, since a row can tell us
    the state after each play. Here are our columns:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仔细追踪玛莎的游戏，我们需要跟踪六个信息点。使用表格来记录这些信息很方便，因为每一行可以告诉我们每次游戏后的状态。这里是我们的列：
- en: '**Plays** the number of slot machines that Martha has played'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩** 玛莎已经玩过的老虎机数量'
- en: '**Quarters** the number of quarters that Martha has'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**代币** 玛莎拥有的代币数量'
- en: '**Next play** the slot machine that Martha would play next'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一个游戏** 玛莎接下来要玩的老虎机'
- en: '**First plays** the number of times that the first machine has been played
    since it last paid'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一次游戏** 自上次支付以来，第一个老虎机已经被玩了多少次'
- en: '**Second plays** the number of times that the second machine has been played
    since it last paid'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二次游戏** 自上次支付以来，第二个老虎机已经被玩了多少次'
- en: '**Third plays** the number of times that the third machine has been played
    since it last paid'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三次游戏** 自上次支付以来，第三个老虎机已经被玩了多少次'
- en: 'To start, Martha has played zero slot machines, she has seven quarters, and
    she’ll next play the first slot machine. The first slot machine has been played
    28 times since it last paid, the second has been played 0 times since it last
    paid, and the third has been played 8 times since it last paid. Our state looks
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，玛莎已经玩过零次老虎机，她有七个代币，接下来她会玩第一个老虎机。自上次支付以来，第一个老虎机已经被玩了28次，第二个老虎机已经被玩了0次，第三个老虎机已经被玩了8次。我们的状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 7 | first | 28 | 0 | 8 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 7 | 第一个 | 28 | 0 | 8 |'
- en: 'Martha starts by playing the first slot machine. That costs one quarter. Because
    this is the 29th time this machine has been played since it last paid, not the
    35th, the slot machine pays Martha nothing. Martha will play the second slot machine
    next. This is our new state:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎从玩第一个老虎机开始。那需要一个代币。因为这是自上次支付以来，这台机器被玩过的第29次，而不是第35次，所以老虎机不会支付玛莎任何奖励。玛莎接下来会玩第二个老虎机。我们的新状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 6 | second | 29 | 0 | 8 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 6 | 第二次 | 29 | 0 | 8 |'
- en: 'Playing the second slot machine costs one quarter. Because this is the first
    time this machine has been played since it last paid, not the 100th, the slot
    machine pays Martha nothing. Martha will play the third slot machine next. This
    is our new state:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 玩第二个老虎机需要一个代币。因为这是自上次支付以来，这台机器被玩过的第一次，而不是第100次，所以老虎机不会支付玛莎任何奖励。玛莎接下来会玩第三个老虎机。我们的新状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 2 | 5 | third | 29 | 1 | 8 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 5 | 第三次 | 29 | 1 | 8 |'
- en: 'Playing the third slot machine costs one quarter. Because this is the 9th time
    this machine has been played since it last paid, not the 10th, the slot machine
    pays Martha nothing. Next, Martha will cycle back to the first slot machine. This
    is our new state:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 玩第三个老虎机需要一个代币。因为这是自上次支付以来，这台机器被玩过的第九次，而不是第十次，所以老虎机不会支付玛莎任何奖励。接下来，玛莎将回到第一个老虎机。我们新的状态如下：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 3 | 4 | first | 29 | 1 | 9 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | 第一个 | 29 | 1 | 9 |'
- en: 'Now Martha plays the first slot machine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玛莎玩第一个老虎机：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 4 | 3 | second | 30 | 1 | 9 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | second | 30 | 1 | 9 |'
- en: 'Then Martha plays the second slot machine:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，玛莎玩第二个老虎机：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **玩** | **代币** | **下一个游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 5 | 2 | third | 30 | 2 | 9 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | 第三次 | 30 | 2 | 9 |'
- en: 'Martha is almost out of quarters! But there’s good news coming, because she’s
    next going to play the third slot machine. It has been played nine times since
    it last paid. The next play is therefore its 10th, which pays Martha nine quarters.
    She had two quarters, pays one to play this machine, and then gets paid nine,
    so she’ll have 2 – 1 + 9 = 10 quarters after this play:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 玛莎几乎没有剩余的硬币了！但有好消息，因为接下来她将玩第三台老虎机。自从上次支付以来，它已经进行了九次游戏。因此，下一次游戏是它的第十次，这次将支付玛莎九个硬币。她原本有两个硬币，支付一个来玩这个机器，然后得到了九个硬币，所以她这次游戏后将有
    2 – 1 + 9 = 10 个硬币：
- en: '| **Plays** | **Quarters** | **Next play** | **First plays** | **Second plays**
    | **Third plays** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **播放次数** | **硬币数** | **下一次播放** | **第一次播放** | **第二次播放** | **第三次播放** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 6 | 10 | first | 30 | 2 | 0 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 10 | first | 30 | 2 | 0 |'
- en: Notice that the third slot machine has now been played zero times since it last
    paid.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到第三台老虎机自上次支付以来，已经进行了零次游戏。
- en: That’s six plays so far. I encourage you to keep tracing. You should see that
    Martha never gets paid again and that after 10 more plays (for a total of 16),
    Martha is broke.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止已经进行过六次播放。我鼓励你继续追踪。你应该会看到玛莎再也没有得到报酬，并且在再进行 10 次播放后（总共 16 次），玛莎破产了。
- en: A Limitation of for loops
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环的局限性
- en: In [Chapter 3](ch03.xhtml#ch03), we studied for loops. Standard for loops loop
    through a sequence, such as a string. We certainly have no string in the Slot
    Machines problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml#ch03)中，我们学习了 for 循环。标准的 for 循环会遍历一个序列，比如字符串。在老虎机问题中，我们当然没有字符串。
- en: Range for loops loop through a range of integers and can be used to loop a specified
    number of times. But how many times should we loop for Slot Machines? Ten? Fifty?
    Who knows. It depends on the number of plays that Martha can make before she’s
    out of quarters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Range for 循环遍历一个整数范围，可以用于指定次数的循环。但对于老虎机问题，我们应该循环多少次呢？十次？五十次？谁知道呢。这取决于玛莎能玩多少次，直到她用完硬币。
- en: We have no string and don’t know how many iterations are required. If all we
    had were for loops, we’d be stuck.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有字符串，也不知道需要多少次迭代。如果我们只有 for 循环，我们就会被卡住。
- en: Enter the *while loop*, the most general looping structure that Python offers.
    We can write while loops that have nothing to do with strings or sequences of
    integers. In return for this added flexibility, we’ll need to be a little more
    careful and take a little more responsibility with writing our loops. Let’s dig
    in!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 *while 循环*，这是 Python 提供的最通用的循环结构。我们可以编写与字符串或整数序列无关的 while 循环。为了获得这种额外的灵活性，我们需要更加小心，并对编写循环负更多责任。让我们深入了解一下！
- en: while loops
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: To write a while loop, we use Python’s while statement. A while loop is controlled
    by a Boolean expression. If the Boolean expression is True, then Python executes
    one iteration of the while loop. If the expression is still True, then Python
    executes another iteration of the while loop, and so on, until the Boolean expression
    is False. If the Boolean expression is False at the outset, then the loop does
    not run at all.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个 while 循环，我们使用 Python 的 while 语句。while 循环由一个布尔表达式控制。如果布尔表达式为 True，则 Python
    执行一次 while 循环的迭代。如果表达式仍为 True，则 Python 执行另一次迭代，以此类推，直到布尔表达式为 False。如果布尔表达式在开始时就是
    False，那么循环根本不会执行。
- en: 'while loops are *indefinite loops*: the number of iterations may not be known
    in advance.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环是 *不确定循环*：迭代次数可能事先无法知道。
- en: Using while loops
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 while 循环
- en: 'Let’s start with the following example of a while loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下的 while 循环示例开始：
- en: ❶ >>> num = 0
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> num = 0
- en: '❷ >>> while num < 5:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ >>> while num < 5:'
- en: '...      print(num)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '...      print(num)'
- en: ❸ ...     num = num + 1
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ...      num = num + 1
- en: '...'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: In a for loop, the loop variable is created for us; we don’t have to use an
    assignment statement to create the variable prior to the loop. But in a while
    loop, we get nothing for free. If we need a variable to loop through values in
    a while loop, then we have to create that variable ourselves. We do that here
    by making num refer to 0 prior to the loop ❶.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 循环中，循环变量是由系统自动创建的；我们不需要在循环前使用赋值语句创建变量。但在 while 循环中，我们什么都不免费获得。如果我们需要一个变量来遍历
    while 循环中的值，那么我们必须自己创建这个变量。我们在这里通过在循环之前让 num 等于 0 来实现这一点 ❶。
- en: The while loop itself is controlled by the Boolean expression num < 5 ❷. If
    num < 5 is True, then the code in the loop block will run. Right now, num refers
    to 0, so the Boolean expression is True. We therefore run the loop block, which
    outputs 0 and then increases num to 1 ❸.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: while循环本身由布尔表达式num < 5控制❷。如果num < 5为True，则循环块中的代码将运行。此时，num的值是0，因此布尔表达式为True。因此，我们运行循环块，输出0，并将num增加到1
    ❸。
- en: We jump back to the top of the loop and evaluate the num < 5 Boolean expression
    again. As num refers to 1, the expression is True. We therefore run the loop block
    again, which outputs 1 and then increases num to 2.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳回循环的顶部，再次评估num < 5的布尔表达式。由于num为1，表达式为True。因此，我们再次运行循环块，输出1，并将num增加到2。
- en: 'Back to the top of the loop: is num < 5 still True? It is, because num is only
    2. That kicks off another iteration of the loop, which outputs 2 and increases
    num to 3.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到循环的顶部：num < 5还为True吗？是的，因为num的值是2。这会启动另一次循环迭代，输出2，并将num增加到3。
- en: 'This pattern continues, with two more iterations of the loop: one when num
    refers to 3 and one when num refers to 4. When num refers to 5, the num < 5 Boolean
    expression is finally False, which terminates the loop.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式继续下去，循环会再进行两次迭代：一次当num为3时，另一次当num为4时。当num为5时，num < 5的布尔表达式最终为False，从而终止了循环。
- en: 'It’s important that we remember to increase num ❸. A for loop automatically
    steps our loop variable through the appropriate values. But, again, we get nothing
    for free in a while loop and must update variables ourselves to bring us closer
    and closer to loop termination. If we forget to increase num, this happens:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们需要增加num ❸是非常重要的。for循环会自动将循环变量逐步推进到适当的值。但在while循环中，我们不能指望什么都不做就能完成工作，必须手动更新变量，才能将我们带到终止条件。如果忘记增加num，就会发生以下情况：
- en: '>>> num = 0'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = 0'
- en: '>>> while num < 5:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while num < 5:'
- en: '...     print(num)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(num)'
- en: '...'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '... forever'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '... 永远'
- en: If you run this code on your computer, your screen will fill up with zeros,
    and you’ll have to terminate your program. You can do that by pressing CTRL-C
    or by closing the Python window.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的计算机上运行这段代码，屏幕将充满零，你必须终止程序。你可以通过按CTRL-C或关闭Python窗口来终止程序。
- en: The problem is that num < 5 stays True forever; nothing in the loop can ever
    make it False. This situation, where a loop never terminates, is called an *infinite
    loop*. It’s surprisingly easy to inadvertently produce infinite while loops. If
    you see the same values repeating or your program appears to be doing nothing
    at all, it’s likely that you’re stuck in an infinite loop. Carefully check the
    while loop’s Boolean expression and that the loop block is making progress toward
    termination.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于num < 5永远为True；循环中的任何代码都无法使其变为False。这种循环永远不终止的情况被称为*无限循环*。意外地生成无限while循环是非常容易的。如果你看到相同的值反复出现，或者程序似乎什么都不做，那么很可能是你卡在了一个无限循环中。仔细检查while循环的布尔表达式，并确保循环块正在朝着终止方向进展。
- en: 'We can do whatever we like with the num variable. Here’s a while loop counting
    up by three:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随意操作num变量。这里是一个每次增加3的while循环：
- en: '>>> num = 0'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = 0'
- en: '>>> while num < 10:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while num < 10:'
- en: '...     print(num)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(num)'
- en: '...     num = num + 3'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '...     num = num + 3'
- en: '...'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '3'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '6'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '9'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'And here’s a while loop counting down from 4 to 0:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从4到0的while循环：
- en: '>>> num = 4'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = 4'
- en: '❶ >>> while num >= 0:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ >>> while num >= 0:'
- en: '...     print(num)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(num)'
- en: '...     num = num - 1'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '...     num = num - 1'
- en: '...'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '4'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Notice that I’ve used >= here rather than > ❶. This way, the while loop runs
    when num refers to 0, as desired.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在这里使用了>=而不是> ❶。这样，while循环在num为0时仍然会运行，正如预期的那样。
- en: '**CONCEPT CHECK**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: n = 3
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: n = 3
- en: 'while n > 0:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'while n > 0:'
- en: 'if n == 5:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n == 5:'
- en: n = -100
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: n = -100
- en: print(n)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: print(n)
- en: n = n + 1
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: n = n + 1
- en: A.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: '3'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: B.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: '3'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: C.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: '3'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '-100'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '-100'
- en: D.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: D.
- en: '3'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '-100'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '-100'
- en: 'Answer: C. A while loop’s Boolean expression is checked only at the start of
    each iteration. Even if it becomes False at some point during the iteration, the
    remainder of the iteration completes.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。while循环的布尔表达式只在每次迭代开始时检查一次。即使在迭代过程中某个时刻变为False，剩余的迭代也会完成。
- en: As 3 is greater than 0, an iteration of the loop runs. The if statement block
    is skipped (because its Boolean expression is False), so this iteration outputs
    3 and sets n to 4. As 4 is greater than 0, we have another iteration of the loop,
    this one outputting 4 and setting n to 5. As 5 is greater than 0, we have yet
    another iteration of the loop. This time, the if statement block runs, which sets
    n to -100. Next, -100 is output, and n is set to -99. And here we stop, because
    n > 0 is False.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于3大于0，循环迭代开始。if语句块被跳过（因为其布尔表达式为False），所以此迭代输出3并将n设置为4。由于4大于0，我们进行下一次迭代，此次迭代输出4并将n设置为5。由于5大于0，我们再进行一次迭代。这次if语句块执行，将n设置为-100。接着输出-100，并将n设置为-99。到这里我们停止，因为n
    > 0为False。
- en: '**CONCEPT CHECK**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: x = 6
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: x = 6
- en: 'while x > 4:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x > 4:'
- en: x = x - 1
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: x = x - 1
- en: print(x)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: print(x)
- en: A.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: '6'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: B.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: '6'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: C.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: '5'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: D.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: D.
- en: '5'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: E.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: E.
- en: '6'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'Answer: C. Many while loops do something and then update the loop variable,
    but not this one. This one first decrements the loop variable x and *then* outputs
    it. As 6 is greater than 4, an iteration of the loop runs, which assigns 5 to
    x and then outputs 5. Next, 5 is greater than 4, so we have another iteration,
    this one assigning 4 to x and outputting 4. And that’s it: 4 is not greater than
    4, so the loop terminates.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。许多while循环做某些事情并更新循环变量，但这个循环不是这样。这个循环首先递减循环变量x，然后输出它。由于6大于4，循环运行一次，将5赋值给x并输出5。接着，5大于4，所以进行另一轮迭代，将4赋值给x并输出4。就这样：4不大于4，所以循环结束。
- en: Nesting Loops in Loops
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在循环中嵌套循环
- en: 'We can nest loops inside of while loops, much as we can nest loops inside of
    for loops. In “Nesting” in [Chapter 3](ch03.xhtml#ch03), I noted that the inner
    for loop completes all of its iterations before the next iteration of the outer
    loop begins. The same holds for while loops. Here’s an example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在for循环中嵌套循环一样，在while循环中嵌套循环。在[第3章](ch03.xhtml#ch03)的“嵌套”部分，我提到过内部for循环在外部循环的下一次迭代开始之前完成所有迭代。while循环也是如此。以下是一个示例：
- en: '>>> i = 0'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '>>> while i < 3:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < 3:'
- en: '...     j = 8'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '...     j = 8'
- en: '...     while j < 11:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '...     while j < 11:'
- en: '...         print(i, j)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(i, j)'
- en: '...         j = j + 1'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '...         j = j + 1'
- en: '...     i = i + 1'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1'
- en: '...'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0 8
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 0 8
- en: 0 9
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 0 9
- en: 0 10
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 0 10
- en: 1 8
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 1 8
- en: 1 9
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 1 9
- en: 1 10
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 1 10
- en: 2 8
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 2 8
- en: 2 9
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 2 9
- en: 2 10
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 2 10
- en: Each value of i is involved in three lines of output, one for each iteration
    of the inner j loop.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个i的值都会涉及三行输出，每一行对应内部j循环的迭代。
- en: '**CONCEPT CHECK**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: How many lines are output by the following nested loop?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下嵌套循环会输出多少行？
- en: x = 0
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: x = 0
- en: y = 1
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: y = 1
- en: 'while x < 3:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x < 3:'
- en: 'while y < 3:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'while y < 3:'
- en: print(x, y)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: print(x, y)
- en: y = y + 1
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: y = y + 1
- en: x = x + 1
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: x = x + 1
- en: A. 2
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: A. 2
- en: B. 3
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: B. 3
- en: C. 6
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: C. 6
- en: D. 8
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: D. 8
- en: E. 9
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: E. 9
- en: 'Answer: A. The outer loop’s Boolean expression, x < 3, is True, so we perform
    an iteration of the outer loop. That leads to two iterations of the inner loop:
    one when y is 1 and one when y is 2, each of which prints a line of output. So
    that’s two lines of output so far.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。外部循环的布尔表达式x < 3为True，所以我们执行外部循环的一次迭代。接着进入两个内部循环的迭代：一次当y为1时，另一次当y为2时，每次都会输出一行。所以目前为止输出了两行。
- en: But nothing in the code resets y’s value! Therefore, y < 3 will never be True
    again, and there won’t be any further iterations of the inner loop.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但代码中没有任何地方重置y的值！因此，y < 3将再也不会为True，也不会有进一步的内部循环迭代。
- en: Forgetting to reset a loop variable is a common mistake when dealing with nested
    while loops.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记重置循环变量是处理嵌套while循环时常见的错误。
- en: Adding Boolean Operators
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加布尔运算符
- en: 'To solve Slot Machines, we want to loop while Martha has at least one quarter.
    That looks like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决老虎机问题，我们希望在玛莎至少有一枚硬币时进行循环。代码如下：
- en: 'while quarters >= 1:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'while quarters >= 1:'
- en: 'That simple Boolean expression will suffice for this problem. But just like
    for if statements, the Boolean expression following the word while can include
    relational or Boolean operators. Here’s an example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的布尔表达式就足够解决问题。但和if语句一样，while后面的布尔表达式也可以包含关系运算符或布尔运算符。以下是一个示例：
- en: '>>> x = 4'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 4'
- en: '>>> y = 10'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = 10'
- en: '>>> while x <= 10 and y <= 13:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while x <= 10 and y <= 13:'
- en: '...     print(x, y)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(x, y)'
- en: '...     x = x + 1'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '...     x = x + 1'
- en: '...     y = y + 1'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '...     y = y + 1'
- en: '...'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 4 10
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 4 10
- en: 5 11
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 5 11
- en: 6 12
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 6 12
- en: 7 13
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 7 13
- en: The while loop is controlled by the Boolean expression x <= 10 and y <= 13.
    As with any and operator, both of its operands must be True for the whole expression
    to be True. When x refers to 8 and y refers to 14, the loop terminates because
    the y <= 13 operand is False.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环由布尔表达式 x <= 10 和 y <= 13 控制。与任何 `and` 运算符一样，只有当两个操作数都为 `True` 时，整个表达式才为
    `True`。当 x 为 8，y 为 14 时，循环终止，因为 y <= 13 操作数为 `False`。'
- en: Solving the Problem
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: To solve Slot Machines, we know that we need a while loop, not a for loop, because
    we can’t predict the number of iterations in advance. Each iteration of the loop
    will play the current slot machine. When the loop terminates, Martha will have
    no quarters left, and we will output the number of times she played.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决老虎机问题，我们知道需要使用 `while` 循环，而不是 `for` 循环，因为我们无法预先预测迭代次数。每次循环迭代将玩当前的老虎机。当循环结束时，Martha
    将没有硬币，我们将输出她玩了多少次。
- en: 'Here’s what we need to do on each iteration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每次迭代时需要做的事情：
- en: Decrease Martha’s quarters by one (since it costs one quarter to play a slot
    machine).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Martha 的硬币数量减少一（因为玩一次老虎机需要一枚硬币）。
- en: If Martha is currently on the first slot machine, play that machine. This involves
    increasing the number of times this machine has been played. If this is the 35th
    play, then pay Martha and reset the number of times that this machine has been
    played to 0.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Martha 当前正在玩第一台老虎机，则玩该机器。这涉及到增加该机器的游戏次数。如果这是第 35 次游戏，则支付 Martha，并将该机器的游戏次数重置为
    0。
- en: If Martha is currently on the second slot machine, play that machine (similar
    to how we played the first machine).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Martha 当前正在玩第二台老虎机，则玩该机器（类似于我们玩第一台机器的方式）。
- en: If Martha is currently on the third slot machine, play that machine (similar
    to how we played the first machine).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Martha 当前正在玩第三台老虎机，则玩该机器（类似于我们玩第一台机器的方式）。
- en: Increase the number of Martha’s plays (since we just played a machine).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 Martha 的游戏次数（因为我们刚刚玩了一台机器）。
- en: Move to the next machine. If Martha just played the first machine, we want to
    move to the second; if she just played the second, we want to move to the third;
    and if she just played the third, we want to cycle back to the first.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动到下一台机器。如果 Martha 刚玩过第一台机器，我们要移动到第二台；如果她刚玩过第二台，我们要移动到第三台；如果她刚玩过第三台，我们要回到第一台。
- en: Our programs are getting longer now, so outlining the plan as I just did is
    a useful technique for keeping the complexity under control and guiding us toward
    correct code. We can use the outline to make sure we’re following the plan and
    not forgetting anything.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序现在变得更长了，因此像我刚才做的那样列出计划是一种有效的技术，有助于控制复杂性并引导我们写出正确的代码。我们可以使用这个大纲来确保我们在按照计划执行，且没有遗漏任何步骤。
- en: Our code is in [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码在[清单 4-1](ch04.xhtml#ch04ex01)中。
- en: quarters = int(input())
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = int(input())
- en: first = int(input())
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: first = int(input())
- en: second = int(input())
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: second = int(input())
- en: third = int(input())
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: third = int(input())
- en: plays = 0
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: plays = 0
- en: ❶ machine = 0
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ machine = 0
- en: '❷ while quarters >= 1:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ while quarters >= 1:'
- en: ❸ quarters = quarters - 1
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ quarters = quarters - 1
- en: '❹ if machine == 0:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ if machine == 0:'
- en: first = first + 1
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: first = first + 1
- en: '❺ if first == 35:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ if first == 35:'
- en: first = 0
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: first = 0
- en: quarters = quarters + 30
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 30
- en: 'elif machine == 1:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif machine == 1:'
- en: second = second + 1
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: second = second + 1
- en: 'if second == 100:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'if second == 100:'
- en: second = 0
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: second = 0
- en: quarters = quarters + 60
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 60
- en: 'elif machine == 2:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif machine == 2:'
- en: third = third + 1
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: third = third + 1
- en: 'if third == 10:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'if third == 10:'
- en: third = 0
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: third = 0
- en: quarters = quarters + 9
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 9
- en: ❻ plays = plays + 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ plays = plays + 1
- en: ❼ machine = machine + 1
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ machine = machine + 1
- en: '❽ if machine == 3:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '❽ if machine == 3:'
- en: machine = 0
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: machine = 0
- en: print('Martha plays', plays, 'times before going broke.')
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: print('Martha plays', plays, 'times before going broke.')
- en: '*Listing 4-1: Solving Slot Machines*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：解决老虎机问题*'
- en: The quarters variable tracks the number of quarters that Martha has. The first,
    second, and third variables track the number of plays since the last payment for
    the first, second, and third slot machines, respectively.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: quarters 变量跟踪 Martha 拥有的硬币数量。first、second 和 third 变量分别跟踪自上次支付以来，第一个、第二个和第三个老虎机的游戏次数。
- en: The machine variable tracks the slot machine that Martha will play next. The
    first slot machine is referred to by the number 0, the second by the number 1,
    and the third by 2. Making machine refer to 0 therefore indicates that the first
    slot machine will be played next ❶.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: machine 变量跟踪 Martha 将要玩的下一台老虎机。第一台老虎机用数字 0 表示，第二台用数字 1 表示，第三台用数字 2 表示。因此，将 machine
    设置为 0 表示下一台要玩的老虎机是第一台 ❶。
- en: 'We could have referred to the slot machines using 1, 2, and 3 instead of 0,
    1, and 2. Or we could have used strings: ''first'', ''second'', and ''third''.
    But numbering items starting from zero is customary, so that’s what I’ve done
    here.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以用 1、2 和 3 来代替 0、1 和 2 来表示老虎机。或者我们也可以使用字符串：'first'、'second' 和 'third'。但从零开始编号是惯例，因此我在这里采用了这种方式。
- en: The final variable in this program is plays, which tracks the number of slot
    machines that Martha has played. We’ll output this once Martha is out of quarters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的最终变量是 plays，它跟踪玛莎玩过的老虎机次数。等玛莎的硬币用完时，我们会输出这个值。
- en: The bulk of the program consists of a while loop that loops as long as Martha
    has quarters ❷.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主体部分是一个 while 循环，它在玛莎有硬币的情况下不断循环 ❷。
- en: Each iteration of the loop plays one slot machine. As such, the first thing
    we do is decrease Martha’s quarters by one ❸. Next, we play the current slot machine.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环都会玩一个老虎机。因此，首先我们会将玛莎的硬币减少 1 ❸。接着，我们玩当前的老虎机。
- en: Are we on slot machine 0? Slot machine 1? Slot machine 2? We need an if statement
    to answer that.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在老虎机 0 上吗？老虎机 1 上吗？老虎机 2 上吗？我们需要一个 if 语句来回答这个问题。
- en: We first check whether we’re on slot machine 0 ❹. If we are, then we increase
    the number of plays since this slot machine paid by one. To determine whether
    Martha gets paid, we then check whether this machine has been played exactly 35
    times since it last paid ❺. If it has, then we reset this machine’s plays to 0
    and increase Martha’s quarters by 30.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否在老虎机 0 上 ❹。如果是，那么我们增加游戏次数，因为这个老虎机支付了玛莎一个硬币。接下来，我们检查玛莎是否会获得支付，方法是检查自上次支付以来这个机器是否已被玩了
    35 次 ❺。如果是，那么我们将这个机器的游戏次数重置为 0，并增加玛莎 30 个硬币。
- en: There are several levels of nesting here, so take some time to convince yourself
    that the logic of the code is correct. In particular, note that every time we
    play the first machine, we increase its number of plays by one. But we only pay
    Martha after every 35 plays—that’s why we have the inner if statement ❺!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个层次的嵌套，因此花点时间确认代码逻辑是正确的。特别注意，每次我们玩第一个机器时，我们都会将它的游戏次数增加 1。但我们只在每 35 次游戏后才支付玛莎——这就是为什么我们需要内层的
    if 语句 ❺！
- en: We handle the second and third slot machines just as we handled the first. The
    only difference is that each slot machine pays Martha after its own number of
    plays and pays Martha its own amount of quarters.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理第二和第三个老虎机的方式与处理第一个老虎机一样。唯一的区别是每个老虎机在它自己规定的次数后支付玛莎，并支付她对应数量的硬币。
- en: Having played a slot machine, we increase Martha’s number of plays by one ❻.
    Now all that’s left is to move to the next machine so that we’ll be at the right
    machine if there’s a next iteration of the loop.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 玩过老虎机后，我们将玛莎的游戏次数增加了 1 ❻。现在只剩下移动到下一个机器，如果有下一次循环的话，我们就能在正确的机器上。
- en: To move to the next machine, we increase machine by one ❼. If we were on machine
    0, this would move us to machine 1. If we were on machine 1, this would move us
    to machine 2. If we were on machine 2, this would move us to machine 3.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动到下一个机器，我们将 machine 增加 1 ❼。如果我们在机器 0 上，这将把我们移到机器 1。如果我们在机器 1 上，这将把我们移到机器
    2。如果我们在机器 2 上，这将把我们移到机器 3。
- en: '*. . .* Machine 3? There’s no machine 3! If we just played machine 2, then
    we want to start over at machine 0\. To do that, we add a check: if we just moved
    to machine 3 ❽, then we know that we just played machine 2, so we reset machine
    to machine 0.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*. . .* 机器 3？没有机器 3！如果我们刚刚玩过机器 2，那么我们希望从机器 0 开始重新来过。为此，我们添加了一个检查：如果我们刚刚移动到机器
    3 ❽，那么我们知道我们刚才玩过机器 2，因此将 machine 重置为机器 0。'
- en: When the loop terminates, we know that Martha has no quarters left. As a last
    step, we output the required sentence, including Martha’s number of plays.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环终止时，我们知道玛莎已经没有硬币了。最后，我们输出所需的句子，包括玛莎的游戏次数。
- en: 'This code has a lot going on: stopping when Martha has no quarters left, keeping
    track of the current machine, paying Martha when appropriate, and counting Martha’s
    plays. Feel free to submit this code now, but also to consider whether you’d have
    written parts of it in a different way. What happens if you increase plays by
    1 at the top of the loop instead of the bottom? Does it matter whether you decrease
    quarters by 1 at the top of the loop or the bottom? Would you have used new variables
    to keep track of the number of times that Martha played each slot machine, rather
    than modifying first, second, and third? I strongly encourage you to experiment
    with variations of what we’ve done here. If you make changes and the code no longer
    passes the tests, great! Now you have a new learning opportunity to fix the code
    and learn why your changes led to undesired behavior.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了很多内容：当玛莎没有硬币时停止，跟踪当前的机器，适时支付玛莎，并计算玛莎的游戏次数。现在你可以提交这段代码，但也可以考虑是否会以不同的方式编写其中的部分代码。如果你在循环顶部增加plays的值而不是底部会发生什么？你是否认为在循环顶部或底部减少硬币数有区别？你会不会使用新的变量来跟踪玛莎玩过每台老虎机的次数，而不是修改first、second和third？我强烈鼓励你尝试不同的实现方式。如果你做了修改，并且代码不再通过测试，那太好了！现在你有了新的学习机会，去修复代码并了解为什么你的修改导致了不期望的行为。
- en: The next two sections offer further refinement of the code. We’ll use the %
    operator to reduce the number of variables that we need and learn about f-strings
    to streamline how we build strings.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将进一步改进代码。我们将使用%运算符来减少所需的变量数量，并学习如何使用f-strings来简化字符串的构建。
- en: The Mod Operator
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模运算符
- en: 'In “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01), I
    introduced the mod (%) operator for calculating the remainder of an integer division.
    For example, 16 divided by 5 has a remainder of 1:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.xhtml#ch01)的“整数和浮点数”一节中，我介绍了用于计算整数除法余数的模（%）运算符。例如，16除以5的余数是1：
- en: '>>> 16 % 5'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 16 % 5'
- en: '1'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'And 15 divided by 5 has a remainder of 0 (because 5 divides 15 exactly):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 而15除以5的余数是0（因为5恰好能除尽15）：
- en: '>>> 15 % 5'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 15 % 5'
- en: '0'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'The second operand dictates the range of values that % can possibly return.
    The possible return values are 0 up to but not including the second operand. For
    example, if the second operand is 3, then the only values that can be returned
    by % are 0, 1, and 2\. In addition, as we increase the first operand, we cycle
    through all possible return values. Here’s an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作数决定了%运算符可能返回的值的范围。可能的返回值是从0开始，直到但不包括第二个操作数。例如，如果第二个操作数是3，那么%运算符可能返回的值只有0、1和2。另外，随着第一个操作数的增加，我们会在所有可能的返回值之间循环。下面是一个示例：
- en: '>>> 0 % 3'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 0 % 3'
- en: '0'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> 1 % 3'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1 % 3'
- en: '1'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> 2 % 3'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2 % 3'
- en: '2'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> 3 % 3'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 3 % 3'
- en: '0'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> 4 % 3'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 % 3'
- en: '1'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> 5 % 3'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 % 3'
- en: '2'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> 6 % 3'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 6 % 3'
- en: '0'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> 7 % 3'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 7 % 3'
- en: '1'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'Notice the pattern: 0, 1, 2, 0, 1, 2, and so on.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个模式：0，1，2，0，1，2，如此循环。
- en: 'This behavior is useful for counting up to a specified number and then cycling
    back to 0\. It’s exactly the behavior that we need when playing the slot machines:
    we play slot machine 0, then 1, then 2, then 0, then 1, then 2, then 0, then 1,
    and so on. (This is another reason why I used 0, 1, and 2, rather than other values,
    to refer to the slot machines.)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于计算达到指定数量后再返回0非常有用。它正是我们玩老虎机时需要的行为：我们先玩老虎机0，然后是1，再是2，然后回到0，再是1，再是2，如此循环。（这也是为什么我用0、1、2，而不是其他值，来代表老虎机的原因。）
- en: 'Suppose that variable plays refers to the number of times that Martha has played.
    To determine the next machine to play (0, 1, or 2), we can use the % operator.
    For example, suppose that Martha has played one slot machine so far, and we want
    to know which she will play next. She’ll play slot machine 1 next, and the % operator
    tells us that:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量plays表示玛莎已经玩的次数。为了确定下一个她将玩的机器（0、1或2），我们可以使用%运算符。例如，假设玛莎到目前为止只玩了一台老虎机，我们想知道她接下来会玩哪一台。她接下来会玩老虎机1，而%运算符告诉我们：
- en: '>>> plays = 1'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays = 1'
- en: '>>> plays % 3'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays % 3'
- en: '1'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'If Martha has played six times so far, then she’s played slot machines 0, 1,
    2, 0, 1, 2\. The next slot machine she’ll play is machine 0\. And, as she’s played
    all three machines twice, with no other plays beyond that, the % operator gives
    us 0:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玛莎到目前为止玩了六次，那么她玩过老虎机0、1、2、0、1、2。接下来她将玩的是老虎机0。而且，由于她已经玩过这三台机器两次，且没有其他额外的游戏，%运算符给出的结果是0：
- en: '>>> plays = 6'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays = 6'
- en: '>>> plays % 3'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays % 3'
- en: '0'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'As a final example, suppose that Martha has played 11 times so far. She’s done
    three complete cycles: 0, 1, 2, 0, 1, 2, 0, 1, 2\. That’s nine of the plays. The
    remaining two plays put Martha on slot machine 2 for her next play:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个最终的例子，假设玛莎已经玩了 11 次。她完成了三轮：0, 1, 2, 0, 1, 2, 0, 1, 2。这是她的九次游戏。剩下的两次游戏让玛莎在她的下一次游戏中玩老虎机
    2：
- en: '>>> plays = 11'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays = 11'
- en: '>>> plays % 3'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays % 3'
- en: '2'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: That is, we can figure out the slot machine to play without explicitly maintaining
    a machine variable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以在不显式维护一个机器变量的情况下，推算出要玩的老虎机。
- en: 'We can also use % to simplify the logic of determining whether the next play
    on the current slot machine pays Martha. Consider the first slot machine. In [Listing
    4-1](ch04.xhtml#ch04ex01), we counted the number of plays since the slot machine
    paid. If that number is 35, then we pay Martha and reset the count to 0\. But
    there’s no need to reset the count if we’re using the % operator. We can just
    check whether the slot machine has been played a multiple of 35 times and pay
    Martha if so. To test whether a number is a multiple of 35, we can use the % operator.
    A number is a multiple of 35 if dividing it by 35 yields no remainder:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `%` 来简化判断当前老虎机是否支付给玛莎的逻辑。考虑第一个老虎机。在 [Listing 4-1](ch04.xhtml#ch04ex01)
    中，我们统计了自从老虎机支付后经过的游戏次数。如果这个次数是 35，那么我们就支付玛莎并将计数重置为 0。但如果使用 `%` 运算符，就不需要重置计数。我们只需检查老虎机是否已经被玩了
    35 次的倍数，如果是，就支付玛莎。要测试一个数字是否是 35 的倍数，我们可以使用 `%` 运算符。一个数字如果除以 35 没有余数，那么它就是 35 的倍数：
- en: '>>> first = 35'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first = 35'
- en: '>>> first % 35'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first % 35'
- en: '0'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> first = 48'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first = 48'
- en: '>>> first % 35'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first % 35'
- en: '13'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '>>> first = 70'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first = 70'
- en: '>>> first % 35'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first % 35'
- en: '0'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> first = 175'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first = 175'
- en: '>>> first % 35'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first % 35'
- en: '0'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: We can just check first % 35 == 0 to determine whether to pay Martha.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先检查 `% 35 == 0` 来判断是否支付玛莎。
- en: I’ve updated [Listing 4-1](ch04.xhtml#ch04ex01) to use the % operator. The new
    code is in [Listing 4-2](ch04.xhtml#ch04ex02).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我已更新 [Listing 4-1](ch04.xhtml#ch04ex01) 以使用 `%` 运算符。新代码见 [Listing 4-2](ch04.xhtml#ch04ex02)。
- en: quarters = int(input())
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = int(input())
- en: first = int(input())
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: first = int(input())
- en: second = int(input())
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: second = int(input())
- en: third = int(input())
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: third = int(input())
- en: plays = 0
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: plays = 0
- en: 'while quarters >= 1:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'while quarters >= 1:'
- en: ❶ machine = plays % 3
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ machine = plays % 3
- en: quarters = quarters - 1
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters - 1
- en: 'if machine == 0:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'if machine == 0:'
- en: first = first + 1
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: first = first + 1
- en: '❷ if first % 35 == 0:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 first % 35 == 0：
- en: quarters = quarters + 30
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 30
- en: 'elif machine == 1:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif machine == 1:'
- en: second = second + 1
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: second = second + 1
- en: 'if second % 100 == 0:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'if second % 100 == 0:'
- en: quarters = quarters + 60
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 60
- en: 'elif machine == 2:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif machine == 2:'
- en: third = third + 1
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: third = third + 1
- en: 'if third % 10 == 0:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'if third % 10 == 0:'
- en: quarters = quarters + 9
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: quarters = quarters + 9
- en: plays = plays + 1
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: plays = plays + 1
- en: print('Martha plays', plays, 'times before going broke.')
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: print('Martha plays', plays, 'times before going broke.')
- en: '*Listing 4-2: Solving Slot Machines using* %'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-2: 使用* % *解决老虎机问题*'
- en: 'I’ve used % in the two ways described in this section: to determine the current
    machine based on the number of plays ❶ and to determine whether Martha gets paid
    on a play (for example, at ❷).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中描述的两种方式中都使用了 `%`：一种是根据游戏次数判断当前的机器 ❶，另一种是判断玛莎是否在某次游戏时得到支付（例如，在 ❷ 处）。
- en: Associating % with returning the remainder of a division belies its flexibility.
    Whenever you need to count in a cycle (0, 1, 2, 0, 1, 2), consider whether you
    can use % to simplify your code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `%` 与返回除法余数的操作结合使用，体现了它的灵活性。每当你需要在一个循环中计数（0, 1, 2, 0, 1, 2）时，考虑是否可以使用 `%`
    来简化你的代码。
- en: F-Strings
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F-Strings
- en: 'The final thing we do in our solution to Slot Machines is output the required
    sentence, like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的老虎机解决方案中的最后一步是输出所需的句子，如下所示：
- en: print('Martha plays', plays, 'times before going broke.')
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: print('Martha plays', plays, 'times before going broke.')
- en: 'We have to remember to end the first string so that we can output the number
    of plays and then start a new string for the second half of the sentence. In addition,
    we’re using multiple arguments to print to avoid having to convert plays to a
    string. If we were storing the resulting string rather than printing it, we’d
    need the str conversion:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记得结束第一个字符串，这样我们就可以输出游戏次数，然后为句子的后半部分开始一个新的字符串。另外，我们使用多个参数进行打印，以避免将游戏次数转换为字符串。如果我们存储结果字符串而不是直接打印，我们就需要进行`str`转换：
- en: '>>> plays = 6'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plays = 6'
- en: '>>> result = ''Martha plays '' + str(plays) + '' times before going broke.'''
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> result = ''Martha plays '' + str(plays) + '' times before going broke.'''
- en: '>>> result'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> result'
- en: '''Martha plays 6 times before going broke.'''
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '''Martha plays 6 times before going broke.'''
- en: 'Gluing strings and integers together is fine for a simple sentence like this,
    but it doesn’t scale. Here’s how it looks when we try to embed three integers
    instead of one:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串和整数拼接在一起对于像这样的简单句子来说是可以的，但它不具备可扩展性。以下是我们尝试嵌入三个整数而不是一个时的样子：
- en: '>>> num1 = 7'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num1 = 7'
- en: '>>> num2 = 82'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num2 = 82'
- en: '>>> num3 = 11'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num3 = 11'
- en: '>>> ''We have '' + str(num1) + '', '' + str(num2) + '', and '' + str(num3)
    + ''.'''
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''We have '' + str(num1) + '', '' + str(num2) + '', and '' + str(num3)
    + ''.'''
- en: '''We have 7, 82, and 11.'''
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '''We have 7, 82, and 11.'''
- en: We don’t want to have to keep track of all of those quotes, pluses, and spaces.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次都要追踪所有的引号、加号和空格。
- en: 'The most flexible way to build a string consisting of strings and numbers is
    to use an *f-string*. Here’s how the previous example looks with an f-string:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包含字符串和数字的字符串最灵活的方法是使用 *f-string*。下面是前一个示例使用 f-string 的样子：
- en: '>>> num1 = 7'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num1 = 7'
- en: '>>> num2 = 82'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num2 = 82'
- en: '>>> num3 = 11'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num3 = 11'
- en: '>>> f''We have {num1}, {num2}, and {num3}.'''
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f''We have {num1}, {num2}, and {num3}.'''
- en: '''We have 7, 82, and 11.'''
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '''We have 7, 82, and 11.'''
- en: 'Notice the f before the opening quote of the string. The f stands for format,
    because f-strings allow you to format the contents of a string. Inside of an f-string,
    we can place expressions inside curly brackets. As the string is being built,
    each expression is replaced by its value and inserted into the string. The result
    is just a regular old string—there’s no new type here:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串的开头有一个 f。这个 f 代表格式化，因为 f-strings 允许你格式化字符串的内容。在 f-string 中，我们可以将表达式放入花括号中。当字符串构建时，每个表达式都会被其值替换并插入到字符串中。结果只是一个普通的字符串——这里没有新的类型：
- en: '>>> type(f''hello'')'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(f''hello'')'
- en: <class 'str'>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'str'>
- en: '>>> type(f''{num1} days'')'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(f''{num1} days'')'
- en: <class 'str'>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'str'>
- en: 'The expressions in the curly brackets can be more complex than bare variable
    names:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号中的表达式可以比简单的变量名更复杂：
- en: '>>> f''The sum is {num1 + num2 + num3}'''
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f''The sum is {num1 + num2 + num3}'''
- en: '''The sum is 100'''
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '''The sum is 100'''
- en: 'We can use f-strings in the final line of Slot Machines. Here’s how that would
    look:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Slot Machines 的最后一行使用 f-strings。下面是它的样子：
- en: print(f'Martha plays {plays} times before going broke.')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: print(f'Martha plays {plays} times before going broke.')
- en: Even in this simplest of string-formatting contexts, I think f-strings add clarity.
    Keep them in the back of your mind for whenever you catch yourself building a
    string from smaller pieces.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个最简单的字符串格式化上下文中，我认为 f-strings 增加了清晰度。每当你发现自己在将多个部分拼接成一个字符串时，记得使用它们。
- en: 'One warning about f-strings: they were added in Python 3.6, which at the time
    of writing is still a reasonably recent version of Python. In older versions of
    Python, f-strings cause syntax errors.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 f-strings 的一个警告：它们是在 Python 3.6 中加入的，而在本文写作时，Python 3.6 仍然是相对较新的版本。在 Python
    的旧版本中，f-strings 会导致语法错误。
- en: If you use f-strings, be sure to check that the judge you’re submitting to is
    using Python 3.6 or newer to test your code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 f-strings，请确保检查你提交的评测环境是否使用 Python 3.6 或更高版本来测试你的代码。
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决《章节练习》中的第 1 题，位于 [第 99 页](ch04.xhtml#ch04lev1sec17)。
- en: 'Problem #9: Song Playlist'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #9：歌曲播放列表'
- en: Sometimes we don’t know in advance how much input will be provided. We’ll see
    in this problem that a while loop is what we need in such cases.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们无法提前知道会提供多少输入。在这个问题中，我们将看到在这种情况下，while 循环是我们所需要的。
- en: This is DMOJ problem ccc08j2.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 ccc08j2。
- en: The Challenge
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'We have five favorite songs named A, B, C, D, and E. We’ve created a playlist
    of these songs and are using an app to manage the playlist. The songs start off
    in the order A, B, C, D, E. The app has four buttons:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五首最喜欢的歌，分别是 A、B、C、D 和 E。我们已经创建了一个包含这些歌曲的播放列表，并使用一个应用程序来管理这个播放列表。歌曲最初的顺序是
    A、B、C、D、E。应用程序有四个按钮：
- en: 'Button 1: Moves the first song of the playlist to the end of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to B,
    C, D, E, A.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 1：将播放列表中的第一首歌移到播放列表的末尾。例如，如果播放列表目前是 A, B, C, D, E，那么它将变成 B, C, D, E, A。
- en: 'Button 2: Moves the last song of the playlist to the beginning of the playlist.
    For example, if the playlist is currently A, B, C, D, E, then it changes to E,
    A, B, C, D.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 2：将播放列表中的最后一首歌移到播放列表的最前面。例如，如果播放列表目前是 A, B, C, D, E，那么它将变成 E, A, B, C, D。
- en: 'Button 3: Swaps the first two songs of the playlist. For example, if the playlist
    is currently A, B, C, D, E, then it changes to be B, A, C, D, E.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 3：交换播放列表中的前两首歌曲。例如，如果播放列表目前是 A, B, C, D, E，那么它将变成 B, A, C, D, E。
- en: 'Button 4: Plays the playlist!'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 4：播放播放列表！
- en: We’re provided a user’s button presses. When the user presses button 4, output
    the order of songs in the playlist.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了用户按下按钮的输入。当用户按下按钮 4 时，输出播放列表中歌曲的顺序。
- en: Input
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of pairs of lines, where the first line of a pair gives
    the number of a button (1, 2, 3, or 4), and the second gives the number of times
    that the user pressed this button (between 1 and 10). That is, the first line
    is the number of a button, the second line is the number of times it is pressed,
    the third line is the number of a button, the fourth line is the number of times
    it is pressed, and so on. The input ends with these two lines:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由一对一对的行组成，每对行的第一行给出一个按钮的编号（1、2、3 或 4），第二行给出用户按下该按钮的次数（介于 1 和 10 之间）。即，第一行是按钮的编号，第二行是按下该按钮的次数，第三行是按钮的编号，第四行是按下次数，依此类推。输入以以下两行结束：
- en: '4'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '1'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: indicating that the user pressed button 4 once.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 表示用户按下了按钮 4 一次。
- en: Output
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the order of songs in the playlist after all button presses. The output
    must be on one line, with a space separating each pair of songs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 输出播放列表中歌曲的顺序，所有按键按下后的结果。输出必须在一行中，每对歌曲之间用空格分隔。
- en: String Slicing
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串切片
- en: 'The high-level plan of our solution to Song Playlist will be a while loop that
    keeps going as long as we haven’t found the press of button 4. On each iteration,
    we’ll read two lines of input and process them. That leads to this structure:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案的高层次计划是使用一个 while 循环，只要我们没有找到按钮 4 的按下，就一直运行。在每次迭代中，我们会读取两行输入并处理它们。最终形成这个结构：
- en: ❶ button = 0
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ button = 0
- en: 'while button != 4:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'while button != 4:'
- en: '# Read button'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取按钮'
- en: '# Read number of presses'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取按下次数'
- en: '# Process button presses'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '# 处理按钮按下'
- en: Prior to the while loop, we create the variable button and make it refer to
    the number 0 ❶. Without this, the button variable would not exist, and we’d get
    a NameError in the while loop’s Boolean expression. Any number besides 4 would
    work here to trigger the first iteration of the loop.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 while 循环之前，我们创建变量 button 并将其初始化为 0 ❶。没有这个，button 变量就不存在，在 while 循环的布尔表达式中会导致
    NameError。这里可以使用任何数字，除了 4，用来触发循环的第一次迭代。
- en: Within this while loop, we’ll use a for loop to process the button presses.
    For each press, we’ll use an if statement to check which button was pressed. We’ll
    need four indented blocks of statements in the if statement, one for each of the
    four buttons.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 while 循环内，我们将使用 for 循环来处理按钮按下的次数。对于每次按下，我们将使用 if 语句检查按下的是哪个按钮。我们需要在 if 语句中为每个按钮编写四个缩进代码块。
- en: 'Let’s talk about how to handle each of the buttons. Button 1 moves the first
    song of the playlist to the end of the playlist. Because we have a small, known
    number of songs, we can get away with using string indexing to concatenate each
    character. Remember that the first character of a string is at index 0, not 1\.
    We can put that character at the end of the string like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论如何处理每个按钮。按钮 1 将播放列表中的第一首歌移到播放列表的末尾。由于我们有一个小且已知数量的歌曲，我们可以使用字符串索引来拼接每个字符。记住，字符串的第一个字符位于索引
    0，而不是 1。我们可以像这样将该字符放到字符串的末尾：
- en: '>>> songs = ''ABCDE'''
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> songs = ''ABCDE'''
- en: '>>> songs = songs[1] + songs[2] + songs[3] + songs[4] + songs[0]'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> songs = songs[1] + songs[2] + songs[3] + songs[4] + songs[0]'
- en: '>>> songs'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> songs'
- en: '''BCDEA'''
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '''BCDEA'''
- en: This is rather unwieldy and is specific to having exactly five songs. We can
    use string slicing to write more general and less error-prone code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做相当繁琐，且仅适用于恰好有五首歌曲的情况。我们可以使用字符串切片来编写更通用且更不容易出错的代码。
- en: '*Slicing* is a Python feature that lets us refer to a substring of a string.
    (In fact, it works on any sequence, as we’ll see later in the book.) It takes
    two indices: the index where we want to start, and the index one to the right
    of where we want to end. If we use indices 4 and 8, for example, then we get the
    characters at indices 4, 5, 6, and 7\. Slicing uses square brackets, with a colon
    between the two indices:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片*是 Python 的一项特性，它允许我们引用字符串的子字符串。（实际上，它适用于任何序列，正如我们在书中稍后会看到的那样。）它需要两个索引：我们希望开始的位置和我们希望结束的位置的右边一个索引。例如，如果我们使用索引
    4 和 8，那么我们会得到索引 4、5、6 和 7 处的字符。切片使用方括号，两个索引之间用冒号分隔：'
- en: '>>> s = ''abcdefghijk'''
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''abcdefghijk'''
- en: '>>> s[4:8]'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[4:8]'
- en: '''efgh'''
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '''efgh'''
- en: 'The slicing doesn’t change what s refers to. We can make s refer to the slice
    by using an assignment statement:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 切片不会改变 s 的引用。我们可以使用赋值语句让 s 引用这个切片：
- en: '>>> s'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '''abcdefghijk'''
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '''abcdefghijk'''
- en: '>>> s = s[4:8]'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = s[4:8]'
- en: '>>> s'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '''efgh'''
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '''efgh'''
- en: It’s easy to make an off-by-one error here and think that s[4:8] includes the
    character at index 8\. But it doesn’t, just like range(4, 8) doesn’t include the
    8. So while this behavior may be a little counterintuitive, it’s applied consistently
    in both range and slicing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里很容易犯一个“错位”的错误，认为 s[4:8] 包含索引 8 处的字符。但实际上它并不包含，就像 range(4, 8) 不包括 8 一样。虽然这种行为可能有点违反直觉，但它在
    range 和切片操作中是一致的。
- en: 'We must always include the colon when performing string slicing, but the start
    and end indices are optional. If we leave off the start index, Python starts slicing
    at index 0:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进行字符串切片时，必须始终包含冒号，但开始和结束索引是可选的。如果省略了开始索引，Python 会从索引 0 开始切片：
- en: '>>> s = ''abcdefghijk'''
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''abcdefghijk'''
- en: '>>> s[:4]'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[:4]'
- en: '''abcd'''
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '''abcd'''
- en: 'If we leave off the end index, Python slices until the end of the string:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略结束索引，Python 会切片到字符串的末尾：
- en: '>>> s[4:]'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[4:]'
- en: '''efghijk'''
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '''efghijk'''
- en: 'And leaving out both indices? That gives us a slice consisting of the entire
    string:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果省略了两个索引呢？这样就会得到一个包含整个字符串的切片：
- en: '>>> s[:]'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[:]'
- en: '''abcdefghijk'''
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '''abcdefghijk'''
- en: 'We can even use negative indices in a slice. Here’s an example:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在切片中使用负索引。以下是一个示例：
- en: '>>> s[-4:]'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[-4:]'
- en: '''hijk'''
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '''hijk'''
- en: The start index refers to the fourth character from the right, which is 'h',
    and the end index is omitted. We therefore get a slice from the 'h' to the end
    of the string.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 起始索引指的是从右侧数第四个字符，即 'h'，结束索引被省略。因此我们得到的切片是从 'h' 到字符串的末尾。
- en: 'Unlike indexing, slicing never produces an index error. If we use indices that
    are outside of the string, Python slices to the appropriate end of the string:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 与索引不同，切片操作永远不会引发索引错误。如果我们使用超出字符串范围的索引，Python 会切片到字符串的适当位置：
- en: '>>> s[8:20]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[8:20]'
- en: '''ijk'''
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '''ijk'''
- en: '>>> s[-50:2]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[-50:2]'
- en: '''ab'''
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '''ab'''
- en: 'We’ll use string slicing to implement the behaviors of buttons 1, 2, and 3.
    Here’s what the code looks like for button 1:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字符串切片来实现按钮 1、2 和 3 的行为。按钮 1 的代码如下：
- en: '>>> songs = ''ABCDE'''
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> songs = ''ABCDE'''
- en: '>>> songs = songs[1:] + songs[0]'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> songs = songs[1:] + songs[0]'
- en: '>>> songs'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> songs'
- en: '''BCDEA'''
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '''BCDEA'''
- en: The slice gives us the entire string except for the character at index 0\. (There’s
    nothing specific to a string of length 5 here; this code would work on a nonempty
    string of any length.) Appending that missing character results in the first song
    moving to the end of the playlist. The slicing for the other buttons is similar;
    you’ll see that code next.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 该切片给我们整个字符串，除了索引 0 处的字符。（这里并没有涉及到长度为 5 的字符串；这段代码适用于任何长度的非空字符串。）将缺失的字符加回来后，第一首歌就移动到了播放列表的末尾。其他按钮的切片操作也类似，代码如下所示。
- en: '**CONCEPT CHECK**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: game = 'Lost Vikings'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: game = 'Lost Vikings'
- en: print(game[2:-6])
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: print(game[2:-6])
- en: A. st V
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: A. st V
- en: B. ost V
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: B. ost V
- en: C. iking
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: C. iking
- en: D. st Vi
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: D. st Vi
- en: E. Viking
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: E. 维京
- en: 'Answer: A. The character at index 2 is the ''s'' in ''Lost''. The character
    at index -6 is the first ''i'' in ''Vikings''. Since we go from index 2 up to
    but not including index -6, we get the slice ''st V''.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 索引 2 处的字符是 'Lost' 中的 's'。索引 -6 处的字符是 'Vikings' 中的第一个 'i'。因为我们从索引 2 开始，到索引
    -6 之前，所以得到的切片是 'st V'。
- en: '**CONCEPT CHECK**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Which password gets us out of the following loop?
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个密码可以让我们跳出下面的循环？
- en: valid = False
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: valid = False
- en: 'while not valid:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 'while not valid:'
- en: s = input()
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: s = input()
- en: valid = len(s) == 5 and s[:2] == 'xy'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: valid = len(s) == 5 and s[:2] == 'xy'
- en: A. xyz
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: A. xyz
- en: B. xyabc
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: B. xyabc
- en: C. abcxy
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: C. abcxy
- en: D. More than one of the above passwords get us out of the loop
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: D. 多个以上的密码可以让我们跳出循环
- en: E. None; the loop never executes and no passwords are obtained
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: E. 没有；循环从不执行，也没有得到密码
- en: 'Answer: B. The while loop terminates when valid is True (because then not valid
    is False). The only one of the given passwords whose length is 5 and whose first
    two characters are ''xy'' is xyabc. This is therefore the only given password
    that sets valid to True and ends the loop.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 当 valid 为 True 时，while 循环终止（因为 not valid 为 False）。给定密码中，只有一个密码的长度为 5 且前两个字符为
    'xy'，即 xyabc。因此这是唯一一个能使 valid 为 True 并终止循环的密码。
- en: Solving the Problem
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Now that we have some practice using while loops to loop as long as there are
    more buttons to handle, and using slicing for string manipulation, we’re ready
    to solve Song Playlist. See [Listing 4-3](ch04.xhtml#ch04ex03) for the code.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经通过使用 while 循环循环处理多个按钮，并使用切片进行字符串操作有所练习，准备好解决歌曲播放列表的问题了。请参考 [Listing 4-3](ch04.xhtml#ch04ex03)
    中的代码。
- en: songs = 'ABCDE'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: songs = 'ABCDE'
- en: button = 0
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: button = 0
- en: '❶ while button != 4:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ while button != 4:'
- en: button = int(input())
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: button = int(input())
- en: presses = int(input())
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: presses = int(input())
- en: '❷ for i in range(presses):'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for i in range(presses):'
- en: 'if button == 1:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button == 1:'
- en: ❸ songs = songs[1:] + songs[0]
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ songs = songs[1:] + songs[0]
- en: 'elif button == 2:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif button == 2:'
- en: ❹ songs = songs[-1] + songs[:-1]
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ songs = songs[-1] + songs[:-1]
- en: 'elif button == 3:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif button == 3:'
- en: ❺ songs = songs[1] + songs[0] + songs[2:]
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ songs = songs[1] + songs[0] + songs[2:]
- en: ❻ output = ''
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ output = ''
- en: 'for song in songs:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 'for song in songs:'
- en: output = output + song + ' '
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: output = output + song + ' '
- en: ❼ print(output[:-1])
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ print(output[:-1])
- en: '*Listing 4-3: Solving Song Playlist*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：解决歌曲播放列表问题*'
- en: The while loop continues as long as button 4 hasn’t been pressed ❶. On each
    iteration of the while loop, we read the button number and then read the number
    of times that this button was pressed.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会继续，直到按钮 4 被按下 ❶。每次执行 `while` 循环时，我们读取按钮编号，然后读取此按钮被按下的次数。'
- en: Now, nested in the outer while loop, we need to loop once per button press.
    Keep all of the loop types in mind as you decide which to use. Here, a range for
    loop is the best choice ❷, since it’s the easiest way to loop exactly the number
    of times we specify.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在外层的 `while` 循环中，我们需要在每次按下按钮时循环一次。选择哪种循环类型时要牢记所有循环的类型。在这里，使用 `range` 循环是最好的选择
    ❷，因为它是最简单的方式来精确控制循环的次数。
- en: The behavior inside the range for loop depends on which button is pressed. We
    therefore use an if statement to check the button number and modify the playlist
    accordingly. If button 1 is pressed, we use slicing to move the first song to
    the end of the playlist ❸. If button 2 is pressed, we use slicing to move the
    last song to the beginning of the playlist ❹. To do that, we start with the character
    at the right end of the string and then use slicing to append all other characters.
    For button 3, we need to modify the playlist so that the first two songs swap
    positions. We build a new string with the character at index 1, then the character
    at index 0, and then all of the characters starting at index 2 ❺.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 循环内部的行为取决于按下的按钮。我们因此使用 `if` 语句来检查按钮编号并相应地修改播放列表。如果按下按钮 1，我们使用切片将第一首歌移到播放列表的末尾
    ❸。如果按下按钮 2，我们使用切片将最后一首歌移到播放列表的开头 ❹。为此，我们从字符串的右端开始，然后使用切片将其他所有字符添加进去。对于按钮 3，我们需要修改播放列表，使得前两首歌交换位置。我们通过将索引
    1 处的字符放在前面，再放置索引 0 处的字符，最后添加从索引 2 开始的所有字符来构建一个新字符串 ❺。'
- en: Once we escape the while loop, we need to output the songs, with a space between
    each pair of songs. We can’t just output songs, because that doesn’t have spaces.
    Instead, we build an output string that has the appropriate spaces. To do that,
    we start with the empty string ❻ and then use a for loop to concatenate each song
    and a space. One small annoyance is that this adds a space to the end of the string,
    after the last song, and we don’t want that. We therefore use slicing to remove
    that final space character ❼.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们跳出 `while` 循环，就需要输出歌曲，并在每对歌曲之间添加空格。我们不能直接输出歌曲，因为那样没有空格。因此，我们构建一个包含适当空格的输出字符串。为此，我们从空字符串
    ❻ 开始，然后使用 `for` 循环将每首歌和空格连接起来。有一个小问题是，这会在字符串的末尾添加一个空格，出现在最后一首歌后面，而我们不希望这样。所以，我们使用切片去除最后的空格字符
    ❼。
- en: You’re now ready to submit to the judge.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以提交给裁判了。
- en: Before continuing, you might like to try solving exercise 3 from “Chapter Exercises”
    on [page 99](ch04.xhtml#ch04lev1sec17).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决 “章节练习” 中第 3 题，见 [第 99 页](ch04.xhtml#ch04lev1sec17)。
- en: 'Problem #10: Secret Sentence'
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #10：秘密句子'
- en: Even if we have a string and even if we know how much input will be provided,
    a while loop may still be the required type of loop. This problem demonstrates
    why this can be the case.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们有一个字符串，并且我们知道将提供多少输入，`while` 循环仍然可能是所需的循环类型。这个问题展示了为什么会出现这种情况。
- en: This is DMOJ problem coci08c3p2.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 coci08c3p2。
- en: The Challenge
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Luka is writing a secret sentence in class. He doesn’t want the teacher to be
    able to read it, so instead of writing down the original sentence, he writes down
    an encoded version. After each vowel in the sentence (*a*, *e*, *i*, *o*, or *u*),
    he adds the letter *p* and that vowel again. For example, rather than write down
    the sentence *i like you*, he would write *ipi lipikepe yopoupu*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Luka 在课堂上写下一个秘密句子。他不想让老师读懂这个句子，所以他没有写下原句，而是写下了一个编码版本。在句子中的每个元音（*a*、*e*、*i*、*o*
    或 *u*）后面，他加上字母 *p* 和该元音的重复。例如，他不会写下句子 *i like you*，而是写 *ipi lipikepe yopoupu*。
- en: The teacher acquires Luka’s encoded sentence. Recover Luka’s original sentence
    for the teacher.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 老师获取了 Luka 编码后的句子。帮助老师恢复 Luka 的原始句子。
- en: Input
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input is one line of text, Luka’s encoded sentence. It consists of lowercase
    letters and spaces. There is exactly one space between each pair of words. The
    maximum length of the line is 100 characters.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一行文本，即 Luka 的编码句子。它由小写字母和空格组成。每对单词之间恰好有一个空格。该行的最大长度为 100 个字符。
- en: Output
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output Luka’s original sentence.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 Luka 的原始句子。
- en: Another Limitation of for loops
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环的另一个局限性
- en: In [Chapter 3](ch03.xhtml#ch03), we learned how for loops can be used to process
    strings. A for loop plods through the string, from beginning to end, one character
    at a time. In many cases, that’s precisely what we want. In Three Cups, for example,
    we needed to look at each swap from left to right, so we used a for loop over
    the string of swaps.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.xhtml#ch03)中，我们学习了如何使用 for 循环处理字符串。for 循环从头到尾逐个字符地遍历字符串。在许多情况下，这正是我们想要的。例如，在“三杯”中，我们需要从左到右查看每一个交换，因此我们对交换字符串使用了
    for 循环。
- en: 'In other cases, that’s too restrictive, and a range for loop may be more appropriate.
    A range for loop gives us access to indices rather than characters. It also allows
    us to skip through a sequence with whatever step size we choose. For example,
    we can use a range for loop to visit every third character of a string:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，这种方式太过限制，使用 range for 循环可能更为合适。range for 循环让我们能够访问索引而不是字符，它还允许我们选择任意步长跳过序列中的元素。例如，我们可以使用
    range for 循环访问字符串中的每第三个字符：
- en: '>>> s = ''zephyr'''
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''zephyr'''
- en: '>>> for i in range(0, len(s), 3):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(0, len(s), 3):'
- en: '...     print(s[i])'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(s[i])'
- en: '...'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: z
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: z
- en: h
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: h
- en: 'We can also use a range for loop to process a string from right to left instead
    of left to right:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 range for 循环从右到左处理字符串，而不是从左到右：
- en: '>>> for i in range(len(s) - 1, -1, -1):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(len(s) - 1, -1, -1):'
- en: '...     print(s[i])'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(s[i])'
- en: '...'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: r
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: r
- en: y
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: h
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: h
- en: p
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: p
- en: e
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: e
- en: z
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: z
- en: All of this assumes that we want to step by a fixed amount on each iteration.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切假设我们在每次迭代时都希望按照固定的步长进行跳跃。
- en: What if sometimes we want to move one character to the right and other times
    we want to move three characters to the right? That’s not at all farfetched. In
    fact, if we could do that, then we’d be well on our way to solving Secret Sentence.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有时我们想向右移动一个字符，而其他时候我们想向右移动三个字符呢？这并不是不可能的。事实上，如果我们能够做到这一点，那么我们就可以很好地解决 Secret
    Sentence 问题。
- en: 'To see why, consider this test case:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么，考虑这个测试案例：
- en: ipi lipikepe yopoupu
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ipi lipikepe yopoupu
- en: Imagine that we’re reconstructing Luka’s original sentence by copying characters
    to it. The first character in the encoded sentence is the vowel i. This is the
    first character of Luka’s original sentence, too. Based on how Luka encodes sentences,
    we know that the next two characters will be p and i. We don’t want to include
    those in Luka’s original sentence, so we need to skip over them. That is, after
    processing index 0, we want to jump to index 3.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在通过复制字符来重构 Luka 的原始句子。编码句子的第一个字符是元音字母 i，这也是 Luka 原始句子的第一个字符。根据 Luka 编码句子的方式，我们知道接下来的两个字符将是
    p 和 i。我们不希望将这两个字符包含在 Luka 的原始句子中，因此需要跳过它们。也就是说，在处理完索引 0 后，我们希望跳到索引 3。
- en: Index 3 is a space character. Since it isn’t a vowel, we copy this character
    as is to Luka’s original sentence and then move to index 4\. Index 4 is l, another
    nonvowel, so we copy that too and move to index 5\. Here at index 5 we have a
    vowel; after copying it, we want to jump to index 8.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 索引 3 是一个空格字符。由于它不是元音字母，我们将这个字符按原样复制到 Luka 的原始句子中，然后移动到索引 4。索引 4 是字母 l，另一个非元音字母，因此我们也将它复制过去，并移动到索引
    5。在索引 5 处，我们有一个元音字母；复制后，我们希望跳到索引 8。
- en: What’s the step size here? Sometimes we jump by three, but not always. And sometimes
    we jump by one, but not always. It’s a mix of threes and ones. for loops are not
    designed for this kind of processing.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的步长是多少？有时我们跳跃三个位置，但并非总是如此。有时我们跳跃一个位置，但也不总是如此。这是三步和一步的混合。for 循环并不是为这种处理方式设计的。
- en: With a while loop, we can zip around a string however we please, unencumbered
    by predefined step sizes.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 while 循环，我们可以按自己喜欢的方式在字符串中跳跃，不受预定义步长的限制。
- en: while Loops Through Indices
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环通过索引
- en: 'Writing a while loop that loops through string indices isn’t any different
    from writing any other kind of while loop. We just need to incorporate the string’s
    length. Here’s how we can loop through each character of a string from left to
    right:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个遍历字符串索引的 while 循环与编写任何其他类型的 while 循环没有区别。我们只需要结合字符串的长度。下面是如何从左到右遍历字符串中的每个字符：
- en: '>>> s = ''zephyr'''
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''zephyr'''
- en: '>>> i = 0'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '❶ >>> while i < len(s):'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ >>> while i < len(s):'
- en: '...     print(''We have '' + s[i])'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''We have '' + s[i])'
- en: '...     i = i + 1'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1'
- en: '...'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: We have z
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 z
- en: We have e
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 e
- en: We have p
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 p
- en: We have h
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 h
- en: We have y
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 y
- en: We have r
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 r
- en: The variable i allows us to access each character of the string. It begins at
    0 and increases by one each time through the loop.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 i 使我们能够访问字符串中的每个字符。它从 0 开始，每次循环时增加 1。
- en: 'I used < in the loop’s Boolean expression ❶ to continue as long as we haven’t
    reached the length of the string. Had I used <= instead of <, we’d have received
    an IndexError:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我在循环的布尔表达式 ❶ 中使用了 <，以便在我们还没有到达字符串的长度时继续循环。如果我使用 <= 而不是 <，我们会遇到一个 IndexError
    错误：
- en: '>>> i = 0'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '>>> while i <= len(s):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i <= len(s):'
- en: '...     print(''We have '' + s[i])'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''我们有 '' + s[i])'
- en: '...     i = i + 1'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1'
- en: '...'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: We have z
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 z
- en: We have e
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 e
- en: We have p
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 p
- en: We have h
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 h
- en: We have y
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 y
- en: We have r
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 r
- en: 'Traceback (most recent call last):'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 2, in <module>
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 2 行，在 <module> 中
- en: 'IndexError: string index out of range'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: IndexError：字符串索引超出范围
- en: The length of the string is 6\. We get this error because the loop tries to
    access s[6], which is not a valid index in the string.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的长度是 6。我们得到这个错误是因为循环尝试访问 s[6]，而这是一个无效的索引。
- en: 'Want to loop through the string jumping by three characters at a time instead
    of one? No problem; just increase i by 3 instead of 1:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 想要以每次跳过三个字符的方式遍历字符串，而不是一个字符一个字符地遍历？没问题；只需将 i 增加 3 而不是 1：
- en: '>>> i = 0'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '>>> while i < len(s):'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < len(s):'
- en: '...     print(''We have '' + s[i])'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''我们有 '' + s[i])'
- en: '...     i = i + 3'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 3'
- en: '...'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: We have z
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 z
- en: We have h
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 h
- en: 'We can also go from right to left instead of left to right. We have to start
    at len(s) - 1 instead of 0, and we have to decrease i on each iteration rather
    than increase it. We also have to change the loop’s Boolean expression to detect
    when we’re at the beginning of the string rather than the end. Here’s how we go
    from right to left, looping through each character:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从右向左遍历，而不是从左向右。我们必须从 len(s) - 1 开始，而不是从 0 开始，并且每次迭代时必须减少 i，而不是增加它。我们还必须改变循环的布尔表达式，以便检测何时到达字符串的开头，而不是结尾。以下是如何从右向左遍历，每次遍历一个字符：
- en: '>>> i = len(s) - 1'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = len(s) - 1'
- en: '>>> while i >= 0:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i >= 0:'
- en: '...     print(''We have '' + s[i])'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''我们有 '' + s[i])'
- en: '...     i = i - 1'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i - 1'
- en: '...'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: We have r
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 r
- en: We have y
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 y
- en: We have h
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 h
- en: We have p
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 p
- en: We have e
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 e
- en: We have z
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 z
- en: 'A final use case for a while loop on a string: stopping at the first index
    that meets some criterion.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串使用 while 循环的最后一个用例：在满足某个条件时停止在第一个索引。
- en: 'The strategy is to use the Boolean and operator to continue while there are
    more characters to check and we haven’t yet met our criterion. For example, here
    is how we can find the index of the first ''y'' in a string:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用布尔“与”运算符，在仍有更多字符需要检查且尚未满足我们的标准时继续循环。例如，以下是我们如何找到字符串中第一个'y'的索引：
- en: '>>> i = 0'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '>>> while i < len(s) and s[i] != ''y'':'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < len(s) and s[i] != ''y'':'
- en: '...     i = i + 1'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1'
- en: '...'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> print(i)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(i)'
- en: '4'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'If there’s no ''y'' anywhere in the string, the loop stops when i equals the
    string length:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串中没有 'y'，循环在 i 等于字符串的长度时停止：
- en: '>>> s = ''breeze'''
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''breeze'''
- en: '>>> i = 0'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '>>> while i < len(s) and s[i] != ''y'':'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < len(s) and s[i] != ''y'':'
- en: '...     i = i + 1'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1'
- en: '...'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> print(i)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(i)'
- en: '6'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: When i refers to 6, the first operand of and is False, so the loop terminates.
    You might wonder why the second operand of and doesn’t cause an error here, since
    index 6 is not a valid index in the string. The reason is that the Boolean operators
    use *short-circuiting evaluation*, which means that they stop evaluating their
    operands if the result of the operator is already known. For and, if the first
    operand is False, then we know that, no matter what the second operand is, and
    will return False; Python therefore doesn’t evaluate the second operand. Similarly,
    for or, if the first operand is True, then or is guaranteed to return True, so
    Python doesn’t evaluate the second operand.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 当 i 为 6 时，“与”运算符的第一个操作数为 False，因此循环终止。你可能会想为什么“与”运算符的第二个操作数没有导致错误，因为索引 6 不是字符串中的有效索引。原因是布尔运算符使用*短路求值*，这意味着如果运算符的结果已经可以确定，它们就会停止求值它们的操作数。对于“与”运算符，如果第一个操作数为
    False，那么我们知道无论第二个操作数是什么，“与”运算符都会返回 False；因此 Python 不会评估第二个操作数。类似地，对于“或”运算符，如果第一个操作数为
    True，那么“或”运算符一定会返回 True，因此 Python 不会评估第二个操作数。
- en: Solving the Problem
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Now we know how to use a while loop to loop through a string.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用 while 循环遍历字符串。
- en: For Secret Sentence, we need to do something different depending on whether
    we’re looking at a vowel or a nonvowel. If we’re looking at a vowel, then we need
    to copy the character and jump ahead by three characters (to skip over the p and
    the second occurrence of this vowel). If we’re looking at a nonvowel, then we
    need to copy the character and move to the next character. So, we always copy
    the current character but then move by three or one based on whether the current
    character is a vowel. We can use an if statement inside the while loop to make
    this decision for each character that we see.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 对于秘密句子，我们需要根据是处理元音还是非元音来做不同的处理。如果我们处理的是元音，那么我们需要复制该字符并跳过三个字符（跳过 p 和该元音的第二次出现）。如果我们处理的是非元音，那么我们需要复制该字符并继续处理下一个字符。因此，我们始终复制当前字符，但根据当前字符是否为元音，分别跳过三或一个字符。我们可以在
    while 循环内部使用 if 语句来为我们看到的每个字符做出这个决定。
- en: A solution for Secret Sentence is in [Listing 4-4](ch04.xhtml#ch04ex04).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 解决秘密句子的方案见[清单 4-4](ch04.xhtml#ch04ex04)。
- en: sentence = input()
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: sentence = input()
- en: ❶ result = ''
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ result = ''
- en: i = 0
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: '❷ while i < len(sentence):'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ while i < len(sentence):'
- en: result = result + sentence[i]
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: result = result + sentence[i]
- en: '❸ if sentence[i] in ''aeiou'':'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if sentence[i] in ''aeiou'':'
- en: i = i + 3
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: i = i + 3
- en: 'else:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: i = i + 1
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: i = i + 1
- en: print(result)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: print(result)
- en: '*Listing 4-4: Solving Secret Sentence*'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：解决秘密句子*'
- en: The result variable ❶ is used to build the original sentence, one character
    at a time.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 结果变量 ❶ 用于一次构建原始句子中的一个字符。
- en: The while loop’s Boolean expression is the standard one for looping until we
    reach the end of a string ❷. In that loop, we first concatenate the current character
    to the end of the result. Then we check whether the current character is a vowel
    ❸. Recall from “Relational Operators” in [Chapter 2](ch02.xhtml#ch02) that the
    in operator can be used to check whether the first string occurs in the second.
    If the current character is found in the string of vowels, we jump ahead by three
    characters; if not, we move to the next character.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环的布尔表达式是标准的，直到我们到达字符串的末尾 ❷。在这个循环中，我们首先将当前字符附加到 result 的末尾。然后我们检查当前字符是否是元音
    ❸。回想一下在[第 2 章](ch02.xhtml#ch02)的“关系运算符”中提到的，in 操作符可以用来检查第一个字符串是否出现在第二个字符串中。如果当前字符在元音字符串中，我们就跳过三个字符；否则，我们继续处理下一个字符。
- en: Once the loop terminates, we have gone through the entire encoded sentence and
    copied the correct characters into result. The last thing to do is therefore to
    output this variable.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环结束，我们就遍历了整个编码句子，并将正确的字符复制到 result 中。因此，最后一步就是输出这个变量。
- en: You’re ready to submit our code to the judge. Grepeapat wopork!
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好将代码提交给评审了。Grepeapat wopork!
- en: break and continue
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: break 和 continue
- en: 'In this section, I’ll show you two other loop keywords that Python supports:
    break and continue. It’s my experience that introducing these keywords leads learners
    to overuse them to the detriment of the clarity of their loops, so I’ve decided
    to avoid them elsewhere in the book. Nonetheless, they are occasionally useful,
    and you’re likely to see them in other Python code, so let’s have a brief discussion.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示 Python 支持的另外两个循环关键字：break 和 continue。根据我的经验，引入这些关键字会导致学习者过度使用它们，从而影响循环的清晰性，因此我决定在本书的其他地方避免使用它们。尽管如此，它们偶尔还是有用的，而且你可能会在其他
    Python 代码中看到它们，所以我们简要讨论一下。
- en: break
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: break
- en: The break keyword immediately terminates a loop, no questions asked.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: break 关键字立即终止循环，毫不犹豫。
- en: Back when we solved Song Playlist, we used a while loop that looped while the
    button was not 4. We could also solve that problem using break; see [Listing 4-5](ch04.xhtml#ch04ex05)
    for the code.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解决歌曲播放列表问题时，我们使用了一个 while 循环，该循环在按钮不是 4 时继续执行。我们也可以使用 break 来解决这个问题；请参见[清单
    4-5](ch04.xhtml#ch04ex05)查看代码。
- en: songs = 'ABCDE'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: songs = 'ABCDE'
- en: '❶ while True:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ while True:'
- en: button = int(input())
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: button = int(input())
- en: '❷ if button == 4:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if button == 4:'
- en: ❸ break
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ break
- en: presses = int(input())
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: presses = int(input())
- en: 'for i in range(presses):'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(presses):'
- en: 'if button == 1:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button == 1:'
- en: songs = songs[1:] + songs[0]
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: songs = songs[1:] + songs[0]
- en: 'elif button == 2:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif button == 2:'
- en: songs = songs[-1] + songs[:-1]
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: songs = songs[-1] + songs[:-1]
- en: 'elif button == 3:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif button == 3:'
- en: songs = songs[1] + songs[0] + songs[2:]
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: songs = songs[1] + songs[0] + songs[2:]
- en: output = ''
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: output = ''
- en: 'for song in songs:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 'for song in songs:'
- en: output = output + song + ' '
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: output = output + song + ' '
- en: print(output[:-1])
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: print(output[:-1])
- en: '*Listing 4-5: Solving Song Playlist using* break'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：使用* break 解决歌曲播放列表'
- en: 'The loop’s Boolean expression ❶ looks suspicious: True is always True, so at
    first glance it seems that this loop never terminates. (That’s the downside to
    break. We can’t just look at the Boolean expression to understand what must happen
    for the loop to terminate.) But it can terminate, because of our use of break.
    If button 4 is pressed ❷, then we hit a break ❸, which terminates the loop.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '循环的布尔表达式 ❶ 看起来很可疑：`True`总是`True`，所以乍一看，似乎这个循环永远不会结束。（这就是`break`的缺点。我们不能仅通过布尔表达式来理解循环的终止条件。）但它是可以终止的，因为我们使用了`break`。如果按下按钮4
    ❷，就会触发`break` ❸，从而终止循环。  '
- en: 'Let’s see one more example of using break. In “while Loops Through Indices”
    in this chapter, we wrote code to find the index of the first ''y'' in a string.
    Here’s how that looks using break:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们再看一个使用`break`的例子。在本章的《while循环通过索引》一节中，我们编写了代码来找到字符串中第一个''y''的索引。这里是使用`break`的实现：  '
- en: '>>> s = ''zephyr'''
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''zephyr''  '
- en: '>>> i = 0'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0  '
- en: '>>> while i < len(s):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < len(s):  '
- en: '...     if s[i] == ''y'':'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if s[i] == ''y'':  '
- en: '...         break'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '...         break  '
- en: '...     i = i + 1'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1  '
- en: '...'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '...  '
- en: '>>> print(i)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(i)  '
- en: '4'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '4  '
- en: 'Again, notice that the loop’s Boolean expression is misleading: it suggests
    that the loop always runs until the end of the string, but further scrutiny reveals
    that a break is lurking and can influence termination.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '再次注意，循环的布尔表达式具有误导性：它看起来表明循环总是会一直运行到字符串的末尾，但进一步分析发现`break`的存在可能会影响终止条件。  '
- en: 'A break terminates only its own loop, not any outer loops. Here’s an example:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 只会终止它自己所在的循环，而不会影响任何外部循环。下面是一个例子：  '
- en: '>>> i = 0'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0  '
- en: '>>> while i < 3:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < 3:  '
- en: '...     j = 10'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '...     j = 10  '
- en: '...     while j <= 50:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '...     while j <= 50:  '
- en: '...         print(j)'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(j)  '
- en: '...         if j == 30:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '...         if j == 30:  '
- en: ❶ ...             break
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ ...             break  '
- en: '...         j = j + 10'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '...         j = j + 10  '
- en: '...     i = i + 1'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1  '
- en: '...'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '...  '
- en: '10'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '10  '
- en: '20'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '20  '
- en: '30'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '30  '
- en: '10'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '10  '
- en: '20'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '20  '
- en: '30'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '30  '
- en: '10'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '10  '
- en: '20'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '30'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '30  '
- en: 'Notice how the break ❶ cuts the j loop short. But it doesn’t affect the i loop:
    there are three iterations of that loop, exactly as there would be without the
    break ❶.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到`break` ❶如何缩短了j循环的执行。但它并不影响i循环：该循环有三个迭代，和没有`break` ❶时完全一样。  '
- en: continue
  id: totrans-701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'continue  '
- en: The continue keyword ends the current iteration of the loop without running
    any more of its code. Unlike break, it does not end the loop altogether. If the
    loop condition is True, then further iterations of the loop occur.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 关键字结束当前迭代而不执行该循环中的其他代码。与`break`不同，它不会完全结束循环。如果循环条件为`True`，那么循环会继续进行下一次迭代。  '
- en: 'Here’s an example that uses continue to print each vowel and its index in a
    string:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一个使用`continue`的例子，它会打印字符串中每个元音字母及其索引：  '
- en: '>>> s = ''zephyr'''
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''zephyr''  '
- en: '>>> i = 0'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0  '
- en: '>>> while i < len(s):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < len(s):  '
- en: '❶ ...     if not s[i] in ''aeiou'':'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ ...     if not s[i] in ''aeiou'':  '
- en: '...         i = i + 1'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '...         i = i + 1  '
- en: ❷ ...         continue
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ ...         continue  '
- en: ❸ ...     print(s[i], i)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ ...     print(s[i], i)  '
- en: '...     i = i + 1'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1  '
- en: '...'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '...  '
- en: e 1
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 'e 1  '
- en: If the current character is not a vowel ❶, then we don’t want to print it. So,
    we increase i by 1 to take us past this character and then use continue ❷ to end
    the current iteration. If we get below the if statement ❸, then it must mean that
    we’re looking at a vowel (otherwise continue would have prevented us from getting
    here). We therefore output that character and increase i by 1 to take us past
    this character.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '如果当前字符不是元音 ❶，那么我们不想打印它。因此，我们增加i的值，将其移到下一个字符，然后使用`continue` ❷结束当前的迭代。如果我们进入`if`语句
    ❸，那么这意味着我们正在查看一个元音（否则`continue`会阻止我们到达这里）。所以，我们打印该字符并将i增加1，跳过当前字符。  '
- en: 'The continue keyword is enticing because it seems to give us a way to get us
    out of an iteration that we don’t want to be in. “This isn’t a vowel. I’m out
    of here!” But an if statement can also be used to obtain the same behavior, and
    the logic is often clearer:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 关键字非常吸引人，因为它似乎为我们提供了一种跳出不想执行的迭代的方式。“这不是元音，我走了！”但是，也可以使用`if`语句来实现相同的行为，而且逻辑通常更加清晰：  '
- en: '>>> s = ''zephyr'''
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''zephyr''  '
- en: '>>> i = 0'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0  '
- en: '>>> while i < len(s):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while i < len(s):  '
- en: '...     if s[i] in ''aeiou'':'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if s[i] in ''aeiou'':  '
- en: '...         print(s[i], i)'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(s[i], i)  '
- en: '...     i = i + 1'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '...     i = i + 1  '
- en: '...'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '...  '
- en: e 1
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 'e 1  '
- en: Rather than skip the iteration when the current character is not a vowel, the
    if statement processes it when it *is* a vowel.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '与其在当前字符不是元音时跳过该迭代，不如让`if`语句在它*是*元音时处理它。  '
- en: Summary
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '总结  '
- en: The unifying feature of the problems in this chapter is that we don’t know in
    advance how many iterations of a loop will be required.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '本章问题的统一特点是我们事先并不知道循环需要多少次迭代。  '
- en: '**Slot Machines** The number of iterations depends on the initial number of
    quarters and the payouts of the slot machines.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**老虎机** 迭代次数取决于最初的硬币数量和老虎机的支付金额。'
- en: '**Song Playlist** The number of iterations depends on how many buttons were
    pressed.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**歌曲播放列表** 迭代次数取决于按下了多少个按钮。'
- en: '**Secret Sentence** The number of iterations, and what to do on each iteration,
    depends on where vowels are located in a string.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**秘密句子** 迭代次数以及每次迭代要做什么，取决于元音在字符串中的位置。'
- en: When the number of iterations is unknown, we turn to the while loop, which runs
    as long as needed. Using a while loop is more error-prone than code that uses
    a for loop. It’s also more flexible, as we are freed from the for loop constraint
    of systematically looping through a sequence.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代次数未知时，我们使用 `while` 循环，它会根据需要一直运行。使用 `while` 循环比使用 `for` 循环的代码更容易出错，但它也更加灵活，因为我们不再受到
    `for` 循环要求系统性地遍历序列的限制。
- en: 'In the next chapter, we’ll learn about lists, which allow us to store large
    amounts of numeric or string data. And how do you suppose we’ll process all of
    that data? Yes: loops! Practice the following exercises to hone your loop skills.
    You’ll be using them a lot when we solve problems using lists.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习列表，它允许我们存储大量的数字或字符串数据。那么，我们打算如何处理这些数据呢？没错：使用循环！练习以下练习以提高你的循环技能。我们在使用列表解决问题时会频繁用到它们。
- en: Chapter Exercises
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: 'You now have three types of loops at your disposal: for loops, range for loops,
    and while loops. Part of the challenge of solving problems using loops is knowing
    which loop to use! For each of the following exercises, experiment with using
    different types of loops to arrive at the solution that you like best.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有三种类型的循环可以使用：`for` 循环、`range` 循环和 `while` 循环。使用循环解决问题的挑战之一是知道该使用哪种循环！在接下来的练习中，尝试使用不同类型的循环来找到你最喜欢的解决方案。
- en: 1.  DMOJ problem ccc20j2, Epidemiology
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 1. DMOJ 问题 ccc20j2, 流行病学
- en: DMOJ problem coci08c1p2, Ptice
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 coci08c1p2, Ptice
- en: DMOJ problem ccc02j2, AmeriCanadian
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ccc02j2, 美加
- en: DMOJ problem ecoo13r1p1, Take a Number
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ecoo13r1p1, 拿一个数字
- en: DMOJ problem ecoo15r1p1, When You Eat Your Smarties
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ecoo15r1p1, 当你吃糖果时
- en: DMOJ problem ccc19j3, Cold Compress
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ccc19j3, 冷敷
- en: Notes
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Slot Machines is originally from the 2000 Canadian Computing Competition, Junior/Senior
    Level. Song Playlist is originally from the 2008 Canadian Computing Competition,
    Junior Level. Secret Sentence is originally from the 2008/2009 Croatian Open Competition
    in Informatics, Contest 3.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎机最初来源于2000年加拿大计算机竞赛的初级/高级组。歌曲播放列表最初来源于2008年加拿大计算机竞赛的初级组。秘密句子最初来源于2008/2009年克罗地亚信息学开放竞赛，第三场竞赛。
