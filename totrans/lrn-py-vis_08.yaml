- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries and JSON
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Dictionaries hold collections of items, similar to the ordered lists you learned
    about in Chapter 7. Dictionaries, however, are unordered, and you use an associated
    value to access each item, which makes it easier to remember what the items in
    your dictionary represent. In this chapter, you’ll learn about Python’s dictionary
    syntax and methods, how to combine loops and dictionaries, and how to nest dictionaries
    and lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also learn how to work with another plaintext file format: *JavaScript
    Object Notation (JSON)*. The syntax isn’t quite as simple as CSV, but it’s better
    suited for handling more complex data structures. You’ll use Python’s built-in
    *json* module to read in dictionary data from a JSON file, and as in Chapter 7,
    you’ll then create a data visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a dictionary, each unordered item is associated with a value called a *key*.
    A key is usually a short string, and each dictionary item is composed of a key-value
    pair. This means dictionaries are associative, and some programming languages
    refer to dictionary-type structures as *associative arrays*. Dictionaries are
    different from lists, which are numerically indexed, because each element in a
    list corresponds to a number (index) indicating its position in a sequence of
    items.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how key-value pairs work, you might use a dictionary to note
    the favorite movie of each of your friends. In such a dictionary, each key would
    be a friend’s name, and each value would be a corresponding film title. To insert
    or retrieve your friend Lee’s favorite movie, you’d use the key `'Lee'`. [Figure
    8-1](#figure8-1) is a conceptual diagram of this dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](image_fi/500969c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: A diagram of a dictionary indicating the mapping between keys and
    values'
  prefs: []
  type: TYPE_NORMAL
- en: 'For your first exercise in working with Python dictionaries, you’ll write code
    to manage student records. Create a new sketch named *dictionaries*, andadd the
    following code that shows the difference between a list and dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, note that dictionaries use curly brackets (`{}`), whereas lists use
    square brackets (`[]`). The list 1 and dictionary 2 variants store the same values:
    `''Sam''` and `24`. However, each dictionary item includes a value *and* a key.
    In this instance, the dictionary keys are `''name''` and `''age''`. Keep in mind
    that sensibly named keys help identify what the values represent. This `student`
    dictionary holds two key-value pairs ([Figure 8-2](#figure8-2)).'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the meaningfully named keys to retrieve values from the `student`
    dictionary. To use the `student` list, you would need to recall the seemingly
    arbitrary positions for each value. Lists are better at handling an ordered sequence
    of items, but if you have a set of unique keys that map to values, use a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](image_fi/500969c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: A dictionary with two key-value pairs'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries can hold all types of data, including strings, numbers, Booleans,
    lists, and even other dictionaries. You can store as many key-value pairs as you
    like in a dictionary. Technically speaking, there is an upper limit, but if you’re
    managing such large volumes of data, you should probably look at a database solution.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access any dictionary value, use the dictionary name along with the associated
    key in square brackets. Try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The comments alongside each `print()` function confirm what should appear in
    your console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the entire dictionary, omit the square brackets and key, leaving only
    the dictionary name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The console should display every key-value pair, complete with the curly brackets,
    colons, and commas.
  prefs: []
  type: TYPE_NORMAL
- en: The order of the key-value pairs won’t always match the order in which you defined
    them, and this can vary among Python environments. Dictionaries are inherently
    orderless; Python is concerned with the connections between the keys and values.
    If you need to order your dictionary items—by key or value—you can use various
    functions and methods. You’ll see some sorting techniques in “Combining Loops
    and Dictionaries” on page 163.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to reference a nonexistent key—say, `student[''grade'']`—Processing
    displays a `KeyError` message. If you need to check whether a key exists, use
    the `in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `in` checks whether the `'age'` key exists in the `student` dictionary.
    If found, the operation returns `True`, and the `if` statement executes the `print`
    line displaying the `age` value (which is `24` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dictionaries are dynamic structures, so you can add and modify key-value pairs
    as you please. To change an existing value, reassign it as you would a list element,
    but use the key as opposed to a numeric index. To illustrate, in your *dictionaries*
    sketch, change the student’s age to `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The console output should confirm that the age has changed from `24` to `25`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new key-value pair, follow the same process. Add a student ID number
    to the `student` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `id` value here represents a birth date (1995-05-01) 1. The system can
    use this information to calculate the student’s age, so now it’s no longer necessary
    to store the individual’s `age` value. To remove this, use the `del` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `del` statement permanently removes the `age` key and its corresponding
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Dictionaries and Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionaries can hold other dictionaries or lists, and lists also can hold
    dictionaries. Let’s look at two examples: a dictionary of lists, and a list of
    dictionaries. Both are valid ways to structure data, but as you’ll see, you’ll
    choose one depending on which works best in your particular application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your program stores the details of a single student. A system
    that can manage just one student isn’t very useful, so to handle multiple students,
    try a *dictionary of lists*. Add the following code to the bottom of your *dictionaries*
    sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `names` list item holds a list of two names 1; the `ids` list holds their
    respective ID numbers 2. To access any list element directly within a dictionary
    item, use the associated key followed by a second pair of square brackets containing
    the element index 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach to structuring this data is with a *list of dictionaries*.
    Rather than separating the student names into one list and the IDs into another,
    you could use a dictionary for each student. Add the following code to the bottom
    of your sketch, effectively overwriting the former `students` dictionary entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This retrieves the name `Lee` by using an element index, followed by another
    pair of square brackets containing the dictionary key 1.
  prefs: []
  type: TYPE_NORMAL
- en: The latter of the two approaches (the list of dictionaries) is arguably the
    more sensible structure in this scenario. Each item is like a row in a spreadsheet
    that contains the details for a single student, and each student may have a different
    number of columns. This means you can add an extra key-value pair to Sam’s dictionary
    without having to do the same for Lee. Doing this, however, would be tricky using
    the first approach.
  prefs: []
  type: TYPE_NORMAL
- en: What you name your keys and how you elect to nest lists and dictionaries should
    help relate your data to real-world models while reducing complexity. Keep your
    key names short and descriptive, and bear in mind that well-structured data will
    make for more self-evident algorithms further along in your program. In other
    words, you’ll end up saving time and energy writing code if it’s structured around
    intuitively organized data.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Loops and Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll often want to loop through your dictionaries. For example, you could
    dynamically generate reports for every student in your system by using a single
    loop to populate a predefined template. Considering that a dictionary can hold
    thousands or even millions of key-value pairs, this is a powerful technique. Because
    of the key-value system, though, iterating dictionaries is a little different
    from iterating lists.
  prefs: []
  type: TYPE_NORMAL
- en: You can iterate a dictionary’s keys, values, or key-value pairs with Python’s
    `keys()`, `values()`, and `items()` methods. Note that many list methods—such
    as `append()`, `extend()`, `index()`, `insert()`, and `remove()`—do not work on
    the dictionary data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, add a new dictionary, named `courses`, to the end of your *dictionaries*
    sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary keys represent course titles; the associated values are the professors
    who coordinate each course. Next, you’ll look at ways to combine this dictionary
    with `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can write a `for` loop that deals only with keys, which is useful if you
    don’t need to work with the values in your dictionary. Key iteration happens implicitly
    wherever you use a `for...in` line with a dictionary. Test this behavior in the
    following example, which should display all of the course titles in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With each iteration, Python assigns the next key in `courses` to `course`.
    The `print` line displays each course title on its own line in the console, and
    the loop is complete after all of the keys are exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that you cannot rely on the ordering of dictionary items. If you want
    to ensure that keys are retrieved in alphanumeric order, wrap a `sorted()` function
    around `courses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The amended `for` line prints the keys in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you simply need a list of keys, use the `keys()` method, and to sort them,
    include a `sorted()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This prints a list of the keys in the console, complete with square brackets
    and commas.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `values()` method returns all of a dictionary’s values, which is useful
    if you don’t need to work with the keys in your dictionary. Add a new loop to
    your sketch, using the `values()` method to retrieve the names of each professor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With each iteration, Python assigns the next value in `courses` to `prof`. I’ve
    named this variable `prof` as an abbreviation for *professor* (representing the
    value it will hold). The `print` line displays the name of each course’s professor
    on a new line in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often you’ll want both the dictionary key and the corresponding value for your
    loop. The `items()` method returns all of the dictionary’s key-value pairs. Before
    writing any loop code, print the items in your `courses` dictionary by using the
    `items()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the console output (it doesn’t fit on a single line, which is indicated
    with the ellipsis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to identify each key-value pair, grouped within parentheses.
    The parentheses surrounding each key-value pair denote a *tuple*. This book does
    not cover tuples in detail, so for now, consider them interchangeable with lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this loop to print each key-value tuple on its own line in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When you use an `items()` method with a `for` loop, Python is assigning a tuple
    to your loop variable. I’ve named this `kv` as an abbreviation for *key-value*,
    but you could name it whatever you like. For example, on the *code art* iteration,
    `kv` is equal to `('code art', 'Prof. Sato')`. Run the sketch to confirm that
    the console displays each key-value pair, complete with parentheses and commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make iterating dictionary items more convenient, Python allows you to include
    two variables between the `for` and `in`, one for the key and one for the corresponding
    value. You can name these variables whatever you like, but the order of assignment
    is always *key* first, *value* second; this matches the ordering in the tuple.
    Add this example to assign the course title and professor to separate variables.
    Additionally, this code includes a `sorted()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With each iteration, Python assigns the key (course title) to the first variable
    1 and the value (professor name) to the second variable 2. The console should
    display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `sorted()` function always operates on keys, so the sentences
    are ordered alphabetically by course title, not professor. To reverse the order,
    add a `reversed()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `code art` course will be listed as the last line in your console.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript Object Notation was derived from JavaScript, but it’s a language-independent
    data format. Many programming languages support JSON, Python included, and it’s
    popular for web development. You can use JSON to store dictionary-like data in
    plaintext files, with key-value pairs, to construct nested dictionary- and list-style
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, you’ll use JSON to format data in a plaintext file, just
    as you did with CSV in Chapter 7, except with a different syntax and the *.json*
    file extension. Python’s built-in *json* module will handle the data you read
    in. As mentioned previously, JSON syntax isn’t quite as simple as CSV, but it’s
    more descriptive and versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JSON Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand how JSON syntax works, let’s contrast it with CSV. In Chapter
    7, you stored an album track list (for *The Dark Side of the Moon*) in CSV format.
    Here’s an abridged version of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line contains the field headings. Lines 2 and beyond provide the details
    of each track.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same (abridged) track list formatted as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each value has a corresponding key—just like a Python dictionary! If you study
    the code, you’ll realize that it looks like a list of dictionaries written in
    Python. However, subtle differences exist between JSON and Python’s data structure
    syntax. For instance, with JSON, you must use double quotes for strings; in Python,
    you have the option of single quotes. The terminology is a little different too.
    In JSON, curly brackets denote an object (not a dictionary), and square brackets
    define an array (not a list). What you name your keys and how you nest your elements
    is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a track list for an individual album, every track has the same
    `creator` and `album` information, which seems redundant. To avoid repetition,
    you can restructure your JSON as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The new structure nests the tracks within `tracklist`. The `creator` and `album`
    information is placed at the top level of the structure because it applies to
    every track.
  prefs: []
  type: TYPE_NORMAL
- en: You can write your own JSON data, generate it dynamically, or source it online.
  prefs: []
  type: TYPE_NORMAL
- en: Using Web APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vast repositories of JSON data, ranging from music metadata to cat facts, are
    available via web APIs. A *web application programming interface (API)* is a web-based
    service you can use to request or post data. For example, you might request data
    from the Twitter API to generate a graph measuring your tweet frequency or to
    program a Twitter bot that autonomously posts tweets of your code art.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book doesn’t cover how to use web APIs. However, if you want to explore
    web APIs, you should know a couple of things. Each API works slightly differently,
    which means you’ll need to refer to the service-specific developer documentation.
    Many APIs are accessible directly via a URL, which allows you to interface with
    them by using your web browser. For example, *OpenAQ* provides air-quality data
    from around the world. If you enter the following URL into your web browser, you’ll
    get a JSON summary of the air-quality data for every city in Norway: [https://api.openaq.org/v1/cities?country=NO](https://api.openaq.org/v1/cities?country=NO).'
  prefs: []
  type: TYPE_NORMAL
- en: The *api.openaq.org* part is the API domain name. The */v1* indicates that you
    are using version 1, the first release of the API. The */cities* part requests
    the data for every city in OpenAQ’s database, but the *?country=NO* limits the
    cities to those located in Norway. For a copy of the data, use the **Save Page
    As** option in your browser menu, or copy and paste the contents into any plaintext
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: You’re also likely to come across APIs that provide CSV and XML data.
  prefs: []
  type: TYPE_NORMAL
- en: CSV, JSON, and XML have their own strengths and weaknesses, so weigh the relative
    merits of each format when considering what’s best for your projects. The beauty
    of CSV lies in its simplicity, but it cannot support hierarchically structured
    data. Unlike JSON, which allows you to nest objects within objects several levels
    deep, CSV limits you to a single value per field. XML is an established, widely
    supported, and flexible data exchange format, but it can be overly complex and
    bloated at times. JSON provides somewhat of a middle ground, and it has become
    increasingly popular on the web, as its syntax is more concise than XML’s.
  prefs: []
  type: TYPE_NORMAL
- en: Reading in JSON Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read in JSON data when your sketch runs. In this example, you’ll use
    coffee data stored in a JSON file to generate a chart. Create a new sketch named
    *coffee_chart* with a *data* subfolder, and then complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to *chapter-08-dictionaries_and_json*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the *data.zip* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP archive, and move *coffees.json* to the sketch *data* subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a snippet of the *coffees.json* file contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each top-level object holds the details for a different type of coffee. This
    code shows two types of coffee: `Espresso` and `Irish Coffee`. These are the first
    and last recipes; there are nine types of coffee in all. Each `ingredient` object
    has three key-value pairs: an ingredient name 1, quantity in milliliters 2, and
    fill color 3. Note that these quantities are not necessarily accurate, so the
    final chart might not impress baristas and coffee aficionados, but it will look
    pretty cool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to load the data from the *coffees.json* file. Python’s `open()`
    function can open any file, plaintext or otherwise, and return a file object.
    For a JSON file, load the file object into a Python data structure by using the
    built-in *json* module. Add this code to your sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` line imports the *json* module. The `open()` function opens the
    JSON file and assigns the file object to the variable `jsondata`. The `json.load()`
    function converts the JSON to Python data. To confirm it’s working, print the
    quantity of whiskey in the Irish Coffee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Irish Coffee is the last element in a list of nine coffees; hence, it has
    an index of `8`. The whiskey content is the second ingredient (`['ingredients'][1]`).
    The final `['quantity']` represents the quantity value of the ingredient, 40 milliliters.
  prefs: []
  type: TYPE_NORMAL
- en: When you retrieved CSV data by using `loadStrings()`, everything was data-typed
    as a string, numbers included. You had to convert values to integers by using
    the `int()` function before performing any arithmetic; to create lists, you had
    to use a `split()` function. The *json* module, however, handles all of this conversion
    for you. A JSON value like `40`, with no decimal point or quotation marks, is
    interpreted as an integer; comma-separated values within square brackets are turned
    into Python lists automatically; and so forth. Now that you can access the data
    in Python, you can use it to render a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #9: Coffee Chart'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll visualize the data for all nine coffees by using nine mugs arranged in
    a 3 × 3 grid fashion. [Figure 8-3](#figure8-3) shows a screenshot of the final
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08003](image_fi/500969c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: The complete coffee chart'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to define a display window size, background color, and
    some variables, and to lay out nine empty mugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The lines above the `for` line define the main parameters for the sketch, such
    as the display window size and background color. The `mug` and `spacing` variables
    control the mug sizing and spacing, respectively; the `col` variable serves as
    a column counter. Comments within the `for` loop indicate where the mug and label
    drawing code begins. After drawing each mug 3, Processing translates the drawing
    space 230 pixels to the right and adds 1 to `col`. When `col` reaches 3 2 (every
    third mug), the drawing space is shifted back to the left edge of the display
    window and down one row, and `col` resets to 1\. The ingredients code has been
    left for you to complete; the comment indicates where you should write it 1.
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. You should see nine empty mugs with labels. Now, complete the
    chart so it looks like [Figure 8-3](#figure8-3). If you need help, you can access
    the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-08-dictionaries_and_json/coffee_chart/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-08-dictionaries_and_json/coffee_chart/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to organize a collection of items in a dictionary
    that can associate values with meaningfully named keys. Furthermore, you combined
    dictionaries and lists to create more intuitive data structures. You also learned
    how to define, access, modify, and nest dictionaries, and how to loop through
    dictionaries by using keys, then values.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced you to JSON. You learned how it’s similar to Python
    dictionaries and lists, and how to read in JSON data. You can store dictionary
    and list data in JSON files to separate your Python code from your data. If you’re
    looking for interesting data to work with, many online sources host JSON datasets
    that you can access for free.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 9, you’ll learn how to define and work with functions, which are
    named sections of code. You decide what to name your functions, and whenever you
    want to run a function, you call it by its name. This helps reduce repetition
    in your code because you can repeat a one-line function call instead of many lines
    of code. Think of functions as reusable blocks of code that will make your sketches
    more efficient and easier to maintain. You’ll write functions, including some
    to generate elliptical and wave-like motion, and then you’ll use these functions
    to program animated effects that employ trigonometry.
  prefs: []
  type: TYPE_NORMAL
