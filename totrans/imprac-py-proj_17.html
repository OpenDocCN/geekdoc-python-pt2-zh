<html><head></head><body>
<h2 class="h2" id="appendix"><span epub:type="pagebreak" id="page_367"/>PRACTICE PROJECT SOLUTIONS</h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">This appendix provides the solutions to the practice projects in each chapter. Digital versions are available on the book’s website at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h3 class="h3" id="lev397"><strong>Chapter 1: Silly Name Generator</strong></h3>
<h4 class="h4" id="lev398"><strong><em>Pig Latin</em></strong></h4>
<p class="margin"><em>pig_Latin_practice.py</em></p>
<pre>"""Turn a word into its Pig Latin equivalent."""<br/>import sys<br/><br/>VOWELS = 'aeiouy'<br/><br/>while True:<br/>    word = input("Type a word and get its Pig Latin translation: ")<br/><br/>    if word[0] in VOWELS:<br/>        pig_Latin = word + 'way'<br/><span epub:type="pagebreak" id="page_368"/>    else:<br/>        pig_Latin = word[1:] + word[0] + 'ay'<br/>    print()<br/>    print("{}".format(pig_Latin), file=sys.stderr)<br/><br/>    try_again = input("\n\nTry again? (Press Enter else n to stop)\n ")<br/>    if try_again.lower() == "n":<br/>        sys.exit()</pre>
<h4 class="h4" id="lev399"><strong><em>Poor Man’s Bar Chart</em></strong></h4>
<p class="margin"><em>EATOIN_practice.py</em></p>
<pre>"""Map letters from string into dictionary &amp; print bar chart of frequency."""<br/>import sys<br/>import pprint<br/>from collections import defaultdict<br/><br/># Note: text should be a short phrase for bars to fit in IDLE window<br/>text = 'Like the castle in its corner in a medieval game, I foresee terrible \<br/>trouble and I stay here just the same.'<br/><br/>ALPHABET = 'abcdefghijklmnopqrstuvwxyz'<br/><br/># defaultdict module lets you build dictionary keys on the fly!<br/>mapped = defaultdict(list)<br/>for character in text:<br/>    character = character.lower()<br/>    if character in ALPHABET:<br/>        mapped[character].append(character)<br/><br/># pprint lets you print stacked output<br/>print("\nYou may need to stretch console window if text wrapping occurs.\n")<br/>print("text = ", end='')<br/>print("{}\n".format(text), file=sys.stderr)<br/>pprint.pprint(mapped, width=110)</pre>
<h3 class="h3" id="lev400"><strong>Chapter 2: Finding Palingram Spells</strong></h3>
<h4 class="h4" id="lev401"><strong><em>Dictionary Cleanup</em></strong></h4>
<p class="margin"><em>dictionary_cleanup_practice.py</em></p>
<pre>"""Remove single-letter words from list if not 'a' or 'i'."""<br/>
word_list = ['a', 'nurses', 'i', 'stack', 'b', 'c', 'cat']<br/>
word_list_clean = []<br/>
<br/>
permissible = ('a', 'i')<br/>
<br/>
for word in word_list:<br/>
<span epub:type="pagebreak" id="page_369"/>    if len(word) &gt; 1:<br/>
        word_list_clean.append(word)<br/>
    elif len(word) == 1 and word in permissible:<br/>
        word_list_clean.append(word)<br/>
    else:<br/>
        continue<br/>
<br/>
print("{}".format(word_list_clean))</pre>
<h3 class="h3" id="lev402"><strong>Chapter 3: Solving Anagrams</strong></h3>
<h4 class="h4" id="lev403"><strong><em>Finding Digrams</em></strong></h4>
<p class="margin"><em>count_digrams_practice.py</em></p>
<pre>"""Generate letter pairs in Voldemort &amp; find their frequency in a dictionary.<br/><br/>Requires load_dictionary.py module to load an English dictionary file.<br/><br/>"""<br/>import re<br/>from collections import defaultdict<br/>from itertools import permutations<br/>import load_dictionary<br/><br/>word_list = load_dictionary.load('2of4brif.txt')<br/><br/>name = 'Voldemort'  #(tmvoordle)<br/>name = name.lower()<br/><br/># generate unique letter pairs from name<br/>digrams = set()<br/>perms = {''.join(i) for i in permutations(name)}<br/>for perm in perms:<br/>    for i in range(0, len(perm) - 1):<br/>        digrams.add(perm[i] + perm[i + 1])<br/>print(*sorted(digrams), sep='\n')<br/>print("\nNumber of digrams = {}\n".format(len(digrams)))<br/><br/># use regular expressions to find repeating digrams in a word<br/>mapped = defaultdict(int)<br/>for word in word_list:<br/>    word = word.lower()<br/>    for digram in digrams:<br/>        for m in re.finditer(digram, word):<br/>            mapped[digram] += 1<br/><br/>print("digram frequency count:")<br/>count = 0<br/>for k in sorted(mapped):<br/>    print("{} {}".format(k, mapped[k]))</pre>
<h3 class="h3" id="lev404"><span epub:type="pagebreak" id="page_370"/><strong>Chapter 4: Decoding American Civil War Ciphers</strong></h3>
<h4 class="h4" id="lev405"><strong><em>Hacking Lincoln</em></strong></h4>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tabaa"><strong>Code word</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabaa"><strong>Plaintext</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">WAYLAND</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">captured</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="tabaa">NEPTUNE</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabaa">Richmond</p></td>
</tr>
</tbody>
</table>
<p class="noindent"><strong>Plaintext:</strong> correspondents of the Tribune captured at Richmond please ascertain why they are detained and get them off if you can this fills it up</p>
<h4 class="h4" id="lev406"><strong><em>Identifying Cipher Types</em></strong></h4>
<p class="margin"><em>identify_cipher_type_practice.py</em></p>
<pre>"""Load ciphertext &amp; use fraction of ETAOIN present to classify cipher type."""<br/>import sys<br/>from collections import Counter<br/><br/># set arbitrary cutoff fraction of 6 most common letters in English<br/># ciphertext with target fraction or greater = transposition cipher<br/>CUTOFF = 0.5<br/><br/># load ciphertext<br/>def load(filename):<br/>    """Open text file and return list."""<br/>    with open(filename) as f:<br/>        return f.read().strip()<br/><br/>try:<br/>    ciphertext = load('cipher_a.txt')<br/>except IOError as e:<br/>    print("{}. Terminating program.".format(e),<br/>          file=sys.stderr)<br/>    sys.exit(1)<br/><br/># count 6 most common letters in ciphertext<br/>six_most_frequent = Counter(ciphertext.lower()).most_common(6)<br/>print("\nSix most-frequently-used letters in English = ETAOIN")<br/>print('\nSix most frequent letters in ciphertext =')<br/>print(*six_most_frequent, sep='\n')<br/><br/># convert list of tuples to set of letters for comparison<br/>cipher_top_6 = {i[0] for i in six_most_frequent}<br/><br/>TARGET = 'etaoin'<br/>count = 0<br/>for letter in TARGET:<br/>    if letter in cipher_top_6:<br/>        count += 1<br/><br/>if count/len(TARGET) &gt;= CUTOFF:<br/><span epub:type="pagebreak" id="page_371"/>    print("\nThis ciphertext most-likely produced by a TRANSPOSITION cipher")<br/>else:<br/>    print("This ciphertext most-likely produced by a SUBSTITUTION cipher")</pre>
<h4 class="h4" id="lev407"><strong><em>Storing a Key as a Dictionary</em></strong></h4>
<p class="margin"><em>key_dictionary_practice.py</em></p>
<pre>"""Input cipher key string, get user input on route direction as dict value."""<br/>col_order = """1 3 4 2"""<br/>key = dict()<br/>cols = [int(i) for i in col_order.split()]<br/>for col in cols:<br/>    while True:<br/>        key[col] = input("Direction to read Column {} (u = up, d = down): "<br/>                         .format(col).lower())<br/>        if key[col] == 'u' or key[col] == 'd':<br/>            break<br/>        else:<br/>            print("Input should be 'u' or 'd'")<br/><br/>    print("{}, {}".format(col, key[col]))</pre>
<h4 class="h4" id="lev408"><strong><em>Automating Possible Keys</em></strong></h4>
<p class="margin"><em>permutations_practice.py</em></p>
<pre>"""For a total number of columns, find all unique column arrangements.<br/><br/>Builds a list of lists containing all possible unique arrangements of<br/>individual column numbers, including negative values for route direction<br/>(read up column vs. down).<br/><br/>Input:<br/>-total number of columns<br/><br/>Returns:<br/>-list of lists of unique column orders, including negative values for<br/>route cipher encryption direction<br/><br/>"""<br/>import math<br/>from itertools import permutations, product<br/><br/>#------BEGIN INPUT-----------------------------------------------------------<br/><br/># Input total number of columns:<br/>num_cols = 4<br/><br/>#------DO NOT EDIT BELOW THIS LINE--------------------------------------------<br/><br/><br/># generate listing of individual column numbers<br/><span epub:type="pagebreak" id="page_372"/>columns = [x for x in range(1, num_cols+1)]<br/>print("columns = {}".format(columns))<br/><br/># build list of lists of column number combinations<br/># itertools product computes the Cartesian product of input iterables<br/>def perms(columns):<br/>    """Take number of columns integer &amp; generate pos &amp; neg permutations."""<br/>    results = []<br/>    for perm in permutations(columns):<br/>        for signs in product([-1, 1], repeat=len(columns)):<br/>            results.append([i*sign for i, sign in zip(perm, signs)])<br/>    return results<br/><br/>col_combos = perms(columns)<br/>print(*col_combos, sep="\n")  # comment-out for num_cols &gt; 4!<br/>print("Factorial of num_cols without negatives = {}"<br/>      .format(math.factorial(num_cols)))<br/>print("Number of column combinations = {}".format(len(col_combos)))</pre>
<h4 class="h4" id="lev409"><strong><em>Route Transposition Cipher: Brute-Force Attack</em></strong></h4>
<p class="noindent">This practice project uses two programs. The second, <em>perms.py</em>, is used as a module in the first program, <em>route_cipher_hacker.py</em>. It was built from the <em>permutations_practice.py</em> program previously described in “<a href="appendix.xhtml#lev408">Automating Possible Keys</a>” on <a href="appendix.xhtml#page_371">page 371</a>.</p>
<h5 class="h5" id="lev410"><strong><em>route_cipher_hacker.py</em></strong></h5>
<p class="margin"><em>route_cipher_hacker.py</em></p>
<pre>"""Brute-force hack a Union route cipher (route_cipher_hacker.py).<br/><br/>Designed for whole-word transposition ciphers with variable rows &amp; columns.<br/>Assumes encryption began at either top or bottom of a column.<br/>Possible keys auto-generated based on number of columns &amp; rows input.<br/>Key indicates the order to read columns and the direction to traverse.<br/>Negative column numbers mean start at bottom and read up.<br/>Positive column numbers means start at top &amp; read down.<br/><br/>Example below is for 4x4 matrix with key -1 2 -3 4.<br/>Note "0" is not allowed.<br/>Arrows show encryption route; for negative key values read UP.<br/><br/>  1   2   3   4<br/>___ ___ ___ ___<br/>| ^ | | | ^ | | | MESSAGE IS WRITTEN<br/>|_|_|_v_|_|_|_v_|<br/>| ^ | | | ^ | | | ACROSS EACH ROW<br/>|_|_|_v_|_|_|_v_|<br/>| ^ | | | ^ | | | IN THIS MANNER<br/>|_|_|_v_|_|_|_v_|<br/>| ^ | | | ^ | | | LAST ROW IS FILLED WITH DUMMY WORDS<br/>|_|_|_v_|_|_|_v_|<br/>START        END<br/><br/><span epub:type="pagebreak" id="page_373"/>Required inputs - a text message, # of columns, # of rows, key string<br/>Requires custom-made "perms" module to generate keys<br/>Prints off key used and translated plaintext<br/>"""<br/>import sys<br/>import perms<br/><br/>#==============================================================================<br/># USER INPUT:<br/><br/># the string to be decrypted (type or paste between triple-quotes):<br/>ciphertext = """REST TRANSPORT YOU GODWIN VILLAGE ROANOKE WITH ARE YOUR IS JUST<br/>SUPPLIES FREE SNOW HEADING TO GONE TO SOUTH FILLER<br/>"""<br/><br/># the number of columns believed to be in the transposition matrix:<br/>COLS = 4<br/><br/># the number of rows believed to be in the transposition matrix:<br/>ROWS = 5<br/><br/># END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!<br/>#==============================================================================<br/><br/><br/><br/>def main():<br/>    """Turn ciphertext into list, call validation &amp; decryption functions."""<br/>    cipherlist = list(ciphertext.split())<br/>    validate_col_row(cipherlist)<br/>    decrypt(cipherlist)<br/><br/>def validate_col_row(cipherlist):<br/>    """Check that input columns &amp; rows are valid vs. message length."""<br/>    factors = []<br/>    len_cipher = len(cipherlist)<br/>    for i in range(2, len_cipher):  # range excludes 1-column ciphers<br/>        if len_cipher % i == 0:<br/>            factors.append(i)<br/>    print("\nLength of cipher = {}".format(len_cipher))<br/>    print("Acceptable column/row values include: {}".format(factors))<br/>    print()<br/>    if ROWS * COLS != len_cipher:<br/>        print("\nError - Input columns &amp; rows not factors of length "<br/>              "of cipher. Terminating program.", file=sys.stderr)<br/>        sys.exit(1)<br/><br/>def decrypt(cipherlist):<br/>    """Turn columns into items in list of lists &amp; decrypt ciphertext."""<br/>    col_combos = perms.perms(COLS)<br/>    for key in col_combos:<br/>        translation_matrix = [None] * COLS<br/>        plaintext = ''<br/>        start = 0<br/><span epub:type="pagebreak" id="page_374"/>        stop = ROWS<br/>        for k in key:<br/>            if k &lt; 0: # reading bottom-to-top of column<br/>                col_items = cipherlist[start:stop]<br/>            elif k &gt; 0: # reading top-to-bottom of columnn<br/>                col_items = list((reversed(cipherlist[start:stop])))<br/>            translation_matrix[abs(k) - 1] = col_items<br/>            start += ROWS<br/>            stop += ROWS<br/>        # loop through nested lists popping off last item to a new list:<br/>        for i in range(ROWS):<br/>            for matrix_col in translation_matrix:<br/>                word = str(matrix_col.pop())<br/>                plaintext += word + ' '<br/>        print("\nusing key = {}".format(key))<br/>        print("translated = {}".format(plaintext))<br/>    print("\nnumber of keys = {}".format(len(col_combos)))<br/><br/>if __name__ == '__main__':<br/>    main()</pre>
<h5 class="h5" id="lev411"><strong><em>perms.py</em></strong></h5>
<p class="margin"><em>perms.py</em></p>
<pre>"""For a total number of columns, find all unique column arrangements.<br/><br/>Builds a list of lists containing all possible unique arrangements of<br/>individual column numbers including negative values for route direction<br/><br/>Input:<br/>-total number of columns<br/><br/>Returns:<br/>-list of lists of unique column orders including negative values for<br/>route cipher encryption direction<br/><br/>"""<br/>from itertools import permutations, product<br/><br/># build list of lists of column number combinations<br/># itertools product computes the Cartesian product of input iterables<br/>def perms(num_cols):<br/>    """Take number of columns integer &amp; generate pos &amp; neg permutations."""<br/>    results = []<br/>    columns = [x for x in range(1, num_cols+1)]<br/>    for perm in permutations(columns):<br/>        for signs in product([-1, 1], repeat=len(columns)):<br/>            results.append([i*sign for i, sign in zip(perm, signs)])<br/>    return results</pre>
<h3 class="h3" id="lev412"><span epub:type="pagebreak" id="page_375"/><strong>Chapter 5: Encoding English Civil War Ciphers</strong></h3>
<h4 class="h4" id="lev413"><strong><em>Saving Mary</em></strong></h4>
<p class="margin"><em>save_Mary_practice.py</em></p>
<pre>"""Hide a null cipher within a list of names using a variable pattern."""<br/>import load_dictionary<br/><br/># write a short message and use no punctuation or numbers!<br/>message = "Give your word and we rise"<br/>message = "".join(message.split())<br/><br/># open name file<br/>names = load_dictionary.load('supporters.txt')<br/><br/>name_list = []<br/><br/># start list with null word not used in cipher<br/>name_list.append(names[0])<br/><br/># add letter of null cipher to 2nd letter of name, then 3rd, then repeat<br/>count = 1<br/>for letter in message:<br/>    for name in names:<br/>        if len(name) &gt; 2 and name not in name_list:<br/>            if count % 2 == 0 and name[2].lower() == letter.lower():<br/>                name_list.append(name)<br/>                count += 1<br/>                break<br/>            elif count % 2 != 0 and name[1].lower() == letter.lower():<br/>                name_list.append(name)<br/>                count += 1<br/>                break<br/><br/># add two null words early in message to throw off cryptanalysts<br/>name_list.insert(3, 'Stuart')<br/>name_list.insert(6, 'Jacob')<br/><br/># display cover letter and list with null cipher<br/>print("""<br/>Your Royal Highness: \n<br/>It is with the greatest pleasure I present the list of noble families who<br/>have undertaken to support your cause and petition the usurper for the<br/>release of your Majesty from the current tragical circumstances.<br/>""")<br/><br/>print(*name_list, sep='\n')</pre>
<h4 class="h4" id="lev414"><span epub:type="pagebreak" id="page_376"/><strong><em>The Colchester Catch</em></strong></h4>
<p class="margin"><em>colchester_practice.py</em></p>
<pre>"""Solve a null cipher based on every nth letter in every nth word."""<br/>import sys<br/><br/>def load_text(file):<br/>    """Load a text file as a string."""<br/>    with open(file) as f:<br/>        return f.read().strip()<br/><br/># load &amp; process message:<br/>filename = input("\nEnter full filename for message to translate: ")<br/>try:<br/>    loaded_message = load_text(filename)<br/>except IOError as e:<br/>    print("{}. Terminating program.".format(e), file=sys.stderr)<br/>    sys.exit(1)<br/><br/># check loaded message &amp; # of lines<br/>print("\nORIGINAL MESSAGE = {}\n".format(loaded_message))<br/><br/># convert message to list and get length<br/>message = loaded_message.split()<br/>end = len(message)<br/><br/># get user input on interval to check<br/>increment = int(input("Input max word &amp; letter position to \<br/>                      check (e.g., every 1 of 1, 2 of 2, etc.): "))<br/>print()<br/><br/># find letters at designated intervals<br/>for i in range(1, increment + 1):<br/>    print("\nUsing increment letter {} of word {}".format(i, i))<br/>    print()<br/>    count = i - 1<br/>    location = i - 1<br/>    for index, word in enumerate(message):<br/>        if index == count:<br/>            if location &lt; len(word):<br/>                print("letter = {}".format(word[location]))<br/>                count += i<br/>            else:<br/>                print("Interval doesn't work", file=sys.stderr)</pre>
<h3 class="h3" id="lev415"><span epub:type="pagebreak" id="page_377"/><strong>Chapter 6: Writing in Invisible Ink</strong></h3>
<h4 class="h4" id="lev416"><strong><em>Checking the Number of Blank Lines</em></strong></h4>
<p class="margin"><em>elementary_ink_practice.py</em></p>
<pre>"""Add code to check blank lines in fake message vs lines in real message."""<br/>import sys<br/>import docx<br/>from docx.shared import RGBColor, Pt<br/><br/># get text from fake message &amp; make each line a list item<br/>fake_text = docx.Document('fakeMessage.docx')<br/>fake_list = []<br/>for paragraph in fake_text.paragraphs:<br/>    fake_list.append(paragraph.text)<br/><br/># get text from real message &amp; make each line a list item<br/>real_text = docx.Document('realMessageChallenge.docx')<br/>real_list = []<br/>for paragraph in real_text.paragraphs:<br/>    if len(paragraph.text) != 0:  # remove blank lines<br/>        real_list.append(paragraph.text)<br/><br/># define function to check available hiding space:<br/>def line_limit(fake, real):<br/>    """Compare number of blank lines in fake vs lines in real and<br/>    warn user if there are not enough blanks to hold real message.<br/><br/>    NOTE:  need to import 'sys'<br/><br/>    """<br/>    num_blanks = 0<br/>    num_real = 0<br/>    for line in fake:<br/>        if line == '':<br/>            num_blanks += 1<br/>    num_real = len(real)<br/>    diff = num_real - num_blanks<br/>    print("\nNumber of blank lines in fake message = {}".format(num_blanks))<br/>    print("Number of lines in real message = {}\n".format(num_real))<br/>    if num_real &gt; num_blanks:<br/>        print("Fake message needs {} more blank lines."<br/>              .format(diff), file=sys.stderr)<br/>        sys.exit()<br/><br/>line_limit(fake_list, real_list)<br/><br/># load template that sets style, font, margins, etc.<br/>doc = docx.Document('template.docx')<br/><br/># add letterhead<br/>doc.add_heading('Morland Holmes', 0)<br/><span epub:type="pagebreak" id="page_378"/>subtitle = doc.add_heading('Global Consulting &amp; Negotiations', 1)<br/>subtitle.alignment = 1<br/>doc.add_heading('', 1)<br/>doc.add_paragraph('December 17, 2015')<br/>doc.add_paragraph('')<br/><br/>def set_spacing(paragraph):<br/>    """Use docx to set line spacing between paragraphs."""<br/>    paragraph_format = paragraph.paragraph_format<br/>    paragraph_format.space_before = Pt(0)<br/>    paragraph_format.space_after = Pt(0)<br/><br/>length_real = len(real_list)<br/>count_real = 0  # index of current line in real (hidden) message<br/><br/># interleave real and fake message lines<br/>for line in fake_list:<br/>    if count_real &lt; length_real and line == "":<br/>        paragraph = doc.add_paragraph(real_list[count_real])<br/>        paragraph_index = len(doc.paragraphs) - 1<br/><br/>        # set real message color to white<br/>        run = doc.paragraphs[paragraph_index].runs[0]<br/>        font = run.font<br/>        font.color.rgb = RGBColor(255, 255, 255)  # make it red to test<br/>        count_real += 1<br/><br/>    else:<br/>        paragraph = doc.add_paragraph(line)<br/><br/>    set_spacing(paragraph)<br/><br/>doc.save('ciphertext_message_letterhead.docx')<br/><br/>print("Done"))</pre>
<h3 class="h3" id="lev417"><strong>Chapter 8: Counting Syllables for Haiku Poetry</strong></h3>
<h4 class="h4" id="lev418"><strong><em>Syllable Counter vs. Dictionary File</em></strong></h4>
<p class="margin"><em>test_count_syllables_w_dict.py</em></p>
<pre>"""Load a dictionary file, pick random words, run syllable-counting module."""<br/>import sys<br/>import random<br/>from count_syllables import count_syllables<br/><br/>def load(file):<br/>    """Open a text file &amp; return list of lowercase strings."""<br/>    with open(file) as in_file:<br/>        loaded_txt = in_file.read().strip().split('\n')<br/>        loaded_txt = [x.lower() for x in loaded_txt]<br/>        return loaded_txt<br/><span epub:type="pagebreak" id="page_379"/>try:<br/>    word_list = load('2of4brif.txt')<br/>except IOError as e:<br/>    print("{}\nError opening file. Terminating program.".format(e),<br/>          file=sys.stderr)<br/>    sys.exit(1)<br/><br/>test_data = []<br/>num_words = 100<br/>test_data.extend(random.sample(word_list, num_words))<br/><br/>for word in test_data:<br/>    try:<br/>        num_syllables = count_syllables(word)<br/>        print(word, num_syllables, end='\n')<br/>    except KeyError:<br/>        print(word, end='')<br/>        print(" not found", file=sys.stderr)</pre>
<h3 class="h3" id="lev419"><strong>Chapter 10: Are We Alone? Exploring the Fermi Paradox</strong></h3>
<h4 class="h4" id="lev420"><strong><em>A Galaxy Far, Far Away</em></strong></h4>
<p class="margin"><em>galaxy_practice.py</em></p>
<pre>"""Use spiral formula to build galaxy display."""<br/>import math<br/>from random import randint<br/>import tkinter<br/><br/>root = tkinter.Tk()<br/>root.title("Galaxy BR549")<br/>c = tkinter.Canvas(root, width=1000, height=800, bg='black')<br/>c.grid()<br/>c.configure(scrollregion=(-500, -400, 500, 400))<br/>oval_size = 0<br/><br/># build spiral arms<br/>num_spiral_stars = 500<br/>angle = 3.5<br/>core_diameter = 120<br/>spiral_stars = []<br/>for i in range(num_spiral_stars):<br/>    theta = i * angle<br/>    r = math.sqrt(i) / math.sqrt(num_spiral_stars)<br/>    spiral_stars.append((r * math.cos(theta), r * math.sin(theta)))<br/>for x, y in spiral_stars:<br/>    x = x * 350 + randint(-5, 3)<br/>    y = y * 350 + randint(-5, 3)<br/>    oval_size = randint(1, 3)<br/>    c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,<br/>                  fill='white', outline='')<br/><br/><span epub:type="pagebreak" id="page_380"/># build wisps<br/>wisps = []<br/>for i in range(2000):<br/>    theta = i * angle<br/>    # divide by num_spiral_stars for better dust lanes<br/>    r = math.sqrt(i) / math.sqrt(num_spiral_stars)<br/>    spiral_stars.append((r * math.cos(theta), r * math.sin(theta)))<br/>for x, y in spiral_stars:<br/>    x = x * 330 + randint(-15, 10)<br/>    y = y * 330 + randint(-15, 10)<br/>    h = math.sqrt(x**2 + y**2)<br/>    if h &lt; 350:<br/>        wisps.append((x, y))<br/>        c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')<br/><br/># build galactic core<br/>core = []<br/>for i in range(900):<br/>    x = randint(-core_diameter, core_diameter)<br/>    y = randint(-core_diameter, core_diameter)<br/>    h = math.sqrt(x**2 + y**2)<br/>    if h &lt; core_diameter - 70:<br/>        core.append((x, y))<br/>        oval_size = randint(2, 4)<br/>        c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,<br/>                      fill='white', outline='')<br/>    elif h &lt; core_diameter:<br/>        core.append((x, y))<br/>        oval_size = randint(0, 2)<br/>        c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,<br/>                      fill='white', outline='')<br/><br/>root.mainloop()</pre>
<h4 class="h4" id="lev421"><strong><em>Building a Galactic Empire</em></strong></h4>
<p class="margin"><em>empire_practice.py</em></p>
<pre>"""Build 2-D model of galaxy, post expansion rings for galactic empire."""<br/>import tkinter as tk<br/>import time<br/>from random import randint, uniform, random<br/>import math<br/><br/>#=============================================================================<br/># MAIN INPUT<br/><br/># location of galactic empire homeworld on map:<br/>HOMEWORLD_LOC = (0, 0)<br/><br/># maximum number of years to simulate:<br/>MAX_YEARS = 10000000<br/><br/><span epub:type="pagebreak" id="page_381"/># average expansion velocity as fraction of speed of light:<br/>SPEED = 0.005<br/><br/># scale units<br/>UNIT = 200<br/><br/>#======================================================================<br/><br/># set up display canvas<br/>root = tk.Tk()<br/>root.title("Milky Way galaxy")<br/>c = tk.Canvas(root, width=1000, height=800, bg='black')<br/>c.grid()<br/>c.configure(scrollregion=(-500, -400, 500, 400))<br/><br/># actual Milky Way dimensions (light-years)<br/>DISC_RADIUS = 50000<br/><br/>disc_radius_scaled = round(DISC_RADIUS/UNIT)<br/><br/>def polar_coordinates():<br/>    """Generate uniform random x,y point within a disc for 2-D display."""<br/>    r = random()<br/>    theta = uniform(0, 2 * math.pi)<br/>    x = round(math.sqrt(r) * math.cos(theta) * disc_radius_scaled)<br/>    y = round(math.sqrt(r) * math.sin(theta) * disc_radius_scaled)<br/>    return x, y<br/><br/>def spirals(b, r, rot_fac, fuz_fac, arm):<br/>    """Build spiral arms for tkinter display using Logarithmic spiral formula.<br/><br/>    b = arbitrary constant in logarithmic spiral equation<br/>    r = scaled galactic disc radius<br/>    rot_fac = rotation factor<br/>    fuz_fac = random shift in star position in arm, applied to 'fuzz' variable<br/>    arm = spiral arm (0 = main arm, 1 = trailing stars)<br/>    """<br/>    spiral_stars = []<br/>    fuzz = int(0.030 * abs(r))  # randomly shift star locations<br/>    theta_max_degrees = 520<br/>    for i in range(theta_max_degrees):  # range(0, 700, 2) for no black hole<br/>        theta = math.radians(i)<br/>        x = r * math.exp(b*theta) * math.cos(theta + math.pi * rot_fac)\<br/>            + randint(-fuzz, fuzz) * fuz_fac<br/>        y = r * math.exp(b*theta) * math.sin(theta + math.pi * rot_fac)\<br/>            + randint(-fuzz, fuzz) * fuz_fac<br/>        spiral_stars.append((x, y))<br/>    for x, y in spiral_stars:<br/>        if arm == 0 and int(x % 2) == 0:<br/>            c.create_oval(x-2, y-2, x+2, y+2, fill='white', outline='')<br/>        elif arm == 0 and int(x % 2) != 0:<br/>            c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')<br/>        elif arm == 1:<br/>            c.create_oval(x, y, x, y, fill='white', outline='')<br/><br/><span epub:type="pagebreak" id="page_382"/>def star_haze(scalar):<br/>    """Randomly distribute faint tkinter stars in galactic disc.<br/>    disc_radius_scaled = galactic disc radius scaled to radio bubble diameter<br/>    scalar = multiplier to vary number of stars posted<br/>    """<br/>    for i in range(0, disc_radius_scaled * scalar):<br/>        x, y = polar_coordinates()<br/>        c.create_text(x, y, fill='white', font=('Helvetica', '7'), text='.')<br/><br/>def model_expansion():<br/>    """Model empire expansion from homeworld with concentric rings."""<br/>    r = 0 # radius from homeworld<br/>    text_y_loc = -290<br/>    x, y = HOMEWORLD_LOC<br/>    c.create_oval(x-5, y-5, x+5, y+5, fill='red')<br/>    increment = round(MAX_YEARS / 10)# year interval to post circles<br/>    c.create_text(-475, -350, anchor='w', fill='red', text='Increment = {:,}'<br/>                  .format(increment))<br/>    c.create_text(-475, -325, anchor='w', fill='red',<br/>                  text='Velocity as fraction of Light = {:,}'.format(SPEED))<br/><br/>    for years in range(increment, MAX_YEARS + 1, increment):<br/>        time.sleep(0.5) # delay before posting new expansion circle<br/>        traveled = SPEED * increment / UNIT<br/>        r = r + traveled<br/>        c.create_oval(x-r, y-r, x+r, y+r, fill='', outline='red', width='2')<br/>        c.create_text(-475, text_y_loc, anchor='w', fill='red',<br/>                      text='Years = {:,}'.format(years))<br/>        text_y_loc += 20<br/>        # update canvas for new circle; no longer need mainloop()<br/>        c.update_idletasks()<br/>        c.update()<br/><br/>def main():<br/>    """Generate galaxy display, model empire expansion, run mainloop."""<br/>    spirals(b=-0.3, r=disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)<br/>    spirals(b=-0.3, r=disc_radius_scaled, rot_fac=1.91, fuz_fac=1.5, arm=1)<br/>    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)<br/>    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-2.09, fuz_fac=1.5, arm=1)<br/>    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.5, fuz_fac=1.5, arm=0)<br/>    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.4, fuz_fac=1.5, arm=1)<br/>    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.5, fuz_fac=1.5, arm=0)<br/>    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.6, fuz_fac=1.5, arm=1)<br/>    star_haze(scalar=9)<br/><br/>    model_expansion()<br/><br/>    # run tkinter loop<br/>    root.mainloop()<br/><br/>if __name__ == '__main__':<br/>    main()</pre>
<h4 class="h4" id="lev422"><span epub:type="pagebreak" id="page_383"/><strong><em>A Roundabout Way to Predict Detectability</em></strong></h4>
<p class="margin"><em>rounded_detection_practice.py</em></p>
<pre>"""Calculate probability of detecting 32 LY-diameter radio bubble given 15.6 M<br/>randomly distributed civilizations in the galaxy."""<br/>import math<br/>from random import uniform, random<br/>from collections import Counter<br/><br/># length units in light-years<br/>DISC_RADIUS = 50000<br/>DISC_HEIGHT = 1000<br/>NUM_CIVS = 15600000<br/>DETECTION_RADIUS = 16<br/><br/>def random_polar_coordinates_xyz():<br/>    """Generate uniform random xyz point within a 3D disc."""<br/>    r = random()<br/>    theta = uniform(0, 2 * math.pi)<br/>    x = round(math.sqrt(r) * math.cos(theta) * DISC_RADIUS, 3)<br/>    y = round(math.sqrt(r) * math.sin(theta) * DISC_RADIUS, 3)<br/>    z = round(uniform(0, DISC_HEIGHT), 3)<br/>    return x, y, z<br/><br/>def rounded(n, base):<br/>    """Round a number to the nearest number designated by base parameter."""<br/>    return int(round(n/base) * base)<br/><br/>def distribute_civs():<br/>    """Distribute xyz locations in galactic disc model and return list."""<br/>    civ_locs = []<br/>    while len(civ_locs) &lt; NUM_CIVS:<br/>        loc = random_polar_coordinates_xyz()<br/>        civ_locs.append(loc)<br/>    return civ_locs<br/><br/>def round_civ_locs(civ_locs):<br/>    """Round xyz locations and return list of rounded locations."""<br/>    # convert radius to cubic dimensions:<br/>    detect_distance = round((4 / 3 * math.pi * DETECTION_RADIUS**3)**(1/3))<br/>    print("\ndetection radius = {} LY".format(DETECTION_RADIUS))<br/>    print("cubic detection distance = {} LY".format(detect_distance))<br/><br/>    # round civilization xyz to detection distance<br/>    civ_locs_rounded = []<br/><br/>    for x, y, z in civ_locs:<br/>        i = rounded(x, detect_distance)<br/>        j = rounded(y, detect_distance)<br/>        k = rounded(z, detect_distance)<br/>        civ_locs_rounded.append((i, j, k))<br/><br/>    return civ_locs_rounded<br/><br/><span epub:type="pagebreak" id="page_384"/>def calc_prob_of_detection(civ_locs_rounded):<br/>    """Count locations and calculate probability of duplicate values."""<br/>    overlap_count = Counter(civ_locs_rounded)<br/>    overlap_rollup = Counter(overlap_count.values())<br/>    num_single_civs = overlap_rollup[1]<br/>    prob = 1 - (num_single_civs / NUM_CIVS)<br/><br/>    return overlap_rollup, prob<br/><br/>def main():<br/>    """Call functions and print results."""<br/>    civ_locs = distribute_civs()<br/>    civ_locs_rounded = round_civ_locs(civ_locs)<br/>    overlap_rollup, detection_prob = calc_prob_of_detection(civ_locs_rounded)<br/>    print("length pre-rounded civ_locs = {}".format(len(civ_locs)))<br/>    print("length of rounded civ_locs_rounded = {}".format(len(civ_locs_rounded)))<br/>    print("overlap_rollup = {}\n".format(overlap_rollup))<br/>    print("probability of detection = {0:.3f}".format(detection_prob))<br/><br/>    # QC step to check rounding<br/>    print("\nFirst 3 locations pre- and post-rounding:\n")<br/>    for i in range(3):<br/>        print("pre-round: {}".format(civ_locs[i]))<br/>        print("post-round: {} \n".format(civ_locs_rounded[i]))<br/><br/>if __name__ == '__main__':<br/>    main()</pre>
<h3 class="h3" id="lev423"><strong>Chapter 11: The Monty Hall Problem</strong></h3>
<h4 class="h4" id="lev424"><strong><em>The Birthday Paradox</em></strong></h4>
<p class="margin"><em>birthday_paradox_practice.py</em></p>
<pre>"""Calculate probability of a shared birthday per x number of people."""<br/>import random<br/><br/>max_people = 50<br/>num_runs = 2000<br/><br/>print("\nProbability of at least 2 people having the same birthday:\n")<br/><br/>for people in range(2, max_people + 1):<br/>    found_shared = 0<br/>    for run in range(num_runs):<br/>        bdays = []<br/>        for i in range(0, people):<br/>            bday = random.randrange(0, 365)  # ignore leap years<br/>            bdays.append(bday)<br/>        set_of_bdays = set(bdays)<br/>        if len(set_of_bdays) &lt; len(bdays):<br/>            found_shared += 1<br/>    prob = found_shared/num_runs<br/><span epub:type="pagebreak" id="page_385"/>    print("Number people = {} Prob = {:.4f}".format(people, prob))<br/><br/>print("""<br/>According to the Birthday Paradox, if there are 23 people in a room,<br/>there's a 50% chance that 2 of them will share the same birthday.<br/>""")</pre>
<h3 class="h3" id="lev425"><strong>Chapter 13: Simulating an Alien Volcano</strong></h3>
<h4 class="h4" id="lev426"><strong><em>Going the Distance</em></strong></h4>
<p class="margin"><em>practice_45.py</em></p>
<pre>import sys<br/>import math<br/>import random<br/>import pygame as pg<br/><br/>pg.init()  # initialize pygame<br/><br/># define color table<br/>BLACK = (0, 0, 0)<br/>WHITE = (255, 255, 255)<br/>LT_GRAY = (180, 180, 180)<br/>GRAY = (120, 120, 120)<br/>DK_GRAY = (80, 80, 80)<br/><br/>class Particle(pg.sprite.Sprite):<br/>    """Builds ejecta particles for volcano simulation."""<br/><br/>    gases_colors = {'SO2': LT_GRAY, 'CO2': GRAY, 'H2S': DK_GRAY, 'H2O': WHITE}<br/><br/>    VENT_LOCATION_XY = (320, 300)<br/>    IO_SURFACE_Y = 308<br/>    GRAVITY = 0.5  # pixels-per-frame<br/>    VELOCITY_SO2 = 8  # pixels-per-frame<br/><br/>    # scalars (SO2 atomic weight/particle atomic weight) used for velocity<br/>    vel_scalar = {'SO2': 1, 'CO2': 1.45, 'H2S': 1.9, 'H2O': 3.6}<br/><br/>    def __init__(self, screen, background):<br/>        super().__init__()<br/>        self.screen = screen<br/>        self.background = background<br/>        self.image = pg.Surface((4, 4))<br/>        self.rect = self.image.get_rect()<br/>        self.gas = 'SO2'<br/>        self.color = ''<br/>        self.vel = Particle.VELOCITY_SO2 * Particle.vel_scalar[self.gas]<br/>        self.x, self.y = Particle.VENT_LOCATION_XY<br/>        self.vector()<br/><br/><span epub:type="pagebreak" id="page_386"/>    def vector(self):<br/>        """Calculate particle vector at launch."""<br/>        angles = [65, 55, 45, 35, 25]  # 90 is vertical<br/>        orient = random.choice(angles)<br/>        if orient == 45:<br/>            self.color = WHITE<br/>        else:<br/>            self.color = GRAY<br/>        radians = math.radians(orient)<br/>        self.dx = self.vel * math.cos(radians)<br/>        self.dy = -self.vel * math.sin(radians)  # negative as y increases down<br/><br/>    def update(self):<br/>        """Apply gravity, draw path, and handle boundary conditions."""<br/>        self.dy += Particle.GRAVITY<br/>        pg.draw.line(self.background, self.color, (self.x, self.y),<br/>                     (self.x + self.dx, self.y + self.dy))<br/>        self.x += self.dx<br/>        self.y += self.dy<br/>        if self.x &lt; 0 or self.x &gt; self.screen.get_width():<br/>            self.kill()<br/>        if self.y &lt; 0 or self.y &gt; Particle.IO_SURFACE_Y:<br/>            self.kill()<br/><br/>def main():<br/>    """Set up and run game screen and loop."""<br/>    screen = pg.display.set_mode((639, 360))<br/>    pg.display.set_caption("Io Volcano Simulator")<br/>    background = pg.image.load("tvashtar_plume.gif")<br/><br/>    # Set up color-coded legend<br/>    legend_font = pg.font.SysFont('None', 26)<br/>    text = legend_font.render('White = 45 degrees', True, WHITE, BLACK)<br/><br/><br/>    particles = pg.sprite.Group()<br/><br/>    clock = pg.time.Clock()<br/><br/>    while True:<br/>        clock.tick(25)<br/>        particles.add(Particle(screen, background))<br/>        for event in pg.event.get():<br/>            if event.type == pg.QUIT:<br/>                pg.quit()<br/>                sys.exit()<br/><br/>        screen.blit(background, (0, 0))<br/>        screen.blit(text, (320, 170))<br/><br/>        particles.update()<br/>        particles.draw(screen)<br/><br/>        pg.display.flip()<br/><br/><span epub:type="pagebreak" id="page_387"/>if __name__ == "__main__":<br/>    main()</pre>
<h3 class="h3" id="lev427"><strong>Chapter 16: Finding Frauds with Benford’s Law</strong></h3>
<h4 class="h4" id="lev428"><strong><em>Beating Benford</em></strong></h4>
<p class="margin"><em>beat_benford_practice.py</em></p>
<pre>"""Manipulate vote counts so that final results conform to Benford's law."""<br/><br/># example below is for Trump vs. Clinton, Illinois, 2016 Presidental Election<br/><br/>def load_data(filename):<br/>    """Open a text file of numbers &amp; turn contents into a list of integers."""<br/>    with open(filename) as f:<br/>        lines = f.read().strip().split('\n')<br/>        return [int(i) for i in lines]  # turn strings to integers<br/><br/>def steal_votes(opponent_votes, candidate_votes, scalar):<br/>    """Use scalar to reduce one vote count &amp; increase another, return as lists.<br/><br/>    Arguments:<br/>    opponent_votes – votes to steal from<br/>    candidate_votes - votes to increase by stolen amount<br/>    scalar - fractional percentage, &lt; 1, used to reduce votes<br/><br/>    Returns:<br/>    list of changed opponent votes<br/>    list of changed candidate votes<br/><br/>    """<br/>    new_opponent_votes = []<br/>    new_candidate_votes = []<br/>    for opp_vote, can_vote in zip(opponent_votes, candidate_votes):<br/>        new_opp_vote = round(opp_vote * scalar)<br/>        new_opponent_votes.append(new_opp_vote)<br/>        stolen_votes = opp_vote - new_opp_vote<br/>        new_can_vote = can_vote + stolen_votes<br/>        new_candidate_votes.append(new_can_vote)<br/>    return new_opponent_votes, new_candidate_votes<br/><br/>def main():<br/>    """Run the program.<br/><br/>    Load data, set target winning vote count, call functions, display<br/>    results as table, write new combined vote total as text file to<br/>    use as input for Benford's law analysis.<br/><br/>    """<br/>    # load vote data<br/>    c_votes = load_data('Clinton_votes_Illinois.txt')<br/><span epub:type="pagebreak" id="page_388"/>    j_votes = load_data('Johnson_votes_Illinois.txt')<br/>    s_votes = load_data('Stein_votes_Illinois.txt')<br/>    t_votes = load_data('Trump_votes_Illinois.txt')<br/><br/>    total_votes = sum(c_votes + j_votes + s_votes + t_votes)<br/><br/>    # assume Trump amasses a plurality of the vote with 49%<br/>    t_target = round(total_votes * 0.49)<br/>    print("\nTrump winning target = {:,} votes".format(t_target))<br/><br/>    # calculate extra votes needed for Trump victory<br/>    extra_votes_needed = abs(t_target - sum(t_votes))<br/>    print("extra votes needed = {:,}".format(extra_votes_needed))<br/><br/>    # calculate scalar needed to generate extra votes<br/>    scalar = 1 - (extra_votes_needed / sum(c_votes + j_votes + s_votes))<br/>    print("scalar = {:.3}".format(scalar))<br/>    print()<br/><br/>    # flip vote counts based on scalar &amp; build new combined list of votes<br/>    fake_counts = []<br/>    new_c_votes, new_t_votes = steal_votes(c_votes, t_votes, scalar)<br/>    fake_counts.extend(new_c_votes)<br/>    new_j_votes, new_t_votes = steal_votes(j_votes, new_t_votes, scalar)<br/>    fake_counts.extend(new_j_votes)<br/>    new_s_votes, new_t_votes = steal_votes(s_votes, new_t_votes, scalar)<br/>    fake_counts.extend(new_s_votes)<br/>    fake_counts.extend(new_t_votes)  # add last as has been changing up til now<br/><br/>    # compare old and new vote counts &amp; totals in tabular form<br/>    # switch-out "Trump" and "Clinton" as necessary<br/>    for i in range(0, len(t_votes)):<br/>        print("old Trump: {} \t new Trump: {} \t old Clinton: {} \t " \<br/>              "new Clinton: {}".<br/>              format(t_votes[i], new_t_votes[i], c_votes[i], new_c_votes[i]))<br/>        print("-" * 95)<br/>    print("TOTALS:")<br/>    print("old Trump: {:,} \t new Trump: {:,} \t old Clinton: {:,}  " \<br/>          "new Clinton: {:,}".format(sum(t_votes), sum(new_t_votes),<br/>                                     sum(c_votes), sum(new_c_votes)))<br/><br/>    # write out a text file to use as input to benford.py program<br/>    # this program will check conformance of faked votes to Benford's law<br/>    with open('fake_Illinois_counts.txt', 'w') as f:<br/>        for count in fake_counts:<br/>            f.write("{}\n".format(count))<br/><br/><br/>if __name__ == '__main__':<br/>    main()</pre>
</body></html>