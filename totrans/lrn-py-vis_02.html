<html><head></head><body>
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_29" title="29"/>2</span><br/><span class="ChapterTitle">Drawing More Complicated Shapes</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro">In <span class="xref">Chapter 1</span>, you learned about 2D primitives, including arcs, ellipses, lines, points, quads, rectangles, and triangles. However, some shapes, like hearts, stars, octagons, and Pikachu silhouettes, don’t fit into any such category and require more than shape functions to create.</p>
			<p>
				In this chapter, you’ll learn how to draw more complicated shapes with points and curves, as well as vertex functions for laying points. Using these techniques, you’ll draw shapes that blend straight and curved lines, and you’ll create <em>negative</em> shapes by subtracting one shape from another.</p>
			<p>
				You’ll also learn how to work with two types of curves: <em>Catmull-Rom splines</em> and <em>Bézier curves</em>. Although both involve complicated math, Processing’s curve functions handle the underlying calculus, allowing you to create curves with just the coordinates of a few control points.</p>
			<h2 id="h1-500969c02-0001"><span epub:type="pagebreak" id="Page_30" title="30"/>Displaying a Grid</h2>
			<p class="BodyFirst">The best way to understand how curves work in Processing is to draw a few and then manipulate them. It’s easier to plot points and curves by using a grid background for reference, so you’ll add one by using a ready-made graphic. Create a new sketch and save it as <em>curves</em>, and then follow these instructions to download the grid graphic:</p>
			<ol class="decimal">
				<li value="1">Open your web browser and go to <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/">https://github.com/tabreturn/processing.py-book/</a>.</li>
				<li value="2">Navigate to <em>chapter-02-drawing_more_complicated_shapes</em>.</li>
				<li value="3">Download the <em>grid.png</em> file.</li>
			</ol>
			<p>
				Additional sketch assets (images, fonts, and other media) belong in a subfolder named <em>data</em>, so create a new <em>data</em> subfolder within your <em>curves</em> sketch folder and place the <em>grid.png</em> file within it (<a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>).</p>
			<figure>
				<img alt="f02001" src="image_fi/500969c02/f02001.png"/>
				<figcaption>
					<p><a id="figure2-1">Figure 2-1</a>: Place the grid graphic within your <em>data </em>subfolder.</p>
				</figcaption>
			</figure>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							By default, many operating systems hide file extensions. However, if you dig around in your Windows File Explorer or Mac Finder preferences, you can change the settings so extensions, such as <em>.</em><em>png</em>, show in the file manager.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				This grid graphic will lie beneath everything you draw (<a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>), assisting you in gauging x-y coordinates. Set up your sketch by using the following code:</p>
			<pre><code><span class="ProcessingBlue">size</span>(500, 500)<span aria-label="annotation1" class="CodeAnnotationHang">1</span> <span class="LiteralGray">grid =</span> <span class="ProcessingBlue">loadImage</span>(<span class="ProcessingPurple">'grid.png'</span>)<span aria-label="annotation2" class="CodeAnnotationHang">2</span> <span class="ProcessingBlue">image</span><span class="LiteralGray">(grid, 0, 0)</span><span class="ProcessingBlue">noFill</span>()<span class="ProcessingBlue">strokeWeight</span>(3)</code></pre>
			<p>
				The <code>loadImage()</code> function loads the graphic file and assigns it to a variable named <code>grid </code><span aria-label="annotation1" class="CodeAnnotation">1</span>. The <code>image()</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span> draws the image to the display window. The three arguments<span class="ColorText" style="color:#00000A"> (</span><code>grid</code>, <code>0</code>, <code>0</code>) represent the loaded image file, x-coordinate, and y-coordinate, respectively.</p>
			<p>
				The image is drawn at its original dimensions unless it’s resized using an additional fourth (width) and fifth (height) <code>image()</code> function argument.</p>
				<span epub:type="pagebreak" id="Page_31" title="31"/>
				<figure>
				<img alt="f02002" src="image_fi/500969c02/f02002.png"/>
				<figcaption>
					<p><a id="figure2-2">Figure 2-2</a>: Displaying the grid image</p>
				</figcaption>
			</figure>
			<h2 id="h1-500969c02-0002">Drawing Curves Using Catmull-Rom Splines</h2>
			<p class="BodyFirst">To draw a curved line in Processing, you can use the <code>curve()</code> function. This function accepts eight arguments, which represent four pairs of x-y coordinates; these are the starting control point, start of the curve, end of the curve, and ending control point.</p>
			<p>
				Let’s begin with a standard line and then adapt it into a curve. This way, you can visualize how the <code>curve()</code> function operates by comparing it with the simpler and more familiar <code>line()</code> function. Add a diagonal line to your <em>curves</em> sketch (<a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>):</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#0099FF'</span>) <span class="ProcessingGray"># pale blue</span><span class="ProcessingBlue">line</span>(100,100, 400,400)</code></pre>
			<figure>
				<img alt="f02003" src="image_fi/500969c02/f02003.png"/>
				<figcaption>
					<p><a id="figure2-3">Figure 2-3</a>: A straight line to adapt into a curve</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_32" title="32"/>Processing draws a line between the specified pairs of x-y coordinates: (100, 100) and (400, 400). Note that the line’s coordinates correspond to the grid beneath.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Catmull-Rom Splines</h2>
					<p class="BoxBodyFirst">Processing’s <code>curve</code><code>(</code><code>)</code> function is an implementation of Catmull-Rom splines. Named after Edwin Catmull and Raphael Rom, a <em>Catmull</em><em>-Rom spline</em> is a curve whose position and curvature depend on four points. The term comes from devices called <em>splines</em>, which are the long, thin, flexible strips of wood, plastic, or metal that draftsmen would use to draw smooth curves before they had computers.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<h3 id="h2-500969c02-0001">Curving Lines with curve()</h3>
			<p class="BodyFirst">To use the <code>curve()</code> function to draw the same line, comment out the <code>line()</code> function in the <em>curves</em> sketch and replace it with a <code>curve()</code> function:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">stroke('#0099FF')  # pale blue</span><span class="ProcessingGray">#line(100,100, 400,400)</span><span class="ProcessingBlue">curve</span>(0,0, 100,100, 400,400, 500,500)</code></pre>
			<p>
				When you run the sketch, the visual result should be exactly the same, as shown previously in <a href="#figure2-3">Figure 2-3</a>. The four middle values within the <code>curve()</code> function’s parentheses match those of the <code>line()</code> function, and they also indicate the starting and ending x-y coordinates of the curve.</p>
			<p>
				But the <code>curve()</code> function takes four additional outer arguments (in this example, <code>0,0</code> and <code>500,500</code>), which represent two pairs of <em>control-point</em> coordinates. The positions of these control points determine the direction and amount of curvature you apply to the line. Before exploring this in detail, add the following new lines to the end of your code to draw a yellow line of the same length, at the same position, but with some curvature:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFF00'</span>) <span class="ProcessingGray"># yellow</span><span class="ProcessingBlue">curve</span>(0,250, 100,100, 400,400, 500,250)</code></pre>
			<p>
				In this instance, the four middle arguments remain the same, but the control-point coordinates have been changed to <code>0,250</code> and <code>500,250</code>. The result is a yellow curve with a slight S-bend (<a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a>). By comparing the blue and yellow lines, you can visualize how changing the control points has manipulated the curve.</p>
				<span epub:type="pagebreak" id="Page_33" title="33"/>
				<figure>
				<img alt="f02004" src="image_fi/500969c02/f02004.png"/>
				<figcaption>
					<p><a id="figure2-4">Figure 2-4</a>: The yellow curve’s control points, circled in orange, would otherwise be invisible.</p>
				</figcaption>
			</figure>
			<p>To understand how the control points influence the curve, imagine that each end of the yellow curve extends to its neighboring control point. The closer you bring the control point to the center of the display window, the harder you are “flexing” this curve. Conversely, with control points 1 and 2 positioned at the upper left and lower left corners of the display window, respectively, the four points lie in a row, and the curve does not have to flex, resulting in a straight line.</p>
			<p>To see how the control points work, add the following orange curves to serve as visual aids:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FF9900'</span>) <span class="ProcessingGray"># orange</span><span class="ProcessingGray"># control point 1:</span><span aria-label="annotation1" class="CodeAnnotationHang">1</span> <span class="ProcessingBlue">curve</span><span class="LiteralGray">(0,250, 0,250, 100,100, 400,400)</span><span class="ProcessingGray"># control point 2:</span><span aria-label="annotation2" class="CodeAnnotationHang">2</span> <span class="ProcessingBlue">curve</span><span class="LiteralGray">(100,100, 400,400, 500,250, 500,250)</span></code></pre>
			<p>
				The first <code>curve()</code> function <span aria-label="annotation1" class="CodeAnnotation">1</span> draws an orange curve from control point 1 to the starting point of the yellow curve; the second <code>curve()</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span> draws another orange curve from the end point of the yellow curve to control point 2. The result (<a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a>) is a three-part curve (orange-yellow-orange) that shows how the control points determine the curvature of the yellow part.</p>
				<span epub:type="pagebreak" id="Page_34" title="34"/>
				<figure>
				<img alt="f02005" src="image_fi/500969c02/f02005.png"/>
				<figcaption>
					<p><a id="figure2-5">Figure 2-5</a>: Your Processing curve (left) and a traditional spline (right). (Illustration: Pearson Scott Foresman, licensed under public domain.)</p>
				</figcaption>
			</figure>
			<p>
				As you can see, the orange curves extend the yellow curve and illustrate what the yellow curve would look like as a physically complete spline. To the right in <a href="#figure2-5">Figure 2-5</a>, you can see the flexible strip for drawing such a curve without the aid of a computer. As mentioned earlier, it’s this strip from which the spline takes its name. The two nails correspond to the starting and ending points of the <code>curve()</code> function, and the L-pieces at each end represent the control points.</p>
			<h3 id="h2-500969c02-0002">Changing Curves with curveTightness()</h3>
			<p class="BodyFirst">The <code>curveTightness()</code> function determines how rigidly the curve conforms to the points that control it, as if you were replacing the draftsman’s spline with a strip of less or more pliable material, or feeding a shorter or longer length of spline into the same area. The function accepts values ranging from –5.0 to 5.0, with 0 being the default.</p>
			<p>
				To experiment, add a <code>curveTightness()</code> line above the yellow stroke:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">curveTightness</span>(0) <span class="ProcessingGray"># try values between -0.5 and 0.5</span><span class="LiteralGray">stroke('#FFFF00')  # yellow</span></code></pre>
			<p>
				Enter different values to affect the curves below it. <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a> shows curves with different <code>curveTightness()</code> values.</p>
				<span epub:type="pagebreak" id="Page_35" title="35"/>
				<figure>
				<img alt="f02006" src="image_fi/500969c02/f02006.png"/>
				<figcaption>
					<p><a id="figure2-6">Figure 2-6</a>: Clockwise from the top left: <span class="LiteralInCaption"><code>curveTightness</code></span><span class="LiteralInCaption"><code>(</code></span><span class="LiteralInCaption"><code>-1)</code></span>, <span class="LiteralInCaption"><code>curveTightness</code></span><span class="LiteralInCaption"><code>(0)</code></span>, curveTightness<span class="LiteralInCaption"><code>(1)</code></span>, and<span class="LiteralInCaption"><code> </code></span><span class="LiteralInCaption"><code>curveTightness</code></span><span class="LiteralInCaption"><code>(5)</code></span></p>
				</figcaption>
			</figure>
			<p>
				The lower right curve in <a href="#figure2-6">Figure 2-6</a>, with its tightness argument set to <code>1</code>, fits so rigidly that the result is a straight yellow line. The more you adjust the tightness value away from <code>1</code>, the more the curve will deform. For curves that overshoot their starting and ending points, use values greater than 1. For instance, at an upper tightness limit of <code>5</code> (bottom left), the spline loops as it passes through the starting and ending points. With a tightness argument of <code>-1</code> (top left), the lengthier spline is rerouted to better align with the points it passes through; hence, there is increased curvature but no looping.</p>
			<p><span epub:type="pagebreak" id="Page_36" title="36"/>The <code>curve()</code> function is intuitive and useful for generating curved lines quickly. However, you’re most likely to encounter Bézier curves in 3D modeling, animation, computer-aided design (CAD), and vector illustration software, so let’s look at those next.</p>
			<h2 id="h1-500969c02-0003">Drawing Bézier Curves</h2>
			<p class="BodyFirst"><em>Bézier curves</em> provide an intuitive and versatile means of modeling smooth curves using a series of anchor and control points. You may have encountered these curves in vector graphics drawing software, such as Adobe Illustrator or Inkscape. In this section, you’ll draw curves using the <code>bezier()</code> function. In graphics software, you have visual nodes to grab and manipulate; in Processing, you define the positions of your anchor and control points, using <code>bezier()</code> function arguments.</p>
			<h3 id="h2-500969c02-0003">Using the bezier() Function</h3>
			<p class="BodyFirst">The <code>bezier()</code> function takes eight arguments, expanded across multiple lines here for easier readability:</p>
			<pre><code>bezier( <var>anchor_point_1_x</var>, <var>anchor_point_1_y</var>, <var>control_point_1_x</var>, <var>control_point_1_y</var>, <var>control_point_2_x</var>, <var>control_point_2_y</var>, <var>anchor_point_2_x</var>, <var>anchor_point_2_y</var>
)</code></pre>
			<p>
				The first and last pair of arguments are the starting and ending points for your curve. When using Bézier curves, you typically refer to the points that your visible lines connect to as <em>anchor points</em>. The curvature of the line as it heads away from the first anchor point (<var>anchor_point_1_x, anchor_point_1_y</var>) is controlled by the position of its associated control point (<var>control_point_1_x, control_point_1_y</var>). The other control point (<var>control_point_2_x, control_point_2_y</var>) controls the curvature of the line as it heads toward the ending anchor point (<a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a>). This is not spline-like behavior, though; instead, the control points behave more like magnets, causing the line to bulge toward them.</p>
			<p>To draw a Bézier curve, create four variables to represent the x-y coordinate pairs of the two control points:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FF99FF'</span>) <span class="ProcessingGray"># pink</span>
cp1x = 250
cp1y = 250
cp2x = 250
cp2y = 250<span class="ProcessingBlue">bezier</span>(400,100, cp1x,cp1y, cp2x,cp2y, 100,400)</code></pre>
			<span epub:type="pagebreak" id="Page_37" title="37"/><figure>
				<img alt="f02007" src="image_fi/500969c02/f02007.png"/>
				<figcaption>
					<p><a id="figure2-7">Figure 2-7</a>: The anchor and control points manipulate the position and curvature of the Bézier curve.</p>
				</figcaption>
			</figure>
			<p>
				The first pair of <code>bezier()</code> coordinates positions anchor point 1 near the top right of the grid; the last pair of coordinates positions anchor point 2 near the bottom left. All of the control point variables (<code>cp1x,cp1y, cp2x,cp2y</code>) reference the center of the display window (250, 250). By placing the control points along the diagonal path formed between anchor points 1 and 2, you form a straight line. You’ll next shift these control points outward to observe how this curves the line.</p>
			<p>
				Run this sketch to render a pink line that represents a straightened Bézier curve (<a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a>).</p>
			<figure>
				<img alt="f02008" src="image_fi/500969c02/f02008.png"/>
				<figcaption>
					<p><a id="figure2-8">Figure 2-8</a>: The pink line represents a straightened Bézier curve.</p>
				</figcaption>
			</figure>
			<p>The pink line should cross the yellow curve at the center of the display window (250, 250).</p>
			<h3 id="h2-500969c02-0004"><span epub:type="pagebreak" id="Page_38" title="38"/>Positioning Anchor and Control Points</h3>
			<p class="BodyFirst">To manipulate the pink line into a curve (<a href="#figure2-9" id="figureanchor2-9">Figure 2-9</a>), set the <code>cp1x</code> variable to <code>200</code>. In addition to this change, add two extra lines of code:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">cp1x = </span><b>200</b><span class="LiteralGray">. . .</span><span class="LiteralGray">bezier(400,100, cp1x,cp1y, cp2x,cp2y, 100,400)</span><span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FF0000'</span>) <span class="ProcessingGray"># red</span><span class="ProcessingBlue">line</span>(400,100, cp1x,cp1y)</code></pre>
			<figure>
				<img alt="f02009" src="image_fi/500969c02/f02009.png"/>
				<figcaption>
					<p><a id="figure2-9">Figure 2-9</a>: Curving the pink line by adjusting a control point</p>
				</figcaption>
			</figure>
			<p>
				The additional code creates a red line connecting anchor point 1 (<code>400, 100</code>) and its control point (<code>cp1x,cp1y</code>). This red line is useful because you can now visualize where the control point sits and which anchor point it controls. Moreover, sharing variables between the <code>bezier()</code> and red <code>line()</code> functions means that each time you adjust the values that position the curve’s control point (<code>cp1x,cp1y</code>), the red line adapts accordingly. Setting the value of <code>cp1x</code> to <code>200</code> applies curvature to the pink line because—as the control point moves away from the pink line—the pink line bulges toward it.</p>
			<p>The top half of the curve is affected most by the control point that connects to its top anchor point (control point 1); this will become more apparent when you manipulate the control point for the lower anchor point.</p>
			<p>Now add another red line to connect (the lower) anchor point 2 and control point 2:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">cp2x =</span> <b>320</b><span class="LiteralGray">cp2y =</span> <b>420</b><span class="LiteralGray">. . .</span><span class="LiteralGray">line(400,100, cp1x,cp1y)</span><span class="ProcessingBlue">line</span>(100,400, cp2x,cp2y)</code></pre>
			<p><span epub:type="pagebreak" id="Page_39" title="39"/>The new red line visually connects anchor point 2 (<code>100,400</code>) to its control point (<code>cp2x,cp2y</code>). Run the sketch to see the result (<a href="#figure2-10" id="figureanchor2-10">Figure 2-10</a>). Experiment with different control-point values to see how they affect the curve.</p>
			<figure>
				<img alt="f02010" src="image_fi/500969c02/f02010.png"/>
				<figcaption>
					<p><a id="figure2-10">Figure 2-10</a>: Adjusting control point 2</p>
				</figcaption>
			</figure>
			<p>
				Observe that the lower part of the pink curve is “magnetically” pulled toward control point 2. Knowing where to place the anchor and control points for your desired curve takes some skill. Try downloading and practicing in Inkscape (or Illustrator if you have it installed). Alternatively, try playing The Bézier Game in your web browser at <a class="LinkURL" href="https://bezier.method.ac">https://bezier.method.ac</a><em>/</em>.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Bézier Curves in Vector Graphics</h2>
					<p class="BoxBodyFirst">Vector graphic formats (such as Scalable Vector Graphics, or SVG) employ Bézier curves to render shapes scalable to any size, with no sacrifice in quality. You refer to vector graphics as <em>resolution</em><em> </em><em>independent</em>, being defined by a series of mathematical formulas rather than a grid of pixels. You can create SVG files in vector graphics software, like Inkscape and Illustrator, by using selectable nodes to position the anchor and control points of Bézier curves (<a href="#figure2-11" id="figureanchor2-11">Figure 2-11</a>).</p>
					<figure>
						<img alt="f02011" src="image_fi/500969c02/f02011.png"/>
						<figcaption>
							<p><a id="figure2-11">Figure 2-11</a>: Editing a Bézier curve in Inkscape</p>
						</figcaption>
					</figure>
					<p><span epub:type="pagebreak" id="Page_40" title="40"/>Contrast this with a <em>raster graphic</em>, where, as you zoom further and further in toward a given point, discernible squares of color appear (<a href="#figure2-12" id="figureanchor2-12">Figure 2-12</a>).</p>
					<figure>
						<img alt="f02012" src="image_fi/500969c02/f02012.png"/>
						<figcaption>
							<p><a id="figure2-12">Figure 2-12</a>: Editing a vector version of the Python logo in Illustrator (left), and editing a raster version of the same graphic in Photoshop (right)</p>
						</figcaption>
					</figure>
					<p>This is because pixel-based graphic formats used for photos—such as Joint Photographic Experts Group (JPG) and Portable Network Graphics (PNG)—are composed of a pixel grid, the dimensions of which limit the overall resolution.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				You can now draw curved lines by using Catmull-Rom splines and Bézier curves. The <code>curve()</code> and <code>bezier()</code> functions are useful for standalone curves, but to form shapes composed of multiple curve segments, you’ll need vertices.</p>
			<h2 id="h1-500969c02-0004">Drawing Shapes Using Vertices</h2>
			<p class="BodyFirst">In Processing, a <em>vertex</em> is a point used to connect lines in order to form a shape. <em>Vertices</em> is the plural of vertex. You can think of vertices as the dots in a connect-the-dots drawing puzzle. For example, a triangle requires 3 vertices; a pentagon requires 5; and a five-pointed star (<span class="CustomCharStyle"></span>) requires 10. When using straight lines and curves to connect vertices, the shape possibilities become limitless. A vertex is not limited to 2D space—for instance, Blender’s Suzanne (a monkey head) has around 500 vertices positioned in 3D space (<a href="#figure2-13" id="figureanchor2-13">Figure 2-13</a>).</p>
			<figure>
				<img alt="f02013" src="image_fi/500969c02/f02013.png"/>
				<figcaption>
					<p><a id="figure2-13">Figure 2-13</a>: Three of the 500 or so vertices circled in yellow</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_41" title="41"/>You’ll draw a square-type shape by using a series of <code>vertex()</code> functions. Create a new sketch and save it as <em>vertices</em>. Within the new <em>vertices</em> folder, add a <em>data</em> folder containing a copy of the <em>grid.png</em> file from your preceding sketch (<a href="#figure2-14" id="figureanchor2-14">Figure 2-14</a>).</p>
			<figure>
				<img alt="f02014" src="image_fi/500969c02/f02014.png"/>
				<figcaption>
					<p><a id="figure2-14">Figure 2-14</a>: The <em>vertices</em> sketch folder structure</p>
				</figcaption>
			</figure>
			<p>Add code to set up the initial parameters:</p>
			<pre><code><span class="ProcessingBlue">size</span>(800, 800)
grid = <span class="ProcessingBlue">loadImage</span>(<span class="ProcessingPurple">'grid.png'</span>)<span class="ProcessingBlue">image</span>(grid, 0, 0)<span class="ProcessingBlue">noFill</span>()<span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>)<span class="ProcessingBlue">strokeWeight</span>(3)</code></pre>
			<p>Again, you load and display the grid image to help you gauge coordinates in the display window. Each shape that you draw will have no fill and a white stroke of 3 pixels.</p>
			<p>
				Now, instead of using a <code>rect()</code> or <code>square()</code> function, use vertices to draw a square:</p>
			<pre><code><span class="ProcessingBlue">beginShape</span>() <span class="ProcessingGray"># begins recording vertices for a shape ...</span><span class="ProcessingBlue">vertex</span>(100, 100)<span class="ProcessingBlue">vertex</span>(200, 100)<span class="ProcessingBlue">vertex</span>(200, 200)<span class="ProcessingBlue">vertex</span>(100, 200)<span class="ProcessingBlue">endShape</span>() <span class="ProcessingGray"># stops recording</span></code></pre>
			<p>
				The <code>beginShape()</code> and <code>endShape()</code> functions are essential for separating groups of vertices into individual shapes. Without those two functions, Processing would have to assume that all the vertices in your sketch belong to the same shape. That said, Processing ignores any rogue <code>vertex()</code> lines placed outside the <code>beginShape()</code> and <code>endShape()</code> pair. As depicted in <a href="#figure2-15" id="figureanchor2-15">Figure 2-15</a>, the code draws a square with no left side.</p>
				<span epub:type="pagebreak" id="Page_42" title="42"/>
				<figure>
				<img alt="f02015" src="image_fi/500969c02/f02015.png"/>
				<figcaption>
					<p><a id="figure2-15">Figure 2-15</a>: An open square drawn using vertices</p>
				</figcaption>
			</figure>
			<p>
				The shape will not close automatically unless you include an <code>endShape(CLOSE)</code> argument or add a final vertex that connects with the start. However, an active <code>fill()</code> will fill in color regardless (<a href="#figure2-16" id="figureanchor2-16">Figure 2-16</a>).</p>
			<figure>
				<img alt="f02016" src="image_fi/500969c02/f02016.png"/>
				<figcaption>
					<p><a id="figure2-16">Figure 2-16</a>: Despite the open side, the shape is filled with color.</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_43" title="43"/>You also can provide various parameters to the <code>beginShape()</code> function to determine how the enclosed vertices are connected, if at all (<a href="#figure2-17" id="figureanchor2-17">Figure 2-17</a>).</p>
			<figure>
				<img alt="f02017" src="image_fi/500969c02/f02017.png"/>
				<figcaption>
					<p><a id="figure2-17">Figure 2-17</a>: The functions <var>beginShape(POINTS)</var> (left), and <var>beginShape(LINES)</var> (right)<span class="LiteralInCaption"/></p>
				</figcaption>
			</figure>
			<p>
				For a shape composed of only dots, use <code>beginShape(POINTS)</code>. For a line between every other vertex, use <code>beginShape(LINES)</code>. Consult the reference for more details on <code>beginShape()</code> arguments.</p>
			<h3 id="h2-500969c02-0005">Bézier Vertices</h3>
			<p class="BodyFirst">The <code>bezierVertex()</code> function allows you to draw curved lines between vertices. A <code>curveVertex()</code> function is also available for Catmull-Rom-type curves, but this book focuses on the Bézier type, as it provides for greater control and more graceful curves.</p>
			<p>
				The <code>bezierVertex()</code> function takes six arguments. To understand how those arguments operate, you’ll work toward completing the remaining shapes shown in <a href="#figure2-18" id="figureanchor2-18">Figure 2-18</a>.</p>
			<p>I have manually added the pale blue lines, the dotted tips of which provide a visual indication of the control points. Use these lines for reference purposes only; you don’t need to redraw them.</p>
			<span epub:type="pagebreak" id="Page_44" title="44"/>
			<figure>
				<img alt="f02018" src="image_fi/500969c02/f02018.png"/>
				<figcaption>
					<p><a id="figure2-18">Figure 2-18</a>: A Chinese coin (lower left), S-curve (middle), and heart (right)</p>
				</figcaption>
			</figure>
			<h4 id="h3-500969c02-0001">S-Curve</h4>
			<p class="BodyFirst">The <em>S-curve</em> is just a curved line that comprises two vertices, with each vertex attached to its own control point. You’ll draw it with a <code>bezierVertex()</code> function to keep this first example as simple as possible, but ordinarily, you would draw an S-curve by using <code>bezier()</code>.</p>
			<p>
				Within <code>beginShape()</code> and <code>endShape()</code>, combine the <code>bezierVertex()</code> and <code>vertex()</code> functions however necessary. Your first point, however, is always created with <code>vertex()</code>. Begin a new shape and plot the first (in this case, upper) vertex:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingGray"># s-curve</span><span class="ProcessingBlue">beginShape</span>()<span class="ProcessingBlue">vertex</span>(400, 200) <span class="ProcessingGray"># starting (upper) vertex</span><span class="ProcessingBlue">endShape</span>()</code></pre>
			<p>Run the sketch. There is no second vertex with which to form a line, so the isolated vertex should appear as a point at (400, 200).</p>
			<p>
				Now add the second vertex by using <code>bezierVertex()</code>:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray"># s-curve</span><span class="LiteralGray">beginShape()</span><span epub:type="pagebreak" id="Page_45" title="45"/><span class="LiteralGray">vertex(400,200)</span> <span class="ProcessingGray"># starting (upper) vertex</span><span class="ProcessingBlue">bezierVertex</span>( 300, 300, <span class="ProcessingGray"># control point for the starting vertex</span> 500, 500, <span class="ProcessingGray"># control point for the second (lower) vertex</span> 400, 600 <span class="ProcessingGray"># second (lower) vertex coordinates</span>
)<span class="LiteralGray">endShape()</span></code></pre>
			<p>
				The last pair of <code>bezierVertex()</code> arguments (<code>400, 600</code>) denotes the position of the second (lower) vertex. The second vertex is attached to a control point positioned by the second pair of arguments (<code>500, 500</code>). The first pair of arguments (<code>300, 300</code>) represents the control point for the <code>vertex()</code> function that immediately precedes <code>bezierVertex()</code>. With the positions of the vertices presented for you in the reference image (<a href="#figure2-18">Figure 2-18</a>), creating this shape (<a href="#figure2-19" id="figureanchor2-19">Figure 2-19</a>) is really just a matter of typing in the correct sequence of coordinates.</p>
			<figure>
				<img alt="f02019" src="image_fi/500969c02/f02019.png"/>
				<figcaption>
					<p><a id="figure2-19">Figure 2-19</a>: The complete S-curve</p>
				</figcaption>
			</figure>
			<p>This is an open shape, so it would look odd if filled. Next, you’ll examine a closed shape, but feel free to experiment with different vertex and control-point values before moving along.</p>
			<h4 id="h3-500969c02-0002">Heart</h4>
			<p class="BodyFirst">You can think of the heart shape as two curved lines connected to two vertices. To begin, draw one half of the heart (<a href="#figure2-20" id="figureanchor2-20">Figure 2-20</a>):</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingGray"># heart</span><span class="ProcessingBlue">beginShape</span>()<span class="ProcessingBlue">vertex</span>(600, 400)<span class="ProcessingBlue">bezierVertex</span>(420,300, 550,150, 600,250)<span class="ProcessingBlue">endShape</span>()</code></pre>
			<span epub:type="pagebreak" id="Page_46" title="46"/>
			<figure><img alt="f02020" src="image_fi/500969c02/f02020.png"/><figcaption>
					<p><a id="figure2-20">Figure 2-20</a>: Half a heart</p>
				</figcaption>
			</figure>
			<p>
				All that is left for you to do is complete the right half of the heart. Add a second <code>bezierVertex()</code> line and see if you can fill in the missing arguments:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray"># heart</span><span class="LiteralGray">beginShape()</span><span class="LiteralGray">vertex(600, 400)</span><span class="LiteralGray">bezierVertex(420,300, 550,150, 600,250)</span><span class="ProcessingBlue">bezierVertex</span>(___,___, ___,___, 600,400)<span class="LiteralGray">endShape()</span></code></pre>
			<p>
				Refer back to <a href="#figure2-18">Figure 2-18</a> to see where the control points lie. Remember that you can access all of the solutions to the challenges at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/">https://github.com/tabreturn/processing.py-book/</a>.</p>
			<h4 id="h3-500969c02-0003">Chinese Coin</h4>
			<p class="BodyFirst">Round metal coins with square holes in the center were first introduced in China many centuries ago, but replicating that shape makes for a good example to learn Processing. To create the purple coin shape in <a href="#figure2-18">Figure 2-18</a>, you’ll use the <code>beginContour()</code> and <code>endContour()</code> functions to subtract a square from a circle.</p>
			<p>
				First, you’ll create the outer shape by using the <code>beginShape()</code>, <code>endShape()</code>, and <code>vertex()</code> functions. You’ll then place the <code>beginContour()</code> and <code>endContour()</code> functions within the <code>beginShape()</code> and <code>endShape()</code> functions. Within this pair of contour functions, you’ll draw a second shape that’s also composed of <code>vertex()</code> and <code>bezierVertex()</code> functions; the contour functions subtract this shape from the outer shape.</p>
			<p><span epub:type="pagebreak" id="Page_47" title="47"/>The first challenge is creating the outer circle. The <code>beginContour()</code> and <code>endContour()</code> functions cannot subtract from predefined shape functions—like <code>rect()</code>, <code>ellipse()</code>, or <code>circle()</code>—so you need to construct the outer circle by using vertices. However, it is possible to draw circles by using Bézier curves, which you’ll do by creating a diamond and then using the control points to form it into something round.</p>
			<p>
				Begin by forming a diamond shape with <code>vertex()</code> functions (shown in <a href="#figure2-21" id="figureanchor2-21">Figure 2-21</a>):</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingGray"># coin</span><span class="ProcessingBlue">beginShape</span>()<span class="ProcessingBlue">vertex</span>(100, 600)<span class="ProcessingBlue">vertex</span>(200, 500)<span class="ProcessingBlue">vertex</span>(300, 600)<span class="ProcessingBlue">vertex</span>(200, 700)<span class="ProcessingBlue">vertex</span>(100, 600)<span class="ProcessingBlue">endShape</span>()</code></pre>
			<figure>
				<img alt="f02021" src="image_fi/500969c02/f02021.png"/>
				<figcaption>
					<p><a id="figure2-21">Figure 2-21</a>: The diamond shape that you’ll form into a circle</p>
				</figcaption>
			</figure>
			<p>
				With the vertices in the correct positions, you can proceed to add curvature to the diamond. Of course, this will require <code>bezierVertex()</code> functions, for which you’ll reference the coordinates of the vertices currently in place. For an idea of where to position the additional control-point coordinates, see <a href="#figure2-22" id="figureanchor2-22">Figure 2-22</a>.</p>
				<span epub:type="pagebreak" id="Page_48" title="48"/>
				<figure>
				<img alt="f02022" src="image_fi/500969c02/f02022.png"/>
				<figcaption>
					<p><a id="figure2-22">Figure 2-22</a>: Positioning vertices and control points to form a circle</p>
				</figcaption>
			</figure>
			<p><a href="#figure2-22">Figure 2-22</a> indicates how the control points should be positioned to form the most circular shape. Now replace each <code>vertex()</code> with a <code>bezierVertex()</code> function. Remember, though, that the first point must remain a <code>vertex()</code> to form your circle (<a href="#figure2-23" id="figureanchor2-23">Figure 2-23</a>):</p>
			<pre><code><span class="ProcessingGray"># coin</span><span class="LiteralGray">beginShape()</span><span class="LiteralGray">vertex(100, 600)</span><span class="ProcessingBlue">bezierVertex</span>(100,545, 145,500, 200,500)<span class="ProcessingBlue">bezierVertex</span>(255,500, 300,545, 300,600)<span class="ProcessingBlue">bezierVertex</span>(300,655, 255,700, 200,700)<span class="ProcessingBlue">bezierVertex</span>(145,700, 100,655, 100,600)<span class="LiteralGray">endShape()</span></code></pre>
			<figure>
				<img alt="f02023" src="image_fi/500969c02/f02023.png"/>
				<figcaption>
					<p><a id="figure2-23">Figure 2-23</a>: A circle formed using <span class="LiteralInCaption"><code>bezierVertex</code></span><span class="LiteralInCaption"><code>(</code></span><span class="LiteralInCaption"><code>)</code></span> functions</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_49" title="49"/>With the circle in place, you can go about removing a square from the middle. Once again, define this square by using vertices and not a predefined shape function, like <code>rect()</code> or <code>square()</code>. This is a relatively straightforward exercise, but be aware that you need to use <em>reverse winding</em> for the subtracted shape: you must lay the vertices of the square in a direction that’s opposite to the one you used to place the vertices of the exterior shape (the circle).</p>
			<p>Read through the circle code again and notice that the vertices are plotted in a clockwise sequence; this means that the square’s vertices must be plotted counterclockwise—that is, opposite to the winding of the shape from which it will subtract. If you fail to get this direction correct, no subtraction will take place.</p>
			<p>
				Place the square’s vertices within a <code>beginContour()</code> and <code>endContour()</code> function. Of course, you can’t observe the effect (shown in <a href="#figure2-24" id="figureanchor2-24">Figure 2-24</a>) unless you add a fill:</p>
			<pre><code><span class="ProcessingGray"># coin</span><span aria-label="annotation1" class="CodeAnnotationHang">1</span> <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#6633FF'</span>)<span class="LiteralGray">beginShape()</span><span class="LiteralGray">vertex(100, 600)</span><span class="LiteralGray">bezierVertex(100,545, 145,500, 200,500)</span><span class="LiteralGray">bezierVertex(255,500, 300,545, 300,600)</span><span class="LiteralGray">bezierVertex(300,655, 255,700, 200,700)</span><span class="LiteralGray">bezierVertex(145,700, 100,655, 100,600)</span><span aria-label="annotation2" class="CodeAnnotationHang">2</span> <span class="ProcessingBlue">beginContour</span>()<span class="ProcessingBlue">vertex</span>(180, 580)<span class="ProcessingBlue">vertex</span>(180, 620)<span class="ProcessingBlue">vertex</span>(220, 620)<span class="ProcessingBlue">vertex</span>(220, 580)<span aria-label="annotation3" class="CodeAnnotationHang">3</span> <span class="ProcessingBlue">endContour</span>()<span class="LiteralGray">endShape()</span></code></pre>
			<figure>
				<img alt="f02024" src="image_fi/500969c02/f02024.png"/>
				<figcaption>
					<p><a id="figure2-24">Figure 2-24</a>: The completed coin</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_50" title="50"/>Without the fill <span aria-label="annotation1" class="CodeAnnotation">1</span>, you would see only white outlines. The <code>beginContour()</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span> starts recording the vertices that make up the negative shape. No <code>bezierVertex()</code> functions are necessary, because a square has no curves. The vertices follow a counterclockwise sequence, beginning at the upper left corner of the square (<code>180, 580</code>), proceeding directly downward (to <code>180, 620</code>) and then farther around before the <code>endContour()</code> stops recording <span aria-label="annotation3" class="CodeAnnotation">3</span>.</p>
			<h2 id="h1-500969c02-0005">Using Vector Graphics Software for Generating Shapes</h2>
			<p class="BodyFirst">You can use vector graphics drawing software to draw shapes, and then reference the positions of the vertices and control points for writing Processing code. This is how I mapped out the blue guidelines for the Python logo shown in <a href="#figure2-25" id="figureanchor2-25">Figure 2-25</a>.</p>
			<figure>
				<img alt="f02025" src="image_fi/500969c02/f02025.png"/>
				<figcaption>
					<p><a id="figure2-25">Figure 2-25</a>: Tracing a Python logo that includes the positions of the vertices and control points. (The Python Software Foundation logo trademark policy is available at <a class="LinkURL" href="https://www.python.org/psf/trademarks/">https://www.python.org/psf/trademarks/</a>.)</p>
				</figcaption>
			</figure>
			<p>
				If you’re up for a challenge, clear out your <em>curves</em> sketch and try finishing the half of the Python logo I’ve begun in <a href="#figure2-25">Figure 2-25</a>. Here is some code to get the outline started:</p>
			<pre><code><span class="ProcessingBlue">beginShape</span>()<span class="ProcessingBlue">vertex</span>(262, 238)<span class="ProcessingBlue">vertex</span>(262, 178)<span epub:type="pagebreak" id="Page_51" title="51"/><span class="ProcessingBlue">bezierVertex</span>(262,40, 370,30, 500,30)<span class="ProcessingBlue">bezierVertex</span>(630,30, 730,40, 735,178)<span class="ProcessingBlue">endShape</span>()</code></pre>
			<p>
				You can also export vector graphics as SVG files for use in Processing with the <code>loadShape()</code> and <code>shape()</code> functions, as opposed to the <code>loadImage()</code> and <code>image()</code> functions. But be warned: SVG support is not always dependable, and you may spend some time fiddling with your SVG export settings to get them to display properly in Processing.</p>
			<h2 id="h1-500969c02-0006">Summary</h2>
			<p class="BodyFirst">You’ve now learned most of Processing’s essential drawing features. Using a grid graphic as a reference for your coordinates, you learned to plot curves that mimic physical splines. In addition, you learned to draw Bézier curves—smooth, graceful curves that you can control with anchor and control points. You also saw how to draw shapes by using a series of vertices. When you connect vertices with straight lines and curves, the shape possibilities are limitless. You’ll be using curves, vertices, and the skills you learned in <span class="xref">Chapter 1</span> in many of the tasks to come.</p>
			<p>
				In <span class="xref">Chapter 3</span>, you’ll move on to explore Processing’s text features. This includes drawing text to the display window, styling it, and loading fonts. You’ll also look at Python’s built-in features for manipulating string data. Later in this book, you’ll use text functions to label graphs and graphical interface elements, and to add speech bubbles to images.</p>
		</section>
	</body></html>