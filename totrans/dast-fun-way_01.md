# 1

内存中的信息

![](img/chapterart.png)

任何稍微有趣的计算机程序都需要能够从内存中存储和访问数据。这些数据可能是文档中的文本、网页上的信息，或者存储在数据库中的我们品尝过的各种咖啡的详细信息。在每种情况下，数据对程序执行其预定功能至关重要。

这些示例仅代表用户看到并思考的数据。程序还必须跟踪许多幕后数据，比如我们通过一个循环的次数、游戏中角色的当前位置，或当前的系统时间。如果没有这些数据，程序就无法表示其内部状态的变化。

本章将介绍存储数据到内存的基本知识。我们将探讨最简单的数据结构——普通变量、复合数据结构和数组——如何存储它们的数据。我们还将介绍本书的伪代码约定。对于有编程经验的读者，本章的关键概念可能已经熟悉。尽管如此，这些概念依然是我们旅程的关键起点，值得回顾，因为它们为构建更强大、更激动人心的数据结构提供了基础。

## 变量

单个数据项通常存储在*变量*中，变量本质上是表示计算机内存中某个数据位置（或*地址*）的名称。即便是对编程略有了解的读者也应该对变量有所了解：它们是计算机科学中的基础概念，是即使是最简单程序所必需的。变量使程序能够跟踪在程序执行过程中发生变化的信息。需要计算你通过了多少次`FOR`循环吗？跟踪游戏中玩家的得分？计算你在写关于变量的引言章节时犯了多少拼写错误？使用变量。

没有变量，程序员无法跟踪、评估或更新程序的内部状态。当你创建一个变量时，系统会在幕后分配并为其指定一个位置。然后，你可以自由地使用你选择的变量名将数据写入该位置，并使用相同的名称查找它。只要你知道变量的名称，就不需要知道数据的内存位置。我们可以将计算机的内存想象成一个长长的箱子列。每个变量根据其大小占用一个或多个连续的箱子，如图 1-1 所示，显示了三个变量：`Level`、`Score`和`AveScore`。在这个示意图中，平均分数（`AveScore`）是一个浮点数（带有小数的数字），它使用了两个内存箱子。

![一张图显示，值为 20 的 level 变量占用一个箱子，值为 109 的 score 变量占用一个箱子，值为 100.111111 的平均分数变量占用两个箱子。](img/f01001.png)

图 1-1：计算机内存以一列箱子的形式呈现

从某种意义上讲，变量就像文件夹上的小纸标签，就像在图 1-2 中所示的那样：一旦我们贴上标签，就不需要记住文件夹的顺序或具体的存储方式。我们只需通过标签查找文件夹——但这也意味着使用具有信息量的名称非常重要。作者自己的文件柜里塞满了标签模糊的文件夹，标签上写着*Stuff*、*Misc*、*Important* 和 *Other Stuff*，让人很难知道里面存了什么。同样，模糊的变量名也使得很难猜测它们代表的值。

![带有标签标签的文件，标签突出，便于快速找到文件。从前到后，标签依次为 Level、Top Score、Score 和 Other Stuff。](img/f01002.png)

图 1-2：变量就像文件夹上的标签一样，提供了一种方便的方式来查找和访问存储的值。

在许多编程语言中，变量有一个关联的类型，用来标明它们存储的数据类型，例如整数、用于浮动值的“浮点数”或表示真假值的布尔类型。这些类型告诉程序变量占用的内存大小及其使用方式。例如，布尔变量存储的值范围有限，通常只需要很少的内存。而双精度浮点数可能存储一个更大且更精确的数值，因此需要占用多个内存单元。定义类型的语法，甚至是否需要显式定义类型，在不同的编程语言中都有所不同。

在本书中，我们将使用语言无关的 `<type>: <name>` 伪代码格式来指定示例中的变量。例如：

```py
Integer: coffee_count = 5
Float: percentage_words_spelled_correctly = 21.0
Boolean: had_enough_coffee = False
```

有时，变量会被定义为一般类型 `Type`，表示它可能根据实现的不同而具有一系列类型。我们将使用大多数编程语言中的典型语法来操作这些变量，包括使用 `=` 进行赋值：

```py
coffee_count = coffee_count + 1
```

对于数字类型，包括整数和浮点数，我们将使用标准的算术运算符，如 `+`、`-`、`*` 和 `/`。对于布尔数据类型，我们将使用布尔运算符，如 `AND`、`OR` 和 `NOT`。你在程序中需要使用的语法将取决于你使用的编程语言（这也是不同编程语言优劣之争的常见焦点）。

## 复合数据结构

许多编程语言提供了创建*复合数据结构*的功能，如结构体或对象，它们将多个单独的变量组合成一个整体。复合数据结构提供了一种便捷的方式来收集相关的数据片段并将它们一起传递。例如，我们可能会定义一个 `CoffeeRecord` 来跟踪我们品尝过的咖啡种类的一些信息：

```py
CoffeeRecord {
    String: Name
    String: Brand
    Integer: Rating
    Float: Cost_Per_Pound
    Boolean: Is_Dark_Roast
    String: Other_Notes
}
```

与其维护六个单独的变量来跟踪一杯咖啡的属性，我们将所有这些信息存储在一个单一的复合数据结构中，`CoffeeRecord`。当然，真正的咖啡鉴赏家可能会跟踪几百个附加属性，以及与咖啡消费相关的日期、时间、地点和天气条件的精确信息。毕竟，咖啡是一个复杂的主题，值得详细记录。每一个附加属性进一步强调了使用复合数据结构的重要性：传递几百个相关变量不仅麻烦，而且还增加了程序员犯错的概率，比如把变量传递给函数的顺序错误。

名片提供了一个现实世界的复合数据结构示例。每张名片都是一个包含多个信息的数据包，比如你的名字、电话号码和电子邮件地址。将这些信息捆绑到一张名片中，能够提高跟踪和传递的效率。想象一下，如果你要将五张不同的纸条，每张纸条上只包含一个数据点，交给同事时，那将是多么混乱和困惑。

在许多编程语言中，包括 Java 和 Python，数据复合体可以采取*对象*的形式，包含数据和用于操作数据的函数。对象的函数使用特殊的语法来访问该对象的数据，比如 Python 中的 `self` 引用。一个对象还可以提供不同的可见性规则，指定它的内部数据是否可以在对象的函数外部公开访问，或者只能私下访问。

为了尽量保持通用性，我们将复合数据结构视为它们最通用的形式：作为一组数据。尽管本书及其他地方的示例代码可能将复合数据结构实现为对象，但这些算法也可以调整为使用非对象的表示形式。在使用复合数据结构或对象的代码中，我们使用 `composite.field` 的语法来表示访问复合数据结构的特定字段。例如，使用以下代码：

```py
latest_record.name = "Sublime Blend"
```

我们将咖啡记录 `latest_record` 中的 `name` 字段设置为 `Sublime Blend`。

## 数组

*数组*通常用于存储多个相关的值。例如，我们可能想要跟踪一整年每天消耗的咖啡量。我们可以通过创建 365 个单独的变量，例如 `AmountDay1`、`AmountDay2`、`AmountDay3` 等，来强行存储这些数据，但这既麻烦又无法为数据使用任何结构。`AmountDay2` 只是一个文本标签，程序并不知道 `AmountDay1` 存储的是前一天的信息，`AmountDay3` 存储的是后一天的信息；只有程序员知道这一点。

数组提供了一种简单的机制，用于将多个值存储在相邻且可以索引的箱子中。数组实际上是一排变量——在计算机内存中连续的相同大小的箱子，如图 1-3 所示。与单个变量类似，数组占用一块内存，并且可以与其他任意信息相邻。数组中的每个箱子可以存储给定类型的值，例如数字、字符、指针，甚至其他（固定大小的）数据结构。

![一列 12 个箱子。一个数组占据了中间的 5 个箱子，数组下方的 4 个箱子和上方的 3 个箱子标记为“其他物品”。](img/f01003.png)

图 1-3：计算机内存中的数组作为箱子

数组在我们现实生活中也无处不在。例如，学校走廊上的一排储物柜就是一个物理数组，用于存放学生的外套和书籍。我们可以通过打开相应的储物柜来访问任何一个独立的存储容器。

数组的结构使得你可以通过指定其位置或*索引*，访问数组中的任何值，也叫做*元素*。这些箱子占据计算机内存中的相邻位置，因此我们可以通过计算它们与第一个元素的偏移量来访问单个箱子，并读取该位置的内存。这只需要一次加法运算和内存查找，无论我们访问哪个箱子。这个结构使得数组特别适合存储具有顺序关系的项目，例如我们的每日咖啡摄入量跟踪器。

正式地，我们用 `A[i]` 来引用数组 `A` 中索引为 `i` 的值。在我们的储物柜示例中，索引就是储物柜正面显示的数字。大多数编程语言使用*零索引数组*，这意味着数组的第一个值位于索引 0，第二个值位于索引 1，以此类推，如图 1-4 所示。

![一张图表展示了一系列存储在九个箱子中的值。每个值下方是其索引值。最左侧的索引值为零，索引值依次增加，右侧为 8。](img/f01004.png)

图 1-4：零索引数组

本书将使用零索引数组，以遵循一般计算机的惯例。图 1-5 展示了零索引数组在计算机内存中的表现，其中白色区域为数组的元素。

![一列 12 个箱子。一个数组占据了中间的 5 个箱子，这 5 个箱子标记为 A 零到 A 四。](img/f01005.png)

图 1-5：零索引数组在计算机内存中的排列

零索引允许我们方便地计算元素在内存中的位置，作为从数组在内存中开始位置的偏移量。数组中第 *i* 项的位置信息可以通过以下方式计算：

*位置*(*项* i) = *位置*(*数组开始*) + *每个元素的大小* × i

索引为零的元素位置是数组的起始位置。例如，图 1-5 中的示例数组`A`的第五个元素就是`A[4]`，并且根据图 1-4 中的索引值，它包含值 9。

在大多数编程语言中，我们通过数组的名称和索引的组合来获取和设置数组中的值。例如，我们可以将索引为 5 的箱子的值设置为 16：

```py
A[5] = 16
```

对于我们的咖啡追踪示例，我们可以定义一个数组`Amount`来存储每天消费的杯数，并将相应的数量存储在`Amount[0]`到`Amount[364]`中。这个单一的数组让我们可以通过一个变量名顺序访问 365 个不同的值。我们已经从一系列类似名称的、但独立的变量，过渡到了单一位置的数学偏移。为了理解这一点，考虑一下我们的学校储物柜。如果把每个储物柜命名为“Jeremy 的储物柜”或“姓氏以 K 开头的第三个学生的储物柜”，它们几乎不可能快速找到。学生们不能简单地通过访问特定索引，而是需要检查大量储物柜，比较文本标签，直到找到正确的匹配。通过数组索引，学生们只需使用偏移量就能确定储物柜的位置并直接访问它。

尽管我们通常把数组视为整个数据结构来讨论和可视化，但重要的是要记住，每个箱子都像一个独立的变量。当我们想对数组进行全局更改时，比如将元素向前移动一个位置，我们需要像图 1-6 中所示的那样，分别对每个箱子应用更改。

![图示显示了 8 个箱子。箭头表示箱子中的值都向左移动了 1 个箱子。](img/f01006.png)

图 1-6：将元素在数组中逐个向前移动

数组不像书架上的书籍。我们不能一次性把整个集合推到一边，为最新版本的*《咖啡爱好者指南：最佳自由贸易咖啡》*腾出空间。数组更像是一排店面。我们不能仅仅把一家新的咖啡店挤到我们最喜欢的邻里书商和理发店之间。为了腾出空间，我们需要一个一个地将店面往后移，先清空每个商店，再把其中的物品移到邻近的建筑里。

事实上，我们必须处理一些值才能交换数组中的两个值。例如，要交换索引`i`和`j`上的值，我们需要先将其中一个值赋给一个临时变量：

```py
Temp = A[i]
A[i] = A[j]
A[j] = Temp
```

否则，我们将会覆盖其中一个箱子里的值，导致两个箱子拥有相同的值。同样地，如果我们要交换咖啡店和书商的位置，我们首先需要将书店的内容移到一个空的第三位置，以便为咖啡店的内容腾出空间。只有在我们将咖啡店的内容移动后，才能把书店的内容从临时的第三位置移到咖啡店原来的位置。

### 插入排序

了解数组结构如何影响其使用的最佳方式是将其放在实际算法的背景下进行考察。*插入排序* 是一种用于排序数组中值的算法。它适用于任何可以排序的值类型。我们可以排序整数、字符串，甚至按过期日期排序我们储藏室中的咖啡。

插入排序通过排序数组的一个子集并扩展已排序的范围，直到整个数组排序完成。该算法遍历未排序数组中的每个元素，并将其移动到已排序部分的正确位置。在第`i`次迭代开始时，箱子 0 到 `i` − 1 中的项目已经排序好。然后，算法会取出索引为 `i` 的元素，找到其在已排序前缀中的正确位置并插入，同时将必要的元素向下移动以腾出空间。已排序的前缀现在已经扩展了一个—箱子 0 到 `i` 的项目已排序好。我们可以从 `i` = 1 开始，声明第一个元素为初始已排序前缀。

假设我们想按照新鲜度对咖啡集合进行排序——毕竟，如果把一袋优质咖啡留在储藏室的最深处直到过期，那真是太遗憾了。我们需要把最早的最佳食用日期移到架子的左侧，以便它们随时可用。

我们通过声明将前面的一个袋子视为*已排序*，并以此范围作为我们的已排序前缀，开始我们的咖啡插入排序。然后，我们查看架子上的第二个袋子，比较日期以确定它是否应该排在第一个袋子之前。在我们交换顺序，或者确定不需要交换之后，我们可以自信地宣告前两个元素已经排序好。我们已经拥有一个完全排序的子集。接着，我们继续处理第三个袋子，确定它应该相对于前两个袋子的位置，可能在过程中会进行一些交换。这个过程一直持续，直到我们完成咖啡的完美组织。

我们可以通过一对嵌套循环来实现插入排序，如清单 1-1 所示。

```py
InsertionSort(array: A):
    Integer: N = length(A)
    Integer: i = 1
  ❶ WHILE i < N:
        Type: current = A[i]
        Integer: j = i - 1  
      ❷ WHILE j >= 0 AND A[j] > current:
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = current
        i = i + 1
```

清单 1-1：使用嵌套循环实现插入排序

外部循环的迭代器 `i` 从第一个未排序的元素 `i = 1` 开始，并向前遍历未排序范围中的每个值 ❶。内部循环的迭代器 `j` 将当前值移动到已排序前缀中 ❷。在每一步中，我们通过将 `current` 值与前一个位置（即前缀中的索引 `j`）进行比较，来检查已排序前缀中的位置。如果 `j` 位置的元素较大，说明这两个值顺序错误，需要交换。由于我们将当前值存储在一个单独的变量 `current` 中，我们可以直接复制前一个桶中的数据，而不需要进行完整的交换。内部循环会持续进行，直到将当前值移到数组的前面，或者找到一个较小的前置值，这表明当前值已经在已排序前缀的正确位置。只有当当前值处于正确的位置时，我们才会在循环结束时写入当前值。然后，外部循环会继续处理下一个未排序的值。

我们可以如图 1-7 所示，直观地展示算法的行为。每一行显示的是迭代开始时数组的状态。阴影框代表当前正在移动到合适位置的元素，箭头表示相应的移动。

![一个图示显示通过 8 次迭代的 8 个桶。开始时，零索引处的值为 61，假定它已排序。第二个值是 82，它保持不变。第三个值是 67，它与 82 交换位置。第四个值是 4，它被移动到索引零处；前三个值依次向前移动一位，为 4 腾出空间。依此类推，直到所有八个值按从小到大的顺序排列。](img/f01007.png)

图 1-7：插入排序算法的可视化

插入排序并不是特别高效。在将元素插入数组时，我们可能需要移动数组中的大部分元素。在最坏的情况下，算法的开销与元素数量的平方成正比——每插入一个元素，我们需要将其前面的所有元素向后移动。如果我们将数组的大小翻倍，最坏情况下的开销会增加四倍。虽然在我们的咖啡储藏室里，这可能不会造成很大问题，因为我们可能只会保存少量咖啡，并且能在咖啡变质前消费掉它们，但算法的平方开销在许多应用中会急剧上升。

然而，插入排序提供了关于数组如何工作的一个重要见解。在这个简单的算法中，我们展示了数组的几个特性，包括通过索引访问元素的能力、在插入新元素时交换值的能力，以及遍历条目的宝贵能力。

## 字符串

*字符串*是有序的字符列表，通常可以被视为一种特殊类型的数组。字符串中的每个槽位包含一个单独的字符，无论是字母、数字、符号、空格，还是有限集合中的特殊指示符。通常使用特殊字符表示字符串的结束，例如在图 1-8 中的最后一个槽位使用的`/`。字符串中的字符通常可以通过其索引直接访问。

![一张图示，展示了 13 个字符，索引从 0 到 12。字符拼写为“Hello World”，感叹号，最后一个字符是斜杠。](img/f01008.png)

图 1-8：一个拼写为“Hello world!”的字符串

在某些编程语言中，字符串直接实现为简单的字符数组。而在其他语言中，字符串可能是对象，字符串类充当字符数组或其他数据结构的包装器。字符串的包装类提供了附加功能，例如动态调整字符串大小或查找子字符串的能力。在任何情况下，思考一般的类似数组的结构如何影响字符串操作是有用的。当我们在计算机屏幕上显示字符串时，我们实际上是在逐个字符地迭代并依次显示它们。

检查相等性的一般测试更具趣味性。与整数可以通过单一操作直接比较不同，字符串必须通过迭代每个字符进行比较。程序逐个比较字符并返回是否发现不匹配。

列表 1-2 展示了检查两个字符串相等性的算法。该算法首先比较字符串的大小。如果它们的长度不同，算法就会停止。如果它们长度相同，算法会逐个位置进行迭代并比较每个字符串中的相应字符。当我们发现第一个不匹配时，就可以终止循环。只有当我们在没有发现不匹配的情况下遍历完整个字符串，我们才可以声明两个字符串相等。

```py
StringEqual(String: str1, String: str2):
    IF length(str1) != length(str2):
        return False
    Integer: N = length(str1)
    Integer: i = 0
    WHILE i < N AND str1[i] == str2[i]:
        i = i + 1
    return i == N
```

列表 1-2：检查两个字符串相等性的算法

图 1-9 展示了这个算法如何作用于两个字符串。等号表示在比较时匹配的字符对。X 表示第一个不匹配的字符对，在此处测试终止。

![两个字符串，Hello world 和 Hello friend。等号显示前 6 个字符相同。位置 7 的 X 表示 W 和 F 不同。](img/f01009.png)

图 1-9：两个字符串的比较

字符串比较的最坏情况下的计算成本随着字符串长度的增加而成比例增长。虽然比较两个小字符串所需的工作可能微不足道，但对两个长字符串进行相同操作则可能会耗时。为了做个比较，想象一下通过两本相同书籍逐字扫描，寻找每个不同之处的乏味过程。最好的情况是，我们可以很早就发现不匹配的地方。最坏的情况是，我们需要检查整本书的大部分内容。

许多编程语言，如 Python，提供了一个字符串类，允许直接进行比较，因此我们不需要在清单 1-2 中直接实现比较代码。然而，在简单的比较函数下面，实际上有一个循环在迭代所有字母。如果不了解这个关键细节，就有可能严重低估字符串比较的成本。

## 为什么这很重要

变量和数组是编程入门课程中的基础，因此它们可能看起来不太令人兴奋，但它们值得深入研究，因为它们为计算机编程和数据结构提供了根本的基础。这些概念还为评估动态数据结构及其对算法的影响提供了基准。在后面的章节中，我们将看到动态数据结构如何在效率、灵活性和复杂性之间提供不同的权衡。
