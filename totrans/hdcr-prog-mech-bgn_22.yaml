- en: '17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '17'
- en: READING INPUT FROM A FILE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件读取输入
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: Any engineering application we develop will require some data input. For example,
    to solve a truss structure using the algorithm we developed in the previous chapter,
    we first need to construct the structure model. It’d be tedious to manually instantiate
    the classes to construct the model every time we want to solve a structure; it’d
    be more convenient to simply pass our app a plaintext file that follows a given
    and well-defined scheme defining the structure we want to solve. In this chapter,
    we’ll equip our app with a file parser function that reads text files, interprets
    them, and constructs the model that the app uses internally.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的任何工程应用都需要一些数据输入。例如，要使用我们在上一章中开发的算法解决一个桁架结构问题，我们首先需要构建结构模型。每次想要解决结构问题时手动实例化类来构建模型是非常繁琐的；如果我们能简单地将一个符合给定且明确定义的方案的纯文本文件传递给应用程序，定义我们想要解决的结构，那将更加方便。在本章中，我们将为我们的应用程序配备一个文件解析器功能，它可以读取文本文件，解释文件内容，并构建应用程序内部使用的模型。
- en: '**Defining the Input Format**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义输入格式**'
- en: For our application to work, the files we feed it need to have a well-defined
    structure. The text file has to include the definition of the nodes, the loads
    applied to them, and the bars of the structure. Let’s decide on a format for each
    of these parts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序正常工作，我们提供给它的文件必须具有明确定义的结构。文本文件必须包括节点的定义、施加到它们的载荷以及结构的杆件。让我们为这些部分决定一种格式。
- en: '***The Nodes Format***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***节点格式***'
- en: Each node will be defined in its own line, following this format,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点将在它自己的行中定义，遵循以下格式，
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '*node_id* is the ID given to the node.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*node_id* 是赋予节点的 ID。'
- en: '*x_coord* is the x position of the node.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x_coord* 是节点的 x 位置。'
- en: '*y_coord* is the y position of the node.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y_coord* 是节点的 y 位置。'
- en: '*external_constraints* is a set of the constrained movements.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*external_constraints* 是一组约束运动。'
- en: 'Here’s an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This defines a node with an ID of 1, at position (250, 400), with its x and
    y displacements externally constrained.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个 ID 为 1 的节点，位置为 (250, 400)，其 x 和 y 位移受到外部约束。
- en: '***The Loads Format***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***载荷格式***'
- en: Loads will be defined separately from the nodes they’re applied to, so we’ll
    have to indicate the ID of the node where the load is applied. Having the nodes
    and loads defined in different lines allows us to simplify the input parsing process
    by using two simple regular expressions (one for the nodes and another for the
    loads) instead of one long and complicated regular expression. Each load will
    be defined on a separate line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 载荷将与其应用的节点分开定义，因此我们需要指明载荷应用的节点 ID。将节点和载荷定义在不同的行可以通过使用两个简单的正则表达式（一个用于节点，另一个用于载荷）来简化输入解析过程，而不必使用一个长且复杂的正则表达式。每个载荷将在单独的一行中定义。
- en: Let’s use the following format for loads,
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下格式来定义载荷，
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: where
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '*node_id* is the node where the load is applied.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*node_id* 是载荷作用的节点。'
- en: '*Fx* is the x component of the load.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fx* 是载荷的 x 分量。'
- en: '*Fy* is the y component of the load.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fy* 是载荷的 y 分量。'
- en: 'Here’s an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This defines a load ⟨500,–1000⟩ applied to the node with an ID of 3\. We’re
    using the -> character sequence to separate the node ID from the load components
    instead of a colon so that it’s clear we’re not assigning an ID to the load itself.
    Rather, we’re applying the load to the node with that ID.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个载荷 ⟨500,–1000⟩，作用在 ID 为 3 的节点上。我们使用 -> 字符序列来分隔节点 ID 和载荷分量，而不是使用冒号，以便明确我们不是将
    ID 分配给载荷本身，而是将载荷应用于具有该 ID 的节点。
- en: '***The Bars Format***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***杆件格式***'
- en: Bars are defined between two nodes and have a section and Young’s modulus. As
    with nodes and loads, each bar will be defined on its own line. We can give bars
    the following format,
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 杆件定义在两个节点之间，并具有截面和杨氏模量。与节点和载荷一样，每个杆件将定义在它自己的行中。我们可以为杆件设置以下格式，
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: where
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '*bar_id* is the ID given to the bar.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bar_id* 是赋予杆件的 ID。'
- en: '*start_node_id* is the ID of the start node.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*start_node_id* 是起始节点的 ID。'
- en: '*end_node_id* is the ID of the end node.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*end_node_id* 是结束节点的 ID。'
- en: '*A* is the cross-section area.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* 是横截面积。'
- en: '*E* is the Young’s modulus.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E* 是杨氏模量。'
- en: 'Here’s an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a bar between nodes 1 and 2, with a cross section of 30 and a Young’s
    modulus of 20000000. This bar is given an ID of 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个位于节点 1 和 2 之间的杆件，横截面积为 30，杨氏模量为 20000000。这个杆件的 ID 设置为 1。
- en: '***The File Format***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件格式***'
- en: Now that we’ve come up with a format for the nodes, loads, and bars, let’s see
    how we can put them all together in one file. We’re looking for a file structure
    that’s simple to write by hand but that’s also easy to parse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为节点、荷载和杆件设计了格式，让我们看看如何将它们组合到一个文件中。我们正在寻找一种既容易手动编写又容易解析的文件结构。
- en: 'One interesting idea is to divide the file into sections, each opened by a
    header:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的想法是将文件分成几个部分，每个部分由一个标题开始：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each section should contain only the lines defining entities of the same type.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分应仅包含定义相同类型实体的行。
- en: 'Given that our structure definition files will have three different kinds of
    entities—nodes, loads, and bars—they’ll need three different sections. For example,
    the structure we used for the unit tests in the previous chapter, included here
    as [Figure 17-1](ch17.xhtml#ch17fig1), would be defined as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的结构定义文件将包含三种不同类型的实体——节点、荷载和杆件——因此它们需要三个不同的部分。例如，我们在上一章的单元测试中使用的结构，这里作为[图
    17-1](ch17.xhtml#ch17fig1)展示，将按如下方式定义：
- en: '![Image](../images/17fig01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/17fig01.jpg)'
- en: '*Figure 17-1: Structure from previous chapter’s unit tests*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-1：来自上一章单元测试的结构*'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we’ve defined a format for our structure definition files, we need
    to work on a parser. A *parser* is a component (a function or class) that reads
    text, interprets it, and translates it into a data structure or model. In this
    case, the model is our truss structure class: Structure. We’ll use regular expressions,
    as we did in [Chapter 9](ch09.xhtml#ch09).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为结构定义文件定义了格式，接下来需要开发一个解析器。一个*解析器*是一个组件（函数或类），它读取文本，解释它，并将其转换为数据结构或模型。在这种情况下，模型是我们的桁架结构类：Structure。我们将像在[第9章](ch09.xhtml#ch09)中一样使用正则表达式。
- en: '**Finding the Regular Expressions**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找正则表达式**'
- en: 'If we know the structure ahead of time, regular expressions are a reliable
    way of extracting all the information we need from plaintext. We’ll need three
    different regular expressions: one for the nodes, one for the loads, and one for
    the bars. If you need a refresher on regular expressions, take a moment to review
    “Regular Expressions” on [page 9](ch01.xhtml#page_9). Let’s design these regular
    expressions.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们事先知道结构，正则表达式是一种可靠的提取纯文本中所有需要信息的方法。我们将需要三种不同的正则表达式：一个用于节点，一个用于荷载，一个用于杆件。如果你需要复习正则表达式，请花点时间回顾一下[第9页](ch01.xhtml#page_9)中的“正则表达式”部分。让我们设计这些正则表达式。
- en: '***The Nodes Regex***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***节点正则表达式***'
- en: 'To match nodes defined in our format, we can use the following regular expression:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配我们格式中定义的节点，我们可以使用以下正则表达式：
- en: /(?P<id>\d+)\s*:\s*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<id>\d+)\s*:\s*
- en: \((?P<pos>[\d\s\.,\-]+)\)\s*
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<pos>[\d\s\.,\-]+)\)\s*
- en: \((?P<ec>[xy]{0,2})\)/
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<ec>[xy]{0,2})\)/
- en: This is one scary regular expression. It’s split between several lines because
    it was too long to fit in a single line, but you can imagine it as being just
    one line. Let’s break down this regular expression into its parts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常复杂的正则表达式。它被分成了几行，因为它太长，无法放入一行，但你可以想象它只是一个单行的正则表达式。让我们分解这个正则表达式的各个部分。
- en: (?P<id>\d+) This matches the node’s ID, a number with one or more digits (\d+),
    and captures it in a group named id.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<id>\d+) 这匹配节点的 ID，一个由一位或多位数字组成的数字（\d+），并将其捕获为名为 id 的组。
- en: \s*:\s* This matches the colon after the ID with arbitrary and optional spaces
    around it (\s*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: \s*:\s* 这匹配 ID 后的冒号，并允许冒号前后有任意数量的空格（\s*）。
- en: \((?P<pos>[\d\s\.,\-]+)\) This matches the node’s position coordinates inside
    the parentheses and captures them in a group named pos. Note that we match the
    whole expression between the parentheses; that includes the two coordinates and
    the comma that separates them. We’ll split the two numbers in code. We do it this
    way so that our already monstrous regular expression doesn’t become even scarier.
    Combining regular expressions with Python’s string manipulation methods is a powerful
    technique.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<pos>[\d\s\.,\-]+)\) 这匹配括号内的节点位置坐标，并将其捕获为名为 pos 的组。请注意，我们匹配的是括号内的整个表达式；它包括两个坐标和分隔它们的逗号。我们将在代码中分割这两个数字。我们这样做是为了避免让我们已经非常庞大的正则表达式变得更加可怕。将正则表达式与
    Python 的字符串操作方法结合起来是一种强大的技术。
- en: \s* This matches zero or more spaces separating the coordinates group from the
    external constraints group.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: \s* 这匹配零个或多个空格，用于分隔坐标组和外部约束组。
- en: \((?P<ec>[xy]{0, 2})\) This last part matches the external constraints defined
    between parentheses and captures them in a group named ec. The contents inside
    the parentheses are limited to the character group [xy], that is, the characters
    “x” and “y.” There’s also a constraint in the number of characters allowed, which
    is any number between 0 and 2 ({0, 2}).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<ec>[xy]{0, 2})\) 这一部分匹配括号内定义的外部约束，并将其捕获到名为ec的组中。括号内的内容限于字符集[xy]，即字符“x”和“y”。字符数也有限制，允许的字符数为0到2之间（{0,
    2}）。
- en: We’ll see this regular expression in action soon. [Figure 17-2](ch17.xhtml#ch17fig2)
    may help you understand each of the subparts in the regular expression.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会看到这个正则表达式的实际应用。[图17-2](ch17.xhtml#ch17fig2)可能会帮助你理解正则表达式中每个子部分的含义。
- en: '![Image](../images/17fig02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/17fig02.jpg)'
- en: '*Figure 17-2: Node regular expression visualized*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-2：节点正则表达式的可视化*'
- en: Let’s take a look at how to parse the loads.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何解析负载。
- en: '***The Loads Regex***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***负载正则表达式***'
- en: 'To match loads written with the format we defined, we’ll use the following
    regular expression:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配使用我们定义的格式编写的负载，我们将使用以下正则表达式：
- en: /(?P<node_id>\d+)\s*->\s*\((?P<vec>[\d\s\.,\-]+)\)/
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<node_id>\d+)\s*->\s*\((?P<vec>[\d\s\.,\-]+)\)/
- en: This regular expression isn’t quite as scary as the previous one; let’s break
    it down into its subparts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式并不像前一个那样可怕；让我们将其分解为多个子部分。
- en: (?P<node_id>\d+) This matches the node ID and captures it in a group named node_id.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<node_id>\d+) 这个表达式匹配节点ID，并将其捕获到名为node_id的组中。
- en: \s*->\s* This matches the -> character sequence and the optional blank spaces
    around it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: \s*->\s* 这个表达式匹配`->`字符序列及其周围的可选空格。
- en: \((?P<vec>[\d\s\.,\-]+)\) This matches the entire expression between the parentheses,
    where the force vector components are defined. The character set [\d\s\.,\-] inside
    the parentheses is allowed; this includes digits, spaces, dots, commas, and minus
    signs. Whatever is captured is stored in a capture group named vec.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<vec>[\d\s\.,\-]+)\) 这个表达式匹配括号内的整个内容，其中定义了力向量分量。括号内允许的字符集是[\d\s\.,\-]，包括数字、空格、点、逗号和减号。捕获的内容会存储在名为vec的捕获组中。
- en: '[Figure 17-3](ch17.xhtml#ch17fig3) is a breakdown of the regular expression’s
    different parts. Make sure you understand each of them.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-3](ch17.xhtml#ch17fig3)是正则表达式不同部分的分解。确保你理解它们的每一部分。'
- en: '![Image](../images/17fig03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/17fig03.jpg)'
- en: '*Figure 17-3: Load regular expression visualized*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-3：负载正则表达式的可视化*'
- en: Lastly, let’s take a look at the regular expression for the bars.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看条形的正则表达式。
- en: '***The Bars Regex***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条形正则表达式***'
- en: 'To match bars written using the format we defined earlier, we’ll use the following
    regular expression:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配使用我们之前定义的格式编写的条形，我们将使用以下正则表达式：
- en: /(?P<id>\d+)\s*:\s*
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<id>\d+)\s*:\s*
- en: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\)\s*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\)\s*
- en: (?P<sec>[\d\.]+)\s+
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<sec>[\d\.]+)\s+
- en: (?P<young>[\d\.]+)/
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<young>[\d\.]+)/
- en: 'This regular expression was also broken down into several lines because of
    its length, but you can imagine it as being written in one line. Let’s break it
    down piece by piece:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式因为其长度也被拆分成了几行，但你可以想象它是写在一行中的。让我们逐步分析它：
- en: (?P<id>\d+) This matches the ID assigned to the bar and captures it in the group
    named id.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<id>\d+) 这个表达式匹配分配给条形的ID，并将其捕获到名为id的组中。
- en: \s*:\s* This matches the colon character and the optional blank space around
    it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: \s*:\s* 这个表达式匹配冒号字符及其周围的可选空白字符。
- en: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\) This matches the two node IDs separated
    by the -> character sequence and the optional space around it. The IDs are captured
    in the groups named start_id and end_id. This whole expression is required to
    appear between parentheses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\) 这个表达式匹配由`->`字符序列分隔并且周围有可选空格的两个节点ID。ID会被捕获到名为start_id和end_id的组中。整个表达式需要出现在括号内。
- en: \s* This matches the optional blank space between the last parenthesis and the
    next value, the section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: \s* 这个表达式匹配最后一个括号与下一个值（即节）之间的可选空白字符。
- en: (?P<sec>[\d\.]+) This captures a decimal number and assigns it to the group
    named sec.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<sec>[\d\.]+) 这个表达式捕获一个十进制数，并将其赋值给名为sec的组。
- en: \s+ This matches the required blank space between the last parenthesis and the
    next value, the Young modulus. Recall that, in this case we need at least one
    space. Otherwise, there would be no way to know where the value for the section
    ends and the value for the Young modulus begins.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: (?P<young>[\d\.]+) This captures a decimal number and assigns it to the group
    named young.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This is the largest and most complex regular expression we’ve seen in the book.
    [Figure 17-4](ch17.xhtml#ch17fig4) should help you identify each of its parts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: Bar regular expression visualized*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our regular expressions, let’s start writing the code to parse
    our structure files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Right now, our *structures* package has the following subdirectories:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: structures
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '|- model'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '|- solution'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '|- tests'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new package folder named *parse* by right-clicking *structures*
    and choosing **New** ▸ **Python Package**. If you’re doing this from outside the
    IDE, don’t forget to create an empty *__init__.py* file in the folder. Our *structures*
    package directory should look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: structures
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '|- model'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '|- parse'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '|- solution'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '|- tests'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We’re ready to start implementing the code. We’ll first implement the logic
    for parsing nodes, loads, and bars. Each will be defined in its own function along
    with unit tests. Then, we’ll put it all together in a function that reads the
    entire file’s contents, splits it into lines, and parses each line into the right
    model class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Parsing Nodes**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with the nodes. In *structures/parse*, create a new file named *node_parse.py*.
    In this file, enter the code in [Listing 17-1](ch17.xhtml#ch17lis1).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 17-1: Parsing a node from a string*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the regular expression we saw earlier. It needs to be broken
    down into multiple lines because it’s too long for a single line, but since we’re
    using the continuation backslash character (\), Python will read all the contents
    into a single line.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the parse_node function, which accepts a string parameter as input.
    This string should be formatted following the node’s format we defined earlier.
    We look for a match in the node_str string against the node’s regular expression
    ➊. If there’s no match, we raise a ValueError with a message that includes the
    offending string so that it’s easier to debug errors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Then we extract the ID from the capture group named id and store it in the _id
    variable ➋.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we parse the x and y position coordinates: we read the contents of the
    pos capture group and split the string using the comma character.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This yields the two strings representing the numbers defining the node’s position.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a list comprehension, we map each of the strings to a float number:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we destructure the result into variables x and y ➌.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The last named capture group is ec. It contains the definition of the external
    constraints. We read its contents and store them in the variable ext_const ➍.
    Lastly, we create the node instance passing it all the parameters it expects ➎.
    We pass the ID, the position point, a None for the loads (this will be added later),
    and the external constraints. The external constraints are added by checking whether
    the character “x” or “y” is in the constraints string. For this, we use Python’s
    in operator, which checks whether a given value exists in a sequence. Here’s an
    example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命名捕获组是 ec。它包含了外部约束的定义。我们读取其内容并将其存储在变量 ext_const ➍ 中。最后，我们创建节点实例，传递它所需的所有参数
    ➎。我们传递 ID、位置点、None 作为负载（稍后会添加），以及外部约束。外部约束是通过检查约束字符串中是否包含字符 “x” 或 “y” 来添加的。为此，我们使用
    Python 的 in 运算符，它检查给定的值是否存在于一个序列中。这里有一个示例：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s use some unit tests to make sure our code parses nodes correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些单元测试来确保我们的代码能够正确解析节点。
- en: '***Testing the Node Parser***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试节点解析器***'
- en: Let’s create a new test file in the *structures/tests* directory named *node_parse
    _test.py*. In the file, enter the code in [Listing 17-2](ch17.xhtml#ch17lis2).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *structures/tests* 目录下创建一个新的测试文件，命名为 *node_parse_test.py*。在该文件中，输入 [清单
    17-2](ch17.xhtml#ch17lis2) 中的代码。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 17-2: Testing the parsing of a node*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-2：测试节点解析*'
- en: 'This file defines a new test class: NodeParseTest. We’ve defined a string with
    the correct format so we can test whether we can parse all of its parts. That
    string is node_str ➊. We’ve written all of our tests to work with the node that
    results when we parse the string ➋; we did this to avoid repeating the same parsing
    operation in every test.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了一个新的测试类：NodeParseTest。我们已经定义了一个具有正确格式的字符串，以便我们可以测试是否能够解析其所有部分。这个字符串是
    node_str ➊。我们编写了所有测试，以便与解析该字符串 ➋ 后得到的节点一起使用；我们这样做是为了避免在每个测试中重复相同的解析操作。
- en: Then we have a test to ensure the ID is correctly set in the resulting node,
    another one that checks the node’s position, and two more to test whether the
    external constraints have been added or not.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个测试来确保结果节点中的 ID 被正确设置，另一个测试检查节点的位置，还有两个测试用来验证外部约束是否已被添加。
- en: 'Let’s run our tests to make sure they all pass. You can do so from the IDE
    or from the shell with the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试，确保它们都通过了。你可以通过 IDE 或在 shell 中使用以下命令来完成：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s now work on parsing the bars.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始解析条形图。
- en: '**Parsing Bars**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解析条形图**'
- en: In *structures/parse*, create a new file named *bar_parse.py*. In this file,
    enter the code in [Listing 17-3](ch17.xhtml#ch17lis3).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/parse* 目录下，创建一个名为 *bar_parse.py* 的新文件。在该文件中，输入 [清单 17-3](ch17.xhtml#ch17lis3)
    中的代码。
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 17-3: Parsing a bar from a string*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-3：从字符串解析一个条形图*'
- en: The regular expression to match the bar definition (__BAR_REGEX) is a bit long
    and complex. Make sure you enter it carefully. We’ll write some unit tests later,
    so any error here will come to light there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用于匹配条形图定义的正则表达式 (__BAR_REGEX) 有点长且复杂。确保小心输入它。我们稍后会编写一些单元测试，所以这里的任何错误将在测试中暴露出来。
- en: 'We’ve written the parse_bar function, which takes two parameters: the string
    defining the bar and a dictionary of nodes. In this dictionary, the keys are the
    IDs of the nodes, and the values are the nodes themselves. The bar needs to have
    a reference to its end nodes, so these have to be parsed first and then passed
    to the parse_bar function. This adds a constraint in the way we parse structure
    files: nodes should appear first.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了 parse_bar 函数，它接受两个参数：定义条形图的字符串和一个节点字典。在这个字典中，键是节点的 ID，值是节点本身。条形图需要引用其结束节点，因此必须先解析这些节点，然后传递给
    parse_bar 函数。这对我们解析结构文件的方式增加了一个约束：节点应该首先出现。
- en: As with the nodes, we start by matching the passed-in string against our regular
    expression ➊. If there is no match, we raise a ValueError with a helpful message
    including the string that couldn’t be parsed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与节点一样，我们首先将传入的字符串与我们的正则表达式 ➊ 进行匹配。如果没有匹配项，我们会引发一个 ValueError，并附上一个有帮助的消息，包含无法解析的字符串。
- en: 'Next, we retrieve and parse the capture groups: id parsed as an integer ➋,
    start_id ➌ and end_id ➍ parsed as integers, and sec ➎ and young ➏ parsed as floats.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检索并解析捕获组：id 解析为整数 ➋，start_id ➌ 和 end_id ➍ 解析为整数，sec ➎ 和 young ➏ 解析为浮动数值。
- en: 'Then we look for the start node in the nodes dictionary ➐ and raise an error
    if it’s not found: we can’t build a bar whose nodes don’t exist. We do the same
    thing for the end node, and then we create and return the bar instance in the
    last line ➑, passing it all the parsed values.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在节点字典中查找起始节点 ➐，如果未找到，则抛出错误：我们不能构建没有节点的条形。同样处理终止节点，然后在最后一行 ➑ 创建并返回条形实例，传入所有解析的值。
- en: Let’s test this code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个代码。
- en: '***Testing the Bar Parser***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试条形解析器***'
- en: To test the bar parsing process, create a new file in *structures/tests* named
    *bar_parse_test.py*. Enter the new tests in [Listing 17-4](ch17.xhtml#ch17lis4).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试条形的解析过程，在 *structures/tests* 中创建一个名为 *bar_parse_test.py* 的新文件。将新的测试代码输入到
    [列表 17-4](ch17.xhtml#ch17lis4)。
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 17-4: Testing the parsing of a bar*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-4：测试条形的解析*'
- en: In this test, we define a bar using its string representation ➊. The parse _bar
    function requires a dictionary containing the nodes by ID as its second argument;
    we create a dummy (recall the types from the 16 [page 447](ch16.xhtml#ch00lev1sec97))
    called nodes_dict ➋. This dictionary contains the two node IDs mapped to a string.
    Our parsing code doesn’t really do anything with the nodes or even check their
    types; it simply adds them to the bar instance. So for the tests, a string mocking
    the node is enough.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用条形的字符串表示法 ➊ 来定义一个条形。`parse_bar` 函数需要一个包含按 ID 分类的节点字典作为第二个参数；我们创建了一个虚拟字典（回想一下第
    16 页 [447](ch16.xhtml#ch00lev1sec97) 中的类型），称为 `nodes_dict` ➋。这个字典包含两个节点 ID，并将它们映射到一个字符串。我们的解析代码实际上并不会对节点做任何处理，甚至不会检查它们的类型；它只是简单地将它们添加到条形实例中。因此，在测试中，模拟节点的字符串就足够了。
- en: Again, we parse ➌ first and store the result in the bar variable. We then create
    five tests that check that we’ve correctly parsed the ID, both start and end nodes,
    the cross section, and Young’s modulus.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们首先解析 ➌ 并将结果存储在 `bar` 变量中。然后我们创建五个测试，检查是否正确解析了 ID、起始节点、终止节点、截面和杨氏模量。
- en: 'Run the tests to make sure they all pass. You can do so from the shell:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，确保它们都通过了。你可以从命令行进行测试：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lastly, we need to parse the loads.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要解析负载。
- en: '**Parsing Loads**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解析负载**'
- en: We’ll now write a function to parse the load strings, but we won’t apply the
    loads to the nodes here. That’ll happen later when we put all the pieces together.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在编写一个函数来解析负载字符串，但我们不会在这里将负载应用到节点上。这将在稍后将所有部分结合时进行。
- en: Create a new file in *structures/parse* named *load_parse.py*. Enter the code
    in [Listing 17-5](ch17.xhtml#ch17lis5).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/parse* 文件夹中创建一个名为 *load_parse.py* 的新文件。将代码输入到 [列表 17-5](ch17.xhtml#ch17lis5)。
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 17-5: Parsing a load from a string*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-5：从字符串中解析负载*'
- en: In this listing we define the regular expression that matches the loads as __LOAD_REGEX.
    Then comes the parse_load function, which first looks for a match in the passed-in
    string (load_str) ➊. We raise an error if the string doesn’t match __LOAD_REGEX.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们定义了匹配负载的正则表达式 `__LOAD_REGEX`。接着是 `parse_load` 函数，它首先在传入的字符串（`load_str`）中查找匹配项
    ➊。如果字符串不匹配 `__LOAD_REGEX`，我们会抛出一个错误。
- en: 'The regular expression defines two capturing groups: node_id and vec. The first
    group is the ID of the node where the load needs to be applied. We convert the
    value for this first group into an integer and store it in the node_id variable
    ➋.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式定义了两个捕获组：`node_id` 和 `vec`。第一个组是需要施加负载的节点的 ID。我们将第一个组的值转换为整数，并将其存储在 `node_id`
    变量中 ➋。
- en: To extract the force components, we split the value matched by the vec capture
    group and then parse each part, convert it to a float value, and use destructuring
    to extract the components into the fx and fy variables ➌.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取力的分量，我们拆分由 `vec` 捕获组匹配到的值，然后解析每个部分，将其转换为浮动值，并使用解构赋值将分量提取到 `fx` 和 `fy` 变量中
    ➌。
- en: Lastly, we return a tuple of the node ID and a vector with the force components
    ➍.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回一个元组，包含节点 ID 和一个带有力的分量的向量 ➍。
- en: Let’s test this logic to make sure it parses loads correctly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个逻辑，确保它能正确解析负载。
- en: '***Testing the Load Parser***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试负载解析器***'
- en: In the *structures/tests* folder, create a new file named *load_parse_test.py*.
    Enter the test code in [Listing 17-6](ch17.xhtml#ch17lis6).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/tests* 文件夹中创建一个名为 *load_parse_test.py* 的新文件。将测试代码输入到 [列表 17-6](ch17.xhtml#ch17lis6)。
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 17-6: Testing the parsing of a load*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-6：测试负载的解析*'
- en: This test defines a string representing a load applied to a node with an ID
    of 1 and whose components are ⟨250.0,–3500.0⟩. The string is stored in the load_str
    variable and passed to the parse_load function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试定义了一个表示施加到 ID 为 1 的节点上的负载的字符串，负载的分量是 ⟨250.0,–3500.0⟩。该字符串存储在 `load_str`
    变量中并传递给 `parse_load` 函数。
- en: In the first test, we check that we’ve correctly parsed the node ID, which is
    returned by the function as the tuple’s first value. Then, we check that we’ve
    correctly parsed the tuple’s second value, the vector. These two simple tests
    are enough to make sure our function does its job.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次测试中，我们检查是否正确解析了节点 ID，节点 ID 作为元组的第一个值由函数返回。然后，我们检查是否正确解析了元组的第二个值，即向量。这两个简单的测试足以确保我们的函数能够正常工作。
- en: 'Run the tests from the IDE or from the shell:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从 IDE 或命令行运行测试：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have functions that can parse the structure’s individual parts from
    their string representations, it’s time to put them together. In the next section,
    we’ll work on a function that reads all the lines of a structure definition file
    and generates the corresponding model.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了可以解析结构各个部分的函数，是时候将它们组合起来了。在接下来的章节中，我们将编写一个函数，读取结构定义文件的所有行，并生成相应的模型。
- en: '**Parsing the Structure**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解析结构**'
- en: 'Our structure files define each entity on its own line, and entities appear
    grouped by sections. If you recall, we defined three sections for the three different
    entities we need to parse: nodes, bars, and loads. Here’s the previous example
    of a structure file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结构文件将每个实体定义在单独的行上，实体按部分分组出现。如果你还记得，我们为需要解析的三个不同实体定义了三个部分：节点、杆件和荷载。以下是之前的结构文件示例：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because these files will mostly be written by hand, it would be nice if we
    allowed the inclusion of comments: lines that are ignored by the parsing mechanism
    but explain something to someone reading the file, just like comments in code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些文件大多数是手动编写的，因此如果我们允许包含注释那就太好了：注释行会被解析机制忽略，但能向文件的阅读者解释一些内容，就像代码中的注释一样。
- en: 'Here’s an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ll borrow Python’s syntax and use the # symbol to mark the start of a comment.
    Comments will have to appear on their own lines.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将借用 Python 的语法，使用 # 符号标记注释的开始。注释必须单独占一行。'
- en: '***Overview***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***概览***'
- en: Because we’ll need to write a few functions, it may be helpful to have a diagram
    of the structure parsing process with the function names annotated after the steps.
    Take a look at [Figure 17-5](ch17.xhtml#ch17fig5).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要编写一些函数，可能有一个带注解的结构解析过程图会更有帮助，可以标注出各个步骤对应的函数名。请看一下[图17-5](ch17.xhtml#ch17fig5)。
- en: '![Image](../images/17fig05.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig05.jpg)'
- en: '*Figure 17-5: Structure parsing process*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-5：结构解析过程*'
- en: In this diagram, we show each step of the parsing process. We start with a structure
    file defining the structure in plaintext following our standard format.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，我们展示了解析过程的每个步骤。我们从一个结构文件开始，定义了以纯文本形式表示的结构，遵循我们的标准格式。
- en: The first step is to read the file contents into a string. We’ll implement this
    part in our application in [Chapter 19](ch19.xhtml#ch19).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将文件内容读取到一个字符串中。我们将在[第19章](ch19.xhtml#ch19)的应用中实现这一部分。
- en: The second step consists of splitting the big string into multiple lines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将大的字符串拆分成多行。
- en: The third step is parsing those lines into a dictionary of the structural primitives.
    This step is handled by the private __parse_lines function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是将这些行解析成结构原始数据的字典。这一步由私有的__parse_lines函数处理。
- en: The fourth and final step is aggregating those parsed structural items into
    a structure instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步也是最后一步是将那些解析后的结构项聚合到一个结构实例中。
- en: 'The parse_structure_from_lines function is a combination of steps 3 and 4:
    it transforms a list of definition lines into a complete structure. The parse
    _structure function goes one step further and splits a single string into multiple
    lines.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: parse_structure_from_lines 函数是第 3 步和第 4 步的结合：它将一个定义行的列表转化为一个完整的结构。parse_structure
    函数更进一步，将单一的字符串拆分成多行。
- en: '***Setup***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置***'
- en: 'In the *structures/parse* directory, create a new file named *str_parse.py*.
    The *structures* package should now look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/parse* 目录中，创建一个名为 *str_parse.py* 的新文件。此时 *structures* 包应该是这样的：
- en: structures
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: structures
- en: '|- model'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|- model'
- en: '|    | ...'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '|    | ...'
- en: '|- parse'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|- parse'
- en: '|    |- __init__.py'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- bar_parse.py'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- bar_parse.py'
- en: '|    |- load_parse.py'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- load_parse.py'
- en: '|    |- node_parse.py'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- node_parse.py'
- en: '|    |- str_parse.py'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- str_parse.py'
- en: '|- solution'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '|- solution'
- en: '|    | ...'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|    | ...'
- en: '|- tests'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '|- tests'
- en: '|    | ...'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|    | ...'
- en: Let’s start the implementation with a function that determines whether a line
    in the file is blank or a comment. This function will let us know whether a given
    line can be ignored or whether it has to be parsed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个函数开始，该函数判断文件中的一行是否为空白或是注释。这个函数将告诉我们给定的行是否可以忽略，或者是否需要解析。
- en: '***Ignoring Blank Lines and Comments***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***忽略空行和注释***'
- en: In *str_parse.py*, enter the code in [Listing 17-7](ch17.xhtml#ch17lis7).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在*str_parse.py*中，输入[Listing 17-7](ch17.xhtml#ch17lis7)中的代码。
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 17-7: Function to determine the lines that need to be ignored*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-7：确定需要忽略的行的函数*'
- en: 'We define a constant, __COMMENT_INDICATOR, with the # character for its value.
    If we ever want to change the way comments are identified, we’ll simply need to
    edit this line.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个常量`__COMMENT_INDICATOR`，它的值是`#`字符。如果我们想要更改注释的识别方式，只需编辑这一行。
- en: Next is the __should_ignore_line function. This function receives a string and
    removes any surrounding blank spaces (in other words, it strips the string). Then,
    if the line has a length of zero or starts with the comment indicator, the function
    returns a True value, and a False otherwise.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`__should_ignore_line`函数。该函数接收一个字符串并去除两端的空白字符（换句话说，它会去除字符串的空白）。然后，如果该行的长度为零或以注释标识符开头，函数将返回True值，否则返回False。
- en: '***Parsing the Lines***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解析行***'
- en: Now that we have a way to filter out the lines that don’t need to be parsed,
    let’s look at the ones that do. We’re going to define a function that receives
    a list of strings representing the lines and identifies whether the line is a
    section header (“nodes,” “bars,” or “loads”) or an entity. In the case of a section
    header, the function will set a flag to keep track of the current section being
    read. The rest of the function will take care of parsing each line using the corresponding
    parser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一种方法来过滤掉不需要解析的行，接下来看看需要解析的行。我们将定义一个接收字符串列表的函数，这些字符串代表行，并识别该行是部分头（“nodes”、“bars”或“loads”）还是实体。如果是部分头，函数将设置一个标志来跟踪当前正在读取的部分。函数的其余部分将负责使用相应的解析器解析每一行。
- en: In the file *str_parse.py*, enter the code in [Listing 17-8](ch17.xhtml#ch17lis8).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件*str_parse.py*中，输入[Listing 17-8](ch17.xhtml#ch17lis8)中的代码。
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 17-8: Parsing the lines*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-8：解析行*'
- en: 'We first add three variables with the names of the file headers: __NODES _HEADER,
    __LOADS_HEADER, and __BARS_HEADER. These constants define the names of the sections.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加了三个变量，分别是文件头的名称：`__NODES_HEADER`、`__LOADS_HEADER`和`__BARS_HEADER`。这些常量定义了各个部分的名称。
- en: 'Then comes the __parse_lines function definition, which takes one parameter:
    the list of lines in the structure file. The function declares a variable named
    reading ➊. This variable indicates what structure section the later loop is currently
    in. For example, when its value is ’bars’, the subsequent lines should be parsed
    using the parse_bar function until the end of the file or a new section is encountered.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`__parse_lines`函数的定义，它接收一个参数：结构文件中的行列表。该函数声明了一个名为`reading ➊`的变量。此变量指示后续循环当前处于哪个结构部分。例如，当它的值为“bars”时，随后的行应该使用`parse_bar`函数进行解析，直到文件结束或遇到新的部分。
- en: 'Next comes the definition of the result dictionary ➋. It’s initialized with
    three keys: ’nodes’, ’loads’, and ’bars’. We’ll add the parsed elements to this
    dictionary, in their corresponding key’s collection. Loads and bars are stored
    in a list and nodes in a dictionary, with the keys being their IDs. We store nodes
    mapped to their keys in a dictionary because both loads and bars refer to them
    by ID in the structure file; thus, when we link them, it’ll be more convenient
    to look them up by ID.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是结果字典`➋`的定义。它通过三个键来初始化：'nodes'、'loads'和'bars'。我们将解析后的元素添加到此字典中，按照它们对应的键的集合进行存储。`loads`和`bars`存储在列表中，`nodes`则存储在字典中，键是它们的ID。我们将节点映射到它们的键存储在字典中，因为在结构文件中，`loads`和`bars`都通过ID来引用节点；因此，当我们将它们关联时，通过ID查找会更方便。
- en: Next is the loop that iterates over the lines’ enumeration. Recall that Python’s
    enumerate function returns an iterable sequence that includes the original objects
    along with their index. We’ll use the index only if we encounter an error, using
    the line number in the error message to make looking for the error in the input
    file easier. The first thing we do with each line is check whether it’s blank
    or a comment ➌, in which case we skip it using the continue statement.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个循环，遍历行的枚举。回想一下，Python的`enumerate`函数返回一个可迭代序列，其中包含原始对象以及它们的索引。我们只会在遇到错误时使用该索引，借助行号在错误信息中可以更容易地找到输入文件中的错误。我们对每一行的处理第一步是检查它是否为空行或是注释行
    ➌，如果是这种情况，我们会使用`continue`语句跳过该行。
- en: 'Next, we have a couple of if-else statements. The first block of them is for
    matching header lines ➍. When a line is found to match one of the three possible
    headers, we set the reading variable to the header’s value. The later if-else
    statements evaluate reading to determine which structural element to parse ➎.
    If reading has the value ’nodes’, we use the parse_node function to parse the
    line and store the result in the result dictionary, under the ’nodes’ key:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些 if-else 语句。它们的第一个块用于匹配头部行 ➍。当找到一个与三种可能的头部之一匹配的行时，我们将 `reading` 变量设置为该头部的值。后面的
    if-else 语句评估 `reading`，以确定要解析的结构元素 ➎。如果 `reading` 的值为 'nodes'，我们使用 `parse_node`
    函数解析该行，并将结果存储在结果字典的 'nodes' 键下：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The same goes for bars and loads, but remember that in their case, they’re
    stored in a list:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 bars 和 loads 也一样，但请记住，在它们的情况下，它们被存储在一个列表中：
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function then returns the result dictionary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后返回结果字典。
- en: We’ve implemented a function that reads a sequence of text lines and converts
    each of them into a structure class instance (what we know as parsing). These
    instances represent the nodes, bars, and loads of the structure. The function
    returns a dictionary that bundles these instances by type. The next step is using
    these parsed objects to construct a Structure instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个函数，读取一系列文本行，并将每一行转换为结构类实例（我们称之为解析）。这些实例代表结构中的节点、bars 和 loads。该函数返回一个将这些实例按类型分类的字典。接下来的步骤是使用这些解析后的对象来构造一个
    `Structure` 实例。
- en: '***Splitting the Lines and Instantiating the Structure***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拆分行并实例化结构***'
- en: Given the contents of a structure file as a string, we want to split this string
    into its lines. We’ll pass those lines to the __parse_lines function we wrote
    earlier, and using the parsed objects we can construct an instance of our Structure
    class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 给定结构文件的内容作为字符串，我们希望将这个字符串拆分成行。我们将这些行传递给之前编写的 `__parse_lines` 函数，通过解析后的对象，我们可以构造一个
    `Structure` 类的实例。
- en: In the *str_parse.py* file, before the __parse_lines function, enter the code
    in [Listing 17-9](ch17.xhtml#ch17lis9).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *str_parse.py* 文件中，在 __parse_lines 函数之前，输入 [示例 17-9](ch17.xhtml#ch17lis9)
    中的代码。
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 17-9: Splitting the lines*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 17-9：拆分行*'
- en: We’ve written three new functions. The first of them, parse_structure, splits
    the passed-in string into its lines ➊ and forwards those lines to the parse_structure_from_lines
    function defined afterward.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了三个新函数。第一个函数 `parse_structure` 将传入的字符串拆分成行 ➊，并将这些行传递给随后定义的 `parse_structure_from_lines`
    函数。
- en: 'This second function, parse_structure_from_lines, passes the lines to __parse_lines
    and saves the result in a variable called parsed ➋. It then extracts the contents
    of this result dictionary to the variables: nodes_dict, loads, and bars.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数 `parse_structure_from_lines` 将这些行传递给 __parse_lines，并将结果保存在一个名为 parsed
    ➋ 的变量中。然后，它将结果字典中的内容提取到以下变量中：nodes_dict、loads 和 bars。
- en: 'The loads are defined separately from the nodes they’re applied to; thus, we
    need to add each load to its respective node ➌. To do this, we’ve written another
    small function: __apply_loads_to_nodes. Recall that the loads were defined using
    the format'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 负载与它们应用的节点是分开定义的；因此，我们需要将每个负载添加到其相应的节点 ➌。为此，我们编写了另一个小函数：__apply_loads_to_nodes。回想一下，负载是使用以下格式定义的：
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and are parsed by our parse_load function as a tuple consisting of the node
    ID and the load components as a vector:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并且由我们的 `parse_load` 函数解析，作为一个由节点 ID 和负载组件（作为向量）组成的元组：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It’s important to keep this in mind to understand the loop in __apply _loads_to_nodes
    ➎. The loop iterates over the load tuples, and on each iteration, it stores the
    node ID and load vector into the node_id and load variables, respectively. Because
    our nodes are stored in a dictionary whose keys are the node IDs, applying the
    loads is a piece of cake.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点对于理解 __apply_loads_to_nodes ➎ 中的循环非常重要。该循环遍历负载元组，在每次迭代中，它分别将节点 ID 和负载向量存储到
    `node_id` 和 `load` 变量中。因为我们的节点存储在一个字典中，其键是节点 ID，所以应用负载非常简单。
- en: Once the loads have been applied to the nodes (back in parse_structure _from_lines),
    the last step is to return an instance of the Structure class. The class’s constructor
    expects a list of nodes and a list of bars. The bars are already parsed as a list,
    but the nodes were in a dictionary. To turn the values of a dictionary into a
    list, we simply need to use Python’s list function on the dictionary values, which
    we extract using the values() method ➍.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载操作应用到节点（在parse_structure_from_lines中），最后一步是返回一个Structure类的实例。该类的构造函数需要一个节点列表和一个条形码列表。条形码已经作为列表解析，但节点是以字典的形式存在。为了将字典的值转换为列表，我们只需要使用Python的list函数处理字典的值，这些值通过values()方法提取
    ➍。
- en: With this, our parsing logic is ready!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的解析逻辑已经准备好了！
- en: '***The Result***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: For your reference, [Listing 17-10](ch17.xhtml#ch17lis10) shows the complete
    code for *str_parse.py*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考，[列表 17-10](ch17.xhtml#ch17lis10)展示了*str_parse.py*的完整代码。
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 17-10: Parsing the structure*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-10：解析结构*'
- en: 'Before we move to the next section, open the *__init__.py* file in *parse*,
    and enter the following import:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一部分之前，打开*__init__.py*文件，位于*parse*目录中，并输入以下导入语句：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This allows us to import the parse_structure function like this,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们像这样导入parse_structure函数，
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'instead of this slightly longer version:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这个稍微长一点的版本：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s make sure our parsing function is working correctly by implementing some
    automated tests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一些自动化测试来确保我们的解析函数正常工作。
- en: '***Testing the Structure Parser***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试结构解析器***'
- en: 'To make sure the parse_structure function works as expected, we’ll now add
    a few unit tests. First, we want to create a structure definition file to use
    in the test. In the *structures/tests* directory, create a new file, *test_str.txt*,
    with the following contents:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保parse_structure函数按预期工作，我们现在将添加一些单元测试。首先，我们需要创建一个结构定义文件用于测试。在*structures/tests*目录中，创建一个新文件，命名为*test_str.txt*，其内容如下：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ve added comment lines and some extra blank lines; our function should ignore
    those. Create a new test file: *str_parse_test.py* ([Listing 17-11](ch17.xhtml#ch17lis11)).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了注释行和一些额外的空行；我们的函数应该忽略这些。创建一个新的测试文件：*str_parse_test.py*（[列表 17-11](ch17.xhtml#ch17lis11)）。
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 17-11: Setting up the structure parsing test*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-11：设置结构解析测试*'
- en: 'The file defines a new test class: StructureParseTest. In the setUp method,
    we load the *test_str.txt* file as bytes using the resource_string function. Then,
    we decode those bytes into a UTF-8 encoded Python string. Lastly, using parse_structure,
    we parse the structure string and store the result in a class attribute: self.structure.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件定义了一个新的测试类：StructureParseTest。在setUp方法中，我们使用resource_string函数将*test_str.txt*文件加载为字节。然后，我们将这些字节解码为UTF-8编码的Python字符串。最后，使用parse_structure解析结构字符串，并将结果存储在类的一个属性中：self.structure。
- en: '**Testing the Node Parser**'
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试节点解析器**'
- en: Let’s add some test cases to ensure the structure that we parsed from the *test_str.txt*
    file contains the expected nodes. After the setUp method, enter the first tests
    ([Listing 17-12](ch17.xhtml#ch17lis12)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些测试用例，确保从*test_str.txt*文件解析的结构包含预期的节点。在setUp方法之后，输入第一个测试（[列表 17-12](ch17.xhtml#ch17lis12)）。
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 17-12: Testing the structure parsing: the nodes*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-12：测试结构解析：节点*'
- en: We’ve written three tests. The first one checks that there are three nodes in
    the structure. The next test ensures that those three nodes have the correct position.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写了三个测试。第一个测试检查结构中是否有三个节点。下一个测试确保这三个节点的位置正确。
- en: There’s one interesting thing to note here. Since the __nodes list is private
    to the Structure class, Python uses a trick to try to hide it from us. Python
    prepends an underscore and the name of the class to the name of its private attributes.
    The __nodes attribute will therefore be called _Structure__nodes, and not __nodes
    as we’d expect. This is why, to access it from our tests, we use this name ➊.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点值得注意。由于__nodes列表是Structure类的私有属性，Python通过一个技巧来试图隐藏它。Python会在私有属性的名称前加上一个下划线和类名。因此，__nodes属性将被称为_Structure__nodes，而不是我们预期的__nodes。这就是为什么在我们的测试中，要通过这个名称来访问它
    ➊。
- en: 'The third and last test checks if the external constraints in the nodes have
    the right values as defined in the structure definition file. Let’s run the tests.
    You can click the green play button in the IDE or use the shell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个测试检查节点中的外部约束是否具有结构定义文件中定义的正确值。让我们运行测试。您可以在IDE中点击绿色播放按钮，或者使用终端：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A success message should be displayed in the shell.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在终端中显示一条成功消息。
- en: '**Testing the Bar Parser**'
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试条形码解析器**'
- en: Let’s now test if the bars are also parsed correctly. After the test cases we
    just wrote, enter the ones in [Listing 17-13](ch17.xhtml#ch17lis13).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试杆件是否也被正确解析。在我们刚刚编写的测试用例之后，输入[列表 17-13](ch17.xhtml#ch17lis13)中的测试用例。
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 17-13: Testing the structure parsing: the bars*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-13：测试结构解析：杆件*'
- en: 'The first test asserts that there are three bars in the structure. The second
    test checks that every bar in the structure is linked to the correct node IDs.
    Same as before, to access the private list of bars, we need to prepend _Structure
    to the attribute name: _Structure__bars.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试断言结构中有三根杆件。第二个测试检查结构中的每根杆件是否与正确的节点 ID 关联。和以前一样，要访问私有的杆件列表，我们需要在属性名之前加上
    _Structure：_Structure__bars。
- en: I invite you to add two more tests that check that the values for the cross
    section and Young’s modulus are correctly parsed into the bars. We won’t include
    them here for brevity reasons.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我邀请你添加两个额外的测试，检查横截面和杨氏模量的值是否正确地解析到杆件中。由于篇幅原因，我们在此不包括这些测试。
- en: 'Run the test class again to make sure our new tests also pass. From the shell,
    run this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试类，以确保我们的新测试也通过。在终端中运行以下命令：
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Testing the Load Parser**'
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试荷载解析器**'
- en: Let’s add the two last tests to ensure the loads are properly parsed. Enter
    the code in [Listing 17-14](ch17.xhtml#ch17lis14).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加最后两个测试，确保荷载被正确解析。输入[列表 17-14](ch17.xhtml#ch17lis14)中的代码。
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 17-14: Testing the structure parsing: the loads*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-14：测试结构解析：荷载*'
- en: In these two last tests, we check that the number of loads in the structure
    is 1 and that it’s being correctly applied to the second node.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个最后的测试中，我们检查结构中的荷载数量是否为 1，并且它是否正确地应用到第二个节点。
- en: 'Let’s run all the tests to make sure all pass:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行所有测试，确保所有测试都通过：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If your code is well implemented, all the tests should pass, and you should
    see the following in the shell:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码实现良好，所有测试应该都通过，并且你应该在终端看到以下内容：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Test Class Result**'
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试类结果**'
- en: We’ve done a few tests, so [Listing 17-15](ch17.xhtml#ch17lis15) shows the resulting
    test class for your reference.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了一些测试，因此[列表 17-15](ch17.xhtml#ch17lis15)展示了结果测试类，供您参考。
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 17-15: Testing the structure parsing*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-15：测试结构解析*'
- en: Our structure parsing logic is ready and tested!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结构解析逻辑已经准备好并通过测试！
- en: '**Summary**'
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we first defined a format for our structure files. It’s a simple
    plaintext format that can be written by hand.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先定义了结构文件的格式。这是一个简单的纯文本格式，可以手动编写。
- en: 'We then implemented functions to parse each of the lines in our structure files
    into its appropriate structural element: nodes, loads, and bars. Regular expressions
    were the stars of the show; with them, parsing well-structured text was a breeze.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了函数，将结构文件中的每一行解析为相应的结构元素：节点、荷载和杆件。正则表达式是本次工作的明星；有了它们，解析结构化文本变得轻而易举。
- en: Lastly, we put everything together into a function that splits a big string
    into its lines and decides which parser to use for each line. We’ll use this function
    to read structure files and create the structural model that our truss resolution
    application will work with.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有内容合并到一个函数中，该函数将大字符串分割成各行，并决定每一行使用哪个解析器。我们将使用这个函数来读取结构文件，并创建我们的桁架解法应用程序将使用的结构模型。
- en: It’s now time to work on producing the output diagrams for the structure solution.
    That’s exactly what we’ll do in the next chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始生成结构解法的输出图表了。这正是我们将在下一章中做的事情。
