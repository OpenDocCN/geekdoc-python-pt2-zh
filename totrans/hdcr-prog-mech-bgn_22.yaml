- en: '17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: READING INPUT FROM A FILE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Any engineering application we develop will require some data input. For example,
    to solve a truss structure using the algorithm we developed in the previous chapter,
    we first need to construct the structure model. It’d be tedious to manually instantiate
    the classes to construct the model every time we want to solve a structure; it’d
    be more convenient to simply pass our app a plaintext file that follows a given
    and well-defined scheme defining the structure we want to solve. In this chapter,
    we’ll equip our app with a file parser function that reads text files, interprets
    them, and constructs the model that the app uses internally.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Input Format**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our application to work, the files we feed it need to have a well-defined
    structure. The text file has to include the definition of the nodes, the loads
    applied to them, and the bars of the structure. Let’s decide on a format for each
    of these parts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '***The Nodes Format***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each node will be defined in its own line, following this format,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '*node_id* is the ID given to the node.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x_coord* is the x position of the node.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*y_coord* is the y position of the node.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*external_constraints* is a set of the constrained movements.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This defines a node with an ID of 1, at position (250, 400), with its x and
    y displacements externally constrained.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '***The Loads Format***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Loads will be defined separately from the nodes they’re applied to, so we’ll
    have to indicate the ID of the node where the load is applied. Having the nodes
    and loads defined in different lines allows us to simplify the input parsing process
    by using two simple regular expressions (one for the nodes and another for the
    loads) instead of one long and complicated regular expression. Each load will
    be defined on a separate line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the following format for loads,
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: where
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*node_id* is the node where the load is applied.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fx* is the x component of the load.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fy* is the y component of the load.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This defines a load ⟨500,–1000⟩ applied to the node with an ID of 3\. We’re
    using the -> character sequence to separate the node ID from the load components
    instead of a colon so that it’s clear we’re not assigning an ID to the load itself.
    Rather, we’re applying the load to the node with that ID.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '***The Bars Format***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bars are defined between two nodes and have a section and Young’s modulus. As
    with nodes and loads, each bar will be defined on its own line. We can give bars
    the following format,
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: where
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '*bar_id* is the ID given to the bar.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*start_node_id* is the ID of the start node.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*end_node_id* is the ID of the end node.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A* is the cross-section area.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E* is the Young’s modulus.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a bar between nodes 1 and 2, with a cross section of 30 and a Young’s
    modulus of 20000000. This bar is given an ID of 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '***The File Format***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve come up with a format for the nodes, loads, and bars, let’s see
    how we can put them all together in one file. We’re looking for a file structure
    that’s simple to write by hand but that’s also easy to parse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting idea is to divide the file into sections, each opened by a
    header:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each section should contain only the lines defining entities of the same type.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that our structure definition files will have three different kinds of
    entities—nodes, loads, and bars—they’ll need three different sections. For example,
    the structure we used for the unit tests in the previous chapter, included here
    as [Figure 17-1](ch17.xhtml#ch17fig1), would be defined as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Structure from previous chapter’s unit tests*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we’ve defined a format for our structure definition files, we need
    to work on a parser. A *parser* is a component (a function or class) that reads
    text, interprets it, and translates it into a data structure or model. In this
    case, the model is our truss structure class: Structure. We’ll use regular expressions,
    as we did in [Chapter 9](ch09.xhtml#ch09).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Regular Expressions**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we know the structure ahead of time, regular expressions are a reliable
    way of extracting all the information we need from plaintext. We’ll need three
    different regular expressions: one for the nodes, one for the loads, and one for
    the bars. If you need a refresher on regular expressions, take a moment to review
    “Regular Expressions” on [page 9](ch01.xhtml#page_9). Let’s design these regular
    expressions.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '***The Nodes Regex***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To match nodes defined in our format, we can use the following regular expression:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: /(?P<id>\d+)\s*:\s*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: \((?P<pos>[\d\s\.,\-]+)\)\s*
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: \((?P<ec>[xy]{0,2})\)/
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This is one scary regular expression. It’s split between several lines because
    it was too long to fit in a single line, but you can imagine it as being just
    one line. Let’s break down this regular expression into its parts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: (?P<id>\d+) This matches the node’s ID, a number with one or more digits (\d+),
    and captures it in a group named id.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: \s*:\s* This matches the colon after the ID with arbitrary and optional spaces
    around it (\s*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: \((?P<pos>[\d\s\.,\-]+)\) This matches the node’s position coordinates inside
    the parentheses and captures them in a group named pos. Note that we match the
    whole expression between the parentheses; that includes the two coordinates and
    the comma that separates them. We’ll split the two numbers in code. We do it this
    way so that our already monstrous regular expression doesn’t become even scarier.
    Combining regular expressions with Python’s string manipulation methods is a powerful
    technique.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: \s* This matches zero or more spaces separating the coordinates group from the
    external constraints group.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: \((?P<ec>[xy]{0, 2})\) This last part matches the external constraints defined
    between parentheses and captures them in a group named ec. The contents inside
    the parentheses are limited to the character group [xy], that is, the characters
    “x” and “y.” There’s also a constraint in the number of characters allowed, which
    is any number between 0 and 2 ({0, 2}).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<ec>[xy]{0, 2})\) 这一部分匹配括号内定义的外部约束，并将其捕获到名为ec的组中。括号内的内容限于字符集[xy]，即字符“x”和“y”。字符数也有限制，允许的字符数为0到2之间（{0,
    2}）。
- en: We’ll see this regular expression in action soon. [Figure 17-2](ch17.xhtml#ch17fig2)
    may help you understand each of the subparts in the regular expression.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会看到这个正则表达式的实际应用。[图17-2](ch17.xhtml#ch17fig2)可能会帮助你理解正则表达式中每个子部分的含义。
- en: '![Image](../images/17fig02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/17fig02.jpg)'
- en: '*Figure 17-2: Node regular expression visualized*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-2：节点正则表达式的可视化*'
- en: Let’s take a look at how to parse the loads.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何解析负载。
- en: '***The Loads Regex***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***负载正则表达式***'
- en: 'To match loads written with the format we defined, we’ll use the following
    regular expression:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配使用我们定义的格式编写的负载，我们将使用以下正则表达式：
- en: /(?P<node_id>\d+)\s*->\s*\((?P<vec>[\d\s\.,\-]+)\)/
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<node_id>\d+)\s*->\s*\((?P<vec>[\d\s\.,\-]+)\)/
- en: This regular expression isn’t quite as scary as the previous one; let’s break
    it down into its subparts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式并不像前一个那样可怕；让我们将其分解为多个子部分。
- en: (?P<node_id>\d+) This matches the node ID and captures it in a group named node_id.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<node_id>\d+) 这个表达式匹配节点ID，并将其捕获到名为node_id的组中。
- en: \s*->\s* This matches the -> character sequence and the optional blank spaces
    around it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: \s*->\s* 这个表达式匹配`->`字符序列及其周围的可选空格。
- en: \((?P<vec>[\d\s\.,\-]+)\) This matches the entire expression between the parentheses,
    where the force vector components are defined. The character set [\d\s\.,\-] inside
    the parentheses is allowed; this includes digits, spaces, dots, commas, and minus
    signs. Whatever is captured is stored in a capture group named vec.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<vec>[\d\s\.,\-]+)\) 这个表达式匹配括号内的整个内容，其中定义了力向量分量。括号内允许的字符集是[\d\s\.,\-]，包括数字、空格、点、逗号和减号。捕获的内容会存储在名为vec的捕获组中。
- en: '[Figure 17-3](ch17.xhtml#ch17fig3) is a breakdown of the regular expression’s
    different parts. Make sure you understand each of them.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-3](ch17.xhtml#ch17fig3)是正则表达式不同部分的分解。确保你理解它们的每一部分。'
- en: '![Image](../images/17fig03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/17fig03.jpg)'
- en: '*Figure 17-3: Load regular expression visualized*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-3：负载正则表达式的可视化*'
- en: Lastly, let’s take a look at the regular expression for the bars.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看条形的正则表达式。
- en: '***The Bars Regex***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条形正则表达式***'
- en: 'To match bars written using the format we defined earlier, we’ll use the following
    regular expression:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配使用我们之前定义的格式编写的条形，我们将使用以下正则表达式：
- en: /(?P<id>\d+)\s*:\s*
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<id>\d+)\s*:\s*
- en: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\)\s*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\)\s*
- en: (?P<sec>[\d\.]+)\s+
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<sec>[\d\.]+)\s+
- en: (?P<young>[\d\.]+)/
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<young>[\d\.]+)/
- en: 'This regular expression was also broken down into several lines because of
    its length, but you can imagine it as being written in one line. Let’s break it
    down piece by piece:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式因为其长度也被拆分成了几行，但你可以想象它是写在一行中的。让我们逐步分析它：
- en: (?P<id>\d+) This matches the ID assigned to the bar and captures it in the group
    named id.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<id>\d+) 这个表达式匹配分配给条形的ID，并将其捕获到名为id的组中。
- en: \s*:\s* This matches the colon character and the optional blank space around
    it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: \s*:\s* 这个表达式匹配冒号字符及其周围的可选空白字符。
- en: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\) This matches the two node IDs separated
    by the -> character sequence and the optional space around it. The IDs are captured
    in the groups named start_id and end_id. This whole expression is required to
    appear between parentheses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: \((?P<start_id>\d+)\s*->\s*(?P<end_id>\d+)\) 这个表达式匹配由`->`字符序列分隔并且周围有可选空格的两个节点ID。ID会被捕获到名为start_id和end_id的组中。整个表达式需要出现在括号内。
- en: \s* This matches the optional blank space between the last parenthesis and the
    next value, the section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: \s* 这个表达式匹配最后一个括号与下一个值（即节）之间的可选空白字符。
- en: (?P<sec>[\d\.]+) This captures a decimal number and assigns it to the group
    named sec.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<sec>[\d\.]+) 这个表达式捕获一个十进制数，并将其赋值给名为sec的组。
- en: \s+ This matches the required blank space between the last parenthesis and the
    next value, the Young modulus. Recall that, in this case we need at least one
    space. Otherwise, there would be no way to know where the value for the section
    ends and the value for the Young modulus begins.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: (?P<young>[\d\.]+) This captures a decimal number and assigns it to the group
    named young.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This is the largest and most complex regular expression we’ve seen in the book.
    [Figure 17-4](ch17.xhtml#ch17fig4) should help you identify each of its parts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: Bar regular expression visualized*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our regular expressions, let’s start writing the code to parse
    our structure files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Right now, our *structures* package has the following subdirectories:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: structures
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '|- model'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '|- solution'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '|- tests'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new package folder named *parse* by right-clicking *structures*
    and choosing **New** ▸ **Python Package**. If you’re doing this from outside the
    IDE, don’t forget to create an empty *__init__.py* file in the folder. Our *structures*
    package directory should look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: structures
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '|- model'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '|- parse'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '|- solution'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '|- tests'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We’re ready to start implementing the code. We’ll first implement the logic
    for parsing nodes, loads, and bars. Each will be defined in its own function along
    with unit tests. Then, we’ll put it all together in a function that reads the
    entire file’s contents, splits it into lines, and parses each line into the right
    model class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Parsing Nodes**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with the nodes. In *structures/parse*, create a new file named *node_parse.py*.
    In this file, enter the code in [Listing 17-1](ch17.xhtml#ch17lis1).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 17-1: Parsing a node from a string*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the regular expression we saw earlier. It needs to be broken
    down into multiple lines because it’s too long for a single line, but since we’re
    using the continuation backslash character (\), Python will read all the contents
    into a single line.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the parse_node function, which accepts a string parameter as input.
    This string should be formatted following the node’s format we defined earlier.
    We look for a match in the node_str string against the node’s regular expression
    ➊. If there’s no match, we raise a ValueError with a message that includes the
    offending string so that it’s easier to debug errors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Then we extract the ID from the capture group named id and store it in the _id
    variable ➋.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we parse the x and y position coordinates: we read the contents of the
    pos capture group and split the string using the comma character.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This yields the two strings representing the numbers defining the node’s position.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a list comprehension, we map each of the strings to a float number:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we destructure the result into variables x and y ➌.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The last named capture group is ec. It contains the definition of the external
    constraints. We read its contents and store them in the variable ext_const ➍.
    Lastly, we create the node instance passing it all the parameters it expects ➎.
    We pass the ID, the position point, a None for the loads (this will be added later),
    and the external constraints. The external constraints are added by checking whether
    the character “x” or “y” is in the constraints string. For this, we use Python’s
    in operator, which checks whether a given value exists in a sequence. Here’s an
    example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命名捕获组是 ec。它包含了外部约束的定义。我们读取其内容并将其存储在变量 ext_const ➍ 中。最后，我们创建节点实例，传递它所需的所有参数
    ➎。我们传递 ID、位置点、None 作为负载（稍后会添加），以及外部约束。外部约束是通过检查约束字符串中是否包含字符 “x” 或 “y” 来添加的。为此，我们使用
    Python 的 in 运算符，它检查给定的值是否存在于一个序列中。这里有一个示例：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s use some unit tests to make sure our code parses nodes correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些单元测试来确保我们的代码能够正确解析节点。
- en: '***Testing the Node Parser***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试节点解析器***'
- en: Let’s create a new test file in the *structures/tests* directory named *node_parse
    _test.py*. In the file, enter the code in [Listing 17-2](ch17.xhtml#ch17lis2).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *structures/tests* 目录下创建一个新的测试文件，命名为 *node_parse_test.py*。在该文件中，输入 [清单
    17-2](ch17.xhtml#ch17lis2) 中的代码。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 17-2: Testing the parsing of a node*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-2：测试节点解析*'
- en: 'This file defines a new test class: NodeParseTest. We’ve defined a string with
    the correct format so we can test whether we can parse all of its parts. That
    string is node_str ➊. We’ve written all of our tests to work with the node that
    results when we parse the string ➋; we did this to avoid repeating the same parsing
    operation in every test.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了一个新的测试类：NodeParseTest。我们已经定义了一个具有正确格式的字符串，以便我们可以测试是否能够解析其所有部分。这个字符串是
    node_str ➊。我们编写了所有测试，以便与解析该字符串 ➋ 后得到的节点一起使用；我们这样做是为了避免在每个测试中重复相同的解析操作。
- en: Then we have a test to ensure the ID is correctly set in the resulting node,
    another one that checks the node’s position, and two more to test whether the
    external constraints have been added or not.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个测试来确保结果节点中的 ID 被正确设置，另一个测试检查节点的位置，还有两个测试用来验证外部约束是否已被添加。
- en: 'Let’s run our tests to make sure they all pass. You can do so from the IDE
    or from the shell with the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试，确保它们都通过了。你可以通过 IDE 或在 shell 中使用以下命令来完成：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s now work on parsing the bars.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始解析条形图。
- en: '**Parsing Bars**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解析条形图**'
- en: In *structures/parse*, create a new file named *bar_parse.py*. In this file,
    enter the code in [Listing 17-3](ch17.xhtml#ch17lis3).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/parse* 目录下，创建一个名为 *bar_parse.py* 的新文件。在该文件中，输入 [清单 17-3](ch17.xhtml#ch17lis3)
    中的代码。
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 17-3: Parsing a bar from a string*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-3：从字符串解析一个条形图*'
- en: The regular expression to match the bar definition (__BAR_REGEX) is a bit long
    and complex. Make sure you enter it carefully. We’ll write some unit tests later,
    so any error here will come to light there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用于匹配条形图定义的正则表达式 (__BAR_REGEX) 有点长且复杂。确保小心输入它。我们稍后会编写一些单元测试，所以这里的任何错误将在测试中暴露出来。
- en: 'We’ve written the parse_bar function, which takes two parameters: the string
    defining the bar and a dictionary of nodes. In this dictionary, the keys are the
    IDs of the nodes, and the values are the nodes themselves. The bar needs to have
    a reference to its end nodes, so these have to be parsed first and then passed
    to the parse_bar function. This adds a constraint in the way we parse structure
    files: nodes should appear first.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了 parse_bar 函数，它接受两个参数：定义条形图的字符串和一个节点字典。在这个字典中，键是节点的 ID，值是节点本身。条形图需要引用其结束节点，因此必须先解析这些节点，然后传递给
    parse_bar 函数。这对我们解析结构文件的方式增加了一个约束：节点应该首先出现。
- en: As with the nodes, we start by matching the passed-in string against our regular
    expression ➊. If there is no match, we raise a ValueError with a helpful message
    including the string that couldn’t be parsed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与节点一样，我们首先将传入的字符串与我们的正则表达式 ➊ 进行匹配。如果没有匹配项，我们会引发一个 ValueError，并附上一个有帮助的消息，包含无法解析的字符串。
- en: 'Next, we retrieve and parse the capture groups: id parsed as an integer ➋,
    start_id ➌ and end_id ➍ parsed as integers, and sec ➎ and young ➏ parsed as floats.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检索并解析捕获组：id 解析为整数 ➋，start_id ➌ 和 end_id ➍ 解析为整数，sec ➎ 和 young ➏ 解析为浮动数值。
- en: 'Then we look for the start node in the nodes dictionary ➐ and raise an error
    if it’s not found: we can’t build a bar whose nodes don’t exist. We do the same
    thing for the end node, and then we create and return the bar instance in the
    last line ➑, passing it all the parsed values.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test this code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Bar Parser***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test the bar parsing process, create a new file in *structures/tests* named
    *bar_parse_test.py*. Enter the new tests in [Listing 17-4](ch17.xhtml#ch17lis4).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 17-4: Testing the parsing of a bar*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we define a bar using its string representation ➊. The parse _bar
    function requires a dictionary containing the nodes by ID as its second argument;
    we create a dummy (recall the types from the 16 [page 447](ch16.xhtml#ch00lev1sec97))
    called nodes_dict ➋. This dictionary contains the two node IDs mapped to a string.
    Our parsing code doesn’t really do anything with the nodes or even check their
    types; it simply adds them to the bar instance. So for the tests, a string mocking
    the node is enough.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Again, we parse ➌ first and store the result in the bar variable. We then create
    five tests that check that we’ve correctly parsed the ID, both start and end nodes,
    the cross section, and Young’s modulus.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests to make sure they all pass. You can do so from the shell:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lastly, we need to parse the loads.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**Parsing Loads**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now write a function to parse the load strings, but we won’t apply the
    loads to the nodes here. That’ll happen later when we put all the pieces together.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in *structures/parse* named *load_parse.py*. Enter the code
    in [Listing 17-5](ch17.xhtml#ch17lis5).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 17-5: Parsing a load from a string*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In this listing we define the regular expression that matches the loads as __LOAD_REGEX.
    Then comes the parse_load function, which first looks for a match in the passed-in
    string (load_str) ➊. We raise an error if the string doesn’t match __LOAD_REGEX.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular expression defines two capturing groups: node_id and vec. The first
    group is the ID of the node where the load needs to be applied. We convert the
    value for this first group into an integer and store it in the node_id variable
    ➋.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To extract the force components, we split the value matched by the vec capture
    group and then parse each part, convert it to a float value, and use destructuring
    to extract the components into the fx and fy variables ➌.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we return a tuple of the node ID and a vector with the force components
    ➍.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test this logic to make sure it parses loads correctly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Load Parser***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the *structures/tests* folder, create a new file named *load_parse_test.py*.
    Enter the test code in [Listing 17-6](ch17.xhtml#ch17lis6).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 17-6: Testing the parsing of a load*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This test defines a string representing a load applied to a node with an ID
    of 1 and whose components are ⟨250.0,–3500.0⟩. The string is stored in the load_str
    variable and passed to the parse_load function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, we check that we’ve correctly parsed the node ID, which is
    returned by the function as the tuple’s first value. Then, we check that we’ve
    correctly parsed the tuple’s second value, the vector. These two simple tests
    are enough to make sure our function does its job.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests from the IDE or from the shell:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have functions that can parse the structure’s individual parts from
    their string representations, it’s time to put them together. In the next section,
    we’ll work on a function that reads all the lines of a structure definition file
    and generates the corresponding model.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Parsing the Structure**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our structure files define each entity on its own line, and entities appear
    grouped by sections. If you recall, we defined three sections for the three different
    entities we need to parse: nodes, bars, and loads. Here’s the previous example
    of a structure file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because these files will mostly be written by hand, it would be nice if we
    allowed the inclusion of comments: lines that are ignored by the parsing mechanism
    but explain something to someone reading the file, just like comments in code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ll borrow Python’s syntax and use the # symbol to mark the start of a comment.
    Comments will have to appear on their own lines.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '***Overview***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because we’ll need to write a few functions, it may be helpful to have a diagram
    of the structure parsing process with the function names annotated after the steps.
    Take a look at [Figure 17-5](ch17.xhtml#ch17fig5).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig05.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: Structure parsing process*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we show each step of the parsing process. We start with a structure
    file defining the structure in plaintext following our standard format.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to read the file contents into a string. We’ll implement this
    part in our application in [Chapter 19](ch19.xhtml#ch19).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The second step consists of splitting the big string into multiple lines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The third step is parsing those lines into a dictionary of the structural primitives.
    This step is handled by the private __parse_lines function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and final step is aggregating those parsed structural items into
    a structure instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The parse_structure_from_lines function is a combination of steps 3 and 4:
    it transforms a list of definition lines into a complete structure. The parse
    _structure function goes one step further and splits a single string into multiple
    lines.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '***Setup***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the *structures/parse* directory, create a new file named *str_parse.py*.
    The *structures* package should now look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: structures
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '|- model'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '|    | ...'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '|- parse'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- __init__.py'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- bar_parse.py'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- load_parse.py'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- node_parse.py'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- str_parse.py'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '|- solution'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '|    | ...'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '|- tests'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '|    | ...'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start the implementation with a function that determines whether a line
    in the file is blank or a comment. This function will let us know whether a given
    line can be ignored or whether it has to be parsed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '***Ignoring Blank Lines and Comments***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***忽略空行和注释***'
- en: In *str_parse.py*, enter the code in [Listing 17-7](ch17.xhtml#ch17lis7).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在*str_parse.py*中，输入[Listing 17-7](ch17.xhtml#ch17lis7)中的代码。
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 17-7: Function to determine the lines that need to be ignored*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-7：确定需要忽略的行的函数*'
- en: 'We define a constant, __COMMENT_INDICATOR, with the # character for its value.
    If we ever want to change the way comments are identified, we’ll simply need to
    edit this line.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个常量`__COMMENT_INDICATOR`，它的值是`#`字符。如果我们想要更改注释的识别方式，只需编辑这一行。
- en: Next is the __should_ignore_line function. This function receives a string and
    removes any surrounding blank spaces (in other words, it strips the string). Then,
    if the line has a length of zero or starts with the comment indicator, the function
    returns a True value, and a False otherwise.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`__should_ignore_line`函数。该函数接收一个字符串并去除两端的空白字符（换句话说，它会去除字符串的空白）。然后，如果该行的长度为零或以注释标识符开头，函数将返回True值，否则返回False。
- en: '***Parsing the Lines***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解析行***'
- en: Now that we have a way to filter out the lines that don’t need to be parsed,
    let’s look at the ones that do. We’re going to define a function that receives
    a list of strings representing the lines and identifies whether the line is a
    section header (“nodes,” “bars,” or “loads”) or an entity. In the case of a section
    header, the function will set a flag to keep track of the current section being
    read. The rest of the function will take care of parsing each line using the corresponding
    parser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一种方法来过滤掉不需要解析的行，接下来看看需要解析的行。我们将定义一个接收字符串列表的函数，这些字符串代表行，并识别该行是部分头（“nodes”、“bars”或“loads”）还是实体。如果是部分头，函数将设置一个标志来跟踪当前正在读取的部分。函数的其余部分将负责使用相应的解析器解析每一行。
- en: In the file *str_parse.py*, enter the code in [Listing 17-8](ch17.xhtml#ch17lis8).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件*str_parse.py*中，输入[Listing 17-8](ch17.xhtml#ch17lis8)中的代码。
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 17-8: Parsing the lines*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-8：解析行*'
- en: 'We first add three variables with the names of the file headers: __NODES _HEADER,
    __LOADS_HEADER, and __BARS_HEADER. These constants define the names of the sections.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加了三个变量，分别是文件头的名称：`__NODES_HEADER`、`__LOADS_HEADER`和`__BARS_HEADER`。这些常量定义了各个部分的名称。
- en: 'Then comes the __parse_lines function definition, which takes one parameter:
    the list of lines in the structure file. The function declares a variable named
    reading ➊. This variable indicates what structure section the later loop is currently
    in. For example, when its value is ’bars’, the subsequent lines should be parsed
    using the parse_bar function until the end of the file or a new section is encountered.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`__parse_lines`函数的定义，它接收一个参数：结构文件中的行列表。该函数声明了一个名为`reading ➊`的变量。此变量指示后续循环当前处于哪个结构部分。例如，当它的值为“bars”时，随后的行应该使用`parse_bar`函数进行解析，直到文件结束或遇到新的部分。
- en: 'Next comes the definition of the result dictionary ➋. It’s initialized with
    three keys: ’nodes’, ’loads’, and ’bars’. We’ll add the parsed elements to this
    dictionary, in their corresponding key’s collection. Loads and bars are stored
    in a list and nodes in a dictionary, with the keys being their IDs. We store nodes
    mapped to their keys in a dictionary because both loads and bars refer to them
    by ID in the structure file; thus, when we link them, it’ll be more convenient
    to look them up by ID.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是结果字典`➋`的定义。它通过三个键来初始化：'nodes'、'loads'和'bars'。我们将解析后的元素添加到此字典中，按照它们对应的键的集合进行存储。`loads`和`bars`存储在列表中，`nodes`则存储在字典中，键是它们的ID。我们将节点映射到它们的键存储在字典中，因为在结构文件中，`loads`和`bars`都通过ID来引用节点；因此，当我们将它们关联时，通过ID查找会更方便。
- en: Next is the loop that iterates over the lines’ enumeration. Recall that Python’s
    enumerate function returns an iterable sequence that includes the original objects
    along with their index. We’ll use the index only if we encounter an error, using
    the line number in the error message to make looking for the error in the input
    file easier. The first thing we do with each line is check whether it’s blank
    or a comment ➌, in which case we skip it using the continue statement.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个循环，遍历行的枚举。回想一下，Python的`enumerate`函数返回一个可迭代序列，其中包含原始对象以及它们的索引。我们只会在遇到错误时使用该索引，借助行号在错误信息中可以更容易地找到输入文件中的错误。我们对每一行的处理第一步是检查它是否为空行或是注释行
    ➌，如果是这种情况，我们会使用`continue`语句跳过该行。
- en: 'Next, we have a couple of if-else statements. The first block of them is for
    matching header lines ➍. When a line is found to match one of the three possible
    headers, we set the reading variable to the header’s value. The later if-else
    statements evaluate reading to determine which structural element to parse ➎.
    If reading has the value ’nodes’, we use the parse_node function to parse the
    line and store the result in the result dictionary, under the ’nodes’ key:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The same goes for bars and loads, but remember that in their case, they’re
    stored in a list:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function then returns the result dictionary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We’ve implemented a function that reads a sequence of text lines and converts
    each of them into a structure class instance (what we know as parsing). These
    instances represent the nodes, bars, and loads of the structure. The function
    returns a dictionary that bundles these instances by type. The next step is using
    these parsed objects to construct a Structure instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '***Splitting the Lines and Instantiating the Structure***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the contents of a structure file as a string, we want to split this string
    into its lines. We’ll pass those lines to the __parse_lines function we wrote
    earlier, and using the parsed objects we can construct an instance of our Structure
    class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the *str_parse.py* file, before the __parse_lines function, enter the code
    in [Listing 17-9](ch17.xhtml#ch17lis9).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 17-9: Splitting the lines*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We’ve written three new functions. The first of them, parse_structure, splits
    the passed-in string into its lines ➊ and forwards those lines to the parse_structure_from_lines
    function defined afterward.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'This second function, parse_structure_from_lines, passes the lines to __parse_lines
    and saves the result in a variable called parsed ➋. It then extracts the contents
    of this result dictionary to the variables: nodes_dict, loads, and bars.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The loads are defined separately from the nodes they’re applied to; thus, we
    need to add each load to its respective node ➌. To do this, we’ve written another
    small function: __apply_loads_to_nodes. Recall that the loads were defined using
    the format'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and are parsed by our parse_load function as a tuple consisting of the node
    ID and the load components as a vector:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It’s important to keep this in mind to understand the loop in __apply _loads_to_nodes
    ➎. The loop iterates over the load tuples, and on each iteration, it stores the
    node ID and load vector into the node_id and load variables, respectively. Because
    our nodes are stored in a dictionary whose keys are the node IDs, applying the
    loads is a piece of cake.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Once the loads have been applied to the nodes (back in parse_structure _from_lines),
    the last step is to return an instance of the Structure class. The class’s constructor
    expects a list of nodes and a list of bars. The bars are already parsed as a list,
    but the nodes were in a dictionary. To turn the values of a dictionary into a
    list, we simply need to use Python’s list function on the dictionary values, which
    we extract using the values() method ➍.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: With this, our parsing logic is ready!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '***The Result***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For your reference, [Listing 17-10](ch17.xhtml#ch17lis10) shows the complete
    code for *str_parse.py*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 17-10: Parsing the structure*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move to the next section, open the *__init__.py* file in *parse*,
    and enter the following import:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This allows us to import the parse_structure function like this,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'instead of this slightly longer version:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s make sure our parsing function is working correctly by implementing some
    automated tests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Structure Parser***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make sure the parse_structure function works as expected, we’ll now add
    a few unit tests. First, we want to create a structure definition file to use
    in the test. In the *structures/tests* directory, create a new file, *test_str.txt*,
    with the following contents:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ve added comment lines and some extra blank lines; our function should ignore
    those. Create a new test file: *str_parse_test.py* ([Listing 17-11](ch17.xhtml#ch17lis11)).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 17-11: Setting up the structure parsing test*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The file defines a new test class: StructureParseTest. In the setUp method,
    we load the *test_str.txt* file as bytes using the resource_string function. Then,
    we decode those bytes into a UTF-8 encoded Python string. Lastly, using parse_structure,
    we parse the structure string and store the result in a class attribute: self.structure.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the Node Parser**'
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s add some test cases to ensure the structure that we parsed from the *test_str.txt*
    file contains the expected nodes. After the setUp method, enter the first tests
    ([Listing 17-12](ch17.xhtml#ch17lis12)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 17-12: Testing the structure parsing: the nodes*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We’ve written three tests. The first one checks that there are three nodes in
    the structure. The next test ensures that those three nodes have the correct position.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: There’s one interesting thing to note here. Since the __nodes list is private
    to the Structure class, Python uses a trick to try to hide it from us. Python
    prepends an underscore and the name of the class to the name of its private attributes.
    The __nodes attribute will therefore be called _Structure__nodes, and not __nodes
    as we’d expect. This is why, to access it from our tests, we use this name ➊.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The third and last test checks if the external constraints in the nodes have
    the right values as defined in the structure definition file. Let’s run the tests.
    You can click the green play button in the IDE or use the shell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A success message should be displayed in the shell.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the Bar Parser**'
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now test if the bars are also parsed correctly. After the test cases we
    just wrote, enter the ones in [Listing 17-13](ch17.xhtml#ch17lis13).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 17-13: Testing the structure parsing: the bars*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test asserts that there are three bars in the structure. The second
    test checks that every bar in the structure is linked to the correct node IDs.
    Same as before, to access the private list of bars, we need to prepend _Structure
    to the attribute name: _Structure__bars.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: I invite you to add two more tests that check that the values for the cross
    section and Young’s modulus are correctly parsed into the bars. We won’t include
    them here for brevity reasons.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test class again to make sure our new tests also pass. From the shell,
    run this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Testing the Load Parser**'
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s add the two last tests to ensure the loads are properly parsed. Enter
    the code in [Listing 17-14](ch17.xhtml#ch17lis14).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 17-14: Testing the structure parsing: the loads*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In these two last tests, we check that the number of loads in the structure
    is 1 and that it’s being correctly applied to the second node.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run all the tests to make sure all pass:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If your code is well implemented, all the tests should pass, and you should
    see the following in the shell:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Test Class Result**'
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve done a few tests, so [Listing 17-15](ch17.xhtml#ch17lis15) shows the resulting
    test class for your reference.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 17-15: Testing the structure parsing*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Our structure parsing logic is ready and tested!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we first defined a format for our structure files. It’s a simple
    plaintext format that can be written by hand.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'We then implemented functions to parse each of the lines in our structure files
    into its appropriate structural element: nodes, loads, and bars. Regular expressions
    were the stars of the show; with them, parsing well-structured text was a breeze.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we put everything together into a function that splits a big string
    into its lines and decides which parser to use for each line. We’ll use this function
    to read structure files and create the structural model that our truss resolution
    application will work with.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to work on producing the output diagrams for the structure solution.
    That’s exactly what we’ll do in the next chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
