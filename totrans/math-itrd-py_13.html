<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_201"/><span class="big">10</span><br/>CREATING FRACTALS USING RECURSION</h2>&#13;
<p class="epigraph"><em>What’s another word for</em> thesaurus<em>?<br/>—Steven Wright</em></p>&#13;
<div class="image"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">Fractals are delightfully complicated designs, where each smaller part of the design contains the entire design (see <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>). They were invented (or discovered, since fractals exist in nature) by Benoit Mandelbrot in 1980 when he was visualizing some complex functions on a state-of-the-art IBM computer.</p>&#13;
<div class="image"><a id="ch10fig1"/><img alt="image" src="../images/f201-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-1: Examples of fractals</em></p>&#13;
<span epub:type="pagebreak" id="page_202"/>&#13;
<p class="indent">Fractals don’t look like regular shapes we recognize from geometry, like squares, triangles, and circles. Their shapes are crooked and jagged, making them great models for simulating natural phenomena. In fact, scientists use fractals to model everything from the arteries in your heart, to earthquakes, to neurons in your brain.</p>&#13;
<p class="indent">What makes fractals so interesting is that they illustrate how you can get surprisingly complex designs from simple rules being run over and over and patterns being repeated at smaller and smaller scale.</p>&#13;
<p class="indent">Our main interest is the interesting, complicated designs you can make using fractals. There’s a picture of a fractal in every math book these days, but textbooks never show you how to make one—you need a computer to do that. In this chapter, you learn how to make your own fractals using Python.</p>&#13;
<h3 class="h3" id="ch10_1">THE LENGTH OF A COASTLINE</h3>&#13;
<p class="noindent">Before you can start creating fractals, let’s look at a simple example to understand how fractals can be useful. A mathematician named Lewis Richardson asked a simple question; “How long is the coastline of England?” As you can see in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>, the answer depends on how long your ruler is.</p>&#13;
<div class="image"><a id="ch10fig2"/><img alt="image" src="../images/f202-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-2: Approximating the length of a coastline</em></p>&#13;
<p class="indent">The smaller your ruler, the more closely you can approximate the coastline’s jagged edges, which means you’ll end up with a longer measurement. The cool thing is that <em>the length of the coastline approaches infinity as the length of the ruler gets close to zero!</em> This is known as the Coastline Paradox.</p>&#13;
<p class="indent">Think this is just abstract mathematical noodling? Coastline length estimates can vary wildly in the real world. Even with modern technology, it all depends on the scale used to measure the map. We’ll draw a figure like <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>, the Koch snowflake, to show how a fractal can prove a rough enough coastline can get as long as you want!</p>&#13;
<span epub:type="pagebreak" id="page_203"/>&#13;
<div class="image"><a id="ch10fig3"/><img alt="image" src="../images/f203-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-3: An increasingly detailed fractal, modeling an increasingly rough coastline</em></p>&#13;
<p class="indent">First, you’re going to need to learn a few tricks, like recursion.</p>&#13;
<h4 class="h4" id="ch10_1_1">WHAT IS RECURSION?</h4>&#13;
<p class="noindent">The power of fractals is that you can repeat patterns of numbers or shapes that get smaller at every step until you’re dealing with very small numbers. The key to repeating all this code is a concept called <em>recursion</em>, which is when something is defined in terms of itself. Some of these jokes illustrate how recursion works:</p>&#13;
<ul>&#13;
<li class="noindent">If you google “recursion,” it asks you, “Did you mean <em>recursion</em>?”</li>&#13;
<li class="noindent">In the index to more than one computer programming book, there’s an entry like this: “recursion, see <em>recursion</em>.”</li>&#13;
</ul>&#13;
<p class="indent">As you can imagine, recursion is a pretty strange concept. The virtue of recursion is that it can tidy up code that would otherwise be too complicated, but the disadvantage is that you can end up using up too much memory.</p>&#13;
<h4 class="h4" id="ch10_1_2">WRITING THE FACTORIAL() FUNCTION</h4>&#13;
<p class="noindent">Let’s see recursion in action by writing a function for the factorial of a number. You may recall from math class that the <em>factorial</em> of <em>n</em> (expressed as <em>n!</em>) is defined as the product of all the integers from 1 to <em>n</em>. For example, 5! = 1 × 2 × 3 × 4 × 5 = 120.</p>&#13;
<p class="indent">The formula looks like this: <em>n</em>! = 1 × 2 × 3 . . . × (<em>n</em> – 2) × (<em>n</em> – 1) × <em>n</em>. This is an example of a recursive sequence, because 5! = 5 × 4! and 4! = 4 × 3!, and so on. Recursion is an important concept in math because math is all about patterns, and recursion allows you to copy and extend patterns infinitely!</p>&#13;
<p class="indent">We can define the factorial of n as the product of n and the factorial of n – 1. We just have to define the factorial of 0 (which is 1, not 0) and the factorial of 1 and then use a recursive statement. Open a new file in IDLE, save it as <em>factorial.py</em>, and then enter with the code in <a href="ch10.xhtml#ch10list1">Listing 10-1</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>factorial.py</em></span><br/><span class="pd_orange">def</span> <span class="pd_blue">factorial</span>(n):<br/>    <span class="pd_orange">if</span> n == 0:<br/>        <span class="pd_orange">return</span> 1<br/>    <span class="pd_orange">else</span>:<br/>        <span class="pd_orange">return</span> n * factorial(n – 1)</p>&#13;
<p class="listing" id="ch10list1"><em>Listing 10-1: Using a recursive statement to write the <span class="literal">factorial()</span> function</em></p>&#13;
<span epub:type="pagebreak" id="page_204"/>&#13;
<p class="indent">First, we’re saying, “If the user (or the program) asks for the factorial of 0 or 1, return 1.” This is because 0! and 1! both equal 1. Then we tell the program, “For any other number <em>n</em>, return <em>n</em> times the factorial of the number 1 less than <em>n</em>.”</p>&#13;
<p class="indent">Notice that on the last line of <a href="ch10.xhtml#ch10list1">Listing 10-1</a>, we’re calling the <span class="literal">factorial()</span> function <em>inside</em> the definition of the <span class="literal">factorial()</span> function! That’s like a recipe for a loaf of bread containing the step “Bake a loaf of bread.” People wouldn’t even begin following a recipe written like that. But computers can start going through the steps and follow them throughout the process.</p>&#13;
<p class="indent">In this example, when we ask for the factorial of 5, the program proceeds obediently and makes it to the last line, where it asks for the factorial of <em>n</em> – 1, which in this case (because <em>n</em> = 5) is the factorial of 4. To calculate factorial (5 – 1), the program starts the <span class="literal">factorial()</span> function again with <em>n</em> = 4 and tries to evaluate the factorial of 4 the same way, followed by the factorial of 3, the factorial of 2, the factorial of 1, and finally the factorial of 0. Because we already defined the function to return the factorial of 0 as 1, the function can go back up through the process, evaluating the factorial of 1, then 2, then 3, then 4, and finally 5.</p>&#13;
<p class="indent">Defining a function recursively (by calling the function inside its own definition) might seem confusing, but it’s the key to making all the fractals in this chapter. Let’s start with a classic: the fractal tree.</p>&#13;
<h4 class="h4" id="ch10_1_3">BUILDING A FRACTAL TREE</h4>&#13;
<p class="noindent">Making a fractal starts with defining a simple function and adding a call to the function inside the function itself. Let’s try building a fractal tree that looks like <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>&#13;
<div class="image"><a id="ch10fig4"/><img alt="image" src="../images/f204-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-4: A fractal tree</em></p>&#13;
<p class="indent">This would be an incredibly complicated design to create if you had to tell the program every line to draw. But it takes surprisingly little code if you use recursion. Using translations, rotations, and the <span class="literal">line()</span> function, we’ll first draw a Y in Processing, as shown in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>.</p>&#13;
<span epub:type="pagebreak" id="page_205"/>&#13;
<div class="image"><a id="ch10fig5"/><img alt="image" src="../images/f205-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-5: The beginnings of a fractal tree</em></p>&#13;
<p class="indent">The only requirement to eventually make this Y into a fractal is that after the program draws the Y tree, along with the branches, the program has to return to the bottom of the “trunk.” This is because the “branches” are going to become Y’s themselves. If the program doesn’t return to the bottom of the Y every time, we won’t get our tree.</p>&#13;
<h5 class="h5">WRITING THE Y() FUNCTION</h5>&#13;
<p class="noindent">Your Y doesn’t have to be perfect or symmetrical, but here’s my code for drawing a Y. Open a new sketch in Processing, name it <em>fractals.pyde</em>, and enter the code in <a href="ch10.xhtml#ch10list2">Listing 10-2</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>fractals.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(300,500)<br/>    y(100)<br/><br/><span class="pd_green1">def</span> y(sz):<br/>    <span class="pd_blue1">line</span>(0,0,0,-sz)<br/>    <span class="pd_blue1">translate</span>(0,-sz)<br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(30))<br/>    <span class="pd_blue1">line</span>(0,0,0,-0.8*sz) <span class="pd_gray">#right branch</span><br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-60))<br/>    <span class="pd_blue1">line</span>(0,0,0,-0.8*sz) <span class="pd_gray">#left branch</span><br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(30))<br/>    <span class="pd_blue1">translate</span>(0,sz)</p>&#13;
<p class="listing" id="ch10list2"><em>Listing 10-2: Writing the <span class="literal">y()</span> function for the fractal tree</em></p>&#13;
<p class="indent">We set up the Processing sketch the way we always do: in the <span class="literal">setup()</span> function we tell the program what size to make the display window, and then in the <span class="literal">draw()</span> function we set the background color (255 is white) and translate to where we want to start drawing. Finally, we call the <span class="literal">y()</span> function and pass the number 100 for the size of the “trunk” of the fractal tree.</p>&#13;
<p class="indent">The <span class="literal">y()</span> function takes a number <span class="literal">sz</span> as a parameter to be the length of the trunk of the tree. Then all the branches will be based on that number. The first line of code in the <span class="literal">y()</span> function draws the trunk of the tree using <span epub:type="pagebreak" id="page_206"/>a vertical line. To create a line branching off to the right, we translate the vertical line up the trunk of the tree (in the negative y-direction) and then rotate it 30 degrees to the right. Next, we draw another line for the right branch, rotate to the left (negative 60 degrees), and draw another line for the left branch. Finally, we have to rotate so we’re facing straight up again so that we can translate down the trunk again. Save and run this sketch, and you should see the Y in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>.</p>&#13;
<p class="indent">We can convert this program that draws a single Y into one that draws a fractal by making the branches into <em>smaller</em> Y’s. But if we simply replace “line” with “y” in the <span class="literal">y()</span> function, our program will get stuck in an infinite loop, throwing an error like this:</p>&#13;
<p class="programs">RuntimeError: maximum recursion depth exceeded</p>&#13;
<p class="indent">Recall that we didn’t call <span class="literal">factorial(n)</span> inside the factorial function but rather called <span class="literal">factorial(n-1)</span>. We have to introduce a <span class="literal">level</span> parameter to the <span class="literal">y()</span> function. Then each branch up, the tree will be a level down, so the branch will get the parameter <span class="literal">level – 1</span>. This means the trunk is always the highest numbered level and the last set of branches up the tree is always level 0. Here’s how to change the <span class="literal">y()</span> function in <a href="ch10.xhtml#ch10list3">Listing 10-3</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>fractals.pyde</em></span><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    background(255)</span><br/><span class="pd_gray">    translate(300,500)</span><br/><span class="pd_gray">    </span>y(100,2)<br/><br/><span class="pd_green1">def</span> y(sz,level):<br/>    <span class="pd_lime">if</span> level &gt; 0:<br/>        <span class="pd_blue1">line</span>(0,0,0,-sz)<br/>        <span class="pd_blue1">translate</span>(0,-sz)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(30))<br/>        y(0.8*sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-60))<br/>        y(0.8*sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(30))<br/>        <span class="pd_blue1">translate</span>(0,sz)</p>&#13;
<p class="listing" id="ch10list3"><em>Listing 10-3: Adding recursion to the <span class="literal">y()</span> function</em></p>&#13;
<p class="indent">Notice that we replaced all the <span class="literal">line()</span> functions in the code with <span class="literal">y()</span> functions to draw the branches. Because we changed the call to the <span class="literal">y()</span> function in <span class="literal">draw()</span> to <span class="literal">y(100,2)</span>, we’ll get a tree of trunk size 100 with two levels. Try a three-level tree, a four-level one, and so on! You should see something like <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>.</p>&#13;
<span epub:type="pagebreak" id="page_207"/>&#13;
<div class="image"><a id="ch10fig6"/><img alt="image" src="../images/f207-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-6: Trees of levels 1 through 4</em></p>&#13;
<h5 class="h5">Mapping the Mouse</h5>&#13;
<p class="noindent">Now let’s make a program that allows you to control the shape of the fractal in real time, just by moving your mouse up or down! We can vary the level of rotation dynamically by tracking the mouse and returning a value between 0 and 10 based on its location. Update the <span class="literal">draw()</span> function with the code in <a href="ch10.xhtml#ch10list4">Listing 10-4</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>fractals.pyde</em></span><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    background(255)</span><br/><span class="pd_gray">    translate(300,500)</span><br/>    level = <span class="pd_blue1">int</span>(<span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,10))<br/>    y(100,level)</p>&#13;
<p class="listing" id="ch10list4"><em>Listing 10-4: Adding the <span class="literal">level</span> parameter to the <span class="literal">draw()</span> function</em></p>&#13;
<p class="indent">Our mouse’s x-value can be anywhere between 0 and the width of the window. The <span class="literal">map()</span> function replaces one range of values with another. In <a href="ch10.xhtml#ch10list4">Listing 10-4</a>, <span class="literal">map()</span> will take the x-value and instead of the output being between 0 and 600 (the width of the display screen), it will be between 0 and 10, the range of levels we want to draw. So we assign that value to a variable called <span class="literal">level</span> and pass that value to the <span class="literal">y()</span> function in the next line.</p>&#13;
<p class="indent">Now that we’ve tweaked the <span class="literal">draw()</span> function to return a value based on the position of the mouse, we can vary the shape of our tree by linking the y-coordinate of the mouse to the angle we’re rotating by.</p>&#13;
<p class="indent">The angle of rotation should only go up to 180 because the tree will “fold up” completely at 180 degrees, but the mouse’s y-value can go up to 600 since that’s the height of the screen we declared in <span class="literal">setup()</span>. We could do a little math to convert the values ourselves, but it would be easier to just use Processing’s built-in <span class="literal">map()</span> function. We tell the <span class="literal">map()</span> function what variable we want to map, specifying its current minimum and maximum values and the desired minimum and maximum values. The entire code for the Y fractal tree is shown in <a href="ch10.xhtml#ch10list5">Listing 10-5</a>.</p>&#13;
<span epub:type="pagebreak" id="page_208"/>&#13;
<p class="programs"><span class="pd_g1"><em>fractals.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(300,500)<br/>    level = int(<span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,15))<br/>    y(100,level)<br/><br/><span class="pd_green1">def</span> y(sz,level):<br/>    <span class="pd_lime">if</span> level &gt; 0:<br/>        <span class="pd_blue1">line</span>(0,0,0,-sz)<br/>        <span class="pd_blue1">translate</span>(0,-sz)<br/>        angle = <span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseY</span>,0,<span class="pd_raspberry">height</span>,0,180)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(angle))<br/>        y(0.8*sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-2*angle))<br/>        y(0.8*sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(angle))<br/>        <span class="pd_blue1">translate</span>(0,sz)</p>&#13;
<p class="listing" id="ch10list5"><em>Listing 10-5: The entire code to make a dynamic fractal tree</em></p>&#13;
<p class="indent">We take the mouse’s y-value and convert it to a range between 0 and 180 (if you already think in radians, you can map it to between 0 and pi). In the <span class="literal">rotate()</span> lines, we give it that angle (which is in degrees) and have Processing convert the degrees to radians. The first <span class="literal">rotate()</span> line will rotate to the right. The second <span class="literal">rotate()</span> line will rotate a negative angle, meaning to the left. It’ll rotate twice as much to the left. Then the third <span class="literal">rotate()</span> line will rotate to the right again.</p>&#13;
<p class="indent">When you run the code, you should see something like <a href="ch10.xhtml#ch10fig7">Figure 10-7</a>.</p>&#13;
<div class="image"><a id="ch10fig7"/><img alt="image" src="../images/f208-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-7: A dynamic fractal tree</em></p>&#13;
<p class="indent">Now when you move the mouse up or down, left or right, the level and shape of the fractal should change accordingly.</p>&#13;
<span epub:type="pagebreak" id="page_209"/>&#13;
<p class="indent">Through drawing the fractal tree, you learned how to use recursion to draw complicated designs using a surprisingly small amount of code. Now we’ll return to the coastline problem. How could a coastline, or any line, double or triple in length just from getting more jagged?</p>&#13;
<h3 class="h3" id="ch10_2">KOCH SNOWFLAKE</h3>&#13;
<p class="noindent">The Koch snowflake is a famous fractal named after Swedish mathematician Helge von Koch, who wrote about the shape in a paper in 1904! It’s made from an equilateral triangle. We start with a line and add a “bump” to it. Then, we add a smaller bump to each resulting line segment and repeat the process, like in <a href="ch10.xhtml#ch10fig8">Figure 10-8</a>.</p>&#13;
<div class="image"><a id="ch10fig8"/><img alt="image" src="../images/f209-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-8: Adding a “bump” to each segment</em></p>&#13;
<p class="indent">Let’s start a new Processing sketch, call it <em>snowflake.pyde</em>, and add the code in <a href="ch10.xhtml#ch10list6">Listing 10-6</a>, which will give us an upside-down equilateral triangle.</p>&#13;
<p class="programs"><span class="pd_g1"><em>snowflake.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(100,100)<br/>    snowflake(400,1)<br/><br/><span class="pd_green1">def</span> snowflake(sz,level):<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(3):<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(120))</p>&#13;
<p class="listing" id="ch10list6"><em>Listing 10-6: Writing the <span class="literal">snowflake()</span> function</em></p>&#13;
<p class="indent">In the <span class="literal">draw()</span> function, we call the <span class="literal">snowflake()</span> function, which for now takes only two parameters: <span class="literal">sz</span> (the size of the initial triangle) and <span class="literal">level</span> (the level of the fractal). The <span class="literal">snowflake()</span> function draws a triangle by starting a loop that repeats the code three times. Inside the loop we draw a line of length <span class="literal">sz</span>, which will be the side of the triangle, and then translate along the line to the next vertex of the triangle and rotate 120 degrees. Then we draw the next side of the triangle.</p>&#13;
<p class="indent">When you run the code in <a href="ch10.xhtml#ch10list6">Listing 10-6</a>, you should see <a href="ch10.xhtml#ch10fig9">Figure 10-9</a>.</p>&#13;
<span epub:type="pagebreak" id="page_210"/>&#13;
<div class="image"><a id="ch10fig9"/><img alt="image" src="../images/f210-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-9: Level 1 snowflake: a triangle</em></p>&#13;
<h4 class="h4" id="ch10_1_4">WRITING THE SEGMENT() FUNCTION</h4>&#13;
<p class="noindent">Now we need to tell the program how to change a line into a segment that will have different levels. Level 0 will just be a straight line, but the next level will introduce the “bump” in the side. We’re really dividing the segment into three segments and then taking the middle segment and replicating it to make it into a little equilateral triangle. We’ll change the <span class="literal">snowflake()</span> function to call another function to draw the segment. This will be the recursive function, because as the levels go up, the segments will become smaller copies of the segment in <a href="ch10.xhtml#ch10fig10">Figure 10-10</a>.</p>&#13;
<div class="image"><a id="ch10fig10"/><img alt="image" src="../images/f210-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-10: Cutting a segment into thirds and adding a “bump” to the middle third</em></p>&#13;
<p class="indent">We’ll call the side a <em>segment</em>. If the level is 0, the segment is simply a straight line, the side of the triangle. In the next step, a bump is added in the middle of the side. All the segments in <a href="ch10.xhtml#ch10fig10">Figure 10-10</a> are the same length, a third of the whole sidelength. This requires 11 steps:</p>&#13;
<ol>&#13;
<li class="noindent">Draw a line a third of the sidelength.</li>&#13;
<li class="noindent">Translate to the end of the segment you just drew.</li>&#13;
<li class="noindent">Rotate –60 degrees (to the left).</li>&#13;
<li class="noindent">Draw another segment.</li>&#13;
<li class="noindent">Translate to the end of that segment.</li>&#13;
<li class="noindent">Rotate 120 degrees (to the right).</li>&#13;
<li class="noindent">Draw a third segment.</li>&#13;
<li class="noindent">Translate to the end of that segment.</li>&#13;
<li class="noindent">Rotate –60 degrees again (to the left).</li>&#13;
<li class="noindent">Draw the last segment.</li>&#13;
<li class="noindent">Translate to the end of that segment.</li>&#13;
</ol>&#13;
<span epub:type="pagebreak" id="page_211"/>&#13;
<p class="indent">Now, instead of drawing a line, the <span class="literal">snowflake()</span> function will call a <span class="literal">segment()</span> function, which will do the drawing and translating. Add the <span class="literal">segment()</span> function in <a href="ch10.xhtml#ch10list7">Listing 10-7</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>snowflake.pyde</em></span><br/><span class="pd_gray">def snowflake(sz,level):</span><br/>    <span class="pd_gray">for i in range(3):</span><br/>        <span class="pd_gray">segment(sz,level)</span><br/>        <span class="pd_gray">rotate(radians(120))</span><br/><br/><span class="pd_green1">def</span> segment(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/>    <span class="pd_lime">else</span>:<br/>        <span class="pd_blue1">line</span>(0,0,sz/3.0,0)<br/>        <span class="pd_blue1">translate</span>(sz/3.0,0)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-60))<br/>        <span class="pd_blue1">line</span>(0,0,sz/3.0,0)<br/>        <span class="pd_blue1">translate</span>(sz/3.0,0)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(120))<br/>        <span class="pd_blue1">line</span>(0,0,sz/3.0,0)<br/>        <span class="pd_blue1">translate</span>(sz/3.0,0)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-60))<br/>        <span class="pd_blue1">line</span>(0,0,sz/3.0,0)<br/>        <span class="pd_blue1">translate</span>(sz/3.0,0)</p>&#13;
<p class="listing" id="ch10list7"><em>Listing 10-7: Drawing a “bump” on the sides of the triangle</em></p>&#13;
<p class="indent">In the <span class="literal">segment()</span> function, if the level is 0, it’s just a straight line, and we translate to the end of the line. Otherwise, we have 11 lines of code corresponding to the 11 steps of making a “bump.” First, we draw a line a third of the length of the side and then translate to the end of that line. We rotate left (–60 degrees) to draw the second segment in the line. That segment is also a third of the length of the side of the triangle. We translate to the end of that segment and then turn right by rotating 120 degrees. We then draw a segment and turn left one last time by rotating –60 degrees. Finally, we draw a fourth line (segment) and translate to the end of the side.</p>&#13;
<p class="indent">This draws a triangle if the level is 0 and puts a bump on each side if the level isn’t 0. As you can see in <a href="ch10.xhtml#ch10fig8">Figure 10-8</a>, at every step, every segment in the previous step gets a bump. This would be a headache to do without recursion! But we’ll take the line of code that draws a line and change that into a segment, just one level lower. This is the recursive step.</p>&#13;
<p class="indent">Next, we need to replace each line with a segment one level down, whose length is <span class="literal">sz</span> divided by 3. The code for the <span class="literal">segment()</span> function is shown in <a href="ch10.xhtml#ch10list8">Listing 10-8</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>snowflake.pyde</em></span><br/><span class="pd_gray">def segment(sz,level):</span><br/><span class="pd_gray">    if level == 0:</span><br/><span class="pd_gray">        line(0,0,sz,0)</span><br/><span class="pd_gray">        translate(sz,0)</span><br/><span class="pd_gray">    else:</span><br/>        segment(sz/3.0,level-1)<br/><span epub:type="pagebreak" id="page_212"/>&#13;
        <span class="pd_gray">rotate(radians(-60))</span><br/>        segment(sz/3.0,level-1)<br/>        <span class="pd_gray">rotate(radians(120))</span><br/>        segment(sz/3.0,level-1)<br/>        <span class="pd_gray">rotate(radians(-60))</span><br/>        segment(sz/3.0,level-1)</p>&#13;
<p class="listing" id="ch10list8"><em>Listing 10-8: Replacing the lines with segments</em></p>&#13;
<p class="indent">So all we did was replace each instance of <span class="literal">line</span> in <a href="ch10.xhtml#ch10list7">Listing 10-7</a> (whose level is greater than 0) with <span class="literal">segment()</span>. Because we don’t want to enter an infinite loop, the segments have to be one level down (<span class="literal">level – 1</span>) from the previous segment. Now we can change the level of the snowflake in the <span class="literal">draw()</span> function, as shown in the following code, and we’ll see different designs, as shown in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>.</p>&#13;
<p class="programs"><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    background(255)</span><br/><span class="pd_gray">    </span><span class="pd_blue1">translate</span>(100,<span class="pd_raspberry">height</span>-100)<br/>    snowflake(400,3)</p>&#13;
<div class="image"><a id="ch10fig11"/><img alt="image" src="../images/f212--01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-11: A level 3 snowflake</em></p>&#13;
<p class="indent">Even better, we can make it interactive by mapping the mouse’s x-value to the level. The mouse’s x-value can be anywhere from 0 to whatever the width of the screen is. We want to change that range to between 0 and 7. Here’s the code for that:</p>&#13;
<p class="programs">level = <span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,7)</p>&#13;
<p class="indent">However, we want only integer levels, so we’ll change that value to an integer using <span class="literal">int</span>, like this:</p>&#13;
<p class="programs">level = <span class="pd_blue1">int</span>(<span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,7))</p>&#13;
<span epub:type="pagebreak" id="page_213"/>&#13;
<p class="indent">We’ll add that to our <span class="literal">draw()</span> function and send the output “level” to the <span class="literal">snowflake()</span> function. The entire code for the Koch snowflake is shown in <a href="ch10.xhtml#ch10list9">Listing 10-9</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>snowflake.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(100,200)<br/>    level = <span class="pd_blue1">int</span>(<span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,7))<br/>    <span class="pd_gray">#y(100,level)</span><br/>    snowflake(400,level)<br/><br/><span class="pd_green1">def</span> snowflake(sz,level):<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(3):<br/>        segment(sz,level)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(120))<br/><br/><span class="pd_green1">def</span> segment(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/>    <span class="pd_lime">else</span>:<br/>        segment(sz/3.0,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-60))<br/>        segment(sz/3.0,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(120))<br/>        segment(sz/3.0,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-60))<br/>        segment(sz/3.0,level-1)</p>&#13;
<p class="listing" id="ch10list9"><em>Listing 10-9: Complete code for the Koch snowflake</em></p>&#13;
<p class="indent">Now when you run the program and move your mouse left and right, you’ll see the snowflake get more “bumps” on its segments, like in <a href="ch10.xhtml#ch10fig12">Figure 10-12</a>.</p>&#13;
<div class="image"><a id="ch10fig12"/><img alt="image" src="../images/f213-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-12: A level 7 snowflake</em></p>&#13;
<span epub:type="pagebreak" id="page_214"/>&#13;
<p class="indent">How does this help us understand the Coastline Paradox? Looking back at <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>, let’s call the length of the line (the side of the triangle) 1 unit (for example, 1 mile). When we split it in thirds, take out the middle, and add a “bump” two thirds long in the middle, the side is now 1 1/3 units long. It just got 1/3 longer, right? The perimeter of the snowflake (the “coastline”) gets 1/3 longer every step. So at the <em>n</em>th step, the length of the coastline is (4/3)<sup><em>n</em></sup> times the perimeter of the original triangle. It might not be possible to see, but after 20 steps, the coastline of the snowflake is so jagged that its total length is over 300 times the original measurement!</p>&#13;
<h3 class="h3" id="ch10_3">SIERPINSKI TRIANGLE</h3>&#13;
<p class="noindent">The Sierpinski triangle is a famous fractal first described by Polish mathematician Wacław Sierpiński in 1915, but there are examples of the design on the floors of churches in Italy from as far back as the 11th century! It follows a geometric pattern that’s easy to describe, but the design is surprisingly complicated. It works on an interesting recursive idea: draw a triangle for the first level, and for the next level turn each triangle into three smaller triangles at its corners, as shown in <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>.</p>&#13;
<div class="image"><a id="ch10fig13"/><img alt="image" src="../images/f214-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-13: Sierpinski triangles, levels 0, 1, and 2</em></p>&#13;
<p class="indent">The first step is easy: just draw a triangle. Open a new sketch and name it <em>sierpinski.pyde</em>. We set it up as usual, with <span class="literal">setup()</span> and <span class="literal">draw()</span> functions. In <span class="literal">setup()</span>, we set the size of the output window to 600 pixels by 600 pixels. In <span class="literal">draw()</span>, we set the background white and translate to a point (50,450) in the bottom left of the screen to start drawing our triangle. Next, we write a function named <span class="literal">sierpinski()</span>, similar to what we did with <span class="literal">tree()</span>, that draws a triangle if the level is 0. The code so far is shown in <a href="ch10.xhtml#ch10list10">Listing 10-10</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>sierpinski.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(50,450)<br/>    sierpinski(400,0)<br/><br/><span class="pd_green1">def</span> sierpinski(sz, level):<br/>    <span class="pd_lime">if</span> level == 0: <span class="pd_gray">#draw a black triangle</span><br/>        <span class="pd_blue1">fill</span>(0)<br/>        <span class="pd_blue1">triangle</span>(0,0,sz,0,sz/2.0,-sz*<span class="pd_blue1">sqrt</span>(3)/2.0)</p>&#13;
<p class="listing" id="ch10list10"><em>Listing 10-10: The setup of the Sierpinski fractal</em></p>&#13;
<span epub:type="pagebreak" id="page_215"/>&#13;
<p class="indent">The <span class="literal">sierpinski()</span> function takes two parameters: the size of the figure (<span class="literal">sz</span>) and the <span class="literal">level</span> variable. The fill color is 0 for black, but you can make it any color you want by using RGB values. The triangle line contains six numbers: the x- and y-coordinates of the three corners of an equilateral triangle with sidelength <span class="literal">sz</span>.</p>&#13;
<p class="indent">As you can see in <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>, level 1 contains three triangles at each corner of the original triangle. These triangles are also half the size of the triangle in the previous level. What we’ll do is create a smaller, lower-level Sierpinski triangle, translate to the next corner, and then rotate 120 degrees. Add the code in <a href="ch10.xhtml#ch10list11">Listing 10-11</a> to the <span class="literal">sierpinski()</span> function.</p>&#13;
<p class="programs"><span class="pd_gray">def draw():</span><br/>    <span class="pd_gray">background(255)</span><br/>    <span class="pd_gray">translate(50,450)</span><br/>    sierpinski(400,8)<br/><br/><span class="pd_gray">def sierpinski(sz, level):</span><br/><span class="pd_gray">    if level == 0: #draw a black triangle</span><br/><span class="pd_gray">        fill(0)</span><br/><span class="pd_gray">        triangle(0,0,sz,0,sz/2.0,-sz*sqrt(3)/2.0)</span><br/>    <span class="pd_lime">else</span>: <span class="pd_gray">#draw sierpinskis at each vertex</span><br/>        <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(3):<br/>            sierpinski(sz/2.0,level-1)<br/>            <span class="pd_blue1">translate</span>(sz/2.0,-sz*<span class="pd_blue1">sqrt</span>(3)/2.0)<br/>            <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(120))</p>&#13;
<p class="listing" id="ch10list11"><em>Listing 10-11: Adding the recursive step to the Sierpinski program</em></p>&#13;
<p class="indent">This new code tells Processing what to do when the level isn’t 0 (the line <span class="literal">for i in range(3):</span> means “repeat this three times”): draw a half-sized Sierpinski triangle of one level lower, and then translate halfway across and halfway up the equilateral triangle and turn right 120 degrees. Notice the <span class="literal">sierpinski()</span> function in <span class="literal">sierpinski(sz/2.0,level-1)</span> is executed inside the definition of the <span class="literal">sierpinski()</span> function itself. That’s the recursive step! When you call</p>&#13;
<p class="programs">sierpinski(400,8)</p>&#13;
<div class="image"><a id="ch10fig14"/><img alt="image" src="../images/f215-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-14: A level 8 Sierpinski triangle</em></p>&#13;
<p class="noindent">in the <span class="literal">draw()</span> function, you get a level 8 Sierpinski triangle, which you see in <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>.</p>&#13;
<p class="indent">An interesting thing about the Sierpinski triangle is that it shows up in other fractals too, like the next one, which doesn’t start with a triangle.</p>&#13;
<span epub:type="pagebreak" id="page_216"/>&#13;
<h3 class="h3" id="ch10_4">SQUARE FRACTAL</h3>&#13;
<p class="noindent">We can make the Sierpinski triangle out of squares too. For example, we can create a square, remove the lower-right quadrant, and then replace each remaining quadrant with the resulting shape. When we repeat this process, we should get something like <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>.</p>&#13;
<div class="image"><a id="ch10fig15"/><img alt="image" src="../images/f216--01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-15: The square fractal at levels 0, 1, 2, and 3</em></p>&#13;
<p class="indent">To create this fractal, we have to make each of the three smaller squares into a copy of the whole. Start a new Processing sketch called <em>squareFractal.pyde</em> and then set up the sketch with the code in <a href="ch10.xhtml#ch10list12">Listing 10-12</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>squareFractal.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">fill</span>(150,0,150) <span class="pd_gray">#purple</span><br/>    <span class="pd_blue1">noStroke</span>()<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(50,50)<br/>    squareFractal(500,0)<br/><br/><span class="pd_green1">def</span> squareFractal(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">rect</span>(0,0,sz,sz)</p>&#13;
<p class="listing" id="ch10list12"><em>Listing 10-12: Creating the <span class="literal">squareFractal()</span> function</em></p>&#13;
<div class="image"><a id="ch10fig16"/><img alt="image" src="../images/f216--02.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-16: Purple square (level 0)</em></p>&#13;
<p class="indent">We can use the RGB values for purple in the <span class="literal">setup()</span> function just because we won’t be changing the fill anywhere else. We use <span class="literal">noStroke()</span> so that we won’t see black outlines on the squares. In the <span class="literal">draw()</span> function we call the <span class="literal">squareFractal()</span> function, telling it to make the size of each square 500 pixels and level 0. In the function definition, we tell the program to simply draw a square if the level is zero. This should give us a nice big purple square, as shown in <a href="ch10.xhtml#ch10fig16">Figure 10-16</a>.</p>&#13;
<p class="indent">For the next level, we’ll make squares of half the sidelength of <span epub:type="pagebreak" id="page_217"/>the initial square. One will be positioned at the top left of the figure; then we’ll translate around to put the other two squares at the bottom left and top right of <a href="ch10.xhtml#ch10fig16">Figure 10-16</a>. <a href="ch10.xhtml#ch10list13">Listing 10-13</a> does this while leaving out a quarter of the big square.</p>&#13;
<p class="programs"><span class="pd_g1"><em>squareFractal.pyde</em></span><br/><span class="pd_gray">def squareFractal(sz,level):</span><br/>    <span class="pd_gray">if level == 0:</span><br/>        <span class="pd_gray">rect(0,0,sz,sz)</span><br/>    <span class="pd_lime">else</span>:<br/>        <span class="pd_blue1">rect</span>(0,0,sz/2.0,sz/2.0)<br/>        <span class="pd_blue1">translate</span>(sz/2.0,0)<br/>        <span class="pd_blue1">rect</span>(0,0,sz/2.0,sz/2.0)<br/>        <span class="pd_blue1">translate</span>(-sz/2.0,sz/2.0)<br/>        <span class="pd_blue1">rect</span>(0,0,sz/2.0,sz/2.0)</p>&#13;
<p class="listing" id="ch10list13"><em>Listing 10-13: Adding more squares to the square fractal</em></p>&#13;
<p class="indent">Here, we draw a big square if the level is 0. If the level is not 0, we add a smaller square in the top left of the screen, translate to the right, add another smaller square in the top right, translate left (negative x) and down (positive y), and add a smaller square at the bottom left of the screen.</p>&#13;
<p class="indent">That’s the next level, and when we update <span class="literal">squareFractal(500,0)</span> in the <span class="literal">draw()</span> function to <span class="literal">squareFractal(500,1)</span>, it should give us a square with the bottom-right quarter left out, as shown in <a href="ch10.xhtml#ch10fig17">Figure 10-17</a>.</p>&#13;
<div class="image"><a id="ch10fig17"/><img alt="image" src="../images/f217-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-17: The next level of the square fractal</em></p>&#13;
<p class="indent">For the next levels, we want each of the squares to be further subdivided into fractals, so we’ll replace the <span class="literal">rect</span> lines with <span class="literal">squareFractal()</span>, divide the value in <span class="literal">sz</span> by 2, and tell it to move one level down, like in <a href="ch10.xhtml#ch10list14">Listing 10-14</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>squareFractal.pyde</em></span><br/><span class="pd_green1">def</span> squareFractal(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">rect</span>(0,0,sz,sz)<br/>    <span class="pd_lime">else</span>:<br/>        squareFractal(sz/2.0,level-1)<br/>        <span class="pd_blue1">translate</span>(sz/2.0,0)<br/>        squareFractal(sz/2.0,level-1)<br/><span epub:type="pagebreak" id="page_218"/>&#13;
        <span class="pd_blue1">translate</span>(-sz/2.0,sz/2.0)<br/>        squareFractal(sz/2.0,level-1)</p>&#13;
<p class="listing" id="ch10list14"><em>Listing 10-14: Adding the recursive step to the square fractal</em></p>&#13;
<div class="image"><a id="ch04fig1"/><a id="ch10fig18"/><img alt="image" src="../images/f218-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-18: Not what we were expecting!</em></p>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10list14">Listing 10-14</a>, notice that the <span class="literal">rect</span> lines (when the level isn’t 0) are replaced with <span class="literal">squareFractal()</span>. When we call <span class="literal">squareFractal(500,2)</span> in the <span class="literal">draw()</span> function, we don’t get the output we were expecting—we get <a href="ch10.xhtml#ch10fig18">Figure 10-18</a> instead.</p>&#13;
<p class="indent">This is because we didn’t translate back to the starting point like we did with our Y fractal earlier in the chapter.</p>&#13;
<p class="indent">Although we can calculate how much to translate manually, we can also use the <span class="literal">pushMatrix()</span> and <span class="literal">popMatrix()</span> functions in Processing, which you learned about in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<p class="indent">We can use the <span class="literal">pushMatrix()</span> function to save the current orientation of the screen—that is, where the origin (0,0) is located and how much the grid is rotated. After that, we can do as much translating and rotating as we like and then use the <span class="literal">popMatrix()</span> function to return to the saved orientation without any calculating!</p>&#13;
<p class="indent">Let’s add <span class="literal">pushMatrix()</span> at the beginning of the <span class="literal">squareFractal()</span> function and <span class="literal">popMatrix()</span> at the end, like in <a href="ch10.xhtml#ch10list15">Listing 10-15</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>squareFractal.pyde</em></span><br/><span class="pd_gray">def squareFractal(sz,level):</span><br/><span class="pd_gray">    if level == 0:</span><br/><span class="pd_gray">        rect(0,0,sz,sz)</span><br/><span class="pd_gray">    else:</span><br/>        <span class="pd_blue1">pushMatrix</span>()<br/><span class="pd_gray">        squareFractal(sz/2.0,level-1)</span><br/><span class="pd_gray">        translate(sz/2.0,0)</span><br/><span class="pd_gray">        squareFractal(sz/2.0,level-1)</span><br/><span class="pd_gray">        translate(-sz/2.0,sz/2.0)</span><br/><span class="pd_gray">        squareFractal(sz/2.0,level-1)</span><br/>        <span class="pd_blue1">popMatrix</span>()</p>&#13;
<p class="listing" id="ch10list15"><em>Listing 10-15: Using <span class="literal">pushMatrix()</span> and <span class="literal">popMatrix()</span> to complete the squares</em></p>&#13;
<p class="indent">Now, each of the smaller squares from level 1 should be transformed into a fractal, with the bottom-right square removed, as shown in <a href="ch10.xhtml#ch10fig19">Figure 10-19</a>.</p>&#13;
<span epub:type="pagebreak" id="page_219"/>&#13;
<div class="image"><a id="ch10fig19"/><img alt="image" src="../images/f219-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-19: Level 2 of the square fractal</em></p>&#13;
<p class="indent">Now let’s try making our mouse generate the level numbers like we’ve done before by replacing <span class="literal">squareFractal(500,2)</span> with the code in <a href="ch10.xhtml#ch10list16">Listing 10-16</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>squareFractal.pyde</em></span><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    background(255)</span><br/><span class="pd_gray">    translate(50,50)</span><br/>    level = <span class="pd_blue1">int</span>(<span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,7))<br/>    squareFractal(500,level)</p>&#13;
<p class="listing" id="ch10list16"><em>Listing 10-16: Making the square fractal interactive</em></p>&#13;
<p class="indent">At higher levels, the square fractal looks a lot like the Sierpinski triangle, as you can see in <a href="ch10.xhtml#ch10fig20">Figure 10-20</a>!</p>&#13;
<div class="image"><a id="ch10fig20"/><img alt="image" src="../images/f219-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-20: High-level square fractals look like the Sierpinski triangle!</em></p>&#13;
<span epub:type="pagebreak" id="page_220"/>&#13;
<h3 class="h3" id="ch10_5">DRAGON CURVE</h3>&#13;
<p class="noindent">The final fractal we’ll create looks different from the others we’ve created so far in that the shapes on each level don’t get smaller, they get bigger. <a href="ch10.xhtml#ch10fig21">Figure 10-21</a> shows an example of the dragon curve for levels 0 through 3.</p>&#13;
<div class="image"><a id="ch10fig21"/><img alt="image" src="../images/f220-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-21: The first four levels of the dragon curve</em></p>&#13;
<p class="indent">As mathematical entertainer Vi Hart shows in one of her YouTube videos, the second half of the dragon curve is a perfect copy of the first half, and she models it by folding and then unfolding pieces of paper. The third level (level 2) in <a href="ch10.xhtml#ch10fig21">Figure 10-21</a> looks like two left turns followed by a right turn. The “hinge” or “fold” is at the midpoint of each dragon curve. See if you can find it in your dragon curves! Later, you’ll rotate part of the curve dynamically to match the next-level curve.</p>&#13;
<p class="indent">Open a new Processing sketch and name it <em>dragonCurve.pyde</em>. To create this fractal, we first create a function for the “left dragon,” as in <a href="ch10.xhtml#ch10list17">Listing 10-17</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>dragonCurve.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">strokeWeight</span>(2) <span class="pd_gray">#a little thicker lines</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    leftDragon(5,11)<br/><br/><span class="pd_green1">def</span> leftDragon(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/>    <span class="pd_lime">else</span>:<br/>        leftDragon(sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-90))<br/>        rightDragon(sz,level-1)</p>&#13;
<p class="listing" id="ch10list17"><em>Listing 10-17: Writing the <span class="literal">leftDragon()</span> function</em></p>&#13;
<p class="indent">After the usual <span class="literal">setup()</span> and <span class="literal">draw()</span> functions, we define our <span class="literal">leftDragon()</span> function. If the level is 0, we just draw a line and then translate along the <span epub:type="pagebreak" id="page_221"/>line. It’s kind of like the turtle from <a href="ch01.xhtml#ch01">Chapter 1</a> drawing a line as it walks along. If the level is greater than 0, make a left dragon (one level down), turn left 90 degrees, and make a right dragon (one level down).</p>&#13;
<p class="indent">Now we’ll make the “right dragon” function (see <a href="ch10.xhtml#ch10list18">Listing 10-18</a>). It’s pretty similar to the <span class="literal">leftDragon()</span> function. If the level is 0, simply draw a line and move along it. Otherwise, make a left dragon, and this time turn <em>right</em> 90 degrees and make a right dragon.</p>&#13;
<p class="programs"><span class="pd_g1"><em>dragonCurve.pyde</em></span><br/><span class="pd_green1">def</span> rightDragon(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/><span class="pd_gray">    </span><span class="pd_lime">else</span>:<br/>        leftDragon(sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(90))<br/>        rightDragon(sz,level-1)</p>&#13;
<p class="listing" id="ch10list18"><em>Listing 10-18: Writing the <span class="literal">rightDragon()</span> function</em></p>&#13;
<p class="indent">It’s interesting that the recursive statement in this case is not only inside one function, but it also jumps back and forth from the left dragon function to the right dragon function! Execute it, and the 11th level will look like <a href="ch10.xhtml#ch10fig22">Figure 10-22</a>.</p>&#13;
<div class="image"><a id="ch10fig22"/><img alt="image" src="../images/f221-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-22: A level 11 dragon curve</em></p>&#13;
<p class="indent">Far from being simply a chaotic jumble of angles, this fractal starts to look like a dragon after enough levels! Remember I said the dragon curve is “folded” in the middle? In the version shown in <a href="ch10.xhtml#ch10list19">Listing 10-19</a>, I’ve added a few variables to change the level and the size, and I made an <span class="literal">angle</span> variable change with the mouse’s x-coordinate. This will rotate a dragon curve around a “hinge” in the middle of the next-level dragon curve. See how you can simply rotate the curve to get both halves of the next-level curve!</p>&#13;
<p class="programs"><span class="pd_g1"><em>dragonCurve.pyde</em></span><br/><span class="ent">➊</span> RED = <span class="pd_blue1">color</span>(255,0,0)<br/>  BLACK = <span class="pd_blue1">color</span>(0)<br/><span epub:type="pagebreak" id="page_222"/>&#13;
<br/> <span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>  <span class="ent">➋</span> <span class="pd_green1">global</span> thelevel,size1<br/>    <span class="pd_blue1">size</span>(600,600)<br/>  <span class="ent">➌</span> thelevel = 1<br/>    size1 = 40<br/><br/> <span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> thelevel<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>  <span class="ent">➍</span> angle = <span class="pd_blue1">map</span>(<span class="pd_raspberry">mouseX</span>,0,<span class="pd_raspberry">width</span>,0,2*<span class="pd_olive">PI</span>)<br/>    <span class="pd_blue1">stroke</span>(RED)<br/>    <span class="pd_blue1">strokeWeight</span>(3)<br/>    <span class="pd_blue1">pushMatrix</span>()<br/>    leftDragon(size1,thelevel)<br/>    <span class="pd_blue1">popMatrix</span>()<br/>    leftDragon(size1,thelevel-1)<br/>  <span class="ent">➎</span> <span class="pd_blue1">rotate</span>(angle)<br/>    <span class="pd_blue1">stroke</span>(BLACK)<br/>    rightDragon(size1,thelevel-1)<br/><br/> <span class="pd_green1">def</span> leftDragon(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/>    <span class="pd_lime">else</span>:<br/>        leftDragon(sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(-90))<br/>        rightDragon(sz,level-1)<br/><br/> <span class="pd_green1">def</span> rightDragon(sz,level):<br/>    <span class="pd_lime">if</span> level == 0:<br/>        <span class="pd_blue1">line</span>(0,0,sz,0)<br/>        <span class="pd_blue1">translate</span>(sz,0)<br/>    <span class="pd_lime">else</span>:<br/>        leftDragon(sz,level-1)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(90))<br/>        rightDragon(sz,level-1)<br/><br/> <span class="pd_green1">def</span> <span class="pd_raspberry">keyPressed</span>():<br/>    <span class="pd_green1">global</span> thelevel,size1<br/>  <span class="ent">➏</span> <span class="pd_lime">if</span> <span class="pd_raspberry">key</span> == <span class="pd_olive">CODED</span>:<br/>        <span class="pd_lime">if</span> <span class="pd_raspberry">keyCode</span> == <span class="pd_olive">UP</span>:<br/>            thelevel += 1<br/>        <span class="pd_lime">if</span> <span class="pd_raspberry">keyCode</span> == <span class="pd_olive">DOWN</span>:<br/>            thelevel -= 1<br/>        <span class="pd_lime">if</span> <span class="pd_raspberry">keyCode</span> == <span class="pd_olive">LEFT</span>:<br/>            size1 -= 5<br/>        <span class="pd_lime">if</span> <span class="pd_raspberry">keyCode</span> == <span class="pd_olive">RIGHT</span>:<br/>            size1 += 5</p>&#13;
<p class="listing" id="ch10list19"><em>Listing 10-19: A dynamic dragon curve</em></p>&#13;
<span epub:type="pagebreak" id="page_223"/>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10list19">Listing 10-19</a>, we add a couple of colors <span class="ent">➊</span> to use for the curves. In the <span class="literal">setup()</span> function, we declare two global variables, <span class="literal">thelevel</span> and <span class="literal">size1</span> <span class="ent">➋</span>, whose initial values we declare at <span class="ent">➌</span> and which we change with the arrow keys in the <span class="literal">keyPressed()</span> function at the end of the file.</p>&#13;
<p class="indent">In the <span class="literal">draw()</span> function, we link an <span class="literal">angle</span> variable <span class="ent">➍</span> to the x-position of the mouse. After that, we set the stroke color to red, make the stroke weight a little heavier, and draw a left dragon with the initial values of <span class="literal">thelevel</span> and <span class="literal">size1</span>. The <span class="literal">pushMatrix()</span> and <span class="literal">popMatrix()</span> functions, as you’ll remember, simply return the drawing point to the original spot, to draw another curve. Then we rotate the grid by however many radians the angle variable is <span class="ent">➎</span>, and draw another dragon curve, in black. The <span class="literal">leftDragon()</span> and <span class="literal">rightDragon()</span> functions are exactly the same as before.</p>&#13;
<p class="indent">Processing’s built-in <span class="literal">keyPressed()</span> function could come in handy for changing variables in a sketch! All you have to do is declare the global variables you want to change with the left (in this case), right, up, and down arrow keys on the keyboard. Note that <span class="literal">CODED</span> <span class="ent">➏</span> just means it’s not a letter or character key. Finally, it checks which arrow key is being pressed and makes the level variable go up or down (if the up or down arrow key is being pressed) or the size variable go up or down (if the left or right arrow key is being pressed).</p>&#13;
<p class="indent">When you run this version of the <em>dragonCurve</em> sketch, it draws a dragon curve at level 5 in red; then you can rotate a level 4 curve and see how the level 5 curve is made up of two level 4’s, just rotated in the middle, as shown in <a href="ch10.xhtml#ch10fig23">Figure 10-23</a>.</p>&#13;
<div class="image"><a id="ch10fig23"/><img alt="image" src="../images/f223-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 10-23: A level 5 dragon curve and a dynamic, interactive level 4 curve</em></p>&#13;
<p class="indent">When you move the mouse, the black dragon curve should rotate, and you can see how it fits both halves of the red curve. The up and down arrow keys control the level of the curve; press the up arrow key and the curve gets longer. If the curve extends off the display window, use the left arrow key to make each segment shorter, so it’ll fit on the screen. The right arrow key makes it bigger.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/>This makes sense, because the <span class="literal">leftDragon()</span> function comes first, turns left, and makes a right dragon curve. The <span class="literal">rightDragon()</span> function just turns the opposite way from <span class="literal">leftDragon()</span>: it makes a right turn in the middle instead of a left. No wonder it turns out to be a perfect copy.</p>&#13;
<h3 class="h3" id="ch10_6">SUMMARY</h3>&#13;
<p class="noindent">We’ve only scratched the surface of fractals, but hopefully you got a taste of how beautiful fractals can be and how powerful they are at modeling the messiness of nature. Fractals and recursion can help us reevaluate our ideas about logic and measurement. The question is no longer “how long is the coastline?” but rather “how jagged is it?”</p>&#13;
<p class="indent">For fractal lines like coastlines and meandering rivers, the standard characteristic is the scale of self-similarity, or how much we have to scale the map up by before it looks like a different scale of the same thing. This is effectively what you did by feeding <span class="literal">0.8*sz</span>, <span class="literal">sz/2.0</span>, or <span class="literal">sz/3.0</span> into the next level.</p>&#13;
<p class="indent">In the next chapter, we’ll create cellular automata (CAs), which we’ll draw as little squares on the screen that are born, grow, and respond to their surroundings. Just like with our grass-eating sheep in <a href="ch09.xhtml#ch09">Chapter 9</a>, we’ll create CAs and let them run—and just like with fractals, we’ll watch the surprising and beautiful patterns that are created from very simple rules.</p>&#13;
</body></html>