["```py\ntarget = \"I never go back on my word, because that is my Ninja way.\"\n```", "```py\ncharacters = \" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!\"\n```", "```py\n*genetic\nQuote.py*\nimport random\n\ntarget = \"I never go back on my word, because that is my Ninja way.\"\ncharacters = \" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!\"\n\ndef makeList():\n    '''Returns a list of characters the same length\n    as the target'''\n    charList = [] #empty list to fill with random characters\n    for i in range(len(target)):\n        charList.append(random.choice(characters))\n    return charList\n```", "```py\n>>> len(target)\n57\n>>> newList = makeList()\n>>> newList\n['p', 'H', 'Z', '!', 'R', 'i', 'e', 'j', 'c', 'F', 'a', 'u', 'F', 'y', '.',\n'w', 'u', '.', 'H', 'W', 'w', 'P', 'Z', 'D', 'D', 'E', 'H', 'N', 'f', ' ',\n'W', 'S', 'A', 'B', ',', 'w', '?', 'K', 'b', 'N', 'f', 'k', 'g', 'Q', 'T',\n'n', 'Q', 'H', 'o', 'r', 'G', 'h', 'w', 'l', 'l', 'W', 'd']\n>>> len(newList)\n57\n```", "```py\n>>> a = \"Hello\"\n>>> a[0] = \"J\"\nTraceback (most recent call last):\n  File \"<pyshell#16>\", line 1, in <module>\n    a[0] = \"J\"\nTypeError: 'str' object does not support item assignment\n>>> b = [\"H\",\"e\",\"l\",\"l\",\"o\"]\n>>> b[0] = \"J\"\n>>> b\n['J', 'e', 'l', 'l', 'o']\n```", "```py\n>>> print(''.join(newList))\npHZ!RiejcFauFy.wu.HWwPZDDEHNf WSAB,w?KbNfkgQTnQHorGhwllWd\n```", "```py\n*genetic\nQuote.py*\ndef score(mylist):\n    '''Returns one integer: the number of matches with target'''\n    matches = 0\n    for i in range(len(target)):\n        if mylist[i] == target[i]:\n            matches += 1\n    return matches\n```", "```py\n>>> newList = makeList()\n>>> score(newList)\n0\n```", "```py\n*genetic\nQuote.py*\ndef mutate(mylist):\n    '''Returns mylist with one letter changed'''\n    newlist = list(mylist)\n new_letter = random.choice(characters)\n    index = random.randint(0,len(target)-1)\n    newlist[index] = new_letter\n    return newlist\n```", "```py\n*genetic\nQuote.py*\nrandom.seed()\nbestList = makeList()\nbestScore = score(bestList)\n```", "```py\nguesses = 0\n```", "```py\nwhile True:\n    guess = mutate(bestList)\n    guessScore = score(guess)\n    guesses += 1\n```", "```py\n    if guessScore <= bestScore:\n        continue\n```", "```py\n    print(''.join(guess),guessScore,guesses)\n    if guessScore == len(target):\n        break\n```", "```py\n    bestList = list(guess)\n    bestScore = guessScore\n```", "```py\n*genetic Quote.py*\nimport random\n\ntarget = \"I never go back on my word, because that is my Ninja way.\"\ncharacters = \" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!\"\n\n#function to create a \"guess\" list of characters the same length as target\ndef makeList():\n    '''Returns a list of characters the same length\n    as the target'''\n    charList = [] #empty list to fill with random characters\n    for i in range(len(target)):\n        charList.append(random.choice(characters))\n    return charList\n\n#function to \"score\" the guess list by comparing it to target\ndef score(mylist):\n    '''Returns one integer: the number of matches with target'''\n    matches = 0\n    for i in range(len(target)):\n        if mylist[i] == target[i]:\n            matches += 1\n    return matches\n\n#function to \"mutate\" a list by randomly changing one letter\ndef mutate(mylist):\n    '''Returns mylist with one letter changed'''\n    newlist = list(mylist)\n    new_letter = random.choice(characters)\n    index = random.randint(0,len(target)-1)\n    newlist[index] = new_letter\n    return newlist\n\n#create a list, set the list to be the bestList\n#set the score of bestList to be the bestScore\n random.seed()\nbestList = makeList()\nbestScore = score(bestList)\n\nguesses = 0\n\n#make an infinite loop that will create a mutation\n#of the bestList, score it\nwhile True:\n    guess = mutate(bestList)\n    guessScore = score(guess)\n    guesses += 1\n\n#if the score of the newList is lower than the bestList,\n#\"continue\" on to the next iteration of the loop\n    if guessScore <= bestScore:\n        continue\n\n#if the score of the newlist is the optimal score,\n#print the list and break out of the loop\n    print(''.join(guess),guessScore,guesses)\n    if guessScore == len(target):\n        break\n\n#otherwise, set the bestList to the value of the newList\n#and the bestScore to be the value of the score of the newList\n    bestList = list(guess)\n    bestScore = guessScore\n```", "```py\ni.fpzgPG.'kHT!NW WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 1 178\ni.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 2 237\ni.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 3 266\ni fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 4 324\n--snip--\nI nevgP go back on my word, because that is my Ninja way. 55 8936\nI neveP go back on my word, because that is my Ninja way. 56 10019\nI never go back on my word, because that is my Ninja way. 57 16028\n```", "```py\n*travelingSales person.pyde*\nclass City:\n    def __init__(self,x,y,num):\n        self.x = x\n        self.y = y\n        self.number = num #identifying number\n\n    def display(self):\n        fill(0,255,255) #sky blue\n        ellipse(self.x,self.y,10,10)\n        noFill()\n```", "```py\ndef setup():\n    size(600,600)\n    background(0)\n    city0 = City(100,200,0)\n    city0.display()\n```", "```py\n        textSize(20)\n        text(self.number,self.x-10,self.y-10)\n```", "```py\nimport random\n```", "```py\n*travelingSalesperson.pyde*\ncities = []\n\ndef setup():\n    size(600,600)\n    background(0)\n    for i in range(6):\n        cities.append(City(random.randint(50,width-50),\n                           random.randint(50,height-50),i))\n\n    for city in cities:\n        city.display()\n```", "```py\nN_CITIES = 10\n```", "```py\nclass Route:\n    def __init__(self):\n        self.distance = 0\n        #put cities in a list in order:\n        self.cityNums = random.sample(list(range(N_CITIES)),N_CITIES)\n```", "```py\n>>> n = list(range(10))\n>>> n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> import random\n>>> x = random.sample(n,5)\n>>> x\n[2, 0, 5, 3, 8]\n```", "```py\n    def display(self):\n        strokeWeight(3)\n        stroke(255,0,255) #purple\n        beginShape()\n        for i in self.cityNums:\n            vertex(cities[i].x,cities[i].y)\n            #then display the cities and their numbers\n cities[i].display()\n        endShape(CLOSE)\n```", "```py\ndef setup():\n    size(600,600)\n    background(0)\n    for i in range(N_CITIES):\n        cities.append(City(random.randint(50,width-50),\n                           random.randint(50,height-50),i))\n    route1 = Route()\n    route1.display()\n```", "```py\n    def calcLength(self):\n        self.distance = 0\n        for i,num in enumerate(self.cityNums):\n        # find the distance from the current city to the previous city\n            self.distance += dist(cities[num].x,\n                                cities[num].y,\n                                cities[self.cityNums[i-1]].x,\n                                cities[self.cityNums[i-1]].y)\n        return self.distance\n```", "```py\n    println(route1.calcLength())\n```", "```py\nN_CITIES = 4\n```", "```py\ncities = [City(100,100,0), City(300,100,1),\n                  City(300,300,2), City(100,300,3)]\n\ndef setup():\n    size(600,600)\n    background(0)\n    '''for i in range(N_CITIES):\n        cities.append(City(random.randint(0,width),\n                           random.randint(0,height),i))'''\n    route1 = Route()\n    route1.cityNums = [0,1,2,3]\n    route1.display()\n    println(route1.calcLength())\n```", "```py\n*travelingSales person.pyde*\nimport random\n\nN_CITIES = 10\n\nclass City:\n    def __init__(self,x,y,num):\n        self.x = x\n        self.y = y\n        self.number = num #identifying number\n\n    def display(self):\n        fill(0,255,255) #sky blue\n ellipse(self.x,self.y,10,10)\n        textSize(20)\n        text(self.number,self.x-10,self.y-10)\n        noFill()\n\nclass Route:\n    def __init__(self):\n        self.distance = 0\n        #put cities in a list in numList order:\n        self.cityNums = random.sample(list(range(N_CITIES)),N_CITIES)\n\n    def display(self):\n        strokeWeight(3)\n        stroke(255,0,255) #purple\n        beginShape()\n        for i in self.cityNums:\n            vertex(cities[i].x,cities[i].y)\n            #then display the cities and their numbers\n            cities[i].display()\n        endShape(CLOSE)\n\n    def calcLength(self):\n        self.distance = 0\n        for i,num in enumerate(self.cityNums):\n        # find the distance to the previous city\n            self.distance += dist(cities[num].x,\n                                cities[num].y,\n                                cities[self.cityNums[i-1]].x,\n                                cities[self.cityNums[i-1]].y)\n        return self.distance\n\ncities = []\n\ndef setup():\n    size(600,600)\n    for i in range(N_CITIES):\n        cities.append(City(random.randint(50,width-50),\n                           random.randint(50,height-50),i))\n\ndef draw():\n    background(0)\n    route1 = Route()\n    route1.display()\n    println(route1.calcLength())\n```", "```py\ncities = []\nrandom_improvements = 0\nmutated_improvements = 0\n\ndef setup():\n    global best, record_distance\n    size(600,600)\n    for i in range(N_CITIES):\n        cities.append(City(random.randint(50,width-50),\n                           random.randint(50,height-50),i))\n    best = Route()\n    record_distance = best.calcLength()\n\ndef draw():\n    global best, record_distance, random_improvements\n    background(0)\n    best.display()\n    println(record_distance)\n    println(\"random: \"+str(random_improvements))\n    route1 = Route()\n    length1 = route1.calcLength()\n    if length1 < record_distance:\n        record_distance = length1\n        best = route1\n\n        random_improvements += 1\n```", "```py\n>>> x = 2\n>>> y = 3\n>>> x = y\n>>> y = x\n>>> x\n3\n>>> y\n3\n```", "```py\n>>> x = 2\n>>> y = 3\n>>> x,y = y,x\n>>> x\n3\n>>> y\n2\n```", "```py\ndef mutateN(self,num):\n    indices = random.sample(list(range(N_CITIES)),num)\n    child = Route()\n    child.cityNums = self.cityNums[::]\n    for i in range(num-1):\n        child.cityNums[indices[i]],child.cityNums[indices[(i+1)%num]] = \\\n        child.cityNums[indices[(i+1)%num]],child.cityNums[indices[i]]\n    return child\n```", "```py\ndef draw():\n    global best,record_distance,random_improvements\n    global mutated_improvements\n    background(0)\n best.display()\n    println(record_distance)\n    println(\"random: \"+str(random_improvements))\n    println(\"mutated: \"+str(mutated_improvements))\n    route1 = Route()\n    length1 = route1.calcLength()\n    if length1 < record_distance:\n        record_distance = length1\n        best = route1\n        random_improvements += 1\n    for i in range(2,6):\n        #create a new Route\n        mutated = Route()\n        #set its number list to the best one\n        mutated.cityNums = best.cityNums[::]\n        mutated = mutated.mutateN(i) #mutate it\n        length2 = mutated.calcLength()\n        if length2 < record_distance:\n            record_distance = length2\n            best = mutated\n            mutated_improvements += 1\n```", "```py\nfor i in range(2,11):\n```", "```py\ncities = []\nrandom_improvements = 0\nmutated_improvements = 0\npopulation = []\nPOP_N = 1000 #number of routes\n```", "```py\ndef setup():\n    global best,record_distance,first,population\n    size(600,600)\n    for i in range(N_CITIES):\n        cities.append(City(random.randint(50,width-50),\n                           random.randint(50,height-50),i))\n    #put organisms in population list\n    for i in range(POP_N):\n        population.append(Route())\n    best = random.choice(population)\n    record_distance = best.calcLength()\n    first = record_distance\n```", "```py\na: [6, 0, 7, 8, 2, 1, 3, 9, 4, 5]\nb: [1, 0, 4, 9, 6, 2, 5, 8, 7, 3]\nindex: 3\nc: [6, 0, 7, 1, 4, 9, 2, 5, 8, 3]\n```", "```py\n    def crossover(self,partner):\n        '''Splice together genes with partner's genes'''\n        child = Route()\n        #randomly choose slice point\n        index = random.randint(1,N_CITIES - 2)\n        #add numbers up to slice point\n        child.cityNums = self.cityNums[:index]\n        #half the time reverse them\n        if random.random()<0.5:\n            child.cityNums = child.cityNums[::-1]\n        #list of numbers not in the slice\n        notinslice = [x for x in partner.cityNums if x not in child.cityNums]\n        #add the numbers not in the slice\n        child.cityNums += notinslice\n        return child\n```", "```py\ndef draw():\n    global best,record_distance,population\n    background(0)\n    best.display()\n    println(record_distance)\n    #println(best.cityNums) #If you need the exact Route through the cities!\n ➊ population.sort(key=Route.calcLength)\n    population = population[:POP_N] #limit size of population\n    length1 = population[0].calcLength()\n    if length1 < record_distance:\n        record_distance = length1\n        best = population[0]\n\n    #do crossover on population\n ➋ for i in range(POP_N):\n        parentA,parentB = random.sample(population,2)\n        #reproduce:\n        child = parentA.crossover(parentB)\n        population.append(child)\n\n    #mutateN the best in the population\n ➌ for i in range(3,25):\n        if i < N_CITIES:\n            new = best.mutateN(i)\n            population.append(new)\n #mutateN random Routes in the population\n ➍ for i in range(3,25):\n        if i < N_CITIES:\n            new = random.choice(population)\n            new = new.mutateN(i)\n            population.append(new)\n```"]