- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Skip Lists
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter introduces the *skip list*, a sorted linked list with multiple
    pointers that allow us to occasionally jump forward to an element further ahead
    in the list during operations like search, insertion, or deletion. This potential
    to jump mitigates one of the major concerns with linked lists—that we have to
    scan through all the elements to find a single target. Skipping some elements
    saves precious time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*跳表*，一种带有多个指针的排序链表，它允许我们在进行搜索、插入或删除等操作时，偶尔跳跃到链表中更远的元素。这种跳跃的可能性缓解了链表的一大主要问题——我们必须扫描所有元素才能找到一个目标。跳过一些元素节省了宝贵的时间。
- en: To envision how skip lists work, consider the strategy I employ every time I
    lose my place in a book. Determined to avoid spoilers, I do not use binary search,
    which may jump to parts of the text I haven’t read yet. Instead, I start at the
    beginning of the book and skip forward multiple pages at a time—in sections large
    enough that I’m not scanning every page, but small enough that, if I overshoot,
    it won’t ruin the story. I use larger jumps in the beginning of my search but
    shift to smaller and smaller jumps as I near where I left off. Skip lists use
    a similar approach to dramatically change the behavior of the linked list, enabling
    it to take on problems that we’d previously reserved for tree-based data structures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解跳表是如何工作的，可以考虑我每次在看书时丢失位置的策略。为了避免剧透，我不使用二分查找，因为它可能会跳到我还没读过的部分。相反，我从书的开头开始，每次跳过多页——跳得足够大，以免扫描每一页，但又足够小，避免跳得太远破坏了故事情节。我在搜索的开始使用较大的跳跃，但随着接近我停下的位置，我会逐渐改用更小的跳跃。跳表采用了类似的方式，显著改变了链表的行为，使其能够解决之前我们只会交给基于树的数据结构的问题。
- en: Skip lists, proposed by computer scientist William Pugh, are probabilistic data
    structures that make operations such as insertion, deletion, and searching significantly
    more efficient in the *average* case. Instead of storing a single linked list,
    skip lists effectively create a layer of linked lists, each with only a subset
    of the nodes at the layer below. This means we start our search at higher levels
    of the skip list, where there are fewer nodes, and take large steps across the
    list to *skip* unnecessary nodes. As we get closer to our target and refine our
    search, we drop down in the multilevel hierarchy. In the case of searching for
    our place in a book, this corresponds to using smaller and smaller jumps as we
    near our most recent location.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表由计算机科学家威廉·普赫（William Pugh）提出，是一种概率性数据结构，可以显著提高插入、删除和搜索等操作在*平均*情况下的效率。跳表并不是存储一个单一的链表，而是有效地创建了一层层链表，每层只包含下层链表中的部分节点。这意味着我们从跳表的较高层开始搜索，在这些层中节点较少，并且可以大步跳过不必要的节点。随着我们逐渐接近目标并精细化搜索，我们会在多级层次结构中向下移动。在搜索书籍中的位置时，这就相当于在接近我们最近的位置时，逐渐使用越来越小的跳跃。
- en: 'I’ve included skip lists in this book for two reasons. First, in keeping with
    almost every other data structure presented here, they demonstrate how additional
    information or structure can provide significant algorithmic advantages. In this
    case, multiple levels of links decrease the cost of a search. Second, and perhaps
    more exciting, skip lists are randomized data structures. Unlike Bloom filters,
    which are deterministic given the data, skip lists push the use of randomness
    a step further: their very structure is probabilistically determined in order
    to balance out performance in the average case. We use a random number generator
    to choose the level of each node and thus how far ahead it will let us skip.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中加入跳表有两个原因。首先，和本书介绍的几乎所有其他数据结构一样，跳表展示了额外的信息或结构如何提供显著的算法优势。在这种情况下，多层链接降低了搜索的成本。第二，也是可能更令人兴奋的，跳表是随机化数据结构。与布隆过滤器（Bloom
    filters）不同，后者在数据给定的情况下是确定性的，跳表将随机性的使用更进一步：它们的结构本身是通过概率性的方法来决定的，以平衡平均情况下的性能。我们使用随机数生成器来选择每个节点的层级，从而决定它能够跳过多少远的元素。
- en: Randomized vs. Deterministic Structures
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机化结构与确定性结构
- en: The change from a deterministically generated data structure to a randomized
    one introduces both complexities and benefits. The structure of every data structure
    we have examined so far is fully determined by the data we insert. For example,
    if we insert the same data in the same order into a binary search tree, we always
    get the same structure. The same applies for heaps, tries, grids, quadtrees, and
    so forth. Even two hash tables or Bloom filters will be identical if we use the
    same hash functions and insert the same set of items.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个确定性生成的数据结构转变为一个随机化的数据结构引入了复杂性和益处。到目前为止，我们所研究的每个数据结构的结构都完全由我们插入的数据决定。例如，如果我们将相同的数据按相同的顺序插入二叉搜索树，我们总是会得到相同的结构。堆、前缀树、网格、四叉树等结构也一样。即使是两个哈希表或布隆过滤器，如果我们使用相同的哈希函数并插入相同的数据集，它们也将是相同的。
- en: This determinism can lead to problems in the face of worst-case data. As we
    saw in Chapter 5, if we start with an empty binary search tree and insert elements
    in sorted order, our tree effectively becomes a sorted linked list. Each node
    will have a single child node in the same direction. One potential way to mitigate
    this problem is to insert the data in random order. While we still might happen
    to choose a bad ordering, the probability is significantly lower.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种确定性可能会在最坏情况的数据面前引发问题。正如我们在第5章中看到的，如果我们从一个空的二叉搜索树开始，并按排序顺序插入元素，那么我们的树实际上会变成一个排序链表。每个节点将只拥有一个子节点，且方向相同。缓解这个问题的一种潜在方法是按随机顺序插入数据。虽然我们仍然可能选择一个不理想的顺序，但这种情况的概率显著降低。
- en: We can extend this randomized approach to constructing the data structures themselves
    by randomly choosing parameters during each insertion. Instead of varying the
    order of the data, we are varying how we link that data into our structure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种随机化方法扩展到构建数据结构本身，在每次插入时随机选择参数。我们不再变化数据的顺序，而是变化如何将数据链接到我们的结构中。
- en: At first, the randomized approach can seem unintuitive. If we don’t know our
    input distribution, we may easily end up making bad structural choices for that
    distribution. We might worry that we will always choose the worst-case parameter.
    However, if we use a good randomization strategy, this level of failure will be
    exceedingly rare. On the other hand, the randomized design prevents us from making
    consistently suboptimal choices. While it might not lead to an optimal solution,
    it will often produce a reasonable one. The randomness can provide good average
    case performance. The randomness also helps smooth out cases where the data arrives
    in a pathologically bad ordering.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，随机化方法可能显得不直观。如果我们不了解输入的分布，我们可能会轻易地为该分布做出糟糕的结构选择。我们可能担心总是会选择最坏的参数。然而，如果我们使用一个好的随机化策略，这种失败的可能性将极为罕见。另一方面，随机化设计可以防止我们做出持续的不优选择。虽然它可能不会导致最优解，但它通常会产生一个合理的解。随机性可以提供良好的平均情况表现，也有助于平滑数据以病态方式到达的情况。
- en: Introducing Skip Lists
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入跳表
- en: As we saw in Chapter 3, certain operations on linked lists are inherently limited
    by the list’s structure. We can’t efficiently search a linked list because we
    can’t randomly access elements. This has tragic consequences; even when we know
    the nodes are sorted, we can’t use binary search. We’re forced to crawl along
    the pointers from one node to another until we reach the target node. This frustrating
    limitation has caused many new computer scientists to tear out their hair, muttering
    unkind things.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第3章中看到的，链表上的某些操作本质上受到链表结构的限制。我们不能高效地搜索链表，因为我们不能随机访问元素。这会产生悲惨的后果；即使我们知道节点是有序的，我们也不能使用二分查找。我们被迫沿着指针从一个节点爬行到另一个节点，直到找到目标节点。这一令人沮丧的限制让许多新计算机科学家抓狂，嘀咕着不太友善的话。
- en: 'Skip lists help alleviate this inefficiency by providing the ability to jump
    ahead multiple entries. At its heart, a skip list is simply a sorted linked list
    with multi-height nodes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表通过提供一次跳跃多个条目的能力来缓解这种低效。跳表的核心就是一个带有多层节点的排序链表：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The field `top_level` represents the highest level currently in use, while the
    field `max_level` represents the highest allowable level. For simplicity, we specify
    `max_level` independently so we can preallocate an array of pointers at the start
    of our list.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 字段`top_level`表示当前使用的最高级别，而字段`max_level`表示允许的最高级别。为了简化，我们独立指定`max_level`，这样我们可以在列表开始时预分配一个指针数组。
- en: Skip lists’ complexity, and thus their power, arises from the pointer structure
    within the nodes. Instead of storing a single pointer to the next node in the
    list, each node has a predefined level, or *height*, in which it stores pointers
    to the next node. Nodes of level *L* maintain *L* + 1 different forward pointers,
    one for each level [0, *L*]. Critically, the pointer at level *L* links the current
    node to the next node *at the same height*, meaning that the pointers in `next`
    will often point to different skip list nodes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃列表的复杂性，也因此是其强大的地方，源于节点内部的指针结构。每个节点不仅存储指向列表中下一个节点的单个指针，还具有预定义的层级或*高度*，在该层级中，它存储指向下一个节点的多个指针。层级为
    *L* 的节点维护 *L* + 1 个不同的前向指针，每个指针对应一个层级 [0, *L*]。关键的是，层级 *L* 处的指针将当前节点链接到同一高度的下一个节点，这意味着
    `next` 中的指针通常会指向不同的跳跃列表节点。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the higher levels of a skip list contain fewer nodes than the layers below
    them, nodes at these higher levels can link further than would have been possible
    at the lower layers. This allows algorithms to take larger steps at the higher
    layers and skip many intervening nodes. As the levels progress higher and higher,
    the number of nodes decreases, and these linkings jump further and further ahead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跳跃列表的高层包含的节点比低层少，这些高层的节点可以链接得比低层更远。这使得算法可以在较高的层级上跨越更多的节点，从而跳过许多中间节点。随着层级的逐步提高，节点的数量减少，这些链接也跳得越来越远。
- en: Imagine the process of searching a skip list in terms of passing messages between
    buildings by signaling with flashlights. How far you can pass a message depends
    on what floor you are on and the heights of the buildings in your path. If you
    are stuck on the first floor, you can only pass messages to the adjacent building.
    Any building beyond that is blocked by the adjacent building itself. However,
    if you are lucky enough to be in a tall building, you can pass messages over the
    heads of closer, but shorter, buildings, as shown in [Figure 14-1](#figure14-1).
    Alternatively, if you need to send a message to your immediate neighbor, you can
    simply move down to the lowest floor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在跳跃列表中搜索的过程就像通过手电筒在建筑物之间传递消息一样。你能传递消息的距离取决于你所在的楼层以及路径中建筑物的高度。如果你被困在一楼，你只能将消息传递到邻近的建筑物。更远的建筑物会被邻近的建筑物本身阻挡。然而，如果你幸运地处在一座高楼里，你可以越过更近但较矮的建筑物传递消息，正如[图
    14-1](#figure14-1)所示。或者，如果你需要将消息发送给紧邻的邻居，你可以简单地移到最低楼层。
- en: '![Five buildings of different heights. Building 2 is the highest, and building
    5 is next highest. An arrow shows that someone in the second building can pass
    messages to the last building from a floor above the tops of the two buildings
    in between.](image_fi/502604c14/f14001.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![五座不同高度的建筑。建筑物 2 是最高的，建筑物 5 紧随其后。箭头显示，第二座建筑中的人可以通过位于两座建筑之间上方楼层的方式，将消息传递到最后一座建筑。](image_fi/502604c14/f14001.png)'
- en: 'Figure 14-1: Moving between nodes in a skip list is like passing messages by
    flashlight between buildings in a city.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：在跳跃列表中节点之间的移动就像是在城市的建筑物之间通过手电筒传递消息一样。
- en: Skip lists create these linkings probabilistically. The program gives each node
    a random height, independent of the key stored in the node, and inserts the new
    node into its corresponding list for each level. Thus, a node with height 0 will
    only appear in the bottommost list, while a node with height 2 will appear in
    the lists for levels 0, 1, and 2\. [Figure 14-2](#figure14-2) shows an example
    of this. In the message-passing example above, this would be equivalent to a building
    with only a single floor compared to a building with three floors. The building
    with three floors is able to pass messages at three different heights, potentially
    accessing up to three neighbors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃列表通过概率性地创建这些链接。程序为每个节点分配一个随机高度，这与节点中存储的键无关，并将新节点插入到每个层级的对应列表中。因此，具有高度 0 的节点只会出现在最底层的列表中，而高度为
    2 的节点将出现在层级 0、1 和 2 的列表中。[图 14-2](#figure14-2)展示了这一点。在上述的消息传递示例中，这相当于一座只有一层的建筑与一座有三层的建筑。那座有三层的建筑能够在三个不同的高度上传递消息，可能访问最多三个邻居。
- en: '![The skip list contains the keys 0, 1, 8, 9, 12, and 17\. Each node has a
    height between 0 and 2\. The node for 1 has pointers to the node 8 at height 0,
    node 12 at height 1, and node 17 at height 2.](image_fi/502604c14/f14002.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![跳跃列表包含键值 0、1、8、9、12 和 17。每个节点的高度在 0 到 2 之间。键值 1 的节点在高度 0 上指向键值 8 的节点，在高度
    1 上指向键值 12 的节点，在高度 2 上指向键值 17 的节点。](image_fi/502604c14/f14002.png)'
- en: 'Figure 14-2: An example skip list'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：一个跳跃列表的示例
- en: Since higher nodes provide the ability to skip further ahead, over the tops
    of the lower nodes, we ideally want to use them sparsely and sprinkle them throughout
    the list. In the message-passing example, we do not want our cityscape to include
    only buildings of the same height. We want a lot of single-story buildings with
    some medium buildings and a few taller buildings that allow us to jump our messages
    down the street. By choosing heights with the correct probability distribution,
    we can, on average, balance out the density at each level. Nodes of level *L*
    + 1 are less numerous than nodes at level *L*. This leads to good average case
    performance and can help avoid the worst-case scenarios that can occur in other
    data structures.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于较高层的节点提供了跳过更远的能力，越过较低层的节点，我们理想的做法是稀疏使用这些节点，并将它们分布在整个列表中。在消息传递的例子中，我们不希望我们的城市景观只包括相同高度的建筑。我们希望有很多单层建筑，配合一些中层建筑和几座较高的建筑，允许我们将消息跳过街道。通过选择具有正确概率分布的高度，我们可以在平均情况下平衡每一层的密度。*L*
    + 1层的节点数量少于*L*层的节点数量。这有助于实现良好的平均性能，并且可以避免其他数据结构中可能出现的最坏情况。
- en: As shown in [Figure 14-2](#figure14-2), this skip list implementation uses a
    dummy node `front` to store the pointers at the front of each level. The node
    `front` is a `SkipListNode` but contains no key or value. Tracking the front of
    the list in a `SkipListNode` makes the code for insertion and deletion significantly
    simpler, as we’ll see later in the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 14-2](#figure14-2)所示，这个跳表实现使用了一个虚拟节点`front`来存储每一层前面的指针。节点`front`是一个`SkipListNode`，但不包含键或值。将跳表的前端跟踪到一个`SkipListNode`中，使得插入和删除的代码大大简化，正如我们在本章稍后的内容中将看到的那样。
- en: Searching Skip Lists
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳表搜索
- en: To search a skip list, we start at the front of the top-most level and iterate
    through the list nodes. Speaking more informally based on the illustration in
    [Figure 14-2](#figure14-2), we start at the top left corner and proceed downward
    and to the right. At each iteration, we check whether there is another node along
    this level and, if so, whether its key is less than our target. If both those
    conditions are met, we move along to the next node at that level. If either of
    these conditions is false (we have hit the end of the level or found a node whose
    key is larger than or equal to our target), we drop down a level and continue
    our search from there. Our search terminates when we try to drop below the bottom
    level.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索一个跳表，我们从最上层的前端开始，遍历列表中的节点。根据[图 14-2](#figure14-2)中的插图，通俗地说，我们从左上角开始，然后向下并向右移动。在每次迭代时，我们检查当前层是否有另一个节点，如果有，检查该节点的键是否小于目标。如果这两个条件都满足，我们就继续移动到当前层的下一个节点。如果任一条件不成立（我们到达了该层的末尾，或者找到了一个键大于或等于目标的节点），我们就下降到下一层并从那里继续搜索。当我们尝试下降到最低层以下时，搜索终止。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code for a skip list search starts with the `current` node at the front
    of the topmost list ❶. Two nested `WHILE` loops handle the traversal. The inner
    loop iterates through the current linked list until it hits the end of the list
    (`current.next[level] == null`) or a node with a key larger than or equal to target
    (`current.next[level].key >= target`). The outer loop drops down a single level
    each iteration until we hit the bottom of the list ❷. If the target is in the
    list, it will be at the next node in the list ❸. However, we must check that that
    node both exists and has the correct key ❹. When the search loop terminates, we
    are guaranteed to be at the last node in the list with a key *less* than the target.
    The target is either the next node in the list or does not exist.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表搜索的代码从顶层列表的`current`节点开始 ❶。两个嵌套的`WHILE`循环负责遍历。内循环遍历当前的链表，直到遇到链表的末尾（`current.next[level]
    == null`）或者一个键大于或等于目标的节点（`current.next[level].key >= target`）。外循环每次迭代时下降一级，直到到达列表的底部
    ❷。如果目标存在于列表中，它将出现在列表中的下一个节点 ❸。但是，我们必须检查该节点是否存在并且具有正确的键 ❹。当搜索循环结束时，我们可以确保停留在列表中键值*小于*目标的最后一个节点。目标要么是列表中的下一个节点，要么不存在。
- en: Consider searching for a target of 14 in the list shown in [Figure 14-3](#figure14-3).
    We start at the front of level 3\. The first node at this level has a key of 13,
    which is less than our target, so we progress to that node. At this point we've
    reached the end of the list for level 3\. We can’t progress any further at this
    height. The next node pointer is null.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[图 14-3](#figure14-3)所示的列表中搜索目标 14。我们从第 3 层的前端开始。该层的第一个节点的键值为 13，小于我们的目标，因此我们继续到该节点。此时，我们已经到达了第
    3 层的列表末端，无法在此高度进一步前进。下一个节点的指针为 null。
- en: The search then drops down a level and continues on level 2\. Here we find the
    next key in the list (14) is *not* less than our target, so we drop down to level
    1\. The same condition holds true on level 1 and level 0—the next key in the list
    is not less than our target. Our search terminates once we have completed level
    0\. At this point, our current node’s (key = 13) `next` pointer leads to the target
    node.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索然后下降到第 2 层并继续进行。在这里，我们发现列表中的下一个键值（14）*不*小于我们的目标，因此我们继续下降到第 1 层。第 1 层和第 0 层的条件相同——列表中的下一个键值不小于我们的目标。搜索在完成第
    0 层后终止。此时，我们当前节点（键值 = 13）的`next`指针指向目标节点。
- en: '![The search for 14 starts at the front, follows the pointer to node 13 at
    height 3, and then proceeds down the levels in that node.](image_fi/502604c14/f14003.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![搜索 14 从前端开始，沿着指针跳到第 3 层的节点 13，然后继续沿着该节点向下跳到更低的层。](image_fi/502604c14/f14003.png)'
- en: 'Figure 14-3: Searching a skip list for the target of 14\. The shaded entries
    and dashed pointers represent the ones traversed during the search.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-3：在跳表中搜索目标 14。阴影部分的条目和虚线指针表示在搜索过程中遍历的节点。
- en: Note that although we pointed to the target node for several iterations (at
    levels 2, 1, and 0), we continued the search until we passed the bottom level.
    This is due to our termination criteria in the code. We could add additional logic
    to halt the search earlier, but we keep the logic simpler here to match the logic
    used later for insertion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们已经对目标节点进行了多次迭代（在第 2 层、第 1 层和第 0 层），但我们仍然继续搜索直到通过了最底层。这是由于我们在代码中的终止标准。我们可以添加额外的逻辑来更早地停止搜索，但为了简化逻辑，我们在这里保持与后续插入逻辑一致的简化方式。
- en: In contrast, if we were searching the same list for a target of 12, as shown
    in [Figure 14-4](#figure14-4), we'd drop down to the bottom level significantly
    earlier in our search and progress along the bottom level.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们在相同的列表中搜索目标 12，如[图 14-4](#figure14-4)所示，我们会在搜索的早期就迅速降到最底层，并在底层继续搜索。
- en: '![The search for 12 starts at the front, follows the pointer to node 2 at height
    2, Proceeds down that node until height 0, and follows the pointer to node 9 at
    height 0.](image_fi/502604c14/f14004.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![搜索 12 从前端开始，沿着指针跳到第 2 层的节点 2，接着沿着该节点向下跳到第 0 层，最后沿着指针跳到第 0 层的节点 9。](image_fi/502604c14/f14004.png)'
- en: 'Figure 14-4: Searching a skip list for the target of 12\. The shaded entries
    and dashed pointers represent the ones traversed during the search.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-4：在跳表中搜索目标 12。阴影部分的条目和虚线指针表示在搜索过程中遍历的节点。
- en: We can picture this traversal as a squirrel’s navigation along a row of trees.
    Enjoying the views from higher branches, the squirrel jumps from tree to tree
    until there are no more trees of that height before its destination. Whenever
    possible it jumps between tall, old oak trees and sails over the shorter saplings
    in between. Since the taller trees are rarer, and thus further apart, the squirrel
    also covers more distance per jump. Moving from the wide branches of a tall tree
    to those of its tall neighbor requires fewer jumps than traversing all the small
    saplings in between.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这次遍历想象成一只松鼠在一排树木之间的导航。它在高处欣赏美景，跳跃着从一棵树到另一棵树，直到到达目标前的树木高度无法再继续跳跃为止。每当有可能时，它会在高大、古老的橡树之间跳跃，飞跃其间较矮的树苗。由于高大的橡树较为稀少，因此它们之间的距离较远，所以松鼠每次跳跃所覆盖的距离较长。从一棵大树的宽大树枝跳到另一棵大树的树枝所需的跳跃次数少于穿越中间的所有小树苗。
- en: However, the squirrel is unwilling to waste time backtracking and thus never
    overshoots its destination. Eventually the squirrel reaches a point where it will
    pass its destination if it jumps to the next tree at this level. Or perhaps there
    are no more trees of this height. Either way, the squirrel sighs and reluctantly
    descends to the lower level of branches before continuing forward. It progresses
    at the next level, taking jumps as large as possible and enjoying the scenic route,
    until it again hits a point where it needs to descend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，松鼠不愿意浪费时间回溯，因此永远不会超越它的目标。最终，松鼠会到达一个地方，在这里，如果它跳到这个高度的下一个树上，它就会超过目标。或者，可能没有更多的同高度树。不管怎样，松鼠叹了口气，勉强降落到较低的树枝层级，然后继续向前。它在下一个层级前进，尽可能跳得更远，享受风景路线，直到它再次遇到需要下降的地方。
- en: Adding Nodes
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加节点
- en: The distribution we use to select the height of a new node can have a significant
    impact on the structure and performance of the skip list. If everything is the
    same level, whether minimum or maximum, our skip list devolves into nothing more
    than a sorted linked list with additional memory overhead. Worse, if we set all
    the heights to the maximum, we create multiple parallel lists without adding any
    search efficiencies. Ideally, we’d like fewer tall nodes with increasing numbers
    at each level below.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于选择新节点高度的分布方式对跳表的结构和性能有重要影响。如果所有节点都处于相同的层级，无论是最小层级还是最大层级，那么我们的跳表就会退化成一个排序链表，且附带额外的内存开销。更糟糕的是，如果我们将所有高度设置为最大值，我们就会创建多个并行列表，但并没有增加任何搜索效率。理想情况下，我们希望有较少的高节点，并且在每个下层级上节点数量逐渐增加。
- en: William Pugh’s original approach to selecting heights is to continually use
    a constant probability *p* of adding another level. All nodes start at level 0\.
    We keep flipping a weighted coin—choosing a random number from 0 to 1 and checking
    if it is less than *p*—until we either get a number greater than *p* or hit the
    maximum allowable height. We count the number of flips less than *p* and set that
    as our new level. For example, we could use *p* = 0.5, in which case we’d expect
    approximately half the nodes at level *L* to be promoted to level *L* + 1\. We
    can use the value of *p* to balance search efficiency with memory usage. A smaller
    value of *p* will mean fewer tall nodes and thus fewer pointers per node. We cap
    a node’s height at `max_level` to stay consistent with the preallocated array
    in the `front` node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: William Pugh 最初选择高度的方法是不断使用一个常数概率 *p* 来添加另一个层级。所有节点从 0 层开始。我们不断抛一个加权硬币——选择一个从
    0 到 1 的随机数，检查它是否小于 *p*——直到得到一个大于 *p* 的数字或达到最大允许高度。我们计算小于 *p* 的抛掷次数，并将其设为新的层级。例如，我们可以使用
    *p* = 0.5，在这种情况下，我们期望大约一半的节点在 *L* 层被提升到 *L* + 1 层。我们可以通过调整 *p* 的值来平衡搜索效率和内存使用。较小的
    *p* 值意味着较少的高节点，从而每个节点的指针也更少。我们将节点的高度限制在 `max_level`，以保持与 `front` 节点中预分配数组的一致性。
- en: You can visualize this approach in terms of an inconsistent parent responding
    to a child’s request for more candy. When the child gets candy, they always gets
    a single piece, and then they always want more. Every time the child asks for
    candy, the parent randomly (with probability *p*) decides whether to grant the
    request. If so, they give the child another piece. This corresponds to increasing
    the height of the node by one. Naturally the child, seeing their victory, asks
    again immediately. The process continues until the parent finally gets annoyed,
    with probability (1 − *p*), and shouts a definitive “No more candy!” Similarly,
    we continue to increase the height of the node until either our random number
    generator or our max threshold tells us to stop altogether.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个不一致的父母回应孩子要求更多糖果的情境来形象化这种方法。当孩子得到糖果时，他们总是得到一块，而之后总是想要更多。每次孩子请求糖果时，父母都会随机（以概率*p*）决定是否满足请求。如果同意，他们就会再给孩子一块糖果。这相当于将节点的高度增加一。自然地，孩子看到自己获胜后，会立刻再次提出请求。这个过程会继续，直到父母最终感到恼火，以概率（1
    − *p*）喊出“不给糖果了！”类似地，我们会继续增加节点的高度，直到我们的随机数生成器或最大阈值告诉我们要完全停止。
- en: 'Adding nodes to a skip list follows the same flow as searching for a target
    node: we progress downward and to the right, looking for a place to insert the
    new node. In fact, we can reuse the basic structure of the search for our insertion.
    We just need to track one additional piece of data: the last node at each level
    that could point to our new node.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 向跳表中添加节点的过程与搜索目标节点的流程相同：我们向下和向右移动，寻找插入新节点的位置。事实上，我们可以重用搜索的基本结构来进行插入。我们只需要跟踪一个额外的数据：每个层级中可以指向新节点的最后一个节点。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We begin at the top left corner of the list (`list.top_level` of `list.front`)
    ❶. With a pair of nested `WHILE` loops, we progress downward and to the right
    as we search for the correct place to insert the node. The outer `WHILE` loop
    ❸ iterates through the list’s levels, saving the last node seen at each level
    and then dropping down to the next level. The inner `WHILE` loop ❹ traverses the
    skip list, moving forward whenever another node along this level has a key less
    than our target.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从列表的左上角开始（`list.front` 的 `list.top_level`） ❶。通过一对嵌套的 `WHILE` 循环，我们在寻找插入节点的正确位置时向下和向右移动。外层
    `WHILE` 循环 ❸ 遍历列表的各个层级，保存每个层级看到的最后一个节点，然后下降到下一个层级。内层 `WHILE` 循环 ❹ 遍历跳表，每当当前层级的另一个节点的键值小于我们的目标时，就向前移动。
- en: Every entry in the array `last` starts off at `list.front`, indicating that
    the node is inserted in the front of the list ❷. We update `last` for each level
    each time we drop down from that level ❺, because we have seen that the key of
    the next node at this level is greater than or equal to the key to be inserted
    (or the next node is `null`) and therefore we will need to insert before that
    node. If we happen to find a matching key while traversing the skip list, we simply
    update the data for that key ❻. This means that, like our other data structures,
    our skip list implementation treats each key as unique.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `last` 中的每个条目一开始都指向 `list.front`，表示该节点被插入到列表的最前端 ❷。我们会在每个层级下降时更新 `last` ❺，因为我们发现该层级的下一个节点的键值大于或等于要插入的键值（或者下一个节点为
    `null`），因此我们需要在该节点之前插入。如果在遍历跳表时恰好找到一个匹配的键值，我们只需更新该键的相关数据 ❻。这意味着，像我们的其他数据结构一样，我们的跳表实现将每个键视为唯一。
- en: When we find the correct point to insert the new node, we pick a random level
    for this node ❼. As we discussed previously, the probability distribution we use
    to select this height will have a significant impact on the structure and performance
    of the skip list. Since we cap the new level to be less than `list.max_level`,
    we avoid an invalid access to the `last` array. We check whether the selected
    level represents a new top level for the list and, if so, update `list.top_level`
    ❽.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到正确的插入位置时，我们为该节点选择一个随机的层级 ❼。正如我们之前讨论的，选择这个高度的概率分布会对跳表的结构和性能产生重大影响。由于我们将新层级限制为小于
    `list.max_level`，我们避免了对 `last` 数组的无效访问。我们检查所选层级是否代表列表的新顶部层级，如果是，则更新 `list.top_level`
    ❽。
- en: Finally, the code inserts the new element by using a `WHILE` loop to update
    the pointers from the new node to point to the correct following node ❾. Then
    it updates each of the nodes listed in `last` to point to our new node. Here we
    can see the benefit of using the dummy node `front` (with the maximum height)
    to store the pointers to the beginning of the list. We can track and update this
    “front of list” position as we would any other node. This greatly simplifies the
    code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码使用 `WHILE` 循环更新指针，将新节点的指针指向正确的下一个节点 ❾。然后，它更新 `last` 中列出的每个节点，将它们的指针指向我们的新节点。在这里，我们可以看到使用虚拟节点
    `front`（具有最大高度）来存储指向列表开头的指针的好处。我们可以像更新任何其他节点一样跟踪并更新这个“列表前端”位置。这大大简化了代码。
- en: '[Figure 14-5](#figure14-5) shows how we would insert the key of 10 into an
    example skip list. The shaded nodes indicate which entries we traverse during
    the search.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](#figure14-5) 显示了我们如何将键值 10 插入到一个示例跳表中。阴影节点表示在搜索过程中我们遍历的条目。'
- en: '![The last array points to front at height 3, node 1 at height 2, Node 1 at
    height 1, and node 9 at height 0.](image_fi/502604c14/f14005.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![最后的数组在高度 3 处指向 front，在高度 2 处指向节点 1，在高度 1 处指向节点 1，在高度 0 处指向节点 9。](image_fi/502604c14/f14005.png)'
- en: 'Figure 14-5: Inserting the key of 10 into a skip list. The array last tracks
    which node comes before the inserted node.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-5：将键值 10 插入跳表。数组 `last` 跟踪插入节点前的节点。
- en: By tracking the last node at each level *before* the target, we are effectively
    tracking which node needs to point to the new node. As we traverse the list, we
    are noting down the locations where we will need to insert new links. At each
    level, we reach a point where the next key is larger than or equal to our new
    key, and we can exclaim, “I see where we need to insert the new node. It’s right
    after this one!” We then descend a level to continue our work. By the time the
    search phase reaches the bottom layer, we already have a full list of all the
    nodes whose forward pointers we need to adjust.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过追踪每一层级上位于目标节点*之前*的最后一个节点，我们实际上在追踪哪个节点需要指向新的节点。随着我们遍历列表，我们记录下需要插入新链接的位置。在每一层级，我们会到达一个位置，其中下一个键值大于或等于我们的新键值，然后我们就可以喊道：“我看到了需要插入新节点的位置，就在这个节点后面！”接着我们会下移到下一层继续工作。当搜索阶段到达底层时，我们已经完整记录了所有需要调整前向指针的节点。
- en: Deleting Nodes
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除节点
- en: Deleting nodes from a skip list follows almost the same algorithm as inserting
    nodes. We first search the skip list for the deletion target while tracking the
    last node at each level that comes *before* the target node. Once the search phase
    completes, we update this list of previous nodes to remove the node we are deleting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从跳表中删除节点几乎遵循与插入节点相同的算法。我们首先搜索跳表以找到删除目标，同时追踪每一层级上位于目标节点*之前*的最后一个节点。一旦搜索阶段完成，我们更新这些先前节点的列表以删除我们要删除的节点。
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The initial block of deletion code is identical to the code for insertion. We
    start at the top left of the list ❶. A pair of nested `WHILE` loops ❷ searches
    across each level until we hit a node with a key greater than or equal to `target`
    or the end of the list (`null`). At this point, we record the last node visited
    and drop down to the next level to continue our search. At the end of the search,
    we check that we’ve found a node whose `key` matches `target` ❸. Otherwise, there
    is no match in the skip list and thus nothing to delete.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 删除代码的初始块与插入代码相同。我们从列表的左上角开始 ❶。一对嵌套的`WHILE`循环 ❷ 会在每一层级上进行搜索，直到我们遇到一个键值大于或等于`target`的节点，或者遇到列表的末尾（`null`）。此时，我们记录下最后访问的节点，并下移到下一层继续搜索。在搜索结束时，我们检查是否找到一个`key`与`target`匹配的节点
    ❸。否则，跳表中没有匹配项，因此没有节点可供删除。
- en: 'To remove the identified node, we use a `WHILE` loop ❹ to simply link the next
    pointers for each node in the skip list’s `last` to point past the current node:
    `last[j].next[j] = result.next[j]` for all levels `j`. This splices our node out
    of the list. We also set `result.next[j]` to `null` because `result` is no longer
    in the list.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除识别出的节点，我们使用一个`WHILE`循环 ❹ 来简单地链接跳表中每个节点的`last`节点的`next`指针，使其指向当前节点之后的节点：`last[j].next[j]
    = result.next[j]`，对于所有层级`j`。这将把我们的节点从列表中剪切掉。我们还将`result.next[j]`设置为`null`，因为`result`不再在列表中。
- en: Finally, we need to check whether the skip list’s top level is still valid ❺.
    If we deleted the sole node with height of `top_level`, then `top_level` should
    be decreased to reflect the current maximum height. We can update `top_level`
    by proceeding down the `front` node and checking the `next` pointers until we
    find one that is not `null`. The last block of code in our deletion function updates
    the list’s top level if needed. It finds the first level where our dummy front
    node points to a valid data node. If the list is empty, we simply default to a
    top level of zero.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查跳表的顶部层级是否仍然有效 ❺。如果我们删除了唯一一个高度为`top_level`的节点，那么`top_level`应该减小，以反映当前的最大高度。我们可以通过沿着`front`节点向下，并检查`next`指针，直到找到一个不为`null`的指针，来更新`top_level`。在我们的删除函数中的最后一段代码，会在需要时更新列表的顶部层级。它找到第一个层级，其中我们的虚拟前端节点指向一个有效的数据节点。如果列表为空，我们就默认将顶部层级设为零。
- en: 'Again, we can visualize the initial search required for deletion in terms of
    how we are viewing the next node and maintaining the list of nodes to update.
    At each level, we identify the node to delete (if it exists) while still at the
    node immediately preceding it at that level. The next node’s key is greater or
    equal to the key we need to delete. We pause: “I’d better mark down this current
    node, because I will need to change its pointers to skip the deleted node.” We
    record the pointer to the current node in `last` and proceed to the next level.
    At the end of our journey, we have collected a full list of the nodes whose pointers
    need to be updated.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过我们如何查看下一个节点并维护需要更新的节点列表来形象化删除所需的初始搜索。在每一层，我们识别需要删除的节点（如果它存在），同时仍停留在该层的前一个节点。下一个节点的键值大于或等于我们需要删除的键值。我们暂停：“我最好标记下这个当前节点，因为我将需要修改它的指针来跳过被删除的节点。”我们将当前节点的指针记录在`last`中，并继续前往下一层。在我们的旅程结束时，我们已经收集了一个完整的需要更新指针的节点列表。
- en: Runtimes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行时间
- en: The cost of search, insertion, and deletion operations will all depend on the
    nodes’ locations and distributions of heights. In an ideal case, the nodes at
    level *L* would include every other node from level *L* − 1\. We drop half the
    nodes at each level and space them evenly apart. In this case, the behavior of
    a skip list mirrors that of binary search. We can prune half the search space
    by looking at the single node in the top layer. We then drop down a layer and
    cut the space in half again. Thus, in the best case, our performance will be logarithmic
    in terms of the number of entries.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索、插入和删除操作的成本将取决于节点的位置和高度分布。在理想情况下，*L*层的节点将包含*L* − 1层的每隔一个节点。我们在每一层丢弃一半的节点，并将它们均匀地分布开来。在这种情况下，跳表的行为与二叉搜索相似。我们可以通过查看顶层的单个节点来修剪掉一半的搜索空间。然后，我们再下降一层，再次将空间减半。因此，在最好的情况下，我们的性能将在条目数量上呈对数增长。
- en: The worst-case performance of a skip list is equivalent to that of a standard
    linked list—it is linearly proportional to the number of nodes. If every node
    in the list is the same height, our skip list is nothing more than a sorted linked
    list. We’re forced to scan through each node in sequence to find a given target.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表的最坏情况性能与标准链表相当——它与节点数量成线性比例。如果列表中的每个节点都具有相同的高度，那么我们的跳表就只是一个排序链表。我们被迫按顺序扫描每个节点，以找到给定的目标。
- en: Assuming that we use a good probability distribution of heights, such as that
    provided by the previously described Pugh’s original technique (with *p* = 0.5),
    the *expected* costs of insertions, deletions, and searches all scale logarithmically
    with the number of entries. Unlike worst-case cost, expected cost provides an
    estimate of how the data structure will perform on average. This puts the average
    performance of skip lists on par with binary search trees.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用了良好的高度概率分布，比如之前描述的Pugh原始技术（其中*p* = 0.5），那么插入、删除和搜索的*预期*成本都会随着条目数量的对数级别增长。与最坏情况成本不同，预期成本提供了数据结构在平均情况下的性能估计。这使得跳表的平均性能与二叉搜索树相当。
- en: Why This Matters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: Skip lists are intended to be a simpler alternative to balanced search trees,
    as yet another dynamic data structure that enables efficient search. However,
    unlike the other algorithms we've applied to this task, including sorted arrays
    and binary search trees, skip lists rely on randomized structure to provide good
    performance. The *expected* computational cost of our common operations—search,
    insertion, and deletion—is logarithmic in the size of the list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表旨在作为平衡搜索树的简单替代方案，它是另一种动态数据结构，能够实现高效的搜索。然而，与我们为此任务应用的其他算法不同，包括排序数组和二叉搜索树，跳表依赖于随机化结构来提供良好的性能。我们常见操作——搜索、插入和删除的*预期*计算成本——是列表大小的对数级别。
- en: 'This naturally poses a question: why should we trust the performance of our
    algorithm to randomized behavior? We could easily run into cases where the tall
    nodes are clustered, or the distribution of heights is too flat. Yet the same
    is true of binary search trees. If we insert and remove nodes in a suboptimal
    order, we can end up with a linked list of tree nodes. Where more sophisticated
    extensions of binary search trees can be employed to avoid this worst-case behavior,
    skip lists rely on randomization to avoid terrible behavior. In exchange, they
    use much simpler code. Thus, skip lists demonstrate how randomization can provide
    both a robust defense against bad data and simplicity in a data structure’s implementation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然引出了一个问题：为什么我们要把算法的性能寄托于随机化行为上？我们很容易遇到高节点聚集的情况，或者高度分布过于平坦的情况。然而，二叉搜索树也有类似的问题。如果我们以次优顺序插入和删除节点，最终可能会得到一个链表结构的树节点。在更复杂的二叉搜索树扩展中，可以通过避免这种最坏情况的发生来解决问题，而跳表则依赖随机化来避免糟糕的表现。作为交换，跳表使用了更简单的代码。因此，跳表展示了随机化如何同时提供对坏数据的强大防御和数据结构实现的简洁性。
