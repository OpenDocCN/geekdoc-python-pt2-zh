- en: Part III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分
- en: Interactive Games
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互动游戏
- en: '9'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Graphics and Animation with the *turtle* Module
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *turtle* 模块进行图形和动画
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Our goal in the next few chapters is to build voice-controlled graphical games
    such as tic-tac-toe, Connect Four, and guess-the-word. You’ll do all these with
    the *turtle* module.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在接下来的几章中的目标是构建语音控制的图形游戏，如井字棋、四连棋和猜单词。你将使用 *turtle* 模块来完成所有这些。
- en: In this chapter, you won’t be working with voice interactivity. Instead you’ll
    learn the *turtle* module’s basic commands that will let you set up a turtle screen,
    draw shapes, and create animations. This functionality will be the basis for all
    the games you’ll be building.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你将不会使用语音交互。相反，你将学习 *turtle* 模块的基本命令，这些命令将帮助你设置海龟屏幕、绘制形状和创建动画。这些功能将成为你将要构建的所有游戏的基础。
- en: Before you begin, set up the folder */mpt/ch09/* for this chapter. As always,
    all scripts in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，为本章设置文件夹 */mpt/ch09/*。和往常一样，本章中的所有脚本都可以在本书的资源页面找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Basic Commands
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本命令
- en: The *turtle* module allows us to use a robotic turtle to draw shapes and create
    animations on a canvas. The turtle mimics the way people draw on a physical canvas,
    but we use commands to move the turtle and create the drawings.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块允许我们使用一个机器人海龟在画布上绘制图形并创建动画。海龟模仿了人们在物理画布上绘画的方式，但我们使用命令来移动海龟并创建图画。'
- en: For its underlying graphics, the *turtle* module uses the *tkinter* module,
    which is Python’s de facto standard graphical user interface (GUI) package. Both
    *turtle* and *tkinter* are in the Python standard library, so there’s no need
    to install them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其底层图形，*turtle* 模块使用了 *tkinter* 模块，这是 Python 的事实标准图形用户界面（GUI）包。*turtle* 和 *tkinter*
    都包含在 Python 标准库中，因此无需安装它们。
- en: 'Turtle graphics were invented in the 1960s, three decades before the Python
    language. The *turtle* module allows Python programmers to take advantage of many
    features of turtle graphics. The first is their simplicity: *turtle* is easier
    to learn than other game modules such as *pygame* or *tkinter*. The *turtle* module
    is also intuitive, making it easy to create pictures and shapes by manipulating
    the drawing pen on a canvas (that is, the screen).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟图形是在 1960 年代发明的，比 Python 语言早了三十年。*turtle* 模块允许 Python 程序员利用海龟图形的许多特性。第一个特性是它的简单性：*turtle*
    比其他游戏模块，如 *pygame* 或 *tkinter*，更容易学习。*turtle* 模块还很直观，使得通过操控画笔在画布（即屏幕）上绘制图片和形状变得简单。
- en: The *turtle* module is also better suited to voice activation. Unlike other
    game modules, which constantly run through a game loop too fast to capture voice
    commands, *turtle* scripts don’t need a game loop. This makes voice-controlled
    games possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块也更适合语音激活。与其他游戏模块不同，后者通常通过游戏循环运行得太快，无法捕捉语音命令，*turtle* 脚本不需要游戏循环。这使得语音控制的游戏成为可能。'
- en: Create a turtle Screen
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个海龟屏幕
- en: 'To use *turtle*, you need to create a turtle screen to contain all objects
    in the script. The following script shows you a simple example of the turtle screen.
    Enter the following lines of code in Spyder and save the script as *set_up_screen.py*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *turtle*，你需要创建一个海龟屏幕来容纳脚本中的所有对象。下面的脚本向你展示了一个简单的海龟屏幕示例。在 Spyder 中输入以下代码行，并将脚本保存为
    *set_up_screen.py*：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We import the *turtle* module and give it a short alias name, `t`. This is one
    situation where a short alias module name is beneficial, since we’ll be calling
    multiple functions from the module, and often. Therefore, we want to use only
    `t.`, instead of `turtle.`, in front of all the functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 *turtle* 模块并为其指定一个简短的别名 `t`。这是一个简短别名有利的情况，因为我们将多次调用模块中的多个函数。因此，我们希望在所有函数前面只使用
    `t.`，而不是 `turtle.`。
- en: At 1, we create a screen by using `Screen()`, which doesn’t require arguments.
    We then use `setup()` to specify the size and location of the screen. The four
    parameters are screen width, screen height, horizontal distance from the top left
    of your computer screen, and vertical distance from the top left of your computer
    screen, in that order. Our screen will be 600 pixels wide and 500 pixels tall,
    100 pixels from the left edge of the computer screen, and 200 pixels from the
    top edge.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1，我们通过使用`Screen()`创建一个屏幕，这不需要任何参数。接着我们使用`setup()`来指定屏幕的大小和位置。四个参数依次是屏幕宽度、屏幕高度、距离计算机屏幕左上角的水平距离以及距离计算机屏幕左上角的垂直距离。我们的屏幕将是600像素宽、500像素高，距离计算机屏幕左边缘100像素，距离上边缘200像素。
- en: Next, we give the turtle screen a background color by using `bgcolor()`. The
    *turtle* module provides a wide range of colors, including `brown`, `black`, `gray`,
    `white`, `yellow`, `gold`, `orange`, `red`, `purple`, `navy`, `blue`, `lightblue`,
    `darkblue`, `cyan`, `turquoise`, `lightgreen`, `green`, and `darkgreen`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`bgcolor()`为海龟屏幕设置背景颜色。*turtle*模块提供了多种颜色，包括`brown`（棕色）、`black`（黑色）、`gray`（灰色）、`white`（白色）、`yellow`（黄色）、`gold`（金色）、`orange`（橙色）、`red`（红色）、`purple`（紫色）、`navy`（海军蓝）、`blue`（蓝色）、`lightblue`（浅蓝色）、`darkblue`（深蓝色）、`cyan`（青色）、`turquoise`（绿松石色）、`lightgreen`（浅绿色）、`green`（绿色）和`darkgreen`（深绿色）。
- en: At 2, we give a title to the screen, which you’ll see at the top beside the
    turtle graphics symbol ([Figure 9-1](#figure9-1)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2，我们为屏幕添加一个标题，你可以在屏幕顶部看到它，靠近海龟图形符号（[图9-1](#figure9-1)）。
- en: The `done()` command tells the script to start the event, which is how objects
    on the screen could be animated. The `bye()` command tells the script to exit
    *turtle* when you click the X symbol.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`命令告诉脚本开始事件，这样屏幕上的对象就可以进行动画处理。`bye()`命令则告诉脚本在你点击X符号时退出*turtle*模块。'
- en: The screen should look something like [Figure 9-1](#figure9-1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕应该看起来像[图9-1](#figure9-1)所示。
- en: '![f09001](Images/f09001.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](Images/f09001.png)'
- en: 'Figure 9-1: Set up the size, background color, and title of the screen.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：设置屏幕的大小、背景颜色和标题。
- en: A turtle screen uses a *Cartesian* coordinate system, with the center coordinate
    (x = 0, y = 0). The x-value increases from left to right, and the y-value increases
    from bottom to top, just like the two-dimensional plane you learned in high school
    mathematics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟屏幕使用的是*笛卡尔*坐标系，坐标原点为(x = 0, y = 0)。x值从左到右递增，y值从下到上递增，就像你在高中数学中学到的二维平面。
- en: Create Movements
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建动作
- en: 'In earlier days, the turtle cursor was literally a picture of a turtle moving
    around on the screen. Now, instead of a literal turtle, you see a small arrowhead
    as the default cursor. The turtle has three attributes: location, direction, and
    a pen. You can adjust the color and width of the pen, and you can decide whether
    to put the pen down on the plane so the turtle’s path is marked when it moves
    or lift it up so the movement isn’t tracked.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，海龟光标实际上是一个在屏幕上移动的海龟图像。现在，默认的光标是一个小箭头，取代了原来的海龟图像。海龟有三个属性：位置、方向和画笔。你可以调整画笔的颜色和宽度，还可以决定是否将画笔放在平面上，这样海龟移动时就会在其路径上留下痕迹，或者将画笔抬起，这样就不会跟踪移动。
- en: Let’s see an actual drawing before looking at the various movements in the module.
    Enter the code shown in [Listing 9-1](#listing9-1) in a Spyder editor and save
    it as *show_turtle.py* in your chapter folder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看模块中的各种动作之前，先看看实际的绘图。在Spyder编辑器中输入[示例9-1](#listing9-1)中的代码，并将其保存为*show_turtle.py*，放在你的章节文件夹中。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-1: Showing the turtle in the *turtle* module'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-1：显示*turtle*模块中的海龟
- en: At 1, we change the shape of the cursor back to the original turtle shape, as
    you can see in [Figure 9-2](#figure9-2). If you run the script, you can see that
    the turtle starts at position (x = 0, y = 0) and faces right. It moves forward
    200 pixels with the default down pen position, so this movement draws a line on
    the canvas. We turn the turtle right 90 degrees and lift up the pen before moving
    forward 100 pixels. This time, no line is drawn on the canvas since the drawing
    pen is not touching the canvas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1，我们将光标的形状改回原始的海龟形状，正如[图9-2](#figure9-2)所示。如果你运行脚本，你会看到海龟从位置(x = 0, y = 0)开始并朝右移动。它在默认的放下画笔状态下向前移动200像素，因此在画布上绘制了一条线。然后我们将海龟右转90度并抬起画笔，再向前移动100像素。这次由于画笔没有接触到画布，因此不会绘制线条。
- en: '![f09002](Images/f09002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](Images/f09002.png)'
- en: 'Figure 9-2: The turtle moves on the canvas to make a drawing.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：海龟在画布上移动进行绘图。
- en: Now we’ll discuss in detail some basic movements in the *turtle* module that
    are useful for our projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将详细讨论一些在*turtle*模块中非常有用的基本动作，这些动作对我们的项目非常重要。
- en: The forward() and backward() Functions
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: forward() 和 backward() 函数
- en: The `forward()` function tells the turtle to move forward the specified number
    of pixels on the screen. The `backward()` function does the same backward. Enter
    the code shown in [Listing 9-2](#listing9-2) in a Spyder editor and save it as
    *forward_backward.py* in your chapter folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward()` 函数让乌龟在屏幕上向前移动指定的像素数。`backward()` 函数做相同的操作，只不过是向后移动。在 Spyder 编辑器中输入
    [列表 9-2](#listing9-2) 中显示的代码，并将其保存为 *forward_backward.py* 文件到您的章节文件夹中。'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-2: Basic movement functions in the *turtle* module'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-2：*turtle* 模块中的基本运动函数
- en: We set up the screen with a different background color and a title. At 1, the
    turtle moves forward 200 pixels. The default starting position of the turtle is
    at (x = 0, y = 0), facing to the right, so moving forward 200 pixels leads the
    turtle to the point (x = 200, y = 0).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个不同背景颜色和标题的屏幕。在 1 处，乌龟前进 200 像素。乌龟的默认起始位置是 (x = 0, y = 0)，面朝右侧，因此前进 200
    像素后，乌龟的位置将到达 (x = 200, y = 0)。
- en: At 2, the turtle moves from the point (x = 200, y = 0) backward 300 pixels,
    ending up at (x = –100, y = 0).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2 处，乌龟从点 (x = 200, y = 0) 向后移动 300 像素，最终停在 (x = -100, y = 0) 处。
- en: The left() and right() Functions
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: left() 和 right() 函数
- en: The `left()` or `right()` function changes the direction the turtle is facing.
    As the argument, we give the degree of the angle to move by. For example, `90`
    degrees turns the turtle perpendicular to the original direction. A degree value
    of `360` turns the turtle in a full circle so it’s still going in the original
    direction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`left()` 或 `right()` 函数改变乌龟的方向。我们给定一个角度值作为参数，用以表示乌龟要转动的角度。例如，`90` 度让乌龟转向与原方向垂直的方向。`360`
    度的角度让乌龟旋转一圈，从而仍然朝向原来的方向。'
- en: The script *left_right.py* in [Listing 9-3](#listing9-3) shows how the `left()`
    and `right()` functions work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-3](#listing9-3) 中的脚本 *left_right.py* 展示了 `left()` 和 `right()` 函数的用法。'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: Python code for *left_right.py*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-3：*left_right.py* 的 Python 代码
- en: The `pensize()` function specifies the thickness of the line the turtle is drawing
    1. The default value is 1 pixel. Here we set the pen size to 5 pixels. At 2, we
    tell the turtle to turn right 30 degrees. Then, we move the turtle forward 200
    pixels. We then turn the turtle left 30 degrees and move backward 400 pixels.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`pensize()` 函数指定乌龟绘制的线条粗细，默认值为 1 像素。在这里，我们将笔的大小设置为 5 像素。在 2 处，我们让乌龟右转 30 度。然后，我们让乌龟前进
    200 像素。接着，我们让乌龟左转 30 度并后退 400 像素。'
- en: The `pencolor()` function changes the color of the drawing pen to red 3. The
    default is black. After this step, the lines will be red instead of black.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`pencolor()` 函数将绘图笔的颜色改为红色 3，默认颜色为黑色。经过这一步，绘制的线条将变为红色，而不是黑色。'
- en: Run the script and you should see a screen similar to [Figure 9-3](#figure9-3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您应该会看到类似于 [图 9-3](#figure9-3) 的屏幕。
- en: '![f09003](Images/f09003.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](Images/f09003.png)'
- en: 'Figure 9-3: The `left()` and `right()` functions in the *turtle* module'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：*turtle* 模块中的 `left()` 和 `right()` 函数
- en: The goto() Function
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: goto() 函数
- en: The `goto()` function tells the turtle to go to the specified point on the screen.
    Together with `up()` and `down()`, it can create straight lines and dashed lines.
    The `up()` function means the turtle pen is not touching the canvas and so doesn’t
    draw as it moves. The `down()` function puts the pen on the canvas and creates
    drawings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto()` 函数告诉乌龟移动到屏幕上的指定点。结合 `up()` 和 `down()`，它可以绘制直线和虚线。`up()` 函数意味着乌龟的笔没有接触到画布，因此在移动时不会绘制任何内容。`down()`
    函数则将笔放在画布上，开始绘图。'
- en: If the turtle pen is in the down position, `goto()` will create a straight line
    between the current position and the specified position. However, if the turtle
    pen is in the up position, `goto()` will create nothing on the screen, but merely
    moving the turtle from the current position to the specified position. Dashed
    lines can be created by drawing a sequence of short lines with spaces in between.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果乌龟的笔处于下方位置，`goto()` 将在当前位置和指定位置之间绘制一条直线。然而，如果乌龟的笔处于上方位置，`goto()` 将不会在屏幕上绘制任何东西，而只是将乌龟从当前位置移动到指定位置。通过绘制一系列短线并在它们之间留空，可以创建虚线。
- en: Enter the script *create_lines.py* in [Listing 9-4](#listing9-4).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9-4](#listing9-4) 中输入脚本 *create_lines.py*。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-4: Python code for *create_lines**.py*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：*create_lines.py* 的 Python 代码
- en: At 1, we tell the turtle to go to (x = 200, y = 100). By default, the turtle
    is in the down position and the starting position is (x = 0, y = 0), so `goto(200,100)`
    draws a line between the two points (0, 0) and (200, 100), as you can see in [Figure
    9-4](#figure9-4).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步，我们告诉乌龟移动到 (x = 200, y = 100)。默认情况下，乌龟是处于下笔状态，起始位置是 (x = 0, y = 0)，因此
    `goto(200,100)` 会在两个点 (0, 0) 和 (200, 100) 之间画一条线，如[图 9-4](#figure9-4) 所示。
- en: At 2, the script tells the turtle to lift up the pen so that no line is drawn
    on the screen when the turtle goes to another point. We then change the pen color
    to blue. At 3, we start a `for` loop. In each iteration, the turtle goes to a
    point, puts down the pen, and goes to another point 30 pixels to the right. This
    leaves a 30-pixel-long dash, done eight times with gaps between.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步，脚本指示乌龟抬起画笔，这样乌龟移动到另一个点时，屏幕上不会画出任何线条。然后我们将画笔颜色改为蓝色。在第 3 步，我们开始一个 `for`
    循环。在每次迭代中，乌龟会到达一个点，放下画笔，然后移动到右边 30 像素的地方。这样就会留下一个 30 像素长的短线，重复八次，之间有间隙。
- en: The `hideturtle()` function hides the turtle so that the black arrow cursor
    is not shown on the screen 4.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`hideturtle()` 函数可以隐藏乌龟，使得屏幕上不显示黑色的箭头光标 4。'
- en: Run the script and you should see a screen similar to [Figure 9-4](#figure9-4).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该能看到一个类似于 [图 9-4](#figure9-4) 的屏幕。
- en: '![f09004](Images/f09004.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](Images/f09004.png)'
- en: 'Figure 9-4: Use the `goto()` function to create lines using the *turtle* module.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：使用 `goto()` 函数通过 *turtle* 模块绘制直线。
- en: Basic Shapes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本形状
- en: The *turtle* module has several built-in shapes, including the commonly used
    `dot()` function that creates a dot. You’ll also learn how to create basic shapes
    such as a triangle, a square, and gridlines.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块有多个内建的形状，包括常用的 `dot()` 函数，它可以创建圆点。你还将学习如何创建基本形状，如三角形、正方形和网格线。'
- en: Use the dot() Function
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 dot() 函数
- en: The `dot()` function creates a dot with the specified diameter and color. For
    example, the command `dot(30,'red')` creates a red dot with a diameter of 30 pixels.
    We’ll use this in our tic-tac-toe and Connect Four games to create game pieces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`dot()` 函数创建一个指定直径和颜色的圆点。例如，命令 `dot(30, ''red'')` 会创建一个直径为 30 像素的红色圆点。我们将在井字游戏和四子棋游戏中使用这个功能来创建游戏棋子。'
- en: '[Listing 9-5](#listing9-5), *dots.py*, shows how the `dot()` function works.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-5](#listing9-5)，*dots.py* 展示了 `dot()` 函数的使用方法。'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-5: Python code for *dots.py*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5：*dots.py* 的 Python 代码
- en: First we lift up the pen 1. Then we go to the point (150, 100). We tell the
    turtle to put a red dot centered on the point (150, 100) and with a diameter of
    120 pixels.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们抬起画笔 1。然后我们移动到点 (150, 100)。我们告诉乌龟在点 (150, 100) 处画一个直径为 120 像素的红色圆点。
- en: Next, we move the turtle to (–150, 100) and draw a yellow dot with a diameter
    of 135 pixels. Note that you don’t need to use `up()` again since the pen is already
    lifted up. With the pen up, the turtle can still draw dots.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将乌龟移到 (–150, 100)，并画一个直径为 135 像素的黄色圆点。请注意，你不需要再次使用 `up()`，因为画笔已经抬起。画笔抬起时，乌龟依然可以画圆点。
- en: Starting from 2, the turtle goes to (150, –100) and draws a blue dot with a
    diameter of 125 pixels. Then it goes to (–150, –100) and draws a green dot with
    a diameter of 140 pixels. [Figure 9-5](#figure9-5) shows the outcome.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 2 步开始，乌龟会到达 (150, –100) 并画出一个直径为 125 像素的蓝色圆点。然后它移动到 (–150, –100) 并画出一个直径为
    140 像素的绿色圆点。[图 9-5](#figure9-5) 展示了最终效果。
- en: '![f09005](Images/f09005.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](Images/f09005.png)'
- en: 'Figure 9-5: Create dots using the *turtle* module.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：使用 *turtle* 模块创建圆点。
- en: Draw Your Own Shapes
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制自己的图形
- en: You can also draw your own shapes using the *turtle* module. We’ll look at some
    basic shapes here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 *turtle* 模块绘制自己的图形。我们将在这里介绍一些基本形状。
- en: Triangles
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三角形
- en: The easiest way to create a triangle is by using `goto()`. [Listing 9-6](#listing9-6),
    *triangle.py*, draws a triangle with the corners at (–50, –50), (50, –50), and
    (0, 100).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三角形的最简单方法是使用 `goto()`。[示例 9-6](#listing9-6) 中，*triangle.py* 绘制了一个三角形，三个角的坐标分别为
    (–50, –50)、(50, –50) 和 (0, 100)。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-6: Python code for *t**riangle.py*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6：*t**riangle.py* 的 Python 代码
- en: The `tracer()` function tells the script whether to trace the movements of the
    turtle. The default value is `tracer(True)`, which means the script shows you
    the movement of the turtle step-by-step. When the turtle pen draws something,
    you’ll see the drawing, one stroke after another. Here, we use `tracer(False)`,
    so the final drawing is printed, but the script doesn’t show the intermediate
    steps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracer()` 函数告诉脚本是否追踪乌龟的运动。默认值是 `tracer(True)`，意味着脚本会逐步展示乌龟的移动。当乌龟画出一些内容时，你将看到每一笔的绘制过程。这里我们使用
    `tracer(False)`，因此最终的图形会被打印出来，但脚本不会显示中间的步骤。'
- en: We change the pen’s color to blue 1 and its size to 5\. We lift up the pen and
    go to point (–50, –50) then put down the pen and go to point (50, –50). This forms
    the first leg of the triangle. With the pen down, we ask the turtle to go to point
    (0, 100), which forms the second leg. The base is drawn when we send the pen back
    to point (–50, –50) to complete the triangle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将笔的颜色改为蓝色1，大小设置为5。然后抬起笔，移动到点（–50, –50），再放下笔，移动到点（50, –50）。这形成了三角形的第一条边。笔下后，我们让海龟移动到点（0,
    100），形成第二条边。最后，我们将笔移动回点（–50, –50），完成三角形的底边。
- en: Note that since we’ve used the command `tracer(False)` to not display each drawing
    step (thus saving time), we need to put `update()` at the end of the script to
    show the completed picture, as shown in [Figure 9-6](#figure9-6).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们使用了命令`tracer(False)`来禁用每一步绘图的显示（从而节省时间），因此在脚本末尾需要使用`update()`来显示完整的图像，如[图
    9-6](#figure9-6)所示。
- en: '![f09006](Images/f09006.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](Images/f09006.png)'
- en: 'Figure 9-6: Draw a triangle using the *turtle* module.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-6: 使用 *turtle* 模块绘制三角形。'
- en: Rectangles
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 矩形
- en: We can draw rectangles by using `goto()`, as we did for triangles, but we can
    also use `forward()` and `left()`. In many situations, you can achieve the same
    goal by using either the `goto()` function or the `forward()` and `left()` functions.
    If you know the coordinates of the destination, `goto()` is easier, and if you
    know the distances between two points, the directional functions are easier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像绘制三角形一样，使用`goto()`绘制矩形，但我们也可以使用`forward()`和`left()`。在许多情况下，你可以通过使用`goto()`函数或`forward()`和`left()`函数来实现相同的目标。如果你知道目的地的坐标，`goto()`更简单；如果你知道两点之间的距离，方向函数则更易用。
- en: Here, we’ll use `forward()` and `left()`. You’ll achieve the same results by
    using `goto()` in the “End-of-Chapter Exercises” on page 187.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`forward()`和`left()`。你也可以通过使用`goto()`来实现相同的结果，详见第187页的“章节末练习”部分。
- en: We’ll draw a rectangle with the points (0, 0), (200, 0), (200, 100), and (0,
    100). Enter the script *rectangle.py* shown in [Listing 9-7](#listing9-7).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个矩形，四个顶点为（0, 0）、（200, 0）、（200, 100）和（0, 100）。请输入[列表 9-7](#listing9-7)中的
    *rectangle.py* 脚本。
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-7: Python code for *r**ectangle.py*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-7: *rectangle.py* 的 Python 代码'
- en: We first set up the screen. At 1, we set the pen size to 6\. We don’t specify
    the pen color, so the default color of black will be used. At 2, the turtle moves
    forward 200 pixels from the initial position of (0, 0) to form the first side
    of the rectangle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置屏幕。在第1步，我们将笔的大小设置为6。由于没有指定笔的颜色，因此使用默认的黑色。在第2步，海龟从初始位置（0, 0）向前移动200像素，形成矩形的第一条边。
- en: Next, the turtle turns left 90 degrees so that it faces up. Then it moves forward
    100 pixels to form the second side. We then make the turtle turn left 90 degrees
    so that it faces west, and move it forward 200 pixels for the third side. The
    last side of the rectangle is formed similarly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，海龟向左转90度，面朝上方。然后它向前移动100像素，形成第二条边。接着，我们让海龟向左转90度，面朝西方，并向前移动200像素，形成第三条边。矩形的最后一条边以类似方式绘制。
- en: The output is shown in [Figure 9-7](#figure9-7).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如[图 9-7](#figure9-7)所示。
- en: '![f09007](Images/f09007.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](Images/f09007.png)'
- en: 'Figure 9-7: Draw a rectangle using the *turtle* module.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-7: 使用 *turtle* 模块绘制矩形。'
- en: We’ll use this rectangle-drawing skill to create a board for our upcoming games.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种绘制矩形的技巧来为即将到来的游戏创建一个棋盘。
- en: Draw Grid Lines
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制网格线
- en: Games such as tic-tac-toe and Connect Four use a grid. We can make a grid simply
    by drawing squares. Here we’ll draw a game board with six rows and seven columns;
    the horizontal lines will be thinner and lighter than the vertical ones to match
    what we’ll do in the Connect Four game. Enter the code from *grid_lines.py* in
    [Listing 9-8](#listing9-8).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 像井字游戏和四连棋这样的游戏都使用网格。我们可以通过绘制方形来简单地创建网格。这里，我们将绘制一个包含六行七列的游戏棋盘；水平线将比垂直线更细、更浅，以符合我们在四连棋游戏中所做的设计。请输入[列表
    9-8](#listing9-8)中的 *grid_lines.py* 代码。
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-8: Python code for *g**rid**_l**ines.py*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-8: *grid_lines.py* 的 Python 代码'
- en: We first set up the screen. Since we plan to draw a game board with six rows
    and seven columns, we set the screen size to 810 pixels wide and 710 pixels tall.
    This way, we can make each cell a square that’s 100 by 100 pixels, with a 55-pixel
    margin around the board. It’s important to think about your screen size so you
    can calculate the coordinates of various points.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置屏幕。由于我们计划绘制一个包含六行七列的游戏棋盘，我们将屏幕大小设置为810像素宽、710像素高。这样，我们可以将每个单元格设置为100×100像素，棋盘四周留有55像素的边距。考虑屏幕大小非常重要，这样可以帮助你计算出各个点的坐标。
- en: 'We draw eight thick vertical lines with a pen size of 5 1 to divide the screen
    into seven columns. The function `range(-350,400,100)` produces eight values:
    `-350, -250, ..., 350`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '我们用笔的大小为 5 1 画了八条粗的垂直线，将屏幕划分为七列。函数 `range(-350,400,100)` 会产生八个值：`-350, -250,
    ..., 350`。  '
- en: After that, we draw seven thin, gray, horizontal lines to form six rows 2. If
    you run the script, you’ll see a screen similar to [Figure 9-8](#figure9-8).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，我们画七条细的灰色水平线，形成六行 2。如果你运行脚本，你会看到一个类似于 [图 9-8](#figure9-8) 的屏幕。  '
- en: We’ll use this board in Chapter 11 for our games.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在第 11 章的游戏中使用这个板。  '
- en: Animation
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '动画  '
- en: In this section, you’ll learn to create animation by using `clear()` and `update()`
    to clear the current image and replace it with the next, producing animation frames.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在这一部分，你将学习如何使用 `clear()` 和 `update()` 来清除当前图像并用下一个图像替换，从而产生动画帧。  '
- en: '![f09008](Images/f09008.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f09008](Images/f09008.png)  '
- en: 'Figure 9-8: Draw grid lines to form a six-by-seven game board'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-8: 绘制网格线以形成一个六行七列的游戏板  '
- en: How Animation Works
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '如何动画工作  '
- en: The `clear()` function erases everything the turtle has drawn on the screen.
    You can then redraw objects and use `update()` to put them onscreen. If you do
    this repeatedly, the rapid replacement of images will create an animation effect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear()` 函数会清除海龟在屏幕上画的所有内容。然后你可以重新绘制对象，并使用 `update()` 将它们显示在屏幕上。如果你重复这个过程，图像的快速替换将产生动画效果。  '
- en: We’ll explore animation by making a simple clock, shown in *turtle_clock.py*
    in [Listing 9-9](#listing9-9).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将通过制作一个简单的时钟来探索动画，时钟在 [示例 9-9](#listing9-9) 的 *turtle_clock.py* 中展示。  '
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-9: Python code for *turtle_clock**.py*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-9: *turtle_clock**.py* 的 Python 代码  '
- en: We import the modules and set up the screen. At 1, we start an infinite loop.
    In each iteration, the script first erases everything onscreen by using `clear()`.
    We then obtain the current time by using the *arrow* module and store the value
    in the variable `current_time`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '我们导入模块并设置屏幕。在 1 处，我们开始一个无限循环。在每次迭代中，脚本首先通过使用 `clear()` 清除屏幕上的所有内容。然后我们通过使用
    *arrow* 模块获取当前时间，并将值存储在变量 `current_time` 中。  '
- en: The `write()` function from the *turtle* module writes text onscreen. It takes
    the text to be displayed as the first argument and the font to use as the second
    argument. At 2, we write `The Current Time Is` to the screen in blue. At 3, the
    script writes the current time in red.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块的 `write()` 函数将在屏幕上写文本。它的第一个参数是要显示的文本，第二个参数是使用的字体。在 2 处，我们用蓝色在屏幕上写
    `The Current Time Is`。在 3 处，脚本用红色写下当前时间。  '
- en: The script then pauses for one second and makes sure that all the new drawings
    are updated by using `update()`. If you run the script, you’ll notice that the
    time changes every second ([Figure 9-9](#figure9-9)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '然后脚本暂停一秒，并确保通过使用 `update()` 更新所有新的绘图。如果你运行脚本，你会注意到时间每秒都会变化（见 [图 9-9](#figure9-9)）。  '
- en: '![f09009](Images/f09009.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f09009](Images/f09009.png)  '
- en: 'Figure 9-9: Create animation in the *turtle* module.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-9: 在 *turtle* 模块中创建动画'
- en: We’ll use this method frequently to create animations in various games.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在各种游戏中频繁使用这种方法来创建动画。  '
- en: Use Multiple Turtles
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '使用多个海龟  '
- en: Now we’ll look at using two turtles simultaneously—the equivalent of using two
    pens. In Chapter 12, when we create a guess-the-word game, we’ll use one turtle
    to create a gold coin on the game board and another to count the number of chances
    the player has left. Whenever the player misses a letter, we’ll erase the previous
    number and change it to the new number. If we used only one turtle, everything,
    including the coin image, would be wiped. If we use a second turtle, we can keep
    everything else onscreen and change only whatever the second turtle draws.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们来看一下如何同时使用两个海龟——相当于使用两支笔。在第 12 章，当我们创建一个猜词游戏时，我们将使用一个海龟在游戏板上画一个金币，另一个用来计算玩家剩余的机会次数。每当玩家错过一个字母时，我们将擦除之前的数字，并用新数字替换。如果我们只使用一个海龟，那么所有内容，包括金币图像都会被清除。如果我们使用第二个海龟，我们可以保持屏幕上的其他内容不变，只更改第二个海龟所绘制的部分。  '
- en: In [Listing 9-10](#listing9-10), *two_turtles.py*, we’ll use one turtle to draw
    a square and another to write something below it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [示例 9-10](#listing9-10)，*two_turtles.py* 中，我们将使用一个海龟绘制一个正方形，另一个海龟在其下方写字。  '
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-10: Python code for *two_turtles**.py*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-10: *two_turtles**.py* 的 Python 代码  '
- en: We import the *turtle* module and set up a screen with a size of 810 by 710
    pixels. Starting at 1, we draw a blue square in the middle of the screen, similar
    to the way we drew a rectangle but with all sides the same length.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '我们导入 *turtle* 模块，并设置一个大小为 810 x 710 像素的屏幕。从 1 开始，我们在屏幕中央画一个蓝色的正方形，类似于我们画矩形的方式，只不过四条边长度相等。  '
- en: At 2, we create a second turtle with `Turtle()` and name it `msg`. We tell the
    script to hide the second turtle
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在2处，我们通过`Turtle()`创建了第二只海龟，并将其命名为`msg`。我们告诉脚本隐藏第二只海龟
- en: The second turtle `msg` lifts up the pen, changes the color to red, goes to
    (–300, –200), and writes the message `this is written by the second turtle`. The
    `update()` function refreshes the screen to draw everything created by the two
    turtles, shown in [Figure 9-10](#figure9-10).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二只海龟`msg`抬起画笔，将颜色改为红色，移动到坐标（–300, –200），并写下消息`this is written by the second
    turtle`。`update()`函数刷新屏幕，绘制由两只海龟创建的所有内容，如[图9-10](#figure9-10)所示。
- en: '![f09010](Images/f09010.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![f09010](Images/f09010.png)'
- en: 'Figure 9-10: A screen created with two turtles'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10：由两只海龟创建的屏幕
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the basics of the *turtle* module. You first learned
    how to set up a turtle screen and then learned basic movements like going forward
    or backward and turning left or right. You created various shapes by using both
    the built-in function and basic movement commands.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了*turtle*模块的基础知识。你首先学习了如何设置海龟屏幕，然后学习了基本的移动方式，比如前进、后退以及左转、右转。你通过使用内置函数和基本移动命令创建了各种形状。
- en: Finally, you learned to create animation effects in the *turtle* module by using
    the `clear()` and `update()` functions. In the next few chapters, you’ll learn
    how to use these skills to create voice-controlled graphical games.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了通过使用`clear()`和`update()`函数在*turtle*模块中创建动画效果。在接下来的几章中，你将学习如何使用这些技能创建语音控制的图形游戏。
- en: End-of-Chapter Exercises
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Modify *set_up_screen.py* so that the screen size is 500 pixels wide and 400
    pixels tall, the background color is blue, and the title is `Modified Screen`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*set_up_screen.py*，使屏幕宽度为500像素，高度为400像素，背景颜色为蓝色，标题为`Modified Screen`。
- en: Modify *forward_backward.py* so that the turtle first moves backward 100 pixels
    and then moves forward 250 pixels.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*forward_backward.py*，使得海龟先后退100像素，再前进250像素。
- en: Modify *dots.py* to have only two light green dots with diameters of 60 at points
    (–100, –100) and (100, 100).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*dots.py*，使其只包含两个直径为60的浅绿色点，分别位于坐标（–100, –100）和（100, 100）处。
- en: Modify *triangle.py* so that the three sides of the triangle are red with a
    thickness of 3\.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*triangle.py*，使得三角形的三条边为红色，边宽为3\。
- en: Replicate the result in *rectangle.py* by using `goto()`. You aren’t allowed
    to use the functions `forward()`, `backward()`, `left()`, or `right()`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`goto()`函数来复制*rectangle.py*中的结果。你不能使用`forward()`、`backward()`、`left()`或`right()`等函数。
- en: '10'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Tic-Tac-Toe
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋
- en: '![](Images/chapterart.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll build a voice-controlled tic-tac-toe game to put all
    your new skills into practice. You’ll draw a game board with blue and white game
    pieces, disallow invalid moves, and detect if a player has won. You’ll then add
    the speech recognition and text-to-speech functionality and set the game so you
    play with your own computer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将构建一个语音控制的井字棋游戏，将你所有的新技能付诸实践。你将绘制一个带有蓝色和白色棋子的游戏棋盘，禁止无效的移动，并检测玩家是否获胜。接着，你会添加语音识别和文本转语音功能，并设置游戏，让你与自己的电脑进行对战。
- en: As usual, all scripts in this chapter are available at the book’s resources
    page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Before you begin, set up the folder */mpt/ch10/* for this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，本章的所有脚本都可以在本书的资源页面上找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。在开始之前，设置本章的文件夹*/mpt/ch10/*。
- en: Game Rules
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: Tic-tac-toe is probably one of the most well-known games in the world, but just
    to be sure, I’ll go over the rules before we create our game board. In tic-tac-toe,
    two players take turns marking a cell with an X or O in a three-by-three grid.
    The first player to connect three Xs or Os in a row horizontally, vertically,
    or diagonally wins. If no one connects three before all the cells are full, the
    game is tied. Instead of X and O, we’ll use blue and white dots as game pieces.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋可能是世界上最著名的游戏之一，但为了确保，我们在创建游戏棋盘之前先复习一下规则。在井字棋中，两个玩家轮流在一个三乘三的网格中标记一个格子，标记为X或O。第一个将三个X或O连成一排（横向、纵向或对角线）的人获胜。如果在所有格子填满之前没有人连成三个，游戏将以平局结束。我们将用蓝色和白色的点代替X和O作为棋子。
- en: Draw the Game Board
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制游戏棋盘
- en: We’ll draw a three-by-three grid on the screen and assign a number to each cell
    so we can tell the script where to place each game piece. Open your Spyder editor,
    copy the code in [Listing 10-1](#listing10-1), and save the script as *ttt_board.py*
    in your chapter folder.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕上绘制一个三乘三的网格，并为每个单元格分配一个编号，以便告诉脚本在哪里放置每个棋子。打开你的 Spyder 编辑器，复制 [清单 10-1](#listing10-1)
    中的代码，并将脚本保存为 *ttt_board.py*，存放在你的章节文件夹中。
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10-1: Drawing the tic-tac-toe game board'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-1：绘制井字游戏棋盘
- en: We import all functions in the *turtle* module and set the screen to 600 by
    600 pixels. Because we have a three-by-three grid, each cell is 200 by 200 pixels.
    We set the background color to red and set the title as `Tic-Tac-Toe in Turtle
    Graphics`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 *turtle* 模块中的所有函数，并将屏幕设置为 600 像素 × 600 像素。由于我们有一个三乘三的网格，因此每个单元格的大小是 200
    像素 × 200 像素。我们将背景色设置为红色，并将标题设置为 `Tic-Tac-Toe in Turtle Graphics`。
- en: With the command `for i in (-100, 100)`, we iterate the variable `i` through
    the range –100 to 100 1. As a result, the `for` loop produces two horizontal lines
    and two vertical lines. The two horizontal lines are between points (–300, –100)
    and (300, –100) and points (–300, 100) and (300, 100). The two vertical lines
    are between points (–100, –300) and (–100, 300) and points (100, –300) and (100,
    300). These lines evenly divide the screen into nine cells.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 `for i in (-100, 100)`，我们将变量 `i` 在范围 -100 到 100 之间进行迭代。结果，`for` 循环产生了两条水平线和两条垂直线。两条水平线分别位于点
    (–300, –100) 和 (300, –100)，以及点 (–300, 100) 和 (300, 100) 之间。两条垂直线分别位于点 (–100, –300)
    和 (–100, 300)，以及点 (100, –300) 和 (100, 300) 之间。这些线均匀地将屏幕分成了九个单元格。
- en: We then create a dictionary `cellcenter` to map each cell number to the x- and
    y-coordinates of the center of the corresponding cell 2. For example, the lower-left
    cell is cell number 1, and the coordinates of its center are (x = –200, y = –200).
    We do this for all nine cells in the dictionary, using the cell number as the
    key and the coordinates as the value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个字典 `cellcenter`，将每个单元格编号映射到相应单元格中心的 x 和 y 坐标。例如，左下角的单元格是单元格编号 1，它的中心坐标是
    (x = –200, y = –200)。我们为字典中的所有九个单元格执行相同操作，使用单元格编号作为键，坐标作为值。
- en: 'At 3, we use the `for` loop to iterate through nine pairs of values to write
    the cell number at the cell’s center. The command `list(cellcenter.items())` produces
    a list of the nine key-and-value pairs from `cellcenter`, which should look like
    this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步，我们使用 `for` 循环迭代九对值，在每个单元格的中心写入单元格编号。命令 `list(cellcenter.items())` 会生成一个包含来自
    `cellcenter` 的九个键值对的列表，结果应该如下所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At each iteration of the `for` loop, the turtle goes to the center of the cell
    and writes the cell number there. Run the script and you should see a screen similar
    to [Figure 10-1](#figure10-1).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代 `for` 循环时，海龟会移动到单元格的中心，并在那里写下单元格编号。运行脚本后，你应该能看到类似于 [图 10-1](#figure10-1)
    的屏幕。
- en: '![f10001](Images/f10001.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](Images/f10001.png)'
- en: 'Figure 10-1: The board for tic-tac-toe'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：井字游戏的棋盘
- en: Create the Game Pieces
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏棋子
- en: Now we’ll add code to place game pieces in the cells. You’ll first learn how
    mouse clicks work in the *turtle* module and then use them to place the pieces.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加代码，将游戏棋子放置到单元格中。你将首先了解鼠标点击在 *turtle* 模块中的工作原理，然后使用它们来放置棋子。
- en: How Mouse Clicks Work in turtle
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标点击在 turtle 中的工作原理
- en: When you left-click on the turtle screen, the x- and y-coordinates of the point
    you clicked are displayed onscreen. [Listing 10-2](#listing10-2), *mouse_click.py*,
    handles a simple mouse click. This is just for example purposes; we won’t use
    this code in the final script but will use the same principles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 turtle 屏幕上左键点击时，点击位置的 x 和 y 坐标会显示在屏幕上。[清单 10-2](#listing10-2) 中的 *mouse_click.py*
    处理一个简单的鼠标点击事件。这只是示范用的代码；我们不会在最终的脚本中使用这段代码，但会使用相同的原理。
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-2: How mouse clicks work in the *turtle* module'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-2：鼠标点击在 *turtle* 模块中的工作原理
- en: As usual, we import the *turtle* module and set up the screen. At 1, we define
    the function `get_xy()`, which prints out the x- and y-coordinates of your click.
    We also hide the turtle so you don’t see the cursor moving around the screen.
    At 2, we bind the onscreen mouse click to the `get_xy()` function by using the
    *turtle* function `onscreenclick()`, which returns the x- and y-coordinates of
    the click. As a result, `onscreenclick(get_xy)` supplies the x- and y-coordinates
    of your mouse click to `get_xy()` as its two inputs. At 3, we use `listen()` to
    detect events like mouse clicks and keyboard presses.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们导入 *turtle* 模块并设置屏幕。在第1步中，我们定义了函数 `get_xy()`，它会输出你点击的 x 和 y 坐标。我们还隐藏了海龟图形，这样你就不会看到光标在屏幕上移动了。在第2步中，我们使用
    *turtle* 的 `onscreenclick()` 函数将屏幕上的鼠标点击绑定到 `get_xy()` 函数，该函数返回点击的 x 和 y 坐标。因此，`onscreenclick(get_xy)`
    将鼠标点击的 x 和 y 坐标作为输入传递给 `get_xy()`。在第3步中，我们使用 `listen()` 来检测诸如鼠标点击和键盘按键等事件。
- en: 'Run *mouse_click.py*, randomly click the screen several times, and you should
    see something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *mouse_click.py*，随机点击屏幕几次，你应该会看到类似这样的输出：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For each of my five clicks, `onscreenclick()` captured the x- and y-coordinates
    of the point and provided the two values to `get_xy()`, which printed out the
    corresponding x- and y-values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我五次点击中，`onscreenclick()` 捕捉到了点击点的 x 和 y 坐标，并将这两个值提供给 `get_xy()`，后者打印出了相应的 x
    和 y 值。
- en: Convert Mouse Clicks to Cell Numbers
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将鼠标点击转换为单元格编号
- en: Next, we’ll combine the board creation and click detection scripts so that when
    you click a cell, the script prints out the cell number. In [Figure 10-2](#figure10-2),
    I’ve marked the row and column numbers on the game board along with the x- and
    y-coordinates of the gridlines.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将棋盘创建和点击检测脚本结合起来，这样当你点击一个单元格时，脚本会输出单元格编号。在[图 10-2](#figure10-2)中，我在游戏棋盘上标出了行和列的编号，以及网格线的
    x 和 y 坐标。
- en: Open *ttt_board.py*, add the code in [Listing 10-3](#listing10-3) at the bottom
    (above `t.done()`) and save the new script as *cell_number.py* in your chapter
    folder. This script is just an example; we won’t use it in the final code but
    will use something similar.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *ttt_board.py*，在底部（`t.done()` 之前）添加[列表 10-3](#listing10-3)中的代码，并将新的脚本保存为
    *cell_number.py* 到你的章节文件夹中。这个脚本只是一个示例，我们在最终的代码中不会使用它，但会使用类似的代码。
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-3: Converting mouse clicks to cell numbers'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-3：将鼠标点击转换为单元格编号
- en: '![f10002](Images/f10002.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![f10002](Images/f10002.png)'
- en: 'Figure 10-2: Mark the row and column numbers on the game board.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：在游戏棋盘上标出行和列的编号。
- en: At 1, we define `cell_number()`, which will convert the x- and y-coordinates
    of the mouse click to the cell number. Inside the function, we restrict the x-
    and y-coordinates of the point you click to the range of the board. If you click
    outside the range, the script will print `you have clicked outside the game board`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们定义了 `cell_number()`，该函数将鼠标点击的 x 和 y 坐标转换为单元格编号。在函数内部，我们将你点击的点的 x 和 y
    坐标限制在棋盘的范围内。如果你点击的地方超出了范围，脚本会输出 `you have clicked outside the game board`。
- en: At 2, we convert the x-coordinate of the click to the column number. Points
    in column 1 have x-coordinates between –300 and –100, and points in column 2 have
    x-coordinates between –100 and 100, so we use the formula `col = int((x+500)//200)`
    to get the full range of pixel coordinates in the column so we can convert the
    x-coordinate to the column number. We use the same method to convert the y-coordinate
    to the row number.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步，我们将点击的 x 坐标转换为列号。第一列的点的 x 坐标在 -300 到 -100 之间，第二列的点的 x 坐标在 -100 到 100 之间，因此我们使用公式
    `col = int((x+500)//200)` 来获取列中像素坐标的完整范围，从而将 x 坐标转换为列号。我们使用相同的方法将 y 坐标转换为行号。
- en: We then calculate the cell number by using the formula `cellnumber = col+(row-1)*3`
    because the cell numbers increase from left to right and then from bottom to top
    3. Finally, we bind the onscreen click to `cell_number()`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用公式 `cellnumber = col+(row-1)*3` 来计算单元格编号，因为单元格编号是从左到右、从下到上增加的。最后，我们将屏幕点击事件绑定到
    `cell_number()`。
- en: 'Run *cell_number.py*. Here’s the output from one exchange with the script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *cell_number.py*。以下是与脚本交互的一次输出：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each time you click a cell, the script prints out the column number, row number,
    and cell number.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击单元格时，脚本会输出列号、行号和单元格编号。
- en: Place Game Pieces
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 放置游戏棋子
- en: Next, we’ll place the game pieces on the board. When you first click any of
    the nine cells, a blue piece will appear at the center of the cell. When you click
    again, the piece will be white, then blue, and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把棋子放到棋盘上。当你第一次点击任何一个单元格时，一个蓝色棋子会出现在单元格的中心。再点击一次，棋子会变成白色，然后是蓝色，如此交替。
- en: Open *ttt_board.py*, add the code in [Listing 10-4](#listing10-4), and save
    the new script as *mark_cell.py* in your chapter folder. Make sure you don’t add
    this code snippet to *cell_number.py*!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*ttt_board.py*，添加[列表 10-4](#listing10-4)中的代码，并将新脚本保存为*mark_cell.py*，保存在你的章节文件夹中。确保不要把这段代码加入到*cell_number.py*中！
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-4: Placing game pieces on the board'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-4：在棋盘上放置棋子
- en: We draw the board and then define the variable `turn` that will keep track of
    whose turn it is. We first assign the value `blue` to the variable so that the
    blue player moves first.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先绘制棋盘，然后定义变量`turn`来跟踪轮到谁走棋。我们首先将`blue`赋值给该变量，这样蓝色玩家就会先走。
- en: 'At 1, we define `mark_cell()`, which places a piece in the cell you click.
    At 2, we declare the global variable `turn`. Python provides the `global` keyword,
    which allows `turn` to be used both inside and outside `mark_cell()`. Without
    making the variable global, you’d get the error message `UnboundLocalError: local
    variable ''turn'' referenced before assignment` each time you clicked the board.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '在第1步，我们定义了`mark_cell()`，它会在你点击的单元格中放置棋子。在第2步，我们声明了全局变量`turn`。Python 提供了`global`关键字，允许`turn`在`mark_cell()`函数内外都能使用。如果没有将变量声明为全局变量，每次点击棋盘时，你都会看到错误信息`UnboundLocalError:
    local variable ''turn'' referenced before assignment`。'
- en: We then convert the x- and y-coordinates of the click to the cell number on
    the game board 3. Within the same line, we also convert the cell number from an
    integer to a string to match the variable type used in the dictionary `cellcenter`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将点击的 x 和 y 坐标转换为棋盘上的单元格编号 3。在同一行内，我们还将单元格编号从整数转换为字符串，以匹配字典`cellcenter`中使用的变量类型。
- en: At 4, we get the coordinates for the center of the clicked cell from `cellcenter`
    and tell the turtle to go there. The turtle places a dot 180 pixels wide and the
    color of the value stored in `turn`. After that, the turn is over, and we assign
    the turn to the other player. Finally, we bind `mark_cell()` to the mouse-click
    event.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，我们从`cellcenter`获取被点击单元格的中心坐标，并告诉海龟到达该位置。海龟会绘制一个180像素宽的点，颜色为`turn`中存储的值。然后，轮到另一个玩家。最后，我们将`mark_cell()`绑定到鼠标点击事件上。
- en: Run the script and you’ll be able to click the board and mark the cell. The
    color of the dot will alternate between blue and white, as in [Figure 10-3](#figure10-3).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你就可以点击棋盘并标记单元格了。点的颜色会在蓝色和白色之间交替，如[图 10-3](#figure10-3)所示。
- en: '![f10003](Images/f10003.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![f10003](Images/f10003.png)'
- en: 'Figure 10-3: Mark cells on the tic-tac-toe board.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：在井字棋盘上标记单元格。
- en: 'The script is now a playable game! However, we need to implement three new
    rules to make it follow the rules of tic-tac-toe:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本已经可以进行游戏了！不过，我们需要实现三个新规则，以使其符合井字游戏的规则：
- en: If a cell is already occupied, you cannot mark it again.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个单元格已经被占用，你就不能再次标记它。
- en: If a player marks three cells in a straight line—either horizontally, vertically,
    or diagonally—the player wins, and the game should stop.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在一条直线上——无论是水平、垂直还是对角线——标记了三个单元格，则该玩家获胜，游戏应该停止。
- en: If all nine cells are occupied, the game should stop, and a tie should be called
    if no player wins.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有九个单元格都被占用，游戏应该停止，如果没有玩家获胜，则判定为平局。
- en: Determine Valid Moves, Wins, and Ties
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定有效的移动、胜利和平局
- en: Next, we’ll implement those rules, allowing only valid moves and declaring wins
    (or ties). Download *ttt_click.py* from the book’s resources and save it in your
    chapter folder or alter *mark_cell.py* with the differences highlighted in [Listing
    10-5](#listing10-5).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现这些规则，仅允许有效的移动，并判定胜利（或平局）。从书籍资源中下载*ttt_click.py*并将其保存到章节文件夹中，或者根据[列表
    10-5](#listing10-5)中的不同之处修改*mark_cell.py*。
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-5: Allow only valid moves and declare wins and ties.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5：仅允许有效的移动并判定胜利和平局。
- en: Our first change is to import the *messagebox* module from the *tkinter* package;
    this module displays a message box for a win, tie, or invalid move.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个修改是从*tkinter*包中导入*messagebox*模块；这个模块会显示一个消息框，用于显示胜利、平局或无效的移动。
- en: Starting at 1, we create a variable `rounds`, a list `validinputs`, and a dictionary
    `occupied`. The variable `rounds` keeps track of the number of turns taken, which
    is the number of cells that have been marked. When the number of rounds reaches
    nine and no player wins (which is often the case in tic-tac-toe), we’ll declare
    a tie game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1行开始，我们创建了一个变量`rounds`、一个列表`validinputs`和一个字典`occupied`。变量`rounds`用于跟踪已进行的回合数，也就是已标记的单元格数。当回合数达到9且没有玩家获胜（在井字棋中这通常发生），我们将宣布平局。
- en: We use `validinputs` to determine whether a move is valid. If a cell is marked
    by a player, we’ll remove it from the list of valid moves.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`validinputs`来判断一个移动是否有效。如果一个单元格已被玩家标记，我们将把它从有效移动列表中移除。
- en: The dictionary `occupied` keeps track of each player’s moves. At the beginning
    of the game, the keys `blue` and `white` both have an empty list as their value.
    When a player occupies a cell, the cell number will be added to that player’s
    list. For example, if the blue player has occupied cells 1, 5, and 9 and the white
    player has occupied cells 3 and 7, `occupied` will become `{"blue":["1","5","9"],"white":["3","7"]}`.
    We’ll use this later to determine whether a player has won the game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 字典`occupied`跟踪每个玩家的移动。在游戏开始时，键`blue`和`white`的值都是空列表。当玩家占据一个单元格时，该单元格编号将被添加到该玩家的列表中。例如，如果蓝色玩家占据了单元格1、5和9，白色玩家占据了单元格3和7，`occupied`将变为`{"blue":["1","5","9"],"white":["3","7"]}`。我们稍后将使用它来确定玩家是否获胜。
- en: 'At 2, we define `win_game()`, which checks whether a player has won the game.
    There are eight ways a player can win, which we explicitly check for:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们定义了`win_game()`函数，用于检查玩家是否获胜。玩家可以通过八种方式获胜，我们将明确检查这些方式：
- en: Cells 1, 2, and 3 have been occupied by the same player.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格1、2和3已被同一玩家占据。
- en: Cells 4, 5, and 6 have been occupied by the same player.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格4、5和6已被同一玩家占据。
- en: Cells 7, 8, and 9 have been occupied by the same player.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格7、8和9已被同一玩家占据。
- en: Cells 1, 4, and 7 have been occupied by the same player.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格1、4和7已被同一玩家占据。
- en: Cells 2, 5, and 8 have been occupied by the same player.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格2、5和8已被同一玩家占据。
- en: Cells 3, 6, and 9 have been occupied by the same player.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格3、6和9已被同一玩家占据。
- en: Cells 1, 5, and 9 have been occupied by the same player.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格1、5和9已被同一玩家占据。
- en: Cells 3, 5, and 7 have been occupied by the same player.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格3、5和7已被同一玩家占据。
- en: The function `win_game()` creates the variable `win` and assigns `False` as
    a default value. The function checks the dictionary `occupied` for the list of
    cells occupied by the player who currently has the turn, checking all eight win
    cases listed earlier. If one of the cases matches, the value `win` changes to
    `True`. When `win_game()` is called, it returns the value stored in the variable
    `win`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`win_game()`创建了变量`win`，并将其默认值设置为`False`。该函数检查字典`occupied`，获取当前轮到的玩家占据的单元格列表，并检查之前列出的八种获胜情况。如果其中一种情况匹配，`win`的值将变为`True`。当调用`win_game()`时，它返回存储在变量`win`中的值。
- en: We’ve made significant changes to `mark_cell()`. At 3, we declare three global
    variables; all must be declared global because they will be modified inside the
    function. At 4, we check whether the cell number most recently clicked is in the
    list `validinputs`; if it is, a dot is placed in the cell, and the cell number
    is added to the player’s list of occupied cells 5. The cell is then removed from
    `validinputs` so that players can’t mark the same cell in future rounds.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`mark_cell()`做了重大修改。在第3行，我们声明了三个全局变量；所有这些都必须声明为全局变量，因为它们将在函数内部被修改。在第4行，我们检查最近点击的单元格编号是否在`validinputs`列表中；如果在，则该单元格上会标记一个点，且该单元格编号会被添加到玩家的占据单元格列表中。然后，单元格会从`validinputs`中移除，以防止玩家在未来的回合中再次标记该单元格。
- en: At 6, we call `win_game()` and see whether the current player has won the game.
    If yes, we change `validinputs` to an empty list so no further moves can be made.
    A message box will pop up to say, `Congrats player blue, you won!` or `Congrats
    player white, you won!`, using `showinfo()` from the *messagebox* module ([Figure
    10-4](#figure10-4)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我们调用`win_game()`，查看当前玩家是否获胜。如果获胜，我们将`validinputs`清空，这样就不能再进行任何移动。弹出一个消息框，显示`恭喜蓝色玩家，你获胜了！`或`恭喜白色玩家，你获胜了！`，并使用*messagebox*模块的`showinfo()`函数（见[图10-4](#figure10-4)）。
- en: '![f10004](Images/f10004.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![f10004](Images/f10004.png)'
- en: 'Figure 10-4: A win for blue!'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-4：蓝色玩家获胜！
- en: If the player hasn’t won, the script checks whether the number of rounds has
    reached nine 7. If yes, the script declares a tie game, displaying `Game over,
    it's a tie!` ([Figure 10-5](#figure10-5)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有获胜，脚本会检查回合数是否达到了九回合（7）。如果是，脚本会宣布平局，显示`游戏结束，平局！`（[图 10-5](#figure10-5)）。
- en: '![f10005](Images/f10005.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![f10005](Images/f10005.png)'
- en: 'Figure 10-5: A tied game'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：平局
- en: If the game doesn’t end, we increase the number of rounds by one and assign
    the turn to the other player. During the game, if a player clicks an invalid cell,
    we’ll display `Sorry, that's an invalid move!` ([Figure 10-6](#figure10-6)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏没有结束，我们将增加回合数，并把回合交给另一个玩家。在游戏过程中，如果玩家点击了一个无效的格子，我们会显示`抱歉，那是一个无效的动作！`（[图
    10-6](#figure10-6)）。
- en: '![f10006](Images/f10006.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![f10006](Images/f10006.png)'
- en: 'Figure 10-6: An invalid move'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：无效的动作
- en: Voice-Controlled Version
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音控制版本
- en: Now we’re ready to add the voice control and speech functionality. One significant
    change is that we’ll now make your opponent your computer. We’ll build on the
    latest *ttt_click.py* file. After you make a move as the blue player, the computer
    will randomly select a move as the white player until the game ends.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好添加语音控制和语音功能了。一个显著的变化是，我们将对手设置为计算机。我们将基于最新的*ttt_click.py*文件进行构建。在你作为蓝色玩家走完一步后，计算机会随机选择一个动作作为白色玩家，直到游戏结束。
- en: Download *ttt_hs.py* from the book’s resources or make the changes shown in
    [Listing 10-6](#listing10-6).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从书本资源中下载*ttt_hs.py*，或按照[列表 10-6](#listing10-6)中的修改内容进行调整。
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-6: Adding speech and voice-control functionality'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-6：添加语音和语音控制功能
- en: 'We import the functions we’ll need: the `choice()` function from the *random*
    module to let the computer randomly select a move and our `print_say()` and `voice_to_text()`
    functions from the custom package *mptpkg*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入所需的函数：从*random*模块导入`choice()`函数，让计算机随机选择一个动作，以及从自定义包*mptpkg*导入我们的`print_say()`和`voice_to_text()`函数。
- en: At 1, we start an infinite `while` loop. At each iteration, the script asks
    for your move out loud. You speak into the microphone to make your move, and the
    script captures your voice command, storing the response in the variable `inp`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1 处，我们开始了一个无限的`while`循环。在每次循环中，脚本都会大声询问你的动作。你对着麦克风说出你的动作，脚本捕捉到你的语音命令，将回应存储在变量`inp`中。
- en: 'Here we did a little tweaking to make `voice_to_text()` more responsive to
    your voice commands. When your voice input is just one word, such as “One” or
    “Two,” it’s hard for the software to put the word in context and respond. On the
    other hand, if you say “Number one” or “Number two,” the software can easily pick
    up your meaning. The script simply replaces the “number” part of the voice command
    with an empty string so that only the number is left in `inp`. Sometimes `voice_to_text()`
    returns the number in word form such as `one` or `two`, instead of in numeric
    form, such as `1` or `2`. We therefore also change all the word forms to numerical
    forms. This way, you can say “number one” or “one” to the microphone, and `inp`
    will always be in the form you want: `1`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们对`voice_to_text()`做了一些调整，使其更能响应你的语音命令。当你的语音输入只有一个词时，比如“One”或“Two”，软件很难理解该词的上下文并作出反应。另一方面，如果你说“Number
    one”或“Number two”，软件就能轻松理解你的意思。脚本简单地将语音命令中的“number”部分替换为空字符串，这样`inp`中就只剩下数字部分。有时`voice_to_text()`返回的是文字形式的数字，比如`one`或`two`，而不是数字形式，比如`1`或`2`。因此，我们还将所有的文字形式转换为数字形式。这样，你可以对着麦克风说“number
    one”或“one”，`inp`将始终是你想要的形式：`1`。
- en: 'If your choice is in `validinputs`, the script performs the sequence of actions
    to make the move: place a dot in the corresponding cell, add the cell number to
    your list of occupied cells, and remove the occupied cell number from the list
    of valid inputs.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的选择在`validinputs`中，脚本将执行一系列动作来完成这一步：在相应的格子中放置一个圆点，将该格子的编号添加到你占据的格子列表中，并从有效输入的列表中移除该格子的编号。
- en: The script then checks if you’ve won or tied the game 2 and responds out loud
    appropriately.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接着检查你是否赢得了比赛或是否平局，并适当地大声回应。
- en: Once your turn is over, the computer randomly selects a move from `validinputs`
    to play against you 3. The script checks whether the computer has won or tied
    the game. If your voice command is not a valid move, the script speaks an alert.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的回合结束，计算机会从`validinputs`中随机选择一个动作与您对抗。脚本会检查计算机是否赢得了比赛或是否平局。如果你的语音命令不是有效的动作，脚本会发出警告。
- en: 'Here’s one interaction with the game:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与游戏的一次互动：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I’ve managed to win in just three moves!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在三步内赢得了比赛！
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to build a voice-controlled graphical tic-tac-toe
    game that talks in a human voice. Along the way, you learned a few new skills.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了构建一个语音控制的图形井字游戏，它能够用人声进行对话。在这个过程中，你掌握了一些新技能。
- en: You learned how mouse clicks work in the *turtle* module. With that knowledge,
    we marked cells on the game board with mouse clicks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何在*turtle*模块中处理鼠标点击。凭借这一知识，你在游戏棋盘上通过鼠标点击来标记单元格。
- en: You learned how to determine whether a player has won tic-tac-toe based on the
    explicit game rules. This is at the heart of game creation. You listed all cases
    when a player can win the game, then added code to check all cases and see whether
    there is a winner.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何根据明确的游戏规则判断玩家是否赢得了井字游戏。这是游戏创建的核心。你列出了所有玩家可以获胜的情况，然后添加了代码来检查所有这些情况并判断是否有赢家。
- en: You also added the speech recognition and text-to-speech features to a game,
    making a few tweaks to make sure the script can understand your input. By combining
    these skills, you’ll be able to create your own voice-controlled games.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将语音识别和文本转语音功能添加到了游戏中，进行了一些调整，以确保脚本能够理解你的输入。通过结合这些技能，你将能够创建自己的语音控制游戏。
- en: End-of-Chapter Exercises
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Modify *ttt_board.py* so that the cell number appears in 15-point font at the
    lower-left corner of each cell (80 pixels from the center of the cell, both horizontally
    and vertically).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*ttt_board.py*，使得单元格编号出现在每个单元格的左下角，字体大小为15点（从单元格中心水平和垂直偏移80像素）。
- en: Modify *mouse_click.py* so that each time you click the screen, the script prints
    out the additional message `x + y is`, followed by the actual value of the x-
    and y-coordinates of the clicked point.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*mouse_click.py*，使得每次点击屏幕时，脚本输出附加信息`x + y is`，后面跟着点击点的x和y坐标的实际值。
- en: Modify *cell_number.py* so that each time you click the screen, the script prints
    `you clicked the point (``x``,` `y``)` before printing the column, row, and cell
    numbers, where `x` and `y` are the actual coordinates. For example, if you click
    the point (x = –100, y = 50), the message should say `you clicked the point (-100,
    50)`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*cell_number.py*，使得每次点击屏幕时，脚本输出`you clicked the point (``x``,` `y``)`，然后再输出列、行和单元格编号，其中`x`和`y`是实际坐标。例如，如果你点击的是(x
    = –100, y = 50)的点，信息应显示为`you clicked the point (-100, 50)`。
- en: Modify *mark_cell.py* so that the white player moves first.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*mark_cell.py*，使得白色玩家先手。
- en: Modify *ttt_click.py* so that a player wins only by marking three cells in a
    row horizontally or vertically, but not diagonally.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*ttt_click.py*，使得玩家只有通过横向或纵向连续标记三个单元格才能获胜，但不能通过对角线获胜。
- en: '11'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Connect Four
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 四子棋
- en: '![](Images/chapterart.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll build a voice-controlled Connect Four game. As with
    tic-tac-toe in Chapter 10, you’ll first draw the board and set the yellow and
    red game pieces to alternate turns. You’ll animate the effect of a disc falling
    from the top of a column to the lowest available row to make the game more visually
    engaging. You’ll disallow invalid moves, detect if a player has won, and detect
    if all 42 cells have been occupied with no winner, meaning the game is tied.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个语音控制的四子棋游戏。与第10章中的井字游戏相似，你将首先绘制棋盘并设置黄色和红色棋子交替轮流。你还将为棋子从列的顶部落下到最底层空白行的过程添加动画效果，使游戏更加具有视觉吸引力。你将禁止无效的移动，检测玩家是否获胜，并检测是否所有42个单元格都已被占满而没有赢家，意味着游戏平局。
- en: In Chapter 10, you learned how to check whether a player has won the game by
    laying out all winning scenarios and checking whether the current game board matches
    one of the scenarios. We’ll apply that same strategy here. You’ll also learn how
    to use exception handling to prevent crashing during the process of checking and
    how to prevent negative indexing errors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，你学会了如何通过列出所有的获胜情形，并检查当前的游戏棋盘是否符合其中一种情形，从而判断玩家是否获胜。我们将在这里应用同样的策略。你还将学习如何使用异常处理来防止在检查过程中崩溃，以及如何避免负索引错误。
- en: Once the game is set up, we’ll add the speech recognition and text-to-speech
    features so you can play the game with your voice alone.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏设置完成，我们将添加语音识别和文本转语音功能，让你仅凭声音就能玩游戏。
- en: To start, set up the folder */mpt/ch11/* for this chapter. All scripts in this
    chapter are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为本章设置文件夹*/mpt/ch11/*。本章的所有脚本可以通过本书的资源页面获取：[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Game Rules
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: Connect Four is a well-known board game, but I’ll go over the rules to clarify
    the logic in the upcoming code. In Connect Four, two players take turns dropping
    discs into one of seven columns, from the top. One player has red discs and the
    other yellow. The seven columns are on a six-row, vertically suspended grid. When
    a disc is dropped into a column, it will fall to the lowest available space in
    that column. Discs cannot move from one column to another.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 连接四子是一个著名的棋盘游戏，但为了澄清即将展示的代码逻辑，我会先介绍一下规则。在连接四子中，两名玩家轮流将棋子从顶部投放到七列中的一个。一个玩家使用红色棋子，另一个使用黄色棋子。七列位于一个六行的垂直悬挂网格上。当棋子被投放到某一列时，它会掉落到该列中最低的可用空间。棋子无法从一列移动到另一列。
- en: The first player who forms a direct line—either horizontally, vertically, or
    diagonally—with four of their game pieces wins. If all 42 slots have been filled
    and nobody has won, the game is tied. We’ll use a red dot and a yellow dot to
    represent the discs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个形成四个连续棋子（无论是横向、纵向还是对角线）的玩家获胜。如果42个格子都被填满且没有人获胜，游戏平局。我们将用红色圆点和黄色圆点来代表棋子。
- en: Draw the Game Board
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制游戏棋盘
- en: We first draw a grid with six rows and seven columns. We’ll number the columns
    at the top of the screen to make it easier to play.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先绘制一个六行七列的网格。我们将在屏幕顶部为每一列编号，方便玩家进行游戏。
- en: Open your Spyder editor and enter the code from [Listing 11-1](#listing11-1).
    Save the script as *conn_board.py* in your chapter folder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Spyder编辑器，输入[列表11-1](#listing11-1)中的代码。将脚本保存为*conn_board.py*，并放在你的章节文件夹中。
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-1: Drawing the Connect Four game board'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-1：绘制连接四子的游戏棋盘
- en: We first import all functions in the *turtle* module, and then we set up the
    screen as 700 by 600 pixels 1. That lets us make each cell 100 by 100 pixels to
    keep things simple. We set the background color to light green and the title to
    `Connect Four in Turtle Graphics`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入*turtle*模块中的所有函数，然后将屏幕设置为700x600像素。这使得我们可以将每个单元格设置为100x100像素，保持简单。我们将背景色设置为浅绿色，标题为`Connect
    Four in Turtle Graphics`。
- en: 'We then draw six thick vertical lines to divide the screen into seven columns.
    At 2, we set the pen width to 5 pixels. The command line `for i in range(-250,350,100)`
    tells the variable `i` to iterate through the following six values: –250, –150,
    –50, 50, 150, and 250\. These are the x-coordinates of the six vertical lines.
    The y-coordinates of the two endpoints of the six vertical lines are all –350
    and 350\. Similarly, we draw five thin, gray horizontal lines to divide the screen
    into six rows, starting at 3, with a pen size of 1 pixel and color of gray so
    that the lines appear thin and light. This all gives us an even grid with seven
    columns and six rows.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着画了六条粗的垂直线，将屏幕分成七列。在第2行，我们将画笔宽度设置为5像素。命令行`for i in range(-250,350,100)`让变量`i`遍历以下六个值：–250、–150、–50、50、150和250。这些是六条垂直线的x坐标。六条垂直线两个端点的y坐标都是–350和350。类似地，我们画了五条细的灰色横线，把屏幕分成六行。从第3行开始，画笔大小为1像素，颜色为灰色，这样线条看起来又细又轻。这就为我们提供了一个均匀的网格，包含七列六行。
- en: Next, we number the columns to let players know where to place the discs. We
    first create a variable `colnum` and assign a value `1` to it 4. We then iterate
    through the x-coordinates of the center of the seven columns and write the corresponding
    column number by adding one to the value of `colnum`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为列编号，以便玩家知道将棋子放在哪一列。我们首先创建一个变量`colnum`并赋值为`1`。然后我们遍历七列中心的x坐标，并通过将`colnum`的值加一来写出相应的列号。
- en: Run the script and you should see a screen like [Figure 11-1](#figure11-1).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该能看到类似于[图11-1](#figure11-1)的画面。
- en: '![f11001](Images/f11001.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![f11001](Images/f11001.png)'
- en: 'Figure 11-1: The board for the Connect Four game'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：连接四子游戏的棋盘
- en: The Mouse-Click Version
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标点击版
- en: Now you have a game board. Let’s drop some discs into the columns. In this section,
    you’ll learn how to use mouse clicks to place a disc in a column and let it fall
    to the lowest available cell. After that, you’ll detect invalid moves, wins, and
    ties.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个游戏棋盘。让我们把一些棋子投放到列中。在这一部分，你将学习如何使用鼠标点击将棋子放入某一列，并让它掉落到最低可用的单元格。之后，你将检测无效的操作、胜利和平局。
- en: Drop a Disc
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投放棋子
- en: Here, you’ll use mouse clicks to place a disc in a column of your choice. The
    column number in which the disc will appear is determined by where you click.
    The row number depends on the number of discs already in that column.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将使用鼠标点击将棋子放入你选择的列中。棋子所在的列由你点击的位置决定。行号则取决于该列中已有的棋子数量。
- en: When you first click a column, a red dot will be placed in the lowest available
    cell. The colors will alternate with each click.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次点击一列时，红色的圆点将被放置在该列最底部可用的单元格中。每次点击时，颜色将交替变化。
- en: Open *conn_board.py* and add the code in [Listing 11-2](#listing11-2). Then
    save the new script as *show_disc.py* in your chapter folder.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*conn_board.py*并添加[Listing 11-2](#listing11-2)中的代码。然后将新的脚本保存为*show_disc.py*，并放入你的章节文件夹中。
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-2: Dropping discs on the game board'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-2: 在棋盘上放置棋子'
- en: The red player goes first, so after the game board is drawn, we define the variable
    `turn` and assign the value `red` to it 1. Starting at 2, we define three lists.
    The list `xs` contains values corresponding to the x-coordinates of the middle
    points of the seven columns. The list `ys` has six values corresponding to the
    y-coordinates of the middle points of the six rows. Later, we’ll use these lists
    to determine the x- and y-coordinates of the center of all 42 cells.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 红色玩家先行，所以在绘制完棋盘后，我们定义了变量`turn`并将值`red`赋给它1。从第2行开始，我们定义了三个列表。列表`xs`包含与七列中点的x坐标对应的值。列表`ys`包含与六行中点的y坐标对应的六个值。稍后，我们将使用这些列表来确定所有42个单元格中心的x和y坐标。
- en: The list `occupied` is a list of lists. It starts as a list of seven empty lists,
    each representing a column. When you place a disc in a column, the disc will be
    added to the corresponding list. This way, `occupied` will keep track of all discs
    placed and their positions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`occupied`是一个列表的列表。它一开始是一个包含七个空列表的列表，每个列表代表一列。当你将棋子放置到某列时，棋子将被添加到对应的列表中。这样，`occupied`将追踪所有已放置的棋子及其位置。
- en: At 3, we define `conn()`, which places the disc on the column you click. We
    declare `turn` as a global variable, so that its value can be recognized both
    inside and outside `conn()`. Then, we convert the x-coordinate of the user’s click
    to the column number on the game board. We then determine the lowest row available
    in that column, which tells us which row to place the disc in. Note that `occupied[col-1]`
    is the list of all discs currently in the column, and we use `col-1` instead of
    `col` because Python uses zero indexing but our columns are numbered starting
    at 1\.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们定义了`conn()`，它将棋子放置在你点击的列上。我们将`turn`声明为全局变量，这样它的值在`conn()`内外都能被识别。接着，我们将用户点击的x坐标转换为棋盘上的列号。然后，我们确定该列中最底部可用的行，这告诉我们应该将棋子放置在哪一行。请注意，`occupied[col-1]`是该列中当前所有棋子的列表，我们使用`col-1`而不是`col`，因为Python使用零索引，但我们的列是从1开始编号的。
- en: We then obtain the x- and y-coordinates of the center of the cell in which to
    place the new disc. The *turtle* module places a dot with a diameter of 80 pixels
    and the color value stored in `turn`. We add the disc to the corresponding list
    within `occupied` so that next time a disc is placed in the same column, the appropriate
    cell is marked as invalid. With this, the player’s turn is over, and we hand the
    turn to the other player. Finally, we bind `conn()` to the mouse-click event.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取要放置新棋子的单元格中心的x和y坐标。*turtle*模块会以直径为80像素的大小放置一个圆点，颜色值为`turn`中存储的颜色。我们将棋子添加到`occupied`中的相应列表中，这样下次将棋子放置在同一列时，适当的单元格将被标记为无效。这样，玩家的回合就结束了，接着我们将回合交给另一位玩家。最后，我们将`conn()`绑定到鼠标点击事件上。
- en: Run the script, and you should be able to click on the game board and mark the
    cell with a red or yellow dot. Keep clicking, and the color of the dot will alternate
    between red and yellow ([Figure 11-2](#figure11-2)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该能够点击游戏棋盘，并用红色或黄色圆点标记单元格。继续点击，圆点的颜色将在红色和黄色之间交替变化（见[图 11-2](#figure11-2)）。
- en: '![f11002](Images/f11002.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![f11002](Images/f11002.png)'
- en: 'Figure 11-2: Place discs on the Connect Four game board.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：将棋子放置在四连棋的棋盘上。
- en: Animate the Falling Discs
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化掉落的棋子
- en: When you play Connect Four in the real world, you drop the disc at the top,
    and it falls into the proper position. Next, you’ll create the animation effect
    of the disc falling. This is a good opportunity to learn how to create animation
    effects using the *turtle* module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在现实世界中玩四连棋时，你将棋子从上方丢下，它会掉入适当的位置。接下来，你将创建棋子掉落的动画效果。这是一个很好的机会来学习如何使用*turtle*模块创建动画效果。
- en: Open *show_disc.py* and add the code in [Listing 11-3](#listing11-3). Save this
    as *disc_fall.py* in your chapter folder.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*show_disc.py*并添加[Listing 11-3](#listing11-3)中的代码。将其保存为*disc_fall.py*，并放入你的章节文件夹中。
- en: '[PRE23]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-3: Script to show the animation effect of discs falling'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-3: 显示棋子掉落动画效果的脚本'
- en: We import `sleep()` so we can pause the script to let the falling disc stay
    in a cell for a short while, allowing the user to see its movement 1. Starting
    at 2, we create a second turtle named `fall`. We lift the drawing pen of the new
    turtle so that it won’t leave a line as it moves. We also use `hideturtle()` to
    hide the cursor 3.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`sleep()`，以便在脚本中暂停，让下落的棋盘片在单元格中停留片刻，允许用户看到它的移动 1。接下来，从第 2 行开始，我们创建一个名为`fall`的第二个海龟（turtle）。我们抬起新海龟的画笔，这样它移动时就不会留下痕迹。同时，我们使用`hideturtle()`来隐藏光标
    3。
- en: Starting at 4, we animate the falling disc. We first see if the column is full
    by checking whether the row number is less than 6\. If yes, we’ll show the animation
    effect. If the lower rows in the column are full, the disc can be left in place
    (there’s no need to show the disc falling).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 4 行开始，我们动画化下落的棋盘片。首先，我们通过检查行号是否小于6来查看列是否已满。如果是的话，就显示动画效果。如果该列下方的行已经满了，棋盘片就可以停留在当前位置（无需展示棋盘片下落）。
- en: We iterate `i` through all the empty cells above the lowest available cell.
    If the lowest available position is `row = 2`, for example, the command `for i
    in range(6,row,-1)` iterates `i` through values 6, 5, 4, and 3\. The `-1` tells
    the range function to count backward. At each iteration, the `fall` turtle places
    a dot in the center of the empty cell. The script draws a dot to the screen, pauses
    for 0.05 seconds, and then erases the dot before going to the next iteration.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过迭代`i`遍历所有空单元格，直到最低可用单元格上方。如果最低可用位置是`row = 2`，例如，命令`for i in range(6,row,-1)`会将`i`依次设为
    6、5、4 和 3。`-1`告诉range函数按倒序计数。在每次迭代中，`fall`海龟会在空单元格的中心放置一个点。脚本在屏幕上绘制一个点，暂停0.05秒后再擦除该点，然后进入下一次迭代。
- en: 'The script is now a complete game! However, at the moment, players must use
    their own judgment to enforce the following rules:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本已经是一个完整的游戏了！然而，目前，玩家必须自行判断并遵守以下规则：
- en: If a column is already full, you cannot drop a disc in it.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某列已经满了，就不能再在该列放置棋盘片。
- en: If a player connects four cells in a straight line, that player wins, and the
    game should stop.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某个玩家将四个单元格连成一条直线，该玩家获胜，游戏应停止。
- en: If all 42 cells are occupied and nobody has won, the game should stop and a
    tie be declared.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有 42 个单元格都已占满且没有人获胜，游戏应停止并宣布平局。
- en: Let’s code that into the game.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些代码添加到游戏中。
- en: Determine Valid Moves, Wins, and Ties
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定有效移动、胜利和平局
- en: Next, we’ll improve the game by blocking invalid moves and declaring wins or
    ties. Open *disc_fall.py* and add the code in [Listing 11-4](#listing11-4). Save
    the new script as *conn_click.py*. The code changes are shown in two sections,
    so it’s easier to refer back to the code when reading the explanations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过阻止无效移动并声明胜利或平局来改进游戏。打开*disc_fall.py*并添加[清单 11-4](#listing11-4)中的代码。将新的脚本保存为*conn_click.py*。代码更改分为两个部分，便于在阅读解释时参考代码。
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 11-4: First half of the script to disallow invalid moves and declare
    wins and ties'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-4：脚本的前半部分，用于禁止无效移动并声明胜利和平局
- en: We import the *messagebox* module from the *tkinter* package to allow us to
    display messages about wins, ties, and invalid moves.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*tkinter*包中导入*messagebox*模块，以便在游戏中显示关于胜利、平局和无效移动的消息。
- en: At 1, we create the list `validinputs` to keep track of valid moves. All seven
    columns are valid to start with. If a column contains six discs, it will be removed
    from the list.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 行，我们创建了列表`validinputs`来跟踪有效的移动。最开始，所有七列都是有效的。如果某列已满六个棋盘片，它将从列表中移除。
- en: 'A player can win the game by collecting four discs in a row in one of four
    orientations: horizontally, vertically, diagonally in a forward-slash fashion
    (/), or diagonally in a backslash fashion (\). Therefore, we define four functions
    to check for each way of winning.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过在四个方向之一连成四个棋盘片来获胜：水平、垂直、斜向（/）或反斜向（\）。因此，我们定义了四个函数来检查每种获胜方式。
- en: At 2, we define `horizontal4()`, which checks if a player has won the game by
    successfully connecting four discs in a row horizontally. In the function, we
    create the variable `win` and assign a default value of `False`. The function
    then checks whether the player has connected four discs horizontally. If yes,
    the value of `win` changes to `True`. When the function `horizontal4()` is called,
    it returns the value stored in the variable `win`. Let’s look at the details of
    this function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2 处，我们定义了 `horizontal4()`，它检查玩家是否通过成功地将四个棋子水平连接成一排赢得游戏。在这个函数中，我们创建了变量 `win`
    并将其默认值设为 `False`。函数接着检查玩家是否将四个棋子水平连接成一排。如果是，`win` 的值会变为 `True`。当调用 `horizontal4()`
    函数时，它返回存储在变量 `win` 中的值。让我们来看一下这个函数的详细情况。
- en: We’ll use `x = col-1` and `y = row-1` to convert column and row numbers on the
    game board to indexes in the `occupied`list. The cell with column number `col`
    and row number `row` corresponds to `occupied[x][y]` in `occupied`. For simplicity,
    we’ll call this cell `[x][y]` for the rest of the chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `x = col-1` 和 `y = row-1` 将游戏板上的列号和行号转换为 `occupied` 列表中的索引。列号为 `col` 和行号为
    `row` 的单元格对应于 `occupied[x][y]`。为了简便起见，本章其余部分我们将称这个单元格为 `[x][y]`。
- en: 'A player can connect four pieces horizontally in four ways:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过四种方式将四个棋子水平连接：
- en: Cells `[x-3][y]`, `[x-2][y]`, and `[x-1][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格 `[x-3][y]`、`[x-2][y]` 和 `[x-1][y]` 的颜色与单元格 `[x][y]` 相同。
- en: Cells `[x-2][y]`, `[x-1][y]`, and `[x+1][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格 `[x-2][y]`、`[x-1][y]` 和 `[x+1][y]` 的颜色与单元格 `[x][y]` 相同。
- en: Cells `[x-1][y]`, `[x+1][y]`, and `[x+2][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格 `[x-1][y]`、`[x+1][y]` 和 `[x+2][y]` 的颜色与单元格 `[x][y]` 相同。
- en: Cells `[x+1][y]`, `[x+2][y]`, and `[x+3][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格 `[x+1][y]`、`[x+2][y]` 和 `[x+3][y]` 的颜色与单元格 `[x][y]` 相同。
- en: We therefore define a variable `dif` to iterate through four values `(-3, -2,
    -1, 0)`. For each value of `dif`, we check whether all four cells—`[x+dif][y]`,
    `[x+dif+1][y]`, `[x+dif+2][y]`, and `[x+dif+3][y]`—have the same color. If yes,
    we change the value of `win` to `True`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个变量 `dif` 来遍历四个值 `(-3, -2, -1, 0)`。对于每个 `dif` 的值，我们检查四个单元格——`[x+dif][y]`、`[x+dif+1][y]`、`[x+dif+2][y]`
    和 `[x+dif+3][y]`——是否具有相同的颜色。如果是，我们将 `win` 的值改为 `True`。
- en: In the process, we need to make exceptions for `IndexError` because, for example,
    the value of `x+3` may be 8, but the board has only seven columns. If we do not
    make exceptions for `IndexError`, the script will crash in the process of checking
    whether the player has won the game.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们需要处理 `IndexError` 的例外情况，因为例如，`x+3` 的值可能是 8，但棋盘只有七列。如果我们不处理 `IndexError`
    的例外情况，脚本在检查玩家是否赢得游戏的过程中会崩溃。
- en: Further, we ensure that none of the indexes have negative values, because negative
    indexing has a very specific meaning in Python. In Python, a negative index wraps
    around to the beginning of the list instead of falling off at the end. For example,
    index `-1` refers to the last element in a list in Python, `-2` to the second
    to last, and so on. Negative indexing will not raise an `IndexOutOfBounds` error,
    but it will also not behave as you expect.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们确保所有索引都没有负值，因为负索引在 Python 中有非常特定的含义。在 Python 中，负索引会绕回到列表的开头，而不是在末尾掉出。例如，索引
    `-1` 在 Python 中表示列表中的最后一个元素，`-2` 表示倒数第二个，以此类推。负索引不会引发 `IndexOutOfBounds` 错误，但它的行为也不会如你预期那样。
- en: 'Let’s look at a concrete example: for x = 1 and y = 2, when the script checks
    the cell `[x-3][2]`, it will look at cell `[-2][2]`, which is actually cell `[5][2`]
    because `-2` refers to the second-to-last value in x, which is 5 (that is, the
    sixth column, since there is a total of seven columns). Therefore, we put the
    condition `x+dif> = 0` in the function to ensure that we have no negative indexing
    anywhere.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的例子：对于 x = 1 和 y = 2，当脚本检查单元格 `[x-3][2]` 时，它实际上会查看单元格 `[-2][2]`，而这个单元格实际上是
    `[5][2]`，因为 `-2` 指的是 x 中倒数第二个值，即 5（也就是第六列，因为一共有七列）。因此，我们在函数中加入条件 `x+dif >= 0`
    以确保没有任何地方出现负索引。
- en: Finally, we use `try` and `except` in every one of the four cases of winning
    by connecting four discs horizontally. If instead we had used just one set of
    `try` and `except` for all four cases of wins, whenever any `IndexError` occured,
    the script would skip all remaining cases and go to the `except` branch directly.
    This would cause the script to fail to identify many cases of wins.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在四种通过水平连接四个棋子的获胜情况中使用`try`和`except`。如果我们只为所有四种获胜情况使用一组`try`和`except`，那么每当发生`IndexError`时，脚本会跳过所有剩余的情况，直接进入`except`分支。这样就会导致脚本无法识别许多获胜的情况。
- en: Similarly, we define `vertical4()` to check for a win by connecting four discs
    in a row vertically 3. Then `forward4()`checks for a forward diagonal win, and
    `back4()`checks for a backward diagonal win.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们定义了`vertical4()`来检查通过竖直方向连接四个棋子是否获胜。然后，`forward4()`检查前斜线方向的获胜情况，`back4()`检查后斜线方向的获胜情况。
- en: At 4, we define `win_game()`, which checks for a win in any of the 13 win scenarios
    (four horizontally, one vertically, four diagonally in a forward-slash fashion,
    and four diagonally in a backslash fashion). In `win_game()`, we create the variable
    `win` and assign a default value of `False`. The function first converts column
    and row numbers, `col` and `row`, to indexes in the `occupied`list, `x` and `y`.
    The function then calls the four functions just defined to see if the player may
    have won. If any of the four functions returns a value of `True`, the value of
    `win` changes to `True`, and `win_game()` will return a value of `True` when it’s
    called.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，我们定义了`win_game()`，该函数检查13种获胜场景中的任何一种（四个水平， 一个垂直，四个前斜线方向，四个后斜线方向）。在`win_game()`中，我们创建了变量`win`并将其默认值设为`False`。该函数首先将列和行号`col`和`row`转换为`occupied`列表中的索引`x`和`y`。然后，该函数调用先前定义的四个函数来检查玩家是否可能获胜。如果有任何一个函数返回`True`，`win`的值将变为`True`，并且每当调用`win_game()`时，它将返回`True`。
- en: Now let’s examine the second half of the script (which we are saving as *conn_click.py*),
    shown in [Listing 11-5](#listing11-5).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们查看脚本的后半部分（我们将其保存为*conn_click.py*），见[清单11-5](#listing11-5)。
- en: '[PRE25]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 11-5: Second half of the script to disallow invalid moves and declare
    wins and ties'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-5：脚本的后半部分，用于禁止无效操作并宣布胜利和平局
- en: At 1, we create the variable `rounds`to keep track of the number of rounds played,
    corresponding to the number of discs on the game board, so that we can declare
    a tie when the number reaches 42\.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们创建了变量`rounds`，用来追踪游戏中进行的回合数，这与棋盘上棋子的数量相对应，以便在回合数达到42时可以宣布平局。
- en: We change `conn()` 2 to declare three global variables so that their values
    can be recognized both inside and outside the function. At 3, we call `win_game()`
    to see whether anyone has won. If yes, we change `validinputs` to an empty list
    so no further moves can be made. A message box will pop up that says `Congrats
    player red, you won!` or `Congrats player yellow, you won!`
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`conn()`中的第2行修改为声明三个全局变量，这样它们的值就可以在函数内部和外部都能被识别。在第3行，我们调用`win_game()`来检查是否有人获胜。如果是，我们将`validinputs`更改为空列表，这样就无法再进行任何操作。一个消息框会弹出，显示`恭喜红方玩家，您赢了！`或`恭喜黄方玩家，您赢了！`
- en: '[Figure 11-3](#figure11-3) shows the red player winning a game.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-3](#figure11-3)显示了红方玩家赢得了比赛。'
- en: '![f11003](Images/f11003.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](Images/f11003.png)'
- en: 'Figure 11-3: Red wins! The darker discs are red, and the lighter are yellow.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：红方获胜！较深色的棋子是红色，较浅色的是黄色。
- en: If no one has won but `rounds` reaches 42, the script declares a tie game ([Figure
    11-4](#figure11-4)).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有人获胜，且`rounds`达到42，脚本将声明平局（[图11-4](#figure11-4)）。
- en: '![f11004](Images/f11004.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![f11004](Images/f11004.png)'
- en: 'Figure 11-4: A tied game'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-4：平局
- en: If no player has won or the game is not tied, we increase the value of `rounds`
    by one and assign the turn to the other player. We also update the list of valid
    moves. If the number of discs in the current column reaches six, we remove the
    column number from the list `validinputs` 4.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有玩家获胜或游戏没有平局，我们将`rounds`的值加一，并将轮到的玩家交给另一个玩家。我们还会更新有效操作的列表。如果当前列的棋子数达到六个，我们会从`validinputs`列表中移除该列的编号。
- en: During the game, if a player clicks an invalid cell 5, a message box will say
    `Sorry, that's an invalid move!` ([Figure 11-5](#figure11-5)).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，如果玩家点击了一个无效的单元格，第5行，消息框将显示`抱歉，这是一个无效的操作！`（[图11-5](#figure11-5)）。
- en: '![f11005](Images/f11005.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![f11005](Images/f11005.png)'
- en: 'Figure 11-5: An invalid move'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5：一个无效的移动
- en: The Voice-Controlled Version
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音控制版本
- en: Now we’re ready to add the voice control functionality!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备添加语音控制功能了！
- en: First, we’ll set the computer as your opponent in the game. After you make a
    move as the red player, the computer will randomly select a yellow move until
    the game ends. Once you understand how playing against a computer works, a voice-controlled
    game in which you play against another person is really simple. I’ll leave that
    as an end-of-chapter exercise, and the script is provided at the book’s resources
    website.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将计算机设为你的对手。在你作为红方落子后，计算机会随机选择一个黄方动作，直到游戏结束。一旦你了解了与计算机对战的方式，语音控制游戏中与其他人对战就非常简单了。我将这作为章节末的练习，脚本可以在书本资源网站上找到。
- en: Download *conn_hs.py* from the book’s resources and save it in your chapter
    folder. [Listing 11-6](#listing11-6) highlights the differences between *conn_hs.py*
    and *conn_click.py*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从书本资源中下载*conn_hs.py*并将其保存在章节文件夹中。[清单 11-6](#listing11-6)展示了*conn_hs.py*和*conn_click.py*之间的差异。
- en: '[PRE26]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11-6: Script highlights for the voice-controlled Connect Four game'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-6：语音控制版Connect Four游戏的脚本亮点
- en: We import a few extra modules. The `choice()` function from the *random* module
    lets the computer randomly select a move to play against you. We also import our
    local `print_say()` and `voice_to_text()` functions from the local package *mptpkg*
    to handle the voice-control functionality.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了一些额外的模块。来自*random*模块的`choice()`函数让计算机随机选择一个动作来与您对战。我们还从本地包*mptpkg*中导入了本地的`print_say()`和`voice_to_text()`函数，用于处理语音控制功能。
- en: This time, we’ll use string values instead of integers to represent the seven
    column numbers in the list `validinputs`, because voice inputs are naturally string
    variables and, in many cases, attempting to convert voice inputs to integers will
    crash the script.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用字符串值而不是整数来表示列表`validinputs`中的七个列号，因为语音输入本质上是字符串变量，并且在许多情况下，尝试将语音输入转换为整数会导致脚本崩溃。
- en: At 1, we start an infinite `while` loop. At each iteration, the script asks
    for your move out loud. You speak into the microphone to make your move, and the
    script captures your voice command and stores it in `inp`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们开始了一个无限的`while`循环。在每次迭代中，脚本会大声询问你的动作。你通过麦克风说出你的动作，脚本捕捉到你的语音命令并将其存储在`inp`中。
- en: Here we did a little tweaking to make `voice_to_text()` more responsive to your
    voice commands, as we did in Chapter 10 (see [Listing 10-6](c10.xhtml#listing10-6)
    as a reminder). Further, the script always interprets *number four* as `number
    for`, so we replace `for` with `4` to get a better response from the script.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`voice_to_text()`进行了些微调整，使其对你的语音命令更加敏感，正如第10章中所做的那样（参见[清单 10-6](c10.xhtml#listing10-6)以作提醒）。此外，脚本总是将*number
    four*解读为`number for`，因此我们用`4`替换`for`，以便从脚本获得更好的响应。
- en: 'If your voice command is not in `validinputs`, the script reminds you out loud:
    “Sorry, that’s an invalid move!” I’ve moved up the invalid voice input so that
    the `if` and `else` branches are close together in the script, making it easy
    for you to understand the logic. If the two branches are far apart, it’s easy
    to get lost in the long lines of code.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的语音命令不在`validinputs`中，脚本会大声提醒你：“抱歉，那是一个无效的动作！”我已经将无效的语音输入提到前面，使得`if`和`else`分支在脚本中彼此靠近，这样你就能更容易理解逻辑。如果这两个分支相距太远，很容易在长长的代码行中迷失。
- en: If your voice command is a valid move 2, the script will place the disc as directed,
    let the disc fall to the lowest available space in the column, add the cell number
    to your list of occupied cells, remove the cell number from the list of valid
    inputs, and so on.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的语音命令是有效的动作，脚本会按指示放置棋子，让棋子落到列中的最低可用位置，将该单元格号码添加到你已占用单元格的列表中，并将该单元格号码从有效输入列表中移除，等等。
- en: The script then checks whether you won the game and, if you have, congratulates
    you out loud 3. If not, it will check for a tie and announce accordingly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接着会检查你是否赢得了游戏，如果是，它会大声祝贺你。如果没有，它将检查是否平局，并相应地宣布。
- en: When your turn is over, and if you haven’t won or tied the game, the computer
    randomly selects a move from `validinputs` to play against you 4, make the move,
    and check whether the computer has won the game 5. It will also check for a tie.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的回合结束，并且如果你没有赢得游戏或平局，计算机会从`validinputs`中随机选择一个动作与您对战，进行该动作，并检查计算机是否赢得了游戏。它还会检查是否平局。
- en: 'Here’s the printed message from one interaction with the game:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次与游戏互动的打印消息：
- en: '[PRE27]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Figure 11-6](#figure11-6) shows my winning game.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-6](#figure11-6)显示了我获胜的游戏。'
- en: '![f11006](Images/f11006.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![f11006](Images/f11006.png)'
- en: 'Figure 11-6: Red winning the voice-controlled version'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：红方赢得了语音控制版本
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you created a voice-controlled graphical Connect Four game
    that talks back to you in a human voice. You set up the game board and mechanisms
    as you did in Chapter 10, but this time animated the moves.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你创建了一个语音控制的图形化 Connect Four 游戏，并且它会用人类的声音与你对话。你设置了游戏板和机制，就像在第 10 章中一样，不过这一次你为游戏添加了动画效果。
- en: You learned how to let Python determine whether a player has won the game. In
    the process, you learned to lay out all cases of winning and use the script to
    check each one. You also learned how to properly use exception handling and prevent
    negative indexing from causing mistakes in your script.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何让 Python 判断玩家是否赢得了游戏。在此过程中，你学习了列出所有获胜的情况，并使用脚本检查每一个。你还学会了如何正确使用异常处理，避免负索引导致脚本出错。
- en: You added the voice recognition and text-to-speech features, but also did a
    bit of refactoring to make sure your code stayed user readable as you added to
    it. In the next couple of chapters, you’ll create more voice-controlled graphical
    games and make them intelligent.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了语音识别和文本转语音功能，并对代码进行了重构，以确保在添加新功能时代码仍然易于阅读。在接下来的几章中，你将创建更多的语音控制图形游戏，并使它们变得更加智能。
- en: End-of-Chapter Exercises
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节结束练习
- en: Modify *conn_board.py* so that six row numbers appear at the right of the screen,
    with the top row being 6 and the bottom row being 1\. Make the x-coordinates of
    the row numbers 325.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *conn_board.py* 使得六个行号出现在屏幕右侧，顶行是 6，底行是 1。并且将行号的 x 坐标设置为 325。
- en: Modify *disc_fall.py* so that the discs fall at twice the speed.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *disc_fall.py* 使得圆盘以两倍的速度下落。
- en: Modify *conn_click.py* so that a player wins only by connecting four discs of
    the same color horizontally or diagonally, and not vertically.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *conn_click.py* 使得玩家仅通过横向或对角线连接四个相同颜色的圆盘来获胜，而不是通过垂直方向。
- en: Currently, when you play Connect Four using the final *conn_hs.py*, you can
    say either “number four” or “four” if you want to place a disc in column 4\. Modify
    the script so that you can also say “column four” to place a disc in that column.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前，当你使用最终版的 *conn_hs.py* 玩 Connect Four 时，如果你想将圆盘放在 4 列，你可以说“number four”或“four”。修改脚本，使得你也可以说“column
    four”将圆盘放入该列。
- en: Modify *conn_hs.py* so that you play against a person instead of the computer.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *conn_hs.py* 使得你与一个人对战，而不是与计算机对战。
- en: '12'
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Guess-the-Word Game
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 猜单词游戏
- en: '![](Images/chapterart.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll build a voice-controlled graphical guess-the-word game.
    This is an interesting challenge because when playing guess-the-word, players
    often talk quickly, so we’ll need to fine-tune our script’s listening abilities.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将构建一个语音控制的图形化猜单词游戏。这是一个有趣的挑战，因为在玩猜单词时，玩家通常会说得很快，因此我们需要调整脚本的听力功能。
- en: As usual, we’ll go over the game rules and draw a game board; this game board
    uses six coins to represent your six guesses. You’ll learn how to load a picture
    to a Python script and create multiple images of it onscreen. You’ll also learn
    to make the images disappear one by one.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将回顾游戏规则并绘制游戏板；这个游戏板使用六个硬币代表你的六次猜测。你将学习如何将图片加载到 Python 脚本中，并在屏幕上创建多个图像。你还将学会让图像一个接一个地消失。
- en: We’ll start the game by using written inputs. Then, when we have it working
    well, we’ll add the speech recognition and text-to-speech features.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过书面输入开始游戏。然后，当游戏运行良好时，我们将添加语音识别和文本转语音功能。
- en: All scripts in this chapter are available on the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch12/* for this chapter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有脚本可以在本书的资源页面上找到：[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。首先为本章创建文件夹
    */mpt/ch12/*。
- en: Game Rules
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: Our guess-the-word game is loosely based on the hangman game. Our game will
    present only four-letter words to keep it simple, but you should try adapting
    it later when you’re comfortable with how it all works. Let’s go over the rules
    of the game first.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的猜单词游戏是基于猜字游戏（hangman）的一个简单版本。我们的游戏只会呈现四个字母的单词，以简化游戏，但当你熟悉其工作原理时，应该尝试稍后进行适配。让我们先来回顾一下游戏规则。
- en: Similar to hangman, our guess-the-word game involves two players. The first
    player thinks of a word and draws a number of dashes equal to the number of letters
    in the word. The first player also draws six coins in the middle of the screen
    to represent the six incorrect guesses the second player will be allowed.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The second player tries to figure out the word by guessing one letter at a time.
    If the suggested letter is in the word, the first player fills in the blanks with
    the letter in the right places. If a suggested letter is not in the word, the
    first player erases a coin in the middle of the screen. If the second player completes
    the word before making six incorrect guesses, they win the game. If that player
    fails to identify the word before using up their six wrong guesses, they lose.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Draw the Game Board
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game board will preload with four dashes to represent the word. We’ll also
    include the message `incorrect guesses` onscreen. Open your Spyder editor and
    enter the code in [Listing 12-1](#listing12-1), saving it as *guess_word_board.py*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 12-1: Python script to draw the guess-the-word game board'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: We import the *turtle* module and set up the screen to be 600 by 500 pixels
    with a lavender background. The title will read `Guess the Word Game in Turtle
    Graphics`. Note that we omitted the last two arguments in `setup()`, so the game
    board will appear at the center of your computer screen by default.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create a variable `score` to keep track of the number of guesses the
    player has left. It starts with a value of 6\. Later in the game, every time the
    player guesses an incorrect letter, the value will decrease by 1\. We also create
    a new turtle named `left`, representing the number of guesses remaining. We use
    the new turtle to write the number of chances the player has left, erasing whatever
    was there before. By using a new turtle, we limit the number of objects we need
    to redraw onscreen.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: We then add the text `incorrect guesses`, which will later show the incorrect
    letters the player guessed. We draw four dashes at the bottom of the board 3 to
    hold the four letters in the word. Run the script and you should see a board similar
    to [Figure 12-1](#figure12-1).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![f12001](Images/f12001.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: The board for the guess-the-word game'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The Text Version
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll place the six coins on the screen and enable the player
    to enter letters with the keyboard. You’ll then determine whether a player has
    won or lost the game. This completes the silent version of guess-the-word.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Load the Coins
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll place six coins at the center of the screen. In the process, you’ll learn
    how to load a picture to the script, resize it to any shape you like, and place
    as many objects on the turtle screen as you like. As noted, each coin corresponds
    to one incorrect guess.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Download the picture file *cash.png* from the book’s resources and place it
    in your chapter folder. Open *guess_word_board.py*, add the highlighted code in
    [Listing 12-2](#listing12-2), and save the new script as *show_coins.py* in the
    same chapter folder containing *cash.png*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍资源中下载图片文件*cash.png*并将其放入章节文件夹中。打开*guess_word_board.py*，将[示例 12-2](#listing12-2)中高亮的代码添加进去，然后将新脚本保存为*show_coins.py*，并将其保存在包含*cash.png*的相同章节文件夹中。
- en: '[PRE29]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 12-2: Script to show and remove coins'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-2：显示和移除金币的脚本
- en: We import the `PhotoImage()` class from the *tkinter* module and the `sleep()`
    function from the *time* module. We then load *cash.png* by using `PhotoImage()`
    1. We use `subsample()` to scale the image to the size we want. In this case,
    we use scale factors of `(10,10)`, which means that both the width and the height
    of the picture are one-tenth that of the original picture.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*tkinter*模块中导入`PhotoImage()`类，从*time*模块中导入`sleep()`函数。然后我们使用`PhotoImage()`加载*cash.png*。我们使用`subsample()`来缩放图像至所需大小。在这个例子中，我们使用缩放因子`(10,10)`，这意味着图片的宽度和高度都是原始图片的十分之一。
- en: 'At 2, we create a list `coins` with six elements by using `[0]*6`. If you print
    out the list, it will look like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们通过使用`[0]*6`创建了一个包含六个元素的列表`coins`。如果你打印出这个列表，它将是这样的：
- en: '[PRE30]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ll change the elements later; the `0` values are just placeholders.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会修改这些元素；`0`值只是占位符。
- en: Next, we create a new turtle in each element in `coins`. We then make the coin
    turtles go to the center of the screen and line up horizontally. To demonstrate
    how to load and then hide the coins, we have them stay onscreen for three seconds
    3 before using `hideturtle()` from the *turtle* module to make them disappear
    from the screen one at a time, starting with the last one.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`coins`中的每个元素创建一个新的海龟。然后我们让这些金币海龟移动到屏幕中心并水平排列。为了演示如何加载和隐藏金币，我们让它们在屏幕上停留三秒钟后，再通过调用*turtle*模块中的`hideturtle()`逐个将它们从屏幕上隐藏，顺序从最后一个开始。
- en: '[Figure 12-2](#figure12-2) shows the screen in the first three seconds, as
    the coins are lined up.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](#figure12-2)显示了在前三秒内的屏幕，金币已排成一行。'
- en: '![f12002](Images/f12002.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![f12002](Images/f12002.png)'
- en: 'Figure 12-2: Showing coins on the guess-the-word game board'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：在猜字游戏板上显示金币
- en: Guess the Letters
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 猜字母
- en: The next version of the game will use 15 four-letter words, picked from a list
    of the most commonly used four-letter words according to Professor Barry Keating’s
    website at the University of Notre Dame (*https://bit.ly/3g7z7cg*). Keating has
    done extensive work in the fields of business forecasting and data mining. He
    is also the coauthor of the popular textbook *Forecasting and Predictive Analytics*
    (McGraw Hill, 2018).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的下一个版本将使用15个四个字母的单词，这些单词来自于诺特丹大学Barry Keating教授网站上列出的最常用四个字母的单词列表（*https://bit.ly/3g7z7cg*）。Keating教授在商业预测和数据挖掘领域做了大量工作。他还是畅销教材《预测与预测分析》（McGraw
    Hill, 2018）的合著者。
- en: After we make the following modifications, the script will randomly choose one
    word, ask you to guess a letter, and then accept input from the IPython console.
    If a guess is right, the letter will show up on one of the dashes corresponding
    to the position of the letter in the word. In the rare case that the letter appears
    in the word twice, the letter will show up on two of the dashes. If the letter
    is not in the word, it will show up at the top of the screen in the list of incorrect
    guesses. We’ll skip placing the coins in this script to make testing of the code
    easier to follow.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做出以下修改后，脚本将随机选择一个单词，要求你猜一个字母，并从IPython控制台接受输入。如果猜对了，字母会出现在对应位置的破折号上。如果字母在单词中出现了两次，它会在两个破折号上显示。如果字母不在单词中，它会显示在屏幕顶部的错误猜测列表中。我们将跳过在这个脚本中放置金币的部分，以便更容易地跟踪代码测试。
- en: Open *guess_word_board.py*, add the highlighted code in [Listing 12-3](#listing12-3),
    and save the new script as *guess_letter.py*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*guess_word_board.py*，将[示例 12-3](#listing12-3)中高亮的代码添加进去，然后将新脚本保存为*guess_letter.py*。
- en: '[PRE31]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 12-3: Script to put letters on the game board'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-3：将字母放到游戏板上的脚本
- en: We first import `choice()` from the *random* module so the script can randomly
    pick a word from the list. We put the 15 words in the list `words` 1 and allocate
    the randomly selected word to `word`. At 2, we create the list `missed` to hold
    all incorrectly guessed letters. We then put the script in an infinite loop3 to
    continuously take your text input. If you want to stop the loop, you can enter
    `done` in the Spyder IPython console.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从*random*模块导入`choice()`，这样脚本可以从列表中随机选择一个单词。我们将15个单词放入列表`words` 1，并将随机选择的单词分配给`word`。在2处，我们创建了列表`missed`，用于保存所有猜错的字母。然后我们将脚本放入一个无限循环3中，不断接收你的文本输入。如果你想停止循环，可以在Spyder
    IPython控制台中输入`done`。
- en: At 4, we check whether the letter you guess is in one of the letters in `word`.
    We use `list()`, which takes a string variable as input and breaks it into a list
    of individual letters; for example, the command `list("have")` produces the list
    `["h","a","v","e"]`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在4处，我们检查你猜测的字母是否出现在`word`中的字母里。我们使用`list()`，它将字符串变量作为输入，并将其分解为一个包含各个字母的列表；例如，命令`list("have")`会生成列表`["h","a","v","e"]`。
- en: If your guessed letter is in `word`, the function checks every letter in `word`
    to see if your guess matches the letter in that position. If so, the function
    writes the letter on the corresponding position onscreen.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜测的字母在`word`中，函数会检查`word`中的每个字母，看你的猜测是否与该位置的字母匹配。如果匹配，函数将在相应位置显示该字母。
- en: If your guess is not in `word` 5, the letter is added to `missed` and is written
    at the top of the screen in the `incorrect guesses` section.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的猜测不在`word` 5中，字母会被添加到`missed`并显示在屏幕顶部的`incorrect guesses`部分。
- en: Note that we also removed the line `t.done()` in this script. This means that,
    once you finish guessing and enter `done`, the script will end and everything
    will disappear from your screen.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还在此脚本中移除了`t.done()`这一行。这意味着，一旦你完成猜测并输入`done`，脚本将结束，屏幕上的所有内容将消失。
- en: 'Here’s the output from one exchange with the script, when the script randomly
    selected the word *have* from the list of the 15 words, with my typed input in
    bold:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与脚本的一次交互输出，当脚本从15个单词的列表中随机选择了单词*have*时，我输入的内容以粗体显示：
- en: '[PRE32]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 12-3](#figure12-3) shows the resultant screen.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-3](#figure12-3)显示了结果屏幕。'
- en: '![f12003](Images/f12003.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![f12003](Images/f12003.png)'
- en: 'Figure 12-3: A guess-the-word game board with letters on it'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3：一个带有字母的猜单词游戏板
- en: 'It’s working, but you may have noticed that some things need improvement. To
    have a complete version of guess-the-word, we need the script to do the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经工作了，但你可能注意到有些地方需要改进。为了完成一个完整的猜单词游戏，我们需要让脚本执行以下操作：
- en: Prevent the players from guessing the same letter more than once. In my preceding
    interaction, I guessed *b*, *v*, and *h* twice, wasting my guesses.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止玩家重复猜测同一个字母。在我之前的互动中，我重复猜测了*b*、*v*和*h*，浪费了猜测机会。
- en: Notify the players when a word is complete.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单词完成时通知玩家。
- en: Stop taking input after a player completes the word.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家完成单词后停止接受输入。
- en: Put the six coins onscreen and remove one every time a player misses a letter.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将六个硬币显示在屏幕上，每当玩家猜错一个字母时，就移除一个硬币。
- en: Determine Valid Guesses, Wins, and Losses
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定有效的猜测、胜利和失败
- en: Next, we’ll disallow duplicate-letter guesses, declare a win if you complete
    the word while missing fewer than six letters, and declare a loss if not.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将禁止重复字母的猜测，如果你在错过少于六个字母的情况下完成了单词，就宣告胜利，否则宣告失败。
- en: Open *guess_letter.py* and add the highlighted parts in [Listing 12-4](#listing12-4).
    Then save the new script as *guess_word.py*. A block of code in *guess_letter.py*
    is modified and replaced by the newly added blocks. If you’re uncertain what’s
    different, download the script *guess_word.py* from the book’s resources page.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*guess_letter.py*，并在[列表12-4](#listing12-4)中添加高亮的部分。然后将新脚本保存为*guess_word.py*。在*guess_letter.py*中的一段代码被修改并替换为新添加的代码块。如果你不确定有什么不同，可以从本书资源页面下载脚本*guess_word.py*。
- en: '[PRE33]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 12-4: A graphical guess-the-word game that takes written input'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-4：一个带有图形界面的猜单词游戏，接受书面输入
- en: We import the *messagebox* module from the *tkinter* Python package again so
    we can display messages to the game screen.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从*tkinter* Python包中导入*messagebox*模块，以便能够在游戏屏幕上显示消息。
- en: Starting at 1, we display the six coins onscreen. We update the screen so that
    everything we put there shows up properly 2.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 从1开始，我们在屏幕上显示六个硬币。我们更新屏幕，以确保我们放置的所有内容都能正确显示2。
- en: At 3, we create the list `validinputs`, which has the 26 letters in the alphabet
    as elements. Later in the script, if the player guesses a letter, we’ll remove
    the letter from the list so that the same letter can’t be guessed more than once.
    We also create the empty list `gotright`. Later we’ll use it to keep track of
    how many positions the player has guessed right in the word.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在3中，我们创建了`validinputs`列表，其中包含了字母表中的26个字母作为元素。在脚本后面，如果玩家猜测一个字母，我们会从列表中删除该字母，以避免同一个字母被猜测多次。我们还创建了一个空列表`gotright`，稍后我们将使用它来跟踪玩家在单词中正确猜中的位置数。
- en: We start an infinite `while` loop that asks for your keyboard input in every
    iteration. If you enter `done`, the loop stops, and the script quits taking input
    from you. If you enter invalid input (either a non-letter or a letter you’ve already
    guessed), the script will show a message box indicating `Sorry, that's an invalid
    input!`
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个无限的`while`循环，每次迭代时请求你的键盘输入。如果你输入`done`，循环停止，脚本不再接收你的输入。如果你输入无效的内容（非字母或已经猜过的字母），脚本会弹出一个消息框，显示`抱歉，这是无效输入！`
- en: If you enter valid input 4, the script checks whether the letter is in the word.
    If yes, the script checks each of the four positions in the word and, for each
    match, adds the letter to the list `gotright`. Note that since the same letter
    can appear in a word more than once, a letter may be added to the list `gotright`
    more than once.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入有效的内容4，脚本会检查字母是否在单词中。如果是，脚本会检查单词中的四个位置，并对每一个匹配的字母，都会将该字母添加到`gotright`列表中。需要注意的是，由于同一个字母可以在单词中出现多次，所以一个字母可能会被多次添加到`gotright`列表中。
- en: The script then checks whether `gotright` has four elements. If yes, it means
    all four letters have been correctly guessed, and a message box will pop up with
    `Great job, you got the word right!`
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接着检查`gotright`是否包含四个元素。如果是，说明所有四个字母都已正确猜出，脚本会弹出一个消息框，显示`太棒了，你猜对了单词！`
- en: 'If the guessed letter is not in the word 5, the value of `score` is decreased
    by one, meaning the player has one less guess left. The script will remove a coin
    from the screen by using `hideturtle()`. The second turtle will erase whatever
    it has drawn on the screen and rewrite the number of guesses left. If the length
    of the list `missed` reaches six, a message box appears: `Sorry, you used up all
    your six guesses!`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果猜测的字母不在单词中5，`score`的值减少1，意味着玩家剩余的猜测次数减少。脚本会通过使用`hideturtle()`从屏幕上移除一个硬币。第二只海龟会清除它在屏幕上绘制的内容，并重新写上剩余的猜测次数。如果`missed`列表的长度达到了六个，一个消息框会出现，显示`抱歉，你已经用完了所有六次猜测！`
- en: 'Here’s one exchange with the script with the user input in bold:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与脚本的一次交互，用户输入部分用粗体显示：
- en: '[PRE34]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: My losing game is shown in [Figure 12-4](#figure12-4).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我的失败游戏显示在[图12-4](#figure12-4)中。
- en: '![f12004](Images/f12004.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![f12004](Images/f12004.png)'
- en: 'Figure 12-4: A losing game of guess-the-word'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4：一个失败的猜单词游戏
- en: The Voice-Controlled Version
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音控制版本
- en: Now we’ll build on the written-input version of the game to add speech functionality.
    Download *guess_word_hs.py* and save it in your chapter folder. The new code is
    highlighted in [Listing 12-5](#listing12-5).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将基于已写输入版本的游戏，添加语音功能。下载*guess_word_hs.py*并将其保存在你的章节文件夹中。新代码在[清单12-5](#listing12-5)中高亮显示。
- en: '[PRE35]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 12-5: A graphical guess-the-word game that takes voice input'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-5：一个图形化的猜单词游戏，支持语音输入
- en: 'We import the usual functions from our local package *mptpkg*: `voice_to_text()`
    and `print_say()`. Because we installed the package (in editable mode), there’s
    no need to tell the system where to find it.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本地包*mptpkg*中导入了常用函数：`voice_to_text()`和`print_say()`。因为我们已安装该包（以可编辑模式），所以不需要告诉系统在哪里找到它。
- en: We start an infinite `while` loop that asks for your choice of letter in each
    iteration 1. You speak your guess into the microphone, and the script captures
    your voice command and stores it in `inp`. We make allowances so the player can
    say either “letter a” or just “a.” If the former, we replace *letter* with an
    empty string so that only `a` is left in the variable `inp`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个无限的`while`循环，在每次迭代中询问你选择的字母1。你将你的猜测通过麦克风说出，脚本会捕捉到你的语音命令并将其存储在`inp`中。我们做了一些处理，以允许玩家说“字母a”或仅说“a”。如果是前者，我们会将*letter*替换为空字符串，这样变量`inp`中只剩下`a`。
- en: To stop the `while` loop, you say, “Stop listening.” If your guess is not in
    the list `validinputs`, the script will answer, “Sorry, that’s an invalid input!”
    out loud. If your guess is in `validinputs` 2, the script checks whether the letter
    is in the word. This time, when you complete the word without missing six times,
    the game will say, “Great job, you got the word right!” 3. If you guess wrong
    six times, the voice will say, “Sorry, you used up your six guesses!” 4.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an exchange with the script in which the player has successfully guessed
    the word *good*, missing only two letters:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can see the screen in [Figure 12-5](#figure12-5).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '![f12005](Images/f12005.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: Winning the voice-controlled guess-the-word game'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you created a voice-controlled graphical guess-the-word game
    that talks back to you in a human voice.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: You first learned how to draw the game board. You then learned to upload a picture
    file to the script and scale it to the size you want. You used the image to create
    six coins on the screen to represent monetary rewards and made them disappear
    from the screen one by one. You also learned how to type in your guess and have
    it show up onscreen. You learned how to disallow guessing the same letter twice
    and how to determine whether a player has won or lost the game.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: You added the speech recognition and text-to-speech features so that the game
    can be voice controlled. Along the way, you learned how to create an image by
    manipulating a picture file in *turtle* and how to use multiple turtles to reduce
    the number of objects you have to redraw on the screen.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *show_coins.py* so that the positions of the six coins are 10 pixels
    below their current positions vertically. Keep the positions of everything else
    the same.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *show_coins.py* so that the leftmost coin disappears from the screen
    first and the rightmost one is the last to disappear.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to figure out what the following line of code will produce. First write
    down your answer and then run the code in Spyder to verify.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '13'
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Smart Games: Adding Intelligence'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: In the one-player version of Connect Four we built in Chapter 11, the computer
    always randomly selects a move. This allowed us to focus on the game’s speech
    recognition and text-to-speech aspects.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: However, once you play against the random computer for a few games, you start
    to wonder if there’s a way to make our Connect Four game more challenging. The
    answer is yes, and in this chapter, you’ll learn to make an intelligent Connect
    Four opponent.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'In one approach, we’ll ask the script to think three steps ahead, as people
    do when playing a game: two moves by the computer and one by the player.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the computer checks whether a move leads to winning the game
    right away. If yes, the computer will take it.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Thinking two steps ahead in Connect Four means the computer tries to prevent
    the opponent from winning in the next turn. This is complicated, because sometimes
    the computer must block a position and other times it must avoid taking a position.
    The computer will distinguish these two cases and block some moves and avoid others
    to prevent the opponent from winning.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: By thinking three steps ahead, the computer will follow the path that most likely
    leads to a victory for the computer after three moves. In many scenarios, thinking
    three steps ahead can guarantee a win in three steps. In particular, if there
    is a move that guarantees the computer to win in three moves, the computer will
    select that as the best next move.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The second method uses an approach that could be classified as a type of *machine
    learning*. You’ll simulate a million games in which both players select random
    moves. You’ll then record the outcome and the intermediate steps. With this data,
    the computer will learn at each move and select the one most likely to lead to
    a winning outcome.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assess the effectiveness of the two strategies and choose the one that
    is more difficult to beat. We’ll then add speech recognition and text-to-speech
    features to the intelligent Connect Four.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, I’ll also challenge you to apply the same methods to the tic-tac-toe
    game in the “End-of-Chapter Exercises” on page 267. As always, all scripts are
    available at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/),
    and you should create the folder */mpt/ch13/* for this chapter.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: The Think-Three-Steps-Ahead Strategy
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll first use the mouse-click version of Connect Four to speed up the testing
    of scripts. After we incorporate the strategy of thinking three steps ahead, we’ll
    add the speech features back.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Think One Step Ahead
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking one step ahead in Connect Four is easy. The computer checks all possible
    next moves, and if one of them will lead to a win right away, the computer will
    take it.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_think1.py* from the book’s resources and save it in your chapter
    folder. This is based on the script *conn_click.py* in Chapter 11, but I’ve altered
    the code so that you’re playing against an automated player that thinks one step
    ahead rather than another human player.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](#listing13-1) highlights the key parts of *conn_think1.py*.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 13-1: Think one step ahead in the Connect Four game.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: We import all needed modules. In particular, we import `choice()` from the *random*
    module and `deepcopy()` from the *copy* module. The *copy* module is in the Python
    standard library, so no installation is needed.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: To search for the best strategy, we’ll look one step ahead and see what would
    happen hypothetically if certain actions were taken. We need `deepcopy()` to copy
    a list without altering the original list. We can’t simply use assignment statements
    in this script when copying lists. Assignment statements in Python create a link
    to the original list object, so if we alter the copy, we alter the original as
    well. Altering the original list is not what we intend and would cause unexpected
    behavior.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we make `horizontal4(x,y,color,board)`more general so that it can be applied
    to any four arguments. Later in the script, we’ll use it to check whether certain
    moves win the game by collecting four discs horizontally in a hypothetical situation.
    We define the functions `vertical4()`, `forward4()`, and `back4()` in a similar
    way.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `win_game(num,color,board)`, which checks whether the player
    has won in any of the preceding four scenarios. We’ve also omitted the row number
    as an argument because it will be inferred from the argument `board`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The main action is in `best_move()`, starting at 3. This function searches for
    the best move for the computer (the red player). If column 4 is empty, the computer
    takes the center column. Since the red player moves first, this line of code ensures
    that the very first move of the game is always the center column 4, giving whoever
    makes the first move an advantage.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: If only one move is left (that is, six columns are full and only one column
    has empty cells), there’s no point searching for a best move, so the computer
    takes the only remaining move.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: If more than one move remains, the function checks every possible move to see
    if any will lead to a win for the computer right away. The script creates the
    list `winner` to contain the potentially winning moves 4. We go through all possible
    next moves. We use `win_game()` to check whether a move will win the game hypothetically.
    If yes, the move is added to `winner`. The function then checks whether `winner`
    is empty, and if it isn’t, the computer takes the first available move in the
    list.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: We then define `computer_move()`5. When called, this function tells the computer
    to make the move produced by `best_move()`. The computer then places a disc in
    the corresponding column. Once the computer places the disc, the script uses `win_game()`
    to check if the move wins the game 6.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The computer makes the first move of the game. After that, we define `conn()`,
    which allows you to click the screen to play your move. The script checks whether
    your move wins the game 7. The computer will move after you if the game isn’t
    over.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Run the script several times and play against the computer. You’ll notice that
    the computer will always take the winning move if there is one. For example, at
    the left of [Figure 13-1](#figure13-1), an opportunity emerges for the red player
    to take column 7 and win the game. The computer thinks one step ahead and takes
    the winning move.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '![f13001a](Images/f13001a.png)![f13001b](Images/f13001b.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A Connect Four game that thinks one step ahead'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Think Two Steps Ahead
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking two steps ahead in Connect Four is a little complicated. The computer’s
    next move can either block the opponent (which is you) or help the opponent’s
    chance of winning the game on the next turn.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll separate these two cases: if the computer’s move blocks the opponent’s
    chance of winning, the script will take it; if the computer’s move helps the opponent’s
    chance of winning, the script will avoid it. Let’s use examples to demonstrate
    the two cases.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Moves to Avoid
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, the computer should avoid a certain move so that the opponent
    won’t win on the next turn.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: At the left of [Figure 13-2](#figure13-2), it’s the red player’s turn. If the
    red player chooses column 6 as the next move, the opponent can win on the following
    turn, as shown on the right in the figure. Therefore, the red player should avoid
    this move.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '![f13002a](Images/f13002a.png)![f13002b](Images/f13002b.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The red player should avoid column 6 in this example.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the red player has made a move that allows yellow to win. We can avoid
    that win with this rule: if you make a next move *x*, and your opponent places
    a disc in the same column *x* two steps ahead and wins the game, you should avoid
    the move *x* in the next step.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Moves to Block
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next case, the computer should block a certain move so the opponent won’t
    win in two steps.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: At the left in [Figure 13-3](#figure13-3), it’s the red player’s turn. If the
    red player doesn’t choose column 3 in the next move, the opponent can choose column
    3 and win on the following turn. Therefore, the red player should block this move.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '![f13003a](Images/f13003a.png)![f13003b](Images/f13003b.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The red player should block column 3\.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the red player makes a different move—column 6—and loses the game. So
    the rule is as follows: if red makes the next move, *x*, and the yellow opponent
    can make a different move *y* within two steps and win, red should block yellow’s
    move *y* in the next step.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Think-Two-Steps-Ahead Strategy
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s allow the computer to think up to two steps ahead by using the three techniques
    just discussed (one for thinking one step ahead, two for thinking two steps ahead).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_think1.py*, replace its `best_move()` with the new `best_move()`
    function defined in [Listing 13-2](#listing13-2), and save the new script as *conn_think2.py*
    in your chapter folder (or you can download it from the book’s resources).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 13-2: Allow the computer to think up to two steps ahead.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: In the newly defined function `best_move()`, the script searches for the best
    move based on discs currently on the board. If this is the very first move of
    the game, the function takes the column in the middle. If only one move is left,
    the function defines the best move to be the only move left.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: If more than one move remains, the function checks every possible move to see
    if any will lead to a win for the red player (the computer) right away 1. If yes,
    the function returns the move as the best move and stores it in `winner`. If not,
    the function will look two steps ahead to see if the opponent can win within two
    steps 2.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'The function checks two separate cases: if the red player’s move `m1` (the
    first move) and the yellow player’s move `m2` (the second move) lead to a win
    for the yellow player in two steps, we add the move `m2` to the list `winner`.
    If the red player’s move `m1` and the yellow player’s move `m2=m1` lead to a win
    for the yellow player in two steps, we add the move `m2` to the list `loser`.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The script checks whether `winner` is empty. If it isn’t, the computer will
    select the opponent’s winning move to block the opponent from winning. Otherwise,
    the computer will check whether the list `loser` is empty. If not, the computer
    will avoid all elements in `loser` so as not to help the opponent win 3.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Run *conn_think2.py* and play a few times against the computer. You’ll notice
    an improvement in the game in the sense that the computer can now think two steps
    ahead and try to prevent you from winning on your next turn.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Think Three Steps Ahead
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This next section will allow the computer to think up to three steps ahead before
    taking its turn. If the computer has no winning move in the next step and the
    opponent has no winning moves two steps ahead, the computer will look three steps
    ahead.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The computer will take the next move that most likely leads to a win in three
    steps. In particular, if there’s a next move that guarantees the computer to win
    in three steps, the computer will select that next move as the best one. Let’s
    use an example to demonstrate.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: An Example of a Win in Three Steps
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The script *conn_think2.py* is harder to beat than *conn_think1.py*, but not
    impossible. A sophisticated player will notice that the computer misses some moves
    that could have led to a win in three steps.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. At the left of [Figure 13-4](#figure13-4), it’s the computer’s
    (the red player’s) turn to move. If the computer drops a disc in column 3, the
    computer is guaranteed to win on its next turn, because the opponent (the yellow
    player) can block only either column 1 or column 5\. The computer can then occupy
    the other column (either column 5 or column 1) in this third step and win the
    game.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: But instead, the computer chooses column 6, as shown at the right of [Figure
    13-4](#figure13-4), missing a chance to guarantee a win.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![f13004a](Images/f13004a.png)![f13004b](Images/f13004b.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: The computer (the red player) fails to make a move that guarantees
    a win.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: We should, therefore, make further improvements on the game. You’ll build a
    game that thinks three steps ahead.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Think-Three-Steps-Ahead Strategy
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s allow the computer to think up to three steps ahead.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_think2.py*, add the newly defined `validmoves()` function and the
    highlighted part in [Listing 13-3](#listing13-3) to the `best_move()` function,
    and save the new script as *conn_think.py* in your chapter folder. Alternatively,
    you can download it from the book’s resources. This is the complete script for
    our think-ahead strategy.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 13-3: Allow the computer to think up to three steps ahead.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: We first define `validmoves(m1,m2,m3,occupied)` to ensure that none of the three
    future hypothetical moves `m1`, `m2`, and `m3` on the game board (represented
    by the list of lists `occupied`) will cause any columns to have more than six
    discs. If the three moves cause any of the seven columns to contain more than
    six discs, the function returns `False`; otherwise, it returns`True`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: As in *conn_think2.py*, the computer first checks whether a winning move could
    be made right away. If yes, it will take it. If not, it checks whether a winning
    move could be made two steps ahead for the opponent. If yes, the computer tries
    to prevent it.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'If no winning moves are available for the opponent two steps ahead, the computer
    looks three steps ahead 1. It checks all combinations of three moves: the computer’s
    next move, `m1`; the opponent’s move two steps ahead, `m2`; and the computer’s
    move at the third step, `m3`. If a combination leads to a win for the player,
    the next move `m1` is added to the list `winner`.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: However, just because a move `x` is in `winner` doesn’t mean this move will
    guarantee a computer win in three steps, because it can’t guarantee that the opponent
    will choose `m2` in the second step. Further, `winner` could contain multiple
    values. The function `best_move()` therefore looks for the most frequent value
    in `winner`, since that’s the move most likely to lead to a win for the computer
    in three steps.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: As with most things in Python, there are many ways to find the most frequent
    value in a list*.* We utilize a trick known as a *list comprehension* to create
    an inline dictionary `cnt`*.* In this dictionary, the key is the number of times
    a move appears in `winner`, and the value is the move 2. For example, if `winner`
    has six elements `[7, 6, 6, 5, 5, 5]`, the dictionary `cnt` would be `{1:7, 2:6,
    3:5}`. We then sort the keys in `cnt` to find the highest frequency and call it
    `maxcnt`. Here, `maxcnt` has a value of `3` because the highest number of times
    a value appears is three. Finally, we use `maxcnt` to retrieve the dictionary
    element with the highest frequency. Here, the move `5` appears most frequently
    in `winner`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: If you run *conn_think.py* and play the game, you’ll find the computer almost
    impossible to beat. If you do everything right, you can tie the game. The moment
    you make a wrong move, the computer will seize the opportunity and win the game.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: The Machine-Learning Strategy
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to make Connect Four smart is to let the computer learn from actual
    game outcomes. You’ll generate a million games in which both players use random
    moves. You’ll record the intermediate steps and the outcome of each game. The
    computer will use the game outcome data to design the best strategy.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: At each move, the computer looks at all games with the same game history as
    the current game board. It calculates the average outcome for each possible next
    move and chooses the one that most likely leads to a favorable outcome.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dataset of Simulated Games
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in the machine-learning strategy is to generate data to learn
    from. We’ll simulate two players choosing random moves and record both the outcome
    and the steps taken to reach that outcome. Even though the moves by both players
    are random, we repeat the game many times. The randomness in all these games is
    washed out by the law of large numbers. As a result, the outcome data will be
    useful to the computer to predict the outcome of a move.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_simulation.py* from the book’s resources. I explain the script
    in [Listing 13-4](#listing13-4).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 13-4: Simulating a million Connect Four games'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: We first define `simulate()`. When called, it simulates a complete Connect Four
    game and records each move and the game outcome. We omit the graphics part of
    the game to save time.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: We define `win_game()` to check if a player has won the game 1. In each game,
    the red player moves first 2. We create the two lists `moves` and `winlose` to
    record the intermediate moves and the game outcome, respectively.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: We create a game loop to iterate a maximum of 42 times because each Connect
    Four game has a maximum of 42 moves 3. In each iteration, a player randomly selects
    a move. The move is added to `moves` to keep track of the history of the game.
    At each step, we check whether a player wins. If yes, we’ll record an outcome
    of `1` if the winner is the red player and `-1` if the winner is the yellow player.
    The default outcome is a tie, in which case we’ll record a value of `0`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: We then call `simulate()` a million times 4. The result of each game is saved
    in a list `result`, with its first element being the outcome of the game (`-1`,
    `1`, or `0`), followed by the intermediate steps of the game.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: The outcomes and intermediate steps of the million games are saved in *conn_simulates.pickle*
    for later use 5. We print out the results of the first 10 games, shown in [Listing
    13-5](#listing13-5).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 13-5: The first 10 simulated Connect Four games'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: For example, the output for the first game is `[1, 1, 7, 1, 5, 7, 6, 5, 1, 5,
    7, 5, 2, 5]`. The first element, `1`, means that the red player has won the game.
    The remaining elements, `1, 7, 1 ...` , indicate the columns the players dropped
    their discs into, alternating between red and yellow. The red player eventually
    wins this game by connecting four red discs vertically in column 5.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Apply the Data
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to use the outcome data to design intelligent moves for the
    computer. At each move, the computer will turn to the simulated data to retrieve
    all games with the same history. It searches through all possible next moves,
    finds the one that leads to the most favorable outcome, and uses that as the next
    move.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_ml.py* and save it in your chapter folder. The script is based
    on *conn_think.py*. [Listing 13-6](#listing13-6) highlights the main differences.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 13-6: A Connect Four game player with the machine-learning strategy'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: We create the new list `moves_made` to keep track of all moves in the game so
    far; we’ll use it later in `best_move()`. We open the simulated Connect Four game
    data and save it in a list `gamedata`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: In `best_move()`, we make sure the first move is always to place a disc in column
    4, as that gives the computer a starting advantage 1. We check if only one move
    is left and, if so, just take it as the next best move. Otherwise, we check all
    simulated games with the same history as the current game and see which next move
    will be most favorable to the red player. We assign that move as the best move.
    I’ll explain how we do that in detail in *ml_move.py*, using a concrete example.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `computer_move()`. When it’s the computer’s turn to play, it
    calls `best_move()` to generate a move. The computer makes the move, and we add
    that move to the list `moves_made` to track the game history.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: We set the computer to make the first move 3. After that, the player clicks
    to make their move 4. The human player’s move is also added to `moves_made`. The
    computer will move after you if the game isn’t over.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Run *conn_ml.py* and play the game a few times. You might be surprised to find
    that it’s relatively easy to win. The machine-learning strategy is not nearly
    as effective as our three-steps method. We’ll look into why later in the chapter.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Test the Effectiveness of the Two Strategies
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we want to measure how intelligent the two strategies are. We’ll simulate
    1,000 games and record the outcomes. In each game, the intelligent computer version
    will play against a simple computer player that selects random moves. We’ll see
    how many times the intelligent player wins or ties the game.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: The Think-Three-Steps-Ahead Strategy
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with the three-steps version. The script *outcome_conn_think.py,*
    shown in [Listing 13-7](#listing13-7), has our two computer players play 1,000
    times, then prints out the number of winning, tying, and losing games.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 13-7: Test the effectiveness of the think-three-steps-ahead strategy.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define `simulate()`, which pits the intelligent computer (the red player)
    using the think-three-steps-ahead strategy against a computer player that selects
    random moves.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'The `win_game()` and `best_move()` functions are the same as those defined
    in *conn_think.py*. We use the list `winlose` to record the game outcomes 2: `1`
    if the red player wins, `-1` if the yellow player wins, and `0` if it’s a tie.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Once the game starts, the red player calls `best_move()` to obtain a move 3,
    while the yellow player randomly selects a move 4.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'At 5, we call `simulate()` 1,000 times and record the outcome of all games.
    We then print out the number of winning, tying, and losing games, summing the
    count of `1`, `-1`, and `0` to make it easier to read. Here’s an example of the
    output:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Out of all the games, the intelligent player with the think-three-steps-ahead
    strategy has won 995 times, never tied, and lost 5 times.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: The Machine-Learning Strategy
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll test the machine-learning strategy in the same way. Download *outcome_conn_ml.py*
    and save it in your chapter folder. This is similar to *outcome_conn_think.py*,
    so I’ll just highlight the differences here:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we obtain the simulated game outcome data that we’ve generated from *conn_simulation.py*.
    Second, we base the definition of `best_move()` on the machine-learning strategy
    instead of the three-steps strategy.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `simulate()` 1,000 times and record the outcomes, printing them as
    before. Here’s an example output:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Out of all the games, the computer has won 882 times, never tied, and lost 118
    times—it did significantly worse than with the three-steps strategy. Let’s look
    at why.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Why Doesn’t the Machine-Learning Strategy Work Well in Connect Four?
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The machine-learning strategy is less effective in our game mainly because
    so many moves are available in a Connect Four game: a maximum of 42\. That means,
    exponentially, that a very large number of possible game outcomes exist. We simulated
    a million games, which sounds like a lot, but when the data is spread among many
    game outcomes, it’s inevitable that some game outcomes will not be in the simulated
    data. As a result, it’s impossible to find a best strategy for many of the game
    histories.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll test the machine-learning strategy with one particular
    game history. Assume that the red and yellow players have both made three moves
    and next it’s the red player’s turn. The game board at this stage is as shown
    in [Figure 13-5](#figure13-5).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '![f13005](Images/f13005.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: One game simulation'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: We’ll simulate this game setup in code to see how our machine-learning strategy
    decides which move to make next. Enter *ml_move.py*, shown in [Listing 13-8](#listing13-8).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 13-8: Search for the best machine learning strategy move.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: We import *pickle*, which enables us to work with datasets saved in the *pickle*
    format. We open the simulation data file, *conn_simulates.pickle,* which was created
    earlier in *conn_simulation.py.* The data is saved in the `gamedata` list.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the red player is able to place a disc in any of the seven columns
    in the next move, so we have all seven values in `validinputs`. We save the six
    moves already made in [Figure 13-4](#figure13-4), `[4, 5, 4, 5, 4, 5]`, in the
    list `moves_made`. The list of lists `occupied` keeps track of the disc positions
    currently on the game board.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: We check the million simulated games data to see if any of those games match
    the game history of the current game. If yes, we put all the historical games
    that match in the list `simu`1. We then focus on the seventh move in all those
    games. We look at the outcomes (win, lose, or tie) of all games associated with
    each of the seven possible moves, 1 through 7, and put them in a dictionary `outcomes`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print out the content of `outcomes` 2:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, nine games have the same game history: none of which placed
    the next disc in column 1, two that used column 2 for the next move, one that
    used column 3, and so on. The values `-1`, `0`, and `1` inside the square brackets
    indicate that the red player loses, ties, and wins the game, respectively.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: To help us compare which of the seven moves leads to the best outcome for the
    red player, we calculate the average outcome for each move 3. If a move leads
    to wins 100 percent of the time, the average outcome is `1`; if a move leads to
    50 percent wins and 50 percent losses, the average outcome is `0`; if a move leads
    to a loss 100 percent of the time, the average is `-1`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'We print the average outcomes (we don’t have results for move 1 because no
    simulated game in `simu`used this move):'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Both moves 3 and 4 lead to an average outcome of `1`. The script prints out
    the first best move, which is 3 in this case 4:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: However, when we look at this move in the game ([Figure 13-6](#figure13-6)),
    we can see it clearly isn’t the best move we could have made.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '![f13006](Images/f13006.png)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: The machine-learning computer makes a mistake.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the problem with the machine-learning strategy is that we don’t
    have enough simulated games that match our game history.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder whether we can just increase the number of simulated games to
    solve the problem. The answer is yes and no. Increasing the number of simulated
    games will make the strategy more intelligent, but it will also increase the data
    size enough to slow the response of the machine-learning script. Thus, the player
    will have to wait a long time for the computer to make a move. This is the trade-off
    when using machine learning.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this by increasing the size of the simulated games to 10 million.
    Generating this data takes several hours. We rerun *ml_move.py* with the larger
    dataset and get the following output:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have much more data to base our decision on, the machine-learning
    strategy correctly recommends column 4, resulting in [Figure 13-7](#figure13-7).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '![f13007](Images/f13007.png)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: With 10 million simulated games, the strategy makes the correct
    move.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Intelligent Connect Four Games
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s wrap up this chapter by adding speech recognition and text-to-speech features
    to the intelligent Connect Four games.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Controlled Game That Thinks Ahead
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll mesh together two scripts, *conn_think.py* and *conn_hs.py*, into *conn_think_hs.py*.
    Download this file from the book’s resources and save it in your chapter folder.
    The main differences are shown in [Listing 13-9](#listing13-9).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 13-9: A voice-controlled Connect Four game with the three-steps strategy'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: The function `best_move()` is the same as in the script *conn_think.py* 1. We
    define `computer_move()` 2, which uses `best_move()` to choose a move and speaks
    aloud the selected column. If the computer’s move wins or ties the game, the script
    also announces it 3.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: The computer then makes the first move of the game4, and it starts a `while`
    loop that keeps running as long as the list `validinputs`isn’t empty 5. At each
    iteration, the script captures your voice input, which should be the number of
    the column you want to drop a disc in. You can say “number five,” “column five,”
    or “5.” It then converts the voice command to an integer number to match the format
    in `validinputs`so it can compare your input to the list. If you said something
    that isn’t convertible to an integer, the script will say, “Sorry, that’s an invalid
    input.”
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve given an invalid move 6, the script will say, “Sorry, that’s an invalid
    move.” If your move is valid, the script places the disc on the game board. In
    the process, it will check whether you’ve won or tied the game and, if so, will
    announce the result aloud. If the game is not yet over, the computer makes a move.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and play the voice-controlled game with the computer. You’ll
    notice that the game is more challenging and more interesting to play.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Controlled Game Using Machine Learning
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll mesh together two scripts we created before, *conn_ml.py* and *conn_hs.py*,
    into *conn_ml_hs.py*. Download the file from the book’s resources and save it
    in your chapter folder. [Listing 13-10](#listing13-10) shows the main differences.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 13-10: A voice-controlled Connect Four game using the machine-learning
    strategy'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: This works in the same way as the voice-controlled three-steps version. Run
    the script and play a game. You should find the game interesting but easier to
    beat than the three-steps strategy.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you created intelligent, voice-controlled graphical Connect
    Four games by using two methods: the think-three-steps-ahead strategy and the
    machine-learning strategy. This taught some important reasoning skills—how do
    we make a script intelligent?—as well as some basic machine-learning skills.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: You learned to generalize these two strategies and apply them to specific games.
    You can apply these skills to create your own intelligent voice-controlled games.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *conn_think1.py* so that the human player moves first and the computer
    moves second.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mesh together *ttt_click.py* from Chapter 10 and *conn_think1.py* to create
    a mouse-click version of the tic-tac-toe game in which the computer thinks one
    step ahead.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a mouse-click version of the tic-tac-toe game in which the computer thinks
    two steps ahead, based on *ttt_click.py* and *conn_think2.py*.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `best_move()`, defined in *conn_think.py*, if the list `winner` has eight
    elements `[7, 7, 4, 5, 6, 6, 6, 6]`, what’s the value of `cnt`, `maxcnt`, and
    `cnt[maxcnt]`, respectively?
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design a mouse-click version of the tic-tac-toe game in which the computer thinks
    three steps ahead, based on *ttt_click.py* and *conn_think.py*.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simulate a million tic-tac-toe games and save the game outcome and intermediate
    steps as *ttt_simulates.pickle*. Then create a mouse-click version of tic-tac-toe
    in which the computer uses the machine-learning strategy, similar to what we’ve
    done in *conn_simulation.py* and *conn_ml.py*.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *outcome_conn_think.py* and *outcome_conn_ml.py* to test the effectiveness
    of the three-steps strategy and the machine-learning strategy in the tic-tac-toe
    games you just created.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running *conn_simulation.py*, we printed out 10 observations from the
    dataset *conn_simulates.pickle*, as shown in [Listing 13-5](#listing13-5). The
    10th observation is `[-1, 1, 4, 1, 4, 1, 2, 4, 5, 6, 6, 6, 3]`. Who has won the
    10th game? Are the four discs connected vertically, horizontally, or diagonally?
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
