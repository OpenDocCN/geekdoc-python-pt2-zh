- en: Part III
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interactive Games
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics and Animation with the *turtle* Module
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Our goal in the next few chapters is to build voice-controlled graphical games
    such as tic-tac-toe, Connect Four, and guess-the-word. You’ll do all these with
    the *turtle* module.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you won’t be working with voice interactivity. Instead you’ll
    learn the *turtle* module’s basic commands that will let you set up a turtle screen,
    draw shapes, and create animations. This functionality will be the basis for all
    the games you’ll be building.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch09/* for this chapter. As always,
    all scripts in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: Basic Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *turtle* module allows us to use a robotic turtle to draw shapes and create
    animations on a canvas. The turtle mimics the way people draw on a physical canvas,
    but we use commands to move the turtle and create the drawings.
  prefs: []
  type: TYPE_NORMAL
- en: For its underlying graphics, the *turtle* module uses the *tkinter* module,
    which is Python’s de facto standard graphical user interface (GUI) package. Both
    *turtle* and *tkinter* are in the Python standard library, so there’s no need
    to install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turtle graphics were invented in the 1960s, three decades before the Python
    language. The *turtle* module allows Python programmers to take advantage of many
    features of turtle graphics. The first is their simplicity: *turtle* is easier
    to learn than other game modules such as *pygame* or *tkinter*. The *turtle* module
    is also intuitive, making it easy to create pictures and shapes by manipulating
    the drawing pen on a canvas (that is, the screen).'
  prefs: []
  type: TYPE_NORMAL
- en: The *turtle* module is also better suited to voice activation. Unlike other
    game modules, which constantly run through a game loop too fast to capture voice
    commands, *turtle* scripts don’t need a game loop. This makes voice-controlled
    games possible.
  prefs: []
  type: TYPE_NORMAL
- en: Create a turtle Screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use *turtle*, you need to create a turtle screen to contain all objects
    in the script. The following script shows you a simple example of the turtle screen.
    Enter the following lines of code in Spyder and save the script as *set_up_screen.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We import the *turtle* module and give it a short alias name, `t`. This is one
    situation where a short alias module name is beneficial, since we’ll be calling
    multiple functions from the module, and often. Therefore, we want to use only
    `t.`, instead of `turtle.`, in front of all the functions.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create a screen by using `Screen()`, which doesn’t require arguments.
    We then use `setup()` to specify the size and location of the screen. The four
    parameters are screen width, screen height, horizontal distance from the top left
    of your computer screen, and vertical distance from the top left of your computer
    screen, in that order. Our screen will be 600 pixels wide and 500 pixels tall,
    100 pixels from the left edge of the computer screen, and 200 pixels from the
    top edge.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we give the turtle screen a background color by using `bgcolor()`. The
    *turtle* module provides a wide range of colors, including `brown`, `black`, `gray`,
    `white`, `yellow`, `gold`, `orange`, `red`, `purple`, `navy`, `blue`, `lightblue`,
    `darkblue`, `cyan`, `turquoise`, `lightgreen`, `green`, and `darkgreen`.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we give a title to the screen, which you’ll see at the top beside the
    turtle graphics symbol ([Figure 9-1](#figure9-1)).
  prefs: []
  type: TYPE_NORMAL
- en: The `done()` command tells the script to start the event, which is how objects
    on the screen could be animated. The `bye()` command tells the script to exit
    *turtle* when you click the X symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The screen should look something like [Figure 9-1](#figure9-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09001](Images/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Set up the size, background color, and title of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: A turtle screen uses a *Cartesian* coordinate system, with the center coordinate
    (x = 0, y = 0). The x-value increases from left to right, and the y-value increases
    from bottom to top, just like the two-dimensional plane you learned in high school
    mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Create Movements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In earlier days, the turtle cursor was literally a picture of a turtle moving
    around on the screen. Now, instead of a literal turtle, you see a small arrowhead
    as the default cursor. The turtle has three attributes: location, direction, and
    a pen. You can adjust the color and width of the pen, and you can decide whether
    to put the pen down on the plane so the turtle’s path is marked when it moves
    or lift it up so the movement isn’t tracked.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an actual drawing before looking at the various movements in the module.
    Enter the code shown in [Listing 9-1](#listing9-1) in a Spyder editor and save
    it as *show_turtle.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: Showing the turtle in the *turtle* module'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we change the shape of the cursor back to the original turtle shape, as
    you can see in [Figure 9-2](#figure9-2). If you run the script, you can see that
    the turtle starts at position (x = 0, y = 0) and faces right. It moves forward
    200 pixels with the default down pen position, so this movement draws a line on
    the canvas. We turn the turtle right 90 degrees and lift up the pen before moving
    forward 100 pixels. This time, no line is drawn on the canvas since the drawing
    pen is not touching the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09002](Images/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: The turtle moves on the canvas to make a drawing.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll discuss in detail some basic movements in the *turtle* module that
    are useful for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: The forward() and backward() Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `forward()` function tells the turtle to move forward the specified number
    of pixels on the screen. The `backward()` function does the same backward. Enter
    the code shown in [Listing 9-2](#listing9-2) in a Spyder editor and save it as
    *forward_backward.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: Basic movement functions in the *turtle* module'
  prefs: []
  type: TYPE_NORMAL
- en: We set up the screen with a different background color and a title. At 1, the
    turtle moves forward 200 pixels. The default starting position of the turtle is
    at (x = 0, y = 0), facing to the right, so moving forward 200 pixels leads the
    turtle to the point (x = 200, y = 0).
  prefs: []
  type: TYPE_NORMAL
- en: At 2, the turtle moves from the point (x = 200, y = 0) backward 300 pixels,
    ending up at (x = –100, y = 0).
  prefs: []
  type: TYPE_NORMAL
- en: The left() and right() Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `left()` or `right()` function changes the direction the turtle is facing.
    As the argument, we give the degree of the angle to move by. For example, `90`
    degrees turns the turtle perpendicular to the original direction. A degree value
    of `360` turns the turtle in a full circle so it’s still going in the original
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: The script *left_right.py* in [Listing 9-3](#listing9-3) shows how the `left()`
    and `right()` functions work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: Python code for *left_right.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The `pensize()` function specifies the thickness of the line the turtle is drawing
    1. The default value is 1 pixel. Here we set the pen size to 5 pixels. At 2, we
    tell the turtle to turn right 30 degrees. Then, we move the turtle forward 200
    pixels. We then turn the turtle left 30 degrees and move backward 400 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The `pencolor()` function changes the color of the drawing pen to red 3. The
    default is black. After this step, the lines will be red instead of black.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you should see a screen similar to [Figure 9-3](#figure9-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09003](Images/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: The `left()` and `right()` functions in the *turtle* module'
  prefs: []
  type: TYPE_NORMAL
- en: The goto() Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `goto()` function tells the turtle to go to the specified point on the screen.
    Together with `up()` and `down()`, it can create straight lines and dashed lines.
    The `up()` function means the turtle pen is not touching the canvas and so doesn’t
    draw as it moves. The `down()` function puts the pen on the canvas and creates
    drawings.
  prefs: []
  type: TYPE_NORMAL
- en: If the turtle pen is in the down position, `goto()` will create a straight line
    between the current position and the specified position. However, if the turtle
    pen is in the up position, `goto()` will create nothing on the screen, but merely
    moving the turtle from the current position to the specified position. Dashed
    lines can be created by drawing a sequence of short lines with spaces in between.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the script *create_lines.py* in [Listing 9-4](#listing9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: Python code for *create_lines**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we tell the turtle to go to (x = 200, y = 100). By default, the turtle
    is in the down position and the starting position is (x = 0, y = 0), so `goto(200,100)`
    draws a line between the two points (0, 0) and (200, 100), as you can see in [Figure
    9-4](#figure9-4).
  prefs: []
  type: TYPE_NORMAL
- en: At 2, the script tells the turtle to lift up the pen so that no line is drawn
    on the screen when the turtle goes to another point. We then change the pen color
    to blue. At 3, we start a `for` loop. In each iteration, the turtle goes to a
    point, puts down the pen, and goes to another point 30 pixels to the right. This
    leaves a 30-pixel-long dash, done eight times with gaps between.
  prefs: []
  type: TYPE_NORMAL
- en: The `hideturtle()` function hides the turtle so that the black arrow cursor
    is not shown on the screen 4.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you should see a screen similar to [Figure 9-4](#figure9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09004](Images/f09004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: Use the `goto()` function to create lines using the *turtle* module.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *turtle* module has several built-in shapes, including the commonly used
    `dot()` function that creates a dot. You’ll also learn how to create basic shapes
    such as a triangle, a square, and gridlines.
  prefs: []
  type: TYPE_NORMAL
- en: Use the dot() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dot()` function creates a dot with the specified diameter and color. For
    example, the command `dot(30,'red')` creates a red dot with a diameter of 30 pixels.
    We’ll use this in our tic-tac-toe and Connect Four games to create game pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-5](#listing9-5), *dots.py*, shows how the `dot()` function works.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: Python code for *dots.py*'
  prefs: []
  type: TYPE_NORMAL
- en: First we lift up the pen 1. Then we go to the point (150, 100). We tell the
    turtle to put a red dot centered on the point (150, 100) and with a diameter of
    120 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move the turtle to (–150, 100) and draw a yellow dot with a diameter
    of 135 pixels. Note that you don’t need to use `up()` again since the pen is already
    lifted up. With the pen up, the turtle can still draw dots.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from 2, the turtle goes to (150, –100) and draws a blue dot with a
    diameter of 125 pixels. Then it goes to (–150, –100) and draws a green dot with
    a diameter of 140 pixels. [Figure 9-5](#figure9-5) shows the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09005](Images/f09005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: Create dots using the *turtle* module.'
  prefs: []
  type: TYPE_NORMAL
- en: Draw Your Own Shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also draw your own shapes using the *turtle* module. We’ll look at some
    basic shapes here.
  prefs: []
  type: TYPE_NORMAL
- en: Triangles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The easiest way to create a triangle is by using `goto()`. [Listing 9-6](#listing9-6),
    *triangle.py*, draws a triangle with the corners at (–50, –50), (50, –50), and
    (0, 100).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: Python code for *t**riangle.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The `tracer()` function tells the script whether to trace the movements of the
    turtle. The default value is `tracer(True)`, which means the script shows you
    the movement of the turtle step-by-step. When the turtle pen draws something,
    you’ll see the drawing, one stroke after another. Here, we use `tracer(False)`,
    so the final drawing is printed, but the script doesn’t show the intermediate
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: We change the pen’s color to blue 1 and its size to 5\. We lift up the pen and
    go to point (–50, –50) then put down the pen and go to point (50, –50). This forms
    the first leg of the triangle. With the pen down, we ask the turtle to go to point
    (0, 100), which forms the second leg. The base is drawn when we send the pen back
    to point (–50, –50) to complete the triangle.
  prefs: []
  type: TYPE_NORMAL
- en: Note that since we’ve used the command `tracer(False)` to not display each drawing
    step (thus saving time), we need to put `update()` at the end of the script to
    show the completed picture, as shown in [Figure 9-6](#figure9-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09006](Images/f09006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: Draw a triangle using the *turtle* module.'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can draw rectangles by using `goto()`, as we did for triangles, but we can
    also use `forward()` and `left()`. In many situations, you can achieve the same
    goal by using either the `goto()` function or the `forward()` and `left()` functions.
    If you know the coordinates of the destination, `goto()` is easier, and if you
    know the distances between two points, the directional functions are easier.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll use `forward()` and `left()`. You’ll achieve the same results by
    using `goto()` in the “End-of-Chapter Exercises” on page 187.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll draw a rectangle with the points (0, 0), (200, 0), (200, 100), and (0,
    100). Enter the script *rectangle.py* shown in [Listing 9-7](#listing9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: Python code for *r**ectangle.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We first set up the screen. At 1, we set the pen size to 6\. We don’t specify
    the pen color, so the default color of black will be used. At 2, the turtle moves
    forward 200 pixels from the initial position of (0, 0) to form the first side
    of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the turtle turns left 90 degrees so that it faces up. Then it moves forward
    100 pixels to form the second side. We then make the turtle turn left 90 degrees
    so that it faces west, and move it forward 200 pixels for the third side. The
    last side of the rectangle is formed similarly.
  prefs: []
  type: TYPE_NORMAL
- en: The output is shown in [Figure 9-7](#figure9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09007](Images/f09007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-7: Draw a rectangle using the *turtle* module.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this rectangle-drawing skill to create a board for our upcoming games.
  prefs: []
  type: TYPE_NORMAL
- en: Draw Grid Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Games such as tic-tac-toe and Connect Four use a grid. We can make a grid simply
    by drawing squares. Here we’ll draw a game board with six rows and seven columns;
    the horizontal lines will be thinner and lighter than the vertical ones to match
    what we’ll do in the Connect Four game. Enter the code from *grid_lines.py* in
    [Listing 9-8](#listing9-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: Python code for *g**rid**_l**ines.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We first set up the screen. Since we plan to draw a game board with six rows
    and seven columns, we set the screen size to 810 pixels wide and 710 pixels tall.
    This way, we can make each cell a square that’s 100 by 100 pixels, with a 55-pixel
    margin around the board. It’s important to think about your screen size so you
    can calculate the coordinates of various points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We draw eight thick vertical lines with a pen size of 5 1 to divide the screen
    into seven columns. The function `range(-350,400,100)` produces eight values:
    `-350, -250, ..., 350`.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we draw seven thin, gray, horizontal lines to form six rows 2. If
    you run the script, you’ll see a screen similar to [Figure 9-8](#figure9-8).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this board in Chapter 11 for our games.
  prefs: []
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn to create animation by using `clear()` and `update()`
    to clear the current image and replace it with the next, producing animation frames.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09008](Images/f09008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-8: Draw grid lines to form a six-by-seven game board'
  prefs: []
  type: TYPE_NORMAL
- en: How Animation Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `clear()` function erases everything the turtle has drawn on the screen.
    You can then redraw objects and use `update()` to put them onscreen. If you do
    this repeatedly, the rapid replacement of images will create an animation effect.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore animation by making a simple clock, shown in *turtle_clock.py*
    in [Listing 9-9](#listing9-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: Python code for *turtle_clock**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules and set up the screen. At 1, we start an infinite loop.
    In each iteration, the script first erases everything onscreen by using `clear()`.
    We then obtain the current time by using the *arrow* module and store the value
    in the variable `current_time`.
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` function from the *turtle* module writes text onscreen. It takes
    the text to be displayed as the first argument and the font to use as the second
    argument. At 2, we write `The Current Time Is` to the screen in blue. At 3, the
    script writes the current time in red.
  prefs: []
  type: TYPE_NORMAL
- en: The script then pauses for one second and makes sure that all the new drawings
    are updated by using `update()`. If you run the script, you’ll notice that the
    time changes every second ([Figure 9-9](#figure9-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09009](Images/f09009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-9: Create animation in the *turtle* module.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this method frequently to create animations in various games.
  prefs: []
  type: TYPE_NORMAL
- en: Use Multiple Turtles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll look at using two turtles simultaneously—the equivalent of using two
    pens. In Chapter 12, when we create a guess-the-word game, we’ll use one turtle
    to create a gold coin on the game board and another to count the number of chances
    the player has left. Whenever the player misses a letter, we’ll erase the previous
    number and change it to the new number. If we used only one turtle, everything,
    including the coin image, would be wiped. If we use a second turtle, we can keep
    everything else onscreen and change only whatever the second turtle draws.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 9-10](#listing9-10), *two_turtles.py*, we’ll use one turtle to draw
    a square and another to write something below it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: Python code for *two_turtles**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *turtle* module and set up a screen with a size of 810 by 710
    pixels. Starting at 1, we draw a blue square in the middle of the screen, similar
    to the way we drew a rectangle but with all sides the same length.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we create a second turtle with `Turtle()` and name it `msg`. We tell the
    script to hide the second turtle
  prefs: []
  type: TYPE_NORMAL
- en: The second turtle `msg` lifts up the pen, changes the color to red, goes to
    (–300, –200), and writes the message `this is written by the second turtle`. The
    `update()` function refreshes the screen to draw everything created by the two
    turtles, shown in [Figure 9-10](#figure9-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09010](Images/f09010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-10: A screen created with two turtles'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of the *turtle* module. You first learned
    how to set up a turtle screen and then learned basic movements like going forward
    or backward and turning left or right. You created various shapes by using both
    the built-in function and basic movement commands.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned to create animation effects in the *turtle* module by using
    the `clear()` and `update()` functions. In the next few chapters, you’ll learn
    how to use these skills to create voice-controlled graphical games.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *set_up_screen.py* so that the screen size is 500 pixels wide and 400
    pixels tall, the background color is blue, and the title is `Modified Screen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *forward_backward.py* so that the turtle first moves backward 100 pixels
    and then moves forward 250 pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *dots.py* to have only two light green dots with diameters of 60 at points
    (–100, –100) and (100, 100).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *triangle.py* so that the three sides of the triangle are red with a
    thickness of 3\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replicate the result in *rectangle.py* by using `goto()`. You aren’t allowed
    to use the functions `forward()`, `backward()`, `left()`, or `right()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tic-Tac-Toe
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voice-controlled tic-tac-toe game to put all
    your new skills into practice. You’ll draw a game board with blue and white game
    pieces, disallow invalid moves, and detect if a player has won. You’ll then add
    the speech recognition and text-to-speech functionality and set the game so you
    play with your own computer.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all scripts in this chapter are available at the book’s resources
    page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Before you begin, set up the folder */mpt/ch10/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Game Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tic-tac-toe is probably one of the most well-known games in the world, but just
    to be sure, I’ll go over the rules before we create our game board. In tic-tac-toe,
    two players take turns marking a cell with an X or O in a three-by-three grid.
    The first player to connect three Xs or Os in a row horizontally, vertically,
    or diagonally wins. If no one connects three before all the cells are full, the
    game is tied. Instead of X and O, we’ll use blue and white dots as game pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Draw the Game Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll draw a three-by-three grid on the screen and assign a number to each cell
    so we can tell the script where to place each game piece. Open your Spyder editor,
    copy the code in [Listing 10-1](#listing10-1), and save the script as *ttt_board.py*
    in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Drawing the tic-tac-toe game board'
  prefs: []
  type: TYPE_NORMAL
- en: We import all functions in the *turtle* module and set the screen to 600 by
    600 pixels. Because we have a three-by-three grid, each cell is 200 by 200 pixels.
    We set the background color to red and set the title as `Tic-Tac-Toe in Turtle
    Graphics`.
  prefs: []
  type: TYPE_NORMAL
- en: With the command `for i in (-100, 100)`, we iterate the variable `i` through
    the range –100 to 100 1. As a result, the `for` loop produces two horizontal lines
    and two vertical lines. The two horizontal lines are between points (–300, –100)
    and (300, –100) and points (–300, 100) and (300, 100). The two vertical lines
    are between points (–100, –300) and (–100, 300) and points (100, –300) and (100,
    300). These lines evenly divide the screen into nine cells.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a dictionary `cellcenter` to map each cell number to the x- and
    y-coordinates of the center of the corresponding cell 2. For example, the lower-left
    cell is cell number 1, and the coordinates of its center are (x = –200, y = –200).
    We do this for all nine cells in the dictionary, using the cell number as the
    key and the coordinates as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 3, we use the `for` loop to iterate through nine pairs of values to write
    the cell number at the cell’s center. The command `list(cellcenter.items())` produces
    a list of the nine key-and-value pairs from `cellcenter`, which should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At each iteration of the `for` loop, the turtle goes to the center of the cell
    and writes the cell number there. Run the script and you should see a screen similar
    to [Figure 10-1](#figure10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](Images/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: The board for tic-tac-toe'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Game Pieces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll add code to place game pieces in the cells. You’ll first learn how
    mouse clicks work in the *turtle* module and then use them to place the pieces.
  prefs: []
  type: TYPE_NORMAL
- en: How Mouse Clicks Work in turtle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you left-click on the turtle screen, the x- and y-coordinates of the point
    you clicked are displayed onscreen. [Listing 10-2](#listing10-2), *mouse_click.py*,
    handles a simple mouse click. This is just for example purposes; we won’t use
    this code in the final script but will use the same principles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: How mouse clicks work in the *turtle* module'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we import the *turtle* module and set up the screen. At 1, we define
    the function `get_xy()`, which prints out the x- and y-coordinates of your click.
    We also hide the turtle so you don’t see the cursor moving around the screen.
    At 2, we bind the onscreen mouse click to the `get_xy()` function by using the
    *turtle* function `onscreenclick()`, which returns the x- and y-coordinates of
    the click. As a result, `onscreenclick(get_xy)` supplies the x- and y-coordinates
    of your mouse click to `get_xy()` as its two inputs. At 3, we use `listen()` to
    detect events like mouse clicks and keyboard presses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *mouse_click.py*, randomly click the screen several times, and you should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For each of my five clicks, `onscreenclick()` captured the x- and y-coordinates
    of the point and provided the two values to `get_xy()`, which printed out the
    corresponding x- and y-values.
  prefs: []
  type: TYPE_NORMAL
- en: Convert Mouse Clicks to Cell Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll combine the board creation and click detection scripts so that when
    you click a cell, the script prints out the cell number. In [Figure 10-2](#figure10-2),
    I’ve marked the row and column numbers on the game board along with the x- and
    y-coordinates of the gridlines.
  prefs: []
  type: TYPE_NORMAL
- en: Open *ttt_board.py*, add the code in [Listing 10-3](#listing10-3) at the bottom
    (above `t.done()`) and save the new script as *cell_number.py* in your chapter
    folder. This script is just an example; we won’t use it in the final code but
    will use something similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: Converting mouse clicks to cell numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '![f10002](Images/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: Mark the row and column numbers on the game board.'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define `cell_number()`, which will convert the x- and y-coordinates
    of the mouse click to the cell number. Inside the function, we restrict the x-
    and y-coordinates of the point you click to the range of the board. If you click
    outside the range, the script will print `you have clicked outside the game board`.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we convert the x-coordinate of the click to the column number. Points
    in column 1 have x-coordinates between –300 and –100, and points in column 2 have
    x-coordinates between –100 and 100, so we use the formula `col = int((x+500)//200)`
    to get the full range of pixel coordinates in the column so we can convert the
    x-coordinate to the column number. We use the same method to convert the y-coordinate
    to the row number.
  prefs: []
  type: TYPE_NORMAL
- en: We then calculate the cell number by using the formula `cellnumber = col+(row-1)*3`
    because the cell numbers increase from left to right and then from bottom to top
    3. Finally, we bind the onscreen click to `cell_number()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *cell_number.py*. Here’s the output from one exchange with the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each time you click a cell, the script prints out the column number, row number,
    and cell number.
  prefs: []
  type: TYPE_NORMAL
- en: Place Game Pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll place the game pieces on the board. When you first click any of
    the nine cells, a blue piece will appear at the center of the cell. When you click
    again, the piece will be white, then blue, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Open *ttt_board.py*, add the code in [Listing 10-4](#listing10-4), and save
    the new script as *mark_cell.py* in your chapter folder. Make sure you don’t add
    this code snippet to *cell_number.py*!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: Placing game pieces on the board'
  prefs: []
  type: TYPE_NORMAL
- en: We draw the board and then define the variable `turn` that will keep track of
    whose turn it is. We first assign the value `blue` to the variable so that the
    blue player moves first.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 1, we define `mark_cell()`, which places a piece in the cell you click.
    At 2, we declare the global variable `turn`. Python provides the `global` keyword,
    which allows `turn` to be used both inside and outside `mark_cell()`. Without
    making the variable global, you’d get the error message `UnboundLocalError: local
    variable ''turn'' referenced before assignment` each time you clicked the board.'
  prefs: []
  type: TYPE_NORMAL
- en: We then convert the x- and y-coordinates of the click to the cell number on
    the game board 3. Within the same line, we also convert the cell number from an
    integer to a string to match the variable type used in the dictionary `cellcenter`.
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we get the coordinates for the center of the clicked cell from `cellcenter`
    and tell the turtle to go there. The turtle places a dot 180 pixels wide and the
    color of the value stored in `turn`. After that, the turn is over, and we assign
    the turn to the other player. Finally, we bind `mark_cell()` to the mouse-click
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you’ll be able to click the board and mark the cell. The
    color of the dot will alternate between blue and white, as in [Figure 10-3](#figure10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10003](Images/f10003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: Mark cells on the tic-tac-toe board.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is now a playable game! However, we need to implement three new
    rules to make it follow the rules of tic-tac-toe:'
  prefs: []
  type: TYPE_NORMAL
- en: If a cell is already occupied, you cannot mark it again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player marks three cells in a straight line—either horizontally, vertically,
    or diagonally—the player wins, and the game should stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all nine cells are occupied, the game should stop, and a tie should be called
    if no player wins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine Valid Moves, Wins, and Ties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll implement those rules, allowing only valid moves and declaring wins
    (or ties). Download *ttt_click.py* from the book’s resources and save it in your
    chapter folder or alter *mark_cell.py* with the differences highlighted in [Listing
    10-5](#listing10-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Allow only valid moves and declare wins and ties.'
  prefs: []
  type: TYPE_NORMAL
- en: Our first change is to import the *messagebox* module from the *tkinter* package;
    this module displays a message box for a win, tie, or invalid move.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 1, we create a variable `rounds`, a list `validinputs`, and a dictionary
    `occupied`. The variable `rounds` keeps track of the number of turns taken, which
    is the number of cells that have been marked. When the number of rounds reaches
    nine and no player wins (which is often the case in tic-tac-toe), we’ll declare
    a tie game.
  prefs: []
  type: TYPE_NORMAL
- en: We use `validinputs` to determine whether a move is valid. If a cell is marked
    by a player, we’ll remove it from the list of valid moves.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary `occupied` keeps track of each player’s moves. At the beginning
    of the game, the keys `blue` and `white` both have an empty list as their value.
    When a player occupies a cell, the cell number will be added to that player’s
    list. For example, if the blue player has occupied cells 1, 5, and 9 and the white
    player has occupied cells 3 and 7, `occupied` will become `{"blue":["1","5","9"],"white":["3","7"]}`.
    We’ll use this later to determine whether a player has won the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 2, we define `win_game()`, which checks whether a player has won the game.
    There are eight ways a player can win, which we explicitly check for:'
  prefs: []
  type: TYPE_NORMAL
- en: Cells 1, 2, and 3 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 4, 5, and 6 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 7, 8, and 9 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 1, 4, and 7 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 2, 5, and 8 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 3, 6, and 9 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 1, 5, and 9 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 3, 5, and 7 have been occupied by the same player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function `win_game()` creates the variable `win` and assigns `False` as
    a default value. The function checks the dictionary `occupied` for the list of
    cells occupied by the player who currently has the turn, checking all eight win
    cases listed earlier. If one of the cases matches, the value `win` changes to
    `True`. When `win_game()` is called, it returns the value stored in the variable
    `win`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made significant changes to `mark_cell()`. At 3, we declare three global
    variables; all must be declared global because they will be modified inside the
    function. At 4, we check whether the cell number most recently clicked is in the
    list `validinputs`; if it is, a dot is placed in the cell, and the cell number
    is added to the player’s list of occupied cells 5. The cell is then removed from
    `validinputs` so that players can’t mark the same cell in future rounds.
  prefs: []
  type: TYPE_NORMAL
- en: At 6, we call `win_game()` and see whether the current player has won the game.
    If yes, we change `validinputs` to an empty list so no further moves can be made.
    A message box will pop up to say, `Congrats player blue, you won!` or `Congrats
    player white, you won!`, using `showinfo()` from the *messagebox* module ([Figure
    10-4](#figure10-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10004](Images/f10004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: A win for blue!'
  prefs: []
  type: TYPE_NORMAL
- en: If the player hasn’t won, the script checks whether the number of rounds has
    reached nine 7. If yes, the script declares a tie game, displaying `Game over,
    it's a tie!` ([Figure 10-5](#figure10-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10005](Images/f10005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: A tied game'
  prefs: []
  type: TYPE_NORMAL
- en: If the game doesn’t end, we increase the number of rounds by one and assign
    the turn to the other player. During the game, if a player clicks an invalid cell,
    we’ll display `Sorry, that's an invalid move!` ([Figure 10-6](#figure10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10006](Images/f10006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: An invalid move'
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to add the voice control and speech functionality. One significant
    change is that we’ll now make your opponent your computer. We’ll build on the
    latest *ttt_click.py* file. After you make a move as the blue player, the computer
    will randomly select a move as the white player until the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Download *ttt_hs.py* from the book’s resources or make the changes shown in
    [Listing 10-6](#listing10-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Adding speech and voice-control functionality'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the functions we’ll need: the `choice()` function from the *random*
    module to let the computer randomly select a move and our `print_say()` and `voice_to_text()`
    functions from the custom package *mptpkg*.'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start an infinite `while` loop. At each iteration, the script asks
    for your move out loud. You speak into the microphone to make your move, and the
    script captures your voice command, storing the response in the variable `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we did a little tweaking to make `voice_to_text()` more responsive to
    your voice commands. When your voice input is just one word, such as “One” or
    “Two,” it’s hard for the software to put the word in context and respond. On the
    other hand, if you say “Number one” or “Number two,” the software can easily pick
    up your meaning. The script simply replaces the “number” part of the voice command
    with an empty string so that only the number is left in `inp`. Sometimes `voice_to_text()`
    returns the number in word form such as `one` or `two`, instead of in numeric
    form, such as `1` or `2`. We therefore also change all the word forms to numerical
    forms. This way, you can say “number one” or “one” to the microphone, and `inp`
    will always be in the form you want: `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your choice is in `validinputs`, the script performs the sequence of actions
    to make the move: place a dot in the corresponding cell, add the cell number to
    your list of occupied cells, and remove the occupied cell number from the list
    of valid inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks if you’ve won or tied the game 2 and responds out loud
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Once your turn is over, the computer randomly selects a move from `validinputs`
    to play against you 3. The script checks whether the computer has won or tied
    the game. If your voice command is not a valid move, the script speaks an alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one interaction with the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I’ve managed to win in just three moves!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to build a voice-controlled graphical tic-tac-toe
    game that talks in a human voice. Along the way, you learned a few new skills.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how mouse clicks work in the *turtle* module. With that knowledge,
    we marked cells on the game board with mouse clicks.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to determine whether a player has won tic-tac-toe based on the
    explicit game rules. This is at the heart of game creation. You listed all cases
    when a player can win the game, then added code to check all cases and see whether
    there is a winner.
  prefs: []
  type: TYPE_NORMAL
- en: You also added the speech recognition and text-to-speech features to a game,
    making a few tweaks to make sure the script can understand your input. By combining
    these skills, you’ll be able to create your own voice-controlled games.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *ttt_board.py* so that the cell number appears in 15-point font at the
    lower-left corner of each cell (80 pixels from the center of the cell, both horizontally
    and vertically).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *mouse_click.py* so that each time you click the screen, the script prints
    out the additional message `x + y is`, followed by the actual value of the x-
    and y-coordinates of the clicked point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *cell_number.py* so that each time you click the screen, the script prints
    `you clicked the point (``x``,` `y``)` before printing the column, row, and cell
    numbers, where `x` and `y` are the actual coordinates. For example, if you click
    the point (x = –100, y = 50), the message should say `you clicked the point (-100,
    50)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *mark_cell.py* so that the white player moves first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *ttt_click.py* so that a player wins only by marking three cells in a
    row horizontally or vertically, but not diagonally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connect Four
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voice-controlled Connect Four game. As with
    tic-tac-toe in Chapter 10, you’ll first draw the board and set the yellow and
    red game pieces to alternate turns. You’ll animate the effect of a disc falling
    from the top of a column to the lowest available row to make the game more visually
    engaging. You’ll disallow invalid moves, detect if a player has won, and detect
    if all 42 cells have been occupied with no winner, meaning the game is tied.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 10, you learned how to check whether a player has won the game by
    laying out all winning scenarios and checking whether the current game board matches
    one of the scenarios. We’ll apply that same strategy here. You’ll also learn how
    to use exception handling to prevent crashing during the process of checking and
    how to prevent negative indexing errors.
  prefs: []
  type: TYPE_NORMAL
- en: Once the game is set up, we’ll add the speech recognition and text-to-speech
    features so you can play the game with your voice alone.
  prefs: []
  type: TYPE_NORMAL
- en: To start, set up the folder */mpt/ch11/* for this chapter. All scripts in this
    chapter are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: Game Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connect Four is a well-known board game, but I’ll go over the rules to clarify
    the logic in the upcoming code. In Connect Four, two players take turns dropping
    discs into one of seven columns, from the top. One player has red discs and the
    other yellow. The seven columns are on a six-row, vertically suspended grid. When
    a disc is dropped into a column, it will fall to the lowest available space in
    that column. Discs cannot move from one column to another.
  prefs: []
  type: TYPE_NORMAL
- en: The first player who forms a direct line—either horizontally, vertically, or
    diagonally—with four of their game pieces wins. If all 42 slots have been filled
    and nobody has won, the game is tied. We’ll use a red dot and a yellow dot to
    represent the discs.
  prefs: []
  type: TYPE_NORMAL
- en: Draw the Game Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first draw a grid with six rows and seven columns. We’ll number the columns
    at the top of the screen to make it easier to play.
  prefs: []
  type: TYPE_NORMAL
- en: Open your Spyder editor and enter the code from [Listing 11-1](#listing11-1).
    Save the script as *conn_board.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: Drawing the Connect Four game board'
  prefs: []
  type: TYPE_NORMAL
- en: We first import all functions in the *turtle* module, and then we set up the
    screen as 700 by 600 pixels 1. That lets us make each cell 100 by 100 pixels to
    keep things simple. We set the background color to light green and the title to
    `Connect Four in Turtle Graphics`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then draw six thick vertical lines to divide the screen into seven columns.
    At 2, we set the pen width to 5 pixels. The command line `for i in range(-250,350,100)`
    tells the variable `i` to iterate through the following six values: –250, –150,
    –50, 50, 150, and 250\. These are the x-coordinates of the six vertical lines.
    The y-coordinates of the two endpoints of the six vertical lines are all –350
    and 350\. Similarly, we draw five thin, gray horizontal lines to divide the screen
    into six rows, starting at 3, with a pen size of 1 pixel and color of gray so
    that the lines appear thin and light. This all gives us an even grid with seven
    columns and six rows.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we number the columns to let players know where to place the discs. We
    first create a variable `colnum` and assign a value `1` to it 4. We then iterate
    through the x-coordinates of the center of the seven columns and write the corresponding
    column number by adding one to the value of `colnum`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you should see a screen like [Figure 11-1](#figure11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11001](Images/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The board for the Connect Four game'
  prefs: []
  type: TYPE_NORMAL
- en: The Mouse-Click Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you have a game board. Let’s drop some discs into the columns. In this section,
    you’ll learn how to use mouse clicks to place a disc in a column and let it fall
    to the lowest available cell. After that, you’ll detect invalid moves, wins, and
    ties.
  prefs: []
  type: TYPE_NORMAL
- en: Drop a Disc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, you’ll use mouse clicks to place a disc in a column of your choice. The
    column number in which the disc will appear is determined by where you click.
    The row number depends on the number of discs already in that column.
  prefs: []
  type: TYPE_NORMAL
- en: When you first click a column, a red dot will be placed in the lowest available
    cell. The colors will alternate with each click.
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_board.py* and add the code in [Listing 11-2](#listing11-2). Then
    save the new script as *show_disc.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Dropping discs on the game board'
  prefs: []
  type: TYPE_NORMAL
- en: The red player goes first, so after the game board is drawn, we define the variable
    `turn` and assign the value `red` to it 1. Starting at 2, we define three lists.
    The list `xs` contains values corresponding to the x-coordinates of the middle
    points of the seven columns. The list `ys` has six values corresponding to the
    y-coordinates of the middle points of the six rows. Later, we’ll use these lists
    to determine the x- and y-coordinates of the center of all 42 cells.
  prefs: []
  type: TYPE_NORMAL
- en: The list `occupied` is a list of lists. It starts as a list of seven empty lists,
    each representing a column. When you place a disc in a column, the disc will be
    added to the corresponding list. This way, `occupied` will keep track of all discs
    placed and their positions.
  prefs: []
  type: TYPE_NORMAL
- en: At 3, we define `conn()`, which places the disc on the column you click. We
    declare `turn` as a global variable, so that its value can be recognized both
    inside and outside `conn()`. Then, we convert the x-coordinate of the user’s click
    to the column number on the game board. We then determine the lowest row available
    in that column, which tells us which row to place the disc in. Note that `occupied[col-1]`
    is the list of all discs currently in the column, and we use `col-1` instead of
    `col` because Python uses zero indexing but our columns are numbered starting
    at 1\.
  prefs: []
  type: TYPE_NORMAL
- en: We then obtain the x- and y-coordinates of the center of the cell in which to
    place the new disc. The *turtle* module places a dot with a diameter of 80 pixels
    and the color value stored in `turn`. We add the disc to the corresponding list
    within `occupied` so that next time a disc is placed in the same column, the appropriate
    cell is marked as invalid. With this, the player’s turn is over, and we hand the
    turn to the other player. Finally, we bind `conn()` to the mouse-click event.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script, and you should be able to click on the game board and mark the
    cell with a red or yellow dot. Keep clicking, and the color of the dot will alternate
    between red and yellow ([Figure 11-2](#figure11-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11002](Images/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Place discs on the Connect Four game board.'
  prefs: []
  type: TYPE_NORMAL
- en: Animate the Falling Discs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you play Connect Four in the real world, you drop the disc at the top,
    and it falls into the proper position. Next, you’ll create the animation effect
    of the disc falling. This is a good opportunity to learn how to create animation
    effects using the *turtle* module.
  prefs: []
  type: TYPE_NORMAL
- en: Open *show_disc.py* and add the code in [Listing 11-3](#listing11-3). Save this
    as *disc_fall.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Script to show the animation effect of discs falling'
  prefs: []
  type: TYPE_NORMAL
- en: We import `sleep()` so we can pause the script to let the falling disc stay
    in a cell for a short while, allowing the user to see its movement 1. Starting
    at 2, we create a second turtle named `fall`. We lift the drawing pen of the new
    turtle so that it won’t leave a line as it moves. We also use `hideturtle()` to
    hide the cursor 3.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 4, we animate the falling disc. We first see if the column is full
    by checking whether the row number is less than 6\. If yes, we’ll show the animation
    effect. If the lower rows in the column are full, the disc can be left in place
    (there’s no need to show the disc falling).
  prefs: []
  type: TYPE_NORMAL
- en: We iterate `i` through all the empty cells above the lowest available cell.
    If the lowest available position is `row = 2`, for example, the command `for i
    in range(6,row,-1)` iterates `i` through values 6, 5, 4, and 3\. The `-1` tells
    the range function to count backward. At each iteration, the `fall` turtle places
    a dot in the center of the empty cell. The script draws a dot to the screen, pauses
    for 0.05 seconds, and then erases the dot before going to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is now a complete game! However, at the moment, players must use
    their own judgment to enforce the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a column is already full, you cannot drop a disc in it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player connects four cells in a straight line, that player wins, and the
    game should stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all 42 cells are occupied and nobody has won, the game should stop and a
    tie be declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s code that into the game.
  prefs: []
  type: TYPE_NORMAL
- en: Determine Valid Moves, Wins, and Ties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll improve the game by blocking invalid moves and declaring wins or
    ties. Open *disc_fall.py* and add the code in [Listing 11-4](#listing11-4). Save
    the new script as *conn_click.py*. The code changes are shown in two sections,
    so it’s easier to refer back to the code when reading the explanations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: First half of the script to disallow invalid moves and declare
    wins and ties'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *messagebox* module from the *tkinter* package to allow us to
    display messages about wins, ties, and invalid moves.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create the list `validinputs` to keep track of valid moves. All seven
    columns are valid to start with. If a column contains six discs, it will be removed
    from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A player can win the game by collecting four discs in a row in one of four
    orientations: horizontally, vertically, diagonally in a forward-slash fashion
    (/), or diagonally in a backslash fashion (\). Therefore, we define four functions
    to check for each way of winning.'
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `horizontal4()`, which checks if a player has won the game by
    successfully connecting four discs in a row horizontally. In the function, we
    create the variable `win` and assign a default value of `False`. The function
    then checks whether the player has connected four discs horizontally. If yes,
    the value of `win` changes to `True`. When the function `horizontal4()` is called,
    it returns the value stored in the variable `win`. Let’s look at the details of
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use `x = col-1` and `y = row-1` to convert column and row numbers on the
    game board to indexes in the `occupied`list. The cell with column number `col`
    and row number `row` corresponds to `occupied[x][y]` in `occupied`. For simplicity,
    we’ll call this cell `[x][y]` for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A player can connect four pieces horizontally in four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Cells `[x-3][y]`, `[x-2][y]`, and `[x-1][y]` all have the same color as cell
    `[x][y]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells `[x-2][y]`, `[x-1][y]`, and `[x+1][y]` all have the same color as cell
    `[x][y]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells `[x-1][y]`, `[x+1][y]`, and `[x+2][y]` all have the same color as cell
    `[x][y]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells `[x+1][y]`, `[x+2][y]`, and `[x+3][y]` all have the same color as cell
    `[x][y]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We therefore define a variable `dif` to iterate through four values `(-3, -2,
    -1, 0)`. For each value of `dif`, we check whether all four cells—`[x+dif][y]`,
    `[x+dif+1][y]`, `[x+dif+2][y]`, and `[x+dif+3][y]`—have the same color. If yes,
    we change the value of `win` to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we need to make exceptions for `IndexError` because, for example,
    the value of `x+3` may be 8, but the board has only seven columns. If we do not
    make exceptions for `IndexError`, the script will crash in the process of checking
    whether the player has won the game.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we ensure that none of the indexes have negative values, because negative
    indexing has a very specific meaning in Python. In Python, a negative index wraps
    around to the beginning of the list instead of falling off at the end. For example,
    index `-1` refers to the last element in a list in Python, `-2` to the second
    to last, and so on. Negative indexing will not raise an `IndexOutOfBounds` error,
    but it will also not behave as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example: for x = 1 and y = 2, when the script checks
    the cell `[x-3][2]`, it will look at cell `[-2][2]`, which is actually cell `[5][2`]
    because `-2` refers to the second-to-last value in x, which is 5 (that is, the
    sixth column, since there is a total of seven columns). Therefore, we put the
    condition `x+dif> = 0` in the function to ensure that we have no negative indexing
    anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `try` and `except` in every one of the four cases of winning
    by connecting four discs horizontally. If instead we had used just one set of
    `try` and `except` for all four cases of wins, whenever any `IndexError` occured,
    the script would skip all remaining cases and go to the `except` branch directly.
    This would cause the script to fail to identify many cases of wins.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we define `vertical4()` to check for a win by connecting four discs
    in a row vertically 3. Then `forward4()`checks for a forward diagonal win, and
    `back4()`checks for a backward diagonal win.
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we define `win_game()`, which checks for a win in any of the 13 win scenarios
    (four horizontally, one vertically, four diagonally in a forward-slash fashion,
    and four diagonally in a backslash fashion). In `win_game()`, we create the variable
    `win` and assign a default value of `False`. The function first converts column
    and row numbers, `col` and `row`, to indexes in the `occupied`list, `x` and `y`.
    The function then calls the four functions just defined to see if the player may
    have won. If any of the four functions returns a value of `True`, the value of
    `win` changes to `True`, and `win_game()` will return a value of `True` when it’s
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s examine the second half of the script (which we are saving as *conn_click.py*),
    shown in [Listing 11-5](#listing11-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: Second half of the script to disallow invalid moves and declare
    wins and ties'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create the variable `rounds`to keep track of the number of rounds played,
    corresponding to the number of discs on the game board, so that we can declare
    a tie when the number reaches 42\.
  prefs: []
  type: TYPE_NORMAL
- en: We change `conn()` 2 to declare three global variables so that their values
    can be recognized both inside and outside the function. At 3, we call `win_game()`
    to see whether anyone has won. If yes, we change `validinputs` to an empty list
    so no further moves can be made. A message box will pop up that says `Congrats
    player red, you won!` or `Congrats player yellow, you won!`
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-3](#figure11-3) shows the red player winning a game.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11003](Images/f11003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Red wins! The darker discs are red, and the lighter are yellow.'
  prefs: []
  type: TYPE_NORMAL
- en: If no one has won but `rounds` reaches 42, the script declares a tie game ([Figure
    11-4](#figure11-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11004](Images/f11004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: A tied game'
  prefs: []
  type: TYPE_NORMAL
- en: If no player has won or the game is not tied, we increase the value of `rounds`
    by one and assign the turn to the other player. We also update the list of valid
    moves. If the number of discs in the current column reaches six, we remove the
    column number from the list `validinputs` 4.
  prefs: []
  type: TYPE_NORMAL
- en: During the game, if a player clicks an invalid cell 5, a message box will say
    `Sorry, that's an invalid move!` ([Figure 11-5](#figure11-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11005](Images/f11005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: An invalid move'
  prefs: []
  type: TYPE_NORMAL
- en: The Voice-Controlled Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to add the voice control functionality!
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll set the computer as your opponent in the game. After you make a
    move as the red player, the computer will randomly select a yellow move until
    the game ends. Once you understand how playing against a computer works, a voice-controlled
    game in which you play against another person is really simple. I’ll leave that
    as an end-of-chapter exercise, and the script is provided at the book’s resources
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_hs.py* from the book’s resources and save it in your chapter
    folder. [Listing 11-6](#listing11-6) highlights the differences between *conn_hs.py*
    and *conn_click.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: Script highlights for the voice-controlled Connect Four game'
  prefs: []
  type: TYPE_NORMAL
- en: We import a few extra modules. The `choice()` function from the *random* module
    lets the computer randomly select a move to play against you. We also import our
    local `print_say()` and `voice_to_text()` functions from the local package *mptpkg*
    to handle the voice-control functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we’ll use string values instead of integers to represent the seven
    column numbers in the list `validinputs`, because voice inputs are naturally string
    variables and, in many cases, attempting to convert voice inputs to integers will
    crash the script.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start an infinite `while` loop. At each iteration, the script asks
    for your move out loud. You speak into the microphone to make your move, and the
    script captures your voice command and stores it in `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: Here we did a little tweaking to make `voice_to_text()` more responsive to your
    voice commands, as we did in Chapter 10 (see [Listing 10-6](c10.xhtml#listing10-6)
    as a reminder). Further, the script always interprets *number four* as `number
    for`, so we replace `for` with `4` to get a better response from the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your voice command is not in `validinputs`, the script reminds you out loud:
    “Sorry, that’s an invalid move!” I’ve moved up the invalid voice input so that
    the `if` and `else` branches are close together in the script, making it easy
    for you to understand the logic. If the two branches are far apart, it’s easy
    to get lost in the long lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: If your voice command is a valid move 2, the script will place the disc as directed,
    let the disc fall to the lowest available space in the column, add the cell number
    to your list of occupied cells, remove the cell number from the list of valid
    inputs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks whether you won the game and, if you have, congratulates
    you out loud 3. If not, it will check for a tie and announce accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: When your turn is over, and if you haven’t won or tied the game, the computer
    randomly selects a move from `validinputs` to play against you 4, make the move,
    and check whether the computer has won the game 5. It will also check for a tie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the printed message from one interaction with the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-6](#figure11-6) shows my winning game.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11006](Images/f11006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Red winning the voice-controlled version'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you created a voice-controlled graphical Connect Four game
    that talks back to you in a human voice. You set up the game board and mechanisms
    as you did in Chapter 10, but this time animated the moves.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to let Python determine whether a player has won the game. In
    the process, you learned to lay out all cases of winning and use the script to
    check each one. You also learned how to properly use exception handling and prevent
    negative indexing from causing mistakes in your script.
  prefs: []
  type: TYPE_NORMAL
- en: You added the voice recognition and text-to-speech features, but also did a
    bit of refactoring to make sure your code stayed user readable as you added to
    it. In the next couple of chapters, you’ll create more voice-controlled graphical
    games and make them intelligent.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *conn_board.py* so that six row numbers appear at the right of the screen,
    with the top row being 6 and the bottom row being 1\. Make the x-coordinates of
    the row numbers 325.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *disc_fall.py* so that the discs fall at twice the speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *conn_click.py* so that a player wins only by connecting four discs of
    the same color horizontally or diagonally, and not vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currently, when you play Connect Four using the final *conn_hs.py*, you can
    say either “number four” or “four” if you want to place a disc in column 4\. Modify
    the script so that you can also say “column four” to place a disc in that column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *conn_hs.py* so that you play against a person instead of the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Guess-the-Word Game
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voice-controlled graphical guess-the-word game.
    This is an interesting challenge because when playing guess-the-word, players
    often talk quickly, so we’ll need to fine-tune our script’s listening abilities.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we’ll go over the game rules and draw a game board; this game board
    uses six coins to represent your six guesses. You’ll learn how to load a picture
    to a Python script and create multiple images of it onscreen. You’ll also learn
    to make the images disappear one by one.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start the game by using written inputs. Then, when we have it working
    well, we’ll add the speech recognition and text-to-speech features.
  prefs: []
  type: TYPE_NORMAL
- en: All scripts in this chapter are available on the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch12/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Game Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our guess-the-word game is loosely based on the hangman game. Our game will
    present only four-letter words to keep it simple, but you should try adapting
    it later when you’re comfortable with how it all works. Let’s go over the rules
    of the game first.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to hangman, our guess-the-word game involves two players. The first
    player thinks of a word and draws a number of dashes equal to the number of letters
    in the word. The first player also draws six coins in the middle of the screen
    to represent the six incorrect guesses the second player will be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The second player tries to figure out the word by guessing one letter at a time.
    If the suggested letter is in the word, the first player fills in the blanks with
    the letter in the right places. If a suggested letter is not in the word, the
    first player erases a coin in the middle of the screen. If the second player completes
    the word before making six incorrect guesses, they win the game. If that player
    fails to identify the word before using up their six wrong guesses, they lose.
  prefs: []
  type: TYPE_NORMAL
- en: Draw the Game Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game board will preload with four dashes to represent the word. We’ll also
    include the message `incorrect guesses` onscreen. Open your Spyder editor and
    enter the code in [Listing 12-1](#listing12-1), saving it as *guess_word_board.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Python script to draw the guess-the-word game board'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *turtle* module and set up the screen to be 600 by 500 pixels
    with a lavender background. The title will read `Guess the Word Game in Turtle
    Graphics`. Note that we omitted the last two arguments in `setup()`, so the game
    board will appear at the center of your computer screen by default.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create a variable `score` to keep track of the number of guesses the
    player has left. It starts with a value of 6\. Later in the game, every time the
    player guesses an incorrect letter, the value will decrease by 1\. We also create
    a new turtle named `left`, representing the number of guesses remaining. We use
    the new turtle to write the number of chances the player has left, erasing whatever
    was there before. By using a new turtle, we limit the number of objects we need
    to redraw onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: We then add the text `incorrect guesses`, which will later show the incorrect
    letters the player guessed. We draw four dashes at the bottom of the board 3 to
    hold the four letters in the word. Run the script and you should see a board similar
    to [Figure 12-1](#figure12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f12001](Images/f12001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: The board for the guess-the-word game'
  prefs: []
  type: TYPE_NORMAL
- en: The Text Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll place the six coins on the screen and enable the player
    to enter letters with the keyboard. You’ll then determine whether a player has
    won or lost the game. This completes the silent version of guess-the-word.
  prefs: []
  type: TYPE_NORMAL
- en: Load the Coins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll place six coins at the center of the screen. In the process, you’ll learn
    how to load a picture to the script, resize it to any shape you like, and place
    as many objects on the turtle screen as you like. As noted, each coin corresponds
    to one incorrect guess.
  prefs: []
  type: TYPE_NORMAL
- en: Download the picture file *cash.png* from the book’s resources and place it
    in your chapter folder. Open *guess_word_board.py*, add the highlighted code in
    [Listing 12-2](#listing12-2), and save the new script as *show_coins.py* in the
    same chapter folder containing *cash.png*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Script to show and remove coins'
  prefs: []
  type: TYPE_NORMAL
- en: We import the `PhotoImage()` class from the *tkinter* module and the `sleep()`
    function from the *time* module. We then load *cash.png* by using `PhotoImage()`
    1. We use `subsample()` to scale the image to the size we want. In this case,
    we use scale factors of `(10,10)`, which means that both the width and the height
    of the picture are one-tenth that of the original picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 2, we create a list `coins` with six elements by using `[0]*6`. If you print
    out the list, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ll change the elements later; the `0` values are just placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new turtle in each element in `coins`. We then make the coin
    turtles go to the center of the screen and line up horizontally. To demonstrate
    how to load and then hide the coins, we have them stay onscreen for three seconds
    3 before using `hideturtle()` from the *turtle* module to make them disappear
    from the screen one at a time, starting with the last one.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-2](#figure12-2) shows the screen in the first three seconds, as
    the coins are lined up.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f12002](Images/f12002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: Showing coins on the guess-the-word game board'
  prefs: []
  type: TYPE_NORMAL
- en: Guess the Letters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next version of the game will use 15 four-letter words, picked from a list
    of the most commonly used four-letter words according to Professor Barry Keating’s
    website at the University of Notre Dame (*https://bit.ly/3g7z7cg*). Keating has
    done extensive work in the fields of business forecasting and data mining. He
    is also the coauthor of the popular textbook *Forecasting and Predictive Analytics*
    (McGraw Hill, 2018).
  prefs: []
  type: TYPE_NORMAL
- en: After we make the following modifications, the script will randomly choose one
    word, ask you to guess a letter, and then accept input from the IPython console.
    If a guess is right, the letter will show up on one of the dashes corresponding
    to the position of the letter in the word. In the rare case that the letter appears
    in the word twice, the letter will show up on two of the dashes. If the letter
    is not in the word, it will show up at the top of the screen in the list of incorrect
    guesses. We’ll skip placing the coins in this script to make testing of the code
    easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Open *guess_word_board.py*, add the highlighted code in [Listing 12-3](#listing12-3),
    and save the new script as *guess_letter.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Script to put letters on the game board'
  prefs: []
  type: TYPE_NORMAL
- en: We first import `choice()` from the *random* module so the script can randomly
    pick a word from the list. We put the 15 words in the list `words` 1 and allocate
    the randomly selected word to `word`. At 2, we create the list `missed` to hold
    all incorrectly guessed letters. We then put the script in an infinite loop3 to
    continuously take your text input. If you want to stop the loop, you can enter
    `done` in the Spyder IPython console.
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we check whether the letter you guess is in one of the letters in `word`.
    We use `list()`, which takes a string variable as input and breaks it into a list
    of individual letters; for example, the command `list("have")` produces the list
    `["h","a","v","e"]`.
  prefs: []
  type: TYPE_NORMAL
- en: If your guessed letter is in `word`, the function checks every letter in `word`
    to see if your guess matches the letter in that position. If so, the function
    writes the letter on the corresponding position onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: If your guess is not in `word` 5, the letter is added to `missed` and is written
    at the top of the screen in the `incorrect guesses` section.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also removed the line `t.done()` in this script. This means that,
    once you finish guessing and enter `done`, the script will end and everything
    will disappear from your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output from one exchange with the script, when the script randomly
    selected the word *have* from the list of the 15 words, with my typed input in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-3](#figure12-3) shows the resultant screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f12003](Images/f12003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: A guess-the-word game board with letters on it'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s working, but you may have noticed that some things need improvement. To
    have a complete version of guess-the-word, we need the script to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevent the players from guessing the same letter more than once. In my preceding
    interaction, I guessed *b*, *v*, and *h* twice, wasting my guesses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notify the players when a word is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop taking input after a player completes the word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the six coins onscreen and remove one every time a player misses a letter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine Valid Guesses, Wins, and Losses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll disallow duplicate-letter guesses, declare a win if you complete
    the word while missing fewer than six letters, and declare a loss if not.
  prefs: []
  type: TYPE_NORMAL
- en: Open *guess_letter.py* and add the highlighted parts in [Listing 12-4](#listing12-4).
    Then save the new script as *guess_word.py*. A block of code in *guess_letter.py*
    is modified and replaced by the newly added blocks. If you’re uncertain what’s
    different, download the script *guess_word.py* from the book’s resources page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: A graphical guess-the-word game that takes written input'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *messagebox* module from the *tkinter* Python package again so
    we can display messages to the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 1, we display the six coins onscreen. We update the screen so that
    everything we put there shows up properly 2.
  prefs: []
  type: TYPE_NORMAL
- en: At 3, we create the list `validinputs`, which has the 26 letters in the alphabet
    as elements. Later in the script, if the player guesses a letter, we’ll remove
    the letter from the list so that the same letter can’t be guessed more than once.
    We also create the empty list `gotright`. Later we’ll use it to keep track of
    how many positions the player has guessed right in the word.
  prefs: []
  type: TYPE_NORMAL
- en: We start an infinite `while` loop that asks for your keyboard input in every
    iteration. If you enter `done`, the loop stops, and the script quits taking input
    from you. If you enter invalid input (either a non-letter or a letter you’ve already
    guessed), the script will show a message box indicating `Sorry, that's an invalid
    input!`
  prefs: []
  type: TYPE_NORMAL
- en: If you enter valid input 4, the script checks whether the letter is in the word.
    If yes, the script checks each of the four positions in the word and, for each
    match, adds the letter to the list `gotright`. Note that since the same letter
    can appear in a word more than once, a letter may be added to the list `gotright`
    more than once.
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks whether `gotright` has four elements. If yes, it means
    all four letters have been correctly guessed, and a message box will pop up with
    `Great job, you got the word right!`
  prefs: []
  type: TYPE_NORMAL
- en: 'If the guessed letter is not in the word 5, the value of `score` is decreased
    by one, meaning the player has one less guess left. The script will remove a coin
    from the screen by using `hideturtle()`. The second turtle will erase whatever
    it has drawn on the screen and rewrite the number of guesses left. If the length
    of the list `missed` reaches six, a message box appears: `Sorry, you used up all
    your six guesses!`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one exchange with the script with the user input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: My losing game is shown in [Figure 12-4](#figure12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f12004](Images/f12004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: A losing game of guess-the-word'
  prefs: []
  type: TYPE_NORMAL
- en: The Voice-Controlled Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll build on the written-input version of the game to add speech functionality.
    Download *guess_word_hs.py* and save it in your chapter folder. The new code is
    highlighted in [Listing 12-5](#listing12-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: A graphical guess-the-word game that takes voice input'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the usual functions from our local package *mptpkg*: `voice_to_text()`
    and `print_say()`. Because we installed the package (in editable mode), there’s
    no need to tell the system where to find it.'
  prefs: []
  type: TYPE_NORMAL
- en: We start an infinite `while` loop that asks for your choice of letter in each
    iteration 1. You speak your guess into the microphone, and the script captures
    your voice command and stores it in `inp`. We make allowances so the player can
    say either “letter a” or just “a.” If the former, we replace *letter* with an
    empty string so that only `a` is left in the variable `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: To stop the `while` loop, you say, “Stop listening.” If your guess is not in
    the list `validinputs`, the script will answer, “Sorry, that’s an invalid input!”
    out loud. If your guess is in `validinputs` 2, the script checks whether the letter
    is in the word. This time, when you complete the word without missing six times,
    the game will say, “Great job, you got the word right!” 3. If you guess wrong
    six times, the voice will say, “Sorry, you used up your six guesses!” 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an exchange with the script in which the player has successfully guessed
    the word *good*, missing only two letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can see the screen in [Figure 12-5](#figure12-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f12005](Images/f12005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: Winning the voice-controlled guess-the-word game'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you created a voice-controlled graphical guess-the-word game
    that talks back to you in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: You first learned how to draw the game board. You then learned to upload a picture
    file to the script and scale it to the size you want. You used the image to create
    six coins on the screen to represent monetary rewards and made them disappear
    from the screen one by one. You also learned how to type in your guess and have
    it show up onscreen. You learned how to disallow guessing the same letter twice
    and how to determine whether a player has won or lost the game.
  prefs: []
  type: TYPE_NORMAL
- en: You added the speech recognition and text-to-speech features so that the game
    can be voice controlled. Along the way, you learned how to create an image by
    manipulating a picture file in *turtle* and how to use multiple turtles to reduce
    the number of objects you have to redraw on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *show_coins.py* so that the positions of the six coins are 10 pixels
    below their current positions vertically. Keep the positions of everything else
    the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *show_coins.py* so that the leftmost coin disappears from the screen
    first and the rightmost one is the last to disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to figure out what the following line of code will produce. First write
    down your answer and then run the code in Spyder to verify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Smart Games: Adding Intelligence'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In the one-player version of Connect Four we built in Chapter 11, the computer
    always randomly selects a move. This allowed us to focus on the game’s speech
    recognition and text-to-speech aspects.
  prefs: []
  type: TYPE_NORMAL
- en: However, once you play against the random computer for a few games, you start
    to wonder if there’s a way to make our Connect Four game more challenging. The
    answer is yes, and in this chapter, you’ll learn to make an intelligent Connect
    Four opponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In one approach, we’ll ask the script to think three steps ahead, as people
    do when playing a game: two moves by the computer and one by the player.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the computer checks whether a move leads to winning the game
    right away. If yes, the computer will take it.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking two steps ahead in Connect Four means the computer tries to prevent
    the opponent from winning in the next turn. This is complicated, because sometimes
    the computer must block a position and other times it must avoid taking a position.
    The computer will distinguish these two cases and block some moves and avoid others
    to prevent the opponent from winning.
  prefs: []
  type: TYPE_NORMAL
- en: By thinking three steps ahead, the computer will follow the path that most likely
    leads to a victory for the computer after three moves. In many scenarios, thinking
    three steps ahead can guarantee a win in three steps. In particular, if there
    is a move that guarantees the computer to win in three moves, the computer will
    select that as the best next move.
  prefs: []
  type: TYPE_NORMAL
- en: The second method uses an approach that could be classified as a type of *machine
    learning*. You’ll simulate a million games in which both players select random
    moves. You’ll then record the outcome and the intermediate steps. With this data,
    the computer will learn at each move and select the one most likely to lead to
    a winning outcome.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assess the effectiveness of the two strategies and choose the one that
    is more difficult to beat. We’ll then add speech recognition and text-to-speech
    features to the intelligent Connect Four.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, I’ll also challenge you to apply the same methods to the tic-tac-toe
    game in the “End-of-Chapter Exercises” on page 267. As always, all scripts are
    available at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/),
    and you should create the folder */mpt/ch13/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Think-Three-Steps-Ahead Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll first use the mouse-click version of Connect Four to speed up the testing
    of scripts. After we incorporate the strategy of thinking three steps ahead, we’ll
    add the speech features back.
  prefs: []
  type: TYPE_NORMAL
- en: Think One Step Ahead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking one step ahead in Connect Four is easy. The computer checks all possible
    next moves, and if one of them will lead to a win right away, the computer will
    take it.
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_think1.py* from the book’s resources and save it in your chapter
    folder. This is based on the script *conn_click.py* in Chapter 11, but I’ve altered
    the code so that you’re playing against an automated player that thinks one step
    ahead rather than another human player.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](#listing13-1) highlights the key parts of *conn_think1.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: Think one step ahead in the Connect Four game.'
  prefs: []
  type: TYPE_NORMAL
- en: We import all needed modules. In particular, we import `choice()` from the *random*
    module and `deepcopy()` from the *copy* module. The *copy* module is in the Python
    standard library, so no installation is needed.
  prefs: []
  type: TYPE_NORMAL
- en: To search for the best strategy, we’ll look one step ahead and see what would
    happen hypothetically if certain actions were taken. We need `deepcopy()` to copy
    a list without altering the original list. We can’t simply use assignment statements
    in this script when copying lists. Assignment statements in Python create a link
    to the original list object, so if we alter the copy, we alter the original as
    well. Altering the original list is not what we intend and would cause unexpected
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we make `horizontal4(x,y,color,board)`more general so that it can be applied
    to any four arguments. Later in the script, we’ll use it to check whether certain
    moves win the game by collecting four discs horizontally in a hypothetical situation.
    We define the functions `vertical4()`, `forward4()`, and `back4()` in a similar
    way.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `win_game(num,color,board)`, which checks whether the player
    has won in any of the preceding four scenarios. We’ve also omitted the row number
    as an argument because it will be inferred from the argument `board`.
  prefs: []
  type: TYPE_NORMAL
- en: The main action is in `best_move()`, starting at 3. This function searches for
    the best move for the computer (the red player). If column 4 is empty, the computer
    takes the center column. Since the red player moves first, this line of code ensures
    that the very first move of the game is always the center column 4, giving whoever
    makes the first move an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: If only one move is left (that is, six columns are full and only one column
    has empty cells), there’s no point searching for a best move, so the computer
    takes the only remaining move.
  prefs: []
  type: TYPE_NORMAL
- en: If more than one move remains, the function checks every possible move to see
    if any will lead to a win for the computer right away. The script creates the
    list `winner` to contain the potentially winning moves 4. We go through all possible
    next moves. We use `win_game()` to check whether a move will win the game hypothetically.
    If yes, the move is added to `winner`. The function then checks whether `winner`
    is empty, and if it isn’t, the computer takes the first available move in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: We then define `computer_move()`5. When called, this function tells the computer
    to make the move produced by `best_move()`. The computer then places a disc in
    the corresponding column. Once the computer places the disc, the script uses `win_game()`
    to check if the move wins the game 6.
  prefs: []
  type: TYPE_NORMAL
- en: The computer makes the first move of the game. After that, we define `conn()`,
    which allows you to click the screen to play your move. The script checks whether
    your move wins the game 7. The computer will move after you if the game isn’t
    over.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script several times and play against the computer. You’ll notice that
    the computer will always take the winning move if there is one. For example, at
    the left of [Figure 13-1](#figure13-1), an opportunity emerges for the red player
    to take column 7 and win the game. The computer thinks one step ahead and takes
    the winning move.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13001a](Images/f13001a.png)![f13001b](Images/f13001b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A Connect Four game that thinks one step ahead'
  prefs: []
  type: TYPE_NORMAL
- en: Think Two Steps Ahead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking two steps ahead in Connect Four is a little complicated. The computer’s
    next move can either block the opponent (which is you) or help the opponent’s
    chance of winning the game on the next turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll separate these two cases: if the computer’s move blocks the opponent’s
    chance of winning, the script will take it; if the computer’s move helps the opponent’s
    chance of winning, the script will avoid it. Let’s use examples to demonstrate
    the two cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Moves to Avoid
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, the computer should avoid a certain move so that the opponent
    won’t win on the next turn.
  prefs: []
  type: TYPE_NORMAL
- en: At the left of [Figure 13-2](#figure13-2), it’s the red player’s turn. If the
    red player chooses column 6 as the next move, the opponent can win on the following
    turn, as shown on the right in the figure. Therefore, the red player should avoid
    this move.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13002a](Images/f13002a.png)![f13002b](Images/f13002b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The red player should avoid column 6 in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the red player has made a move that allows yellow to win. We can avoid
    that win with this rule: if you make a next move *x*, and your opponent places
    a disc in the same column *x* two steps ahead and wins the game, you should avoid
    the move *x* in the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: Moves to Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next case, the computer should block a certain move so the opponent won’t
    win in two steps.
  prefs: []
  type: TYPE_NORMAL
- en: At the left in [Figure 13-3](#figure13-3), it’s the red player’s turn. If the
    red player doesn’t choose column 3 in the next move, the opponent can choose column
    3 and win on the following turn. Therefore, the red player should block this move.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13003a](Images/f13003a.png)![f13003b](Images/f13003b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The red player should block column 3\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the red player makes a different move—column 6—and loses the game. So
    the rule is as follows: if red makes the next move, *x*, and the yellow opponent
    can make a different move *y* within two steps and win, red should block yellow’s
    move *y* in the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Think-Two-Steps-Ahead Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s allow the computer to think up to two steps ahead by using the three techniques
    just discussed (one for thinking one step ahead, two for thinking two steps ahead).
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_think1.py*, replace its `best_move()` with the new `best_move()`
    function defined in [Listing 13-2](#listing13-2), and save the new script as *conn_think2.py*
    in your chapter folder (or you can download it from the book’s resources).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: Allow the computer to think up to two steps ahead.'
  prefs: []
  type: TYPE_NORMAL
- en: In the newly defined function `best_move()`, the script searches for the best
    move based on discs currently on the board. If this is the very first move of
    the game, the function takes the column in the middle. If only one move is left,
    the function defines the best move to be the only move left.
  prefs: []
  type: TYPE_NORMAL
- en: If more than one move remains, the function checks every possible move to see
    if any will lead to a win for the red player (the computer) right away 1. If yes,
    the function returns the move as the best move and stores it in `winner`. If not,
    the function will look two steps ahead to see if the opponent can win within two
    steps 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function checks two separate cases: if the red player’s move `m1` (the
    first move) and the yellow player’s move `m2` (the second move) lead to a win
    for the yellow player in two steps, we add the move `m2` to the list `winner`.
    If the red player’s move `m1` and the yellow player’s move `m2=m1` lead to a win
    for the yellow player in two steps, we add the move `m2` to the list `loser`.'
  prefs: []
  type: TYPE_NORMAL
- en: The script checks whether `winner` is empty. If it isn’t, the computer will
    select the opponent’s winning move to block the opponent from winning. Otherwise,
    the computer will check whether the list `loser` is empty. If not, the computer
    will avoid all elements in `loser` so as not to help the opponent win 3.
  prefs: []
  type: TYPE_NORMAL
- en: Run *conn_think2.py* and play a few times against the computer. You’ll notice
    an improvement in the game in the sense that the computer can now think two steps
    ahead and try to prevent you from winning on your next turn.
  prefs: []
  type: TYPE_NORMAL
- en: Think Three Steps Ahead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This next section will allow the computer to think up to three steps ahead before
    taking its turn. If the computer has no winning move in the next step and the
    opponent has no winning moves two steps ahead, the computer will look three steps
    ahead.
  prefs: []
  type: TYPE_NORMAL
- en: The computer will take the next move that most likely leads to a win in three
    steps. In particular, if there’s a next move that guarantees the computer to win
    in three steps, the computer will select that next move as the best one. Let’s
    use an example to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: An Example of a Win in Three Steps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The script *conn_think2.py* is harder to beat than *conn_think1.py*, but not
    impossible. A sophisticated player will notice that the computer misses some moves
    that could have led to a win in three steps.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. At the left of [Figure 13-4](#figure13-4), it’s the computer’s
    (the red player’s) turn to move. If the computer drops a disc in column 3, the
    computer is guaranteed to win on its next turn, because the opponent (the yellow
    player) can block only either column 1 or column 5\. The computer can then occupy
    the other column (either column 5 or column 1) in this third step and win the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: But instead, the computer chooses column 6, as shown at the right of [Figure
    13-4](#figure13-4), missing a chance to guarantee a win.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13004a](Images/f13004a.png)![f13004b](Images/f13004b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: The computer (the red player) fails to make a move that guarantees
    a win.'
  prefs: []
  type: TYPE_NORMAL
- en: We should, therefore, make further improvements on the game. You’ll build a
    game that thinks three steps ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Think-Three-Steps-Ahead Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s allow the computer to think up to three steps ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_think2.py*, add the newly defined `validmoves()` function and the
    highlighted part in [Listing 13-3](#listing13-3) to the `best_move()` function,
    and save the new script as *conn_think.py* in your chapter folder. Alternatively,
    you can download it from the book’s resources. This is the complete script for
    our think-ahead strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-3: Allow the computer to think up to three steps ahead.'
  prefs: []
  type: TYPE_NORMAL
- en: We first define `validmoves(m1,m2,m3,occupied)` to ensure that none of the three
    future hypothetical moves `m1`, `m2`, and `m3` on the game board (represented
    by the list of lists `occupied`) will cause any columns to have more than six
    discs. If the three moves cause any of the seven columns to contain more than
    six discs, the function returns `False`; otherwise, it returns`True`.
  prefs: []
  type: TYPE_NORMAL
- en: As in *conn_think2.py*, the computer first checks whether a winning move could
    be made right away. If yes, it will take it. If not, it checks whether a winning
    move could be made two steps ahead for the opponent. If yes, the computer tries
    to prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no winning moves are available for the opponent two steps ahead, the computer
    looks three steps ahead 1. It checks all combinations of three moves: the computer’s
    next move, `m1`; the opponent’s move two steps ahead, `m2`; and the computer’s
    move at the third step, `m3`. If a combination leads to a win for the player,
    the next move `m1` is added to the list `winner`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, just because a move `x` is in `winner` doesn’t mean this move will
    guarantee a computer win in three steps, because it can’t guarantee that the opponent
    will choose `m2` in the second step. Further, `winner` could contain multiple
    values. The function `best_move()` therefore looks for the most frequent value
    in `winner`, since that’s the move most likely to lead to a win for the computer
    in three steps.
  prefs: []
  type: TYPE_NORMAL
- en: As with most things in Python, there are many ways to find the most frequent
    value in a list*.* We utilize a trick known as a *list comprehension* to create
    an inline dictionary `cnt`*.* In this dictionary, the key is the number of times
    a move appears in `winner`, and the value is the move 2. For example, if `winner`
    has six elements `[7, 6, 6, 5, 5, 5]`, the dictionary `cnt` would be `{1:7, 2:6,
    3:5}`. We then sort the keys in `cnt` to find the highest frequency and call it
    `maxcnt`. Here, `maxcnt` has a value of `3` because the highest number of times
    a value appears is three. Finally, we use `maxcnt` to retrieve the dictionary
    element with the highest frequency. Here, the move `5` appears most frequently
    in `winner`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run *conn_think.py* and play the game, you’ll find the computer almost
    impossible to beat. If you do everything right, you can tie the game. The moment
    you make a wrong move, the computer will seize the opportunity and win the game.
  prefs: []
  type: TYPE_NORMAL
- en: The Machine-Learning Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to make Connect Four smart is to let the computer learn from actual
    game outcomes. You’ll generate a million games in which both players use random
    moves. You’ll record the intermediate steps and the outcome of each game. The
    computer will use the game outcome data to design the best strategy.
  prefs: []
  type: TYPE_NORMAL
- en: At each move, the computer looks at all games with the same game history as
    the current game board. It calculates the average outcome for each possible next
    move and chooses the one that most likely leads to a favorable outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dataset of Simulated Games
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in the machine-learning strategy is to generate data to learn
    from. We’ll simulate two players choosing random moves and record both the outcome
    and the steps taken to reach that outcome. Even though the moves by both players
    are random, we repeat the game many times. The randomness in all these games is
    washed out by the law of large numbers. As a result, the outcome data will be
    useful to the computer to predict the outcome of a move.
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_simulation.py* from the book’s resources. I explain the script
    in [Listing 13-4](#listing13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-4: Simulating a million Connect Four games'
  prefs: []
  type: TYPE_NORMAL
- en: We first define `simulate()`. When called, it simulates a complete Connect Four
    game and records each move and the game outcome. We omit the graphics part of
    the game to save time.
  prefs: []
  type: TYPE_NORMAL
- en: We define `win_game()` to check if a player has won the game 1. In each game,
    the red player moves first 2. We create the two lists `moves` and `winlose` to
    record the intermediate moves and the game outcome, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We create a game loop to iterate a maximum of 42 times because each Connect
    Four game has a maximum of 42 moves 3. In each iteration, a player randomly selects
    a move. The move is added to `moves` to keep track of the history of the game.
    At each step, we check whether a player wins. If yes, we’ll record an outcome
    of `1` if the winner is the red player and `-1` if the winner is the yellow player.
    The default outcome is a tie, in which case we’ll record a value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `simulate()` a million times 4. The result of each game is saved
    in a list `result`, with its first element being the outcome of the game (`-1`,
    `1`, or `0`), followed by the intermediate steps of the game.
  prefs: []
  type: TYPE_NORMAL
- en: The outcomes and intermediate steps of the million games are saved in *conn_simulates.pickle*
    for later use 5. We print out the results of the first 10 games, shown in [Listing
    13-5](#listing13-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-5: The first 10 simulated Connect Four games'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the output for the first game is `[1, 1, 7, 1, 5, 7, 6, 5, 1, 5,
    7, 5, 2, 5]`. The first element, `1`, means that the red player has won the game.
    The remaining elements, `1, 7, 1 ...` , indicate the columns the players dropped
    their discs into, alternating between red and yellow. The red player eventually
    wins this game by connecting four red discs vertically in column 5.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to use the outcome data to design intelligent moves for the
    computer. At each move, the computer will turn to the simulated data to retrieve
    all games with the same history. It searches through all possible next moves,
    finds the one that leads to the most favorable outcome, and uses that as the next
    move.
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_ml.py* and save it in your chapter folder. The script is based
    on *conn_think.py*. [Listing 13-6](#listing13-6) highlights the main differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-6: A Connect Four game player with the machine-learning strategy'
  prefs: []
  type: TYPE_NORMAL
- en: We create the new list `moves_made` to keep track of all moves in the game so
    far; we’ll use it later in `best_move()`. We open the simulated Connect Four game
    data and save it in a list `gamedata`.
  prefs: []
  type: TYPE_NORMAL
- en: In `best_move()`, we make sure the first move is always to place a disc in column
    4, as that gives the computer a starting advantage 1. We check if only one move
    is left and, if so, just take it as the next best move. Otherwise, we check all
    simulated games with the same history as the current game and see which next move
    will be most favorable to the red player. We assign that move as the best move.
    I’ll explain how we do that in detail in *ml_move.py*, using a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `computer_move()`. When it’s the computer’s turn to play, it
    calls `best_move()` to generate a move. The computer makes the move, and we add
    that move to the list `moves_made` to track the game history.
  prefs: []
  type: TYPE_NORMAL
- en: We set the computer to make the first move 3. After that, the player clicks
    to make their move 4. The human player’s move is also added to `moves_made`. The
    computer will move after you if the game isn’t over.
  prefs: []
  type: TYPE_NORMAL
- en: Run *conn_ml.py* and play the game a few times. You might be surprised to find
    that it’s relatively easy to win. The machine-learning strategy is not nearly
    as effective as our three-steps method. We’ll look into why later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Test the Effectiveness of the Two Strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we want to measure how intelligent the two strategies are. We’ll simulate
    1,000 games and record the outcomes. In each game, the intelligent computer version
    will play against a simple computer player that selects random moves. We’ll see
    how many times the intelligent player wins or ties the game.
  prefs: []
  type: TYPE_NORMAL
- en: The Think-Three-Steps-Ahead Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with the three-steps version. The script *outcome_conn_think.py,*
    shown in [Listing 13-7](#listing13-7), has our two computer players play 1,000
    times, then prints out the number of winning, tying, and losing games.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-7: Test the effectiveness of the think-three-steps-ahead strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define `simulate()`, which pits the intelligent computer (the red player)
    using the think-three-steps-ahead strategy against a computer player that selects
    random moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `win_game()` and `best_move()` functions are the same as those defined
    in *conn_think.py*. We use the list `winlose` to record the game outcomes 2: `1`
    if the red player wins, `-1` if the yellow player wins, and `0` if it’s a tie.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the game starts, the red player calls `best_move()` to obtain a move 3,
    while the yellow player randomly selects a move 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 5, we call `simulate()` 1,000 times and record the outcome of all games.
    We then print out the number of winning, tying, and losing games, summing the
    count of `1`, `-1`, and `0` to make it easier to read. Here’s an example of the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Out of all the games, the intelligent player with the think-three-steps-ahead
    strategy has won 995 times, never tied, and lost 5 times.
  prefs: []
  type: TYPE_NORMAL
- en: The Machine-Learning Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll test the machine-learning strategy in the same way. Download *outcome_conn_ml.py*
    and save it in your chapter folder. This is similar to *outcome_conn_think.py*,
    so I’ll just highlight the differences here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we obtain the simulated game outcome data that we’ve generated from *conn_simulation.py*.
    Second, we base the definition of `best_move()` on the machine-learning strategy
    instead of the three-steps strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `simulate()` 1,000 times and record the outcomes, printing them as
    before. Here’s an example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Out of all the games, the computer has won 882 times, never tied, and lost 118
    times—it did significantly worse than with the three-steps strategy. Let’s look
    at why.
  prefs: []
  type: TYPE_NORMAL
- en: Why Doesn’t the Machine-Learning Strategy Work Well in Connect Four?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The machine-learning strategy is less effective in our game mainly because
    so many moves are available in a Connect Four game: a maximum of 42\. That means,
    exponentially, that a very large number of possible game outcomes exist. We simulated
    a million games, which sounds like a lot, but when the data is spread among many
    game outcomes, it’s inevitable that some game outcomes will not be in the simulated
    data. As a result, it’s impossible to find a best strategy for many of the game
    histories.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll test the machine-learning strategy with one particular
    game history. Assume that the red and yellow players have both made three moves
    and next it’s the red player’s turn. The game board at this stage is as shown
    in [Figure 13-5](#figure13-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13005](Images/f13005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: One game simulation'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll simulate this game setup in code to see how our machine-learning strategy
    decides which move to make next. Enter *ml_move.py*, shown in [Listing 13-8](#listing13-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-8: Search for the best machine learning strategy move.'
  prefs: []
  type: TYPE_NORMAL
- en: We import *pickle*, which enables us to work with datasets saved in the *pickle*
    format. We open the simulation data file, *conn_simulates.pickle,* which was created
    earlier in *conn_simulation.py.* The data is saved in the `gamedata` list.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the red player is able to place a disc in any of the seven columns
    in the next move, so we have all seven values in `validinputs`. We save the six
    moves already made in [Figure 13-4](#figure13-4), `[4, 5, 4, 5, 4, 5]`, in the
    list `moves_made`. The list of lists `occupied` keeps track of the disc positions
    currently on the game board.
  prefs: []
  type: TYPE_NORMAL
- en: We check the million simulated games data to see if any of those games match
    the game history of the current game. If yes, we put all the historical games
    that match in the list `simu`1. We then focus on the seventh move in all those
    games. We look at the outcomes (win, lose, or tie) of all games associated with
    each of the seven possible moves, 1 through 7, and put them in a dictionary `outcomes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print out the content of `outcomes` 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, nine games have the same game history: none of which placed
    the next disc in column 1, two that used column 2 for the next move, one that
    used column 3, and so on. The values `-1`, `0`, and `1` inside the square brackets
    indicate that the red player loses, ties, and wins the game, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: To help us compare which of the seven moves leads to the best outcome for the
    red player, we calculate the average outcome for each move 3. If a move leads
    to wins 100 percent of the time, the average outcome is `1`; if a move leads to
    50 percent wins and 50 percent losses, the average outcome is `0`; if a move leads
    to a loss 100 percent of the time, the average is `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We print the average outcomes (we don’t have results for move 1 because no
    simulated game in `simu`used this move):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Both moves 3 and 4 lead to an average outcome of `1`. The script prints out
    the first best move, which is 3 in this case 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: However, when we look at this move in the game ([Figure 13-6](#figure13-6)),
    we can see it clearly isn’t the best move we could have made.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13006](Images/f13006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: The machine-learning computer makes a mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the problem with the machine-learning strategy is that we don’t
    have enough simulated games that match our game history.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder whether we can just increase the number of simulated games to
    solve the problem. The answer is yes and no. Increasing the number of simulated
    games will make the strategy more intelligent, but it will also increase the data
    size enough to slow the response of the machine-learning script. Thus, the player
    will have to wait a long time for the computer to make a move. This is the trade-off
    when using machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this by increasing the size of the simulated games to 10 million.
    Generating this data takes several hours. We rerun *ml_move.py* with the larger
    dataset and get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have much more data to base our decision on, the machine-learning
    strategy correctly recommends column 4, resulting in [Figure 13-7](#figure13-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13007](Images/f13007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: With 10 million simulated games, the strategy makes the correct
    move.'
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Intelligent Connect Four Games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s wrap up this chapter by adding speech recognition and text-to-speech features
    to the intelligent Connect Four games.
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Controlled Game That Thinks Ahead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll mesh together two scripts, *conn_think.py* and *conn_hs.py*, into *conn_think_hs.py*.
    Download this file from the book’s resources and save it in your chapter folder.
    The main differences are shown in [Listing 13-9](#listing13-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-9: A voice-controlled Connect Four game with the three-steps strategy'
  prefs: []
  type: TYPE_NORMAL
- en: The function `best_move()` is the same as in the script *conn_think.py* 1. We
    define `computer_move()` 2, which uses `best_move()` to choose a move and speaks
    aloud the selected column. If the computer’s move wins or ties the game, the script
    also announces it 3.
  prefs: []
  type: TYPE_NORMAL
- en: The computer then makes the first move of the game4, and it starts a `while`
    loop that keeps running as long as the list `validinputs`isn’t empty 5. At each
    iteration, the script captures your voice input, which should be the number of
    the column you want to drop a disc in. You can say “number five,” “column five,”
    or “5.” It then converts the voice command to an integer number to match the format
    in `validinputs`so it can compare your input to the list. If you said something
    that isn’t convertible to an integer, the script will say, “Sorry, that’s an invalid
    input.”
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve given an invalid move 6, the script will say, “Sorry, that’s an invalid
    move.” If your move is valid, the script places the disc on the game board. In
    the process, it will check whether you’ve won or tied the game and, if so, will
    announce the result aloud. If the game is not yet over, the computer makes a move.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and play the voice-controlled game with the computer. You’ll
    notice that the game is more challenging and more interesting to play.
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Controlled Game Using Machine Learning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll mesh together two scripts we created before, *conn_ml.py* and *conn_hs.py*,
    into *conn_ml_hs.py*. Download the file from the book’s resources and save it
    in your chapter folder. [Listing 13-10](#listing13-10) shows the main differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-10: A voice-controlled Connect Four game using the machine-learning
    strategy'
  prefs: []
  type: TYPE_NORMAL
- en: This works in the same way as the voice-controlled three-steps version. Run
    the script and play a game. You should find the game interesting but easier to
    beat than the three-steps strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you created intelligent, voice-controlled graphical Connect
    Four games by using two methods: the think-three-steps-ahead strategy and the
    machine-learning strategy. This taught some important reasoning skills—how do
    we make a script intelligent?—as well as some basic machine-learning skills.'
  prefs: []
  type: TYPE_NORMAL
- en: You learned to generalize these two strategies and apply them to specific games.
    You can apply these skills to create your own intelligent voice-controlled games.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *conn_think1.py* so that the human player moves first and the computer
    moves second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mesh together *ttt_click.py* from Chapter 10 and *conn_think1.py* to create
    a mouse-click version of the tic-tac-toe game in which the computer thinks one
    step ahead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a mouse-click version of the tic-tac-toe game in which the computer thinks
    two steps ahead, based on *ttt_click.py* and *conn_think2.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `best_move()`, defined in *conn_think.py*, if the list `winner` has eight
    elements `[7, 7, 4, 5, 6, 6, 6, 6]`, what’s the value of `cnt`, `maxcnt`, and
    `cnt[maxcnt]`, respectively?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design a mouse-click version of the tic-tac-toe game in which the computer thinks
    three steps ahead, based on *ttt_click.py* and *conn_think.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simulate a million tic-tac-toe games and save the game outcome and intermediate
    steps as *ttt_simulates.pickle*. Then create a mouse-click version of tic-tac-toe
    in which the computer uses the machine-learning strategy, similar to what we’ve
    done in *conn_simulation.py* and *conn_ml.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *outcome_conn_think.py* and *outcome_conn_ml.py* to test the effectiveness
    of the three-steps strategy and the machine-learning strategy in the tic-tac-toe
    games you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running *conn_simulation.py*, we printed out 10 observations from the
    dataset *conn_simulates.pickle*, as shown in [Listing 13-5](#listing13-5). The
    10th observation is `[-1, 1, 4, 1, 4, 1, 2, 4, 5, 6, 6, 6, 3]`. Who has won the
    10th game? Are the four discs connected vertically, horizontally, or diagonally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
