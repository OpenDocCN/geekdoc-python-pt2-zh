- en: Part III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分
- en: Interactive Games
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互动游戏
- en: '9'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Graphics and Animation with the *turtle* Module
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *turtle* 模块进行图形和动画
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Our goal in the next few chapters is to build voice-controlled graphical games
    such as tic-tac-toe, Connect Four, and guess-the-word. You’ll do all these with
    the *turtle* module.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在接下来的几章中的目标是构建语音控制的图形游戏，如井字棋、四连棋和猜单词。你将使用 *turtle* 模块来完成所有这些。
- en: In this chapter, you won’t be working with voice interactivity. Instead you’ll
    learn the *turtle* module’s basic commands that will let you set up a turtle screen,
    draw shapes, and create animations. This functionality will be the basis for all
    the games you’ll be building.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你将不会使用语音交互。相反，你将学习 *turtle* 模块的基本命令，这些命令将帮助你设置海龟屏幕、绘制形状和创建动画。这些功能将成为你将要构建的所有游戏的基础。
- en: Before you begin, set up the folder */mpt/ch09/* for this chapter. As always,
    all scripts in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，为本章设置文件夹 */mpt/ch09/*。和往常一样，本章中的所有脚本都可以在本书的资源页面找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Basic Commands
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本命令
- en: The *turtle* module allows us to use a robotic turtle to draw shapes and create
    animations on a canvas. The turtle mimics the way people draw on a physical canvas,
    but we use commands to move the turtle and create the drawings.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块允许我们使用一个机器人海龟在画布上绘制图形并创建动画。海龟模仿了人们在物理画布上绘画的方式，但我们使用命令来移动海龟并创建图画。'
- en: For its underlying graphics, the *turtle* module uses the *tkinter* module,
    which is Python’s de facto standard graphical user interface (GUI) package. Both
    *turtle* and *tkinter* are in the Python standard library, so there’s no need
    to install them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其底层图形，*turtle* 模块使用了 *tkinter* 模块，这是 Python 的事实标准图形用户界面（GUI）包。*turtle* 和 *tkinter*
    都包含在 Python 标准库中，因此无需安装它们。
- en: 'Turtle graphics were invented in the 1960s, three decades before the Python
    language. The *turtle* module allows Python programmers to take advantage of many
    features of turtle graphics. The first is their simplicity: *turtle* is easier
    to learn than other game modules such as *pygame* or *tkinter*. The *turtle* module
    is also intuitive, making it easy to create pictures and shapes by manipulating
    the drawing pen on a canvas (that is, the screen).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟图形是在 1960 年代发明的，比 Python 语言早了三十年。*turtle* 模块允许 Python 程序员利用海龟图形的许多特性。第一个特性是它的简单性：*turtle*
    比其他游戏模块，如 *pygame* 或 *tkinter*，更容易学习。*turtle* 模块还很直观，使得通过操控画笔在画布（即屏幕）上绘制图片和形状变得简单。
- en: The *turtle* module is also better suited to voice activation. Unlike other
    game modules, which constantly run through a game loop too fast to capture voice
    commands, *turtle* scripts don’t need a game loop. This makes voice-controlled
    games possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块也更适合语音激活。与其他游戏模块不同，后者通常通过游戏循环运行得太快，无法捕捉语音命令，*turtle* 脚本不需要游戏循环。这使得语音控制的游戏成为可能。'
- en: Create a turtle Screen
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个海龟屏幕
- en: 'To use *turtle*, you need to create a turtle screen to contain all objects
    in the script. The following script shows you a simple example of the turtle screen.
    Enter the following lines of code in Spyder and save the script as *set_up_screen.py*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *turtle*，你需要创建一个海龟屏幕来容纳脚本中的所有对象。下面的脚本向你展示了一个简单的海龟屏幕示例。在 Spyder 中输入以下代码行，并将脚本保存为
    *set_up_screen.py*：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We import the *turtle* module and give it a short alias name, `t`. This is one
    situation where a short alias module name is beneficial, since we’ll be calling
    multiple functions from the module, and often. Therefore, we want to use only
    `t.`, instead of `turtle.`, in front of all the functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 *turtle* 模块并为其指定一个简短的别名 `t`。这是一个简短别名有利的情况，因为我们将多次调用模块中的多个函数。因此，我们希望在所有函数前面只使用
    `t.`，而不是 `turtle.`。
- en: At 1, we create a screen by using `Screen()`, which doesn’t require arguments.
    We then use `setup()` to specify the size and location of the screen. The four
    parameters are screen width, screen height, horizontal distance from the top left
    of your computer screen, and vertical distance from the top left of your computer
    screen, in that order. Our screen will be 600 pixels wide and 500 pixels tall,
    100 pixels from the left edge of the computer screen, and 200 pixels from the
    top edge.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1，我们通过使用`Screen()`创建一个屏幕，这不需要任何参数。接着我们使用`setup()`来指定屏幕的大小和位置。四个参数依次是屏幕宽度、屏幕高度、距离计算机屏幕左上角的水平距离以及距离计算机屏幕左上角的垂直距离。我们的屏幕将是600像素宽、500像素高，距离计算机屏幕左边缘100像素，距离上边缘200像素。
- en: Next, we give the turtle screen a background color by using `bgcolor()`. The
    *turtle* module provides a wide range of colors, including `brown`, `black`, `gray`,
    `white`, `yellow`, `gold`, `orange`, `red`, `purple`, `navy`, `blue`, `lightblue`,
    `darkblue`, `cyan`, `turquoise`, `lightgreen`, `green`, and `darkgreen`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`bgcolor()`为海龟屏幕设置背景颜色。*turtle*模块提供了多种颜色，包括`brown`（棕色）、`black`（黑色）、`gray`（灰色）、`white`（白色）、`yellow`（黄色）、`gold`（金色）、`orange`（橙色）、`red`（红色）、`purple`（紫色）、`navy`（海军蓝）、`blue`（蓝色）、`lightblue`（浅蓝色）、`darkblue`（深蓝色）、`cyan`（青色）、`turquoise`（绿松石色）、`lightgreen`（浅绿色）、`green`（绿色）和`darkgreen`（深绿色）。
- en: At 2, we give a title to the screen, which you’ll see at the top beside the
    turtle graphics symbol ([Figure 9-1](#figure9-1)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2，我们为屏幕添加一个标题，你可以在屏幕顶部看到它，靠近海龟图形符号（[图9-1](#figure9-1)）。
- en: The `done()` command tells the script to start the event, which is how objects
    on the screen could be animated. The `bye()` command tells the script to exit
    *turtle* when you click the X symbol.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`命令告诉脚本开始事件，这样屏幕上的对象就可以进行动画处理。`bye()`命令则告诉脚本在你点击X符号时退出*turtle*模块。'
- en: The screen should look something like [Figure 9-1](#figure9-1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕应该看起来像[图9-1](#figure9-1)所示。
- en: '![f09001](Images/f09001.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](Images/f09001.png)'
- en: 'Figure 9-1: Set up the size, background color, and title of the screen.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：设置屏幕的大小、背景颜色和标题。
- en: A turtle screen uses a *Cartesian* coordinate system, with the center coordinate
    (x = 0, y = 0). The x-value increases from left to right, and the y-value increases
    from bottom to top, just like the two-dimensional plane you learned in high school
    mathematics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟屏幕使用的是*笛卡尔*坐标系，坐标原点为(x = 0, y = 0)。x值从左到右递增，y值从下到上递增，就像你在高中数学中学到的二维平面。
- en: Create Movements
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建动作
- en: 'In earlier days, the turtle cursor was literally a picture of a turtle moving
    around on the screen. Now, instead of a literal turtle, you see a small arrowhead
    as the default cursor. The turtle has three attributes: location, direction, and
    a pen. You can adjust the color and width of the pen, and you can decide whether
    to put the pen down on the plane so the turtle’s path is marked when it moves
    or lift it up so the movement isn’t tracked.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，海龟光标实际上是一个在屏幕上移动的海龟图像。现在，默认的光标是一个小箭头，取代了原来的海龟图像。海龟有三个属性：位置、方向和画笔。你可以调整画笔的颜色和宽度，还可以决定是否将画笔放在平面上，这样海龟移动时就会在其路径上留下痕迹，或者将画笔抬起，这样就不会跟踪移动。
- en: Let’s see an actual drawing before looking at the various movements in the module.
    Enter the code shown in [Listing 9-1](#listing9-1) in a Spyder editor and save
    it as *show_turtle.py* in your chapter folder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看模块中的各种动作之前，先看看实际的绘图。在Spyder编辑器中输入[示例9-1](#listing9-1)中的代码，并将其保存为*show_turtle.py*，放在你的章节文件夹中。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-1: Showing the turtle in the *turtle* module'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-1：显示*turtle*模块中的海龟
- en: At 1, we change the shape of the cursor back to the original turtle shape, as
    you can see in [Figure 9-2](#figure9-2). If you run the script, you can see that
    the turtle starts at position (x = 0, y = 0) and faces right. It moves forward
    200 pixels with the default down pen position, so this movement draws a line on
    the canvas. We turn the turtle right 90 degrees and lift up the pen before moving
    forward 100 pixels. This time, no line is drawn on the canvas since the drawing
    pen is not touching the canvas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1，我们将光标的形状改回原始的海龟形状，正如[图9-2](#figure9-2)所示。如果你运行脚本，你会看到海龟从位置(x = 0, y = 0)开始并朝右移动。它在默认的放下画笔状态下向前移动200像素，因此在画布上绘制了一条线。然后我们将海龟右转90度并抬起画笔，再向前移动100像素。这次由于画笔没有接触到画布，因此不会绘制线条。
- en: '![f09002](Images/f09002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](Images/f09002.png)'
- en: 'Figure 9-2: The turtle moves on the canvas to make a drawing.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：海龟在画布上移动进行绘图。
- en: Now we’ll discuss in detail some basic movements in the *turtle* module that
    are useful for our projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将详细讨论一些在*turtle*模块中非常有用的基本动作，这些动作对我们的项目非常重要。
- en: The forward() and backward() Functions
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `forward()` function tells the turtle to move forward the specified number
    of pixels on the screen. The `backward()` function does the same backward. Enter
    the code shown in [Listing 9-2](#listing9-2) in a Spyder editor and save it as
    *forward_backward.py* in your chapter folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-2: Basic movement functions in the *turtle* module'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We set up the screen with a different background color and a title. At 1, the
    turtle moves forward 200 pixels. The default starting position of the turtle is
    at (x = 0, y = 0), facing to the right, so moving forward 200 pixels leads the
    turtle to the point (x = 200, y = 0).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: At 2, the turtle moves from the point (x = 200, y = 0) backward 300 pixels,
    ending up at (x = –100, y = 0).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The left() and right() Functions
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `left()` or `right()` function changes the direction the turtle is facing.
    As the argument, we give the degree of the angle to move by. For example, `90`
    degrees turns the turtle perpendicular to the original direction. A degree value
    of `360` turns the turtle in a full circle so it’s still going in the original
    direction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The script *left_right.py* in [Listing 9-3](#listing9-3) shows how the `left()`
    and `right()` functions work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: Python code for *left_right.py*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The `pensize()` function specifies the thickness of the line the turtle is drawing
    1. The default value is 1 pixel. Here we set the pen size to 5 pixels. At 2, we
    tell the turtle to turn right 30 degrees. Then, we move the turtle forward 200
    pixels. We then turn the turtle left 30 degrees and move backward 400 pixels.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The `pencolor()` function changes the color of the drawing pen to red 3. The
    default is black. After this step, the lines will be red instead of black.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you should see a screen similar to [Figure 9-3](#figure9-3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![f09003](Images/f09003.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: The `left()` and `right()` functions in the *turtle* module'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The goto() Function
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `goto()` function tells the turtle to go to the specified point on the screen.
    Together with `up()` and `down()`, it can create straight lines and dashed lines.
    The `up()` function means the turtle pen is not touching the canvas and so doesn’t
    draw as it moves. The `down()` function puts the pen on the canvas and creates
    drawings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If the turtle pen is in the down position, `goto()` will create a straight line
    between the current position and the specified position. However, if the turtle
    pen is in the up position, `goto()` will create nothing on the screen, but merely
    moving the turtle from the current position to the specified position. Dashed
    lines can be created by drawing a sequence of short lines with spaces in between.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Enter the script *create_lines.py* in [Listing 9-4](#listing9-4).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-4: Python code for *create_lines**.py*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we tell the turtle to go to (x = 200, y = 100). By default, the turtle
    is in the down position and the starting position is (x = 0, y = 0), so `goto(200,100)`
    draws a line between the two points (0, 0) and (200, 100), as you can see in [Figure
    9-4](#figure9-4).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步，我们告诉乌龟移动到 (x = 200, y = 100)。默认情况下，乌龟是处于下笔状态，起始位置是 (x = 0, y = 0)，因此
    `goto(200,100)` 会在两个点 (0, 0) 和 (200, 100) 之间画一条线，如[图 9-4](#figure9-4) 所示。
- en: At 2, the script tells the turtle to lift up the pen so that no line is drawn
    on the screen when the turtle goes to another point. We then change the pen color
    to blue. At 3, we start a `for` loop. In each iteration, the turtle goes to a
    point, puts down the pen, and goes to another point 30 pixels to the right. This
    leaves a 30-pixel-long dash, done eight times with gaps between.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步，脚本指示乌龟抬起画笔，这样乌龟移动到另一个点时，屏幕上不会画出任何线条。然后我们将画笔颜色改为蓝色。在第 3 步，我们开始一个 `for`
    循环。在每次迭代中，乌龟会到达一个点，放下画笔，然后移动到右边 30 像素的地方。这样就会留下一个 30 像素长的短线，重复八次，之间有间隙。
- en: The `hideturtle()` function hides the turtle so that the black arrow cursor
    is not shown on the screen 4.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`hideturtle()` 函数可以隐藏乌龟，使得屏幕上不显示黑色的箭头光标 4。'
- en: Run the script and you should see a screen similar to [Figure 9-4](#figure9-4).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该能看到一个类似于 [图 9-4](#figure9-4) 的屏幕。
- en: '![f09004](Images/f09004.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](Images/f09004.png)'
- en: 'Figure 9-4: Use the `goto()` function to create lines using the *turtle* module.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：使用 `goto()` 函数通过 *turtle* 模块绘制直线。
- en: Basic Shapes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本形状
- en: The *turtle* module has several built-in shapes, including the commonly used
    `dot()` function that creates a dot. You’ll also learn how to create basic shapes
    such as a triangle, a square, and gridlines.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块有多个内建的形状，包括常用的 `dot()` 函数，它可以创建圆点。你还将学习如何创建基本形状，如三角形、正方形和网格线。'
- en: Use the dot() Function
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 dot() 函数
- en: The `dot()` function creates a dot with the specified diameter and color. For
    example, the command `dot(30,'red')` creates a red dot with a diameter of 30 pixels.
    We’ll use this in our tic-tac-toe and Connect Four games to create game pieces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`dot()` 函数创建一个指定直径和颜色的圆点。例如，命令 `dot(30, ''red'')` 会创建一个直径为 30 像素的红色圆点。我们将在井字游戏和四子棋游戏中使用这个功能来创建游戏棋子。'
- en: '[Listing 9-5](#listing9-5), *dots.py*, shows how the `dot()` function works.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-5](#listing9-5)，*dots.py* 展示了 `dot()` 函数的使用方法。'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-5: Python code for *dots.py*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5：*dots.py* 的 Python 代码
- en: First we lift up the pen 1. Then we go to the point (150, 100). We tell the
    turtle to put a red dot centered on the point (150, 100) and with a diameter of
    120 pixels.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们抬起画笔 1。然后我们移动到点 (150, 100)。我们告诉乌龟在点 (150, 100) 处画一个直径为 120 像素的红色圆点。
- en: Next, we move the turtle to (–150, 100) and draw a yellow dot with a diameter
    of 135 pixels. Note that you don’t need to use `up()` again since the pen is already
    lifted up. With the pen up, the turtle can still draw dots.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将乌龟移到 (–150, 100)，并画一个直径为 135 像素的黄色圆点。请注意，你不需要再次使用 `up()`，因为画笔已经抬起。画笔抬起时，乌龟依然可以画圆点。
- en: Starting from 2, the turtle goes to (150, –100) and draws a blue dot with a
    diameter of 125 pixels. Then it goes to (–150, –100) and draws a green dot with
    a diameter of 140 pixels. [Figure 9-5](#figure9-5) shows the outcome.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 2 步开始，乌龟会到达 (150, –100) 并画出一个直径为 125 像素的蓝色圆点。然后它移动到 (–150, –100) 并画出一个直径为
    140 像素的绿色圆点。[图 9-5](#figure9-5) 展示了最终效果。
- en: '![f09005](Images/f09005.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](Images/f09005.png)'
- en: 'Figure 9-5: Create dots using the *turtle* module.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：使用 *turtle* 模块创建圆点。
- en: Draw Your Own Shapes
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制自己的图形
- en: You can also draw your own shapes using the *turtle* module. We’ll look at some
    basic shapes here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 *turtle* 模块绘制自己的图形。我们将在这里介绍一些基本形状。
- en: Triangles
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三角形
- en: The easiest way to create a triangle is by using `goto()`. [Listing 9-6](#listing9-6),
    *triangle.py*, draws a triangle with the corners at (–50, –50), (50, –50), and
    (0, 100).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三角形的最简单方法是使用 `goto()`。[示例 9-6](#listing9-6) 中，*triangle.py* 绘制了一个三角形，三个角的坐标分别为
    (–50, –50)、(50, –50) 和 (0, 100)。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-6: Python code for *t**riangle.py*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6：*t**riangle.py* 的 Python 代码
- en: The `tracer()` function tells the script whether to trace the movements of the
    turtle. The default value is `tracer(True)`, which means the script shows you
    the movement of the turtle step-by-step. When the turtle pen draws something,
    you’ll see the drawing, one stroke after another. Here, we use `tracer(False)`,
    so the final drawing is printed, but the script doesn’t show the intermediate
    steps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracer()` 函数告诉脚本是否追踪乌龟的运动。默认值是 `tracer(True)`，意味着脚本会逐步展示乌龟的移动。当乌龟画出一些内容时，你将看到每一笔的绘制过程。这里我们使用
    `tracer(False)`，因此最终的图形会被打印出来，但脚本不会显示中间的步骤。'
- en: We change the pen’s color to blue 1 and its size to 5\. We lift up the pen and
    go to point (–50, –50) then put down the pen and go to point (50, –50). This forms
    the first leg of the triangle. With the pen down, we ask the turtle to go to point
    (0, 100), which forms the second leg. The base is drawn when we send the pen back
    to point (–50, –50) to complete the triangle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将笔的颜色改为蓝色1，大小设置为5。然后抬起笔，移动到点（–50, –50），再放下笔，移动到点（50, –50）。这形成了三角形的第一条边。笔下后，我们让海龟移动到点（0,
    100），形成第二条边。最后，我们将笔移动回点（–50, –50），完成三角形的底边。
- en: Note that since we’ve used the command `tracer(False)` to not display each drawing
    step (thus saving time), we need to put `update()` at the end of the script to
    show the completed picture, as shown in [Figure 9-6](#figure9-6).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们使用了命令`tracer(False)`来禁用每一步绘图的显示（从而节省时间），因此在脚本末尾需要使用`update()`来显示完整的图像，如[图
    9-6](#figure9-6)所示。
- en: '![f09006](Images/f09006.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](Images/f09006.png)'
- en: 'Figure 9-6: Draw a triangle using the *turtle* module.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-6: 使用 *turtle* 模块绘制三角形。'
- en: Rectangles
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 矩形
- en: We can draw rectangles by using `goto()`, as we did for triangles, but we can
    also use `forward()` and `left()`. In many situations, you can achieve the same
    goal by using either the `goto()` function or the `forward()` and `left()` functions.
    If you know the coordinates of the destination, `goto()` is easier, and if you
    know the distances between two points, the directional functions are easier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像绘制三角形一样，使用`goto()`绘制矩形，但我们也可以使用`forward()`和`left()`。在许多情况下，你可以通过使用`goto()`函数或`forward()`和`left()`函数来实现相同的目标。如果你知道目的地的坐标，`goto()`更简单；如果你知道两点之间的距离，方向函数则更易用。
- en: Here, we’ll use `forward()` and `left()`. You’ll achieve the same results by
    using `goto()` in the “End-of-Chapter Exercises” on page 187.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`forward()`和`left()`。你也可以通过使用`goto()`来实现相同的结果，详见第187页的“章节末练习”部分。
- en: We’ll draw a rectangle with the points (0, 0), (200, 0), (200, 100), and (0,
    100). Enter the script *rectangle.py* shown in [Listing 9-7](#listing9-7).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个矩形，四个顶点为（0, 0）、（200, 0）、（200, 100）和（0, 100）。请输入[列表 9-7](#listing9-7)中的
    *rectangle.py* 脚本。
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-7: Python code for *r**ectangle.py*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-7: *rectangle.py* 的 Python 代码'
- en: We first set up the screen. At 1, we set the pen size to 6\. We don’t specify
    the pen color, so the default color of black will be used. At 2, the turtle moves
    forward 200 pixels from the initial position of (0, 0) to form the first side
    of the rectangle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置屏幕。在第1步，我们将笔的大小设置为6。由于没有指定笔的颜色，因此使用默认的黑色。在第2步，海龟从初始位置（0, 0）向前移动200像素，形成矩形的第一条边。
- en: Next, the turtle turns left 90 degrees so that it faces up. Then it moves forward
    100 pixels to form the second side. We then make the turtle turn left 90 degrees
    so that it faces west, and move it forward 200 pixels for the third side. The
    last side of the rectangle is formed similarly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，海龟向左转90度，面朝上方。然后它向前移动100像素，形成第二条边。接着，我们让海龟向左转90度，面朝西方，并向前移动200像素，形成第三条边。矩形的最后一条边以类似方式绘制。
- en: The output is shown in [Figure 9-7](#figure9-7).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如[图 9-7](#figure9-7)所示。
- en: '![f09007](Images/f09007.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](Images/f09007.png)'
- en: 'Figure 9-7: Draw a rectangle using the *turtle* module.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-7: 使用 *turtle* 模块绘制矩形。'
- en: We’ll use this rectangle-drawing skill to create a board for our upcoming games.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种绘制矩形的技巧来为即将到来的游戏创建一个棋盘。
- en: Draw Grid Lines
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制网格线
- en: Games such as tic-tac-toe and Connect Four use a grid. We can make a grid simply
    by drawing squares. Here we’ll draw a game board with six rows and seven columns;
    the horizontal lines will be thinner and lighter than the vertical ones to match
    what we’ll do in the Connect Four game. Enter the code from *grid_lines.py* in
    [Listing 9-8](#listing9-8).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 像井字游戏和四连棋这样的游戏都使用网格。我们可以通过绘制方形来简单地创建网格。这里，我们将绘制一个包含六行七列的游戏棋盘；水平线将比垂直线更细、更浅，以符合我们在四连棋游戏中所做的设计。请输入[列表
    9-8](#listing9-8)中的 *grid_lines.py* 代码。
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-8: Python code for *g**rid**_l**ines.py*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-8: *grid_lines.py* 的 Python 代码'
- en: We first set up the screen. Since we plan to draw a game board with six rows
    and seven columns, we set the screen size to 810 pixels wide and 710 pixels tall.
    This way, we can make each cell a square that’s 100 by 100 pixels, with a 55-pixel
    margin around the board. It’s important to think about your screen size so you
    can calculate the coordinates of various points.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置屏幕。由于我们计划绘制一个包含六行七列的游戏棋盘，我们将屏幕大小设置为810像素宽、710像素高。这样，我们可以将每个单元格设置为100×100像素，棋盘四周留有55像素的边距。考虑屏幕大小非常重要，这样可以帮助你计算出各个点的坐标。
- en: 'We draw eight thick vertical lines with a pen size of 5 1 to divide the screen
    into seven columns. The function `range(-350,400,100)` produces eight values:
    `-350, -250, ..., 350`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '我们用笔的大小为 5 1 画了八条粗的垂直线，将屏幕划分为七列。函数 `range(-350,400,100)` 会产生八个值：`-350, -250,
    ..., 350`。  '
- en: After that, we draw seven thin, gray, horizontal lines to form six rows 2. If
    you run the script, you’ll see a screen similar to [Figure 9-8](#figure9-8).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，我们画七条细的灰色水平线，形成六行 2。如果你运行脚本，你会看到一个类似于 [图 9-8](#figure9-8) 的屏幕。  '
- en: We’ll use this board in Chapter 11 for our games.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在第 11 章的游戏中使用这个板。  '
- en: Animation
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '动画  '
- en: In this section, you’ll learn to create animation by using `clear()` and `update()`
    to clear the current image and replace it with the next, producing animation frames.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在这一部分，你将学习如何使用 `clear()` 和 `update()` 来清除当前图像并用下一个图像替换，从而产生动画帧。  '
- en: '![f09008](Images/f09008.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f09008](Images/f09008.png)  '
- en: 'Figure 9-8: Draw grid lines to form a six-by-seven game board'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-8: 绘制网格线以形成一个六行七列的游戏板  '
- en: How Animation Works
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '如何动画工作  '
- en: The `clear()` function erases everything the turtle has drawn on the screen.
    You can then redraw objects and use `update()` to put them onscreen. If you do
    this repeatedly, the rapid replacement of images will create an animation effect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear()` 函数会清除海龟在屏幕上画的所有内容。然后你可以重新绘制对象，并使用 `update()` 将它们显示在屏幕上。如果你重复这个过程，图像的快速替换将产生动画效果。  '
- en: We’ll explore animation by making a simple clock, shown in *turtle_clock.py*
    in [Listing 9-9](#listing9-9).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将通过制作一个简单的时钟来探索动画，时钟在 [示例 9-9](#listing9-9) 的 *turtle_clock.py* 中展示。  '
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-9: Python code for *turtle_clock**.py*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-9: *turtle_clock**.py* 的 Python 代码  '
- en: We import the modules and set up the screen. At 1, we start an infinite loop.
    In each iteration, the script first erases everything onscreen by using `clear()`.
    We then obtain the current time by using the *arrow* module and store the value
    in the variable `current_time`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '我们导入模块并设置屏幕。在 1 处，我们开始一个无限循环。在每次迭代中，脚本首先通过使用 `clear()` 清除屏幕上的所有内容。然后我们通过使用
    *arrow* 模块获取当前时间，并将值存储在变量 `current_time` 中。  '
- en: The `write()` function from the *turtle* module writes text onscreen. It takes
    the text to be displayed as the first argument and the font to use as the second
    argument. At 2, we write `The Current Time Is` to the screen in blue. At 3, the
    script writes the current time in red.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*turtle* 模块的 `write()` 函数将在屏幕上写文本。它的第一个参数是要显示的文本，第二个参数是使用的字体。在 2 处，我们用蓝色在屏幕上写
    `The Current Time Is`。在 3 处，脚本用红色写下当前时间。  '
- en: The script then pauses for one second and makes sure that all the new drawings
    are updated by using `update()`. If you run the script, you’ll notice that the
    time changes every second ([Figure 9-9](#figure9-9)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '然后脚本暂停一秒，并确保通过使用 `update()` 更新所有新的绘图。如果你运行脚本，你会注意到时间每秒都会变化（见 [图 9-9](#figure9-9)）。  '
- en: '![f09009](Images/f09009.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f09009](Images/f09009.png)  '
- en: 'Figure 9-9: Create animation in the *turtle* module.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9-9: 在 *turtle* 模块中创建动画'
- en: We’ll use this method frequently to create animations in various games.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在各种游戏中频繁使用这种方法来创建动画。  '
- en: Use Multiple Turtles
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '使用多个海龟  '
- en: Now we’ll look at using two turtles simultaneously—the equivalent of using two
    pens. In Chapter 12, when we create a guess-the-word game, we’ll use one turtle
    to create a gold coin on the game board and another to count the number of chances
    the player has left. Whenever the player misses a letter, we’ll erase the previous
    number and change it to the new number. If we used only one turtle, everything,
    including the coin image, would be wiped. If we use a second turtle, we can keep
    everything else onscreen and change only whatever the second turtle draws.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们来看一下如何同时使用两个海龟——相当于使用两支笔。在第 12 章，当我们创建一个猜词游戏时，我们将使用一个海龟在游戏板上画一个金币，另一个用来计算玩家剩余的机会次数。每当玩家错过一个字母时，我们将擦除之前的数字，并用新数字替换。如果我们只使用一个海龟，那么所有内容，包括金币图像都会被清除。如果我们使用第二个海龟，我们可以保持屏幕上的其他内容不变，只更改第二个海龟所绘制的部分。  '
- en: In [Listing 9-10](#listing9-10), *two_turtles.py*, we’ll use one turtle to draw
    a square and another to write something below it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [示例 9-10](#listing9-10)，*two_turtles.py* 中，我们将使用一个海龟绘制一个正方形，另一个海龟在其下方写字。  '
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-10: Python code for *two_turtles**.py*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-10: *two_turtles**.py* 的 Python 代码  '
- en: We import the *turtle* module and set up a screen with a size of 810 by 710
    pixels. Starting at 1, we draw a blue square in the middle of the screen, similar
    to the way we drew a rectangle but with all sides the same length.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '我们导入 *turtle* 模块，并设置一个大小为 810 x 710 像素的屏幕。从 1 开始，我们在屏幕中央画一个蓝色的正方形，类似于我们画矩形的方式，只不过四条边长度相等。  '
- en: At 2, we create a second turtle with `Turtle()` and name it `msg`. We tell the
    script to hide the second turtle
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在2处，我们通过`Turtle()`创建了第二只海龟，并将其命名为`msg`。我们告诉脚本隐藏第二只海龟
- en: The second turtle `msg` lifts up the pen, changes the color to red, goes to
    (–300, –200), and writes the message `this is written by the second turtle`. The
    `update()` function refreshes the screen to draw everything created by the two
    turtles, shown in [Figure 9-10](#figure9-10).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二只海龟`msg`抬起画笔，将颜色改为红色，移动到坐标（–300, –200），并写下消息`this is written by the second
    turtle`。`update()`函数刷新屏幕，绘制由两只海龟创建的所有内容，如[图9-10](#figure9-10)所示。
- en: '![f09010](Images/f09010.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![f09010](Images/f09010.png)'
- en: 'Figure 9-10: A screen created with two turtles'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10：由两只海龟创建的屏幕
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the basics of the *turtle* module. You first learned
    how to set up a turtle screen and then learned basic movements like going forward
    or backward and turning left or right. You created various shapes by using both
    the built-in function and basic movement commands.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了*turtle*模块的基础知识。你首先学习了如何设置海龟屏幕，然后学习了基本的移动方式，比如前进、后退以及左转、右转。你通过使用内置函数和基本移动命令创建了各种形状。
- en: Finally, you learned to create animation effects in the *turtle* module by using
    the `clear()` and `update()` functions. In the next few chapters, you’ll learn
    how to use these skills to create voice-controlled graphical games.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了通过使用`clear()`和`update()`函数在*turtle*模块中创建动画效果。在接下来的几章中，你将学习如何使用这些技能创建语音控制的图形游戏。
- en: End-of-Chapter Exercises
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Modify *set_up_screen.py* so that the screen size is 500 pixels wide and 400
    pixels tall, the background color is blue, and the title is `Modified Screen`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*set_up_screen.py*，使屏幕宽度为500像素，高度为400像素，背景颜色为蓝色，标题为`Modified Screen`。
- en: Modify *forward_backward.py* so that the turtle first moves backward 100 pixels
    and then moves forward 250 pixels.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*forward_backward.py*，使得海龟先后退100像素，再前进250像素。
- en: Modify *dots.py* to have only two light green dots with diameters of 60 at points
    (–100, –100) and (100, 100).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*dots.py*，使其只包含两个直径为60的浅绿色点，分别位于坐标（–100, –100）和（100, 100）处。
- en: Modify *triangle.py* so that the three sides of the triangle are red with a
    thickness of 3\.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*triangle.py*，使得三角形的三条边为红色，边宽为3\。
- en: Replicate the result in *rectangle.py* by using `goto()`. You aren’t allowed
    to use the functions `forward()`, `backward()`, `left()`, or `right()`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`goto()`函数来复制*rectangle.py*中的结果。你不能使用`forward()`、`backward()`、`left()`或`right()`等函数。
- en: '10'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Tic-Tac-Toe
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋
- en: '![](Images/chapterart.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll build a voice-controlled tic-tac-toe game to put all
    your new skills into practice. You’ll draw a game board with blue and white game
    pieces, disallow invalid moves, and detect if a player has won. You’ll then add
    the speech recognition and text-to-speech functionality and set the game so you
    play with your own computer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将构建一个语音控制的井字棋游戏，将你所有的新技能付诸实践。你将绘制一个带有蓝色和白色棋子的游戏棋盘，禁止无效的移动，并检测玩家是否获胜。接着，你会添加语音识别和文本转语音功能，并设置游戏，让你与自己的电脑进行对战。
- en: As usual, all scripts in this chapter are available at the book’s resources
    page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Before you begin, set up the folder */mpt/ch10/* for this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，本章的所有脚本都可以在本书的资源页面上找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。在开始之前，设置本章的文件夹*/mpt/ch10/*。
- en: Game Rules
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: Tic-tac-toe is probably one of the most well-known games in the world, but just
    to be sure, I’ll go over the rules before we create our game board. In tic-tac-toe,
    two players take turns marking a cell with an X or O in a three-by-three grid.
    The first player to connect three Xs or Os in a row horizontally, vertically,
    or diagonally wins. If no one connects three before all the cells are full, the
    game is tied. Instead of X and O, we’ll use blue and white dots as game pieces.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋可能是世界上最著名的游戏之一，但为了确保，我们在创建游戏棋盘之前先复习一下规则。在井字棋中，两个玩家轮流在一个三乘三的网格中标记一个格子，标记为X或O。第一个将三个X或O连成一排（横向、纵向或对角线）的人获胜。如果在所有格子填满之前没有人连成三个，游戏将以平局结束。我们将用蓝色和白色的点代替X和O作为棋子。
- en: Draw the Game Board
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制游戏棋盘
- en: We’ll draw a three-by-three grid on the screen and assign a number to each cell
    so we can tell the script where to place each game piece. Open your Spyder editor,
    copy the code in [Listing 10-1](#listing10-1), and save the script as *ttt_board.py*
    in your chapter folder.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕上绘制一个三乘三的网格，并为每个单元格分配一个编号，以便告诉脚本在哪里放置每个棋子。打开你的 Spyder 编辑器，复制 [清单 10-1](#listing10-1)
    中的代码，并将脚本保存为 *ttt_board.py*，存放在你的章节文件夹中。
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10-1: Drawing the tic-tac-toe game board'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-1：绘制井字游戏棋盘
- en: We import all functions in the *turtle* module and set the screen to 600 by
    600 pixels. Because we have a three-by-three grid, each cell is 200 by 200 pixels.
    We set the background color to red and set the title as `Tic-Tac-Toe in Turtle
    Graphics`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 *turtle* 模块中的所有函数，并将屏幕设置为 600 像素 × 600 像素。由于我们有一个三乘三的网格，因此每个单元格的大小是 200
    像素 × 200 像素。我们将背景色设置为红色，并将标题设置为 `Tic-Tac-Toe in Turtle Graphics`。
- en: With the command `for i in (-100, 100)`, we iterate the variable `i` through
    the range –100 to 100 1. As a result, the `for` loop produces two horizontal lines
    and two vertical lines. The two horizontal lines are between points (–300, –100)
    and (300, –100) and points (–300, 100) and (300, 100). The two vertical lines
    are between points (–100, –300) and (–100, 300) and points (100, –300) and (100,
    300). These lines evenly divide the screen into nine cells.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 `for i in (-100, 100)`，我们将变量 `i` 在范围 -100 到 100 之间进行迭代。结果，`for` 循环产生了两条水平线和两条垂直线。两条水平线分别位于点
    (–300, –100) 和 (300, –100)，以及点 (–300, 100) 和 (300, 100) 之间。两条垂直线分别位于点 (–100, –300)
    和 (–100, 300)，以及点 (100, –300) 和 (100, 300) 之间。这些线均匀地将屏幕分成了九个单元格。
- en: We then create a dictionary `cellcenter` to map each cell number to the x- and
    y-coordinates of the center of the corresponding cell 2. For example, the lower-left
    cell is cell number 1, and the coordinates of its center are (x = –200, y = –200).
    We do this for all nine cells in the dictionary, using the cell number as the
    key and the coordinates as the value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个字典 `cellcenter`，将每个单元格编号映射到相应单元格中心的 x 和 y 坐标。例如，左下角的单元格是单元格编号 1，它的中心坐标是
    (x = –200, y = –200)。我们为字典中的所有九个单元格执行相同操作，使用单元格编号作为键，坐标作为值。
- en: 'At 3, we use the `for` loop to iterate through nine pairs of values to write
    the cell number at the cell’s center. The command `list(cellcenter.items())` produces
    a list of the nine key-and-value pairs from `cellcenter`, which should look like
    this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步，我们使用 `for` 循环迭代九对值，在每个单元格的中心写入单元格编号。命令 `list(cellcenter.items())` 会生成一个包含来自
    `cellcenter` 的九个键值对的列表，结果应该如下所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At each iteration of the `for` loop, the turtle goes to the center of the cell
    and writes the cell number there. Run the script and you should see a screen similar
    to [Figure 10-1](#figure10-1).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代 `for` 循环时，海龟会移动到单元格的中心，并在那里写下单元格编号。运行脚本后，你应该能看到类似于 [图 10-1](#figure10-1)
    的屏幕。
- en: '![f10001](Images/f10001.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](Images/f10001.png)'
- en: 'Figure 10-1: The board for tic-tac-toe'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：井字游戏的棋盘
- en: Create the Game Pieces
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏棋子
- en: Now we’ll add code to place game pieces in the cells. You’ll first learn how
    mouse clicks work in the *turtle* module and then use them to place the pieces.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加代码，将游戏棋子放置到单元格中。你将首先了解鼠标点击在 *turtle* 模块中的工作原理，然后使用它们来放置棋子。
- en: How Mouse Clicks Work in turtle
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标点击在 turtle 中的工作原理
- en: When you left-click on the turtle screen, the x- and y-coordinates of the point
    you clicked are displayed onscreen. [Listing 10-2](#listing10-2), *mouse_click.py*,
    handles a simple mouse click. This is just for example purposes; we won’t use
    this code in the final script but will use the same principles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 turtle 屏幕上左键点击时，点击位置的 x 和 y 坐标会显示在屏幕上。[清单 10-2](#listing10-2) 中的 *mouse_click.py*
    处理一个简单的鼠标点击事件。这只是示范用的代码；我们不会在最终的脚本中使用这段代码，但会使用相同的原理。
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-2: How mouse clicks work in the *turtle* module'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-2：鼠标点击在 *turtle* 模块中的工作原理
- en: As usual, we import the *turtle* module and set up the screen. At 1, we define
    the function `get_xy()`, which prints out the x- and y-coordinates of your click.
    We also hide the turtle so you don’t see the cursor moving around the screen.
    At 2, we bind the onscreen mouse click to the `get_xy()` function by using the
    *turtle* function `onscreenclick()`, which returns the x- and y-coordinates of
    the click. As a result, `onscreenclick(get_xy)` supplies the x- and y-coordinates
    of your mouse click to `get_xy()` as its two inputs. At 3, we use `listen()` to
    detect events like mouse clicks and keyboard presses.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *mouse_click.py*, randomly click the screen several times, and you should
    see something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For each of my five clicks, `onscreenclick()` captured the x- and y-coordinates
    of the point and provided the two values to `get_xy()`, which printed out the
    corresponding x- and y-values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Convert Mouse Clicks to Cell Numbers
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll combine the board creation and click detection scripts so that when
    you click a cell, the script prints out the cell number. In [Figure 10-2](#figure10-2),
    I’ve marked the row and column numbers on the game board along with the x- and
    y-coordinates of the gridlines.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Open *ttt_board.py*, add the code in [Listing 10-3](#listing10-3) at the bottom
    (above `t.done()`) and save the new script as *cell_number.py* in your chapter
    folder. This script is just an example; we won’t use it in the final code but
    will use something similar.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-3: Converting mouse clicks to cell numbers'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![f10002](Images/f10002.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: Mark the row and column numbers on the game board.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define `cell_number()`, which will convert the x- and y-coordinates
    of the mouse click to the cell number. Inside the function, we restrict the x-
    and y-coordinates of the point you click to the range of the board. If you click
    outside the range, the script will print `you have clicked outside the game board`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we convert the x-coordinate of the click to the column number. Points
    in column 1 have x-coordinates between –300 and –100, and points in column 2 have
    x-coordinates between –100 and 100, so we use the formula `col = int((x+500)//200)`
    to get the full range of pixel coordinates in the column so we can convert the
    x-coordinate to the column number. We use the same method to convert the y-coordinate
    to the row number.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We then calculate the cell number by using the formula `cellnumber = col+(row-1)*3`
    because the cell numbers increase from left to right and then from bottom to top
    3. Finally, we bind the onscreen click to `cell_number()`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *cell_number.py*. Here’s the output from one exchange with the script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each time you click a cell, the script prints out the column number, row number,
    and cell number.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Place Game Pieces
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll place the game pieces on the board. When you first click any of
    the nine cells, a blue piece will appear at the center of the cell. When you click
    again, the piece will be white, then blue, and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Open *ttt_board.py*, add the code in [Listing 10-4](#listing10-4), and save
    the new script as *mark_cell.py* in your chapter folder. Make sure you don’t add
    this code snippet to *cell_number.py*!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-4: Placing game pieces on the board'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We draw the board and then define the variable `turn` that will keep track of
    whose turn it is. We first assign the value `blue` to the variable so that the
    blue player moves first.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'At 1, we define `mark_cell()`, which places a piece in the cell you click.
    At 2, we declare the global variable `turn`. Python provides the `global` keyword,
    which allows `turn` to be used both inside and outside `mark_cell()`. Without
    making the variable global, you’d get the error message `UnboundLocalError: local
    variable ''turn'' referenced before assignment` each time you clicked the board.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We then convert the x- and y-coordinates of the click to the cell number on
    the game board 3. Within the same line, we also convert the cell number from an
    integer to a string to match the variable type used in the dictionary `cellcenter`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we get the coordinates for the center of the clicked cell from `cellcenter`
    and tell the turtle to go there. The turtle places a dot 180 pixels wide and the
    color of the value stored in `turn`. After that, the turn is over, and we assign
    the turn to the other player. Finally, we bind `mark_cell()` to the mouse-click
    event.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you’ll be able to click the board and mark the cell. The
    color of the dot will alternate between blue and white, as in [Figure 10-3](#figure10-3).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![f10003](Images/f10003.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: Mark cells on the tic-tac-toe board.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is now a playable game! However, we need to implement three new
    rules to make it follow the rules of tic-tac-toe:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If a cell is already occupied, you cannot mark it again.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player marks three cells in a straight line—either horizontally, vertically,
    or diagonally—the player wins, and the game should stop.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all nine cells are occupied, the game should stop, and a tie should be called
    if no player wins.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine Valid Moves, Wins, and Ties
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll implement those rules, allowing only valid moves and declaring wins
    (or ties). Download *ttt_click.py* from the book’s resources and save it in your
    chapter folder or alter *mark_cell.py* with the differences highlighted in [Listing
    10-5](#listing10-5).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-5: Allow only valid moves and declare wins and ties.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Our first change is to import the *messagebox* module from the *tkinter* package;
    this module displays a message box for a win, tie, or invalid move.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 1, we create a variable `rounds`, a list `validinputs`, and a dictionary
    `occupied`. The variable `rounds` keeps track of the number of turns taken, which
    is the number of cells that have been marked. When the number of rounds reaches
    nine and no player wins (which is often the case in tic-tac-toe), we’ll declare
    a tie game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We use `validinputs` to determine whether a move is valid. If a cell is marked
    by a player, we’ll remove it from the list of valid moves.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary `occupied` keeps track of each player’s moves. At the beginning
    of the game, the keys `blue` and `white` both have an empty list as their value.
    When a player occupies a cell, the cell number will be added to that player’s
    list. For example, if the blue player has occupied cells 1, 5, and 9 and the white
    player has occupied cells 3 and 7, `occupied` will become `{"blue":["1","5","9"],"white":["3","7"]}`.
    We’ll use this later to determine whether a player has won the game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'At 2, we define `win_game()`, which checks whether a player has won the game.
    There are eight ways a player can win, which we explicitly check for:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Cells 1, 2, and 3 have been occupied by the same player.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 4, 5, and 6 have been occupied by the same player.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 7, 8, and 9 have been occupied by the same player.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 1, 4, and 7 have been occupied by the same player.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 2, 5, and 8 have been occupied by the same player.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 3, 6, and 9 have been occupied by the same player.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 1, 5, and 9 have been occupied by the same player.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells 3, 5, and 7 have been occupied by the same player.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function `win_game()` creates the variable `win` and assigns `False` as
    a default value. The function checks the dictionary `occupied` for the list of
    cells occupied by the player who currently has the turn, checking all eight win
    cases listed earlier. If one of the cases matches, the value `win` changes to
    `True`. When `win_game()` is called, it returns the value stored in the variable
    `win`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made significant changes to `mark_cell()`. At 3, we declare three global
    variables; all must be declared global because they will be modified inside the
    function. At 4, we check whether the cell number most recently clicked is in the
    list `validinputs`; if it is, a dot is placed in the cell, and the cell number
    is added to the player’s list of occupied cells 5. The cell is then removed from
    `validinputs` so that players can’t mark the same cell in future rounds.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: At 6, we call `win_game()` and see whether the current player has won the game.
    If yes, we change `validinputs` to an empty list so no further moves can be made.
    A message box will pop up to say, `Congrats player blue, you won!` or `Congrats
    player white, you won!`, using `showinfo()` from the *messagebox* module ([Figure
    10-4](#figure10-4)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![f10004](Images/f10004.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: A win for blue!'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: If the player hasn’t won, the script checks whether the number of rounds has
    reached nine 7. If yes, the script declares a tie game, displaying `Game over,
    it's a tie!` ([Figure 10-5](#figure10-5)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![f10005](Images/f10005.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: A tied game'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: If the game doesn’t end, we increase the number of rounds by one and assign
    the turn to the other player. During the game, if a player clicks an invalid cell,
    we’ll display `Sorry, that's an invalid move!` ([Figure 10-6](#figure10-6)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![f10006](Images/f10006.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: An invalid move'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Version
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to add the voice control and speech functionality. One significant
    change is that we’ll now make your opponent your computer. We’ll build on the
    latest *ttt_click.py* file. After you make a move as the blue player, the computer
    will randomly select a move as the white player until the game ends.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Download *ttt_hs.py* from the book’s resources or make the changes shown in
    [Listing 10-6](#listing10-6).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-6: Adding speech and voice-control functionality'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the functions we’ll need: the `choice()` function from the *random*
    module to let the computer randomly select a move and our `print_say()` and `voice_to_text()`
    functions from the custom package *mptpkg*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start an infinite `while` loop. At each iteration, the script asks
    for your move out loud. You speak into the microphone to make your move, and the
    script captures your voice command, storing the response in the variable `inp`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we did a little tweaking to make `voice_to_text()` more responsive to
    your voice commands. When your voice input is just one word, such as “One” or
    “Two,” it’s hard for the software to put the word in context and respond. On the
    other hand, if you say “Number one” or “Number two,” the software can easily pick
    up your meaning. The script simply replaces the “number” part of the voice command
    with an empty string so that only the number is left in `inp`. Sometimes `voice_to_text()`
    returns the number in word form such as `one` or `two`, instead of in numeric
    form, such as `1` or `2`. We therefore also change all the word forms to numerical
    forms. This way, you can say “number one” or “one” to the microphone, and `inp`
    will always be in the form you want: `1`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'If your choice is in `validinputs`, the script performs the sequence of actions
    to make the move: place a dot in the corresponding cell, add the cell number to
    your list of occupied cells, and remove the occupied cell number from the list
    of valid inputs.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks if you’ve won or tied the game 2 and responds out loud
    appropriately.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Once your turn is over, the computer randomly selects a move from `validinputs`
    to play against you 3. The script checks whether the computer has won or tied
    the game. If your voice command is not a valid move, the script speaks an alert.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one interaction with the game:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I’ve managed to win in just three moves!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to build a voice-controlled graphical tic-tac-toe
    game that talks in a human voice. Along the way, you learned a few new skills.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: You learned how mouse clicks work in the *turtle* module. With that knowledge,
    we marked cells on the game board with mouse clicks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to determine whether a player has won tic-tac-toe based on the
    explicit game rules. This is at the heart of game creation. You listed all cases
    when a player can win the game, then added code to check all cases and see whether
    there is a winner.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: You also added the speech recognition and text-to-speech features to a game,
    making a few tweaks to make sure the script can understand your input. By combining
    these skills, you’ll be able to create your own voice-controlled games.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *ttt_board.py* so that the cell number appears in 15-point font at the
    lower-left corner of each cell (80 pixels from the center of the cell, both horizontally
    and vertically).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *mouse_click.py* so that each time you click the screen, the script prints
    out the additional message `x + y is`, followed by the actual value of the x-
    and y-coordinates of the clicked point.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *cell_number.py* so that each time you click the screen, the script prints
    `you clicked the point (``x``,` `y``)` before printing the column, row, and cell
    numbers, where `x` and `y` are the actual coordinates. For example, if you click
    the point (x = –100, y = 50), the message should say `you clicked the point (-100,
    50)`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *mark_cell.py* so that the white player moves first.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *ttt_click.py* so that a player wins only by marking three cells in a
    row horizontally or vertically, but not diagonally.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '11'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connect Four
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voice-controlled Connect Four game. As with
    tic-tac-toe in Chapter 10, you’ll first draw the board and set the yellow and
    red game pieces to alternate turns. You’ll animate the effect of a disc falling
    from the top of a column to the lowest available row to make the game more visually
    engaging. You’ll disallow invalid moves, detect if a player has won, and detect
    if all 42 cells have been occupied with no winner, meaning the game is tied.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 10, you learned how to check whether a player has won the game by
    laying out all winning scenarios and checking whether the current game board matches
    one of the scenarios. We’ll apply that same strategy here. You’ll also learn how
    to use exception handling to prevent crashing during the process of checking and
    how to prevent negative indexing errors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Once the game is set up, we’ll add the speech recognition and text-to-speech
    features so you can play the game with your voice alone.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To start, set up the folder */mpt/ch11/* for this chapter. All scripts in this
    chapter are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Game Rules
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connect Four is a well-known board game, but I’ll go over the rules to clarify
    the logic in the upcoming code. In Connect Four, two players take turns dropping
    discs into one of seven columns, from the top. One player has red discs and the
    other yellow. The seven columns are on a six-row, vertically suspended grid. When
    a disc is dropped into a column, it will fall to the lowest available space in
    that column. Discs cannot move from one column to another.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The first player who forms a direct line—either horizontally, vertically, or
    diagonally—with four of their game pieces wins. If all 42 slots have been filled
    and nobody has won, the game is tied. We’ll use a red dot and a yellow dot to
    represent the discs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Draw the Game Board
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first draw a grid with six rows and seven columns. We’ll number the columns
    at the top of the screen to make it easier to play.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Open your Spyder editor and enter the code from [Listing 11-1](#listing11-1).
    Save the script as *conn_board.py* in your chapter folder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-1: Drawing the Connect Four game board'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We first import all functions in the *turtle* module, and then we set up the
    screen as 700 by 600 pixels 1. That lets us make each cell 100 by 100 pixels to
    keep things simple. We set the background color to light green and the title to
    `Connect Four in Turtle Graphics`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We then draw six thick vertical lines to divide the screen into seven columns.
    At 2, we set the pen width to 5 pixels. The command line `for i in range(-250,350,100)`
    tells the variable `i` to iterate through the following six values: –250, –150,
    –50, 50, 150, and 250\. These are the x-coordinates of the six vertical lines.
    The y-coordinates of the two endpoints of the six vertical lines are all –350
    and 350\. Similarly, we draw five thin, gray horizontal lines to divide the screen
    into six rows, starting at 3, with a pen size of 1 pixel and color of gray so
    that the lines appear thin and light. This all gives us an even grid with seven
    columns and six rows.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Next, we number the columns to let players know where to place the discs. We
    first create a variable `colnum` and assign a value `1` to it 4. We then iterate
    through the x-coordinates of the center of the seven columns and write the corresponding
    column number by adding one to the value of `colnum`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you should see a screen like [Figure 11-1](#figure11-1).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![f11001](Images/f11001.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The board for the Connect Four game'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The Mouse-Click Version
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you have a game board. Let’s drop some discs into the columns. In this section,
    you’ll learn how to use mouse clicks to place a disc in a column and let it fall
    to the lowest available cell. After that, you’ll detect invalid moves, wins, and
    ties.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Drop a Disc
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, you’ll use mouse clicks to place a disc in a column of your choice. The
    column number in which the disc will appear is determined by where you click.
    The row number depends on the number of discs already in that column.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: When you first click a column, a red dot will be placed in the lowest available
    cell. The colors will alternate with each click.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_board.py* and add the code in [Listing 11-2](#listing11-2). Then
    save the new script as *show_disc.py* in your chapter folder.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-2: Dropping discs on the game board'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The red player goes first, so after the game board is drawn, we define the variable
    `turn` and assign the value `red` to it 1. Starting at 2, we define three lists.
    The list `xs` contains values corresponding to the x-coordinates of the middle
    points of the seven columns. The list `ys` has six values corresponding to the
    y-coordinates of the middle points of the six rows. Later, we’ll use these lists
    to determine the x- and y-coordinates of the center of all 42 cells.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The list `occupied` is a list of lists. It starts as a list of seven empty lists,
    each representing a column. When you place a disc in a column, the disc will be
    added to the corresponding list. This way, `occupied` will keep track of all discs
    placed and their positions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: At 3, we define `conn()`, which places the disc on the column you click. We
    declare `turn` as a global variable, so that its value can be recognized both
    inside and outside `conn()`. Then, we convert the x-coordinate of the user’s click
    to the column number on the game board. We then determine the lowest row available
    in that column, which tells us which row to place the disc in. Note that `occupied[col-1]`
    is the list of all discs currently in the column, and we use `col-1` instead of
    `col` because Python uses zero indexing but our columns are numbered starting
    at 1\.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We then obtain the x- and y-coordinates of the center of the cell in which to
    place the new disc. The *turtle* module places a dot with a diameter of 80 pixels
    and the color value stored in `turn`. We add the disc to the corresponding list
    within `occupied` so that next time a disc is placed in the same column, the appropriate
    cell is marked as invalid. With this, the player’s turn is over, and we hand the
    turn to the other player. Finally, we bind `conn()` to the mouse-click event.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Run the script, and you should be able to click on the game board and mark the
    cell with a red or yellow dot. Keep clicking, and the color of the dot will alternate
    between red and yellow ([Figure 11-2](#figure11-2)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![f11002](Images/f11002.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Place discs on the Connect Four game board.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Animate the Falling Discs
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you play Connect Four in the real world, you drop the disc at the top,
    and it falls into the proper position. Next, you’ll create the animation effect
    of the disc falling. This is a good opportunity to learn how to create animation
    effects using the *turtle* module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Open *show_disc.py* and add the code in [Listing 11-3](#listing11-3). Save this
    as *disc_fall.py* in your chapter folder.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-3: Script to show the animation effect of discs falling'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: We import `sleep()` so we can pause the script to let the falling disc stay
    in a cell for a short while, allowing the user to see its movement 1. Starting
    at 2, we create a second turtle named `fall`. We lift the drawing pen of the new
    turtle so that it won’t leave a line as it moves. We also use `hideturtle()` to
    hide the cursor 3.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 4, we animate the falling disc. We first see if the column is full
    by checking whether the row number is less than 6\. If yes, we’ll show the animation
    effect. If the lower rows in the column are full, the disc can be left in place
    (there’s no need to show the disc falling).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We iterate `i` through all the empty cells above the lowest available cell.
    If the lowest available position is `row = 2`, for example, the command `for i
    in range(6,row,-1)` iterates `i` through values 6, 5, 4, and 3\. The `-1` tells
    the range function to count backward. At each iteration, the `fall` turtle places
    a dot in the center of the empty cell. The script draws a dot to the screen, pauses
    for 0.05 seconds, and then erases the dot before going to the next iteration.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is now a complete game! However, at the moment, players must use
    their own judgment to enforce the following rules:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: If a column is already full, you cannot drop a disc in it.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player connects four cells in a straight line, that player wins, and the
    game should stop.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all 42 cells are occupied and nobody has won, the game should stop and a
    tie be declared.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s code that into the game.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Determine Valid Moves, Wins, and Ties
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll improve the game by blocking invalid moves and declaring wins or
    ties. Open *disc_fall.py* and add the code in [Listing 11-4](#listing11-4). Save
    the new script as *conn_click.py*. The code changes are shown in two sections,
    so it’s easier to refer back to the code when reading the explanations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 11-4: First half of the script to disallow invalid moves and declare
    wins and ties'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We import the *messagebox* module from the *tkinter* package to allow us to
    display messages about wins, ties, and invalid moves.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create the list `validinputs` to keep track of valid moves. All seven
    columns are valid to start with. If a column contains six discs, it will be removed
    from the list.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'A player can win the game by collecting four discs in a row in one of four
    orientations: horizontally, vertically, diagonally in a forward-slash fashion
    (/), or diagonally in a backslash fashion (\). Therefore, we define four functions
    to check for each way of winning.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `horizontal4()`, which checks if a player has won the game by
    successfully connecting four discs in a row horizontally. In the function, we
    create the variable `win` and assign a default value of `False`. The function
    then checks whether the player has connected four discs horizontally. If yes,
    the value of `win` changes to `True`. When the function `horizontal4()` is called,
    it returns the value stored in the variable `win`. Let’s look at the details of
    this function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use `x = col-1` and `y = row-1` to convert column and row numbers on the
    game board to indexes in the `occupied`list. The cell with column number `col`
    and row number `row` corresponds to `occupied[x][y]` in `occupied`. For simplicity,
    we’ll call this cell `[x][y]` for the rest of the chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'A player can connect four pieces horizontally in four ways:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Cells `[x-3][y]`, `[x-2][y]`, and `[x-1][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells `[x-2][y]`, `[x-1][y]`, and `[x+1][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells `[x-1][y]`, `[x+1][y]`, and `[x+2][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells `[x+1][y]`, `[x+2][y]`, and `[x+3][y]` all have the same color as cell
    `[x][y]`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We therefore define a variable `dif` to iterate through four values `(-3, -2,
    -1, 0)`. For each value of `dif`, we check whether all four cells—`[x+dif][y]`,
    `[x+dif+1][y]`, `[x+dif+2][y]`, and `[x+dif+3][y]`—have the same color. If yes,
    we change the value of `win` to `True`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we need to make exceptions for `IndexError` because, for example,
    the value of `x+3` may be 8, but the board has only seven columns. If we do not
    make exceptions for `IndexError`, the script will crash in the process of checking
    whether the player has won the game.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Further, we ensure that none of the indexes have negative values, because negative
    indexing has a very specific meaning in Python. In Python, a negative index wraps
    around to the beginning of the list instead of falling off at the end. For example,
    index `-1` refers to the last element in a list in Python, `-2` to the second
    to last, and so on. Negative indexing will not raise an `IndexOutOfBounds` error,
    but it will also not behave as you expect.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example: for x = 1 and y = 2, when the script checks
    the cell `[x-3][2]`, it will look at cell `[-2][2]`, which is actually cell `[5][2`]
    because `-2` refers to the second-to-last value in x, which is 5 (that is, the
    sixth column, since there is a total of seven columns). Therefore, we put the
    condition `x+dif> = 0` in the function to ensure that we have no negative indexing
    anywhere.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `try` and `except` in every one of the four cases of winning
    by connecting four discs horizontally. If instead we had used just one set of
    `try` and `except` for all four cases of wins, whenever any `IndexError` occured,
    the script would skip all remaining cases and go to the `except` branch directly.
    This would cause the script to fail to identify many cases of wins.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we define `vertical4()` to check for a win by connecting four discs
    in a row vertically 3. Then `forward4()`checks for a forward diagonal win, and
    `back4()`checks for a backward diagonal win.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we define `win_game()`, which checks for a win in any of the 13 win scenarios
    (four horizontally, one vertically, four diagonally in a forward-slash fashion,
    and four diagonally in a backslash fashion). In `win_game()`, we create the variable
    `win` and assign a default value of `False`. The function first converts column
    and row numbers, `col` and `row`, to indexes in the `occupied`list, `x` and `y`.
    The function then calls the four functions just defined to see if the player may
    have won. If any of the four functions returns a value of `True`, the value of
    `win` changes to `True`, and `win_game()` will return a value of `True` when it’s
    called.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s examine the second half of the script (which we are saving as *conn_click.py*),
    shown in [Listing 11-5](#listing11-5).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 11-5: Second half of the script to disallow invalid moves and declare
    wins and ties'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create the variable `rounds`to keep track of the number of rounds played,
    corresponding to the number of discs on the game board, so that we can declare
    a tie when the number reaches 42\.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: We change `conn()` 2 to declare three global variables so that their values
    can be recognized both inside and outside the function. At 3, we call `win_game()`
    to see whether anyone has won. If yes, we change `validinputs` to an empty list
    so no further moves can be made. A message box will pop up that says `Congrats
    player red, you won!` or `Congrats player yellow, you won!`
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-3](#figure11-3) shows the red player winning a game.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![f11003](Images/f11003.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Red wins! The darker discs are red, and the lighter are yellow.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: If no one has won but `rounds` reaches 42, the script declares a tie game ([Figure
    11-4](#figure11-4)).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![f11004](Images/f11004.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: A tied game'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: If no player has won or the game is not tied, we increase the value of `rounds`
    by one and assign the turn to the other player. We also update the list of valid
    moves. If the number of discs in the current column reaches six, we remove the
    column number from the list `validinputs` 4.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: During the game, if a player clicks an invalid cell 5, a message box will say
    `Sorry, that's an invalid move!` ([Figure 11-5](#figure11-5)).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![f11005](Images/f11005.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: An invalid move'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The Voice-Controlled Version
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to add the voice control functionality!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll set the computer as your opponent in the game. After you make a
    move as the red player, the computer will randomly select a yellow move until
    the game ends. Once you understand how playing against a computer works, a voice-controlled
    game in which you play against another person is really simple. I’ll leave that
    as an end-of-chapter exercise, and the script is provided at the book’s resources
    website.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_hs.py* from the book’s resources and save it in your chapter
    folder. [Listing 11-6](#listing11-6) highlights the differences between *conn_hs.py*
    and *conn_click.py*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11-6: Script highlights for the voice-controlled Connect Four game'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: We import a few extra modules. The `choice()` function from the *random* module
    lets the computer randomly select a move to play against you. We also import our
    local `print_say()` and `voice_to_text()` functions from the local package *mptpkg*
    to handle the voice-control functionality.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: This time, we’ll use string values instead of integers to represent the seven
    column numbers in the list `validinputs`, because voice inputs are naturally string
    variables and, in many cases, attempting to convert voice inputs to integers will
    crash the script.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start an infinite `while` loop. At each iteration, the script asks
    for your move out loud. You speak into the microphone to make your move, and the
    script captures your voice command and stores it in `inp`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Here we did a little tweaking to make `voice_to_text()` more responsive to your
    voice commands, as we did in Chapter 10 (see [Listing 10-6](c10.xhtml#listing10-6)
    as a reminder). Further, the script always interprets *number four* as `number
    for`, so we replace `for` with `4` to get a better response from the script.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'If your voice command is not in `validinputs`, the script reminds you out loud:
    “Sorry, that’s an invalid move!” I’ve moved up the invalid voice input so that
    the `if` and `else` branches are close together in the script, making it easy
    for you to understand the logic. If the two branches are far apart, it’s easy
    to get lost in the long lines of code.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: If your voice command is a valid move 2, the script will place the disc as directed,
    let the disc fall to the lowest available space in the column, add the cell number
    to your list of occupied cells, remove the cell number from the list of valid
    inputs, and so on.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks whether you won the game and, if you have, congratulates
    you out loud 3. If not, it will check for a tie and announce accordingly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: When your turn is over, and if you haven’t won or tied the game, the computer
    randomly selects a move from `validinputs` to play against you 4, make the move,
    and check whether the computer has won the game 5. It will also check for a tie.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the printed message from one interaction with the game:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Figure 11-6](#figure11-6) shows my winning game.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![f11006](Images/f11006.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Red winning the voice-controlled version'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you created a voice-controlled graphical Connect Four game
    that talks back to you in a human voice. You set up the game board and mechanisms
    as you did in Chapter 10, but this time animated the moves.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to let Python determine whether a player has won the game. In
    the process, you learned to lay out all cases of winning and use the script to
    check each one. You also learned how to properly use exception handling and prevent
    negative indexing from causing mistakes in your script.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: You added the voice recognition and text-to-speech features, but also did a
    bit of refactoring to make sure your code stayed user readable as you added to
    it. In the next couple of chapters, you’ll create more voice-controlled graphical
    games and make them intelligent.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *conn_board.py* so that six row numbers appear at the right of the screen,
    with the top row being 6 and the bottom row being 1\. Make the x-coordinates of
    the row numbers 325.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *disc_fall.py* so that the discs fall at twice the speed.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *conn_click.py* so that a player wins only by connecting four discs of
    the same color horizontally or diagonally, and not vertically.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currently, when you play Connect Four using the final *conn_hs.py*, you can
    say either “number four” or “four” if you want to place a disc in column 4\. Modify
    the script so that you can also say “column four” to place a disc in that column.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *conn_hs.py* so that you play against a person instead of the computer.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '12'
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Guess-the-Word Game
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voice-controlled graphical guess-the-word game.
    This is an interesting challenge because when playing guess-the-word, players
    often talk quickly, so we’ll need to fine-tune our script’s listening abilities.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we’ll go over the game rules and draw a game board; this game board
    uses six coins to represent your six guesses. You’ll learn how to load a picture
    to a Python script and create multiple images of it onscreen. You’ll also learn
    to make the images disappear one by one.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start the game by using written inputs. Then, when we have it working
    well, we’ll add the speech recognition and text-to-speech features.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: All scripts in this chapter are available on the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch12/* for this chapter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Game Rules
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our guess-the-word game is loosely based on the hangman game. Our game will
    present only four-letter words to keep it simple, but you should try adapting
    it later when you’re comfortable with how it all works. Let’s go over the rules
    of the game first.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Similar to hangman, our guess-the-word game involves two players. The first
    player thinks of a word and draws a number of dashes equal to the number of letters
    in the word. The first player also draws six coins in the middle of the screen
    to represent the six incorrect guesses the second player will be allowed.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The second player tries to figure out the word by guessing one letter at a time.
    If the suggested letter is in the word, the first player fills in the blanks with
    the letter in the right places. If a suggested letter is not in the word, the
    first player erases a coin in the middle of the screen. If the second player completes
    the word before making six incorrect guesses, they win the game. If that player
    fails to identify the word before using up their six wrong guesses, they lose.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Draw the Game Board
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game board will preload with four dashes to represent the word. We’ll also
    include the message `incorrect guesses` onscreen. Open your Spyder editor and
    enter the code in [Listing 12-1](#listing12-1), saving it as *guess_word_board.py*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 12-1: Python script to draw the guess-the-word game board'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: We import the *turtle* module and set up the screen to be 600 by 500 pixels
    with a lavender background. The title will read `Guess the Word Game in Turtle
    Graphics`. Note that we omitted the last two arguments in `setup()`, so the game
    board will appear at the center of your computer screen by default.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we create a variable `score` to keep track of the number of guesses the
    player has left. It starts with a value of 6\. Later in the game, every time the
    player guesses an incorrect letter, the value will decrease by 1\. We also create
    a new turtle named `left`, representing the number of guesses remaining. We use
    the new turtle to write the number of chances the player has left, erasing whatever
    was there before. By using a new turtle, we limit the number of objects we need
    to redraw onscreen.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: We then add the text `incorrect guesses`, which will later show the incorrect
    letters the player guessed. We draw four dashes at the bottom of the board 3 to
    hold the four letters in the word. Run the script and you should see a board similar
    to [Figure 12-1](#figure12-1).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![f12001](Images/f12001.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: The board for the guess-the-word game'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The Text Version
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll place the six coins on the screen and enable the player
    to enter letters with the keyboard. You’ll then determine whether a player has
    won or lost the game. This completes the silent version of guess-the-word.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Load the Coins
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll place six coins at the center of the screen. In the process, you’ll learn
    how to load a picture to the script, resize it to any shape you like, and place
    as many objects on the turtle screen as you like. As noted, each coin corresponds
    to one incorrect guess.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Download the picture file *cash.png* from the book’s resources and place it
    in your chapter folder. Open *guess_word_board.py*, add the highlighted code in
    [Listing 12-2](#listing12-2), and save the new script as *show_coins.py* in the
    same chapter folder containing *cash.png*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 12-2: Script to show and remove coins'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: We import the `PhotoImage()` class from the *tkinter* module and the `sleep()`
    function from the *time* module. We then load *cash.png* by using `PhotoImage()`
    1. We use `subsample()` to scale the image to the size we want. In this case,
    we use scale factors of `(10,10)`, which means that both the width and the height
    of the picture are one-tenth that of the original picture.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'At 2, we create a list `coins` with six elements by using `[0]*6`. If you print
    out the list, it will look like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ll change the elements later; the `0` values are just placeholders.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new turtle in each element in `coins`. We then make the coin
    turtles go to the center of the screen and line up horizontally. To demonstrate
    how to load and then hide the coins, we have them stay onscreen for three seconds
    3 before using `hideturtle()` from the *turtle* module to make them disappear
    from the screen one at a time, starting with the last one.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-2](#figure12-2) shows the screen in the first three seconds, as
    the coins are lined up.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![f12002](Images/f12002.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: Showing coins on the guess-the-word game board'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Guess the Letters
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next version of the game will use 15 four-letter words, picked from a list
    of the most commonly used four-letter words according to Professor Barry Keating’s
    website at the University of Notre Dame (*https://bit.ly/3g7z7cg*). Keating has
    done extensive work in the fields of business forecasting and data mining. He
    is also the coauthor of the popular textbook *Forecasting and Predictive Analytics*
    (McGraw Hill, 2018).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: After we make the following modifications, the script will randomly choose one
    word, ask you to guess a letter, and then accept input from the IPython console.
    If a guess is right, the letter will show up on one of the dashes corresponding
    to the position of the letter in the word. In the rare case that the letter appears
    in the word twice, the letter will show up on two of the dashes. If the letter
    is not in the word, it will show up at the top of the screen in the list of incorrect
    guesses. We’ll skip placing the coins in this script to make testing of the code
    easier to follow.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Open *guess_word_board.py*, add the highlighted code in [Listing 12-3](#listing12-3),
    and save the new script as *guess_letter.py*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 12-3: Script to put letters on the game board'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: We first import `choice()` from the *random* module so the script can randomly
    pick a word from the list. We put the 15 words in the list `words` 1 and allocate
    the randomly selected word to `word`. At 2, we create the list `missed` to hold
    all incorrectly guessed letters. We then put the script in an infinite loop3 to
    continuously take your text input. If you want to stop the loop, you can enter
    `done` in the Spyder IPython console.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we check whether the letter you guess is in one of the letters in `word`.
    We use `list()`, which takes a string variable as input and breaks it into a list
    of individual letters; for example, the command `list("have")` produces the list
    `["h","a","v","e"]`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: If your guessed letter is in `word`, the function checks every letter in `word`
    to see if your guess matches the letter in that position. If so, the function
    writes the letter on the corresponding position onscreen.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: If your guess is not in `word` 5, the letter is added to `missed` and is written
    at the top of the screen in the `incorrect guesses` section.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also removed the line `t.done()` in this script. This means that,
    once you finish guessing and enter `done`, the script will end and everything
    will disappear from your screen.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output from one exchange with the script, when the script randomly
    selected the word *have* from the list of the 15 words, with my typed input in
    bold:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 12-3](#figure12-3) shows the resultant screen.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![f12003](Images/f12003.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: A guess-the-word game board with letters on it'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s working, but you may have noticed that some things need improvement. To
    have a complete version of guess-the-word, we need the script to do the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Prevent the players from guessing the same letter more than once. In my preceding
    interaction, I guessed *b*, *v*, and *h* twice, wasting my guesses.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notify the players when a word is complete.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop taking input after a player completes the word.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the six coins onscreen and remove one every time a player misses a letter.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine Valid Guesses, Wins, and Losses
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll disallow duplicate-letter guesses, declare a win if you complete
    the word while missing fewer than six letters, and declare a loss if not.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Open *guess_letter.py* and add the highlighted parts in [Listing 12-4](#listing12-4).
    Then save the new script as *guess_word.py*. A block of code in *guess_letter.py*
    is modified and replaced by the newly added blocks. If you’re uncertain what’s
    different, download the script *guess_word.py* from the book’s resources page.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 12-4: A graphical guess-the-word game that takes written input'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: We import the *messagebox* module from the *tkinter* Python package again so
    we can display messages to the game screen.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 1, we display the six coins onscreen. We update the screen so that
    everything we put there shows up properly 2.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: At 3, we create the list `validinputs`, which has the 26 letters in the alphabet
    as elements. Later in the script, if the player guesses a letter, we’ll remove
    the letter from the list so that the same letter can’t be guessed more than once.
    We also create the empty list `gotright`. Later we’ll use it to keep track of
    how many positions the player has guessed right in the word.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: We start an infinite `while` loop that asks for your keyboard input in every
    iteration. If you enter `done`, the loop stops, and the script quits taking input
    from you. If you enter invalid input (either a non-letter or a letter you’ve already
    guessed), the script will show a message box indicating `Sorry, that's an invalid
    input!`
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: If you enter valid input 4, the script checks whether the letter is in the word.
    If yes, the script checks each of the four positions in the word and, for each
    match, adds the letter to the list `gotright`. Note that since the same letter
    can appear in a word more than once, a letter may be added to the list `gotright`
    more than once.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks whether `gotright` has four elements. If yes, it means
    all four letters have been correctly guessed, and a message box will pop up with
    `Great job, you got the word right!`
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'If the guessed letter is not in the word 5, the value of `score` is decreased
    by one, meaning the player has one less guess left. The script will remove a coin
    from the screen by using `hideturtle()`. The second turtle will erase whatever
    it has drawn on the screen and rewrite the number of guesses left. If the length
    of the list `missed` reaches six, a message box appears: `Sorry, you used up all
    your six guesses!`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one exchange with the script with the user input in bold:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: My losing game is shown in [Figure 12-4](#figure12-4).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '![f12004](Images/f12004.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: A losing game of guess-the-word'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The Voice-Controlled Version
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll build on the written-input version of the game to add speech functionality.
    Download *guess_word_hs.py* and save it in your chapter folder. The new code is
    highlighted in [Listing 12-5](#listing12-5).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 12-5: A graphical guess-the-word game that takes voice input'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the usual functions from our local package *mptpkg*: `voice_to_text()`
    and `print_say()`. Because we installed the package (in editable mode), there’s
    no need to tell the system where to find it.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: We start an infinite `while` loop that asks for your choice of letter in each
    iteration 1. You speak your guess into the microphone, and the script captures
    your voice command and stores it in `inp`. We make allowances so the player can
    say either “letter a” or just “a.” If the former, we replace *letter* with an
    empty string so that only `a` is left in the variable `inp`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: To stop the `while` loop, you say, “Stop listening.” If your guess is not in
    the list `validinputs`, the script will answer, “Sorry, that’s an invalid input!”
    out loud. If your guess is in `validinputs` 2, the script checks whether the letter
    is in the word. This time, when you complete the word without missing six times,
    the game will say, “Great job, you got the word right!” 3. If you guess wrong
    six times, the voice will say, “Sorry, you used up your six guesses!” 4.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an exchange with the script in which the player has successfully guessed
    the word *good*, missing only two letters:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can see the screen in [Figure 12-5](#figure12-5).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '![f12005](Images/f12005.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: Winning the voice-controlled guess-the-word game'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you created a voice-controlled graphical guess-the-word game
    that talks back to you in a human voice.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: You first learned how to draw the game board. You then learned to upload a picture
    file to the script and scale it to the size you want. You used the image to create
    six coins on the screen to represent monetary rewards and made them disappear
    from the screen one by one. You also learned how to type in your guess and have
    it show up onscreen. You learned how to disallow guessing the same letter twice
    and how to determine whether a player has won or lost the game.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: You added the speech recognition and text-to-speech features so that the game
    can be voice controlled. Along the way, you learned how to create an image by
    manipulating a picture file in *turtle* and how to use multiple turtles to reduce
    the number of objects you have to redraw on the screen.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *show_coins.py* so that the positions of the six coins are 10 pixels
    below their current positions vertically. Keep the positions of everything else
    the same.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *show_coins.py* so that the leftmost coin disappears from the screen
    first and the rightmost one is the last to disappear.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to figure out what the following line of code will produce. First write
    down your answer and then run the code in Spyder to verify.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '13'
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Smart Games: Adding Intelligence'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: In the one-player version of Connect Four we built in Chapter 11, the computer
    always randomly selects a move. This allowed us to focus on the game’s speech
    recognition and text-to-speech aspects.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: However, once you play against the random computer for a few games, you start
    to wonder if there’s a way to make our Connect Four game more challenging. The
    answer is yes, and in this chapter, you’ll learn to make an intelligent Connect
    Four opponent.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'In one approach, we’ll ask the script to think three steps ahead, as people
    do when playing a game: two moves by the computer and one by the player.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the computer checks whether a move leads to winning the game
    right away. If yes, the computer will take it.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Thinking two steps ahead in Connect Four means the computer tries to prevent
    the opponent from winning in the next turn. This is complicated, because sometimes
    the computer must block a position and other times it must avoid taking a position.
    The computer will distinguish these two cases and block some moves and avoid others
    to prevent the opponent from winning.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: By thinking three steps ahead, the computer will follow the path that most likely
    leads to a victory for the computer after three moves. In many scenarios, thinking
    three steps ahead can guarantee a win in three steps. In particular, if there
    is a move that guarantees the computer to win in three moves, the computer will
    select that as the best next move.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The second method uses an approach that could be classified as a type of *machine
    learning*. You’ll simulate a million games in which both players select random
    moves. You’ll then record the outcome and the intermediate steps. With this data,
    the computer will learn at each move and select the one most likely to lead to
    a winning outcome.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assess the effectiveness of the two strategies and choose the one that
    is more difficult to beat. We’ll then add speech recognition and text-to-speech
    features to the intelligent Connect Four.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, I’ll also challenge you to apply the same methods to the tic-tac-toe
    game in the “End-of-Chapter Exercises” on page 267. As always, all scripts are
    available at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/),
    and you should create the folder */mpt/ch13/* for this chapter.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: The Think-Three-Steps-Ahead Strategy
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll first use the mouse-click version of Connect Four to speed up the testing
    of scripts. After we incorporate the strategy of thinking three steps ahead, we’ll
    add the speech features back.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Think One Step Ahead
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking one step ahead in Connect Four is easy. The computer checks all possible
    next moves, and if one of them will lead to a win right away, the computer will
    take it.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_think1.py* from the book’s resources and save it in your chapter
    folder. This is based on the script *conn_click.py* in Chapter 11, but I’ve altered
    the code so that you’re playing against an automated player that thinks one step
    ahead rather than another human player.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](#listing13-1) highlights the key parts of *conn_think1.py*.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 13-1: Think one step ahead in the Connect Four game.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: We import all needed modules. In particular, we import `choice()` from the *random*
    module and `deepcopy()` from the *copy* module. The *copy* module is in the Python
    standard library, so no installation is needed.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: To search for the best strategy, we’ll look one step ahead and see what would
    happen hypothetically if certain actions were taken. We need `deepcopy()` to copy
    a list without altering the original list. We can’t simply use assignment statements
    in this script when copying lists. Assignment statements in Python create a link
    to the original list object, so if we alter the copy, we alter the original as
    well. Altering the original list is not what we intend and would cause unexpected
    behavior.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we make `horizontal4(x,y,color,board)`more general so that it can be applied
    to any four arguments. Later in the script, we’ll use it to check whether certain
    moves win the game by collecting four discs horizontally in a hypothetical situation.
    We define the functions `vertical4()`, `forward4()`, and `back4()` in a similar
    way.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `win_game(num,color,board)`, which checks whether the player
    has won in any of the preceding four scenarios. We’ve also omitted the row number
    as an argument because it will be inferred from the argument `board`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The main action is in `best_move()`, starting at 3. This function searches for
    the best move for the computer (the red player). If column 4 is empty, the computer
    takes the center column. Since the red player moves first, this line of code ensures
    that the very first move of the game is always the center column 4, giving whoever
    makes the first move an advantage.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: If only one move is left (that is, six columns are full and only one column
    has empty cells), there’s no point searching for a best move, so the computer
    takes the only remaining move.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: If more than one move remains, the function checks every possible move to see
    if any will lead to a win for the computer right away. The script creates the
    list `winner` to contain the potentially winning moves 4. We go through all possible
    next moves. We use `win_game()` to check whether a move will win the game hypothetically.
    If yes, the move is added to `winner`. The function then checks whether `winner`
    is empty, and if it isn’t, the computer takes the first available move in the
    list.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: We then define `computer_move()`5. When called, this function tells the computer
    to make the move produced by `best_move()`. The computer then places a disc in
    the corresponding column. Once the computer places the disc, the script uses `win_game()`
    to check if the move wins the game 6.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The computer makes the first move of the game. After that, we define `conn()`,
    which allows you to click the screen to play your move. The script checks whether
    your move wins the game 7. The computer will move after you if the game isn’t
    over.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Run the script several times and play against the computer. You’ll notice that
    the computer will always take the winning move if there is one. For example, at
    the left of [Figure 13-1](#figure13-1), an opportunity emerges for the red player
    to take column 7 and win the game. The computer thinks one step ahead and takes
    the winning move.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '![f13001a](Images/f13001a.png)![f13001b](Images/f13001b.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A Connect Four game that thinks one step ahead'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Think Two Steps Ahead
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking two steps ahead in Connect Four is a little complicated. The computer’s
    next move can either block the opponent (which is you) or help the opponent’s
    chance of winning the game on the next turn.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll separate these two cases: if the computer’s move blocks the opponent’s
    chance of winning, the script will take it; if the computer’s move helps the opponent’s
    chance of winning, the script will avoid it. Let’s use examples to demonstrate
    the two cases.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Moves to Avoid
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, the computer should avoid a certain move so that the opponent
    won’t win on the next turn.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: At the left of [Figure 13-2](#figure13-2), it’s the red player’s turn. If the
    red player chooses column 6 as the next move, the opponent can win on the following
    turn, as shown on the right in the figure. Therefore, the red player should avoid
    this move.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '![f13002a](Images/f13002a.png)![f13002b](Images/f13002b.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The red player should avoid column 6 in this example.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the red player has made a move that allows yellow to win. We can avoid
    that win with this rule: if you make a next move *x*, and your opponent places
    a disc in the same column *x* two steps ahead and wins the game, you should avoid
    the move *x* in the next step.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Moves to Block
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next case, the computer should block a certain move so the opponent won’t
    win in two steps.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: At the left in [Figure 13-3](#figure13-3), it’s the red player’s turn. If the
    red player doesn’t choose column 3 in the next move, the opponent can choose column
    3 and win on the following turn. Therefore, the red player should block this move.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '![f13003a](Images/f13003a.png)![f13003b](Images/f13003b.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The red player should block column 3\.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the red player makes a different move—column 6—and loses the game. So
    the rule is as follows: if red makes the next move, *x*, and the yellow opponent
    can make a different move *y* within two steps and win, red should block yellow’s
    move *y* in the next step.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Think-Two-Steps-Ahead Strategy
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s allow the computer to think up to two steps ahead by using the three techniques
    just discussed (one for thinking one step ahead, two for thinking two steps ahead).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_think1.py*, replace its `best_move()` with the new `best_move()`
    function defined in [Listing 13-2](#listing13-2), and save the new script as *conn_think2.py*
    in your chapter folder (or you can download it from the book’s resources).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 13-2: Allow the computer to think up to two steps ahead.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: In the newly defined function `best_move()`, the script searches for the best
    move based on discs currently on the board. If this is the very first move of
    the game, the function takes the column in the middle. If only one move is left,
    the function defines the best move to be the only move left.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: If more than one move remains, the function checks every possible move to see
    if any will lead to a win for the red player (the computer) right away 1. If yes,
    the function returns the move as the best move and stores it in `winner`. If not,
    the function will look two steps ahead to see if the opponent can win within two
    steps 2.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'The function checks two separate cases: if the red player’s move `m1` (the
    first move) and the yellow player’s move `m2` (the second move) lead to a win
    for the yellow player in two steps, we add the move `m2` to the list `winner`.
    If the red player’s move `m1` and the yellow player’s move `m2=m1` lead to a win
    for the yellow player in two steps, we add the move `m2` to the list `loser`.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The script checks whether `winner` is empty. If it isn’t, the computer will
    select the opponent’s winning move to block the opponent from winning. Otherwise,
    the computer will check whether the list `loser` is empty. If not, the computer
    will avoid all elements in `loser` so as not to help the opponent win 3.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Run *conn_think2.py* and play a few times against the computer. You’ll notice
    an improvement in the game in the sense that the computer can now think two steps
    ahead and try to prevent you from winning on your next turn.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Think Three Steps Ahead
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This next section will allow the computer to think up to three steps ahead before
    taking its turn. If the computer has no winning move in the next step and the
    opponent has no winning moves two steps ahead, the computer will look three steps
    ahead.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The computer will take the next move that most likely leads to a win in three
    steps. In particular, if there’s a next move that guarantees the computer to win
    in three steps, the computer will select that next move as the best one. Let’s
    use an example to demonstrate.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: An Example of a Win in Three Steps
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The script *conn_think2.py* is harder to beat than *conn_think1.py*, but not
    impossible. A sophisticated player will notice that the computer misses some moves
    that could have led to a win in three steps.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. At the left of [Figure 13-4](#figure13-4), it’s the computer’s
    (the red player’s) turn to move. If the computer drops a disc in column 3, the
    computer is guaranteed to win on its next turn, because the opponent (the yellow
    player) can block only either column 1 or column 5\. The computer can then occupy
    the other column (either column 5 or column 1) in this third step and win the
    game.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: But instead, the computer chooses column 6, as shown at the right of [Figure
    13-4](#figure13-4), missing a chance to guarantee a win.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![f13004a](Images/f13004a.png)![f13004b](Images/f13004b.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: The computer (the red player) fails to make a move that guarantees
    a win.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: We should, therefore, make further improvements on the game. You’ll build a
    game that thinks three steps ahead.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Think-Three-Steps-Ahead Strategy
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s allow the computer to think up to three steps ahead.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Open *conn_think2.py*, add the newly defined `validmoves()` function and the
    highlighted part in [Listing 13-3](#listing13-3) to the `best_move()` function,
    and save the new script as *conn_think.py* in your chapter folder. Alternatively,
    you can download it from the book’s resources. This is the complete script for
    our think-ahead strategy.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 13-3: Allow the computer to think up to three steps ahead.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: We first define `validmoves(m1,m2,m3,occupied)` to ensure that none of the three
    future hypothetical moves `m1`, `m2`, and `m3` on the game board (represented
    by the list of lists `occupied`) will cause any columns to have more than six
    discs. If the three moves cause any of the seven columns to contain more than
    six discs, the function returns `False`; otherwise, it returns`True`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: As in *conn_think2.py*, the computer first checks whether a winning move could
    be made right away. If yes, it will take it. If not, it checks whether a winning
    move could be made two steps ahead for the opponent. If yes, the computer tries
    to prevent it.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'If no winning moves are available for the opponent two steps ahead, the computer
    looks three steps ahead 1. It checks all combinations of three moves: the computer’s
    next move, `m1`; the opponent’s move two steps ahead, `m2`; and the computer’s
    move at the third step, `m3`. If a combination leads to a win for the player,
    the next move `m1` is added to the list `winner`.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: However, just because a move `x` is in `winner` doesn’t mean this move will
    guarantee a computer win in three steps, because it can’t guarantee that the opponent
    will choose `m2` in the second step. Further, `winner` could contain multiple
    values. The function `best_move()` therefore looks for the most frequent value
    in `winner`, since that’s the move most likely to lead to a win for the computer
    in three steps.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: As with most things in Python, there are many ways to find the most frequent
    value in a list*.* We utilize a trick known as a *list comprehension* to create
    an inline dictionary `cnt`*.* In this dictionary, the key is the number of times
    a move appears in `winner`, and the value is the move 2. For example, if `winner`
    has six elements `[7, 6, 6, 5, 5, 5]`, the dictionary `cnt` would be `{1:7, 2:6,
    3:5}`. We then sort the keys in `cnt` to find the highest frequency and call it
    `maxcnt`. Here, `maxcnt` has a value of `3` because the highest number of times
    a value appears is three. Finally, we use `maxcnt` to retrieve the dictionary
    element with the highest frequency. Here, the move `5` appears most frequently
    in `winner`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: If you run *conn_think.py* and play the game, you’ll find the computer almost
    impossible to beat. If you do everything right, you can tie the game. The moment
    you make a wrong move, the computer will seize the opportunity and win the game.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: The Machine-Learning Strategy
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to make Connect Four smart is to let the computer learn from actual
    game outcomes. You’ll generate a million games in which both players use random
    moves. You’ll record the intermediate steps and the outcome of each game. The
    computer will use the game outcome data to design the best strategy.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: At each move, the computer looks at all games with the same game history as
    the current game board. It calculates the average outcome for each possible next
    move and chooses the one that most likely leads to a favorable outcome.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dataset of Simulated Games
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in the machine-learning strategy is to generate data to learn
    from. We’ll simulate two players choosing random moves and record both the outcome
    and the steps taken to reach that outcome. Even though the moves by both players
    are random, we repeat the game many times. The randomness in all these games is
    washed out by the law of large numbers. As a result, the outcome data will be
    useful to the computer to predict the outcome of a move.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_simulation.py* from the book’s resources. I explain the script
    in [Listing 13-4](#listing13-4).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 13-4: Simulating a million Connect Four games'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: We first define `simulate()`. When called, it simulates a complete Connect Four
    game and records each move and the game outcome. We omit the graphics part of
    the game to save time.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: We define `win_game()` to check if a player has won the game 1. In each game,
    the red player moves first 2. We create the two lists `moves` and `winlose` to
    record the intermediate moves and the game outcome, respectively.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: We create a game loop to iterate a maximum of 42 times because each Connect
    Four game has a maximum of 42 moves 3. In each iteration, a player randomly selects
    a move. The move is added to `moves` to keep track of the history of the game.
    At each step, we check whether a player wins. If yes, we’ll record an outcome
    of `1` if the winner is the red player and `-1` if the winner is the yellow player.
    The default outcome is a tie, in which case we’ll record a value of `0`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: We then call `simulate()` a million times 4. The result of each game is saved
    in a list `result`, with its first element being the outcome of the game (`-1`,
    `1`, or `0`), followed by the intermediate steps of the game.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: The outcomes and intermediate steps of the million games are saved in *conn_simulates.pickle*
    for later use 5. We print out the results of the first 10 games, shown in [Listing
    13-5](#listing13-5).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 13-5: The first 10 simulated Connect Four games'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: For example, the output for the first game is `[1, 1, 7, 1, 5, 7, 6, 5, 1, 5,
    7, 5, 2, 5]`. The first element, `1`, means that the red player has won the game.
    The remaining elements, `1, 7, 1 ...` , indicate the columns the players dropped
    their discs into, alternating between red and yellow. The red player eventually
    wins this game by connecting four red discs vertically in column 5.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Apply the Data
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to use the outcome data to design intelligent moves for the
    computer. At each move, the computer will turn to the simulated data to retrieve
    all games with the same history. It searches through all possible next moves,
    finds the one that leads to the most favorable outcome, and uses that as the next
    move.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Download *conn_ml.py* and save it in your chapter folder. The script is based
    on *conn_think.py*. [Listing 13-6](#listing13-6) highlights the main differences.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 13-6: A Connect Four game player with the machine-learning strategy'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: We create the new list `moves_made` to keep track of all moves in the game so
    far; we’ll use it later in `best_move()`. We open the simulated Connect Four game
    data and save it in a list `gamedata`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: In `best_move()`, we make sure the first move is always to place a disc in column
    4, as that gives the computer a starting advantage 1. We check if only one move
    is left and, if so, just take it as the next best move. Otherwise, we check all
    simulated games with the same history as the current game and see which next move
    will be most favorable to the red player. We assign that move as the best move.
    I’ll explain how we do that in detail in *ml_move.py*, using a concrete example.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define `computer_move()`. When it’s the computer’s turn to play, it
    calls `best_move()` to generate a move. The computer makes the move, and we add
    that move to the list `moves_made` to track the game history.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: We set the computer to make the first move 3. After that, the player clicks
    to make their move 4. The human player’s move is also added to `moves_made`. The
    computer will move after you if the game isn’t over.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Run *conn_ml.py* and play the game a few times. You might be surprised to find
    that it’s relatively easy to win. The machine-learning strategy is not nearly
    as effective as our three-steps method. We’ll look into why later in the chapter.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Test the Effectiveness of the Two Strategies
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we want to measure how intelligent the two strategies are. We’ll simulate
    1,000 games and record the outcomes. In each game, the intelligent computer version
    will play against a simple computer player that selects random moves. We’ll see
    how many times the intelligent player wins or ties the game.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: The Think-Three-Steps-Ahead Strategy
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with the three-steps version. The script *outcome_conn_think.py,*
    shown in [Listing 13-7](#listing13-7), has our two computer players play 1,000
    times, then prints out the number of winning, tying, and losing games.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 13-7: Test the effectiveness of the think-three-steps-ahead strategy.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define `simulate()`, which pits the intelligent computer (the red player)
    using the think-three-steps-ahead strategy against a computer player that selects
    random moves.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'The `win_game()` and `best_move()` functions are the same as those defined
    in *conn_think.py*. We use the list `winlose` to record the game outcomes 2: `1`
    if the red player wins, `-1` if the yellow player wins, and `0` if it’s a tie.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Once the game starts, the red player calls `best_move()` to obtain a move 3,
    while the yellow player randomly selects a move 4.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'At 5, we call `simulate()` 1,000 times and record the outcome of all games.
    We then print out the number of winning, tying, and losing games, summing the
    count of `1`, `-1`, and `0` to make it easier to read. Here’s an example of the
    output:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Out of all the games, the intelligent player with the think-three-steps-ahead
    strategy has won 995 times, never tied, and lost 5 times.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: The Machine-Learning Strategy
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll test the machine-learning strategy in the same way. Download *outcome_conn_ml.py*
    and save it in your chapter folder. This is similar to *outcome_conn_think.py*,
    so I’ll just highlight the differences here:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we obtain the simulated game outcome data that we’ve generated from *conn_simulation.py*.
    Second, we base the definition of `best_move()` on the machine-learning strategy
    instead of the three-steps strategy.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `simulate()` 1,000 times and record the outcomes, printing them as
    before. Here’s an example output:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Out of all the games, the computer has won 882 times, never tied, and lost 118
    times—it did significantly worse than with the three-steps strategy. Let’s look
    at why.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Why Doesn’t the Machine-Learning Strategy Work Well in Connect Four?
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The machine-learning strategy is less effective in our game mainly because
    so many moves are available in a Connect Four game: a maximum of 42\. That means,
    exponentially, that a very large number of possible game outcomes exist. We simulated
    a million games, which sounds like a lot, but when the data is spread among many
    game outcomes, it’s inevitable that some game outcomes will not be in the simulated
    data. As a result, it’s impossible to find a best strategy for many of the game
    histories.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll test the machine-learning strategy with one particular
    game history. Assume that the red and yellow players have both made three moves
    and next it’s the red player’s turn. The game board at this stage is as shown
    in [Figure 13-5](#figure13-5).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '![f13005](Images/f13005.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: One game simulation'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: We’ll simulate this game setup in code to see how our machine-learning strategy
    decides which move to make next. Enter *ml_move.py*, shown in [Listing 13-8](#listing13-8).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 13-8: Search for the best machine learning strategy move.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: We import *pickle*, which enables us to work with datasets saved in the *pickle*
    format. We open the simulation data file, *conn_simulates.pickle,* which was created
    earlier in *conn_simulation.py.* The data is saved in the `gamedata` list.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the red player is able to place a disc in any of the seven columns
    in the next move, so we have all seven values in `validinputs`. We save the six
    moves already made in [Figure 13-4](#figure13-4), `[4, 5, 4, 5, 4, 5]`, in the
    list `moves_made`. The list of lists `occupied` keeps track of the disc positions
    currently on the game board.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: We check the million simulated games data to see if any of those games match
    the game history of the current game. If yes, we put all the historical games
    that match in the list `simu`1. We then focus on the seventh move in all those
    games. We look at the outcomes (win, lose, or tie) of all games associated with
    each of the seven possible moves, 1 through 7, and put them in a dictionary `outcomes`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print out the content of `outcomes` 2:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, nine games have the same game history: none of which placed
    the next disc in column 1, two that used column 2 for the next move, one that
    used column 3, and so on. The values `-1`, `0`, and `1` inside the square brackets
    indicate that the red player loses, ties, and wins the game, respectively.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: To help us compare which of the seven moves leads to the best outcome for the
    red player, we calculate the average outcome for each move 3. If a move leads
    to wins 100 percent of the time, the average outcome is `1`; if a move leads to
    50 percent wins and 50 percent losses, the average outcome is `0`; if a move leads
    to a loss 100 percent of the time, the average is `-1`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'We print the average outcomes (we don’t have results for move 1 because no
    simulated game in `simu`used this move):'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Both moves 3 and 4 lead to an average outcome of `1`. The script prints out
    the first best move, which is 3 in this case 4:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: However, when we look at this move in the game ([Figure 13-6](#figure13-6)),
    we can see it clearly isn’t the best move we could have made.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '![f13006](Images/f13006.png)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: The machine-learning computer makes a mistake.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the problem with the machine-learning strategy is that we don’t
    have enough simulated games that match our game history.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder whether we can just increase the number of simulated games to
    solve the problem. The answer is yes and no. Increasing the number of simulated
    games will make the strategy more intelligent, but it will also increase the data
    size enough to slow the response of the machine-learning script. Thus, the player
    will have to wait a long time for the computer to make a move. This is the trade-off
    when using machine learning.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this by increasing the size of the simulated games to 10 million.
    Generating this data takes several hours. We rerun *ml_move.py* with the larger
    dataset and get the following output:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have much more data to base our decision on, the machine-learning
    strategy correctly recommends column 4, resulting in [Figure 13-7](#figure13-7).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '![f13007](Images/f13007.png)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: With 10 million simulated games, the strategy makes the correct
    move.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Intelligent Connect Four Games
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s wrap up this chapter by adding speech recognition and text-to-speech features
    to the intelligent Connect Four games.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Controlled Game That Thinks Ahead
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll mesh together two scripts, *conn_think.py* and *conn_hs.py*, into *conn_think_hs.py*.
    Download this file from the book’s resources and save it in your chapter folder.
    The main differences are shown in [Listing 13-9](#listing13-9).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 13-9: A voice-controlled Connect Four game with the three-steps strategy'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: The function `best_move()` is the same as in the script *conn_think.py* 1. We
    define `computer_move()` 2, which uses `best_move()` to choose a move and speaks
    aloud the selected column. If the computer’s move wins or ties the game, the script
    also announces it 3.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: The computer then makes the first move of the game4, and it starts a `while`
    loop that keeps running as long as the list `validinputs`isn’t empty 5. At each
    iteration, the script captures your voice input, which should be the number of
    the column you want to drop a disc in. You can say “number five,” “column five,”
    or “5.” It then converts the voice command to an integer number to match the format
    in `validinputs`so it can compare your input to the list. If you said something
    that isn’t convertible to an integer, the script will say, “Sorry, that’s an invalid
    input.”
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve given an invalid move 6, the script will say, “Sorry, that’s an invalid
    move.” If your move is valid, the script places the disc on the game board. In
    the process, it will check whether you’ve won or tied the game and, if so, will
    announce the result aloud. If the game is not yet over, the computer makes a move.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and play the voice-controlled game with the computer. You’ll
    notice that the game is more challenging and more interesting to play.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Controlled Game Using Machine Learning
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll mesh together two scripts we created before, *conn_ml.py* and *conn_hs.py*,
    into *conn_ml_hs.py*. Download the file from the book’s resources and save it
    in your chapter folder. [Listing 13-10](#listing13-10) shows the main differences.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 13-10: A voice-controlled Connect Four game using the machine-learning
    strategy'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: This works in the same way as the voice-controlled three-steps version. Run
    the script and play a game. You should find the game interesting but easier to
    beat than the three-steps strategy.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you created intelligent, voice-controlled graphical Connect
    Four games by using two methods: the think-three-steps-ahead strategy and the
    machine-learning strategy. This taught some important reasoning skills—how do
    we make a script intelligent?—as well as some basic machine-learning skills.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: You learned to generalize these two strategies and apply them to specific games.
    You can apply these skills to create your own intelligent voice-controlled games.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *conn_think1.py* so that the human player moves first and the computer
    moves second.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mesh together *ttt_click.py* from Chapter 10 and *conn_think1.py* to create
    a mouse-click version of the tic-tac-toe game in which the computer thinks one
    step ahead.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a mouse-click version of the tic-tac-toe game in which the computer thinks
    two steps ahead, based on *ttt_click.py* and *conn_think2.py*.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `best_move()`, defined in *conn_think.py*, if the list `winner` has eight
    elements `[7, 7, 4, 5, 6, 6, 6, 6]`, what’s the value of `cnt`, `maxcnt`, and
    `cnt[maxcnt]`, respectively?
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design a mouse-click version of the tic-tac-toe game in which the computer thinks
    three steps ahead, based on *ttt_click.py* and *conn_think.py*.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simulate a million tic-tac-toe games and save the game outcome and intermediate
    steps as *ttt_simulates.pickle*. Then create a mouse-click version of tic-tac-toe
    in which the computer uses the machine-learning strategy, similar to what we’ve
    done in *conn_simulation.py* and *conn_ml.py*.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *outcome_conn_think.py* and *outcome_conn_ml.py* to test the effectiveness
    of the three-steps strategy and the machine-learning strategy in the tic-tac-toe
    games you just created.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running *conn_simulation.py*, we printed out 10 observations from the
    dataset *conn_simulates.pickle*, as shown in [Listing 13-5](#listing13-5). The
    10th observation is `[-1, 1, 4, 1, 4, 1, 2, 4, 5, 6, 6, 6, 3]`. Who has won the
    10th game? Are the four discs connected vertically, horizontally, or diagonally?
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
