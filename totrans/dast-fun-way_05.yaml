- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Binary Search Trees
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Binary search trees* use the concepts underpinning the binary search algorithm
    to create a dynamic data structure. The key word here is *dynamic*. Unlike sorted
    arrays, binary search trees support the efficient addition and removal of elements
    in addition to searches, making them the perfect blend of the algorithmic efficiency
    of binary search and the adaptability of dynamic data structures. They also make
    for wonderful decorative mobiles for any room.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉搜索树*利用二分查找算法的基本概念，创建了一种动态数据结构。这里的关键字是*动态*。与排序数组不同，二叉搜索树不仅支持高效的查找，还支持元素的高效添加和删除，使它们成为二分查找算法效率与动态数据结构适应性的完美结合。它们还可以作为任何房间中美丽的装饰性移动物件。'
- en: In addition to introducing binary search trees, this chapter discusses algorithms
    for searching for values, adding new values, and deleting values. It shows how
    to use pointers to create branching structures more powerful than the list-based
    structures in previous chapters. You’ll learn how, by carefully structuring the
    relationships among the values, we can encode the approach used for binary search
    into the very structure of the data itself.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章除了介绍二叉搜索树外，还讨论了查找值、添加新值和删除值的算法。它展示了如何利用指针创建比前几章基于列表的结构更强大的分支结构。你将学习到，通过仔细构建值之间的关系，我们可以将二分查找的方法编码到数据的结构中。
- en: Binary Search Tree Structure
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树结构
- en: Trees are hierarchical data structures composed of branching chains of nodes.
    They are a natural extension of linked lists, where each tree node is permitted
    two `next` pointers that point to subsequent nodes in disjoint lists. [Figure
    5-1](#figure5-1) shows a sample binary search tree.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 树是由节点组成的分支链条的层次结构数据结构。它们是链表的自然扩展，每个树节点允许有两个`next`指针，指向分离链表中的后续节点。[图 5-1](#figure5-1)展示了一个示例二叉搜索树。
- en: '![A binary search tree with one circle representing a node (a value) pointing
    to two other nodes. Each of these nodes points to other nodes (other values).
    ](image_fi/502604c05/f05001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![一个二叉搜索树，图中有一个圆圈表示一个节点（一个值），指向另外两个节点。这些节点又指向其他节点（其他值）。](image_fi/502604c05/f05001.png)'
- en: 'Figure 5-1: An example binary search tree'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：一个示例二叉搜索树
- en: A node contains a value (of a given type) and up to two pointers to lower nodes
    in the tree, as shown in [Figure 5-2](#figure5-2). We call nodes with at least
    one child *internal nodes* and nodes without any children *leaf nodes*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点包含一个值（某种类型的值）和最多两个指向树中下层节点的指针，如[图 5-2](#figure5-2)所示。我们称至少有一个子节点的节点为*内部节点*，没有子节点的节点为*叶节点*。
- en: '![The components of a binary search tree node: a circle representing a value,
    a pointer to the left child, and a pointer to the right child](image_fi/502604c05/f05002.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![二叉搜索树节点的组成部分：一个圆圈表示一个值，一个指向左子节点的指针和一个指向右子节点的指针](image_fi/502604c05/f05002.png)'
- en: 'Figure 5-2: The required components of a binary search tree node'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：二叉搜索树节点的必要组成部分
- en: Tree nodes may contain other information, depending on their use. We often store
    a pointer back to the node’s parent, for instance. This single piece of additional
    information allows us to traverse the tree from the bottom up as well as from
    the top down, which comes in handy when we consider removing nodes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 树节点可能包含其他信息，具体取决于它们的用途。我们通常会存储一个指向节点父节点的指针。例如，这一额外的信息使得我们可以从树的底部向上遍历，也可以从顶部向下遍历，这在我们考虑删除节点时非常有用。
- en: 'Formally, we specify a *binary search tree node* as a data structure with this
    minimal information: a value (or key), pointers to two child nodes (either of
    which can be set to `null` if no corresponding child exists), and an optional
    pointer to the parent node.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，我们将*二叉搜索树节点*定义为具有以下最小信息的数据结构：一个值（或键），指向两个子节点的指针（如果没有相应的子节点，可以将其中一个指针设为`null`），以及一个指向父节点的可选指针。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We might also want to store auxiliary data. Storing and searching for individual
    values are useful, but using these values as keys for looking up more detailed
    information greatly extends the power of the data structure. For example, we could
    use the names of our favorite coffees as the node’s values, allowing us to efficiently
    look up records for any coffee. In this case, our auxiliary data would be a detailed
    record of everything we know about that coffee. Or our values could be timestamps,
    and the nodes could contain indications of which coffee we brewed at that time,
    allowing us to efficiently search our historical coffee consumption. The tree
    node data structure can either store this auxiliary data directly or include a
    pointer to a composite data structure located somewhere else in memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能希望存储辅助数据。存储和搜索单个值非常有用，但将这些值作为键来查找更详细的信息，大大增强了数据结构的功能。例如，我们可以将最喜欢的咖啡的名字作为节点的值，这样就可以高效地查找任何咖啡的记录。在这种情况下，我们的辅助数据将是关于那种咖啡的详细记录。或者，我们的值可以是时间戳，节点可以包含在那个时间点我们泡制了哪种咖啡的信息，从而让我们能够高效地查询我们的历史咖啡消费记录。树节点数据结构可以直接存储这些辅助数据，或者包含指向位于内存其他位置的复合数据结构的指针。
- en: Binary search trees start at a single *root* node at the top of the tree and
    branch into multiple paths as they descend, as shown in [Figure 5-3](#figure5-3).
    This structure allows programs to access the binary search tree through a single
    pointer—the location of its root node.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树从树顶的单一*根*节点开始，并在下降时分支成多个路径，如[图 5-3](#figure5-3)所示。这个结构允许程序通过一个单一的指针访问二叉搜索树——即根节点的位置。
- en: '![The binary search tree in Figure 5‐1, where the topmost node is marked “root
    node.”](image_fi/502604c05/f05003.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 5-1 中的二叉搜索树，最上面的节点标记为“根节点”。](image_fi/502604c05/f05003.png)'
- en: 'Figure 5-3: The root node indicates the top of the binary search tree and is
    the starting location for operations.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：根节点表示二叉搜索树的顶部，是操作的起始位置。
- en: Botanical purists may draw trees with the root node at the bottom of the tree
    and nodes branching upward, instead of starting from the top as in [Figure 5-3](#figure5-3).
    However, the representations are equivalent. In truth, both the top-down and bottom-up
    illustrations hide the actual complexity of the binary search tree. Like a linked
    list, a search tree’s individual nodes can be scattered throughout the computer’s
    memory. Each node is only linked to its children and parents through the power
    and flexibility of pointers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 植物学的纯粹主义者可能会将树画成根节点位于树的底部，节点向上分支，而不是像[图 5-3](#figure5-3)中那样从顶部开始。然而，这两种表示方式是等效的。实际上，无论是从上到下的图示，还是从下到上的图示，都隐藏了二叉搜索树的实际复杂性。就像链表一样，搜索树的各个节点可以分散存储在计算机的内存中。每个节点仅通过指针的强大功能和灵活性与其子节点和父节点连接。
- en: 'The power of the binary search tree stems from how values are organized within
    the tree. The *binary search tree property*states:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的强大功能来源于树中值的组织方式。*二叉搜索树的属性*规定：
- en: For any node *N*, the value of any node in *N*’s left subtree is less than *N*’s
    value, and the value of any node in *N*’s right subtree is greater than *N*’s
    value.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于任何节点*N*，*N*左子树中任何节点的值都小于*N*的值，而*N*右子树中任何节点的值都大于*N*的值。
- en: In other words, the tree is organized by the values at each node, as shown in
    [Figure 5-4](#figure5-4). The values of the data in the left node and all nodes
    below it are less than the value of the current node. Similarly, the values of
    the data in the right node and all nodes below it are greater than the value of
    the current node. The values thus serve two roles. First, and most obviously,
    they indicate the value stored at that node. Second, they define the tree’s structure
    below that node by partitioning the subtree into two subsets.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，树是根据每个节点的值来组织的，如[图 5-4](#figure5-4)所示。左节点及其以下所有节点的数据值都小于当前节点的值。同样，右节点及其以下所有节点的数据值都大于当前节点的值。因此，这些值有两个作用。首先，也是最明显的，它们表示存储在该节点的值。其次，它们通过将子树划分为两个子集来定义该节点以下的树结构。
- en: The above definition implicitly restricts the binary search tree to contain
    unique values. It is possible to define binary search trees that allow duplicate
    values by modifying the binary search tree property accordingly. Other references
    may vary in whether they allow duplicate values and thus how they handle equality
    in the binary search tree property. This chapter focuses on the case of non-duplicate
    values to stay consistent with other indexing data structures we will explore
    in the book, such as skiplists and hash tables, though the algorithms presented
    can be adapted to handle duplicates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义隐含地限制了二分查找树只能包含唯一值。通过相应地修改二分查找树的属性，也可以定义允许重复值的二分查找树。其他文献可能会有所不同，取决于它们是否允许重复值，以及如何处理二分查找树属性中的相等性。本章专注于不包含重复值的情况，以与我们将在本书中探索的其他索引数据结构保持一致，如跳表和哈希表，尽管所呈现的算法可以调整以处理重复值。
- en: '![A binary search tree where the root node has value 52\. Its left pointer
    points to a node with value 32, which is less than 52\. Its right pointer points
    to a node with value 70, which is greater than 52\. All subtrees are also organized
    according to the binary search tree property. ](image_fi/502604c05/f05004.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![一棵二分查找树，其中根节点的值为52\. 它的左指针指向一个值为32的节点，该值小于52\. 它的右指针指向一个值为70的节点，该值大于52\.
    所有子树也根据二分查找树属性进行组织。](image_fi/502604c05/f05004.png)'
- en: 'Figure 5-4: The values of the nodes in a binary search tree are ordered by
    the binary search tree property.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4：二分查找树中节点的值按照二分查找树的属性进行排序。
- en: We could compare a binary search tree’s structure to a public relations department
    that is organized by level of humor. Each employee measures their humor level
    with a single numerical value, the number of funny illustrations in a 30-minute
    presentation. A score of 0 represents the serious presenter who includes only
    technical diagrams. A score of 100 or above represents the aspiring comedian who
    adds multiple jokes to every slide. The entire department structures itself around
    this one metric. Internal nodes represent managers with either one or two direct
    reports. Each manager considers their own humor level and partitions their suborganization
    accordingly. Team members who include more jokes (a *larger* humor level) go in
    the right subteam. Those who include fewer jokes (a *smaller* humor level) go
    in the left subteam. Each manager thus provides both a partitioning function and
    a middle ground between the two subteams.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将二分查找树的结构与一个按幽默感级别组织的公共关系部门进行比较。每个员工通过一个单一的数值来衡量自己的幽默感级别，即在30分钟演示中的幽默插图数量。得分为0表示严肃的演讲者，只包括技术图表。得分为100或更高表示有抱负的喜剧演员，在每一张幻灯片上都加入多个笑话。整个部门围绕这个唯一的标准来组织。内部节点表示拥有一名或两名直接下属的经理。每个经理会根据自己的幽默感级别来划分他们的子团队。包含更多笑话的团队成员（*较高*的幽默感级别）进入右侧子团队。包含较少笑话的团队成员（*较低*的幽默感级别）进入左侧子团队。因此，每位经理既提供了一个分区功能，又在两个子团队之间提供了一个中间立场。
- en: Although this ordering of nodes might not seem like a lot of structure, keep
    in mind the amount of power we got from using a similar property within binary
    search. The binary search tree property is effectively keeping the data within
    the tree sorted with respect to its position in the tree. As we will see, this
    allows us to not only efficiently find values in the tree but also efficiently
    add and remove nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然节点的这种排序可能看起来没有太多结构，但请记住，通过使用类似的属性在二分查找中所获得的强大功能。二分查找树的属性实际上是保持树内的数据根据其在树中的位置进行排序。正如我们将看到的，这不仅允许我们高效地查找树中的值，还能高效地添加和删除节点。
- en: Searching Binary Search Trees
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索二分查找树
- en: We search a binary search tree by walking down from the root node. At each step,
    we determine whether to explore the left or right subtree by comparing the value
    at the current node with the target value. If the target value is less than the
    current value, the search progresses to the left. If the target value is greater
    than the current value, the search progresses to the right. The node’s value thus
    serves the same function as those helpful signs in hotels that tell us rooms 500–519
    are to the left and rooms 520–590 are to the right. With one quick check, we can
    make the appropriate turn and ignore the rooms in the other direction. The search
    ends when either the target value is found or it reaches a node with no children
    in the correct direction. In the latter case, we can definitively say that the
    target value is not in the tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从根节点开始向下遍历二叉搜索树来进行查找。在每一步中，我们通过将当前节点的值与目标值进行比较，来决定是探索左子树还是右子树。如果目标值小于当前值，搜索就会向左进行。如果目标值大于当前值，搜索就会向右进行。因此，节点的值就像酒店里那些有用的指示牌，告诉我们500-519号房间在左边，520-590号房间在右边。通过一次快速检查，我们可以做出适当的转弯，忽略另一个方向的房间。当找到目标值或者达到没有子节点的节点时，搜索结束。在后一种情况下，我们可以断定目标值不在树中。
- en: Iterative and Recursive Searches
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代和递归搜索
- en: We implement this search with either an iterative or recursive approach. The
    following code uses a recursive approach, where the search function calls itself
    using the next node in the tree, initially called on the root node of the tree.
    The code returns a pointer to the node containing the value, allowing us to retrieve
    any auxiliary information from the node.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过迭代或递归的方式实现该搜索。以下代码使用递归方法，其中搜索函数调用自身，传入树中的下一个节点，最初调用的是树的根节点。代码返回指向包含该值的节点的指针，从而允许我们从节点中检索任何辅助信息。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This algorithm performs only a few tests at each node; if any of the tests pass,
    we end the function by returning a value. First, the code checks that the `current`
    node is not `null`, which can happen when searching an empty tree. If it is `null`,
    the tree is empty and, by definition, does not contain the value of interest ❶.
    Second, if the current node’s value equals our target value, the code has found
    the value of interest and returns the node ❷. Third, the code checks whether it
    should explore the left subtree and, if so, returns whatever it finds from that
    exploration ❸. Fourth, the code checks whether it should explore the right subtree
    and, if so, return whatever it finds from that exploration ❹. Note that in both
    the left and right cases, the code also checks that the corresponding child exists.
    If none of the tests trigger, the code has made it to a node that doesn’t match
    our target value and does not have a child in the correct direction. It has reached
    a dead end and is forced to admit defeat by returning a failure value such as
    `null` ❺. A dead end occurs whenever there is no child in the correct direction,
    so it is possible for an internal node with a single child to still be a dead
    end for a search.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在每个节点只进行少量测试；如果任何测试通过，函数就返回一个值并结束。首先，代码检查`current`节点是否为`null`，这可能发生在搜索空树时。如果是`null`，则树为空，并且根据定义，不包含感兴趣的值❶。其次，如果当前节点的值等于我们的目标值，代码已经找到了感兴趣的值，并返回该节点❷。第三，代码检查是否需要探索左子树，如果需要，则返回从该探索中找到的任何内容❸。第四，代码检查是否需要探索右子树，如果需要，则返回从该探索中找到的任何内容❹。请注意，在左右两种情况下，代码还会检查对应的子节点是否存在。如果没有任何测试触发，代码就到达了一个与目标值不匹配的节点，并且在正确方向上没有子节点。它已经走到死胡同，必须通过返回失败值（如`null`）来承认失败❺。死胡同发生在没有正确方向子节点时，因此，即使是一个只有一个子节点的内部节点，在搜索中也可能是一个死胡同。
- en: 'Suppose we used this strategy to search [Figure 5-5](#figure5-5) for the value
    63\. We start at the root node and compare its value (50) to that of our target.
    Since 50 is less than 63, we know that the target value is not in the left-hand
    branch, where every node has a value less than 50\. This simple fact allows us
    to *prune* the entire left-hand subtree from our search. We can avoid checking
    11 of the 22 nodes in our tree with a single comparison. This test is effectively
    the same as the pruning we did within the binary search algorithm from Chapter
    2: we test a single element against our target value and use that to prune out
    a large section of our search space.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用这种策略在[图 5-5](#figure5-5)中查找值为63的节点。我们从根节点开始，并将其值（50）与目标值进行比较。由于50小于63，我们知道目标值不在左分支中，因为该分支的每个节点的值都小于50。这个简单的事实让我们能够*剪枝*掉整个左子树，从而避免检查树中22个节点中的11个节点。这个测试实际上与我们在第二章中的二叉搜索算法中的剪枝类似：我们通过将单个元素与目标值进行比较，使用这个测试来剪除搜索空间的大部分区域。
- en: '![A binary search tree whose root node has a value of 50\. The root node is
    shaded to indicate the search starts here. The first node on the left has a value
    of 23\. The first node on the right has a value of 67.](image_fi/502604c05/f05005.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![一个根节点值为50的二叉搜索树。根节点被阴影标示，表示搜索从这里开始。左边的第一个节点的值为23，右边的第一个节点的值为67。](image_fi/502604c05/f05005.png)'
- en: 'Figure 5-5: The first step in the search of a binary search tree. The search
    begins at the root node.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：二叉搜索树查找的第一步。搜索从根节点开始。
- en: Our search progresses down the right-hand subtree to the node with value 67,
    as shown in [Figure 5-6](#figure5-6). We again employ the binary search tree property
    to rule out half the remaining search space. In this case 63 is less than 67,
    so we choose the left subtree. Anything in node 67’s right-hand subtree must be
    larger than 67, and thus it cannot contain 63\. We’ve pruned another 5 nodes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索继续沿着右子树向下，直到值为67的节点，如[图 5-6](#figure5-6)所示。我们再次利用二叉搜索树的性质，排除掉剩余搜索空间的一半。在这种情况下，63小于67，因此我们选择左子树。67右子树中的任何内容都必须大于67，因此不能包含63。我们又剪枝了5个节点。
- en: '![The binary search tree in Figure 5‐5\. This time, the right node (value 67)
    directly below the root node (value 50) is highlighted. ](image_fi/502604c05/f05006.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 5-5 中的二叉搜索树。这一次，根节点（值为50）下方的右节点（值为67）被高亮显示。](image_fi/502604c05/f05006.png)'
- en: 'Figure 5-6: The second step in the search of a binary search tree'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：二叉搜索树查找的第二步
- en: At this point, we can make definitive statements about the remaining search
    space underneath the current node. Since we branched right at 50 and left at 67,
    we know that all nodes in the new subtree will have values greater than 50 and
    less than 67\. In fact, each time we take a right-hand branch, we’re tightening
    the lower bound of the remaining search space. Whenever we take a left-hand branch,
    we’re tightening the upper bound.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以对当前节点下方剩余的搜索空间做出明确的判断。由于我们在50处选择了右分支，在67处选择了左分支，我们知道新子树中的所有节点的值都大于50且小于67。实际上，每次选择右分支时，我们都在收紧剩余搜索空间的下界；而每次选择左分支时，我们都在收紧上界。
- en: The search continues down the tree, traversing each of the shaded nodes as shown
    in [Figure 5-7](#figure5-7). The search passes through 4 of the 22 nodes before
    finding the target value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续沿树向下遍历，每个阴影节点都被访问，如[图 5-7](#figure5-7)所示。在找到目标值之前，搜索经过了22个节点中的4个节点。
- en: '![The binary search tree in Figure 5‐5\. This time, the nodes 50, 67, 60, and
    63 are all highlighted, indicating we’ve found our target value, 63.](image_fi/502604c05/f05007.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 5-5 中的二叉搜索树。这一次，节点50、67、60和63都被高亮显示，表示我们已经找到了目标值63。](image_fi/502604c05/f05007.png)'
- en: 'Figure 5-7: The complete path of a search of a binary search tree for value
    63'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：二叉搜索树查找值为63的完整路径
- en: Consider this search in the context of the public relations department organized
    by humor metric. Suppose the department head needs to find a speaker for an informal
    presentation at an industry conference. After some consideration, they determine
    a humor level of 63 jokes per 30 minutes will be optimal for this audience. The
    department head (root node) considers their own humor level, realizes they are
    too serious, and therefore asks their right-hand report to find someone within
    the report’s organization. Everyone in the right-hand subtree is more comedic
    than the department head. That manager repeats the same steps of comparing their
    own humor level (67) with the target value and delegating to their appropriate
    report.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在幽默度量组织的公共关系部门中的搜索。假设部门主管需要为一个行业会议的非正式演讲寻找一位发言人。经过一些考虑，他们确定每30分钟63个笑话的幽默水平对于这个观众最为合适。部门主管（根节点）考虑自己的幽默水平，意识到自己太严肃，因此要求他们的得力助手在助手的组织中找到合适的人选。右侧子树中的每个人都比部门主管更有幽默感。那位经理重复相同的步骤，将自己的幽默水平（67）与目标值进行比较，并将任务委派给合适的下属。
- en: Of course, the search does not need to progress all the way down to a leaf node.
    As shown in [Figure 5-8](#figure5-8), the node in question might sit in the middle
    of the tree. If we search the same tree for the value of 14, we take two left
    branches and end at the appropriate internal node. The manager at this intermediate
    level perfectly fits our humor criterion and can give the talk. Thus, as we descend
    the tree, we need to check whether the current node is equal to our target value
    and terminate the search early if we find a match.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，搜索不需要一直进行到叶子节点。如图[5-8](#figure5-8)所示，相关节点可能位于树的中间。如果我们搜索相同的树以查找值14，我们会走两次左支路并最终到达合适的内部节点。这个中间层的经理完全符合我们的幽默标准，可以进行演讲。因此，在树的下降过程中，我们需要检查当前节点是否等于我们的目标值，并在找到匹配时提前终止搜索。
- en: '![The binary search tree in Figure 5‐5\. This time, the nodes 50, 23, and 14
    are all highlighted, indicating we’ve found our target value, 14\. Node 14 is
    an internal node with two children.](image_fi/502604c05/f05008.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 5-5 中的二叉搜索树。这次，节点50、23和14都被高亮显示，表示我们找到了目标值14。节点14是一个有两个子节点的内部节点。](image_fi/502604c05/f05008.png)'
- en: 'Figure 5-8: The search of a binary search tree can conclude at an internal
    node where the value matches our target value.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8：二叉搜索树的搜索可以在一个内部节点结束，其中该节点的值与我们的目标值匹配。
- en: The iterative approach to searching a binary search tree replaces the recursion
    with a `WHILE` loop that iterates down the tree. The search again starts at the
    tree’s root.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代方法搜索二叉搜索树，用`WHILE`循环代替递归，沿树向下迭代。搜索仍然从树的根开始。
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code starts by creating a local variable `current` to point to the current
    node in the search ❶. Initially, this will be the root node, which may be `null`
    in an empty tree. Then a `WHILE` loop keeps iterating down the tree until it either
    hits a dead end (`current == null`) or finds the correct value (`current.value
    == target`) ❷. Within the loop, the code checks whether the next child should
    be to the left or right ❸ and reassigns `current` to point to the corresponding
    child. The function concludes by returning `current`, which is either the found
    node or, if the tree is empty or the value is not found, `null` ❹.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一个本地变量`current`，用于指向当前的搜索节点❶。最初，这将是根节点，在空树中可能为`null`。然后，`WHILE`循环不断遍历树，直到它遇到死胡同（`current
    == null`）或找到正确的值（`current.value == target`）❷。在循环中，代码检查下一个子节点应为左侧还是右侧❸，并重新将`current`指向相应的子节点。函数最终返回`current`，它可能是找到的节点，或者如果树为空或未找到值，则返回`null`❹。
- en: The computational cost of both the recursive and iterative searches is proportional
    to the depth of the target value in the tree. We start at the top of the tree
    and proceed down a single path. The deeper the tree, the more comparisons we need
    to perform. Structuring the tree to minimize its depth thus increases search efficiency.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和迭代搜索的计算成本都与目标值在树中的深度成正比。我们从树的顶部开始，沿着单一路径向下。树越深，所需进行的比较就越多。因此，结构化树以最小化其深度从而提高搜索效率。
- en: Searching Trees vs. Searching Sorted Arrays
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树的搜索与有序数组的搜索
- en: The skeptical reader might protest, “Chapter 2 already taught us how to do an
    efficient search on sorted data. Binary search scales logarithmically with the
    size of the data. You had illustrations and everything. Why bother putting the
    data in a tree rather than a sorted array? Are we adding unnecessary complexity
    and overhead with all these pointers?”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 持怀疑态度的读者可能会抗议：“第二章已经教过我们如何在排序数据上进行高效搜索。二分查找随着数据量的增加按对数级别扩展。你们已经举过例子，为什么要把数据放在树结构里，而不是排序数组里？这样是不是增加了不必要的复杂性和开销，增加了所有这些指针？”
- en: These concerns are reasonable. However, it’s important to consider how the data
    structure and search will be used in a wider context. If our data is already in
    a sorted array and we want to search through it a single time, building a tree
    rather than simply performing a binary search does not help. In fact, building
    the tree itself is more expensive than a single linear scan. Similarly, if the
    data does not change, then sorting it once and using the sorted array may be preferable.
    We avoid the memory overhead of the tree structure itself. The tradeoffs change
    as our data becomes more dynamic.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些顾虑是合理的。然而，考虑数据结构和搜索如何在更广泛的上下文中使用是很重要的。如果我们的数据已经是一个排序过的数组，并且我们只需要进行一次搜索，那么构建一棵树而不是直接进行二分查找并不会带来帮助。实际上，构建树本身比进行一次线性扫描更为昂贵。同样，如果数据不发生变化，那么对数据进行一次排序并使用已排序的数组可能更为合适。这样可以避免树结构本身的内存开销。当数据变得更加动态时，权衡因素会发生变化。
- en: Imagine the case where employees join or leave the PR department. In addition
    to the normal paperwork, the department needs to update its data structure of
    humor levels. Each new employee represents an addition to the list of humor levels.
    Each departure represents a deletion. Instead of using the reporting hierarchy,
    the department could use the office assignments to sort employees by humor level.
    The least humorous person is in office 1 and the most humorous in office 100\.
    The manager can still efficiently search for the correct speaker. However, they
    now need to fix the office assignments with each new addition or departure. For
    a large department or a high number of changes, the overhead increases. In highly
    dynamic environments, such as a list of pending restaurant orders, the costs can
    become significant.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有员工加入或离开公关部门。除了正常的文书工作，部门还需要更新其幽默水平的数据结构。每个新员工代表幽默水平列表的新增项，每个离职代表删除项。部门可以通过使用办公室分配来根据幽默水平对员工进行排序，而不是使用汇报层级。幽默感最差的人在办公室1，幽默感最强的人在办公室100。经理仍然可以高效地搜索到正确的发言人。然而，他们现在需要在每次新增或离职时修正办公室分配。对于一个大型部门或高频次的变动，开销会增加。在高度动态的环境中，比如待处理的餐厅订单列表，成本可能会变得相当可观。
- en: The power of binary search trees, and dynamic data structures in general, arises
    in cases where the data is *changing*. As we will see in the next sections, binary
    search trees allow us to efficiently add and remove data points. In a sorted array,
    we would need to constantly update the array as we add and remove data, which
    can be expensive. In contrast, the binary search tree keeps the data in an easily
    searchable structure as the data itself changes. If we are doing many searches
    over a dynamic data set, this combination of efficiencies becomes critical.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树以及动态数据结构的强大之处，体现在数据*发生变化*的情况下。正如我们在接下来的章节中将看到的，二叉搜索树使得我们可以高效地添加和删除数据点。在一个排序过的数组中，每次添加或删除数据时，我们都需要不断更新数组，这会非常耗费资源。相反，二叉搜索树在数据本身发生变化时，能够保持数据处于一种易于搜索的结构。如果我们在一个动态数据集上进行大量的搜索，这种效率的结合就变得至关重要。
- en: Modifying Binary Search Trees
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改二叉搜索树
- en: The root node always deserves special care when using or modifying a binary
    search tree. When searching for a node in the tree, we always start at the root
    node. When inserting the first node into the tree, such as the first person joining
    our PR department, we make that node our new root. And, as we will see later in
    the chapter, when removing a node from a binary tree, we must treat the root node
    as a special case.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用或修改二叉搜索树时，根节点总是需要特别关注。当在树中搜索一个节点时，我们总是从根节点开始。当将第一个节点插入到树中时，比如第一个加入公关部门的人，我们将该节点作为新的根节点。正如我们将在本章稍后看到的，当从二叉树中删除一个节点时，我们必须把根节点当作特殊情况处理。
- en: 'We can simplify the logic for using binary search trees by wrapping the entire
    tree in a thin data structure that contains the root node:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将整个树结构封装在一个包含根节点的轻量级数据结构中，简化使用二叉搜索树的逻辑：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this might seem like a waste (more complexity and an extra data structure),
    it provides an easy-to-use interface for the tree and greatly simplifies our handling
    of the root node. When using a wrapper data structure (or class) for our binary
    search tree, we also need to provide top-level functions to add or find nodes.
    These are relatively thin wrappers with a special case for handling a tree without
    any nodes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能是浪费（更多的复杂性和额外的数据结构），但它为树提供了一个易于使用的接口，并大大简化了我们对根节点的处理。当使用包装数据结构（或类）来表示我们的二叉查找树时，我们还需要提供顶层函数来添加或查找节点。这些函数是相对简单的包装器，并且处理没有节点的树时有一个特殊情况。
- en: 'To search a tree, the code again starts by checking whether the tree is empty
    (`tree.root == null`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搜索树，代码再次从检查树是否为空（`tree.root == null`）开始：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the tree is empty, it immediately returns `null` to indicate the search failed
    to find a match. Otherwise, the code recursively searches the tree using `FindValue`.
    Performing the `null` check here can even take the place of the check at the start
    of `FindValue`, requiring us to perform it only once for the entire tree instead
    of at each node.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树为空，它会立即返回`null`，表示搜索未找到匹配项。否则，代码会使用`FindValue`递归搜索树。这里进行`null`检查甚至可以替代`FindValue`开始时的检查，从而只需对整个树进行一次检查，而不是每个节点都检查一次。
- en: Adding Nodes
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加节点
- en: 'We use the same basic algorithm to add values to a binary search tree as we
    do to search it. We start at the root node, progress down the tree as if searching
    for the new value, and terminate once we hit a dead end: either a leaf node or
    an internal node with a single child in the wrong direction. The primary difference
    between our search and insertion algorithms comes after we hit the dead end, when
    the insertion algorithm creates a new node as a child of the current node: a left-hand
    child if the new value is less than that of the current node or a right-hand child
    otherwise.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与搜索树时相同的基本算法来添加值。我们从根节点开始，像搜索新值一样向下遍历树，一旦遇到死胡同就终止：无论是叶节点还是具有单个子节点且方向错误的内部节点。我们搜索和插入算法的主要区别出现在遇到死胡同后，插入算法会在当前节点下创建一个新的子节点：如果新值小于当前节点的值，则创建一个左子节点，否则创建右子节点。
- en: Here we can see a clear difference in behavior between trees that allow duplicates
    and ones that do not. If our tree allows duplicate values, we keep going until
    we hit a dead end and then insert a new copy of that value into our tree. If the
    tree doesn’t allow duplicates, we might replace or augment the data stored at
    the matching node. For example, one simple piece of auxiliary data we could track
    is a counter—the number of times the value has been added to the tree. Below we
    focus on the case of overwriting data to stay consistent with other indexing data
    structures we will explore in the book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以清楚地看到允许重复值的树和不允许重复值的树在行为上的区别。如果我们的树允许重复值，我们会继续向下遍历直到遇到死胡同，然后在树中插入该值的一个新副本。如果树不允许重复值，我们可能会替换或扩展匹配节点中存储的数据。例如，我们可以跟踪的一个简单辅助数据是计数器——记录该值被添加到树中的次数。下面我们重点讨论覆盖数据的情况，以便与本书中将要探讨的其他索引数据结构保持一致。
- en: 'As with our search function, we start with a wrapper function for addition
    that handles the case of empty trees:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的搜索函数一样，我们从一个处理空树情况的添加包装函数开始：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the code checks whether the tree is empty (`tree.root == null`). If so,
    it creates a new root node with that value. Otherwise, it calls `InsertNode` on
    the root node, kicking off the recursive process from below. Thus, we can ensure
    that `InsertNode` is called with a valid (non-null) node.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查树是否为空（`tree.root == null`）。如果是，它会使用该值创建一个新的根节点。否则，它会在根节点上调用`InsertNode`，从下面开始启动递归过程。这样，我们可以确保`InsertNode`是在有效（非空）节点上调用的。
- en: 'Here is the `InsertNode` code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`InsertNode`的代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `InsertNode` code starts by checking whether it is at a node with a matching
    value and, if so, updating the node’s data as needed ❶. Otherwise, the code searches
    for the correct location to insert the new value by following either the left-
    or right-hand paths, based on the comparison of the new value and the current
    node’s value ❷. In either case, the code then checks that the next node along
    that path exists ❸ ❹. If the next node exists, the code follows the path, progressing
    deeper into the tree. Otherwise, the code has found a dead end, indicating the
    correct location to insert the new node. The algorithm inserts nodes by creating
    a new node, linking the parent’s corresponding child pointer (`left` or `right`),
    and setting the `parent` link.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertNode`代码首先检查是否遇到了一个值匹配的节点，如果是，则根据需要更新该节点的数据 ❶。否则，代码通过比较新值和当前节点值，按照左路径或右路径的方式搜索插入新值的正确位置
    ❷。在任何情况下，代码都会检查沿着路径的下一个节点是否存在 ❸ ❹。如果下一个节点存在，代码会沿着路径继续前进，深入树中。否则，代码找到了一个死胡同，表示可以插入新节点的正确位置。算法通过创建一个新节点，链接父节点的相应子指针（`left`或`right`），并设置`parent`链接来插入节点。'
- en: For example, if we want to add the number 77 to the binary search tree in [Figure
    5-9](#figure5-9), we progress down through nodes 50, 67, 81, and 78 until we hit
    a dead end at the node with value of 78\. At this point, we find ourselves without
    a valid child in the correct direction. Our search is at a dead end. We create
    a new node with the value of 77 and make it the node 78’s left child.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要将数字77添加到[图5-9](#figure5-9)中的二叉搜索树中，我们会沿着节点50、67、81和78向下移动，直到在值为78的节点处遇到死胡同。此时，我们发现在正确方向上没有有效的子节点。我们的搜索遇到死胡同。我们创建一个值为77的新节点，并将其设置为节点78的左子节点。
- en: '![The binary search tree in Figure 5‐5\. We want to insert value 77\. A series
    of left and right forks leads to a dead end below 78\. We insert the new node
    as a left‐hand child of 78\. ](image_fi/502604c05/f05009.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图5-5中的二叉搜索树。我们要插入值77。一系列的左右分叉导致在78下面遇到死胡同。我们将新节点插入为78的左子节点。](image_fi/502604c05/f05009.png)'
- en: 'Figure 5-9: Inserting the value 77 into our binary search tree'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-9：将值77插入到我们的二叉搜索树中
- en: The cost of inserting a new node into the tree is again proportional to the
    depth of the branch along which we insert the new node. We perform a single comparison
    for each node along the path until we hit a dead end, and, as with the search
    operation, we ignore all the nodes in other branches. Therefore, the worst-case
    cost of an insertion will scale linearly with the depth of the tree.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向树中插入新节点的成本再次与我们插入新节点的分支深度成正比。我们会在路径上每个节点进行一次比较，直到到达死胡同，像搜索操作一样，我们会忽略其他分支中的所有节点。因此，插入操作的最坏情况成本将与树的深度成线性关系。
- en: Removing Nodes
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除节点
- en: 'Removing nodes from a binary search tree is a more complicated process than
    adding them. There are three cases of node removal to consider: removing a leaf
    node (with no children), removing an internal node with a single child, and removing
    an internal node with two children. As you’d expect, the job becomes more complex
    as the number of children increases.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从二叉搜索树中删除节点比添加节点更复杂。删除节点有三种情况需要考虑：删除叶子节点（没有子节点）、删除一个只有一个子节点的内部节点、删除一个有两个子节点的内部节点。正如你所预期的，随着子节点数量的增加，任务变得更加复杂。
- en: To remove a leaf node, we just delete that node and update its parent’s child
    pointer to reflect the fact it no longer exists. This might make the parent node
    into a leaf. For example, to remove node 58 in [Figure 5-10](#figure5-10), we
    would just delete node 58 and set its parent’s left child pointer to `null`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除叶子节点，我们只需删除该节点，并更新其父节点的子指针，以反映该节点不再存在的事实。这可能会使父节点变成叶子节点。例如，要删除[图5-10](#figure5-10)中的节点58，我们只需删除节点58，并将其父节点的左子指针设置为`null`。
- en: '![The binary search tree in Figure 5‐5\. The deleted leaf node with value 55
    is crossed out. The pointer from its parent is also crossed out. ](image_fi/502604c05/f05010.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图5-5中的二叉搜索树。被删除的叶子节点值为55，被划去。来自其父节点的指针也被划去。](image_fi/502604c05/f05010.png)'
- en: 'Figure 5-10: Remove a leaf node from a binary search tree by deleting it and
    updating the pointer from its parent node.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-10：通过删除叶子节点并更新其父节点的指针，来从二叉搜索树中移除叶子节点。
- en: 'Removing leaf nodes shows the value of storing a pointer to the parent node:
    it allows us to search for the node to delete, follow the parent pointer back
    to that node’s parent, and set the corresponding child pointer to `null`. Storing
    this single piece of additional data makes the deletion operation much simpler.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 删除叶节点展示了存储父节点指针的价值：它使我们能够查找要删除的节点，沿父指针回溯到该节点的父节点，并将相应的子指针设置为 `null`。存储这一个额外的数据，使得删除操作变得更简单。
- en: In the example of our public relations department, a leaf node that gets deleted
    corresponds to an employee with no direct reports leaving the company. After the
    farewell party and cake, the rest of the organization returns to work. The only
    change in the hierarchy is that the former employee’s boss has one less person
    on their team. In fact, they might have no one reporting to them now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们公关部门的示例中，被删除的叶节点对应的是一位没有直接下属的员工离职。告别派对和蛋糕过后，组织的其余部分继续工作。层级结构唯一的变化是，前员工的上司少了一个团队成员。实际上，他们现在可能没有下属了。
- en: If the target node has a single child, we remove it by promoting that single
    child to be the child of the deleted node’s parent. This is like removing a manager
    from our reporting hierarchy without shuffling anyone else around. When the manager
    leaves, their boss assumes management of the former employee’s single direct report.
    For example, if we wanted to remove node 17 from our example tree, we could simply
    shift node 21 up to take its place as shown in [Figure 5-11](#figure5-11). Node
    14 now links directly to node 21.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标节点有一个子节点，我们通过将该唯一子节点提升为被删除节点父节点的子节点来移除它。这就像是从我们的汇报层级中移除一位经理而不调整其他人。当经理离开时，他们的上司接管了该前员工的唯一直接下属。例如，如果我们想从示例树中删除节点
    17，我们可以简单地将节点 21 上移，取而代之，如图 [5-11](#figure5-11) 所示。现在，节点 14 直接连接到节点 21。
- en: '![Two diagrams of the binary search tree from Figure 5‐5\. On the left, node
    17 is crossed out and node 14 points directly to 21\. On the right, node 21 is
    moved up into the position previously occupied by node 17.](image_fi/502604c05/f05011b.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 5-5 中二叉搜索树的两个示意图。左侧，节点 17 被删除，节点 14 直接指向 21。右侧，节点 21 被上移到原本属于节点 17 的位置。](image_fi/502604c05/f05011b.png)'
- en: 'Figure 5-11: Remove an internal node with a single child by changing the pointers
    (left) and shifting that child up (right).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11：通过改变指针（左侧）并将该子节点上移（右侧）来删除具有单个子节点的内部节点。
- en: This way of removing a single-child node works even if the node we are shifting
    up has its own subtree. Since the node being moved up was already in the parent’s
    subtree, all of its descendants will continue to respect the binary search tree
    property.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种删除单子节点的方式即使我们上移的节点本身有子树也有效。由于被上移的节点已经在父节点的子树中，它的所有后代将继续遵循二叉搜索树的特性。
- en: The complexity ramps up substantially when we try to remove an internal node
    with two children. It is no longer sufficient to just delete the node or shift
    a single child up. In our public relations department, a node’s two children represent
    two distinct employees with different humor levels. We can’t just choose one to
    promote and let the other accidentally disappear from the hierarchy, no longer
    anchored to the root node through the fragile chain of pointers. We must preserve
    the integrity of the rest of the tree and ensure it continues to follow the binary
    search tree property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试删除具有两个子节点的内部节点时，复杂性显著增加。单纯删除节点或将一个子节点上移已经不够了。在我们公关部门，一个节点的两个子节点代表了两个性格迥异、幽默感不同的员工。我们不能只是选择一个子节点进行提升，而让另一个不小心从层级中消失，失去通过脆弱的指针链条与根节点的连接。我们必须保持树的完整性，并确保它继续遵循二叉搜索树的特性。
- en: To remove a node with two children, we swap that node out for another node in
    the tree that will preserve the binary search tree property. We do this by finding
    the *successor* of the node to be deleted—the next node we would encounter if
    we traversed the nodes in sorted order. We swap the successor into the location
    of the deleted node. This swapped node might also have a child node that needs
    to be handled when it is removed from its old location. In order to remove the
    successor node from the binary tree without breaking any of its pointers, we reuse
    the delete procedure on the node to be swapped. We find the successor, save a
    pointer to that node, and then remove it from the tree.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个有两个子节点的节点，我们用树中的另一个节点替换该节点，以保持二叉搜索树的性质。我们通过找到要删除节点的*后继*来做到这一点——这是我们按排序顺序遍历节点时会遇到的下一个节点。我们将后继节点交换到删除节点的位置。这个交换的节点可能也有一个子节点，当它从原位置移除时需要处理。为了在不破坏任何指针的情况下从二叉树中移除后继节点，我们对要交换的节点重新使用删除程序。我们找到后继节点，保存指向该节点的指针，然后将其从树中移除。
- en: For example, if we wanted to delete value 81 in [Figure 5-12](#figure5-12),
    we need to first swap in the node with a value of 91\. We do this by saving pointers
    to the node to delete and the successor node ([Figure 5-12](#figure5-12)(1)).
    Then we set the successor node to be the child of the deleted node’s parent ([Figure
    5-12](#figure5-12)(2)). Finally, we update the successor node’s children to those
    of the recently deleted node, effectively swapping it into place ([Figure 5-12](#figure5-12)(3)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想删除[图 5-12](#figure5-12)中的值 81，我们需要首先交换值为 91 的节点。我们通过保存指向要删除节点和后继节点的指针来做到这一点（见[图
    5-12](#figure5-12)(1)）。然后，我们将后继节点设置为被删除节点父节点的子节点（见[图 5-12](#figure5-12)(2)）。最后，我们将后继节点的子节点更新为被删除节点的子节点，实际上就是将其交换到该位置（见[图
    5-12](#figure5-12)(3)）。
- en: In order to perform the deletion, we need to be able to efficiently find a node’s
    successor. While this might seem like a daunting task, we have one critical advantage.
    Since we are only considering cases where the node in question has two children,
    we can always find the successor in the node’s right-hand subtree. Specifically,
    the successor will be the minimum (or leftmost) node in the right-hand subtree.
    As a bonus, the successor node is guaranteed to have at most one (right-hand)
    child. If the candidate successor node had a child to the left, then that child
    (or a node down its own left-hand subtree) would be the true successor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行删除操作，我们需要能够高效地找到节点的后继。虽然这看起来是一个艰巨的任务，但我们有一个关键的优势。由于我们只考虑节点有两个子节点的情况，我们始终可以在节点的右子树中找到后继节点。具体来说，后继节点是右子树中最小的（或最左边的）节点。作为额外好处，后继节点保证最多只有一个（右侧）子节点。如果候选后继节点有一个左子节点，那么这个左子节点（或其左子树中的某个节点）才是实际的后继。
- en: '![Three diagrams of the binary search tree from Figure 5‐5 showing the process
    of removing the node with value 81, which is an internal node with two children.
    The node 81 has a parent 67 and pointers to children 78 and 92\. The pointer from
    67 is changed to point at 91\. Then 91 is given the pointers to children 78 and
    92\. ](image_fi/502604c05/f05012.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![三张二叉搜索树的示意图，来自图 5-5，展示了删除值为 81 的节点的过程，81 是一个有两个子节点的内部节点。节点 81 有父节点 67 和指向子节点
    78 和 92 的指针。67 的指针被改为指向 91。然后，91 被赋予指向子节点 78 和 92 的指针。](image_fi/502604c05/f05012.png)'
- en: 'Figure 5-12: To remove an internal node with two children, we first swap the
    node’s successor into that position.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-12：为了移除一个有两个子节点的内部节点，我们首先将节点的后继交换到该位置。
- en: '[Listing 5-1](#listing5-1) provides (admittedly verbose) pseudocode to demonstrate
    removing the three types of nodes we’ve just discussed from a binary search tree.
    Shorter implementations are possible. However, breaking the cases out explicitly
    helps to illustrate the complexities involved. Also note that we delete a node
    using its pointer instead of its value. Thus, in order to delete the node with
    a given value, we would first find a pointer to the node using `FindTreeNode`
    and then call delete with that pointer.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-1](#listing5-1) 提供了（虽然冗长）伪代码，演示了如何从二叉搜索树中删除我们刚刚讨论的三种类型的节点。也可以实现更简短的代码。然而，明确地分解这些情况有助于展示其中的复杂性。还需要注意的是，我们通过节点的指针而不是值来删除节点。因此，为了删除具有给定值的节点，我们首先使用
    `FindTreeNode` 查找该节点的指针，然后用该指针调用删除操作。'
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-1: Removal of a node from a binary search tree'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-1：从二叉搜索树中移除一个节点
- en: 'As with the wrapper functions for insertion and search, the code starts by
    checking whether the tree is empty ❶ and, if so, returning `null`. It also checks
    whether there is a valid node to delete (`node != null`), which is useful in cases
    where we want to combine the search and deletion into a single line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入和查找的包装函数一样，代码首先检查树是否为空 ❶，如果是，则返回`null`。它还检查是否有有效的节点可以删除（`node != null`），这在我们希望将查找和删除合并成一行时非常有用：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since `FindTreeNode` returns `null` if the node is not found, we handle this
    case explicitly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `FindTreeNode` 在找不到节点时返回 `null`，我们显式地处理此情况。
- en: The code then considers the three cases in order. In case A, where it is removing
    a leaf node ❷, the code only needs to change the correct child pointer of the
    removed node’s parent. First, it checks whether the node to be deleted has a parent
    node. If not, the code is removing the root itself and modifies the root node
    pointer to `null`, effectively removing the root. If the removed node was the
    parent’s left-hand child, the code sets that pointer to `null`. Likewise, if the
    removed node was the parent’s right-hand child, the code sets that pointer to
    `null`. The code can then return, having successfully removed the target leaf
    node from the tree.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码按顺序考虑三种情况。在 A 情况下，当移除的是叶子节点 ❷ 时，代码只需要更改被删除节点父节点的正确子指针。首先，代码检查要删除的节点是否有父节点。如果没有，代码正在删除根节点本身，并将根节点指针修改为
    `null`，从而有效地删除根节点。如果删除的节点是父节点的左子节点，代码将该指针设置为 `null`。同样，如果删除的节点是父节点的右子节点，代码也会将该指针设置为
    `null`。然后，代码可以返回，成功地将目标叶子节点从树中删除。
- en: In case B, removing a node with a single child ❸, the code starts by identifying
    which of the node’s two child pointers links to the child by checking which of
    the two pointers is not `null` ❹. The code stores a pointer to that child node
    for later use. Next, it fixes the pointers between the newly promoted node and
    its new parent ❺. The code sets the child’s parent pointer to its previous grandparent,
    splicing the removed node out of the tree in the upward direction. Finally, the
    code fixes the correct child pointer within the removed node’s parent, including
    handling changes to the root node as a special case. The code takes the pointer
    that previously pointed to the removed node and redirects it to point to that
    node’s single child. If the removed node doesn’t have a parent, the code is dealing
    with the root node and needs to modify that pointer accordingly. Once the code
    has spliced out the correct node, it returns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 B 情况下，删除一个只有一个子节点的节点 ❸，代码首先通过检查哪个子指针不是 `null` ❹ 来确定节点的哪个子指针指向该子节点。代码存储该子节点的指针以供后续使用。接下来，它修复新晋升节点与其新父节点之间的指针
    ❺。代码将子节点的父指针设置为其之前的祖父节点，将被删除的节点从树中剪接出去，向上修复。最后，代码修复被删除节点父节点中的正确子指针，包括处理根节点变化的特殊情况。代码将先前指向被删除节点的指针重定向，指向该节点的唯一子节点。如果被删除的节点没有父节点，说明正在处理根节点，需要相应地修改指针。一旦代码完成了正确节点的剪接，它便返回。
- en: 'In case C, where the node to be removed has two children, the code starts by
    identifying the successor node and removing that from the tree ❻. Note that, as
    described above, the recursive call to `RemoveTreeNode` cannot itself trigger
    case C because the successor will have at most a single (right-hand) child. The
    code maintains a pointer to this successor even after removing it from the tree
    because it will use this node to replace the deleted node. The code then replaces
    the deleted node with the successor through the following series of steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 情况下，当要删除的节点有两个子节点时，代码首先确定后继节点，并将其从树中移除 ❻。请注意，如上所述，递归调用 `RemoveTreeNode`
    本身无法触发 C 情况，因为后继节点最多只有一个（右子）节点。即使在将后继节点从树中移除后，代码仍会保持对该后继节点的指针，因为它将使用该节点替换被删除的节点。接下来，代码通过以下一系列步骤将被删除的节点替换为后继节点：
- en: Modifying the deleted node’s parent to set the correct child pointer to the
    successor ❼.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改被删除节点的父节点，将正确的子指针指向后继节点 ❼。
- en: Modifying the successor’s parent pointer to point to its new parent ❽.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改后继节点的父指针，使其指向新的父节点 ❽。
- en: Setting the links to and from the left and right children of the successor ❾.
    The code takes extra care when dealing with the right child, as it is possible
    that it has already deleted that child with the `RemoveTreeNode` operation above
    (in the case where the successor was the immediate right child of `node`). It
    therefore needs to check whether the right-hand child is `null` before trying
    to assign the right child’s parent pointer.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置继承节点的左右子节点的链接❾。处理右子节点时，代码需要额外小心，因为它有可能已经通过上面的`RemoveTreeNode`操作删除了该子节点（当继承节点是`node`的直接右子节点时）。因此，在尝试分配右子节点的父指针之前，它需要检查右子节点是否为`null`。
- en: 'Depending on the programming language and how the code will be used, we might
    also want to set `node`’s outgoing pointers to `null` as part of the deletion.
    This will clean up references from the deleted node to other nodes in the tree.
    We can do this by including the following lines at the end of each of the three
    cases (before the `return` statements in cases A and B and before the end of the
    function for case C):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编程语言及代码的使用方式，我们也可能希望在删除过程中将`node`的出边指针设置为`null`。这样可以清理从已删除节点到树中其他节点的引用。我们可以通过在每个三种情况的末尾（在A和B情况中的`return`语句之前，以及C情况中的函数结束之前）添加以下几行代码来实现：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with both search and insertion, the deletion operation involves at most traversing
    the tree from top to bottom along one path. In cases A and B, this trip happens
    before the `RemoveTreeNode` function (as part of the earlier call to `FindTreeNode`
    to get the pointer to the node itself). Case C adds an additional traversal from
    the internal node to be removed to its successor. Thus, the worst-case runtime
    of deletion is still proportional to the depth of the tree.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与搜索和插入一样，删除操作最多需要沿一条路径从上到下遍历树。在A和B情况下，这一遍历发生在`RemoveTreeNode`函数之前（作为之前调用`FindTreeNode`获取节点指针的一部分）。C情况则增加了从内部节点到其继承节点的额外遍历。因此，删除操作的最坏运行时间仍然与树的深度成正比。
- en: The Danger of Unbalanced Trees
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不平衡树的危险
- en: The time it takes to perform searches, additions, and deletions on a *perfectly
    balanced* binary search tree is, in the worst case, proportional to the depth
    of the tree, making these operations highly efficient in trees that are not too
    deep*.* A perfectly balanced tree is one in which, at every node, the right subtree
    contains the same number of nodes as the left subtree. In this case, the depth
    of the tree grows by 1 each time we double the number of nodes in the tree. Thus,
    in balanced trees, the worst-case performance of all three operations grows proportionally
    to log[2](*N*), the logarithm of the number of elements *N*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*完全平衡*的二叉搜索树上进行搜索、添加和删除操作的时间，在最坏情况下与树的深度成正比，这使得这些操作在树的深度不过大的情况下非常高效。完全平衡的树是指在每个节点处，右子树和左子树的节点数相等。在这种情况下，每次我们将树中的节点数加倍，树的深度都会增加1。因此，在平衡树中，所有三种操作的最坏性能都与log[2](*N*)成正比，其中*N*是元素数量的对数。
- en: Binary search trees are still efficient as long as the trees are mostly, if
    not perfectly, balanced. But if the tree becomes highly unbalanced, its depth
    could grow linearly with the number of elements. In fact, in the extreme case,
    our splendid binary search tree becomes nothing more than a sorted linked list—all
    the nodes have a single child in the same direction as shown in [Figure 5-13](#figure5-13).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树在树形大致平衡时仍然高效，即使不完全平衡。但如果树变得极度不平衡，树的深度可能会随元素数量线性增长。实际上，在极端情况下，我们的优秀二叉搜索树变成了一个排序链表——所有节点都有一个子节点，并且方向相同，如[图5-13](#figure5-13)所示。
- en: '![An unbalanced binary search tree in which each node has only a single right‐hand
    pointer to a single child](image_fi/502604c05/f05013.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![一个不平衡的二叉搜索树，其中每个节点只有一个指向单一子节点的右指针](image_fi/502604c05/f05013.png)'
- en: 'Figure 5-13: An example of an unbalanced binary search tree'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-13：一个不平衡的二叉搜索树示例
- en: Highly unbalanced trees can easily occur in many real-world applications. Imagine
    we are storing our coffee log in a binary search tree indexed by timestamp. Every
    time we drink a cup of coffee, we insert the relevant information into our tree.
    Things go bad quickly. Due to the monotonically increasing timestamps, we insert
    every entry in sorted order, and we create a linked list using only the right-hand
    child pointers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多现实世界的应用中，很容易出现高度不平衡的树。假设我们正在将咖啡日志存储在一个按时间戳索引的二叉搜索树中。每次喝一杯咖啡时，我们就将相关信息插入到树中。事情很快就变得糟糕。由于时间戳是单调递增的，我们按排序顺序插入每一条记录，结果仅使用右子节点指针创建了一个链表。
- en: Operations on an unbalanced tree can be extremely inefficient. Consider a tree
    with *N* nodes. If our tree is balanced, our operations take time logarithmic
    in *N*. In the opposite case, where our tree is a list, our operations can take
    time linearly proportional to *N*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个不平衡的树，操作可能会非常低效。考虑一个包含*N*个节点的树。如果我们的树是平衡的，那么操作的时间复杂度是*N*的对数级别。相反，在树变成链表的情况下，操作的时间复杂度将是与*N*成线性关系。
- en: There are a variety of augmentations, such as red-black trees, 2-3 trees, and
    B-trees, that we can use to keep trees balanced while undergoing dynamic insertions
    and deletions. The tradeoff for any of these approaches is increased complexity
    in the tree operations. We consider B-trees in more detail in Chapter 12 and show
    how their structure keeps them balanced.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种增强技术，如红黑树、2-3树和B树，来保持树在动态插入和删除过程中保持平衡。这些方法的权衡是树操作的复杂性增加。我们将在第12章中详细讨论B树，并展示它们的结构如何保持树的平衡。
- en: The next section introduces a straightforward approach to building a balanced
    binary search tree from an initial set of values. *Bulk construction* allows the
    algorithm to choose which nodes split the data so as to balance the number of
    nodes on each side. This is a good approach when we have many of the values up
    front but need to be careful with future insertions, as they could result in an
    unbalanced tree.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了一种直接的构建平衡二叉搜索树的方法，利用*批量构建*，允许算法选择哪些节点来分割数据，以平衡每一侧的节点数。当我们手头有许多值，但需要小心未来的插入时，这是一个不错的选择，因为插入可能会导致树的不平衡。
- en: Bulk Construction of Binary Search Trees
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树的批量构建
- en: 'We can easily construct a binary search tree by iteratively adding nodes: we
    create a single new node and label that our root, then for each remaining value,
    create a new node and add that node to the tree. This approach has the advantages
    of being simple and reusing the algorithms that we defined previously. Unfortunately,
    it can lead to unbalanced trees. As we saw above, if we add values in sorted order,
    we end up with a sorted linked list. We can do better when creating a tree from
    an initial set of numbers.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过迭代地添加节点轻松构建一个二叉搜索树：首先创建一个新的节点并将其标记为根节点，然后对于每个剩余的值，创建一个新节点并将其添加到树中。这种方法的优点是简单并且复用了我们之前定义的算法。不幸的是，这种方法可能会导致树的不平衡。正如我们之前看到的，如果我们按排序顺序添加值，最终会得到一个排序好的链表。我们可以在从初始的数字集创建树时做得更好。
- en: We create balanced binary search trees from a sorted array, such as the one
    shown in [Figure 5-14](#figure5-14), by recursively dividing the elements into
    smaller subsets. At each level, we choose the middle value to be the node at that
    level. If there is an even number of elements, we can use either of the two middle
    elements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过递归地将元素分割成更小的子集，从排序数组（如[图 5-14](#figure5-14)所示）中创建平衡的二叉搜索树。在每一层，我们选择中间值作为该层的节点。如果元素个数为偶数，我们可以选择两个中间元素中的任意一个。
- en: '![A sorted array with values from 1 to 12](image_fi/502604c05/f05014.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含从1到12的值的排序数组](image_fi/502604c05/f05014.png)'
- en: 'Figure 5-14: A sorted array used for bulk construction of a binary search tree'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-14：用于批量构建二叉搜索树的排序数组
- en: We create a new node with the value equal to the middle element in our array
    and split the remaining elements among the two child nodes, as shown in [Figure
    5-15](#figure5-15). We recursively create subtrees for each of those child nodes
    using the same process. Values less than the middle element go on the left, while
    larger values go on the right.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新节点，节点的值等于数组中的中间元素，并将剩余的元素分配到两个子节点中，如[图 5-15](#figure5-15)所示。我们使用相同的过程为每个子节点递归地创建子树。小于中间元素的值放到左侧，而较大的值放到右侧。
- en: '![The sorted array from Figure 5‐14 is split into two sections. A root node
    with value 7 points left to an array with values 1 through 6 and points right
    to an array with values 8 through 12\. ](image_fi/502604c05/f05015.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图5-14中的排序数组被拆分为两个部分。根节点值为7，指向一个包含值1至6的数组，并指向一个包含值8至12的数组。](image_fi/502604c05/f05015.png)'
- en: 'Figure 5-15: After the first split, we have a single node and two separate
    arrays.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-15：第一次拆分后，我们有一个单一的节点和两个独立的数组。
- en: 'We don’t need to create new copies of the input array at each split. Instead,
    we can take a page from the binary search algorithm and just track the current
    range of the array under consideration, as shown in [Figure 5-16](#figure5-16).
    Each of our splits partitions the array into coherent halves, so we only need
    to worry about two bounds: the indices of the highest and lowest values that fall
    into the current branch.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在每次拆分时创建输入数组的新副本。相反，我们可以借鉴二叉搜索算法的思路，只需跟踪当前考虑中的数组范围，如[图5-16](#figure5-16)所示。每次拆分将数组分成一致的两半，因此我们只需关注两个边界：当前分支中最高和最低值的索引。
- en: '![The array from Figure 5‐15, with boxes 7 through 12 grayed out. Box 1 is
    marked Low, and box 6 is marked High, indicating the bounds of the left‐hand array.
    ](image_fi/502604c05/f05016.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图5-15中的数组，其中第7到12框被灰色标记。框1标记为低（Low），框6标记为高（High），表示左侧数组的范围。](image_fi/502604c05/f05016.png)'
- en: 'Figure 5-16: A high and low index can be used to track the subset of the array
    currently under consideration.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-16：可以使用高低索引来跟踪当前考虑中的数组子集。
- en: Once we’ve created the new node, we use the same approach to build each of the
    left and right subtrees independently. Specifically, we select the middle value,
    create a new node from that value, partition the remaining ranges, and use those
    ranges to create the subtrees. The process ends when there is only a single value
    left in our range. In that case, we create a new leaf node with that value and
    no children.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了新节点，就可以使用相同的方法独立构建左右子树。具体来说，我们选择中间值，从该值创建一个新节点，划分剩余的范围，并利用这些范围来创建子树。当我们的范围中只剩下一个值时，过程结束。在这种情况下，我们创建一个包含该值且没有子节点的新叶节点。
- en: Why This Matters
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: Binary search trees demonstrate how we can adapt dynamic data structures to
    specific problems. The trees use a branching structure to capture and maintain
    ordering information in the data values. This allows them to facilitate efficient
    searches. Further, the pointer-based structure of binary search trees allows them
    to continuously adapt as new data is added. This interplay of data, problem, and
    computation provides the foundation that allows us to solve increasingly complex
    computational challenges.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树展示了我们如何将动态数据结构适应特定问题。这些树使用分支结构来捕捉并维护数据值中的顺序信息，从而实现高效搜索。此外，二叉搜索树的基于指针的结构使其能够在新数据被添加时持续适应。这种数据、问题和计算的相互作用为我们解决越来越复杂的计算挑战提供了基础。
- en: Throughout later chapters, we will continue to build on the concepts of dynamic
    data structures, adapting the structure of the data to the problem itself and
    using branching data structures to allow efficient pruning. These techniques pop
    up in a range of different data structures. Understanding the fundamentals, such
    as how these techniques allow efficient searches in dynamic binary search trees,
    is critical to understanding how to work with more advanced data structures and
    algorithms. The next chapter introduces the trie, showing how the tree-based concepts
    of the binary search tree can be extended to multiway branches in order to improve
    the efficiency of certain types of searches.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将继续构建动态数据结构的概念，将数据结构根据问题本身进行适配，并使用分支数据结构来实现高效的剪枝。这些技术出现在多种不同的数据结构中。理解这些基础知识，特别是这些技术如何在动态二叉搜索树中实现高效搜索，对于理解如何处理更复杂的数据结构和算法至关重要。下一章将介绍字典树（trie），展示如何将二叉搜索树的基于树的概念扩展到多叉分支，以提高某些类型搜索的效率。
