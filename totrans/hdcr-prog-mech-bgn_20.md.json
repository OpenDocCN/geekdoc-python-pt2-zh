["```py\nimport operator\nfrom functools import reduce\n\nfrom geom2d import Point, Vector\n\nclass StrNode:\n\n    def __init__(\n        self,\n     ➊ _id: int,\n        position: Point,\n        loads=None,\n        dx_constrained=False,\n        dy_constrained=False\n    ):\n        self.id = _id\n        self.position = position\n     ➋ self.loads = loads or []\n        self.dx_constrained = dx_constrained\n        self.dy_constrained = dy_constrained\n\n    @property\n    def loads_count(self):\n        return len(self.loads)\n\n    @property\n    def net_load(self):\n     ➌ return reduce(\n            operator.add,\n            self.loads,\n            Vector(0, 0)\n        )\n```", "```py\nself.loads = loads or []\n```", "```py\n>>> 'Hello' or 'Good bye'\n'Hello'\n\n>>> None or 'Good bye'\n'Good bye'\n\n>>> False or True\nTrue\n\n>>> False or 'Hello'\n'Hello'\n\n>>> False or None\n# nothing returned here\n\n>>> False or None or 'Hi'\n'Hi'\n```", "```py\nTypeError: reduce() of empty sequence with no initial value\n```", "```py\nclass StrNode:\n   --snip--\n\n   def add_load(self, load: Vector):\n       self.loads.append(load)\n```", "```py\nclass StrNode:\n   --snip--\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, StrNode):\n            return False\n\n        return self.position == other.position\n```", "```py\nimport operator\nfrom functools import reduce\n\nfrom geom2d import Point, Vector\n\nclass StrNode:\n\n    def __init__(\n            self,\n            _id: int,\n            position: Point,\n            loads=None,\n            dx_constrained=False,\n            dy_constrained=False\n    ):\n        self.id = _id\n        self.position = position\n        self.loads = loads or []\n        self.dx_constrained = dx_constrained\n        self.dy_constrained = dy_constrained\n\n    @property\n    def loads_count(self):\n        return len(self.loads)\n\n    @property\n    def net_load(self):\n        return reduce(\n            operator.add,\n            self.loads,\n            Vector(0, 0)\n        )\n\n    def add_load(self, load: Vector):\n        self.loads.append(load)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, StrNode):\n            return False\n\n        return self.position == other.position\n```", "```py\nfrom geom2d import Segment\nfrom .node import StrNode\n\nclass StrBar:\n\n    def __init__(\n            self,\n            _id: int,\n            start_node: StrNode,\n            end_node: StrNode,\n            cross_section: float,\n            young_mod: float\n    ):\n        self.id = _id\n        self.start_node = start_node\n        self.end_node = end_node\n        self.cross_section = cross_section\n        self.young_mod = young_mod\n\n    @property\n    def geometry(self):\n        return Segment(\n            self.start_node.position,\n            self.end_node.position\n        )\n\n    @property\n    def length(self):\n        return self.geometry.length\n```", "```py\nfrom eqs import Matrix\nfrom geom2d import Segment\nfrom .node import StrNode\n\nclass StrBar:\n    --snip--\n\n    def global_stiffness_matrix(self) -> Matrix:\n        direction = self.geometry.direction_vector\n        eal = self.young_mod * self.cross_section / self.length\n        c = direction.cosine\n        s = direction.sine\n\n        c2_eal = (c ** 2) * eal\n        s2_eal = (s ** 2) * eal\n        sc_eal = (s * c) * eal\n\n        return Matrix(4, 4).set_data([\n            c2_eal, sc_eal, -c2_eal, -sc_eal,\n            sc_eal, s2_eal, -sc_eal, -s2_eal,\n            -c2_eal, -sc_eal, c2_eal, sc_eal,\n            -sc_eal, -s2_eal, sc_eal, s2_eal\n        ])\n```", "```py\nfrom eqs import Matrix\n```", "```py\nimport unittest\nfrom math import sqrt\n\nfrom eqs import Matrix\nfrom geom2d import Point\nfrom structures.model.node import StrNode\nfrom structures.model.bar import StrBar\n\nclass BarTest(unittest.TestCase):\n    section = sqrt(5)\n    young = 5\n\n    node_a = StrNode(1, Point(0, 0))\n    node_b = StrNode(2, Point(2, 1))\n    bar = StrBar(1, node_a, node_b, section, young)\n\n    def test_global_stiffness_matrix(self):\n        expected = Matrix(4, 4).set_data([\n            4, 2, -4, -2,\n            2, 1, -2, -1,\n            -4, -2, 4, 2,\n            -2, -1, 2, 1\n        ])\n        actual = self.bar.global_stiffness_matrix()\n        self.assertEqual(expected, actual)\n```", "```py\n$ python3 -m unittest structures/tests/bar_test.py\n```", "```py\nRan 1 test in 0.000s\n\nOK\n```", "```py\nfrom eqs import Matrix\nfrom geom2d import Segment\nfrom .node import StrNode\n\nclass StrBar:\n\n    def __init__(\n            self,\n            _id: int,\n            start_node: StrNode,\n            end_node: StrNode,\n            cross_section: float,\n            young_mod: float\n    ):\n        self.id = _id\n        self.start_node = start_node\n        self.end_node = end_node\n        self.cross_section = cross_section\n        self.young_mod = young_mod\n\n    @property\n    def geometry(self):\n        return Segment(\n            self.start_node.position,\n            self.end_node.position\n        )\n\n    @property\n    def length(self):\n        return self.geometry.length\n\n    def global_stiffness_matrix(self) -> Matrix:\n        direction = self.geometry.direction_vector\n        eal = self.young_mod * self.cross_section / self.length\n        c = direction.cosine\n        s = direction.sine\n\n        c2_eal = (c ** 2) * eal\n        s2_eal = (s ** 2) * eal\n        sc_eal = (s * c) * eal\n\n        return Matrix(4, 4).set_data([\n            c2_eal, sc_eal, -c2_eal, -sc_eal,\n            sc_eal, s2_eal, -sc_eal, -s2_eal,\n            -c2_eal, -sc_eal, c2_eal, sc_eal,\n            -sc_eal, -s2_eal, sc_eal, s2_eal\n        ])\n```", "```py\nfrom functools import reduce\n\nfrom .node import StrNode\nfrom .bar import StrBar\n\nclass Structure:\n    def __init__(self, nodes: [StrNode], bars: [StrBar]):\n        self.__bars = bars\n        self.__nodes = nodes\n\n    @property\n    def nodes_count(self):\n        return len(self.__nodes)\n\n    @property\n    def bars_count(self):\n        return len(self.__bars)\n\n    @property\n    def loads_count(self):\n        return reduce(\n            lambda count, node: count + node.loads_count,\n            self.__nodes,\n            0\n        )\n```", "```py\n>>> from geom2d import Point, Vector\n>>> from structures.model.node import StrNode\n>>> from structures.model.bar import StrBar\n>>> from structures.model.structure import Structure\n```", "```py\n>>> node_one = StrNode(1, Point(0, 0), None, True, True)\n>>> node_two = StrNode(2, Point(100, 0), None, False, True)\n>>> node_three = StrNode(3, Point(100, 100), (Vector(50, -100)))\n\n>>> bar_one = (1, node_one, node_two, 20, 20000000)\n>>> bar_two = (2, node_two, node_three, 20, 20000000)\n>>> bar_three = (3, node_three, node_one, 20, 20000000)\n\n>>> structure = Structure(\n    (node_one, node_two, node_three),\n    (bar_one, bar_two, bar_three)\n)\n```", "```py\nfrom geom2d import Vector\nfrom structures.model.node import StrNode\n\nclass StrNodeSolution:\n    def __init__(\n            self,\n            original_node: StrNode,\n            global_disp: Vector\n    ):\n        self.__original_node = original_node\n        self.global_disp = global_disp\n\n    @property\n ➊ def id(self):\n        return self.__original_node.id\n\n    @property\n ➋ def original_pos(self):\n        return self.__original_node.position\n\n    @property\n ➌ def is_constrained(self):\n        return self.__original_node.dx_constrained \\\n               or self.__original_node.dy_constrained\n\n    @property\n ➍ def loads(self):\n        return self.__original_node.loads\n\n    @property\n ➎ def is_loaded(self):\n       return self.__original_node.loads_count > 0\n\n    @property\n ➏ def net_load(self):\n        return self.__original_node.net_load\n```", "```py\nclass StrNodeSolution:\n   --snip--\n\n   @property\n   def displaced_pos(self):\n       return self.original_pos.displaced(self.global_disp)\n\n   def displaced_pos_scaled(self, scale=1):\n       return self.original_pos.displaced(self.global_disp, scale)\n```", "```py\nfrom geom2d import Vector\nfrom structures.model.node import StrNode\n\nclass StrNodeSolution:\n    def __init__(\n            self,\n            original_node: StrNode,\n            global_disp: Vector\n    ):\n        self.__original_node = original_node\n        self.global_disp = global_disp\n\n    @property\n    def id(self):\n        return self.__original_node.id\n\n    @property\n    def original_pos(self):\n        return self.__original_node.position\n\n    @property\n    def is_constrained(self):\n        return self.__original_node.dx_constrained \\\n               or self.__original_node.dy_constrained \n\n    @property\n    def loads(self):\n        return self.__original_node.loads\n\n    @property\n    def is_loaded(self):\n        return self.__original_node.loads_count > 0\n\n    @property\n    def displaced_pos(self):\n        return self.original_pos.displaced(self.global_disp)\n\n    def displaced_position_scaled(self, scale=1):\n        return self.original_pos.displaced(self.global_disp, scale)\n```", "```py\nfrom structures.model.bar import StrBar\nfrom .node import StrNodeSolution\n\nclass StrBarSolution:\n    def __init__(\n            self,\n            original_bar: StrBar,\n            start_node: StrNodeSolution,\n            end_node: StrNodeSolution\n    ):\n        if original_bar.start_node.id != start_node.id:\n            raise ValueError('Wrong start node')\n\n        if original_bar.end_node.id != end_node.id:\n            raise ValueError('Wrong end node')\n\n        self.__original_bar = original_bar\n        self.start_node = start_node\n        self.end_node = end_node\n\n    @property\n    def id(self):\n        return self.__original_bar.id\n\n    @property\n    def cross_section(self):\n        return self.__original_bar.cross_section\n\n    @property\n    def young_mod(self):\n        return self.__original_bar.young_mod\n```", "```py\nfrom geom2d import Segment\nfrom structures.model.bar import StrBar\nfrom .node import StrNodeSolution\n\nclass StrBarSolution:\n   --snip--\n\n   @property\n   def original_geometry(self):\n       return self.__original_bar.geometry\n\n   @property\n   def final_geometry(self):\n       return Segment(\n           self.start_node.displaced_pos,\n           self.end_node.displaced_pos\n       )\n```", "```py\nclass StrBarSolution:\n   --snip--\n\n   @property\n   def original_length(self):\n       return self.original_geometry.length\n\n   @property\n   def final_length(self):\n       return self.final_geometry.length\n\n   @property\n   def elongation(self):\n       return self.final_length - self.original_length\n```", "```py\nclass StrBarSolution:\n   --snip--\n\n   @property\n   def strain(self):\n       return self.elongation / self.original_length\n\n   @property\n   def stress(self):\n       return self.young_mod * self.strain\n```", "```py\nfrom geom2d import Segment, make_vector_between\nfrom structures.model.bar import StrBar\nfrom .node import StrNodeSolution\n\nclass StrBarSolution:\n    --snip--\n\n    @property\n    def internal_force_value(self):\n        return self.stress * self.cross_section\n\n    def force_in_node(self, node: StrNodeSolution):\n     ➊ if node is self.start_node:\n            return make_vector_between(\n                self.end_node.displaced_pos,\n                self.start_node.displaced_pos\n            ).with_length(\n                self.internal_force_value\n            )\n     ➋ elif node is self.end_node:\n            return make_vector_between(\n                self.start_node.displaced_pos,\n                self.end_node.displaced_pos\n            ).with_length(\n                self.internal_force_value\n            )\n\n        raise ValueError(\n            f'Bar {self.id} does not know about node {node.id}'\n        )\n```", "```py\nclass StrBarSolution:\n   --snip--\n\n   def has_node(self, node: StrNodeSolution):\n       return node is self.start_node or node is self.end_node\n```", "```py\nclass StrBarSolution:\n   --snip--\n\n   def final_geometry_scaling_displacement(self, scale: float):\n       return Segment(\n           self.start_node.displaced_pos_scaled(scale),\n           self.end_node.displaced_pos_scaled(scale)\n       )\n```", "```py\nfrom geom2d import Segment, make_vector_between\nfrom structures.model.bar import StrBar\nfrom .node import StrNodeSolution\n\nclass StrBarSolution:\n    def __init__(\n            self,\n            original_bar: StrBar,\n            start_node: StrNodeSolution,\n            end_node: StrNodeSolution\n    ):\n        if original_bar.start_node.id != start_node.id:\n            raise ValueError('Wrong start node')\n\n        if original_bar.end_node.id != end_node.id:\n            raise ValueError('Wrong end node')\n\n        self.__original_bar = original_bar\n        self.start_node = start_node\n        self.end_node = end_node\n\n    @property\n    def id(self):\n        return self.__original_bar.id\n\n    @property\n    def cross_section(self):\n        return self.__original_bar.cross_section\n\n    @property\n    def young_mod(self):\n        return self.__original_bar.young_mod\n\n    @property\n    def original_geometry(self):\n        return self.__original_bar.geometry\n\n    @property\n    def final_geometry(self):\n        return Segment(\n            self.start_node.displaced_pos,\n            self.end_node.displaced_pos\n        )\n\n    @property\n    def original_length(self):\n        return self.original_geometry.length\n\n    @property\n    def final_length(self):\n        return self.final_geometry.length\n\n    @property\n    def elongation(self):\n        return self.final_length - self.original_length\n\n    @property\n    def strain(self):\n        return self.elongation / self.original_length\n\n    @property\n    def stress(self):\n        return self.young_mod * self.strain\n\n    @property\n    def internal_force_value(self):\n        return self.stress * self.cross_section\n\n    def force_in_node(self, node: StrNodeSolution):\n        if node is self.start_node:\n            return make_vector_between(\n                self.end_node.displaced_pos,\n                self.start_node.displaced_pos\n            ).with_length(\n                self.internal_force_value\n            )\n        elif node is self.end_node:\n            return make_vector_between(\n                self.start_node.displaced_pos,\n                self.end_node.displaced_pos\n            ).with_length(\n                self.internal_force_value\n            )\n\n        raise ValueError(\n            f'Bar {self.id} does not know about node {node.id}'\n        )\n\n    def has_node(self, node: StrNodeSolution):\n        return node is self.start_node or node is self.end_node\n\n    def final_geometry_scaling_displacement(self, scale: float):\n        return Segment(\n            self.start_node.displaced_position_scaled(scale),\n            self.end_node.displaced_position_scaled(scale)\n        )\n```", "```py\nfrom .bar import StrBarSolution\nfrom .node import StrNodeSolution\n\nclass StructureSolution:\n    def __init__(\n            self,\n            nodes: [StrNodeSolution],\n            bars: [StrBarSolution]\n    ):\n        self.nodes = nodes\n        self.bars = bars\n```", "```py\nfrom geom2d import make_rect_containing_with_margin\nfrom .bar import StrBarSolution\nfrom .node import StrNodeSolution\n\nclass StructureSolution:\n   --snip--\n\n    def bounds_rect(self, margin: float, scale=1):\n        d_pos = [\n            node.displaced_pos_scaled(scale)\n            for node in self.nodes\n        ]\n        return make_rect_containing_with_margin(d_pos, margin)\n```", "```py\nimport operator\nfrom functools import reduce\n\nfrom geom2d import make_rect_containing_with_margin, Vector\nfrom .bar import StrBarSolution\nfrom .node import StrNodeSolution\n\nclass StructureSolution:\n   --snip--\n\n    def reaction_for_node(self, node: StrNodeSolution):\n     ➊ if not node.is_constrained:\n            return Vector(0, 0)\n\n     ➋ forces = [\n            bar.force_in_node(node)\n            for bar in self.bars\n            if bar.has_node(node)\n        ]\n\n        if node.is_loaded:\n         ➌ forces.append(node.net_load.opposite())\n\n     ➍ return reduce(operator.add, forces)\n```", "```py\nimport operator\nfrom functools import reduce\n\nfrom geom2d import make_rect_containing_with_margin, Vector\nfrom .bar import StrBarSolution\nfrom .node import StrNodeSolution\n\nclass StructureSolution:\n    def __init__(\n            self,\n            nodes: [StrNodeSolution],\n            bars: [StrBarSolution]\n    ):\n        self.nodes = nodes\n        self.bars = bars\n\n    def bounds_rect(self, margin: float, scale=1):\n        d_pos = [\n            node.displaced_pos_scaled(scale)\n            for node in self.nodes\n        ]\n        return make_rect_containing_with_margin(d_pos, margin)\n\n    def reaction_for_node(self, node: StrNodeSolution):\n        if not node.is_constrained:\n            return Vector(0, 0)\n\n        forces = [\n            bar.force_in_node(node)\n            for bar in self.bars\n            if bar.has_node(node)\n        ]\n\n        if node.is_loaded:\n            forces.append(node.net_load.opposite())\n\n        return reduce(operator.add, forces)\n```"]