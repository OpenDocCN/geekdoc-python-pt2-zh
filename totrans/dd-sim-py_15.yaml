- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary and Serialization
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 01100010 01101001 01101110 01100001 01110010 01111001\. This is the language
    of computers, the delight of hackers, and the subject of that one computer science
    joke you have memorized. If a programming language wants a chance to gain the
    admiration of elite developers, it must allow working with *binary*.
  prefs: []
  type: TYPE_NORMAL
- en: For the programmers who haven’t encountered binary yet, I’ll start by breaking
    down the fundamentals, particularly as Python sees them, and the different ways
    of expressing binary data and performing bitwise operations. With that foundation
    in place, I’ll cover how to read and write files in binary, and I’ll wrap up with
    a whirlwind tour of some of the most common binary file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Notation and Bitwise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For those who are new to the fine art of bit twiddling, I’ll breeze through
    it now. Even if you already know how to do bitwise manipulation, I recommend hanging
    in there for the next few pages for a review—and perhaps some little surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Number Systems Refresher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary* is a number system with only two digits—`0` and `1`—which correspond
    to the open and closed position (respectively) of gates on circuit boards. This
    is the foundation of all computer programming. Typically, this binary is abstracted
    out for better human comprehension through CPU instructions and data types, and
    then further toward human language through various programming constructs. Although
    you won’t usually need to think much about binary, there are times when manipulating
    it directly is the most effective way to solve a problem.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, when writing a numeric literal in binary, you prefix it with `0b`
    to differentiate it from run-of-the-mill decimal (base-10) numbers. For example,
    while `11` is the decimal value “eleven,” `0b11` is the binary value for “three.”
  prefs: []
  type: TYPE_NORMAL
- en: A binary *bit* is a single digit. A *byte* is usually made up of eight bits,
    although uncommonly, this can vary. Within a byte, place values typically ascend
    from right to left, as with decimal numbers. You can compose any number by switching
    on (`1`) or off (`0`) the bits at different positions. In a byte, the rightmost
    place has a value of `1`, and each subsequent place has double the preceding value.
    The value of each place is demonstrated in [Table 12-1](#table12-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-1: Place Values of Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: So, the byte `0b01011010` would be equivalent to `64 + 16 + 8 + 2`, or `90`.
    The computer interprets particular bytes differently, depending on the data type—something
    determined by the code, rather than stored in the binary data. From a low-level
    perspective, the same sequence of bits could represent the integer `90`, the ASCII
    character `'Z'`, a part of a floating-point number, a bytecode instruction . .
    . the possibilities are endless. Thankfully, you don’t need to worry about how
    the computer handles this interpretation. Trust the language for that.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also represent numeric literals in the *hexadecimal*, or base-16 number
    system, which is so named because there are 16 unique digits for the decimal values
    `0` through `15`. The first 10 use the ordinary digits `0` through `9` and the
    letters `A` through `F` as digits for values `10` through `15`, respectively.
    The decimal value `16` cannot be represented with a single digit in hexadecimal;
    it is instead represented by `10` in this system. In Python, as in most programming
    languages, you prefix hexadecimal literals with `0x` to differentiate them from
    decimal numbers. `0x15` would represent decimal value `21`, because `0x10` (`16`)
    + `0x05` (`5`) = `0x15` (`21`).
  prefs: []
  type: TYPE_NORMAL
- en: When manually composing larger numbers in any number system, mentally or on
    paper, it’s useful to think of each *place value* as the base value raised to
    the place number (starting from zero). For example, the decimal number `4972`
    could be thought of as `2 + 70 + 900 + 4000`, which can further be broken down
    as `(2 * 10`⁰`) + (7 * 10`¹`) + (9 * 10`²`) + (4 * 10`³`).`
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-2](#table12-2) demonstrates this with base 10 (decimal), base 2 (binary),
    and base 16 (hexadecimal).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-2: Place Values in Various Number Systems'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number system** | **Place values** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | `10000 (n`⁴`)` | `1000 (n`³`)` | `100 (n`²`)` | `10 (n`¹`)` | `1 (n`⁰`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Decimal** | `10`⁴ `(10000)` | `10`³ `(1000)` | `10`² `(100)` | `10`¹ `(10)`
    | `10`⁰ `(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| **Binary** | `2`⁴ `(16)` | `2`³ `(8)` | `2`² `(4)` | `2`¹ `(2)` | `2`⁰ `(1)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Hexadecimal** | `16`⁴ `(65536)` | `16`³ `(4096)` | `16`² `(256)` | `16`¹
    `(16)` | `16`⁰ `(1)` |'
  prefs: []
  type: TYPE_TB
- en: You can use this principle to convert a decimal value to another system, such
    as hexadecimal. For example, if I wanted to convert the decimal value 2630, I’d
    first determine the highest place value needed with the formula `⌊log`[16]`2630⌋`,
    which gives me `2`. Then, I’d perform the conversion as shown in [Table 12-3](#table12-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-3: Converting Decimal to Hexadecimal'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value to convert** | `2630` | `70` | `6` |'
  prefs: []
  type: TYPE_TB
- en: '| **Place value** | `⌊``2630``/16`²`⌋ = 0xA (10)` | `⌊``70``/16`¹`⌋ = 0x4`
    | `⌊``6``/16`⁰`⌋ = 0x6` |'
  prefs: []
  type: TYPE_TB
- en: '| **Current hexadecimal value** | `0x``A``00` | `0xA``4``0` | `0xA4``6` |'
  prefs: []
  type: TYPE_TB
- en: '| **Calculate remaining value** | `2630 % 16`² `=` `70` | `70 % 16`¹ `=` `6`
    | `6 % 16`⁰ `= 0` |'
  prefs: []
  type: TYPE_TB
- en: The decimal value `2630` has the hexadecimal value `0xA46`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal is useful in the context of binary because you can exactly express
    each possible value of a byte (eight bits) in two digits, from `0x00` (`0`) to
    `0xFF` (`255`). Hexadecimal is a more succinct way of representing binary: `0b10101010`
    can be written as `0xAA`.'
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal Humor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hexadecimal employs the first six letters of the Latin alphabet as digits, and
    among developers, this has led to a traditional brand of puns known as *hexspeak*.
    Hexadecimal numbers such as 0xDEADBEEF and 0xC0FFEE have valid numeric values
    and are visually recognizable; the former has traditionally been used on some
    ancient IBM systems for uninitialized memory, because it was easy to spot amidst
    the wall of hexadecimal that was a core dump.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, you can sometimes mark special data in your binary. This can
    make your binary files a little easier to read and debug manually, and besides,
    it’s fun! Just be mindful that normal data may coincidentally show up in hexspeak,
    too—for example, a normal integer value that happens to read as 0xDEADBEEF—so
    use it with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Octal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The third most common number system for representing binary data is *octal*,
    or base-8\. Octal literals are prefixed with `0o` (zero, followed by a lowercase
    letter *o*). Octal uses digits for decimal values `0` through `7`, but it writes
    `8` as `0o10`. Thus, decimal values `9` and `10` would be `0o11` and `0o12`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-4](#table12-4) shows that place value table again, this time including
    octal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-4: Place Values in Various Number Systems'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number systems** | **Place values** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | `10000 (n`⁴`)` | `1000 (n`³`)` | `100 (n`²`)` | `10 (n`¹`)` | `1 (n`⁰`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Decimal** | `10`⁴ `(10000)` | `10`³ `(1000)` | `10`² `(100)` | `10`¹ `(10)`
    | `10`⁰ `(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| **Binary** | `2`⁴ `(16)` | `2`³ `(8)` | `2`² `(4)` | `2`¹ `(2)` | `2`⁰ `(1)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Octal** | `8`⁴ `(4096)` | `8`³ `(512)` | `8`² `(64)` | `8`¹ `(8)` | `8`⁰
    `(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| **Hexadecimal** | `16`⁴ `(65536)` | `16`³ `(4096)` | `16`² `(256)` | `16`¹
    `(16)` | `16`⁰ `(1)` |'
  prefs: []
  type: TYPE_TB
- en: Every 8-bit byte can be represented by three octal digits, with the highest
    value (`0xFF`) being `0o377`. Although octal doesn’t map to bytes as cleanly or
    obviously as hexadecimal, it is still useful in some scenarios because it’s more
    compact than binary but doesn’t require six extra digits like hexadecimal. Octal
    is used for UNIX file permissions, and it simplifies specifying individual parts
    of some UTF-8 characters and some assembly op codes. If you have trouble picturing
    these use cases, you probably don’t need octal. You could go through your entire
    career without needing it! Regardless, it is helpful to know about it for the
    rare cases when you might need it.
  prefs: []
  type: TYPE_NORMAL
- en: Number Systems on Integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s important to remember that binary, octal, decimal, and hexadecimal are
    all *number systems*; that is, they’re different ways of representing the same
    *whole number*, or *integer*. The decimal number `12` can be represented as `0b1100`,
    `0xc`, or `0o14`, but binding any of these literals to a name in Python will still
    store an integer with the decimal value `12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: print_integer.py:1a'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, printing an integer always shows the value in decimal. I can instead
    show the value in another number system by using one of the built-in functions
    for that purpose: `bin()`, `oct()`, or `hex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: print_integer.py:1b'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how you display it, the actual value bound to `chapter` is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Two’s Complement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In binary on most computers, negative numbers are represented as the *two’s
    complement* of the positive number. This technique is preferred over simply using
    a single bit to indicate positive or negative, as it allows you to store one additional
    value in the byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the positive number `42` would be `0b00101010` in binary. To get
    `-42`, I’d find the two’s complement by inverting each of the bits (giving me
    `0b11010101`) and then adding `0b1`, ultimately producing `0b11010110` (you carry
    the `1`: `0b01` + `0b01` = `0b10`).'
  prefs: []
  type: TYPE_NORMAL
- en: To convert a negative number back to a positive, you only need to repeat the
    process. Starting with `-42`, or `0b11010110`, I invert each of the bits, giving
    me `0b00101001`. Then, I add `0b1`, producing `0b00101010`, which is positive
    `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python *almost* uses two’s complement—it actually does something more complex,
    as you’ll see in a later section—so it instead shows negative binary numbers by
    placing a negative sign on the binary representation of the positive form of the
    number, as seen below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: negative_binary.py:1'
  prefs: []
  type: TYPE_NORMAL
- en: As a bit wrangler myself, this may be the only thing I dislike about Python,
    although I understand its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, it is possible to see the (approximate) two’s complement notation
    by using a *bitmask*, a binary value that uses strategically placed `1`s to keep
    certain bits in a value and throw away the rest. In this case, I want the first
    eight bits of the value (one byte), so I take the bitwise `AND` the value with
    a bitmask of eight `1`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: negative_binary.py:2'
  prefs: []
  type: TYPE_NORMAL
- en: 'That shows exactly what I’d expect: the eight-bit-long two’s complement representation
    of `-42`.'
  prefs: []
  type: TYPE_NORMAL
- en: Byte Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, I’m not referring to Python at all, but rather to the computer
    memory *underneath* everything. We’re all the way down to silicon right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most data is made up of multiple bytes, but the sequence the bytes appear in
    depends on the *byte order* used by your platform: either *big-endian* or *little-endian*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Byte order has everything to do with how the computer stores data in memory.
    Each one-byte-wide slot in memory has a numeric address, typically represented
    in hexadecimal. Memory addresses are consecutive. Let’s consider a value, say
    `0xAABBCCDD` (`2,864,434,397` in decimal), that is composed of four bytes: `0xAA`,
    `0xBB`, `0xCC`, and `0xDD`. This value can be stored in a four-byte-wide chunk
    of memory, with each byte having an address. For example, the computer might decide
    to store that data in the memory at addresses `0xABCDEF01`, `0xABCDEF02`, `0xABCDEF03`,
    and `0xABCDEF04`, as shown in [Table 12-5](#table12-5).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-5: An Empty Four-Byte Chunk of Memory with Addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | `0xABCDEF01` | `0xABCDEF02` | `0xABCDEF03` | `0xABCDEF04` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Value** |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Now here’s the challenge: in what order do we store those bytes? Your first
    instinct might be to store them as you’d write them on paper, like in [Table 12-6](#table12-6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-6: Data Stored in Memory in Big-Endian Byte Order'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | `0xABCDEF01` | `0xABCDEF02` | `0xABCDEF03` | `0xABCDEF04` |
    Whole value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Hex value** | `0xAA` | `0xBB` | `0xCC` | `0xDD` | `= 0xAABBCCDD` |'
  prefs: []
  type: TYPE_TB
- en: '| **Equivalent** | `2852126720` | `+ 12255232` | `+ 52224` | `+ 221` | `= 2864434397`
    |'
  prefs: []
  type: TYPE_TB
- en: We call this byte order *big-endian*, because the value representing the largest
    part of the value is stored in the lowest, or leftmost, address. The big-endian
    byte order is often the easiest to reason about, because it orders bytes from
    left to right, just like how you’d write it on paper.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, on little-endian systems, the bytes are reversed, as shown in [Table
    12-7](#table12-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-7: Data Stored in Memory in Little-Endian Byte Order'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | `0xABCDEF01` | `0xABCDEF02` | `0xABCDEF03` | `0xABCDEF04` |
    Whole value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Hex value** | `0xDD` | `0xCC` | `0xBB` | `0xAA` | `= 0xDDCCBBAA` |'
  prefs: []
  type: TYPE_TB
- en: '| **Equivalent** | `221` | `+ 52224` | `+ 12255232` | `+ 2852126720` | `= 2864434397`
    |'
  prefs: []
  type: TYPE_TB
- en: As the name *little-endian* suggests, the byte representing the smallest part
    of the number is stored in the lowest memory address.
  prefs: []
  type: TYPE_NORMAL
- en: Endianness only affects primitive data types, like integers and floating-point
    numbers. It will not affect collections, such as strings, which are just arrays
    of individual characters.
  prefs: []
  type: TYPE_NORMAL
- en: Although little-endian byte order sounds confusing, it makes a few little technical
    optimizations possible on the hardware. Most modern computers, including all Intel
    and AMD processors, use little-endian.
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages, we conventionally write binary numbers in big-endian.
    It’s the byte order used when you display an integer in binary in Python with
    `bin()`.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the only time you need to be concerned about byte order is when your
    binary data is going to leave your program, such as when writing it to a file
    or sending it over a network.
  prefs: []
  type: TYPE_NORMAL
- en: Python Integers and Binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like in most programming languages, binary and hexadecimal literals are integers
    in Python. However, one implementation detail behind Python integers bleeds into
    the binary logic of the language: *integers are effectively infinite*.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python 2, the `int` type had a fixed size of 32 bits, or four bytes. Python
    2 also had the `long` type, which had an unlimited size. In Python 3, the `long`
    type was adopted as the new `int`, so all integers now have a theoretically infinite
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior has one critical consequence for binary: two’s complement notation
    must effectively lead with an infinite number of `1` bits. This is why Python
    uses the rather unconventional negative binary notation. There’s no rational way
    to express an infinite number of `1`s! It also means you can’t directly type a
    binary literal for a negative integer. Instead, you have to use the negation operator
    (`-`) before the binary literal of the *positive* integer and trust Python to
    figure things out.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Python uses that negative binary notation, the negative binary form of
    a number reads the same as the positive binary form. The two’s complement notation
    would only be accurate if you could see the infinite leading `1` bits. This has
    a weird consequence elsewhere, as you’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can work directly with binary data using the *bitwise operators*, which
    perform operations on individual bits. There are six bitwise operators, and Python
    offers all of them, although a couple behave a bit differently than you’d ordinarily
    expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Bitwise And* operator (`&`) produces a new binary value, where each bit
    is `1` if the corresponding bits in the left and right operands are both `1`.
    For example, `0b1101 & 0b1010` produces `0b1000`, because only the leftmost bit
    is `1` in both operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *Bitwise Or* operator (`|`) produces a value where each bit is `1` if either
    the left or the right operand is `1` (or if both are). For example, `0b1101 |
    0b1010` produces `0b1111`, because each of the four bits is on in at least one
    of the operands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The *Bitwise Exclusive Or* operator (`^`), also known as a *Bitwise XOR*, sets
    a bit to `1` if it is on in either operand, but not in both. For example, `0b1101
    ^ 0b1010` produces `0b0111`; the first bit is on in both operands, so it is off
    here, but the other three bits are on in only one operand, so they’re included.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *Bitwise Inversion* operator (`~`), also known as the *Bitwise Not*, flips
    each bit in the operand given, such that `0b0101` would become (approximately)
    `0b1010`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, since in Python, integers are infinite, the new value would have infinite
    leading `1` bits. Therefore, the real result of `~0b0101` is actually `0b111...1010`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since infinite `1`s are hard to print, Python shows the result in negative binary
    notation—placing a negative sign at the front and subtracting `1` to get around
    the two’s complement. Remember, this convention is what allows Python to display
    a negative number as the negative binary form of the positive number. Unfortunately,
    it makes it a bit harder to read the results of normal bit twiddling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever this gets in your way, you can print the bitmasked form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: bitwise_inversion.py'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the first value is *internally* correct, as it has the infinite
    leading `1`s that make it a negative Python integer. The second only *looks* correct,
    but it lacks those leading `1`s, so it’s actually wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The last two bitwise operators are the *Left Shift* ([PRE10]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]`Every language must decide which form of bitwise shift its operators
    should use, and Python uses the *arithmetic shift*. In addition, because of the
    infinite nature of integers, you cannot discard bits with a left shift; the integer
    will keep growing to accommodate them, as you can see here:    [PRE12]    Listing
    12-6: bitwise_shift.py:1    That probably won’t have any profound effect on your
    code, but it may change how you implement some binary algorithms that rely on
    discarding bits with a left shift.    A right shift will preserve the sign, so
    it will shift in `0`s on the left for positive integers and `1`s for negative
    integers:    [PRE13]    Listing 12-7: bitwise_shift.py:2    In summary, [Table
    12-8](#table12-8) shows those bitwise operators again, as well as their corresponding
    special methods.      Table 12-8: Bitwise Operators       | **Operator** | **Use**
    | **Binary (not Python) example** | **Special method** | | --- | --- | --- | ---
    | | `&` | Bitwise And | `1100 & 1011 ⇒ 1000` | `__and__(``a``,` `b``)` | | `&#124;`
    | Bitwise Or | `1100 &#124; 1011 ⇒ 1111` | `__or__(``a``,` `b``)` | | `^` | Bitwise
    Exclusive Or (Bitwise XOR) | `1100 ^ 1011 ⇒ 0111` | `__xor__(``a``,` `b``)` |
    | `~` | Bitwise Inversion (Bitwise Not) | `~1100 ⇒ 0011` | `__inv__(``a``)` `__invert__(``a``)`
    | | `<<` | Left (arithmetic) Shift | `0111 << 2 ⇒ 11100` | `__lshift__(``a``,`
    `b``)` | | `>>` | Right (arithmetic) Shift | `0111 >> 2 ⇒ 0001` `1..1010 2 ⇒ 1..1110`
    | `__rshift__(``a``,` `b``)` |    These operators also work on boolean values,
    which are internally based on integers (much to the consistent annoyance of one
    of my colleagues!). They won’t work like this on other types—only on booleans
    and integers.    Be cautious when using bitwise with existing custom classes!
    Because they’re uncommonly used compared to many other operators, some classes
    choose to repurpose the bitwise operators for altogether unrelated purposes. Thus,
    performing bitwise operations on anything except an integer or boolean can result
    in wildly unpredictable behavior. Be sure to read the documentation on any class
    you want to use before you rely on the bitwise operators with it!    You can make
    your own objects work with the bitwise operators themselves by implementing the
    corresponding special methods from [Table 12-8](#table12-8).    ## Bytes Literals    Another
    way to represent binary in Python is with a *bytes literal*, which looks like
    a string literal prepended with `b`, such as `b"HELLO"` or `b"\xAB\x42"`. These
    are not strings, but rather sequences of bytes, with each byte represented by
    either an ASCII character (such as `"H"` for `0x48`) or a hexadecimal escape sequence
    (such as `"\x42"` for `0x42`). Unlike integer objects, bytes literals have the
    explicit size and implied byte order you give them.    Here’s that example bytes
    literal, which contains the binary equivalent of the string “HELLO”:    [PRE14]    Listing
    12-8: bytes_literal.py:1a    Although a bytes literal isn’t exactly a string,
    most of the rules of string literals still apply here, with two major exceptions.
    First, a bytes literal can only contain ASCII characters (values `0x00` to `0xFF`),
    partly because each item in a bytes literal must be exactly one byte in size,
    and partly for backward compatibility with Python 2 and other languages that use
    ASCII text encoding. Second, unlike strings, bytes literals cannot be formatted
    via f-strings.    In all Python strings, you can use the escape sequence `''\x``hh''`
    to represent a character with the hexadecimal value `hh`. Unlike in some languages,
    the escape sequence must always contain a two-digit hexadecimal number. It does
    not matter whether the digits `A` through `F` are uppercase or lowercase: `''\xAB''`
    and `''\xab''` are treated the same, although Python always outputs the latter.    For
    example, if I knew the hexadecimal codes I needed for `"HELLO"`, I could use them
    in place of some (or all) the ASCII character literals:    [PRE15]    Listing
    12-9: bytes_literal.py:1b    These hexadecimal literals are also needed when the
    desired value cannot be represented by a visible character, such as `''\x07''`,
    which in ASCII is the nonprinting control code `BEL`, which sounds the system
    bell. (And yes, `print(''\x07'')` will indeed play a sound, assuming you haven’t
    turned off your system bell in your terminal or system settings.)    You can also
    create raw bytes literals, wherein the backslash character (`\`) is always treated
    as a literal character. Because of this, raw bytes literals cannot interpret escape
    sequences, which limits their usefulness. However, if you don’t need escape sequences
    and do want literal backslashes, then raw bytes literals can occasionally come
    in handy. To define a raw bytes literal, precede the string with either `rb` or
    `br`. I demonstrate this below:    [PRE16]    Listing 12-10: bytes_literal.py:2    Both
    `bits_escaped` and `bits_raw` have exactly the same value, as demonstrated by
    the comparison in the `print()` statement, but the value assigned to `bits_raw`
    was easier to type.    ## Bytes-Like Objects    If you need to store binary data,
    Python offers *bytes-like objects*. Unlike integers, these objects have a fixed
    size and an *implied* byte order. This means they have the byte order you followed
    when you provided the bytes to the bytes-like object; it also means you are responsible
    for explicitly defining the byte order of the data you provide. This can be helpful
    when the infinite nature of integers gets underfoot. Bytes-like objects also provide
    a number of utility functions, unlike bytes literals.    There’s one drawback:
    the bitwise operators don’t work with bytes-like objects. That may sound strange,
    and even annoying, and the exact reasons for this are largely unknown. There are
    two very plausible reasons, however.    First, it’s essential to avoid unexpected
    behavior relating to byte order. If you tried to perform a bitwise operation on
    a big-endian and a little-endian object greater than one byte, the result’s byte
    order would be unclear. You’d run the risk of getting garbage output, which would
    be quite difficult to debug.    Second, it’s difficult to predict how to handle
    bitwise operations on bytes-like objects of different lengths. You could pad them
    to be the same length, but you’d again need to know the byte order to do that
    correctly.    Instead of making the language guess how to implicitly resolve these
    difficult patches of logic, bytes-like objects just don’t support bitwise operators.
    There are a couple of ways to perform bitwise manipulations on bytes-like objects,
    but they’re a little more involved. I’ll come back to that shortly.    There are
    two primary bytes-like objects: `bytes`, which is immutable, and `bytearray`,
    which is mutable. Both objects are identical in all other regards: they provide
    the same functionality as any other Python sequence and offer the same methods
    and behaviors. The two objects are even interoperable.    The decision of whether
    to use `bytes` or `bytearray` comes down solely to whether you want a mutable
    or an immutable object. For simplicity, I’ll mainly use the `bytes` object in
    this section; the code would be the same for `bytearray`.    ### Creating a bytes
    Object    There are six ways to create a bytes-like object—not counting the default
    and copy initializers, which create an empty object or copy the value of another
    bytes-like object, respectively.    The trouble is, passing a binary literal to
    the initializer unexpectedly results in an empty bytes object. This occurs because
    a binary literal is really an integer, and passing an integer `n` to the `bytes()`
    constructor creates an empty bytes object with a size of `n` bytes:    [PRE17]    Listing
    12-11: init_bytes.py:1a    The `bits` object is exactly six (`0b110`) bytes long,
    and each of those bits is set to zero. Although this may feel like surprising
    behavior, remember that any binary data passed to `bytes` must have an explicit
    byte order, something that isn’t inherent to Python integers.    You can create
    a bytes object from binary literals in a couple of ways. One way is to pass an
    iterable of integers to the bytes initializer. However, each of the integers provided
    by the iterable must be positive and representable in a single byte—that is, it
    must be between the values of `0` and `255`, inclusive—or a `ValueError` will
    be raised.    The fastest way to do that here is to pack my binary literal into
    a tuple by itself:    [PRE18]    Listing 12-12: init_bytes.py:1b    Recall that
    I must provide a trailing comma (`,`) in a single-element tuple, or else it will
    be interpreted as a literal integer instead.    Another way to accomplish this
    same goal would be to wrap the binary literal in square brackets (`[ ]`) to define
    a list. Because each integer in the iterable fits in a single byte, the order
    in which the items are provided by the iterable effectively defines the byte order.    Yet
    another way to initialize a bytes object is to assign a bytes literal:    [PRE19]    Listing
    12-13: init_bytes.py:2a    In the case of `bytearray`, you’d pass that literal
    to the initializer:    [PRE20]    Listing 12-14: init_bytes.py:2b    No surprises
    there.    Finally, I can create a bytes object from any string, although I must
    explicitly state the text encoding being used:    [PRE21]    Listing 12-15: init_bytes.py:3    The
    smiley face emoji (`☺`) is a Unicode character with a UTF-8 encoding that spans
    three bytes: `0xE298BA`. If you’re familiar with Unicode, you’ll notice what is
    not happening here: bytes is *not* using the formal Unicode code point for the
    smiley face emoji (`U+263A`), but rather, it is using the internal binary representation
    that UTF-8 uses.    I could have left the keyword off the `encoding=` argument,
    and many Python programmers will, but I prefer to spell it out explicitly. Just
    know that `bytes(''☺'', ''utf-8'')` is equivalent.    ### Using int.to_bytes()    Perhaps
    the easiest way to convert between an integer and a bytes-like object is with
    the `int.to_bytes()` method.    As mentioned, when working with bytes, you must
    specify the byte order. The byte order required is often determined by your situation,
    such as what particular file format you’re working with. Networks always use big-endian
    byte order.    Beyond that, the choice is somewhat arbitrary. If the data is only
    being used by my application, I’ll usually stick to big-endian, which is my preference;
    if the data will be handled by system processes, I’ll employ the system’s byte
    order, which I determine with the following:    [PRE22]    Listing 12-16: int_to_bytes.py:1    The
    `sys.byteorder` attribute provides the byte order of the current system as a string.
    On my machine, as on most modern computers, the value is the string `''little''`,
    for little-endian.    Now, I can create my `bytes` object:    [PRE23]    Listing
    12-17: int_to_bytes.py:2a    I start by binding an integer value to the name `answer`.
    All `int` objects have a `to_bytes()` method for converting the value to a bytes-like
    object. I call that method on `answer`, passing the desired size in bytes (arbitrary
    for this example) of the resulting bytes-like object ❶ and the byte order to use.
    I bind the `bytes` object to the name `bits`.    Finally, to make the output more
    readable, I print out the value of `bits` in hexadecimal, instead of the default
    bytestring, separating the individual byte values with spaces ❷. The value `42`
    is representable with only one byte, and this byte (`2a`) appears on the left,
    since I’m using little-endian byte order.    When I try this with negative numbers,
    things get a little trickier. The same method as above would not work for the
    value `-42`:    [PRE24]    Listing 12-18: int_to_bytes.py:3a    This code fails
    on the `answer.to_bytes()` method call with the following:    [PRE25]    To get
    around this, I must explicitly specify that the integer is *signed*, meaning two’s
    complement is being used to represent negative numbers:    [PRE26]    Listing
    12-19: int_to_bytes.py:3b    This version works as expected, as you can see from
    the output of the `print` statement.    By default, the `signed` parameter is
    `False` to avoid surprises, many originating from the fact that Python only *pretends*
    to use two’s complement but is really doing its own thing. In any case, you should
    get into the habit of setting it to `True` when converting anything that *might*
    be a negative number to an integer. If the integer value is positive, setting
    `signed` to `True` won’t have any effect:    [PRE27]    Listing 12-20: int_to_bytes.py:2b    ###
    Sequence Operations    Nearly all operations you can perform on a sequence like
    a tuple or a list, you can do with bytes-like objects. For example, to see if
    there’s a particular sequence of bytes in a larger bytes object, you can use the
    `in` operator:    [PRE28]    Listing 12-21: bytes_in.py    The `in` operator here
    is acting like it would with a string.    I won’t go into any more depth on these
    operations here, as they behave precisely like they would in `tuple` (for `bytes`)
    or `list` (for `bytearray`).    ### Converting bytes to int    You can create
    an integer from a `bytes` object using `int.from_bytes()`. I’ll start by defining
    a `bytes` object to convert from:    [PRE29]    Listing 12-22: bytes_to_int.py:1    In
    the same way I called `to_bytes()` on a name bound to an integer value, I call
    the same method on an integer literal wrapped in parentheses here ❶. This code
    defines a new `bytes` object, bound to the name `bits`, with the same value as
    in [Listing 12-19](#listing12-19).    To convert the value from `bits` into an
    integer value, I use the `int.from_bytes()` method, which I’m calling on the `int`
    class:    [PRE30]    Listing 12-23: bytes_to_int.py:2    I pass `bits` to the
    method and indicate the `byteorder` and the `bytes` object used. I also indicate
    via `signed=True` that the bytes object is using two’s complement to represent
    negative values. The byte order and signed values are not remembered by the bytes
    object; you’ll need to know these whenever converting from `bytes` objects to
    integers.    The value of `answer` is `-42`, which was obtained from the bytes
    object.    ## struct    The deeper you get into Python’s inner workings, the more
    you discover the C language peeking through. This is largely owing to the fact
    that CPython, the primary implementation of Python, is written in C. Interoperability
    with C remains a factor in how the language is implemented. One example of this
    is the `struct` module. It was originally created to allow data to be moved between
    Python values and C structs. It soon proved to be a handy way to convert values
    to packed binary data, specifically *contiguous* binary data, which is stored
    one item after the next in memory.    The modern `struct` module uses `bytes`
    for storing this binary data, providing the sixth way of creating bytes-like objects.
    Unlike `int.to_bytes()`, which is limited to integers, the `struct.pack()` method
    can also convert floating-point numbers and strings (character arrays) to binary,
    using whichever byte order you request. However, remember that strings themselves
    are unaffected by byte order. You can also use `struct.pack()` to pack multiple
    values into the same `bytes` object and later unpack those individual values into
    separate variables.    By default, `struct` will align all values to the exact
    sizes expected by the C compiler on your system, padding (or truncating padding)
    where necessary, although you can change this alignment behavior to use standard
    sizes instead.    ### struct Format String and Packing    The byte order, alignment
    behavior, and data types for `struct` are determined by the *format string*, which
    must be passed to any of the module’s functions, or else to the initializer of
    the `struct.Struct` object, which lets you reuse the format string more efficiently.    Often,
    the first character of the format string defines the byte order and alignment
    behavior, as in [Table 12-9](#table12-9).      Table 12-9: struct Format String
    Byte Order Flags       | **Character** | **Behavior** | | --- | --- | | `@` |
    Use native byte order and alignment (default). | | `=` | Use native byte order,
    but no alignment. | | `<` | Little-endian, no alignment. | | `>` | Big-endian,
    no alignment. | | `!` | Network standard: big-endian, no alignment (same as `>`).
    |    If you omit this initial character, `struct` will use the native byte order
    and alignment (same as if you start with `@`), padding the data as necessary to
    make sense to the C compiler. The rest of the string indicates the data types
    and order of the values being packed into the struct. Each of the basic C data
    types is represented by a character, as shown in [Table 12-10](#table12-10).      Table
    12-10: struct Format Characters       | **Character** | **C type** | **Python
    type** | **Standard size** | | --- | --- | --- | --- | | `?` | `_Bool` (C99) |
    `bool` | 1 | | `c` | `char` | `bytes(1)` | 1 | | `b` | `signed char` | `int` |
    1 | | `B` | `unsigned char` | `int` | 1 | | `h` | `short` | `int` | 2 | | `H`
    | `unsigned short` | `int` | 2 | | `i` | `int` | `int` | 4 | | `I` | `unsigned
    int` | `int` | 4 | | `l` | `long` | `int` | 4 | | `L` | `unsigned long` | `int`
    | 4 | | `q` | `long long` | `int` | 8 | | `Q` | `unsigned long long` | `int` |
    8 | | `e` | (IEEE 754 binary16 “half precision”) | `float` | 2 | | `f` | `float`
    | `float` | 4 | | `d` | `double` | `float` | 8 | | `s` | `char[]` | `bytes` |  |
    | `p` | `char[]` (Pascal string) | `bytes` |  | | `x` | (pad byte) | effectively
    `bytes(1)` |  |    Most of these types are self-explanatory, especially if you
    know C (or C++, for that matter). When using native alignment, the size of each
    type will depend on the system; otherwise, `struct` uses the standard size.    If
    I wanted to pack two integers and a boolean, in that order, using big-endian notation
    (and standard sizes), I’d use the following format string:    [PRE31]    Listing
    12-24: struct_multiple_values.py:1a    Here, I use the `struct.pack()` function,
    to which I pass the format string and all the values I want to pack, in order.
    This creates a bytes object.    Alternatively, I can precede the type character
    with the desired number of values of that type. Here, I specify two adjacent integer
    values with `2i`, instead of `ii`. The outcome is the same as before:    [PRE32]    Listing
    12-25: struct_multiple_values.py:1b    The format character `''e''` refers to
    the *half-precision* floating-point number introduced in the 2008 revision of
    the IEEE 754, which is the document that defines the floating-point standard used
    by all modern computers.    The pad byte, `''x''`, is exactly one empty byte (`\x00`).
    Use `''x''` to manually pad your data. For example, to pack two integers with
    exactly three empty bytes between them, I’d use the following:    [PRE33]    Listing
    12-26: struct_ints_padded.py:1    There are two ways to represent strings in `struct`.
    Typically, you must *null-terminate* traditional strings (`''s''`), meaning the
    last character is always `\x00`, to mark the end. The number preceding the format
    character is the length of the string in characters; `''10s''` would be a 10-character
    string (that is, 9 characters and the null terminator byte). I can pack the string
    `"Hi!"` like this:    [PRE34]    Listing 12-27: struct_string.py:1    You’ll notice
    that I wrote my string as a bytes literal by prepending it with `b`. The `struct.pack()`
    method cannot work directly with strings, but rather must have a bytes literal
    where the format calls for a string. (A little later, I have an example where
    I convert a typical UTF-8 string to a bytes literal.)    As long as you know the
    size of your string and the data will only ever be read by your code, you don’t
    have to include the null terminator byte here. However, it’s good to be in the
    habit if you’ll be sending your data out of Python. If a C program tried to work
    with a string that lacked a null terminator, some pretty strange behavior could
    result.    Alternatively, you can use a Pascal string (`''p''`), which begins
    with a single byte representing the size as an integer. This string format doesn’t
    require a null termination character, because its size is explicitly stored in
    the first byte. However, it also effectively limits the maximum size of the string
    to 255 bytes.    [PRE35]    Listing 12-28: struct_string.py:2    Another consideration
    is that you may need to pad your `struct` to the *word size*, which is the smallest
    addressable chunk of memory, on your system. This is especially relevant when
    packing data to be handed off to C.    For example, a C `struct` of two longs
    and one short has a length of 24 bytes, but the format string `''@llh''` only
    produces an 18-byte chunk of binary. To correct this, append the format string
    with a zero, followed by the largest type in your struct; in this case, that format
    string would be `''@llh0l''`:    [PRE36]    There is never any danger in padding
    this way. If it’s not needed, the size will be unaffected. This is only applicable
    when using native byte order and alignment (`@`), which is necessary for exchanging
    data with C. If you’re specifying byte order manually or using network standard
    (no alignment), this won’t matter and will have no effect.    There are also three
    types I’ve deliberately omitted from [Table 12-10](#table12-10): `ssize_t` (`n`),
    `size_t` (`N`), and `void*` (`P`). These are only available if you’re using native
    byte ordering and alignment (`@`), but you won’t need those unless you’re moving
    data between C and Python. See the documentation if you need to know about them:
    [https://docs.python.org/3/library/struct.xhtml#format-characters.](https://docs.python.org/3/library/struct.xhtml#format-characters.)    ###
    Unpacking with struct    To unpack data from a `struct` back into Python values,
    I must first determine the appropriate format string for the binary data.    Consider
    an integer packed into `bytes` using native byte order and alignment:    [PRE37]    Listing
    12-29: struct_int.py:1    As long as I know that `bits` uses native ordering and
    contains a single integer, I can retrieve that integer with `struct.unpack()`:    [PRE38]    Listing
    12-30: struct_int.py:2    Notice that I included a trailing comma (`,`) after
    `new_answer` in the assignment statement. The `struct.unpack()` function always
    returns a tuple, which I must unpack. Since that tuple contains only one value,
    the trailing comma forces it to unpack; otherwise, `new_answer` would be bound
    to the tuple itself.    As one more example, I’ll unpack the two integers from
    the bytes-like object from [Listing 12-26](#listing12-26):    [PRE39]    Listing
    12-31: struct_ints_padded.py:2    The three pad bytes (`''3x''`) are discarded,
    and the two integers are unpacked into the names `first` and `second`.    When
    working with `struct`, it is absolutely imperative that you know the format string
    that was used to pack the `struct` in the first place. Observe what would happen
    if I changed the format string in a few ways:    [PRE40]    Listing 12-32: struct_ints_padded.py:3    All
    but the last example *seem* to work, but all the values I’ve unpacked are wrong.
    The moral is simple: know your layout so you can use the correct format strings.    ###
    struct objects    If you need to use the same format string repeatedly, the most
    efficient approach is to initialize a `struct.Struct` object, which provides methods
    analogous to the `struct` functions. For example, here I want to repeatedly pack
    two integers and a floating-point number into bytes objects, so I’ll create a
    `Struct` object.    [PRE41]    Listing 12-33: struct_object.py:1    I create a
    `Struct` object with the format string `''iif''`, and I bind it to the name `packer`.
    The `Struct` object remembers this format string and uses it for any `pack()`
    or `unpack()` calls on the object.    Next, I’ll write a generator that produces
    some strange numeric data and packs it into bytes-like objects:    [PRE42]    Listing
    12-34: struct_object.py:2    In this example, I’m iterating over integers 1 through
    99 as the `right` operand of division, and then I’m taking as the `left` operand
    the modulo of the `right` value and whatever number was passed to the function
    as `n`. Then, I perform the division with left and right, binding the result to
    `result`. (There’s no particular reason for this math; it’s just for fun.)    Next,
    I use `packer.pack()` and pass it the operands and the result of the division.
    The `packer` object uses the format string I passed to its initializer earlier.    In
    the next part of my code, I retrieve the packed `struct` data from the generator
    and, for the sake of the example, unpack the data again, using the `packer` object:    [PRE43]    Listing
    12-35: struct_object.py:3    If you run that code, you’ll see the `left`, `right`,
    and `result` values that had been packed into the bytes objects yielded by the
    generator. This is a silly example, of course; in the real world, I would have
    done something useful with this binary data, such as storing it in a file, instead
    of merely unpacking it again.    ## Bitwise on Bytes-Like Objects    As I mentioned
    earlier, bytes-like objects, including `bytes` and `bytearray`, do not directly
    support bitwise operators. Annoying as this may seem, it makes sense when you
    consider that bytes-like objects don’t know their own byte order. If you performed
    a bitwise operation between a big-endian and a little-endian value, it would be
    impossible to determine the byte order of the result. If there’s one thing that
    Python developers hate, it’s unclear behavior.    It is possible to perform bitwise
    operations on bytes-like objects, but you must use one of two workarounds.    ###
    Bitwise Operations via Integers    The first option is to convert the bytes-like
    objects to integers first, which resolves the byte order. Integers in Python are
    technically infinite, so this approach can be leveraged for handling binary data
    of differing lengths.    Here, I write a function to handle a bitwise operation
    between two bytes-like objects:    [PRE44]    Listing 12-36: bitwise_via_int.py:1    My
    `bitwise_and()` function accepts three arguments: the two bytes-like objects (`left`
    and `right`) as operands for the bitwise operation, plus the byteorder. You will
    recall that the `*` in the parameter list forces all parameters after it, namely
    `byteorder`, to be keyword-only arguments. I don’t offer a default argument for
    `byteorder`, for the same reason `bytes` objects don’t have bitwise operators.
    If the user is unable to provide this argument explicitly, the function should
    fail, rather than potentially producing garbage output.    To convert the result
    back to `bytes` in the last step, I must know the size of the result (which should
    be size of the largest `bytes` object passed to it) so I don’t chop off leading
    or trailing zeros—or actual data, if this were for another bitwise operation!    Because
    `bytes` is a sequence, it implements the `__len__()` special method. In my function,
    I take the `max()` of the lengths of the two `bytes` arguments, and I use that
    value as the size of the output. Here’s the next piece of the function I started
    in [Listing 12-36](#listing12-36):    [PRE45]    Listing 12-37: bitwise_via_int.py:2    I
    convert the `left` and `right` bytes-like objects to integers by using the `int.from_bytes()`
    method, employing the byte order passed to my function. Meanwhile, in writing
    my code, I must assume the arguments from [Listing 12-36](#listing12-36) are mutable,
    lest `bitwise_and()` have a risk of side effects.    Please note, *I am not using*
    `signed=True` *here*! This is utterly vital for the bitwise operation to turn
    out right. Otherwise, my function will interpret any bytes-like object with a
    `1` in the most significant bit as indicative of a negative integer. This would
    thereby pad the significant end of the integer with infinite `1`s. The effective
    result of `0xCCCCCC & 0xAAAA` according to this function would then be `0xCC8888`,
    rather than the correct value of `0x008888`.    Now that I have integer forms
    of these arguments, I can use the normal bitwise operator on them. Here’s the
    last piece of the function, continued from [Listing 12-37](#listing12-37):    [PRE46]    Listing
    12-38: bitwise_via_int.py:3    I bind the result of the bitwise operation to `result`.
    Finally, I convert `result` back to a `bytes` object, using the `size` I determined
    earlier, the `byteorder` passed to my function, and `signed=True` to handle conversion
    of any possible negative integer values. I return the resulting bytes-like object.    I’ll
    use my `bitwise_and()` function to perform a bitwise operation with any two bytes-like
    objects:    [PRE47]    Listing 12-39: bitwise_via_int.py:4    The result is exactly
    right! It doesn’t matter what bytes-like objects I pass to this function; it will
    work as expected.    ### Bitwise Operations via Iteration    The bitwise-via-integers
    approach is the most flexible, but it can be impractical when you’re working with
    a lot of data, since you’re duplicating the contents of the two `bytes` objects
    in `int`. For the algorithmic efficiency crowd, the integer approach has a space
    complexity of `Θ(n)`. Another option is to use iteration, instead of using integers
    as intermediary objects. Interestingly, both options have roughly the same time
    complexity. In fact, the iterative approach is slightly *slower*! Its strength
    is a lower space complexity, which lets it avoid excessive memory consumption
    when processing a large amount of data.    When you have a lot of binary data
    on which to perform bitwise operations, it’s sometimes better to leverage the
    iterable nature of bytes-like objects. Here, I’ll write another function for performing
    a bitwise operation on two bytes-like objects, this time with iteration:    [PRE48]    Listing
    12-40: bitwise_via_iter.py:1a    Within my `bitwise_and()` function, I employ
    a generator expression to create a new `bytes` object, which I ultimately return.
    Iterating over bytes-like objects yields positive integer values equivalent to
    each byte. The `zip()` function allows me to iterate over both the `left` and
    `right` bytes objects at the same time, and then I take the bitwise and (`&`)
    of the pair of integers produced on each iteration.    I use this function in
    much the same manner as with the integer version, except that I don’t need to
    bother with the byte order. The implicit byte order of the operands is used. (As
    mentioned earlier, it’s your responsibility to ensure the byte orders are the
    same!)    Here’s the usage of my function from [Listing 12-40](#listing12-40):    [PRE49]    Listing
    12-41: bitwise_via_iter.py:2    This present approach has one significant limitation:
    I can only reliably perform bitwise operations if the operands are the same length.
    Otherwise, the result will only be as long as the shortest operand object.    It
    is possible to work with operands of different sizes, but for that, I must know
    the byte order again, so I know which side to pad. It took me and my colleague
    Daniel Foerster a fair bit of back-and-forth to work out a reliable and Pythonic
    solution to this particular problem.    Here’s an expanded form of the iterative
    `bitwise_and()` function from [Listing 12-40](#listing12-40), which now handles
    bytes-like objects of different sizes:    [PRE50]   **Listing 12-42: bitwise_via_iter.py:1b    I
    create `pad_left` and `pad_right`, which are iterables for the padding on the
    `left` or `right` operands, respectively. Each of these uses `itertools.repeat()`
    to produce the value `0` on each iteration, up to a particular number of iterations.
    That limit is calculated as how many more bytes the other operand has than one
    I’m padding, or zero if this operand is the larger of the two.    Next, I create
    two more iterables that combine the padding and the operand for each side of the
    bitwise operation. The byte order determines the order in which I combine the
    padding and operand iterables, as the padding must be applied to the higher-value
    end.    If anything other than `''big''` or `''little''` is passed to the `byteorder`
    parameter, I raise a `ValueError`. (The exception and its message I raise there
    are the same as what `int.from_bytes()` would raise with a nonsense `byteorder`
    argument.)    Finally, with the `left_iter` and `right_iter` iterables, which
    will produce the same number of bytes, I perform the iterative bitwise in a generator
    expression, as before.    The usage and return of this version of my `bitwise_and()`
    function is identical to that of the integer-based version:    [PRE51]    Listing
    12-43: bitwise_via_iter.py:2b    Again, the advantage of the iterative approach
    is that it is optimized for space complexity. In terms of time complexity, it
    is slower than the integer-based approach from earlier, so it should be reserved
    for working with particularly large bytes-like objects. Otherwise, stick with
    `int.from_bytes()` and `int.to_bytes()` for bitwise operations on bytes-like objects.    ##
    memoryview    When you’re slicing a bytes object, a copy of the data being sliced
    is created. Ordinarily, this has no negative effects, especially when you’re going
    to assign the data anyway. However, when you’re working with particularly large
    slices, especially repeatedly, all that copying can create some serious performance
    slowdowns.    The `memoryview` class helps alleviate that, by accessing the raw
    memory data of any object that implements the *buffer protocol*, a set of methods
    that provide and govern access to an underlying memory array. Bytes-like objects
    fit this qualification, and you’ll most often use `memoryview` with `bytes` and
    `bytearray`. You won’t often encounter the buffer protocol in any types other
    than binary-oriented objects, although `array.array` is a notable exception. (In
    fact, the buffer protocol is defined and implemented at the C level, rather than
    in Python itself, so implementing it in your own classes is decidedly nontrivial.)    Since
    `memoryview` is designed to provide very low-level access to memory, it has a
    lot of particularly advanced methods and concepts, which I won’t get into here.
    I will show you its most basic usage: slicing, or accessing a part of, a bytes-like
    object by reading in place, rather than by making a copy of the sliced data. Although
    this is only called for when dealing with particularly large buffers, I’ll demonstrate
    with a small `bytes` object for brevity.    In this example, I want to employ
    slicing to confirm that a bit of binary data fits a particular format—perhaps
    that two `0xFF` bytes appear after every three bytes. (Why I’d do this in the
    real world is beyond me; I just needed an example.) Effectively, I want to slice
    the fourth and fifth bytes from every five bytes, as the first three of each set
    of five can be anything.    I’ll start with the version without `memoryview` first,
    for reference:    [PRE52]    Listing 12-44: slicing_with_memoryview.py:1a    With
    this function, I iterate based on the fourth byte (the first in the pair), via
    the `for` loop. As soon as I reach the end of `bits`, I know I’ve processed everything.
    (If this ever slices out only the last byte, the code runs just fine and returns
    `False`, as it should.)    Within each iteration of my loop, I slice out the two
    bytes I care about with `bits[i:i+2]` and compare that to the `b''\xff\xff''`
    I’m checking for. If it doesn’t match, I immediately return `False`. However,
    if the code makes it through the loop without that condition failing, then the
    function returns `True`.    Here’s the usage:    [PRE53]    Listing 12-45: slicing_with_memoryview.py:2    As
    I mentioned, this code is perfectly fine in most cases. When I slice, I make a
    copy of those two bytes. But if that slice is something on the order of two *kilobytes*
    in length, with hundreds of slices being made, I may run into some serious performance
    issues with all that copying.    This is where `memoryview` comes in handy. I’ll
    update my example to use that instead.    [PRE54]    Listing 12-46: slicing_with_memoryview.py:1b    The
    code is functionally the same as before, except that this time, I create a `memoryview`
    object, which I bind to the name `view`, to give me direct access to the underlying
    memory of `bits`.    I can use `memoryview` in essentially the same way as I would
    `bytes`, except that slicing on a `memoryview` only views the data in place, rather
    than creating a copy of the data.    It is *vital* that I release the `memoryview`
    as soon as I’m done with it, by calling the `release()` method on my `memoryview`
    object. Objects that support the buffer protocol know when they’re being watched
    by a `memoryview`, and they will change their behavior in various ways to prevent
    memory errors. For example, a `bytearray` object will not resize as long as there’s
    a `memoryview` of it. It is always safe to call the `release()` method; at worst,
    it will do nothing at all. Once I release a `memoryview`, I cannot use it further.
    Attempting to do so would raise a `ValueError`.    Unfortunately, my code is still
    rather un-Pythonic, what with having to assign a value to `is_good` and return
    with that name at the function end. I’d like to polish that up.    Hmm . . . I
    have to remember to close something when I’m finished with it. Surely, that means
    `memoryview` is also a context manager that I can use in a `with` statement. Sure
    enough, that works! I can incorporate that technique to make my function more
    concise and Pythonic:    [PRE55]    Listing 12-47: slicing_with_memoryview.py:1c    That’s
    more like it. This code still behaves the same as the preceding two versions,
    but it reads cleaner and doesn’t make copies of the data it’s slicing out. The
    usage and outcome are the same as in [Listing 12-45](#listing12-45).    ## Reading
    and Writing Binary Files    Just as you can write strings out to a file using
    a stream, you can use a stream to write binary data to a file. Binary file formats,
    as you’ll see later, have a few advantages over text-based file formats, especially
    in terms of compact file sizes and faster processing. The techniques are almost
    identical to those in Chapter 11, with one critical difference: the stream must
    be opened in *binary mode*, instead of the default text mode. This returns a `BufferedReader`,
    `BufferedWriter`, or `BufferedRandom` object, depending on the mode you open with
    (see Table 11-1 from Chapter 11).    There are a number of existing file formats
    for storing data in binary, which I’ll discuss later, but for this example, I’ll
    create my own format using `struct`. This may be called for sometimes in your
    own projects, when you need to store very specific data in a particular manner.
    Designing your own binary file format can require considerable thought and planning,
    but when done right, a custom file format can be made to fit your data like a
    glove. As you’ll see, `struct` is particularly suitable for this, because of its
    format strings.    ### Organizing the Data    In this section, I’ll create a basic
    class structure for keeping track of a personal bookshelf. Ultimately, I’ll be
    able to write this bookshelf data to a binary stream (including a binary file)
    and create a bookshelf from a binary stream.    I’ll break my code down into three
    files: *book.py*, *bookshelf.py*, and *__main__.py*, all in the same package.
    That package will also need to contain an *__init__.py* file, which will be empty
    in this case. All of these files will go into a directory, *rw_binary_example/*,
    which will become the package. Here’s my file structure for the example:    [PRE56]    Listing
    12-48: File structure of rw_binary_example/ package    #### The Book class    The
    basic unit of data in my code is a `Book`, which I’ll write as its own class:    [PRE57]    Listing
    12-49: book.py:1    Most of this will look familiar by now. A book has a `title`,
    an `author`, a page count (`pages`), and an instance attribute for tracking how
    many pages have been read (`pages_read`). I also provide an `update_progress()`
    method to update the number of pages the user has read so far.    The line of
    particular interest here is the one where I define the class attribute `packer`.
    I bind this name to a `Struct` object, wherein I define the binary format for
    my object in a format string ❶. Here, I use the `Struct` object instead of the
    `pack()` function directly from the `struct` module. I do this for two reasons:
    (1) so there’s a single canonical source for the binary format I’m using and (2)
    because it means the format string is *precompiled* into a Python bytecode object,
    making for more efficient reuse.    I’m using big-endian byte order, not only
    because it’s familiar, but also because it’s what I’d use if I wanted to send
    this data over the internet (although I’m not doing so here). If I have to make
    a somewhat arbitrary decision, like choosing a byte order, I might as well maximize
    the possibilities of what I can do with the data!    I’ll also set a limit on
    the size of my string. I need a predictable format so I can read from the binary
    data later, and working with data that varies in size can be forbiddingly difficult.
    For my program, I set a size limit of 64 bytes, which should be sufficient for
    encoding most book titles and authors. I use `64s` in my format string to denote
    the `struct` fields for title and author. I also follow each of these fields with
    a padding byte (`x`), which will guarantee that these fields can always be interpreted
    as C-style null-terminated strings, even if all 64 characters are used. That makes
    for one less potential bug if my data needs to be interpreted by code in another
    programming language.    I also specify two 2-byte (short) integers (`2h`) for
    storing the page count and pages read. This should be sufficient space for both,
    since a book with more than 32,767 pages is rather an absurd idea. (I could also
    make this number unsigned, but I don’t really need the slightly higher maximum
    value. Perhaps I’ll find a clever use for negative values in a later version of
    my code.) If I try to pack too large a value into a struct field, a `struct.error`
    exception will be raised.    Now that I have my class and its format string, I
    can write an instance method for converting to binary the book data from the `Book`
    class I started in [Listing 12-49](#listing12-49):    [PRE58]    Listing 12-50:
    book.py:2    To use the precompiled format string from earlier, I call the `pack()`
    method on the `self.packer` instance attribute, instead of using `struct.pack()`.
    I only need to pass the data I’m packing into binary.    I must call the `encode()`
    method on each of my strings to convert them from UTF-8 to bytes literal strings.
    I could also have used `self.title.encode(encoding=''utf-8'')` to explicitly specify
    the encoding. I might specify the encoding if I were using some string encoding
    other than the default UTF-8.    The integer values, `self.pages` and `self.pages_read`,
    can be passed as is.    The `self.packer.pack()` method returns a bytes object,
    which I then return from the `serialize` method.    #### The Bookshelf class    My
    program will store a collection of `Book` objects in a `Bookshelf`, which will
    be little more than a thin wrapper around a list:    [PRE59]    Listing 12-51:
    bookshelf.py:1    I’m importing the `Book` class from the `book` module that lives
    in the same package as this module, so I use a relative import, as seen on the
    first line.    The `Bookshelf` class initializes the list, `self.shelf`, which
    will store any book objects passed as arguments to the initializer. Users can
    also add more books to the shelf with the `add_books()` method.    I allow iterating
    over the books directly by returning the iterator for the list from `__iter__()`,
    as there’s no need to reinvent the wheel here.    I could add some other features,
    such as removing or looking up specific books, but I want to keep this simple,
    to focus on converting this data to binary.    Most important to this example
    is the additional `Struct` that I’ve created and bound to `fileinfo`. I’ll use
    it to store the file format ❶. Along with that, I have a `version` class attribute
    for tracking the file format version number. This way, if I later change my *.shlf*
    file format, I can tell my future code how to read both the old and the new files.    I
    define a method for writing this data to a binary stream. You’ll recall from Chapter
    11 that files are opened as streams. I can also apply these same techniques to
    send the data to another process or over a network to another machine.    [PRE60]    Listing
    12-52: bookshelf.py:2    The `write_to_stream()` method accepts a stream object
    as an argument. I write the *.shlf* file format version, `version`, to the binary
    stream first. My code can later check this first value and ensure the *.shlf*
    file being read follows the expected format.    Next, I iterate over the `Book`
    objects in the `self.shelf` list, call the `serialize()` method on each book,
    and write the returned bytes object to the stream using `stream.write()`. Since
    the stream automatically moves its position to the end of the last data I wrote
    to the binary file, I don’t need to call `stream.seek()` at any point.    ###
    Writing to a File    Now, I can put my `Book` and `Bookshelf` classes to work
    to store some data:    [PRE61]    Listing 12-53: __main__.py:1    I import my
    `Book` and `Bookshelf` classes at the top of the module. In my `write_demo_file()`
    function, I create the new `Bookshelf` object `cheuk_ting_bookshelf` and fill
    it with some data. Cheuk Ting sure has good taste in books!    Next, within that
    same `write_file()` method, I add the following to open a file in binary write
    mode:    [PRE62]    Listing 12-54: __main__.py:2    You’ll recall from Chapter
    11 that including `b` in the mode string on `open()` will open the stream in *binary
    mode*, instead of the default text mode. I want to write out the file, overwriting
    its contents if the file already exists, so I use `w` mode.    To aid you in following
    this example, I’ll create a stub function for my `read_demo_file()` function now
    and fill it in later:    [PRE63]    Listing 12-55: __main__.py:3a    After opening
    my file, I pass it to the `write_to_stream()` method of my `cheuk_ting_bookshelf`
    object.    At the bottom of *__main__.py*, I must include the usual boilerplate
    for executing my `main()` function:    [PRE64]    Listing 12-56: *__main__.py:4a*    That’s
    it! Running the package (via `python3 -m rw_binary_example`) creates a new file
    in my current working directory entitled *mybookshelf.shlf*. If you open that
    file in a text editor capable of displaying binary files, such as Visual Studio
    Code, you’ll likely see the titles and authors of the books displayed amidst a
    bunch of strange symbols.    I’ve created a binary file containing my data! (I’ll
    admit, I did some serious chuckling to myself after I got this example working.)    ###
    Reading from a Binary File    The *.shlf* file I created is merely a blob of binary
    data, with no information on how to read it. For my *.shlf* format to be of any
    use, I need to expand my program to be able to read in the data from *.shlf* files,
    converting that binary data back into strings and integers.    In the `Book` class
    again, I add a method for creating a new object from the binary data I would read
    from a *.shlf* file:    [PRE65]    Listing 12-57: *book.py:3*    I’ve chosen to
    make this a class method, rather than an instance method, to prevent the undesired
    side effect of overwriting another book. The method accepts a bytes object, and
    I use the `Book.packer` class attribute (see [Listing 12-49](#listing12-49)) to
    unpack the binary data into four names.    I use `decode()` to convert the strings
    from bytes to UTF-8\. As before, if I were decoding into anything other than UTF-8,
    I’d need to specify the encoding via the `encoding=` parameter of `decode()`.    The
    `unpack()` method automatically converts the integer values to `int`.    Finally,
    within this same `deserialize()` class method, I create and return a new `Book`
    object from the values I unpacked:    [PRE66]    Listing 12-58: *book.py:4*    I’ll
    put this new class method to work in my `Bookshelf` class.    Next, I’ll add a
    `from_stream()` class method for creating a new Bookshelf from a binary stream:    [PRE67]    Listing
    12-59: *bookshelf.py:3*    My `from_stream()` class method receives a stream object
    as an argument, `stream`.    Before I do any processing, I need to check the format
    version of a *.shlf* file, in case some user in the future tries to open a (theoretical,
    for now) version-2 file with this package. To do that, I first determine how many
    bytes to read off the beginning of my file, where I stored the version data. `Struct`
    objects like `cls.fileinfo` (see [Listing 12-51](#listing12-51)) have a `size`
    attribute, which returns an integer representing the exact number of bytes needed
    to represent data packed into that `Struct`.    I read the number of bytes indicated
    by `size` from the binary stream using `stream.read(size)`, and I pass the returned
    bytes literal to `cls.fileinfo.unpack()`. That returns a tuple of values, but
    as the tuple has only one value in this case, I must be careful to unpack that
    value into `version`, rather than binding the tuple itself to that name.    I
    check the returned file format version before proceeding, raising a `ValueError`
    if the format version is wrong for this code. A future expanded version of this
    code might allow me to switch which `Struct` object I use in the `Book` module,
    based on the format version of the file being read.    Now, I prepare to read
    the data for the individual books:    [PRE68]    Listing 12-60: *bookshelf.py:4*    I
    get the size in bytes of the `Struct` object the `Book` class uses, and I store
    that in `size`. I instantiate a new `Bookshelf` object, which I bind to `shelf`.
    I’m now ready to read the rest of the data in the binary stream:    [PRE69]    Listing
    12-61: *bookshelf.py:5*    Within the header of a loop, I use `stream.read(size)`
    to read the next segment of data from the binary stream, which I bind to `bits`.
    I’m using an *assignment expression*, via the *walrus operator*, in this context,
    so I can also check the value of `bits` right here in the loop header. Then, I
    implicitly check that *bits* is not an empty bytes literal (`bytes()`)—the value
    of `bits` will be “falsey,” or implicitly evaluate to `False` in the conditional,
    only if it is actually empty—which would indicate that I’ve reached the end of
    the stream. Any other value of `bits`, even `b''\x00''`, would cause this expression
    to evaluate to `True`.    Within the suite of this loop, I create a new `Book`
    from the binary data in `bits`, using the `Book.deserialize()` class method. Then,
    I add that `Book` object to the `Bookshelf` object bound to `shelf`, which I build
    here.    Finally, after the loop completes, I return `shelf`.    Because of how
    I’ve structured the `Bookshelf` and `Book` classes, the code for reading a *.shlf*
    file is quite elegant. I’ll fill in my `read_demo_file()` function in the *__main__.py*
    module now.    Laís received some book recommendations from her friend Cheuk Ting
    in a *.shlf* file, so she needs to open that file. Here is the code that allows
    her to do so with the `Bookshelf` class:    [PRE70]    Listing 12-62: *__main__.py:3b*    I
    open the *mybookshelf.shlf* file in *binary read* mode (`br`). I pass the `file`
    stream object to `Bookshelf.from_stream()`, and then I bind the resulting `Bookshelf`
    object to `lais_bookshelf`.    Finally, to verify everything has worked, I iterate
    over each book in `lais_bookshelf` and print the titles.    I must be certain
    to call `read_demo_file()`:    [PRE71]    Listing 12-63: *__main__.py:4b*    Running
    that code outputs the following:    [PRE72]    Laís’s bookshelf is now identical
    to Cheuk Ting’s!    I hope Cheuk Ting remembers to recommend *Dead Simple Python*
    to Laís, too, after she gets done with it.    ### Seek with Binary Stream    When
    working with streams, you can change stream position if you only want to read
    or modify part of a stream, rather than traversing or processing the whole thing.
    Recall from Chapter 11 that you can work with the stream position on a text stream
    using the `tell()` and `seek()` methods. You can use these same methods with binary
    stream objects, namely `BufferedReader`, `BufferedWriter`, and `BufferedRandom`,
    but with some additional functionality on `seek()`.    The `seek()` method accepts
    two arguments. The first is `offset`, which is the number of bytes to move in
    the stream. Positive offset values move forward, and negative offset values move
    backward.    The second argument is `whence`, which provides the starting position
    that `offset` moves from. With text streams, the offset must be zero. That limitation
    doesn’t exist on binary streams!    With binary streams, there are three possible
    values for whence: `0` for start, `1` for current position, and `2` for end. If
    I wanted to seek to six bytes from the end of a stream, I’d do something like
    this:    [PRE73]    Listing 12-64: *seek_binary_stream.py:1*    Providing a whence
    of `2` means I start seeking from the end of the stream, and the offset argument
    of `-6` moves back six bytes from there.    Similarly, if I then wanted to move
    forward two bytes from the current stream position, I’d use the following:    [PRE74]    Listing
    12-65: *seek_binary_stream.py:2*    The whence argument of `1` starts the seek
    from the current position, and the offset argument of `2` moves forward two bytes
    from there.    One word of caution when using `seek()`: only use positive offsets
    when starting at the beginning of your file (a whence of `0`, the default), or
    the statement will raise an `OSError`. Similarly, be careful not to rewind past
    the start of the stream when using a negative offset and a whence of `1`.    Always
    use negative offsets when starting at the end of your file (a whence of `2`).
    Positive offsets won’t raise an error, but seeking past the end of the buffer
    is rather pointless, if benign. Seeking past the end and then writing data to
    the buffer from that position will actually drop said data into a black hole;
    it won’t be written to the stream. If you want to append to a stream, position
    yourself at the end with `file.seek(0, 2)`.    ### BufferedRWPair    One of the
    fun things about writing a book like *Dead Simple Python* is discovering unfamiliar
    techniques. While perusing the Python documentation for this section, I learned
    about another type of binary stream called a `BufferedRWPair`, which accepts two
    stream objects: one to read from and another to write from. (These *must* be different
    stream objects!)    The primary use of `BufferedRWPair` is in working with a socket
    or a two-way pipe, wherein your code communicates with another process on the
    system through two separate buffers: one for receiving data from the other process
    and another for sending data.    Another use would be to simplify the process
    of reading data from one source, possibly process it, and then send it somewhere
    else. For example, I could use this to read data from a device’s serial port and
    write it directly out to a file.    I won’t write a full example for this here,
    as it would be fairly involved and likely use topics I haven’t covered. (I prefer
    to stay reasonably relevant.) The usage of `BufferedRWPair` is about the same
    as any other byte stream, except that you’d explicitly initialize it by passing
    two streams: one to read and one to write.    For a simple example, I’ll first
    create a binary file containing some data using the normal means:    [PRE75]    Listing
    12-66: *creating_bufferedrwpair.py:1*    This code only creates the file *readfrom.dat*,
    so I have something to read from in the important part of the example.    I create
    a `BufferedRWPair` by passing it a stream to read and a stream to write. I’ll
    use the `open()` method on `Path` to create the streams:    [PRE76]    Listing
    12-67: *creating_bufferedrwpair.py:2*    To verify this works, I’ll open *writeto.dat*
    directly in read mode to see its contents:    [PRE77]    Listing 12-68: *creating_bufferedrwpair.py:3*    That’s
    clearly an oversimplified example, but you get the essential idea. There are many
    uses for `BufferedRWPair` in advanced situations. Chances are, you’ll know when
    you need it.    ## Serialization Techniques    As mentioned in Chapter 11, *serialization*
    is the process of converting data to a format that can be stored. This data can
    be written to a file, transmitted over a network, or even shared between processes.
    The inverse operation is *deserialization*, which converts the serialized data
    back into its original form, or at least a close equivalent.    I also touched
    on a number of formats used for serialization, especially JSON and CSV. All of
    these formats were text based and intended to be human readable, which makes them
    excellent candidates for files that the user should be able to modify by hand.
    Human-readable formats are also *futureproof*, meaning in this case that the deserialization
    process can be reverse engineered if the presently used technology or format specification
    ever ceases to exist. (And that happens more often than you might think!)    There
    are a few disadvantages of using human-readable, text-based serialization formats,
    rather than *binary* serialization formats. The first is size: it will virtually
    always take more memory to represent non-string data as a string than to use its
    original, binary form. Text-based formats are also often slower to deserialize,
    in contrast to binary formats. This is one reason why binary formats are better
    suited to the *virtual machine* design pattern, wherein different bytes correspond
    to different behaviors. Most interpreted languages, including Python itself, use
    some form of this design pattern internally.    The third disadvantage of text-based
    serialization formats is the same as one of its advantages: the file can be easily
    modified. You may want to discourage users from directly editing particularly
    complex or fragile data, as minor errors can corrupt the file. Using binary serialization
    formats is an effective way of discouraging file tampering.    A good example
    of this is *Minecraft’s .dat* file format, which contains serialized game world
    data in a binary format. (The fact that *Minecraft* is written in Java is beside
    the point; principles of serialization are language agnostic.) It’s important
    to note that obfuscation is not an effective security technique. *Minecraft* *.dat*
    files are still editable by the end user, as evidenced by third-party programs
    like MCEdit.    If you want to protect your serialized data, *encryption* is your
    only answer. How you apply encryption depends on your situation.    For example,
    the space simulator game *Oolite* uses XML to serialize player data so the file
    can still be read and edited by the user, but it includes a hash string of the
    data in the file so the game can detect cheating and make minor adjustments to
    gameplay.    In an application where security really matters, the serialized data
    will often be fully encrypted. Many applications will store saved passwords in
    this manner, encrypted behind a master password or key, to prevent the data from
    being intercepted. The passwords must be serialized and stored to disk for the
    program to retain them, but the encryption ensures that no one else can deserialize
    the data.    In short, your decision on whether to use text-based or binary serialization
    depends entirely on your situation. Binary serialization can offer smaller file
    sizes, faster deserialization, and the added benefit of discouraging tampering
    by end users. However, binary-based formats are not as futureproof as text-based
    formats, and they can also give users an uneasy feeling of opacity about the data.
    These are the reasons why they’re seldom used for serializing settings.    ###
    Forbidden Tools: pickle, marshal, and shelve    *Pickle* is a common built-in
    serialization tool. It stores Python objects in a binary format that can be saved
    to a file and then later deserialized, or *unpickled*, into a Python object again.
    Sounds perfect, right?    There’s a big red box at the top of the documentation
    that screams about security concerns with `pickle`, and it may be tempting to
    overlook that. “This is merely a calculator app,” a developer might say. “Security
    doesn’t matter here.”    Except the security here has nothing to do with the data
    itself. Pickled data can be tampered with to execute arbitrary code, meaning if
    you use `pickle` for serialization, your Python program can be made to do *literally
    anything*. If someone modifies pickled data on a user’s machine, which isn’t difficult
    to do, your harmless Python program will become malware as soon as it unpickles
    that file.    It’s possible to guard against file tampering by signing data with
    a message authentication module called `hmac`, but at that point, it would be
    more straightforward to use the other techniques from this chapter to serialize
    data in a secure fashion. Pickled data isn’t intended to make sense outside of
    Python anyway, whereas a custom serialization approach *could* be made portable.    What’s
    more, `pickle` is painfully slow and produces some pretty bloated files. It’s
    practically the most inefficient way to serialize anything to a file, even before
    I consider security.    There are two related built-in tools in Python: `marshal`
    and `shelve`. The former, `marshal`, is really only intended to be used internally
    by Python, as its deliberately undocumented specification can change between Python
    versions. It also has the same issues related to security and performance as does
    `pickle`, so it shouldn’t be considered an alternative. Even if it were perfect,
    it would still not be intended for your use.    The `shelve` module is built on
    `pickle`, and it should be dismissed for the same reasons as `pickle`.    Frankly,
    `pickle`, `marshal`, and `shelve` offer no advantages over other serialization-to-file
    techniques. They’re like `sudo pip`: they *appear* to work until they completely
    kick the pooch, at which point, you discover in the most painful way possible
    how much evil they conceal.    Ignore the myriad tutorials and misguided Stack
    Overflow answers on this one. Unless you’re transferring data directly between
    processes, please forget that these modules exist at all, except to warn other
    Python developers away from them. Leave the `pickle` in the fridge.    You may
    wonder why these modules are even included in the standard library in the first
    place. There are a few factors.    First, `pickle` does have one valid use: transferring
    data between running processes. This is safe because the data is never written
    to a file. Speed and size are still problems here, but there are efforts to mitigate
    these issues, as it’s believed to be easier to redeem `pickle` than to invent
    a whole new protocol. Python 3.8 saw a new version of the `pickle` protocol, which
    is meant to improve handling of large data (see PEP 574). I’ll revisit `pickle`
    in Chapter 17, when I cover multiprocessing.    Second, plenty of Python code
    exists that relies on these modules. At one time, `pickle` was considered the
    “one obvious way” of serializing data, although it has long since fallen out of
    favor as its flaws have become apparent. There’s already a move to deprecate and
    remove many so-called “dead batteries” (a reference to Python’s “batteries included”
    nature) from the standard library, but `pickle` isn’t on that list because of
    its use in multiprocessing.    That leaves only one solution: accept that `pickle`,
    `marshal`, and `shelve` have their uses, but that serialization-to-file is not
    among them.    ### Serialization Formats    So if `pickle` and friends are out,
    what options remain? Thankfully, quite a few! I’ve compiled a short list of some
    of the most common and popular binary serialization formats, but it is far from
    exhaustive. If you are interested in any of these file formats, peruse the official
    documentation for the associated module or library.    #### Property List    The
    *property list*, or *.plist* file, is a serialization format that was created
    for the NeXTSTEP operating system in the 1980s and was further developed for its
    descendants: macOS and GNUstep. Although it is primarily used with these platforms,
    you can certainly employ property lists in your own project. This is one of the
    best ways to perform binary serialization without `pickle`.    There are two major
    flavors of property list: binary and the human-readable, XML-based form. Both
    can be serialized and deserialized with the built-in `plistlib` module.    One
    of the advantages of property lists in Python is that they can directly serialize
    most basic types, including dictionaries, which are frequently used as the top-level
    objects (like with JSON).    To learn more, read the official documentation at
    [https://docs.python.org/3/library/plistlib.xhtml](https://docs.python.org/3/library/plistlib.xhtml).    ####
    MessagePack    One of the leading formats for binary serialization is *MessagePack*,
    which is designed to produce simple, compact serialized output. It is based on
    JSON, and for the most part, it can represent the same sort of data.    The official
    third-party package, *msgpack*, can be installed via pip. More information and
    official documentation can be found on the MessagePack website: [https://msgpack.org/](https://msgpack.org/).    ####
    BSON    Another binary serialization format based on JSON is called *BSON* (for
    “binary JSON”). Being a binary format, BSON is much faster to deserialize than
    JSON. It also usually produces files that are smaller, though still larger than
    those produced by MessagePack. In certain situations, BSON files can even be larger
    than the equivalent JSON file. BSON also provides some additional types over MessagePack.    As
    MongoDB makes significant use of the BSON format, the MongoDB package for Python,
    *pymongo*, provides a *bson* package. A fork of this package is also available
    simply as *bson*, if you don’t want the whole *pymongo* package. You can also
    learn more about BSON from the specification’s official website: [http://bsonspec.org/](http://bsonspec.org/).    ####
    CBOR    The *Concise Binary Object Representation*, or *CBOR*, is a binary serialization
    format that focuses on concise encoding. Like BSON and MessagePack, it is also
    based on the JSON data model. Unlike its cousins, CBOR is officially defined as
    an internet standard by the Internet Engineering Task Force in RFC 8949, and it
    is employed in the Internet of Things.    There are a few packages available through
    pip for working with CBOR, the most up-to-date of which is *cbor2*. More information
    about the format is available from the official website: [https://cbor.io/](https://cbor.io/).    ####
    NetCDF    The *Network Common Data Form*, or *NetCDF*, is a binary serialization
    format designed primarily for working with array-oriented scientific data. It
    was created in 1989, based on NASA’s Common Data Format, although the two formats
    are no longer compatible. NetCDF is still maintained by the *University Corporation
    for Atmospheric Research* (*UCAR*).    The *netCDF4* package from pip provides
    modules for working with the NetCDF format. You can also learn more about the
    format at [https://www.unidata.ucar.edu/software/netcdf/](https://www.unidata.ucar.edu/software/netcdf/).    ####
    Hierarchial Data Format    The *Hierarchial Data Format*, or *HDF*, is a binary
    serialization format designed for storing large amounts of data. It is developed
    and maintained by the not-for-profit HDF Group, and it is used heavily in science,
    engineering, finance, data analysis, and even creative projects. It has had a
    central role in some major NASA projects, and it was employed in producing movies
    such as *The Lord of the Rings* and *Spider-Man 3*.    HDF5 is the latest version
    of the format and is the current recommended standard. The HDF Group still supports
    and maintains HDF4.    A number of third-party modules exist for working with
    HDF. Two of the leading options are *h5py* and *tables*. More information about
    the format is available from The HDF Group’s website: [https://www.hdfgroup.org/](https://www.hdfgroup.org/).    ####
    Protocol Buffers    Google’s *Protocol Buffers* is an increasingly popular binary
    serialization format, but I’m addressing it last because it operates in a very
    different manner from the others.    Unlike in most formats, which have existing
    standard specifications, you define a tailor-made specification for your file
    in a special *.proto* schema file. This schema is then compiled into your favorite
    language, using Google’s proto compiler; in the case of Python, it produces a
    Python module. You would then use this generated module for serialization and
    deserialization, according to the specification you created.    If you’re interested
    in this, refer to Google’s official documentation: [https://developers.google.com/protocol-buffers/docs/pythontutorial](https://developers.google.com/protocol-buffers/docs/pythontutorial).    ####
    A Few More    There are also a number of binary serialization formats designed
    for specific purposes, such as *GRIB* in meteorology and *FITS* in astronomy.
    Often, the best way to find a serialization format that fits your purpose is to
    think about your data first, how it should be stored, and in what situations it
    needs to be deserialized. Once you find a format that fits your particular need,
    find (or write) a module to work with it in Python.    ## Wrapping Up    Binary
    is the language of computers. It is one of the most reliable ways for your program
    to share data outside of itself, whether through files (as you’ve seen here) or
    across processes or networks. Binary serialization formats generally offer smaller
    file sizes and faster deserialization than text-based formats, at the cost of
    less human readability. Whether you should use text or binary for any particular
    task partly depends on your audience: *text is for humans, binary is for computers*.
    Besides this, consider the available tooling for any given format and its suitability
    for the data you want to encode. For example, even if a user will never need to
    interact with a settings file, *.json* remains a popular format, if for no other
    reason than the ease of debugging it!    The goal of a programmer is ultimately
    to serve as the translator between humans and computers. It takes time to master
    thinking in bits and bytes, binary and hexadecimal, but it’s a skill well worth
    cultivating. No matter how high up the tower of abstractions a programmer climbs,
    they can never really escape the fundamental computer language upon which everything
    is built. An expert programmer is one who is fluent in both human language and
    computer logic; the more you know of both, the better you can utilize the tools
    Python or any other language offers you.**[PRE78]``'
  prefs: []
  type: TYPE_NORMAL
