["```py\nfor k, v in mydict.iteritems():\n    print(k, v)\n```", "```py\nimport six\n\nfor k, v in six.iteritems(mydict):\n    print(k, v)\n```", "```py\nfrom six.moves.configparser import ConfigParser\n\nconf = ConfigParser()\n```", "```py\n(defclass snare-drum ()\n  ())\n\n(defclass cymbal ()\n  ())\n\n(defclass stick ()\n  ())\n\n(defclass brushes ()\n  ())\n```", "```py\n(defgeneric play (instrument accessory)\n  (:documentation \"Play sound with instrument and accessory.\"))\n```", "```py\n(defmethod play ((instrument snare-drum) (accessory stick))\n  \"POC!\")\n\n(defmethod play ((instrument snare-drum) (accessory brushes))\n  \"SHHHH!\")\n\n(defmethod play ((instrument cymbal) (accessory brushes))\n  \"FRCCCHHT!\")\n```", "```py\n* (play (make-instance 'snare-drum) (make-instance 'stick))\n\"POC!\"\n\n* (play (make-instance 'snare-drum) (make-instance 'brushes))\n\"SHHHH!\"\n```", "```py\n* (play (make-instance 'cymbal) (make-instance 'stick))\ndebugger invoked on a SIMPLE-ERROR in thread\n#<THREAD \"main thread\" RUNNING {1002ADAF23}>:\n  There is no applicable method for the generic function\n    #<STANDARD-GENERIC-FUNCTION PLAY (2)>\n  when called with arguments\n    (#<CYMBAL {1002B801D3}> #<STICK {1002B82763}>).\n\nType HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.\n\nrestarts (invokable by number or by possibly abbreviated name):\n  0: [RETRY] Retry calling the generic function.\n  1: [ABORT] Exit debugger, returning to top level.\n\n((:METHOD NO-APPLICABLE-METHOD (T)) #<STANDARD-GENERIC-FUNCTION PLAY (2)>\n#<CYMBAL {1002B801D3}> #<STICK {1002B82763}>) [fast-method]\n```", "```py\n   import functools\n\n   class SnareDrum(object): pass\n   class Cymbal(object): pass\n   class Stick(object): pass\n   class Brushes(object): pass\n\n   @functools.singledispatch\n   def play(instrument, accessory):\n       raise NotImplementedError(\"Cannot play these\")\n\n➊ @play.register(SnareDrum)\n   def _(instrument, accessory):\n       if isinstance(accessory, Stick):\n           return \"POC!\"\n       if isinstance(accessory, Brushes):\n           return \"SHHHH!\"\n       raise NotImplementedError(\"Cannot play these\")\n\n   @play.register(Cymbal)\n   def _(instrument, accessory):\n       if isinstance(accessory, Brushes):\n           return \"FRCCCHHT!\"\n       raise NotImplementedError(\"Cannot play these\")\n```", "```py\n>>> play(SnareDrum(), Stick())\n'POC!'\n>>> play(SnareDrum(), Brushes())\n'SHHHH!'\n>>> play(Cymbal(), Stick())\nTraceback (most recent call last):\nNotImplementedError: Cannot play these\n>>> play(SnareDrum(), Cymbal())\nNotImplementedError: Cannot play these\n```", "```py\nwith open(\"myfile\", \"r\") as f:\n   line = f.readline()\n```", "```py\nclass MyContext(object):\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n```", "```py\nimport contextlib\n\n@contextlib.contextmanager\ndef MyContext():\n    print(\"do something first\")\n    yield\n    print(\"do something else\")\n\nwith MyContext():\n    print(\"hello world\")\n```", "```py\ndo something first\nhello world\ndo something else\n```", "```py\nimport contextlib\n\n@contextlib.contextmanager\ndef MyContext():\n    print(\"do something first\")\n    yield 42\n    print(\"do something else\")\n\nwith MyContext() as value:\n    print(value)\n```", "```py\ndo something first\n42\ndo something else\n```", "```py\n   import contextlib\n\n   @contextlib.contextmanager\n   def MyContext():\n       print(\"do something first\")\n       try:\n           yield 42\n       finally:\n           print(\"do something else\")\n\n   with MyContext() as value:\n       print(\"about to raise\")\n➊     raise ValueError(\"let's try it\")\n       print(value)\n```", "```py\ndo something first\nabout to raise\ndo something else\nTraceback (most recent call last):\n  File \"<stdin>\", line 3, in <module>\nValueError: let's try it\n```", "```py\nwith open(\"file1\", \"r\") as source:\n    with open(\"file2\", \"w\") as destination:\n        destination.write(source.read())\n```", "```py\nwith open(\"file1\", \"r\") as source, open(\"file2\", \"w\") as destination:\n    destination.write(source.read())\n```", "```py\nclass Car(object):\n    def __init__(self, color, speed=0):\n        self.color = color\n        self.speed = speed\n```", "```py\nimport attr\n\n@attr.s\nclass Car(object):\n    color = attr.ib()\n    speed = attr.ib(default=0)\n```", "```py\n>>> Car(\"blue\")\nCar(color='blue', speed=0)\n```", "```py\n<__main__.Car object at 0x104ba4cf8>.\n```", "```py\nimport attr\n\n@attr.s\nclass Car(object):\n    color = attr.ib(converter=str)\n    speed = attr.ib(default=0)\n\n    @speed.validator\n    def speed_validator(self, attribute, value):\n        if value < 0:\n            raise ValueError(\"Value cannot be negative\")\n```", "```py\n>>> import attr\n>>> @attr.s(frozen=True)\n... class Car(object):\n...     color = attr.ib()\n...\n>>> {Car(\"blue\"), Car(\"blue\"), Car(\"red\")}\n{Car(color='red'), Car(color='blue')}\n>>> Car(\"blue\").color = \"red\"\nattr.exceptions.FrozenInstanceError\n```"]