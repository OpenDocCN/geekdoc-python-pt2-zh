- en: '[8](nsp-venkitachalam503045-0008.xhtml#rch08)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[8](nsp-venkitachalam503045-0008.xhtml#rch08)'
- en: Autostereograms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立体自视图
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Stare at [Figure 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1) for a minute.
    Do you see anything other than random dots? [Figure 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)
    is an *autostereogram*, a two-dimensional image that creates the illusion of three
    dimensions. Autostereograms usually consist of repeating patterns that resolve
    into three dimensions on closer inspection. If you can’t see any sort of image,
    don’t worry; it took me a while and a bit of experimentation before I could. (If
    you aren’t having any luck with the version printed in this book, try the color
    version in the *images* folder of the book’s GitHub repository. The footnote to
    the caption reveals what you should see.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 凝视[图 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)一分钟。你除了随机的点，还能看到其他东西吗？[图
    8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)是一个*立体自视图*，一个二维图像，它创造了三维的错觉。立体自视图通常由重复的图案组成，通过仔细观察可以解析出三维效果。如果你看不出任何图像，别担心；我自己也花了一段时间和一些实验才看出来。（如果你在本书中印刷的版本上没有成功，可以尝试本书GitHub仓库中的*图像*文件夹中的彩色版本。图注的脚注部分会告诉你应该看到的内容。）
- en: 'In this project, you’ll use Python to create autostereograms. Here are some
    of the concepts covered in this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将使用Python来创建立体自视图。以下是本项目中涉及的一些概念：
- en: • Linear spacing and depth perception
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 线性间距与深度感知
- en: • Depth maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 深度图
- en: • Creating and editing images using `Pillow`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`Pillow`创建和编辑图像
- en: • Drawing into images using `Pillow`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`Pillow`绘制图像
- en: '![](images/nsp-venkitachalam503045-f08001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08001.jpg)'
- en: 'Figure 8-1: A puzzling image that might gnaw at you[1](nsp-venkitachalam503045-0021.xhtml#fn1)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-1: 可能会让你困扰的图像[1](nsp-venkitachalam503045-0021.xhtml#fn1)'
- en: The autostereograms you’ll generate in this project are designed for “wall-eyed”
    viewing. The best way to see them is to focus your eyes on a point behind the
    image (such as a wall). Almost magically, once you perceive something in the patterns,
    your eyes should automatically bring it into focus, and when the three-dimensional
    image “locks in,” you’ll have a hard time shaking it off. (If you’re still having
    trouble viewing the image, see Gene Levin’s article “How to View Stereograms and
    Viewing Practice”[2](nsp-venkitachalam503045-0021.xhtml#fn2) for help.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本项目中生成的立体自视图是为“壁眼”观看设计的。最好的观看方法是将目光集中在图像后面的某个点（例如墙面）。几乎可以神奇地说，一旦你在图案中感知到某种东西，你的眼睛应该会自动将其聚焦，并且当三维图像“锁定”时，你将很难将其移开。（如果你仍然无法看到图像，可以参见Gene
    Levin的文章《如何查看立体图和观看练习》[2](nsp-venkitachalam503045-0021.xhtml#fn2)获得帮助。）
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1001)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1001)'
- en: An autostereogram starts as an image with a repeating tiled pattern. The hidden
    3D image is embedded into it by changing the linear spacing between the repeating
    patterns, thereby creating the illusion of depth. When you look at repeating patterns
    in an autostereogram, your brain can interpret the spacing as depth information,
    especially if there are multiple patterns with different spacing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 立体自视图开始时是一个具有重复拼接图案的图像。隐藏的三维图像通过改变重复图案之间的线性间距嵌入其中，从而产生深度的错觉。当你观察立体自视图中的重复图案时，大脑会将这些间距解读为深度信息，尤其是当图案间有不同的间距时。
- en: '[Perceiving Depth in an Autostereogram](nsp-venkitachalam503045-0008.xhtml#rbh1001)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在立体自视图中感知深度](nsp-venkitachalam503045-0008.xhtml#rbh1001)'
- en: When your eyes converge at an imaginary point behind the image, your brain matches
    the points seen by your left eye with a different group seen by your right eye,
    and you see these points lying on a plane behind the image. The perceived distance
    to this plane depends on the amount of spacing in the pattern. For example, [Figure
    8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2) shows three rows of *A*s. The
    *A*s are equidistant within each row, but their horizontal spacing increases from
    top to bottom.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的眼睛聚焦在图像后面的一个假想点时，大脑将你左眼看到的点与右眼看到的不同点进行匹配，并看到这些点位于图像后面的一个平面上。对这个平面的感知距离取决于图案中的间距。例如，[图
    8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)展示了三行*A*。这些*A*在每一行内等距，但从上到下它们的水平间距逐渐增大。
- en: '![](images/nsp-venkitachalam503045-f08002.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08002.jpg)'
- en: 'Figure 8-2: Linear spacing and depth perception'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-2: 线性间距与深度感知'
- en: When this image is viewed “wall-eyed,” the top row in [Figure 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)
    should appear to be behind the paper, the middle row should look like it’s a little
    behind the first row, and the bottom row should appear farthest from your eye.
    The text that says *floating text* should appear to “float” on top of these rows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个图像以“壁眼”方式观看时，[图 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)中的顶行应该看起来位于纸张的后面，中间的行看起来稍微在第一行之后，而底部的行则显得最远离你的眼睛。标有*浮动文字*的文字应该看起来像是在这些行的上方“漂浮”。
- en: Why does your brain interpret the spacing between these patterns as depth? Normally,
    when you look at a distant object, your eyes work together to focus and converge
    at the same point, with both eyes rotating inward to point directly at the object.
    But when viewing a “wall-eyed” autostereogram, focus and convergence happen at
    different locations. Your eyes focus on the autostereogram, but your brain sees
    the repeated patterns as coming from the same virtual (imaginary) object, and
    your eyes converge on a point behind the image, as shown in [Figure 8-3](nsp-venkitachalam503045-0021.xhtml#fig8-3).
    This combination of decoupled focus and convergence allows you to see depth in
    an autostereogram.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你的大脑会将这些图案之间的间距解读为深度呢？通常，当你看着一个远处的物体时，你的眼睛会共同工作，聚焦并在同一点汇聚，两只眼睛会向内旋转，直接指向物体。但当你以“壁眼”方式观看自立立体图时，聚焦和汇聚发生在不同的地方。你的眼睛聚焦在自立立体图上，但你的大脑看到这些重复的图案来自同一个虚拟（假想的）物体，而你的眼睛则会汇聚到图像后面的一点，如[图
    8-3](nsp-venkitachalam503045-0021.xhtml#fig8-3)所示。这种聚焦和汇聚的解耦结合使你能够在自立立体图中看到深度。
- en: '![](images/nsp-venkitachalam503045-f08003.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08003.jpg)'
- en: 'Figure 8-3: Seeing depth in autostereograms'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：在自立立体图中看到深度
- en: The perceived depth of the autostereogram depends on the horizontal spacing
    of pixels. Because the first row in [Figure 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)
    has the closest spacing, it appears in front of the other rows. However, if the
    spacing of the points were varied in the image, your brain would perceive each
    point at a different depth, and you could see a virtual three-dimensional image
    appear.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自立立体图的感知深度取决于像素的水平间距。因为[图 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)中的第一行像素间距最小，所以它看起来位于其他行的前面。然而，如果图像中的点间距发生变化，你的大脑会将每个点感知为不同的深度，你就能看到一个虚拟的三维图像出现。
- en: '[Working with Depth Maps](nsp-venkitachalam503045-0008.xhtml#rbh1002)'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[处理深度图](nsp-venkitachalam503045-0008.xhtml#rbh1002)'
- en: The hidden image in an autostereogram comes from a *depth map*, an image in
    which the value of each pixel represents a depth value, which is the distance
    from the eye to the part of the object represented by that pixel. A depth map
    is often shown as a grayscale image, with light areas for nearby points and darker
    areas for points farther away, as shown in [Figure 8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自立立体图中的隐藏图像来自于*深度图*，这是一种图像，其中每个像素的值代表一个深度值，即从眼睛到该像素所表示物体部分的距离。深度图通常以灰度图像形式显示，靠近的点显示为较亮区域，而远离的点则显示为较暗区域，如[图
    8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4)所示。
- en: '![](images/nsp-venkitachalam503045-f08004.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08004.jpg)'
- en: 'Figure 8-4: A depth map'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：深度图
- en: Notice that the nose of the shark, the lightest part of the image, seems closest
    to you. The darker area toward the tail seems farthest away. (By the way, the
    image in [Figure 8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4) is the same depth
    map used to create the first autostereogram shown in [Figure 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1).)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到鲨鱼的鼻子是图像中最亮的部分，看起来离你最近。向尾部的较暗区域则显得最远。（顺便提一下，[图 8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4)中的图像就是用来创建[图
    8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)中第一个自立立体图的深度图。）
- en: Because the depth map represents the depth or distance from the center of each
    pixel to the eye, you can use it to get the depth value associated with a pixel
    location in the image. You know that horizontal shifts are perceived as depth
    in images. So if you shift a pixel in a (patterned) image proportionally to the
    corresponding pixel’s depth value, you would create a depth perception for that
    pixel consistent with the depth map. If you do this for all pixels, you’ll end
    up encoding the entire depth map into the image, creating an autostereogram.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为深度图表示每个像素到眼睛的深度或距离，所以你可以使用它来获取与图像中像素位置相关的深度值。你知道水平位移在图像中被感知为深度。因此，如果你根据相应像素的深度值成比例地移动图像中的一个像素，你就会为该像素创建一个与深度图一致的深度感知。如果你对所有像素都这样做，你就会把整个深度图编码到图像中，生成一个自动立体图。
- en: Depth maps store depth values for each pixel, and the resolution of the value
    depends on the number of bits used to represent it. Because you’ll be using common
    8-bit images in this chapter, depth values will be in the range [0, 255].
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 深度图为每个像素存储深度值，该值的分辨率取决于表示它的位数。由于本章将使用常见的 8 位图像，深度值的范围是 [0, 255]。
- en: 'For the purposes of this project, I’ve posted several example depth maps to
    the book’s GitHub repository. You can download the maps and use them as input
    for generating autostereograms. However, you may also want to try making your
    own depth maps to create some fancier images. There are two approaches you can
    take: using synthetic images created with 3D modeling software or using photographs
    taken with a smartphone camera.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个项目，我已经将几个示例深度图上传到本书的 GitHub 仓库。你可以下载这些图像并将它们作为输入来生成自动立体图。不过，你也可以尝试自己制作深度图，创造一些更精美的图像。你可以采取两种方法：使用
    3D 建模软件创建的合成图像，或者使用智能手机相机拍摄的照片。
- en: Creating Depth Maps from 3D Models
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 3D 模型创建深度图
- en: If you create a 3D model of something using a 3D computer graphics program like
    Blender, you can also use the program to generate a depth map of the model. [Figure
    8-5](nsp-venkitachalam503045-0021.xhtml#fig8-5) shows an example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Blender 等 3D 计算机图形程序创建了某个物体的 3D 模型，你还可以使用该程序生成该模型的深度图。[图 8-5](nsp-venkitachalam503045-0021.xhtml#fig8-5)
    显示了一个示例。
- en: '![](images/nsp-venkitachalam503045-f08005a.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08005a.jpg)'
- en: (a)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f08005b.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08005b.jpg)'
- en: (b)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 8-5: A 3D model (a) and its associated depth map (b)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：一个 3D 模型 (a) 和其相关的深度图 (b)
- en: '[Figure 8-5(a)](nsp-venkitachalam503045-0021.xhtml#fig8-5) shows a 3D model
    rendered using Blender, and [Figure 8-5(b)](nsp-venkitachalam503045-0021.xhtml#fig8-5)
    shows the depth map created from this model. Search YouTube for “Blender depth
    map in 5 minutes!” for a tutorial[3](nsp-venkitachalam503045-0021.xhtml#fn3) from
    Jonty Schmidt on how to do this. The key is to color the image based on the Z-distance
    from the camera.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5(a)](nsp-venkitachalam503045-0021.xhtml#fig8-5) 显示了使用 Blender 渲染的 3D
    模型，[图 8-5(b)](nsp-venkitachalam503045-0021.xhtml#fig8-5) 显示了从该模型创建的深度图。可以在 YouTube
    上搜索 “Blender depth map in 5 minutes!” 查找 Jonty Schmidt 提供的教程[3](nsp-venkitachalam503045-0021.xhtml#fn3)，学习如何制作该深度图。关键是根据与相机的
    Z 距离为图像着色。'
- en: Creating Depth Maps from Smartphone Photographs
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从智能手机照片创建深度图
- en: These days, many smartphone cameras have a *portrait mode*, which captures depth
    information along with the photograph to selectively blur out the background.
    If you could get hold of this depth data, you’d have a depth map of the photograph
    that you can use to create an autostereogram! [Figure 8-6](nsp-venkitachalam503045-0021.xhtml#fig8-6)
    shows an example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多智能手机相机都有 *纵向模式*，它在拍摄照片时捕获深度信息，并选择性地模糊背景。如果你能够获取到这些深度数据，你将得到一张照片的深度图，可以用来创建自动立体图！[图
    8-6](nsp-venkitachalam503045-0021.xhtml#fig8-6) 显示了一个示例。
- en: '![](images/nsp-venkitachalam503045-f08006a.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08006a.jpg)'
- en: (a)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f08006b.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08006b.jpg)'
- en: (b)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 8-6: A portrait mode photo (a) and depth map (b) from an iPhone 11 camera'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：iPhone 11 相机拍摄的纵向模式照片 (a) 和深度图 (b)
- en: '[Figure 8-6(a)](nsp-venkitachalam503045-0021.xhtml#fig8-6) shows a photograph
    taken in portrait mode with an iPhone 11, and [Figure 8-6(b)](nsp-venkitachalam503045-0021.xhtml#fig8-6)
    shows the corresponding depth map. The depth map was created with the open source
    software ExifTool using this command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-6(a)](nsp-venkitachalam503045-0021.xhtml#fig8-6) 显示了使用 iPhone 11 拍摄的纵向模式照片，[图
    8-6(b)](nsp-venkitachalam503045-0021.xhtml#fig8-6) 显示了相应的深度图。该深度图是使用开源软件 ExifTool，通过以下命令创建的：'
- en: exiftool -b -MPImage2 photo.jpg > depth.jpg
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: exiftool -b -MPImage2 photo.jpg > depth.jpg
- en: 'This command extracts the depth information from the metadata in the file *photo.jpg*
    and saves it to the file *depth.jpg*. Download ExifTool from [https://exiftool.org](https://exiftool.org)
    to try the process for yourself. The command works for photos from an iPhone,
    but you can use similar techniques to extract the depth data from images taken
    with other types of phones. There are also various apps available on the Android
    and iOS app stores that can help you with this. Here’s one online depth map extractor
    that works with portrait mode images from a variety of phone models: [http://www.hasaranga.com/dmap](http://www.hasaranga.com/dmap/).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令从文件*photo.jpg*的元数据中提取深度信息，并将其保存到文件*depth.jpg*中。从[https://exiftool.org](https://exiftool.org)下载ExifTool，自己试试看。该命令适用于iPhone的照片，但你也可以使用类似的方法从其他类型手机拍摄的图像中提取深度数据。Android和iOS应用商店也有各种应用程序可以帮助你完成这个操作。这里有一个在线深度图提取工具，适用于来自多种手机型号的肖像模式图像：[http://www.hasaranga.com/dmap](http://www.hasaranga.com/dmap/)。
- en: '[Shifting Pixels](nsp-venkitachalam503045-0008.xhtml#rbh1003)'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[移动像素](nsp-venkitachalam503045-0008.xhtml#rbh1003)'
- en: We’ve looked at how our brains perceive the spacing between repeating elements
    in an image as depth information, and we’ve seen how depth information is conveyed
    through a depth map. Now let’s look at how to shift the pixels in a tiled image
    in proportion to the values in a depth map. This is the key step in creating an
    autostereogram.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了大脑如何将图像中重复元素之间的间距感知为深度信息，并且看到深度信息是如何通过深度图传递的。接下来，我们将探讨如何根据深度图中的值来移动平铺图像中的像素。这是创建自动立体图的关键步骤。
- en: 'A tiled image is created by repeating a smaller image (the tile) in the x-
    and y-directions, although for depth perception, we’re concerned only with the
    x-direction. If the tile that makes up the image is *w* pixels wide, you know
    the color values of the image’s pixels will repeat every *w* pixels in the x-direction
    for any given row. Put another way, the color of the pixel in some row at point
    *i* along the x-axis can be expressed as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 平铺图像是通过在x和y方向上重复一个较小的图像（即瓷砖）来创建的，尽管对于深度感知，我们只关心x方向。如果构成图像的瓷砖宽度为*w*像素，那么你知道图像中像素的颜色值将在任何给定行中每隔*w*像素在x方向上重复。换句话说，某行中x轴位置为*i*的像素颜色可以表示为：
- en: '*C*[i] = *C*[i] [−] [w] for *i* ≥ *w*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[i] = *C*[i] [−] [w]，当*i* ≥ *w*时'
- en: Let’s consider an example. Given a tile width of 100 pixels, for a pixel with
    an x-axis position of 140, the equation tells you that *C*[140] = *C*[140 − 100] = *C*[40].
    This means the color value of the pixel at x-position 140 is the same as that
    of the pixel at x-position 40, due to the repetition of the image. (For values of
    *i* less than *w* in the previous formula, the color is just *C*[i], since the
    tile hasn’t repeated yet.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个例子。假设瓷砖宽度为100像素，对于一个x轴位置为140的像素，公式告诉我们*C*[140] = *C*[140 − 100] = *C*[40]。这意味着x位置为140的像素的颜色值与x位置为40的像素相同，因为图像重复了。（对于公式中*i*小于*w*的情况，颜色就是*C*[i]，因为瓷砖还没有重复。）
- en: 'The goal is to shift pixels in the tiled image according to the values in the
    depth map. Let δ[i] be the value at x-position *i* in the depth map. The shifted
    color value of the corresponding pixel in the tiled image is given by:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是根据深度图中的值在平铺图像中移动像素。设δ[i]为深度图中x位置*i*的值。相应像素在平铺图像中的移动后的颜色值由下式给出：
- en: '![](images/nsp-venkitachalam503045-m08001.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m08001.jpg)'
- en: Returning to the example where the tile width is 100 pixels, given a pixel at
    x-position 140 and a corresponding depth map value of 10, the formula says that
    *C*[140] = *C*[140 − 100 + 10] = *C*[50]. Because of the depth map, the color
    of the pixel at position 140 should be changed to match the color of the pixel
    at position 50\. Since *C*[50] is the same as *C*[150], this is effectively taking
    the pixel at x-position 150 and shifting it 10 pixels to the left. As a result, the
    repetition between positions 50 and 150 has become 10 pixels narrower, and your
    brain will perceive this change as depth information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以瓷砖宽度为100像素为例，假设x位置为140的像素对应的深度图值为10，公式表示为*C*[140] = *C*[140 − 100 + 10] = *C*[50]。由于深度图，x位置为140的像素的颜色应该被修改为与位置50的像素颜色相同。因为*C*[50]与*C*[150]相同，这实际上是在将x位置为150的像素向左移动10个像素。因此，位置50和150之间的重复变得更窄了10个像素，你的大脑会把这个变化感知为深度信息。
- en: To create the complete autostereogram, you’ll repeat this shifting process across
    the width of the image and over all the rows. You’ll see how the shifting is actually
    implemented when you review the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建完整的自动立体图，你将沿着图像的宽度和所有行重复此移动过程。当你查看代码时，将看到如何实现这个移动过程。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1002)'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah1002)'
- en: In this project, you’ll use `Pillow` to read in images, access their underlying
    data, and create and modify images.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将使用`Pillow`来读取图像，访问其底层数据，并创建和修改图像。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1003)'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1003)'
- en: 'The code for this project will follow these steps to create an autostereogram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的代码将按照以下步骤创建一个自动立体图：
- en: 1\. Read in a depth map.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 读取一个深度图。
- en: 2\. Read in a tile image or create a “random dot” tile. This will serve as the
    basis for the autostereogram’s repeating pattern.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 读取一个瓦片图像或创建一个“随机点”瓦片。这将作为自动立体图重复图案的基础。
- en: 3\. Create a new image by repeating the tile. The dimensions of this image should
    match those of the depth map.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 通过重复瓦片来创建新图像。此图像的尺寸应与深度图的尺寸匹配。
- en: 4\. For each pixel in the new image, shift the pixel by an amount proportional
    to the depth value associated with the corresponding pixel in the depth map.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 对新图像中的每个像素，根据深度图中对应像素的深度值，将该像素移动一个与深度值成比例的量。
- en: 5\. Write the resulting autostereogram to a file.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 将结果自动立体图写入文件。
- en: To see the complete project, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0021.xhtml#ah1007)
    on [page 147](nsp-venkitachalam503045-0021.xhtml#p147). You can also download
    the full code listing for this chapter from [https://github.com/mkvenkit/pp2e/tree/main/autos](https://github.com/mkvenkit/pp2e/tree/main/autos).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整项目，请跳转到[“完整代码”](nsp-venkitachalam503045-0021.xhtml#ah1007)第[147页](nsp-venkitachalam503045-0021.xhtml#p147)。你还可以从[https://github.com/mkvenkit/pp2e/tree/main/autos](https://github.com/mkvenkit/pp2e/tree/main/autos)下载本章的完整代码列表。
- en: '[Creating a Tile from Random Circles](nsp-venkitachalam503045-0008.xhtml#rbh1004)'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[从随机圆形创建瓦片](nsp-venkitachalam503045-0008.xhtml#rbh1004)'
- en: The user will have the option to provide a tile image at the start of the program
    (I’ve uploaded an image based on an M.C. Escher drawing to GitHub for this purpose).
    If one isn’t provided, create a tile with random circles using the `createRandomTile()`
    function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以选择在程序开始时提供一个瓦片图像（我已将基于M.C. Escher画作的图像上传到GitHub以供使用）。如果没有提供，则使用`createRandomTile()`函数创建一个带有随机圆形的瓦片。
- en: 'def createRandomTile(dims):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createRandomTile(dims):'
- en: '# create image'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建图像'
- en: ❶ img = Image.new('RGB', dims)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ img = Image.new('RGB', dims)
- en: ❷ draw = ImageDraw.Draw(img)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ draw = ImageDraw.Draw(img)
- en: '# set the radius of a random circle to 1% of'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将随机圆的半径设置为1%  '
- en: '# width or height, whichever is smaller'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '# 宽度或高度，取较小值'
- en: ❸ r = int(min(*dims)/100)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ r = int(min(*dims)/100)
- en: '# number of circles'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '# 圆的数量'
- en: ❹ n = 1000
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ n = 1000
- en: '# draw random circles'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制随机圆'
- en: 'for i in range(n):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: '# -r makes sure that the circles stay inside and aren''t cut off'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '# -r确保圆形保持在图像内，不会被裁剪'
- en: '# at the edges of the image so that they''ll look better when tiled'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在图像的边缘，以便它们在平铺时看起来更好'
- en: ❺ x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
- en: ❻ fill = (random.randint(0, 255), random.randint(0, 255),
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ fill = (random.randint(0, 255), random.randint(0, 255),
- en: random.randint(0, 255))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: random.randint(0, 255))
- en: ❼ draw.ellipse((x-r, y-r, x+r, y+r), fill)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ draw.ellipse((x-r, y-r, x+r, y+r), fill)
- en: return img
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: return img
- en: First you create a new Python Imaging Library (PIL) `Image` object with the
    dimensions given by `dims` ❶. Then you use `ImageDraw.Draw()` ❷ to draw circles
    inside the image with an arbitrarily chosen radius (`r`) of 1/100th of either
    the width or the height of the image, whichever is smaller ❸. (The Python `*`
    operator unpacks the width and height values in the `dims` tuple so that they
    can be passed into the `min()` method.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个新的Python图像库（PIL）`Image`对象，尺寸由`dims` ❶给定。然后，使用`ImageDraw.Draw()` ❷在图像中绘制圆形，半径（`r`）为图像宽度或高度的1/100，取较小值
    ❸。（Python中的`*`运算符解包`dims`元组中的宽度和高度值，以便它们可以传递给`min()`方法。）
- en: You set the number of circles to draw to `1000` ❹ and then calculate the x-
    and y-coordinates of the center of each circle by calling `random.randint()` to
    get random integers in the range [`r`, `width``-r`] and [`r`, `height``-r`] ❺.
    Offsetting the range by `r` ensures the generated circles will fall entirely inside
    the boundaries of the tile. Without it, you could end up drawing a circle right
    at the edge of the image, which means it would be partly cut off. If you tiled
    such an image to create the autostereogram, the result wouldn’t look good because
    the circles at the edge between two tiles would have no spacing between them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你将绘制的圆的数量设置为`1000`❹，然后通过调用`random.randint()`来计算每个圆的中心的x和y坐标，以获取[`r`，`width-r`]和[`r`，`height-r`]范围内的随机整数❺。通过将范围偏移`r`，确保生成的圆完全落在瓦片的边界内。如果没有这样做，你可能会在图像的边缘绘制一个圆，这意味着它会部分被截断。如果你将这样的图像拼接起来生成自动立体图，结果看起来不好，因为两个瓦片之间的边缘处的圆没有间距。
- en: Next, you select a fill color for each circle by randomly choosing RGB values
    from the range [`0`, `255`] ❻. Finally, you use the `ellipse()` method in `draw`
    to draw each of your circles ❼. The first argument to this method is a tuple defining
    the bounding box of the circle, which is given by the top-left and bottom-right
    corners as (`x-r`, `y-r`) and (`x+r`, `y+r`), respectively, where (`x`, `y`) is
    the center of the circle and `r` is its radius. The other argument is the randomly
    chosen fill color.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你为每个圆选择一个填充颜色，通过从[`0`，`255`]的范围中随机选择RGB值❻。最后，你使用`draw`中的`ellipse()`方法来绘制每个圆❼。该方法的第一个参数是一个元组，定义了圆的边界框，给定的左上角和右下角分别为（`x-r`，`y-r`）和（`x+r`，`y+r`），其中（`x`，`y`）是圆的中心，`r`是圆的半径。另一个参数是随机选择的填充颜色。
- en: 'You can test this method in the Python interpreter as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python解释器中按如下方式测试这个方法：
- en: '>>> `import autos`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import autos`'
- en: '>>> `img = autos.createRandomTile((256, 256))`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `img = autos.createRandomTile((256, 256))`'
- en: '>>> `img.save(''out.png'')`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `img.save(''out.png'')`'
- en: '>>> `exit()`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `exit()`'
- en: '[Figure 8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7) shows the output from
    the test.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7)显示了测试的输出。'
- en: '![](images/nsp-venkitachalam503045-f08007.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08007.jpg)'
- en: 'Figure 8-7: A sample run of `createRandomTile()`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7：`createRandomTile()`的示例运行
- en: As you can see in [Figure 8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7), you’ve
    created an image with random dots that you can use as the autostereogram’s tiled
    pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7)所示，你已经创建了一个带有随机点的图像，可以用作自动立体图的瓦片模式。
- en: '[Repeating a Given Tile](nsp-venkitachalam503045-0008.xhtml#rbh1005)'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[重复给定的瓦片](nsp-venkitachalam503045-0008.xhtml#rbh1005)'
- en: Now that you have a tile to work with, you can create an image by repeating
    that tile. This will form the basis of your autostereogram. Define a `createTiledImage()`
    function to do the work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个可用的瓦片，可以通过重复这个瓦片来创建图像。这将构成你自动立体图的基础。定义一个`createTiledImage()`函数来完成这项工作。
- en: 'def createTiledImage(tile, dims):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createTiledImage(tile, dims):'
- en: '# create the new image'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建新的图像'
- en: ❶ img = Image.new('RGB', dims)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ img = Image.new('RGB', dims)
- en: W, H = dims
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: W, H = dims
- en: w, h = tile.size
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: w, h = tile.size
- en: '# calculate the number of tiles needed'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算所需瓦片的数量'
- en: ❷ cols = int(W/w) + 1
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ cols = int(W/w) + 1
- en: ❸ rows = int(H/h) + 1
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ rows = int(H/h) + 1
- en: '# paste the tiles into the image'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将瓦片粘贴到图像中'
- en: 'for i in range(rows):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(rows):'
- en: 'for j in range(cols):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(cols):'
- en: ❹ img.paste(tile, (j*w, i*h))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ img.paste(tile, (j*w, i*h))
- en: '# output the image'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输出图像'
- en: return img
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: return img
- en: The function takes in an image that will serve as the tiled pattern (`tile`),
    and the desired dimensions of the output image (`dims`). The dimensions are given
    as a tuple in the form (`width`, `height`). You create a new `Image` object using
    the supplied dimensions ❶. Next, you store the width and height of both the individual
    tile and the overall image. Dividing the overall image dimensions by those of
    the tile gives you the number of columns ❷ and rows ❸ of tiles you need to have
    in the image. You add 1 to each calculation to make sure that the last column
    of tiles on the right and the last row of tiles on the bottom aren’t missed when
    the output image dimension isn’t an exact integer multiple of the tile dimension.
    Without this precaution, the right and bottom of the image might be cut off. Finally,
    you loop through the rows and columns and fill them with tiles ❹. You determine the
    location of the top-left corner of the tile by multiplying `(j*w, i*h)` so it
    aligns with the rows and columns, just as you did in the photomosaic project.
    Once complete, the function returns an `Image` object of the specified dimensions,
    tiled with the input image `tile`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收一张将作为瓷砖图案（`tile`）的图像和期望的输出图像尺寸（`dims`）。尺寸以元组的形式给出，格式为（`宽度`，`高度`）。你使用提供的尺寸❶创建一个新的`Image`对象。接下来，存储单个瓷砖和整个图像的宽度和高度。将整个图像的尺寸除以瓷砖的尺寸，得到图像中所需的列数❷和行数❸。为了确保当输出图像的尺寸不是瓷砖尺寸的整数倍时，右侧的最后一列瓷砖和底部的最后一行瓷砖不会被遗漏，你要在每次计算时加1。如果没有这个预防措施，图像的右边和底部可能会被截断。最后，你循环遍历行和列并填充瓷砖❹。通过乘以`(j*w,
    i*h)`来确定瓷砖左上角的位置，这样它就能与行和列对齐，就像你在照片拼贴项目中所做的那样。一旦完成，函数将返回一个指定尺寸的`Image`对象，并用输入的图像`tile`进行拼接。
- en: '[Creating Autostereograms](nsp-venkitachalam503045-0008.xhtml#rbh1006)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建自动立体图](nsp-venkitachalam503045-0008.xhtml#rbh1006)'
- en: 'Now let’s create some autostereograms. The `createAutostereogram()` function
    does most of the work. Here it is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些自动立体图。`createAutostereogram()`函数完成了大部分工作。它是这样的：
- en: 'def createAutostereogram(dmap, tile):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createAutostereogram(dmap, tile):'
- en: '# convert the depth map to a single channel if needed'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果需要，将深度图转换为单通道'
- en: '❶ if dmap.mode != ''L'':'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ if dmap.mode != ''L'':'
- en: dmap = dmap.convert('L')
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: dmap = dmap.convert('L')
- en: '# if no image is specified for a tile, create a random circles tile'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果没有为瓷砖指定图像，则创建一个随机圆圈瓷砖'
- en: '❷ if not tile:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if not tile:'
- en: tile = createRandomTile((100, 100))
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: tile = createRandomTile((100, 100))
- en: '# create an image by tiling'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '# 通过拼接创建图像'
- en: ❸ img = createTiledImage(tile, dmap.size)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ img = createTiledImage(tile, dmap.size)
- en: '# create a shifted image using depth map values'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用深度图值创建一个偏移图像'
- en: ❹ sImg = img.copy()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ sImg = img.copy()
- en: '# get access to image pixels by loading the Image object first'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '# 首先加载Image对象以访问图像像素'
- en: ❺ pixD = dmap.load()
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ pixD = dmap.load()
- en: pixS = sImg.load()
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: pixS = sImg.load()
- en: '# shift pixels horizontally based on depth map'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据深度图水平移动像素'
- en: ❻ cols, rows = sImg.size
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ cols, rows = sImg.size
- en: 'for j in range(rows):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(rows):'
- en: 'for i in range(cols):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(cols):'
- en: ❼ xshift = pixD[i, j]/10
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ xshift = pixD[i, j]/10
- en: ❽ xpos = i - tile.size[0] + xshift
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ xpos = i - tile.size[0] + xshift
- en: '❾ if xpos > 0 and xpos < cols:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '❾ if xpos > 0 and xpos < cols:'
- en: ❿ pixS[i, j] = pixS[xpos, j]
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ pixS[i, j] = pixS[xpos, j]
- en: '# display the shifted image'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示偏移图像'
- en: return sImg
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: return sImg
- en: First you convert the provided depth map (`dmap`) into a single-channel grayscale
    image if needed ❶. If the user doesn’t supply an image for the tile, you then
    create a tile of random circles using the `createRandomTile()` function you defined
    earlier ❷. Next, you use your `createTiledImage()` function to create a tiled
    image that matches the size of the supplied depth map image ❸. You then make a
    copy of this tiled image ❹. This copy will become the final autostereogram.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果需要，你将提供的深度图（`dmap`）转换为单通道灰度图像❶。如果用户没有提供瓷砖图像，那么你将使用之前定义的`createRandomTile()`函数创建一个随机圆圈的瓷砖❷。接下来，你使用`createTiledImage()`函数创建一个与提供的深度图像大小相匹配的拼接图像❸。然后，你将这个拼接图像做一个副本❹。这个副本将成为最终的自动立体图。
- en: The function continues by using the `Image.load()` method on the depth map and
    the output image ❺. This method loads image data into memory, allowing you to
    access an image’s pixels as a two-dimensional array in the form `[i, j]`. You
    store the image dimensions as a number of rows and columns ❻, treating the image
    as a grid of individual pixels.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数继续使用`Image.load()`方法加载深度图和输出图像❺。该方法将图像数据加载到内存中，使你能够将图像像素作为二维数组`[i, j]`来访问。你将图像尺寸存储为行数和列数❻，将图像视为由单个像素组成的网格。
- en: The core of the autostereogram creation algorithm lies in the way you shift
    the pixels in the tiled image according to the information gathered from the depth
    map. To do this, you iterate through the tiled image and process each pixel. First
    you look up the value of the corresponding pixel from the depth map and divide
    this value by 10 to determine a shift value for the tiled image ❼. You divide
    by 10 because you’re using an 8-bit depth map here, which means the depth varies
    from 0 to 255\. If you divide these values by 10, you get depth values in the
    approximate range of 0 to 25\. Since the depth map input image dimensions are
    usually in the hundreds of pixels, these shift values work fine. (Play around
    by changing the value you divide by to see how it affects the final image.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自动立体图生成算法的核心在于根据从深度图中获取的信息，将图像中的像素进行偏移。为此，您需要遍历图像中的每个像素，并处理每个像素。首先，您查找深度图中对应像素的值，并将该值除以
    10，以确定图像的偏移值 ❼。之所以除以 10，是因为这里使用的是 8 位深度图，这意味着深度值在 0 到 255 之间。如果将这些值除以 10，您将得到一个大约在
    0 到 25 之间的深度值。由于深度图输入图像的尺寸通常在数百像素，因此这些偏移值是有效的。（通过更改除数的值来试试，看看它如何影响最终图像。）
- en: Next, you use the formula discussed in [“Shifting Pixels”](nsp-venkitachalam503045-0021.xhtml#bh1003)
    on [page 140](nsp-venkitachalam503045-0021.xhtml#p140) to calculate the x-axis
    coordinate to look for the pixel’s new color value ❽. Pixels with a depth map
    value of 0 (black) won’t be shifted and will be perceived as the background. After
    checking to make sure you’re not trying to access a pixel that’s not in the image
    (which can happen at the image’s edges because of the shift) ❾, you replace each
    pixel with its shifted value ❿.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您使用在[“像素偏移”](nsp-venkitachalam503045-0021.xhtml#bh1003)一文中讨论的公式，在[第140页](nsp-venkitachalam503045-0021.xhtml#p140)上计算
    x 轴坐标，以寻找像素的新颜色值 ❽。深度图值为 0（黑色）的像素不会被偏移，并将被视为背景。检查确保您没有尝试访问图像外部的像素（由于偏移，图像的边缘可能会发生这种情况）❾，然后用偏移后的值替换每个像素 ❿。
- en: '[Providing Command Line Options](nsp-venkitachalam503045-0008.xhtml#rbh1007)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[提供命令行选项](nsp-venkitachalam503045-0008.xhtml#rbh1007)'
- en: The `main()` function of the program provides some command line options to customize
    the autostereogram.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的 `main()` 函数提供了一些命令行选项，用于自定义自动立体图。
- en: 'def main():'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# create a parser'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个解析器'
- en: parser = argparse.ArgumentParser(description="Autostereograms...")
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="自动立体图...")
- en: '# add expected arguments'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加期望的参数'
- en: ❶ parser.add_argument('--depth', dest='dmFile', required=True)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser.add_argument('--depth', dest='dmFile', required=True)
- en: parser.add_argument('--tile', dest='tileFile', required=False)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--tile', dest='tileFile', required=False)
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--out', dest='outFile', required=False)
- en: '# parse args'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: args = parser.parse_args()
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set the output file'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置输出文件'
- en: outFile = 'as.png'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = 'as.png'
- en: 'if args.outFile:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.outFile:'
- en: outFile = args.outFile
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = args.outFile
- en: '# set tile'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置图块'
- en: tileFile = False
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: tileFile = False
- en: 'if args.tileFile:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.tileFile:'
- en: tileFile = Image.open(args.tileFile)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: tileFile = Image.open(args.tileFile)
- en: As with previous projects, you define the command line options for the program
    using `argparse`. The one required argument is the name of the depth map file
    ❶. There are also two optional arguments, one to provide an image file to use
    as the tile pattern and the other to set the name of the output file. If a tile
    image isn’t specified, the program will generate a tile of random circles. If
    the output filename isn’t specified, the autostereogram is written to a file named
    *as.png*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的项目一样，您使用 `argparse` 来定义程序的命令行选项。唯一必需的参数是深度图文件的名称 ❶。还有两个可选参数，一个是提供用作图块模式的图像文件，另一个是设置输出文件的名称。如果未指定图块图像，程序将生成一个随机圆形图块。如果未指定输出文件名，自动立体图将被写入名为
    *as.png* 的文件。
- en: '[Running the Autostereogram Generator](nsp-venkitachalam503045-0008.xhtml#rah1004)'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行自动立体图生成器](nsp-venkitachalam503045-0008.xhtml#rah1004)'
- en: 'Now let’s run the program using a depth map of a stool (*stool-depth.png*),
    which you’ll find in the *data* folder of this project’s GitHub repository:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用一个凳子的深度图（*stool-depth.png*），该文件可以在本项目 GitHub 仓库的 *data* 文件夹中找到：
- en: $ `python autos.py --depth data/stool-depth.png`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python autos.py --depth data/stool-depth.png`
- en: '[Figure 8-8](nsp-venkitachalam503045-0021.xhtml#fig8-8) shows the depth map
    image on the left and the generated autostereogram on the right. Because you haven’t
    supplied a graphic for the tile, this autostereogram is created using random tiles.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f08008.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: A sample run of *autos.py*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s give a tile image as input. Use the *stool-depth.png* depth map as
    you did earlier, but this time, supply the image *escher-tile.jpg* for the tiles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: $ `python autos.py --depth data/stool-depth.png –-tile data/escher-tile.jpg`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-9](nsp-venkitachalam503045-0021.xhtml#fig8-9) shows the output.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f08009.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: A sample run of *autos.py* using tiles'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Enjoy creating moiré autostereograms using the images I’ve provided on GitHub
    or using your own depth maps!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1005)'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you learned how to create autostereograms. Given a depth map
    image, you can now create either a random dot autostereogram or one tiled with
    an image you supply.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1006)'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some ways to further explore autostereograms:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Write code to create an image similar to [Figure 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)
    that demonstrates how changes in the linear spacing in an image can create illusions
    of depth. (Hint: use image tiles and the `Image.paste()` method.)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Add a command line option to the program to specify the scale to be applied
    to the depth map values. (Remember that the code divides the depth map value by
    10.) How does changing the value affect the autostereogram?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1007)'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete autostereogram project code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: autos.py
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: A program to create autostereograms.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: import sys, random, argparse
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: from PIL import Image, ImageDraw
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: create spacing/depth example
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def createSpacingDepthExample():'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: tiles = [Image.open('test/a.png'), Image.open('test/b.png'),
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Image.open('test/c.png')]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.new('RGB', (600, 400), (0, 0, 0))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: spacing = [10, 20, 40]
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'for j, tile in enumerate(tiles):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(8):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: img.paste(tile, (10 + i*(100 + j*10), 10 + j*100))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: img.save('sdepth.png')
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: create image filled with random dots
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def createRandomTile(dims):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '# create image'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.new('RGB', dims)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: draw = ImageDraw.Draw(img)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate radius - % of min dimension'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: r = int(min(*dims)/100)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '# number of dots'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: n = 1000
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '# draw random circles'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '# -r is used so circle stays inside - cleaner for tiling'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: fill = (random.randint(0, 255), random.randint(0, 255),
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: random.randint(0, 255))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: draw.ellipse((x-r, y-r, x+r, y+r), fill)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '# return image'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: return img
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: create a larger image of size dims by tiling the given image
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def createTiledImage(tile, dims):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '# create output image'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.new('RGB', dims)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: W, H = dims
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: w, h = tile.size
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate # of tiles needed'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: cols = int(W/w) + 1
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: rows = int(H/h) + 1
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '# paste tiles'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(rows):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(cols):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: img.paste(tile, (j*w, i*h))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '# output image'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: return img
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'create a depth map for testing:'
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def createDepthMap(dims):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: dmap = Image.new('L', dims)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: dmap.paste(10, (200, 25, 300, 125))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: dmap.paste(30, (200, 150, 300, 250))
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: dmap.paste(20, (200, 275, 300, 375))
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: return dmap
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: given a depth map (image) and an input image, create a new image
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: with pixels shifted according to depth
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def createDepthShiftedImage(dmap, img):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '# size check'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: assert dmap.size == img.size
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '# create shifted image'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: sImg = img.copy()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '# get pixel access'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: pixD = dmap.load()
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: pixS = sImg.load()
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '# shift pixels output based on depth map'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: cols, rows = sImg.size
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(rows):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(cols):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: xshift = pixD[i, j]/10
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: xpos = i - 140 + xshift
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'if xpos > 0 and xpos < cols:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: pixS[i, j] = pixS[xpos, j]
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '# return shifted image'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: return sImg
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: given a depth map (image) and an input image, create a new image
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: with pixels shifted according to depth
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def createAutostereogram(dmap, tile):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '# convert depth map to single channel if needed'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'if dmap.mode != ''L'':'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: dmap = dmap.convert('L')
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '# if no tile specified, use random image'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'if not tile:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: tile = createRandomTile((100, 100))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '# create an image by tiling'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: img = createTiledImage(tile, dmap.size)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '# create shifted image'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: sImg = img.copy()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '# get pixel access'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: pixD = dmap.load()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: pixS = sImg.load()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '# shift pixels output based on depth map'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: cols, rows = sImg.size
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(rows):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(cols):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: xshift = pixD[i, j]/10
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: xpos = i - tile.size[0] + xshift
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'if xpos > 0 and xpos < cols:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: pixS[i, j] = pixS[xpos, j]
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '# return shifted image'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: return sImg
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '# use sys.argv if needed'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: print('creating autostereogram...')
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '# create parser'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Autostereograms...")
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '# add expected arguments'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--depth', dest='dmFile', required=True)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--tile', dest='tileFile', required=False)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '# parse args'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '# set output file'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: outFile = 'as.png'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.outFile:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: outFile = args.outFile
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '# set tile'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: tileFile = False
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.tileFile:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: tileFile = Image.open(args.tileFile)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '# open depth map'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: dmImg = Image.open(args.dmFile)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '# create stereogram'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: asImg = createAutostereogram(dmImg, tileFile)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '# write output'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: asImg.save(outFile)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: call main
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[1](nsp-venkitachalam503045-0021.xhtml#fn1r) The hidden image is a shark.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[2](nsp-venkitachalam503045-0021.xhtml#fn2r) [http://colorstereo.com/texts_.txt/practice.htm](http://colorstereo.com/texts_.txt/practice.htm)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[3](nsp-venkitachalam503045-0021.xhtml#fn3r) [https://www.youtube.com/watch?v=oqpDqKpOChE](https://www.youtube.com/watch?v=oqpDqKpOChE)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
