- en: '[8](nsp-venkitachalam503045-0008.xhtml#rch08)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[8](nsp-venkitachalam503045-0008.xhtml#rch08)'
- en: Autostereograms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自立体图
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Stare at [Figure 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1) for a minute.
    Do you see anything other than random dots? [Figure 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)
    is an *autostereogram*, a two-dimensional image that creates the illusion of three
    dimensions. Autostereograms usually consist of repeating patterns that resolve
    into three dimensions on closer inspection. If you can’t see any sort of image,
    don’t worry; it took me a while and a bit of experimentation before I could. (If
    you aren’t having any luck with the version printed in this book, try the color
    version in the *images* folder of the book’s GitHub repository. The footnote to
    the caption reveals what you should see.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 盯着[图 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)看一分钟。你除了看到随机的点，还能看到其他东西吗？[图
    8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)是一个*自立体图*，它是一个二维图像，能够产生三维的错觉。自立体图通常由重复的图案组成，经过仔细观察后会显现出三维效果。如果你看不出任何图像，不用担心；我自己也花了些时间和一些实验才看出来。（如果你在本书中打印的版本看不清楚，可以尝试查看本书GitHub仓库中*images*文件夹里的彩色版本。图注的脚注会告诉你应该看到什么。）
- en: 'In this project, you’ll use Python to create autostereograms. Here are some
    of the concepts covered in this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用Python来创建自立体图。以下是项目中涵盖的一些概念：
- en: • Linear spacing and depth perception
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 线性间距和深度感知
- en: • Depth maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 深度图
- en: • Creating and editing images using `Pillow`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`Pillow`创建和编辑图像
- en: • Drawing into images using `Pillow`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`Pillow`向图像中绘制
- en: '![](images/nsp-venkitachalam503045-f08001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08001.jpg)'
- en: 'Figure 8-1: A puzzling image that might gnaw at you[1](nsp-venkitachalam503045-0021.xhtml#fn1)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：一张可能让你抓狂的谜图[1](nsp-venkitachalam503045-0021.xhtml#fn1)
- en: The autostereograms you’ll generate in this project are designed for “wall-eyed”
    viewing. The best way to see them is to focus your eyes on a point behind the
    image (such as a wall). Almost magically, once you perceive something in the patterns,
    your eyes should automatically bring it into focus, and when the three-dimensional
    image “locks in,” you’ll have a hard time shaking it off. (If you’re still having
    trouble viewing the image, see Gene Levin’s article “How to View Stereograms and
    Viewing Practice”[2](nsp-venkitachalam503045-0021.xhtml#fn2) for help.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这个项目中生成的自立体图是为“壁眼”观看设计的。观看这些图像的最佳方式是将视线集中在图像后方的某个点（比如一面墙）上。几乎神奇的是，一旦你在图案中看到某些东西，你的眼睛应该会自动聚焦，而当三维图像“锁定”时，你将很难再把它从视野中移开。（如果你还是无法查看图像，可以参考Gene
    Levin的文章《如何查看立体图和观看练习》[2](nsp-venkitachalam503045-0021.xhtml#fn2)以获取帮助。）
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1001)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah1001)'
- en: An autostereogram starts as an image with a repeating tiled pattern. The hidden
    3D image is embedded into it by changing the linear spacing between the repeating
    patterns, thereby creating the illusion of depth. When you look at repeating patterns
    in an autostereogram, your brain can interpret the spacing as depth information,
    especially if there are multiple patterns with different spacing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自立体图开始时是一个带有重复图案的图像。隐藏的三维图像通过改变重复图案之间的线性间距嵌入其中，从而创造出深度的错觉。当你看着自立体图中的重复图案时，你的大脑能够将间距解读为深度信息，特别是当多个图案的间距不同的时候。
- en: '[Perceiving Depth in an Autostereogram](nsp-venkitachalam503045-0008.xhtml#rbh1001)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在自立体图中感知深度](nsp-venkitachalam503045-0008.xhtml#rbh1001)'
- en: When your eyes converge at an imaginary point behind the image, your brain matches
    the points seen by your left eye with a different group seen by your right eye,
    and you see these points lying on a plane behind the image. The perceived distance
    to this plane depends on the amount of spacing in the pattern. For example, [Figure
    8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2) shows three rows of *A*s. The
    *A*s are equidistant within each row, but their horizontal spacing increases from
    top to bottom.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的眼睛集中在图像后方的一个假想点时，你的大脑将左眼看到的点与右眼看到的不同组点匹配，你就会看到这些点位于图像后方的一个平面上。这个平面到眼睛的感知距离取决于图案中的间距。例如，[图
    8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)显示了三排*A*。每一排中的*A*之间的间距相等，但它们的水平间距从上到下逐渐增大。
- en: '![](images/nsp-venkitachalam503045-f08002.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08002.jpg)'
- en: 'Figure 8-2: Linear spacing and depth perception'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：线性间距和深度感知
- en: When this image is viewed “wall-eyed,” the top row in [Figure 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)
    should appear to be behind the paper, the middle row should look like it’s a little
    behind the first row, and the bottom row should appear farthest from your eye.
    The text that says *floating text* should appear to “float” on top of these rows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当以“墙眼”方式观看此图像时，[图8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)的顶行应该看起来在纸张后面，中行应该略微在第一行后面，底行应该看起来离你的眼睛最远。标有*浮动文本*的文本应该看起来“浮在”这些行的上方。
- en: Why does your brain interpret the spacing between these patterns as depth? Normally,
    when you look at a distant object, your eyes work together to focus and converge
    at the same point, with both eyes rotating inward to point directly at the object.
    But when viewing a “wall-eyed” autostereogram, focus and convergence happen at
    different locations. Your eyes focus on the autostereogram, but your brain sees
    the repeated patterns as coming from the same virtual (imaginary) object, and
    your eyes converge on a point behind the image, as shown in [Figure 8-3](nsp-venkitachalam503045-0021.xhtml#fig8-3).
    This combination of decoupled focus and convergence allows you to see depth in
    an autostereogram.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大脑为何将这些模式之间的间距解释为深度？通常，当你看远处的物体时，你的眼睛一起工作以聚焦并汇聚到同一点，两只眼睛向内旋转以直接指向物体。但是，观看“墙眼”自动立体图时，焦点和汇聚发生在不同位置。你的眼睛聚焦于自动立体图，但你的大脑看到重复的模式来自同一虚拟（想象的）对象，并且你的眼睛汇聚在图像后面的一个点上，如[图8-3](nsp-venkitachalam503045-0021.xhtml#fig8-3)所示。这种分离的焦点和汇聚的组合使你能够看到自动立体图中的深度。
- en: '![](images/nsp-venkitachalam503045-f08003.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08003.jpg)'
- en: 'Figure 8-3: Seeing depth in autostereograms'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3：观看自动立体图中的深度
- en: The perceived depth of the autostereogram depends on the horizontal spacing
    of pixels. Because the first row in [Figure 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)
    has the closest spacing, it appears in front of the other rows. However, if the
    spacing of the points were varied in the image, your brain would perceive each
    point at a different depth, and you could see a virtual three-dimensional image
    appear.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自动立体图的感知深度取决于像素的水平间距。因为[图8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)的第一行间距最小，所以它看起来比其他行更靠前。然而，如果图像中的点的间距有所变化，你的大脑会感知每个点处于不同的深度，并且你可以看到一个虚拟的三维图像。
- en: '[Working with Depth Maps](nsp-venkitachalam503045-0008.xhtml#rbh1002)'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[处理深度图](nsp-venkitachalam503045-0008.xhtml#rbh1002)'
- en: The hidden image in an autostereogram comes from a *depth map*, an image in
    which the value of each pixel represents a depth value, which is the distance
    from the eye to the part of the object represented by that pixel. A depth map
    is often shown as a grayscale image, with light areas for nearby points and darker
    areas for points farther away, as shown in [Figure 8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自动立体图中的隐藏图像来自于*深度图*，一种每个像素的值表示深度值的图像，即从眼睛到该像素代表的对象部分的距离。深度图通常显示为灰度图像，亮区域表示附近的点，暗区域表示远处的点，如[图8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4)所示。
- en: '![](images/nsp-venkitachalam503045-f08004.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08004.jpg)'
- en: 'Figure 8-4: A depth map'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：深度图
- en: Notice that the nose of the shark, the lightest part of the image, seems closest
    to you. The darker area toward the tail seems farthest away. (By the way, the
    image in [Figure 8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4) is the same depth
    map used to create the first autostereogram shown in [Figure 8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1).)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，鲨鱼的鼻子，即图像中最亮的部分，似乎最接近你。朝尾部的较暗区域看起来最远。（顺便说一句，[图8-4](nsp-venkitachalam503045-0021.xhtml#fig8-4)中的图像是用来创建第一个自动立体图[图8-1](nsp-venkitachalam503045-0021.xhtml#fig8-1)的相同深度图。）
- en: Because the depth map represents the depth or distance from the center of each
    pixel to the eye, you can use it to get the depth value associated with a pixel
    location in the image. You know that horizontal shifts are perceived as depth
    in images. So if you shift a pixel in a (patterned) image proportionally to the
    corresponding pixel’s depth value, you would create a depth perception for that
    pixel consistent with the depth map. If you do this for all pixels, you’ll end
    up encoding the entire depth map into the image, creating an autostereogram.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于深度图表示从每个像素中心到眼睛的深度或距离，你可以用它来获取与图像中某个像素位置相关的深度值。你知道，水平位移在图像中被感知为深度。所以，如果你根据相应像素的深度值按比例移动图像中的一个像素，你就能为该像素创建一个符合深度图的深度感知。如果你对所有像素都这么做，最终你会将整个深度图编码到图像中，从而创建一个自动立体图。
- en: Depth maps store depth values for each pixel, and the resolution of the value
    depends on the number of bits used to represent it. Because you’ll be using common
    8-bit images in this chapter, depth values will be in the range [0, 255].
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 深度图为每个像素存储深度值，值的分辨率取决于用于表示它的位数。由于本章中将使用常见的 8 位图像，深度值的范围将是 [0, 255]。
- en: 'For the purposes of this project, I’ve posted several example depth maps to
    the book’s GitHub repository. You can download the maps and use them as input
    for generating autostereograms. However, you may also want to try making your
    own depth maps to create some fancier images. There are two approaches you can
    take: using synthetic images created with 3D modeling software or using photographs
    taken with a smartphone camera.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个项目，我已将几个示例深度图上传至本书的 GitHub 仓库。你可以下载这些深度图，并将它们作为生成自动立体图的输入。不过，你可能还想尝试自己制作一些深度图，来创造更复杂的图像。你可以采取两种方法：使用
    3D 建模软件创建的合成图像，或者使用智能手机相机拍摄的照片。
- en: Creating Depth Maps from 3D Models
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 3D 模型创建深度图
- en: If you create a 3D model of something using a 3D computer graphics program like
    Blender, you can also use the program to generate a depth map of the model. [Figure
    8-5](nsp-venkitachalam503045-0021.xhtml#fig8-5) shows an example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用像 Blender 这样的 3D 计算机图形程序创建了一个 3D 模型，你还可以使用该程序生成该模型的深度图。[图 8-5](nsp-venkitachalam503045-0021.xhtml#fig8-5)展示了一个例子。
- en: '![](images/nsp-venkitachalam503045-f08005a.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08005a.jpg)'
- en: (a)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f08005b.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08005b.jpg)'
- en: (b)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 8-5: A 3D model (a) and its associated depth map (b)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：一个 3D 模型（a）及其对应的深度图（b）
- en: '[Figure 8-5(a)](nsp-venkitachalam503045-0021.xhtml#fig8-5) shows a 3D model
    rendered using Blender, and [Figure 8-5(b)](nsp-venkitachalam503045-0021.xhtml#fig8-5)
    shows the depth map created from this model. Search YouTube for “Blender depth
    map in 5 minutes!” for a tutorial[3](nsp-venkitachalam503045-0021.xhtml#fn3) from
    Jonty Schmidt on how to do this. The key is to color the image based on the Z-distance
    from the camera.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5(a)](nsp-venkitachalam503045-0021.xhtml#fig8-5)展示了使用 Blender 渲染的 3D 模型，[图
    8-5(b)](nsp-venkitachalam503045-0021.xhtml#fig8-5)展示了从这个模型创建的深度图。你可以在 YouTube
    上搜索“Blender depth map in 5 minutes！”查看 Jonty Schmidt 的教程[3](nsp-venkitachalam503045-0021.xhtml#fn3)，了解如何实现。关键是根据相机的
    Z 距离对图像进行着色。'
- en: Creating Depth Maps from Smartphone Photographs
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从智能手机照片创建深度图
- en: These days, many smartphone cameras have a *portrait mode*, which captures depth
    information along with the photograph to selectively blur out the background.
    If you could get hold of this depth data, you’d have a depth map of the photograph
    that you can use to create an autostereogram! [Figure 8-6](nsp-venkitachalam503045-0021.xhtml#fig8-6)
    shows an example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多智能手机相机都有*人像模式*，它不仅拍摄照片，还捕捉深度信息，选择性地模糊背景。如果你能获取到这些深度数据，你就会拥有照片的深度图，可以用来创建自动立体图！[图
    8-6](nsp-venkitachalam503045-0021.xhtml#fig8-6)展示了一个例子。
- en: '![](images/nsp-venkitachalam503045-f08006a.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08006a.jpg)'
- en: (a)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f08006b.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08006b.jpg)'
- en: (b)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 8-6: A portrait mode photo (a) and depth map (b) from an iPhone 11 camera'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：iPhone 11 相机拍摄的人像模式照片（a）及深度图（b）
- en: '[Figure 8-6(a)](nsp-venkitachalam503045-0021.xhtml#fig8-6) shows a photograph
    taken in portrait mode with an iPhone 11, and [Figure 8-6(b)](nsp-venkitachalam503045-0021.xhtml#fig8-6)
    shows the corresponding depth map. The depth map was created with the open source
    software ExifTool using this command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-6(a)](nsp-venkitachalam503045-0021.xhtml#fig8-6)展示了一张使用 iPhone 11 拍摄的人像模式照片，[图
    8-6(b)](nsp-venkitachalam503045-0021.xhtml#fig8-6)展示了相应的深度图。这个深度图是通过开源软件 ExifTool
    创建的，使用了以下命令：'
- en: exiftool -b -MPImage2 photo.jpg > depth.jpg
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: exiftool -b -MPImage2 photo.jpg > depth.jpg
- en: 'This command extracts the depth information from the metadata in the file *photo.jpg*
    and saves it to the file *depth.jpg*. Download ExifTool from [https://exiftool.org](https://exiftool.org)
    to try the process for yourself. The command works for photos from an iPhone,
    but you can use similar techniques to extract the depth data from images taken
    with other types of phones. There are also various apps available on the Android
    and iOS app stores that can help you with this. Here’s one online depth map extractor
    that works with portrait mode images from a variety of phone models: [http://www.hasaranga.com/dmap](http://www.hasaranga.com/dmap/).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令从文件*photo.jpg*的元数据中提取深度信息，并将其保存到文件*depth.jpg*中。可以从[https://exiftool.org](https://exiftool.org)下载ExifTool来亲自尝试这个过程。该命令适用于iPhone的照片，但你也可以使用类似的技术来提取其他类型手机拍摄的图像中的深度数据。安卓和iOS应用商店也有各种应用可以帮助你完成此操作。这里有一个在线深度图提取工具，支持多种手机型号的肖像模式图像：[http://www.hasaranga.com/dmap](http://www.hasaranga.com/dmap/)。
- en: '[Shifting Pixels](nsp-venkitachalam503045-0008.xhtml#rbh1003)'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[移动像素](nsp-venkitachalam503045-0008.xhtml#rbh1003)'
- en: We’ve looked at how our brains perceive the spacing between repeating elements
    in an image as depth information, and we’ve seen how depth information is conveyed
    through a depth map. Now let’s look at how to shift the pixels in a tiled image
    in proportion to the values in a depth map. This is the key step in creating an
    autostereogram.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了大脑如何将图像中重复元素之间的间距感知为深度信息，也看到了深度信息是如何通过深度图传达的。现在让我们看看如何根据深度图中的值来移动平铺图像中的像素。这是创建自动立体图的关键步骤。
- en: 'A tiled image is created by repeating a smaller image (the tile) in the x-
    and y-directions, although for depth perception, we’re concerned only with the
    x-direction. If the tile that makes up the image is *w* pixels wide, you know
    the color values of the image’s pixels will repeat every *w* pixels in the x-direction
    for any given row. Put another way, the color of the pixel in some row at point
    *i* along the x-axis can be expressed as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一张平铺图像是通过在x轴和y轴方向上重复一个较小的图像（即瓷砖）创建的，尽管在深度感知方面，我们只关心x轴方向。如果组成图像的瓷砖宽度为*w*像素，那么你知道图像中像素的颜色值将在x轴的每一行中每隔*w*像素重复一次。换句话说，位于x轴某一行的像素在点*i*处的颜色可以表示为：
- en: '*C*[i] = *C*[i] [−] [w] for *i* ≥ *w*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[i] = *C*[i] [−] [w] 其中 *i* ≥ *w*'
- en: Let’s consider an example. Given a tile width of 100 pixels, for a pixel with
    an x-axis position of 140, the equation tells you that *C*[140] = *C*[140 − 100] = *C*[40].
    This means the color value of the pixel at x-position 140 is the same as that
    of the pixel at x-position 40, due to the repetition of the image. (For values of
    *i* less than *w* in the previous formula, the color is just *C*[i], since the
    tile hasn’t repeated yet.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。给定瓷砖宽度为100像素，对于x轴位置为140的像素，公式告诉你 *C*[140] = *C*[140 − 100] = *C*[40]。这意味着，由于图像的重复，x位置为140的像素的颜色值与x位置为40的像素相同。（对于前述公式中*i*小于*w*的值，颜色值就是*C*[i]，因为瓷砖尚未重复。）
- en: 'The goal is to shift pixels in the tiled image according to the values in the
    depth map. Let δ[i] be the value at x-position *i* in the depth map. The shifted
    color value of the corresponding pixel in the tiled image is given by:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是根据深度图中的值来移动平铺图像中的像素。设δ[i]为深度图中x位置*i*的值。平铺图像中相应像素的移动后颜色值由以下公式给出：
- en: '![](images/nsp-venkitachalam503045-m08001.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m08001.jpg)'
- en: Returning to the example where the tile width is 100 pixels, given a pixel at
    x-position 140 and a corresponding depth map value of 10, the formula says that
    *C*[140] = *C*[140 − 100 + 10] = *C*[50]. Because of the depth map, the color
    of the pixel at position 140 should be changed to match the color of the pixel
    at position 50\. Since *C*[50] is the same as *C*[150], this is effectively taking
    the pixel at x-position 150 and shifting it 10 pixels to the left. As a result, the
    repetition between positions 50 and 150 has become 10 pixels narrower, and your
    brain will perceive this change as depth information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的例子，假设瓷砖宽度为100像素，x位置为140的像素对应的深度图值为10，公式表示 *C*[140] = *C*[140 − 100 + 10]
    = *C*[50]。由于深度图，x位置为140的像素的颜色应该被改变，以匹配x位置为50的像素的颜色。由于*C*[50]与*C*[150]相同，这实际上是将x位置为150的像素向左移动10个像素。因此，50和150之间的重复区域变得更窄了10个像素，你的大脑会将这种变化感知为深度信息。
- en: To create the complete autostereogram, you’ll repeat this shifting process across
    the width of the image and over all the rows. You’ll see how the shifting is actually
    implemented when you review the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建完整的自动立体图，你需要在图像的宽度和所有行上重复这个移动过程。当你查看代码时，会看到这个移动过程是如何实现的。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1002)'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah1002)'
- en: In this project, you’ll use `Pillow` to read in images, access their underlying
    data, and create and modify images.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将使用 `Pillow` 读取图像，访问它们的底层数据，并创建和修改图像。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1003)'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1003)'
- en: 'The code for this project will follow these steps to create an autostereogram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的代码将按照以下步骤创建一个自动立体图：
- en: 1\. Read in a depth map.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 读取深度图。
- en: 2\. Read in a tile image or create a “random dot” tile. This will serve as the
    basis for the autostereogram’s repeating pattern.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 读取图块图像或创建一个“随机点”图块。它将作为自动立体图重复模式的基础。
- en: 3\. Create a new image by repeating the tile. The dimensions of this image should
    match those of the depth map.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 通过重复图块创建新图像。此图像的尺寸应与深度图的尺寸相匹配。
- en: 4\. For each pixel in the new image, shift the pixel by an amount proportional
    to the depth value associated with the corresponding pixel in the depth map.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 对于新图像中的每个像素，根据深度图中相应像素的深度值按比例移动像素。
- en: 5\. Write the resulting autostereogram to a file.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 将生成的自动立体图保存为文件。
- en: To see the complete project, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0021.xhtml#ah1007)
    on [page 147](nsp-venkitachalam503045-0021.xhtml#p147). You can also download
    the full code listing for this chapter from [https://github.com/mkvenkit/pp2e/tree/main/autos](https://github.com/mkvenkit/pp2e/tree/main/autos).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的项目，请跳转至[“完整代码”](nsp-venkitachalam503045-0021.xhtml#ah1007)在[第147页](nsp-venkitachalam503045-0021.xhtml#p147)。你也可以从[https://github.com/mkvenkit/pp2e/tree/main/autos](https://github.com/mkvenkit/pp2e/tree/main/autos)下载本章节的完整代码列表。
- en: '[Creating a Tile from Random Circles](nsp-venkitachalam503045-0008.xhtml#rbh1004)'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[从随机圆形创建图块](nsp-venkitachalam503045-0008.xhtml#rbh1004)'
- en: The user will have the option to provide a tile image at the start of the program
    (I’ve uploaded an image based on an M.C. Escher drawing to GitHub for this purpose).
    If one isn’t provided, create a tile with random circles using the `createRandomTile()`
    function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将有机会在程序开始时提供一个图块图像（我已将基于M.C. Escher的图案上传到GitHub，供此目的使用）。如果没有提供，则使用 `createRandomTile()`
    函数创建一个随机圆形图块。
- en: 'def createRandomTile(dims):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createRandomTile(dims):'
- en: '# create image'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建图像'
- en: ❶ img = Image.new('RGB', dims)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ img = Image.new('RGB', dims)
- en: ❷ draw = ImageDraw.Draw(img)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ draw = ImageDraw.Draw(img)
- en: '# set the radius of a random circle to 1% of'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置随机圆形的半径为1%'
- en: '# width or height, whichever is smaller'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '# 宽度或高度，取较小者'
- en: ❸ r = int(min(*dims)/100)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ r = int(min(*dims)/100)
- en: '# number of circles'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '# 圆形数量'
- en: ❹ n = 1000
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ n = 1000
- en: '# draw random circles'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制随机圆形'
- en: 'for i in range(n):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: '# -r makes sure that the circles stay inside and aren''t cut off'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '# -r 确保圆形保持在图像内部，不会被截断'
- en: '# at the edges of the image so that they''ll look better when tiled'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在图像边缘绘制，以便它们在平铺时看起来更好'
- en: ❺ x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
- en: ❻ fill = (random.randint(0, 255), random.randint(0, 255),
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ fill = (random.randint(0, 255), random.randint(0, 255),
- en: random.randint(0, 255))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: random.randint(0, 255))
- en: ❼ draw.ellipse((x-r, y-r, x+r, y+r), fill)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ draw.ellipse((x-r, y-r, x+r, y+r), fill)
- en: return img
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: return img
- en: First you create a new Python Imaging Library (PIL) `Image` object with the
    dimensions given by `dims` ❶. Then you use `ImageDraw.Draw()` ❷ to draw circles
    inside the image with an arbitrarily chosen radius (`r`) of 1/100th of either
    the width or the height of the image, whichever is smaller ❸. (The Python `*`
    operator unpacks the width and height values in the `dims` tuple so that they
    can be passed into the `min()` method.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会创建一个新的Python Imaging Library (PIL) `Image` 对象，尺寸由 `dims` 提供 ❶。然后，使用 `ImageDraw.Draw()`
    ❷ 在图像中绘制圆形，圆形的半径（`r`）是图像宽度或高度的1/100，取较小者 ❸。（Python 的 `*` 运算符解包 `dims` 元组中的宽度和高度值，以便它们可以传递给
    `min()` 方法。）
- en: You set the number of circles to draw to `1000` ❹ and then calculate the x-
    and y-coordinates of the center of each circle by calling `random.randint()` to
    get random integers in the range [`r`, `width``-r`] and [`r`, `height``-r`] ❺.
    Offsetting the range by `r` ensures the generated circles will fall entirely inside
    the boundaries of the tile. Without it, you could end up drawing a circle right
    at the edge of the image, which means it would be partly cut off. If you tiled
    such an image to create the autostereogram, the result wouldn’t look good because
    the circles at the edge between two tiles would have no spacing between them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你将绘制圆圈的数量设置为`1000` ❹，然后通过调用`random.randint()`获取在范围[`r`, `width`-r]和[`r`, `height`-r]之间的随机整数，来计算每个圆的中心的
    x 和 y 坐标 ❺。通过将范围偏移`r`，可以确保生成的圆圈完全位于图块的边界内。如果没有这样做，你可能会在图像的边缘绘制一个圆圈，这意味着它会部分被截断。如果你将这样的图像拼接成自动立体图，结果就不好看，因为两个图块之间的边缘上的圆圈之间没有间隙。
- en: Next, you select a fill color for each circle by randomly choosing RGB values
    from the range [`0`, `255`] ❻. Finally, you use the `ellipse()` method in `draw`
    to draw each of your circles ❼. The first argument to this method is a tuple defining
    the bounding box of the circle, which is given by the top-left and bottom-right
    corners as (`x-r`, `y-r`) and (`x+r`, `y+r`), respectively, where (`x`, `y`) is
    the center of the circle and `r` is its radius. The other argument is the randomly
    chosen fill color.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你通过随机选择 RGB 值从范围[`0`, `255`] ❻来为每个圆选择填充颜色。最后，你使用`draw`中的`ellipse()`方法绘制每个圆
    ❼。该方法的第一个参数是一个元组，定义了圆的边界框，由（`x-r`，`y-r`）和（`x+r`，`y+r`）给出，分别是圆的左上角和右下角的坐标，其中（`x`，`y`）是圆的中心，`r`是圆的半径。另一个参数是随机选择的填充颜色。
- en: 'You can test this method in the Python interpreter as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python 解释器中通过以下方式测试此方法：
- en: '>>> `import autos`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import autos`'
- en: '>>> `img = autos.createRandomTile((256, 256))`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `img = autos.createRandomTile((256, 256))`'
- en: '>>> `img.save(''out.png'')`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `img.save(''out.png'')`'
- en: '>>> `exit()`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `exit()`'
- en: '[Figure 8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7) shows the output from
    the test.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7) 显示了测试的输出结果。'
- en: '![](images/nsp-venkitachalam503045-f08007.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08007.jpg)'
- en: 'Figure 8-7: A sample run of `createRandomTile()`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：`createRandomTile()` 的示例运行结果
- en: As you can see in [Figure 8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7), you’ve
    created an image with random dots that you can use as the autostereogram’s tiled
    pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 8-7](nsp-venkitachalam503045-0021.xhtml#fig8-7)所示，你已经创建了一个带有随机点的图像，可以将其用作自动立体图的图块模式。
- en: '[Repeating a Given Tile](nsp-venkitachalam503045-0008.xhtml#rbh1005)'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[重复给定图块](nsp-venkitachalam503045-0008.xhtml#rbh1005)'
- en: Now that you have a tile to work with, you can create an image by repeating
    that tile. This will form the basis of your autostereogram. Define a `createTiledImage()`
    function to do the work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个图块，可以通过重复该图块来创建图像。这将成为你自动立体图的基础。定义一个`createTiledImage()`函数来完成这项工作。
- en: 'def createTiledImage(tile, dims):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createTiledImage(tile, dims):'
- en: '# create the new image'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建新图像'
- en: ❶ img = Image.new('RGB', dims)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ img = Image.new('RGB', dims)
- en: W, H = dims
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: W, H = dims
- en: w, h = tile.size
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: w, h = tile.size
- en: '# calculate the number of tiles needed'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算所需的图块数量'
- en: ❷ cols = int(W/w) + 1
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ cols = int(W/w) + 1
- en: ❸ rows = int(H/h) + 1
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ rows = int(H/h) + 1
- en: '# paste the tiles into the image'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图块粘贴到图像中'
- en: 'for i in range(rows):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(rows):'
- en: 'for j in range(cols):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(cols):'
- en: ❹ img.paste(tile, (j*w, i*h))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ img.paste(tile, (j*w, i*h))
- en: '# output the image'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输出图像'
- en: return img
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: return img
- en: The function takes in an image that will serve as the tiled pattern (`tile`),
    and the desired dimensions of the output image (`dims`). The dimensions are given
    as a tuple in the form (`width`, `height`). You create a new `Image` object using
    the supplied dimensions ❶. Next, you store the width and height of both the individual
    tile and the overall image. Dividing the overall image dimensions by those of
    the tile gives you the number of columns ❷ and rows ❸ of tiles you need to have
    in the image. You add 1 to each calculation to make sure that the last column
    of tiles on the right and the last row of tiles on the bottom aren’t missed when
    the output image dimension isn’t an exact integer multiple of the tile dimension.
    Without this precaution, the right and bottom of the image might be cut off. Finally,
    you loop through the rows and columns and fill them with tiles ❹. You determine the
    location of the top-left corner of the tile by multiplying `(j*w, i*h)` so it
    aligns with the rows and columns, just as you did in the photomosaic project.
    Once complete, the function returns an `Image` object of the specified dimensions,
    tiled with the input image `tile`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个图像作为拼接图案（`tile`），以及输出图像的期望尺寸（`dims`）。尺寸以元组（`width`, `height`）的形式给出。首先，您使用提供的尺寸
    ❶ 创建一个新的 `Image` 对象。接下来，您存储单个拼图和整个图像的宽度和高度。通过将整个图像的尺寸除以拼图的尺寸，您可以得到图像中所需的列数 ❷ 和行数
    ❸。如果输出图像的尺寸不是拼图尺寸的整数倍，您需要在每个计算中加 1，以确保右侧的最后一列和底部的最后一行拼图不会被遗漏。没有这个预防措施，图像的右侧和底部可能会被切掉。最后，您循环遍历行和列，并用拼图填充它们
    ❹。您通过将 `(j*w, i*h)` 相乘来确定拼图的左上角位置，使其与行和列对齐，正如您在拼图项目中所做的那样。一旦完成，函数将返回一个指定尺寸的 `Image`
    对象，该对象由输入图像 `tile` 拼接而成。
- en: '[Creating Autostereograms](nsp-venkitachalam503045-0008.xhtml#rbh1006)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建自动立体图](nsp-venkitachalam503045-0008.xhtml#rbh1006)'
- en: 'Now let’s create some autostereograms. The `createAutostereogram()` function
    does most of the work. Here it is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一些自动立体图。`createAutostereogram()` 函数完成了大部分工作。代码如下：
- en: 'def createAutostereogram(dmap, tile):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createAutostereogram(dmap, tile):'
- en: '# convert the depth map to a single channel if needed'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果需要，将深度图转换为单通道'
- en: '❶ if dmap.mode != ''L'':'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 dmap.mode != 'L'：
- en: dmap = dmap.convert('L')
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: dmap = dmap.convert('L')
- en: '# if no image is specified for a tile, create a random circles tile'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果没有为拼图提供图像，则创建一个随机圆形拼图'
- en: '❷ if not tile:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果没有提供 tile：
- en: tile = createRandomTile((100, 100))
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: tile = createRandomTile((100, 100))
- en: '# create an image by tiling'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '# 通过拼接创建图像'
- en: ❸ img = createTiledImage(tile, dmap.size)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ img = createTiledImage(tile, dmap.size)
- en: '# create a shifted image using depth map values'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用深度图值创建位移图像'
- en: ❹ sImg = img.copy()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ sImg = img.copy()
- en: '# get access to image pixels by loading the Image object first'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '# 首先加载 Image 对象以获取图像像素'
- en: ❺ pixD = dmap.load()
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ pixD = dmap.load()
- en: pixS = sImg.load()
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: pixS = sImg.load()
- en: '# shift pixels horizontally based on depth map'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据深度图水平位移像素'
- en: ❻ cols, rows = sImg.size
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ cols, rows = sImg.size
- en: 'for j in range(rows):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(rows):'
- en: 'for i in range(cols):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(cols):'
- en: ❼ xshift = pixD[i, j]/10
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ xshift = pixD[i, j]/10
- en: ❽ xpos = i - tile.size[0] + xshift
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ xpos = i - tile.size[0] + xshift
- en: '❾ if xpos > 0 and xpos < cols:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果 xpos > 0 且 xpos < cols：
- en: ❿ pixS[i, j] = pixS[xpos, j]
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ pixS[i, j] = pixS[xpos, j]
- en: '# display the shifted image'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示位移图像'
- en: return sImg
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: return sImg
- en: First you convert the provided depth map (`dmap`) into a single-channel grayscale
    image if needed ❶. If the user doesn’t supply an image for the tile, you then
    create a tile of random circles using the `createRandomTile()` function you defined
    earlier ❷. Next, you use your `createTiledImage()` function to create a tiled
    image that matches the size of the supplied depth map image ❸. You then make a
    copy of this tiled image ❹. This copy will become the final autostereogram.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果需要，您将提供的深度图（`dmap`）转换为单通道灰度图像 ❶。如果用户没有为拼图提供图像，您将使用您之前定义的 `createRandomTile()`
    函数创建一个随机圆形拼图 ❷。接下来，您使用 `createTiledImage()` 函数创建一个与提供的深度图图像大小匹配的拼接图像 ❸。然后，您制作该拼接图像的副本
    ❹。这个副本将成为最终的自动立体图。
- en: The function continues by using the `Image.load()` method on the depth map and
    the output image ❺. This method loads image data into memory, allowing you to
    access an image’s pixels as a two-dimensional array in the form `[i, j]`. You
    store the image dimensions as a number of rows and columns ❻, treating the image
    as a grid of individual pixels.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数继续使用 `Image.load()` 方法加载深度图和输出图像 ❺。此方法将图像数据加载到内存中，使您能够以二维数组形式 `[i, j]` 访问图像的像素。您将图像的尺寸存储为行数和列数
    ❻，并将图像视为一个个像素的网格。
- en: The core of the autostereogram creation algorithm lies in the way you shift
    the pixels in the tiled image according to the information gathered from the depth
    map. To do this, you iterate through the tiled image and process each pixel. First
    you look up the value of the corresponding pixel from the depth map and divide
    this value by 10 to determine a shift value for the tiled image ❼. You divide
    by 10 because you’re using an 8-bit depth map here, which means the depth varies
    from 0 to 255\. If you divide these values by 10, you get depth values in the
    approximate range of 0 to 25\. Since the depth map input image dimensions are
    usually in the hundreds of pixels, these shift values work fine. (Play around
    by changing the value you divide by to see how it affects the final image.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 立体图创建算法的核心在于根据从深度图收集的信息，如何在瓦片图像中移动像素。为此，你将遍历瓦片图像并处理每个像素。首先，你查找对应像素在深度图中的值，并将其除以10，以确定瓦片图像的位移值❼。你之所以除以10，是因为这里使用的是8位深度图，这意味着深度值从0到255。如果将这些值除以10，你将得到大致范围为0到25的深度值。由于深度图输入图像的尺寸通常是几百个像素，这些位移值是可以正常工作的。（你可以尝试改变除数，看看它如何影响最终图像。）
- en: Next, you use the formula discussed in [“Shifting Pixels”](nsp-venkitachalam503045-0021.xhtml#bh1003)
    on [page 140](nsp-venkitachalam503045-0021.xhtml#p140) to calculate the x-axis
    coordinate to look for the pixel’s new color value ❽. Pixels with a depth map
    value of 0 (black) won’t be shifted and will be perceived as the background. After
    checking to make sure you’re not trying to access a pixel that’s not in the image
    (which can happen at the image’s edges because of the shift) ❾, you replace each
    pixel with its shifted value ❿.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您使用在[“Shifting Pixels”](nsp-venkitachalam503045-0021.xhtml#bh1003)中讨论的公式，在[第140页](nsp-venkitachalam503045-0021.xhtml#p140)上计算要查找像素新颜色值的x轴坐标❽。深度图值为0（黑色）的像素不会被移动，并将被视为背景。确保你没有尝试访问图像中不存在的像素（因为由于位移，可能会发生在图像边缘）❾后，你将每个像素替换为其位移后的值❿。
- en: '[Providing Command Line Options](nsp-venkitachalam503045-0008.xhtml#rbh1007)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[提供命令行选项](nsp-venkitachalam503045-0008.xhtml#rbh1007)'
- en: The `main()` function of the program provides some command line options to customize
    the autostereogram.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`main()`函数提供了一些命令行选项，以自定义立体图。
- en: 'def main():'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# create a parser'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个解析器'
- en: parser = argparse.ArgumentParser(description="Autostereograms...")
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="立体图生成器...")
- en: '# add expected arguments'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加预期的参数'
- en: ❶ parser.add_argument('--depth', dest='dmFile', required=True)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser.add_argument('--depth', dest='dmFile', required=True)
- en: parser.add_argument('--tile', dest='tileFile', required=False)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--tile', dest='tileFile', required=False)
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--out', dest='outFile', required=False)
- en: '# parse args'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: args = parser.parse_args()
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set the output file'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置输出文件'
- en: outFile = 'as.png'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = 'as.png'
- en: 'if args.outFile:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.outFile:'
- en: outFile = args.outFile
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = args.outFile
- en: '# set tile'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置瓦片'
- en: tileFile = False
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: tileFile = False
- en: 'if args.tileFile:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.tileFile:'
- en: tileFile = Image.open(args.tileFile)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: tileFile = Image.open(args.tileFile)
- en: As with previous projects, you define the command line options for the program
    using `argparse`. The one required argument is the name of the depth map file
    ❶. There are also two optional arguments, one to provide an image file to use
    as the tile pattern and the other to set the name of the output file. If a tile
    image isn’t specified, the program will generate a tile of random circles. If
    the output filename isn’t specified, the autostereogram is written to a file named
    *as.png*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的项目一样，你使用`argparse`定义程序的命令行选项。唯一必需的参数是深度图文件的名称 ❶。还有两个可选参数，一个是提供作为瓦片图案的图像文件，另一个是设置输出文件的名称。如果没有指定瓦片图像，程序将生成一个包含随机圆圈的瓦片。如果没有指定输出文件名，立体图将被写入名为*as.png*的文件。
- en: '[Running the Autostereogram Generator](nsp-venkitachalam503045-0008.xhtml#rah1004)'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行立体图生成器](nsp-venkitachalam503045-0008.xhtml#rah1004)'
- en: 'Now let’s run the program using a depth map of a stool (*stool-depth.png*),
    which you’ll find in the *data* folder of this project’s GitHub repository:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用一个凳子（*stool-depth.png*）的深度图来运行程序，你可以在此项目GitHub仓库的*data*文件夹中找到它：
- en: $ `python autos.py --depth data/stool-depth.png`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python autos.py --depth data/stool-depth.png`
- en: '[Figure 8-8](nsp-venkitachalam503045-0021.xhtml#fig8-8) shows the depth map
    image on the left and the generated autostereogram on the right. Because you haven’t
    supplied a graphic for the tile, this autostereogram is created using random tiles.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-8](nsp-venkitachalam503045-0021.xhtml#fig8-8)显示了左侧的深度图像和右侧生成的自动立体图。因为你没有提供拼贴图形，这个自动立体图是使用随机拼贴生成的。'
- en: '![](images/nsp-venkitachalam503045-f08008.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08008.jpg)'
- en: 'Figure 8-8: A sample run of *autos.py*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-8：*autos.py*示例运行
- en: Now let’s give a tile image as input. Use the *stool-depth.png* depth map as
    you did earlier, but this time, supply the image *escher-tile.jpg* for the tiles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用拼贴图像作为输入。像之前一样使用*stool-depth.png*深度图，但这次提供图像*escher-tile.jpg*作为拼贴图像。
- en: $ `python autos.py --depth data/stool-depth.png –-tile data/escher-tile.jpg`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python autos.py --depth data/stool-depth.png --tile data/escher-tile.jpg`
- en: '[Figure 8-9](nsp-venkitachalam503045-0021.xhtml#fig8-9) shows the output.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-9](nsp-venkitachalam503045-0021.xhtml#fig8-9)显示了输出结果。'
- en: '![](images/nsp-venkitachalam503045-f08009.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f08009.jpg)'
- en: 'Figure 8-9: A sample run of *autos.py* using tiles'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9：使用拼贴的*autos.py*示例运行
- en: Enjoy creating moiré autostereograms using the images I’ve provided on GitHub
    or using your own depth maps!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 享受使用我在 GitHub 上提供的图像或你自己的深度图，制作莫尔纹自动立体图的乐趣！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1005)'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1005)'
- en: In this project, you learned how to create autostereograms. Given a depth map
    image, you can now create either a random dot autostereogram or one tiled with
    an image you supply.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你学会了如何创建自动立体图。给定一个深度图像，现在你可以创建一个随机点的自动立体图，或者是使用你提供的图像拼贴而成的自动立体图。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1006)'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1006)'
- en: 'Here are some ways to further explore autostereograms:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以进一步探索自动立体图：
- en: '1\. Write code to create an image similar to [Figure 8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)
    that demonstrates how changes in the linear spacing in an image can create illusions
    of depth. (Hint: use image tiles and the `Image.paste()` method.)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 编写代码创建一个类似于[图8-2](nsp-venkitachalam503045-0021.xhtml#fig8-2)的图像，展示图像中线性间距的变化如何产生深度错觉。（提示：使用图像拼贴和`Image.paste()`方法。）
- en: 2\. Add a command line option to the program to specify the scale to be applied
    to the depth map values. (Remember that the code divides the depth map value by
    10.) How does changing the value affect the autostereogram?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 给程序添加一个命令行选项，用来指定应用于深度图值的缩放比例。（记住代码是将深度图值除以 10。）改变该值会如何影响自动立体图？
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1007)'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah1007)'
- en: 'Here’s the complete autostereogram project code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的自动立体图项目代码：
- en: '"""'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: autos.py
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: autos.py
- en: A program to create autostereograms.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于创建自动立体图的程序。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, random, argparse
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, random, argparse
- en: from PIL import Image, ImageDraw
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: from PIL import Image, ImageDraw
- en: create spacing/depth example
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建间距/深度示例
- en: 'def createSpacingDepthExample():'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createSpacingDepthExample():'
- en: tiles = [Image.open('test/a.png'), Image.open('test/b.png'),
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: tiles = [Image.open('test/a.png'), Image.open('test/b.png'),
- en: Image.open('test/c.png')]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Image.open('test/c.png')]
- en: img = Image.new('RGB', (600, 400), (0, 0, 0))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: img = Image.new('RGB', (600, 400), (0, 0, 0))
- en: spacing = [10, 20, 40]
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: spacing = [10, 20, 40]
- en: 'for j, tile in enumerate(tiles):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j, tile in enumerate(tiles):'
- en: 'for i in range(8):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(8):'
- en: img.paste(tile, (10 + i*(100 + j*10), 10 + j*100))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: img.paste(tile, (10 + i*(100 + j*10), 10 + j*100))
- en: img.save('sdepth.png')
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: img.save('sdepth.png')
- en: create image filled with random dots
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个随机点填充的图像
- en: 'def createRandomTile(dims):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createRandomTile(dims):'
- en: '# create image'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建图像'
- en: img = Image.new('RGB', dims)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: img = Image.new('RGB', dims)
- en: draw = ImageDraw.Draw(img)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: draw = ImageDraw.Draw(img)
- en: '# calculate radius - % of min dimension'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算半径 - 最小尺寸的百分比'
- en: r = int(min(*dims)/100)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: r = int(min(*dims)/100)
- en: '# number of dots'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 点的数量'
- en: n = 1000
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: n = 1000
- en: '# draw random circles'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制随机圆圈'
- en: 'for i in range(n):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: '# -r is used so circle stays inside - cleaner for tiling'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '# -r 用来保证圆形保持在内部，拼贴时更整洁'
- en: x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)
- en: fill = (random.randint(0, 255), random.randint(0, 255),
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: fill = (random.randint(0, 255), random.randint(0, 255),
- en: random.randint(0, 255))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: random.randint(0, 255))
- en: draw.ellipse((x-r, y-r, x+r, y+r), fill)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: draw.ellipse((x-r, y-r, x+r, y+r), fill)
- en: '# return image'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回图像'
- en: return img
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: return img
- en: create a larger image of size dims by tiling the given image
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过拼接给定图像创建一个更大的图像，尺寸为 dims
- en: 'def createTiledImage(tile, dims):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createTiledImage(tile, dims):'
- en: '# create output image'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建输出图像'
- en: img = Image.new('RGB', dims)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: img = Image.new('RGB', dims)
- en: W, H = dims
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: W, H = dims
- en: w, h = tile.size
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: w, h = tile.size
- en: '# calculate # of tiles needed'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算所需的图块数量'
- en: cols = int(W/w) + 1
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: cols = int(W/w) + 1
- en: rows = int(H/h) + 1
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: rows = int(H/h) + 1
- en: '# paste tiles'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 粘贴图块'
- en: 'for i in range(rows):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(rows):'
- en: 'for j in range(cols):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(cols):'
- en: img.paste(tile, (j*w, i*h))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: img.paste(tile, (j*w, i*h))
- en: '# output image'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输出图像'
- en: return img
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: return img
- en: 'create a depth map for testing:'
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于测试的深度图：
- en: 'def createDepthMap(dims):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createDepthMap(dims):'
- en: dmap = Image.new('L', dims)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: dmap = Image.new('L', dims)
- en: dmap.paste(10, (200, 25, 300, 125))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: dmap.paste(10, (200, 25, 300, 125))
- en: dmap.paste(30, (200, 150, 300, 250))
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: dmap.paste(30, (200, 150, 300, 250))
- en: dmap.paste(20, (200, 275, 300, 375))
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: dmap.paste(20, (200, 275, 300, 375))
- en: return dmap
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: return dmap
- en: given a depth map (image) and an input image, create a new image
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给定深度图（图像）和输入图像，创建一张新图像
- en: with pixels shifted according to depth
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据深度偏移的像素
- en: 'def createDepthShiftedImage(dmap, img):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createDepthShiftedImage(dmap, img):'
- en: '# size check'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '# 大小检查'
- en: assert dmap.size == img.size
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: assert dmap.size == img.size
- en: '# create shifted image'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建偏移图像'
- en: sImg = img.copy()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: sImg = img.copy()
- en: '# get pixel access'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取像素访问'
- en: pixD = dmap.load()
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: pixD = dmap.load()
- en: pixS = sImg.load()
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: pixS = sImg.load()
- en: '# shift pixels output based on depth map'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据深度图偏移像素输出'
- en: cols, rows = sImg.size
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: cols, rows = sImg.size
- en: 'for j in range(rows):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(rows):'
- en: 'for i in range(cols):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(cols):'
- en: xshift = pixD[i, j]/10
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: xshift = pixD[i, j]/10
- en: xpos = i - 140 + xshift
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: xpos = i - 140 + xshift
- en: 'if xpos > 0 and xpos < cols:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xpos > 0 且 xpos < cols：
- en: pixS[i, j] = pixS[xpos, j]
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: pixS[i, j] = pixS[xpos, j]
- en: '# return shifted image'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回偏移图像'
- en: return sImg
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: return sImg
- en: given a depth map (image) and an input image, create a new image
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给定深度图（图像）和输入图像，创建一张新图像
- en: with pixels shifted according to depth
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据深度偏移的像素
- en: 'def createAutostereogram(dmap, tile):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createAutostereogram(dmap, tile):'
- en: '# convert depth map to single channel if needed'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果需要，将深度图转换为单通道'
- en: 'if dmap.mode != ''L'':'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 dmap.mode != 'L'：
- en: dmap = dmap.convert('L')
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: dmap = dmap.convert('L')
- en: '# if no tile specified, use random image'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果没有指定图块，使用随机图像'
- en: 'if not tile:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供图块：
- en: tile = createRandomTile((100, 100))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: tile = createRandomTile((100, 100))
- en: '# create an image by tiling'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '# 通过拼接图块创建图像'
- en: img = createTiledImage(tile, dmap.size)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: img = createTiledImage(tile, dmap.size)
- en: '# create shifted image'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建偏移图像'
- en: sImg = img.copy()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: sImg = img.copy()
- en: '# get pixel access'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取像素访问'
- en: pixD = dmap.load()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: pixD = dmap.load()
- en: pixS = sImg.load()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: pixS = sImg.load()
- en: '# shift pixels output based on depth map'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据深度图偏移像素输出'
- en: cols, rows = sImg.size
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: cols, rows = sImg.size
- en: 'for j in range(rows):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(rows):'
- en: 'for i in range(cols):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(cols):'
- en: xshift = pixD[i, j]/10
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: xshift = pixD[i, j]/10
- en: xpos = i - tile.size[0] + xshift
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: xpos = i - tile.size[0] + xshift
- en: 'if xpos > 0 and xpos < cols:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xpos > 0 且 xpos < cols：
- en: pixS[i, j] = pixS[xpos, j]
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: pixS[i, j] = pixS[xpos, j]
- en: '# return shifted image'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回偏移图像'
- en: return sImg
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: return sImg
- en: main() function
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# use sys.argv if needed'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果需要使用 sys.argv'
- en: print('creating autostereogram...')
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建立体图...')
- en: '# create parser'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建解析器'
- en: parser = argparse.ArgumentParser(description="Autostereograms...")
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="立体图...")
- en: '# add expected arguments'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加预期参数'
- en: parser.add_argument('--depth', dest='dmFile', required=True)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--depth', dest='dmFile', required=True)
- en: parser.add_argument('--tile', dest='tileFile', required=False)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--tile', dest='tileFile', required=False)
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--out', dest='outFile', required=False)
- en: '# parse args'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: args = parser.parse_args()
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set output file'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置输出文件'
- en: outFile = 'as.png'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = 'as.png'
- en: 'if args.outFile:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 args.outFile：
- en: outFile = args.outFile
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = args.outFile
- en: '# set tile'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置图块'
- en: tileFile = False
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: tileFile = False
- en: 'if args.tileFile:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 args.tileFile：
- en: tileFile = Image.open(args.tileFile)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: tileFile = Image.open(args.tileFile)
- en: '# open depth map'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开深度图'
- en: dmImg = Image.open(args.dmFile)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: dmImg = Image.open(args.dmFile)
- en: '# create stereogram'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建立体图'
- en: asImg = createAutostereogram(dmImg, tileFile)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: asImg = createAutostereogram(dmImg, tileFile)
- en: '# write output'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输出图像'
- en: asImg.save(outFile)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: asImg.save(outFile)
- en: call main
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 __name__ == '__main__'：
- en: main()
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '[1](nsp-venkitachalam503045-0021.xhtml#fn1r) The hidden image is a shark.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](nsp-venkitachalam503045-0021.xhtml#fn1r) 隐藏的图像是一只鲨鱼。'
- en: '[2](nsp-venkitachalam503045-0021.xhtml#fn2r) [http://colorstereo.com/texts_.txt/practice.htm](http://colorstereo.com/texts_.txt/practice.htm)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](nsp-venkitachalam503045-0021.xhtml#fn2r) [http://colorstereo.com/texts_.txt/practice.htm](http://colorstereo.com/texts_.txt/practice.htm)'
- en: '[3](nsp-venkitachalam503045-0021.xhtml#fn3r) [https://www.youtube.com/watch?v=oqpDqKpOChE](https://www.youtube.com/watch?v=oqpDqKpOChE)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](nsp-venkitachalam503045-0021.xhtml#fn3r) [https://www.youtube.com/watch?v=oqpDqKpOChE](https://www.youtube.com/watch?v=oqpDqKpOChE)'
