["```py\nimport matplotlib.pyplot as plt\nfrom matplotlib import collections as mc\ndef drawlattice(n,name):\n    for i in range(1,n + 1):\n        for j in range(1,n + 1):\n            plt.plot(i,j,'o',c = 'black')\n    plt.savefig(name)\n```", "```py\ndrawlattice(5,'lattice.png')\n```", "```py\n[(1,2),(1,1)]\n```", "```py\ngame = [[(1,2),(1,1)],[(3,3),(4,3)],[(1,5),(2,5)],[(1,2),(2,2)],[(2,2),(2,1)],[(1,1),(2,1)], \\[(3,4),(3,3)],[(3,4),(4,4)]]\n```", "```py\ndef drawgame(n,name,game):\n    colors2 = []\n    for k in range(0,len(game)):\n        if k%2 == 0:\n            colors2.append('red')\n        else:\n            colors2.append('blue')   \n    lc = mc.LineCollection(game, colors = colors2, linewidths = 2)\n    fig, ax = plt.subplots()\n    for i in range(1,n + 1):\n        for j in range(1,n + 1):\n            plt.plot(i,j,'o',c = 'black')\n    ax.add_collection(lc)\n    ax.autoscale()\n    ax.margins(0.1)\n    plt.savefig(name)\n```", "```py\ndrawgame(5,'gameinprogress.png',game)\n```", "```py\ndef squarefinder(game):\n    countofsquares = 0\n    for line in game:\n        parallel = False\n        left=False\n        right=False\n        if line[0][1]==line[1][1]:\n            if [(line[0][0],line[0][1]-1),(line[1][0],line[1][1] - 1)] in game:\n                parallel=True\n            if [(line[0][0],line[0][1]),(line[1][0]-1,line[1][1] - 1)] in game:\n                left=True           \n            if [(line[0][0]+1,line[0][1]),(line[1][0],line[1][1] - 1)] in game:\n                right=True  \n if parallel and left and right:\n                countofsquares += 1\n    return(countofsquares)\n```", "```py\ndef score(game):\n    score = [0,0]\n    progress = []\n    squares = 0\n    for line in game:\n        progress.append(line)\n        newsquares = squarefinder(progress)\n        if newsquares > squares:\n            if len(progress)%2 == 0:\n                score[1] = score[1] + 1\n            else:\n                score[0] = score[0] + 1\n        squares=newsquares\n    return(score)\n```", "```py\nallpossible = []\n\ngamesize = 5\n\nfor i in range(1,gamesize + 1):\n    for j in range(2,gamesize + 1):\n        allpossible.append([(i,j),(i,j - 1)])\n\nfor i in range(1,gamesize):\n    for j in range(1,gamesize + 1):\n        allpossible.append([(i,j),(i + 1,j)])\n```", "```py\nfor move in allpossible:\n    if move in game:\n        allpossible.remove(move)\n```", "```py\nsimple_tree = [[(4,4),(4,3)],[(1,3),(2,3)]]\n```", "```py\nsimple_tree_with_children = [[[(4,4),(4,3)],[]],[[(1,3),(2,3)],[]]]\n```", "```py\nfull_tree = [[[(4,4),(4,3)],[[(1,3),(2,3)],[(3,1),(4,1)]]],[[(1,3),(2,3)],[[(4,4),(4,3)],\\[(3,1),(4,1)]]]]\n```", "```py\ndef generate_tree(possible_moves,depth,maxdepth):\n    tree = []\n    for move in possible_moves:\n        move_profile = [move]\n        if depth < maxdepth:\n            possible_moves2 = possible_moves.copy()\n            possible_moves2.remove(move)\n            move_profile.append(generate_tree(possible_moves2,depth + 1,maxdepth))\n        tree.append(move_profile)\n    return(tree)\n```", "```py\nallpossible = [[(4,4),(4,3)],[(4,1),(5,1)]]\nthetree = generate_tree(allpossible,0,1)\nprint(thetree)\n```", "```py\n[[[(4, 4), (4, 3)], [[[(4, 1), (5, 1)]]]], [[(4, 1), (5, 1)], [[[(4, 4), (4, 3)]]]]]\n```", "```py\ndef generate_tree(possible_moves,depth,maxdepth,game_so_far):\n    tree = []\n    for move in possible_moves:\n        move_profile = [move]\n        game2 = game_so_far.copy()\n        game2.append(move)\n        move_profile.append(score(game2))\n        if depth < maxdepth:\n            possible_moves2 = possible_moves.copy()\n            possible_moves2.remove(move)\n            move_profile.append(generate_tree(possible_moves2,depth + 1,maxdepth,game2))\n else:\n            move_profile.append([])\n        tree.append(move_profile)\n    return(tree)\n```", "```py\nallpossible = [[(4,4),(4,3)],[(4,1),(5,1)]]\nthetree = generate_tree(allpossible,0,1,[])\nprint(thetree)\n```", "```py\n[[[(4, 4), (4, 3)], [0, 0], [[[(4, 1), (5, 1)], [0, 0], []]]], [[(4, 1), (5, 1)], [0, 0], \\[[[(4, 4), (4, 3)], [0, 0], []]]]]\n```", "```py\nimport numpy as np\ndef minimax(max_or_min,tree):\n    allscores = []\n    for move_profile in tree:\n        if move_profile[2] == []:\n            allscores.append(move_profile[1][0] - move_profile[1][1])\n        else:\n            move,score=minimax((-1) * max_or_min,move_profile[2])\n            allscores.append(score)\n    newlist = [score * max_or_min for score in allscores]\n    bestscore = max(newlist)\n    bestmove = np.argmax(newlist)\n    return(bestmove,max_or_min * bestscore)\n```", "```py\nallpossible = []\n\ngame = [[(1,2),(1,1)],[(3,3),(4,3)],[(1,5),(2,5)],[(1,2),(2,2)],[(2,2),(2,1)],[(1,1),(2,1)],\\[(3,4),(3,3)],[(3,4),(4,4)]]\n\ngamesize = 5\n\nfor i in range(1,gamesize + 1):\n    for j in range(2,gamesize + 1):\n        allpossible.append([(i,j),(i,j - 1)])\n\nfor i in range(1,gamesize):\n    for j in range(1,gamesize + 1):\n        allpossible.append([(i,j),(i + 1,j)])\n\nfor move in allpossible:\n    if move in game:\n        allpossible.remove(move)\n```", "```py\nthetree = generate_tree(allpossible,0,3,game)\n```", "```py\nmove,score = minimax(1,thetree)\n```", "```py\nprint(thetree[move][0])\n```"]