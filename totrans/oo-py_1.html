<html><head></head><body>
<p class="calibre1">method call raises an AbortTransaction exception, control will be transferred </p>
<p class="calibre1">to the except statement 4. </p>
<p class="calibre1">Exceptions are objects. In the except clause, we handle the AbortTransaction </p>
<p class="calibre1">exception that was raised at any lower level. We assign the value of the </p>
<p class="calibre1"><b class="calibre3">82</b>   Chapter 4</p>
<p class="calibre1"><a id="p112"/>exception to the variable error. When we print that variable, the user will see the associated error message. Since the exception was handled in the </p>
<p class="calibre1">except clause, the program continues running, and the user is asked what </p>
<p class="calibre1">they wish to do. </p>
<p class="calibre1"><b class="calibre3">Calling the Same Method on a List of Objects</b></p>
<p class="calibre1">Unlike in our bank example, in cases where individual objects do not need </p>
<p class="calibre1">to be uniquely identified, using a list of objects works extremely well. Let’s </p>
<p class="calibre1">say you’re coding a game and you need to have some number of bad guys, </p>
<p class="calibre1">spaceships, bullets, zombies, or whatever else. Each such object will typically </p>
<p class="calibre1">have some data it remembers and some actions it can perform. As long as </p>
<p class="calibre1">each object does not require a unique identifier, the standard way to handle </p>
<p class="calibre1">this is to create many instances of the object from the class and put all the </p>
<p class="calibre1">objects into a list: </p>
<p class="calibre1">objectList = []  # start off with an empty list</p>
<p class="calibre1">for i in range(nObjects):</p>
<p class="calibre1">oNewObject = MyClass()   # create a new instance</p>
<p class="calibre1">objectList.append(oNewObject)  # store the object in the list</p>
<p class="calibre1">In our game, we represent a world as a large grid, like a spreadsheet. </p>
<p class="calibre1">We want monsters placed at random locations in the grid. Listing 4-12 </p>
<p class="calibre1">shows the start of a Monster class with its __init__() method and a move() </p>
<p class="calibre1">method. When a Monster is instantiated, it is told the number of rows and </p>
<p class="calibre1">columns in the grid and the maximum speed, and it chooses a random </p>
<p class="calibre1">starting location and speed. </p>
<p class="calibre1"><b class="calibre3">File: MonsterExample.py</b></p>
<p class="calibre1">import random</p>
<p class="calibre1">class Monster()</p>
<p class="calibre1">def __init__(self, nRows, nCols, maxSpeed):</p>
<p class="calibre1">self.nRows = nRows  # save away</p>
<p class="calibre1">self.nCols = nCols  # save away</p>
<p class="calibre1">self.myRow = random.randrange(self.nRows) # chooses a random row</p>
<p class="calibre1">self.myCol = random.randrange(self.nCols) # chooses a random col</p>
<p class="calibre1">self.mySpeedX = random.randrange(-maxSpeed, maxSpeed + 1) # chooses an X speed</p>
<p class="calibre1">self.mySpeedY = random.randrange(-maxSpeed, maxSpeed + 1) # chooses a Y speed</p>
<p class="calibre1"># Set other instance variables like health, power, etc. </p>
<p class="calibre1">def move(self):</p>
<p class="calibre1">self.myRow = (self.myRow + self.mySpeedY) %  self.nRows</p>
<p class="calibre1">self.myCol = (self.myCol + self.mySpeedX) % self.nCols</p>
<p class="calibre1"> <i class="calibre4">Listing 4-12: A Monster class that can be used to instantiate many Monsters</i></p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">83</b></p>
<p class="calibre1"><a id="p113"/>With this Monster class, we can create a list of Monster objects like this: N_MONSTERS = 20</p>
<p class="calibre1">N_ROWS = 100   # could be any size</p>
<p class="calibre1">N_COLS = 200   # could be any size </p>
<p class="calibre1">MAX_SPEED = 4</p>
<p class="calibre1">monsterList = []  # start with an empty list</p>
<p class="calibre1">for i in range(N_MONSTERS):</p>
<p class="calibre1">oMonster = Monster(N_ROWS, N_COLS, MAX_SPEED)  # create a Monster</p>
<p class="calibre1">monsterList.append(oMonster)  # add the Monster to our list</p>
<p class="calibre1">This loop will instantiate 20 Monsters, and each will know its own start-</p>
<p class="calibre1">ing location in the grid and its individual speed. Once you have a list of </p>
<p class="calibre1">objects, later in the program when you want each object to do the same </p>
<p class="calibre1">action, you can write a simple loop where you call the same method of each </p>
<p class="calibre1">object in the list:</p>
<p class="calibre1">for objectVariable in objectVariablesList:</p>
<p class="calibre1">objectVariable.someMethod()</p>
<p class="calibre1">For example, if we want each of our Monster objects to move, we could </p>
<p class="calibre1">use a loop like this:</p>
<p class="calibre1">for oMonster in monsterList:</p>
<p class="calibre1">oMonster.move()</p>
<p class="calibre1">Since each Monster object remembers its location and speed, in the </p>
<p class="calibre1">move() method, each Monster can move to and remember its new location. </p>
<p class="calibre1">This technique of building a list of objects and calling the same </p>
<p class="calibre1">method of all objects in the list is extremely useful, and it’s a standard </p>
<p class="calibre1">approach to dealing with a collection of similar objects. We will use this </p>
<p class="calibre1">approach quite often when we get to building games using pygame later. </p>
<p class="calibre1"><b class="calibre3">Interface vs. Implementation</b></p>
<p class="calibre1">Our earlier Account class seems to have methods and instance variables that </p>
<p class="calibre1">work well. When you’re confident your code is working well, you no longer </p>
<p class="calibre1">have to be concerned with the details within the class. When a class does </p>
<p class="calibre1">what you want it to do, all you need to remember is what methods are avail-</p>
<p class="calibre1">able in the class. There are two different ways to look at a class: by focusing </p>
<p class="calibre1">on what it is capable of doing (the  <i class="calibre4">interface</i>) and how it works internally (the <i class="calibre4">implementation</i>). </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">interface</b> </p>
<p class="calibre1">The col ection of methods a class provides (and the parameters that each method </p>
<p class="calibre1">expects) . The interface shows  <i class="calibre4">what</i> an object created from the class can do . </p>
<p class="calibre1"><b class="calibre3">implementation</b>  The actual code of the class, which shows  <i class="calibre4">how</i> an object does what it does . </p>
<p class="calibre1"><b class="calibre3">84</b>   Chapter 4</p>
<p class="calibre1"><a id="p114"/>If you are the creator or maintainer of a class, you need to fully understand the implementation—the code of all of the methods and how they </p>
<p class="calibre1">work together to affect the instance variables. If you are purely writing code </p>
<p class="calibre1">to  <i class="calibre4">use</i> a class, you only need to concern yourself with the interface—the </p>
<p class="calibre1">different methods that are available in the class, the values that need to be </p>
<p class="calibre1">passed into each, and any value(s) that are returned from the methods. If </p>
<p class="calibre1">you are coding on your own (as a “one-person team”), then you will be both </p>
<p class="calibre1">the implementer of a class and the user of its interface. </p>
<p class="calibre1">As long as the interface of a class does not change, the class’s imple-</p>
<p class="calibre1">mentation can change at any time. That is, if you find that a method can be </p>
<p class="calibre1">implemented in a faster or more efficient way, changing the relevant code </p>
<p class="calibre1">inside the class will not have any bad side effects on any other part of the </p>
<p class="calibre1">program. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">An object manager object is an object that manages other objects. It does </p>
<p class="calibre1">this by having one or more instance variables that are lists or dictionaries </p>
<p class="calibre1">made up of other objects. The object manager can call methods of any spe-</p>
<p class="calibre1">cific object or of all managed objects. This technique gives full control of </p>
<p class="calibre1">all managed objects to the object manager alone. </p>
<p class="calibre1">When you encounter an error in a method or function, you can raise an </p>
<p class="calibre1">exception. The raise statement returns control to the caller. The caller can </p>
<p class="calibre1">detect a potential error by placing the call in a try block, and it can react to </p>
<p class="calibre1">any such error using an except block. </p>
<p class="calibre1">The interface of a class is the documentation of all the methods and </p>
<p class="calibre1">related parameters in the class. The implementation is the actual code </p>
<p class="calibre1">of the class. What you need to know depends on your role. The writer/ </p>
<p class="calibre1">maintainer of a class needs to understand the details of the code, whereas </p>
<p class="calibre1">anyone who uses the class only needs to understand the interface that the </p>
<p class="calibre1">class provides. </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">85</b></p>
<p class="calibre1"><a id="p115"/>
<a id="p116"/><b class="calibre3">PART II</b></p>
<p class="calibre1"><b class="calibre3">G R A P H I C A L   U S E R </b></p>
<p class="calibre1"><b class="calibre3">I N T E R F A C E S   W I T H   P Y G A M E</b></p>
<p class="calibre1">These chapters introduce you to <i class="calibre4"> pygame, </i> an external </p>
<p class="calibre1">package that adds functionality common to GUI pro-</p>
<p class="calibre1">grams. Pygame allows you to write Python programs </p>
<p class="calibre1">that have windows, respond to the mouse and key-</p>
<p class="calibre1">board, play sounds, and more. </p>
<p class="calibre1"><a href="#p118">Chapter 5 g</a>ives you a basic understanding of how pygame works and provides a standard template for building pygame-based programs. We’ll </p>
<p class="calibre1">build a few simple programs first, create a program that controls an image </p>
<p class="calibre1">with the keyboard, then we’ll build a ball-bouncing program. </p>
<p class="calibre1"><a href="#p150">Chapter 6 e</a>xplains how pygame can best be used as an object-oriented framework. You’ll see how to rewrite the ball-bouncing program using </p>
<p class="calibre1">object-oriented techniques, and develop simple buttons and text input </p>
<p class="calibre1">fields. </p>
<p class="calibre1"><a href="index_split_003.html#p172">Chapter 7 d</a>escribes the pygwidgets module, which contains full implementations of many standard user interface widgets like buttons, input </p>
<p class="calibre1">and output fields, radio buttons, checkboxes, and more, all using object-</p>
<p class="calibre1">oriented programming. All the code is available for you so that you can use </p>
<p class="calibre1">it to build your own applications. I’ll provide several examples. </p>
<p class="calibre1"><a id="p117"/>
<a id="p118"/><b class="calibre3">5</b></p>
<p class="calibre1"><b class="calibre3">I N T R O D U C T I O N   T O   P Y G A M E</b></p>
<p class="calibre1">The Python language was designed to han-</p>
<p class="calibre1">dle text input and text output. It provides </p>
<p class="calibre1">the ability to get text from and send text to </p>
<p class="calibre1">the user, a file, and the internet. The core lan-</p>
<p class="calibre1">guage, however, has no way of dealing with more mod-</p>
<p class="calibre1">ern concepts such as windows, mouse clicks, sounds, </p>
<p class="calibre1">and so on. So, what if you want to use Python to create </p>
<p class="calibre1">something more state-of-the-art than a text-based program? In this chapter </p>
<p class="calibre1">I’ll introduce  <i class="calibre4">pygame</i>, a free open source external package that was designed to extend Python to allow programmers to build game programs. You can </p>
<p class="calibre1">also use pygame to build other kinds of interactive programs with a graphi-</p>
<p class="calibre1">cal user interface (GUI). It adds the ability to create windows, show images, </p>
<p class="calibre1">recognize mouse move ments and clicks, play sounds, and more. In short, it </p>
<p class="calibre1">allows Python programmers to build the types of games and applications </p>
<p class="calibre1">that current computer users have become familiar with. </p>
<p class="calibre1">It is not my intent to turn you all into game programmers—even though </p>
<p class="calibre1">that might be a fun outcome. Rather, I’ll use the pygame environment to </p>
<p class="calibre1"><a id="p119"/>make certain object-oriented programming techniques clearer and more visual. By working with pygame to make objects visible in a window and </p>
<p class="calibre1">dealing with a user interacting with those objects, you should gain a deeper </p>
<p class="calibre1">understanding of how to effectively use OOP techniques. </p>
<p class="calibre1">This chapter provides a general introduction to pygame, so most of the </p>
<p class="calibre1">information and examples in this chapter will use procedural coding. Starting </p>
<p class="calibre1">with the next chapter, I will explain how to use OOP effectively with pygame. </p>
<p class="calibre1"><b class="calibre3">Installing Pygame</b></p>
<p class="calibre1">Pygame is a free downloadable package. We’ll use the package manager </p>
<p class="calibre1"> <i class="calibre4">pip</i> (short for  <i class="calibre4">pip installs packages</i>) to install Python packages. As mentioned in the Introduction, I am assuming that you have installed the official version of Python from  <i class="calibre4">python.org</i>. The pip program is included as part of that download, so you should already have it installed. </p>
<p class="calibre1">Unlike a standard application, you must run pip from the command </p>
<p class="calibre1">line. On a Mac, start the Terminal application (located in the  <i class="calibre4">Utilities</i> </p>
<p class="calibre1">subfolder inside the  <i class="calibre4">Applications</i> folder). On a Windows system, click the </p>
<p class="calibre1">Windows icon, type <b class="calibre3">cmd</b>, and press ENTER. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">This book was not tested with Linux systems. However, most, if not all, of the content</i> <i class="calibre4">should work with minimal tweaking. To install pygame on a Linux distribution, </i></p>
<p class="calibre1"> <i class="calibre4">open a terminal in whatever way you’re used to. </i></p>
<p class="calibre1">Enter the following commands at the command line:</p>
<p class="calibre1">python3 -m pip install -U pip --user</p>
<p class="calibre1">python3 -m pip install -U pygame --user</p>
<p class="calibre1">The first command ensures that you have the latest version of the pip </p>
<p class="calibre1">program. The second line installs the most recent version of pygame. </p>
<p class="calibre1">If you have any problems installing pygame, consult the pygame docu-</p>
<p class="calibre1">mentation at <a href="https://www.pygame.org/wiki/GettingStarted"> <i class="calibre4">https://www.pygame.org/wiki/GettingStarted</i></a>. To test that pygame has been installed correctly, open IDLE (the development environment that </p>
<p class="calibre1">is bundled with the default implementation of Python), and in the shell win-</p>
<p class="calibre1">dow enter:</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">If you see a message saying something like “Hello from the pygame </p>
<p class="calibre1">community” or if you get no message at all, then pygame has been installed </p>
<p class="calibre1">correctly. The lack of an error message indicates that Python has been able </p>
<p class="calibre1">to find and load the pygame package and it’s ready to use. If you would like </p>
<p class="calibre1">to see a sample game using pygame, enter the following command (which </p>
<p class="calibre1">starts a version of  <i class="calibre4">Space Invaders</i>):</p>
<p class="calibre1">python3 -m pygame.examples.aliens</p>
<p class="calibre1"><b class="calibre3">90</b>   Chapter 5</p>
<p class="calibre1"><a id="p120"/>Before we get into using pygame, I need to explain two important concepts. First, I’ll explain how individual pixels are addressed in programs </p>
<p class="calibre1">that use a GUI. Then, I’ll discuss event-driven programs and how they dif-</p>
<p class="calibre1">fer from typical text-based programs. After that, we’ll code a few programs </p>
<p class="calibre1">that demonstrate key pygame features. </p>
<p class="calibre1"><b class="calibre3">Window Details</b></p>
<p class="calibre1">A computer screen is made up of a large number of rows and columns of </p>
<p class="calibre1">small dots called  <i class="calibre4">pixels</i> (from the words  <i class="calibre4">picture element</i>). A user interacts with a GUI program through one or more windows; each window is a rectangular portion of the screen. Programs can control the color of any individual </p>
<p class="calibre1">pixel in their window(s). If you’re running multiple GUI programs, each </p>
<p class="calibre1">program is typically displayed in its own window. In this section, I’ll discuss </p>
<p class="calibre1">how you address and alter individual pixels in a window. These concepts are </p>
<p class="calibre1">independent of Python; they are common to all computers and are used in </p>
<p class="calibre1">all programming languages. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Window Coordinate System</b></i></p>
<p class="calibre1">You are probably familiar with Cartesian coordinates in a grid like Figure 5-1. </p>
<p class="calibre1">y–axis</p>
<p class="calibre1">6</p>
<p class="calibre1">5</p>
<p class="calibre1">4</p>
<p class="calibre1">3</p>
<p class="calibre1">2</p>
<p class="calibre1">1</p>
<p class="calibre1">x–axis</p>
<p class="calibre1">–6  –5  –4  –3  –2  –1 </p>
<p class="calibre1"/>
<p class="calibre1">1 </p>
<p class="calibre1">2 </p>
<p class="calibre1">3 </p>
<p class="calibre1">4 </p>
<p class="calibre1">5 </p>
<p class="calibre1">6</p>
<p class="calibre1">–1</p>
<p class="calibre1">–2</p>
<p class="calibre1">–3</p>
<p class="calibre1">–4</p>
<p class="calibre1">–5</p>
<p class="calibre1">–6</p>
<p class="calibre1"> <i class="calibre4">Figure 5-1: The standard Cartesian coordinate system</i></p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">91</b></p>
<p class="calibre1"><a id="p121"/>Any point in a Cartesian grid can be located by specifying its x- and y-coordinates (in that order). The origin is the point specified as (0, 0) and </p>
<p class="calibre1">is found in the center of the grid. </p>
<p class="calibre1">Computer window coordinates work in a similar way (Figure 5-2). </p>
<p class="calibre1">0</p>
<p class="calibre1">Max x</p>
<p class="calibre1">0</p>
<p class="calibre1">Max y</p>
<p class="calibre1"> <i class="calibre4">Figure 5-2: A computer window’s coordinate system</i></p>
<p class="calibre1">However, there are a few key differences:</p>
<p class="calibre1">1.  The origin (0, 0) point is in the upper-left corner of the window. </p>
<p class="calibre1">2.  The y-axis is reversed so that y values start at zero at the top of the win-</p>
<p class="calibre1">dow and increase as you go down. </p>
<p class="calibre1">3.  The x and y values are always integers. Each (x, y) pair specifies a single </p>
<p class="calibre1">pixel in the window. These values are always specified as relative to the </p>
<p class="calibre1">upper-left corner of the window, not the screen. That way, the user can </p>
<p class="calibre1">move the window anywhere on the screen without affecting the coordi-</p>
<p class="calibre1">nates of the elements of the program displayed in the window. </p>
<p class="calibre1">The full computer screen has its own set of (x, y) coordinates for every </p>
<p class="calibre1">pixel and uses the same type of coordinate system, but programs rarely, if </p>
<p class="calibre1">ever, need to deal with screen coordinates. </p>
<p class="calibre1">When we write a pygame application, we need to specify the width and </p>
<p class="calibre1">height of the window we want to create. Within the window, we can address </p>
<p class="calibre1">any pixel using its x- and y-coordinates, as shown in Figure 5-3. </p>
<p class="calibre1">Figure 5-3 shows a black pixel at position (3, 5). That is an x-value of 3 </p>
<p class="calibre1">(note that this is actually the fourth column, since coordinates start at 0) </p>
<p class="calibre1">and a y value of 5 (actually the sixth row). Each pixel in a window is com-</p>
<p class="calibre1">monly referred to as a  <i class="calibre4">point</i>. To reference a point in a window, you would </p>
<p class="calibre1">typically use a Python tuple. For example, you might have an assignment </p>
<p class="calibre1">statement like this, with the x value first:</p>
<p class="calibre1">pixelLocation = (3, 5)</p>
<p class="calibre1"><b class="calibre3">92</b>   Chapter 5</p>
<p class="calibre1"><a id="p122"/>0 </p>
<p class="calibre1">1 </p>
<p class="calibre1">2 </p>
<p class="calibre1">3 </p>
<p class="calibre1">4 </p>
<p class="calibre1">5 </p>
<p class="calibre1">6 </p>
<p class="calibre1">7 </p>
<p class="calibre1">8 </p>
<p class="calibre1">9 </p>
<p class="calibre1">10  11  12  13  …</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">4</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1">7</p>
<p class="calibre1">8</p>
<p class="calibre1">9</p>
<p class="calibre1">10</p>
<p class="calibre1">11</p>
<p class="calibre1">12</p>
<p class="calibre1">13</p>
<p class="calibre1">…</p>
<p class="calibre1"> <i class="calibre4">Figure 5-3: A single point (a single pixel) in a computer window </i></p>
<p class="calibre1">To show an image in a window, we need to specify the coordinates of its </p>
<p class="calibre1">starting point—always the upper-left corner of the image—as an (x, y) pair, </p>
<p class="calibre1">as in Figure 5-4, where we draw the image at location (3, 5). </p>
<p class="calibre1">When working with an image, you’ll often need to deal with the </p>
<p class="calibre1"> <i class="calibre4">bounding rectangle</i>, which is the smallest rectangle that can be made that </p>
<p class="calibre1">completely surrounds all pixels of the image. A rectangle is represented </p>
<p class="calibre1">in pygame by a set of four values: x, y, width, height. The rectangle for </p>
<p class="calibre1">the image in Figure 5-4 has values of 3, 5, 11, 7. I’ll show you how to use </p>
<p class="calibre1">a rectangle like this in an upcoming example program. Even if your </p>
<p class="calibre1">image is not rectangular (for example, if it’s a circle or an ellipse), you </p>
<p class="calibre1">still have to consider its bounding rectangle for positioning and collision </p>
<p class="calibre1">detection. </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">93</b></p>
<p class="calibre1"><a id="p123"/>0 </p>
<p class="calibre1">1 </p>
<p class="calibre1">2 </p>
<p class="calibre1">3 </p>
<p class="calibre1">4 </p>
<p class="calibre1">5 </p>
<p class="calibre1">6 </p>
<p class="calibre1">7 </p>
<p class="calibre1">8 </p>
<p class="calibre1">9 </p>
<p class="calibre1">10  11  12  13  …</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">4</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1">7</p>
<p class="calibre1">8</p>
<p class="calibre1">9</p>
<p class="calibre1">10</p>
<p class="calibre1">11</p>
<p class="calibre1">12</p>
<p class="calibre1">13</p>
<p class="calibre1">…</p>
<p class="calibre1"> <i class="calibre4">Figure 5-4: An image in a window</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Pixel Colors</b></i></p>
<p class="calibre1">Let’s explore how colors are represented on the computer screen. If you </p>
<p class="calibre1">have experience with a graphics program like Photoshop, you probably </p>
<p class="calibre1">already know how this works, but you may want a quick refresher anyway. </p>
<p class="calibre1">Each pixel on the screen is made up of a combination of three colors: </p>
<p class="calibre1">red, green, and blue, often referred to as  <i class="calibre4">RGB</i>. The color displayed in </p>
<p class="calibre1">any pixel is composed of some amount of red, green, and blue, where the </p>
<p class="calibre1">amount of each is specified as a value from 0, meaning none, to 255, mean-</p>
<p class="calibre1">ing full intensity. Therefore, there are 256 × 256 × 256 possible combina-</p>
<p class="calibre1">tions, or 16,777,216 (often referred to as just “16 million”) possible colors, </p>
<p class="calibre1">for each pixel. </p>
<p class="calibre1">Colors in pygame are given as RGB values, and we write them as Python </p>
<p class="calibre1">tuples of three numbers. Here is how we create constants for the main colors:</p>
<p class="calibre1">RED = (255, 0, 0)   # full red, no green, no blue</p>
<p class="calibre1">GREEN = (0, 255, 0)  # no red, full green, no blue</p>
<p class="calibre1">BLUE = (0, 0, 255)  # no red, no green, full blue</p>
<p class="calibre1"><b class="calibre3">94</b>   Chapter 5</p>
<p class="calibre1"><a id="p124"/>Here are the definitions of a few more colors. You can create a color using any combination of three numbers between 0 and 255:</p>
<p class="calibre1">BLACK = (0, 0, 0)    # no red, no green, no blue</p>
<p class="calibre1">WHITE = (255, 255, 255)  # full red, full green, full blue</p>
<p class="calibre1">DARK_GRAY = (75, 75, 75)</p>
<p class="calibre1">MEDIUM_GRAY = (128, 128, 128)</p>
<p class="calibre1">LIGHT_GRAY = (175, 175, 175)</p>
<p class="calibre1">TEAL = (0, 128, 128)  # no red, half-strength green, half-strength blue</p>
<p class="calibre1">YELLOW = (255, 255, 0)</p>
<p class="calibre1">PURPLE = (128, 0, 128)</p>
<p class="calibre1">In pygame, you’ll need to specify colors when you want to fill the back-</p>
<p class="calibre1">ground of a window, draw a shape in a color, draw text in a color, and so on. </p>
<p class="calibre1">Defining colors up front as tuple constants makes them very easy to spot </p>
<p class="calibre1">later in code. </p>
<p class="calibre1"><b class="calibre3">Event-Driven Programs</b></p>
<p class="calibre1">In most of the programs in the book so far, the main code has lived in a </p>
<p class="calibre1">while loop. The program stops at a call to the built-in input() function and </p>
<p class="calibre1">waits for some user input to work on. Program output is typically handled </p>
<p class="calibre1">using calls to print(). </p>
<p class="calibre1">In interactive GUI programs, this model no longer works. GUIs intro-</p>
<p class="calibre1">duce a new model of computing known as the  <i class="calibre4">event-driven</i> model. Event-</p>
<p class="calibre1">driven programs don’t rely on input() and print(); instead, the user interacts </p>
<p class="calibre1">with elements in a window at will using a keyboard and/or mouse or other </p>
<p class="calibre1">pointing device. They may be able to click various buttons or icons, make </p>
<p class="calibre1">selections from menus, provide input in text fields, or give commands via </p>
<p class="calibre1">clicks or key presses to control some avatar in the window. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">Calls to print() can still be highly useful for debugging, when used to write out intermediate results. </i></p>
<p class="calibre1">Central to event-driven programming is the concept of an  <i class="calibre4">event</i>. Events </p>
<p class="calibre1">are difficult to define and are best described with examples, such as a mouse </p>
<p class="calibre1">click and a key press (each of which is actually made up of two events: mouse </p>
<p class="calibre1">down and mouse up and key down and key up, respectively). Here is my </p>
<p class="calibre1">working definition. </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">event</b> </p>
<p class="calibre1">Something that happens while your program is running that your program wants to </p>
<p class="calibre1">or needs to respond to . Most events are generated by user actions . </p>
<p class="calibre1">An event-driven GUI program runs constantly in an infinite loop. Each </p>
<p class="calibre1">time through the loop, the program checks for any new events it needs to </p>
<p class="calibre1">react to and executes appropriate code to handle those events. Also, each </p>
<p class="calibre1">time through the loop, the program needs to redraw all the elements in the </p>
<p class="calibre1">window to update what the user sees. </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">95</b></p>
<p class="calibre1"><a id="p125"/><img src="index-125_1.png" alt="Image 18" class="calibre2"/></p>
<p class="calibre1">For example, say we have a simple GUI program that displays two but-</p>
<p class="calibre1">tons: Bark and Meow. When clicked, the Bark button plays a sound of a dog </p>
<p class="calibre1">barking and the Meow button plays a sound of a cat meowing (Figure 5-5). </p>
<p class="calibre1"> <i class="calibre4">Figure 5-5: A simple program  </i></p>
<p class="calibre1"> <i class="calibre4">with two but ons</i></p>
<p class="calibre1">The user can click these buttons in any order and at any time. To han-</p>
<p class="calibre1">dle the user’s actions, the program runs in a loop and constantly checks to </p>
<p class="calibre1">see if either button has been clicked. When it receives a mouse down event </p>
<p class="calibre1">on a button, the program remembers that the button has been clicked and </p>
<p class="calibre1">draws the depressed image of that button. When it receives a mouse up </p>
<p class="calibre1">event on the button, it remembers the new state and redraws the button </p>
<p class="calibre1">with its original appearance, and it plays the appropriate sound. Because </p>
<p class="calibre1">the main loop runs so quickly, the user perceives that the sound plays </p>
<p class="calibre1">immediately after they click the button. Each time through the loop, the </p>
<p class="calibre1">program redraws both buttons with an image matching each button’s cur-</p>
<p class="calibre1">rent state. </p>
<p class="calibre1"><b class="calibre3">Using Pygame</b></p>
<p class="calibre1">At first, pygame may seem like an overwhelmingly large package with many </p>
<p class="calibre1">different calls available. Although it is large, there’s actually not a lot that </p>
<p class="calibre1">you need to understand to get a small program up and running. To intro-</p>
<p class="calibre1">duce pygame, I’ll first give you a template that you can use for all pygame </p>
<p class="calibre1">programs you create. Then I’ll build on that template, adding key pieces of </p>
<p class="calibre1">functionality little by little. </p>
<p class="calibre1">In the following sections, I’ll show you how to:</p>
<p class="calibre1">•  Bring up a blank window. </p>
<p class="calibre1">•  Show an image. </p>
<p class="calibre1">•  Detect a mouse click. </p>
<p class="calibre1">•  Detect both single and continuous key presses. </p>
<p class="calibre1">•  Create a simple animation. </p>
<p class="calibre1">•  Play sound effects and background sounds. </p>
<p class="calibre1">•  Draw shapes. </p>
<p class="calibre1">In the next chapter, we’ll continue the discussion of pygame and you’ll </p>
<p class="calibre1">see how to:</p>
<p class="calibre1">•  Animate many objects. </p>
<p class="calibre1">•  Build and react to a button. </p>
<p class="calibre1">•  Create a text display field. </p>
<p class="calibre1"><b class="calibre3">96</b>   Chapter 5</p>
<p class="calibre1"><a id="p126"/> <i class="calibre4"><b class="calibre3">Bringing Up a Blank Window</b></i></p>
<p class="calibre1">As I said earlier, pygame programs run constantly in a loop, checking for </p>
<p class="calibre1">events. It might help to think of your program as an animation, where </p>
<p class="calibre1">each pass through the main loop is one frame. The user may click on </p>
<p class="calibre1">something during any frame, and your program must not only respond </p>
<p class="calibre1">to that input but also keep track of everything it needs to draw in the </p>
<p class="calibre1">window. For instance, in one example program later in this chapter, we’ll </p>
<p class="calibre1">move a ball across the window so in each frame the ball is drawn in a </p>
<p class="calibre1">slightly different position. </p>
<p class="calibre1">Listing 5-1 is a generic template that you can use as a starting point for </p>
<p class="calibre1">all your pygame programs. This program opens a window and paints the </p>
<p class="calibre1">entire contents black. The only thing the user can do is click the close but-</p>
<p class="calibre1">ton to quit the program. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo0_WindowOnly/PygameWindowOnly.py</b></p>
<p class="calibre1"># pygame demo 0 - window only</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1"/>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program </p>
<p class="calibre1">if event.type == pygame.QUIT:           </p>
<p class="calibre1">pygame.quit()  </p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1"/>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">97</b></p>
<p class="calibre1"><a id="p127"/>    window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND) </p>
<p class="calibre1"> <i class="calibre4">Listing 5-1: A template for creating pygame programs </i></p>
<p class="calibre1">Let’s walk through the different parts of this template:</p>
<p class="calibre1">1.  Import packages. </p>
<p class="calibre1">The template starts with the import statements. We first import the pyg-</p>
<p class="calibre1">ame package itself, then some constants defined inside pygame that </p>
<p class="calibre1">we’ll use later. The last import is the sys package, which we’ll use to quit </p>
<p class="calibre1">our program. </p>
<p class="calibre1">2.  Define constants. </p>
<p class="calibre1">We next define any constants for our program. First we define the </p>
<p class="calibre1">RGB value for BLACK, which we will use to paint the background of </p>
<p class="calibre1">our window. Then we define constants for the width and height of our </p>
<p class="calibre1">window in pixels and a constant for the refresh rate for our program. </p>
<p class="calibre1">This number defines the maximum number of times the program will </p>
<p class="calibre1">loop (and therefore redraw the window) per second. Our value of 30 </p>
<p class="calibre1">is fairly typical. If the amount of work done in our main loop is exces-</p>
<p class="calibre1">sive, the program might run slower than this value, but it will never </p>
<p class="calibre1">run faster. A refresh rate that’s too high might cause the program to </p>
<p class="calibre1">run too fast. In our ball example, this means the ball might bounce </p>
<p class="calibre1">around the window faster than intended. </p>
<p class="calibre1">3.  Initialize the pygame environment. </p>
<p class="calibre1">In this section, we call a function that tells pygame to initialize itself. </p>
<p class="calibre1">We then ask pygame to create a window for our program with the </p>
<p class="calibre1">pygame.display.set_mode() function and pass in the desired width and </p>
<p class="calibre1">height of the window. Finally, we call another pygame function to cre-</p>
<p class="calibre1">ate a clock object, which will be used at the bottom of our main loop to </p>
<p class="calibre1">maintain our maximum frame rate. </p>
<p class="calibre1">4.  Load assets: image(s), sound(s), and so on. </p>
<p class="calibre1">This is a placeholder section, into which we will eventually add code to </p>
<p class="calibre1">load external images, sounds, and so on from the disk for use in our </p>
<p class="calibre1">program. In this basic program we’re not using any external assets, so </p>
<p class="calibre1">this section is empty for now. </p>
<p class="calibre1">5.  Initialize variables. </p>
<p class="calibre1">Here we will eventually initialize any variables that our program will </p>
<p class="calibre1">use. Currently we have none, so we have no code here. </p>
<p class="calibre1"><b class="calibre3">98</b>   Chapter 5</p>
<p class="calibre1"><a id="p128"/>6.  Loop forever. </p>
<p class="calibre1">Here we start our main loop. This is a simple while True infinite loop. </p>
<p class="calibre1">Again, you can think of each iteration through the main loop as one </p>
<p class="calibre1">frame in an animation. </p>
<p class="calibre1">7.  Check for and handle events; commonly referred to as the  <i class="calibre4">event loop</i>. </p>
<p class="calibre1">In this section, we call pygame.event.get() to get a list of the events that </p>
<p class="calibre1">happened since the last time we checked (the last time the main loop </p>
<p class="calibre1">ran), then iterate through the list of events. Each event reported to the </p>
<p class="calibre1">program is an object, and every event object has a type. If no event has </p>
<p class="calibre1">happened, this section is skipped over. </p>
<p class="calibre1">In this minimal program, where the only action a user can take is </p>
<p class="calibre1">to close the window, the only event type we check for is the constant </p>
<p class="calibre1">pygame.QUIT,  generated by pygame when the user clicks the close but-</p>
<p class="calibre1">ton. If we find this event, we tell pygame to quit, which frees up any </p>
<p class="calibre1">resources it was using. Then we quit our program. </p>
<p class="calibre1">8.  Do any “per frame” actions. </p>
<p class="calibre1">In this section we’ll eventually put any code that needs to run in every </p>
<p class="calibre1">frame. This might involve moving things in the window or checking for </p>
<p class="calibre1">collisions between elements. In this minimal program, we have nothing </p>
<p class="calibre1">to do here. </p>
<p class="calibre1">9.  Clear the window. </p>
<p class="calibre1">On each iteration through the main loop, our program must redraw </p>
<p class="calibre1">everything in the window, which means we need to clear it first. The </p>
<p class="calibre1">simplest approach is to just fill the window with a color, which we do here </p>
<p class="calibre1">with a call to window.fill(), specifying a black background. We could also </p>
<p class="calibre1">draw a background picture, but we’ll hold off on that for now. </p>
<p class="calibre1">10.  Draw all window elements. </p>
<p class="calibre1">Here we’ll place code to draw everything we want to show in our win-</p>
<p class="calibre1">dow. In this sample program there is nothing to draw. </p>
<p class="calibre1">In real programs, things are drawn in the order they appear in the </p>
<p class="calibre1">code, in layers from backmost to frontmost. For example, assume we </p>
<p class="calibre1">want to draw two partially overlapping circles, A and B. If we draw A </p>
<p class="calibre1">first, A will appear behind B, and portions of A will be obscured by B. </p>
<p class="calibre1">If we draw B first and then A, the opposite happens, and we see A in </p>
<p class="calibre1">front of B. This is a natural mapping equivalent to the layers in graph-</p>
<p class="calibre1">ics programs such as Photoshop. </p>
<p class="calibre1">11.  Update the window. </p>
<p class="calibre1">This line tells pygame to take all the drawing we’ve included and show </p>
<p class="calibre1">it in the window. Pygame actually does all the drawing in steps 8, 9, and </p>
<p class="calibre1">10 in an off-screen buffer. When you tell pygame to update, it takes the </p>
<p class="calibre1">contents of this off-screen buffer and puts them in the real window. </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">99</b></p>
<p class="calibre1"><a id="p129"/><img src="index-129_1.png" alt="Image 19" class="calibre2"/></p>
<p class="calibre1">12.  Slow things down a bit. </p>
<p class="calibre1">Computers are very fast, and if the loop continued to the next iteration </p>
<p class="calibre1">right away without pausing, the program might run faster than the des-</p>
<p class="calibre1">ignated frame rate. The line in this section tells pygame to wait until a </p>
<p class="calibre1">given amount of time has elapsed in order to make the frames of our </p>
<p class="calibre1">program run at the frame rate that we specified. This is important to </p>
<p class="calibre1">ensure the program runs at a consistent rate, independent of the speed </p>
<p class="calibre1">of the computer on which it’s running. </p>
<p class="calibre1">When you run this program, the program just puts up a blank window </p>
<p class="calibre1">filled with black. To end the program, click on the close button in the </p>
<p class="calibre1">title bar. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Drawing an Image </b></i></p>
<p class="calibre1">Let’s draw something in the window. There are two parts to showing a </p>
<p class="calibre1">graphic image: first we load the image into the computer’s memory, then we </p>
<p class="calibre1">display the image in the application window. </p>
<p class="calibre1">With pygame, all images (and sounds) need to be kept in files external </p>
<p class="calibre1">to your code. Pygame supports many standard graphic file formats, includ-</p>
<p class="calibre1">ing  <i class="calibre4">.png</i>,  <i class="calibre4">.jpg</i>, and  <i class="calibre4">.gif</i>. In this program we’ll load a picture of a ball from the file  <i class="calibre4">ball.png</i>. As a reminder, the code and assets associated with all the major listings in this book are available for download at <a href="https://www.nostarch.com/objectorientedpython/"> <i class="calibre4">https://www.nostarch.com/</i></a></p>
<p class="calibre1"><a href="https://www.nostarch.com/objectorientedpython/"> <i class="calibre4">objectorientedpython/</i> a</a>nd<a href="https://github.com/IrvKalb/Object-Oriented-Python-Code/">  <i class="calibre4">https://github.com/IrvKalb/O</i></a> <i class="calibre4">bject-Oriented-Python-Code/</i>. </p>
<p class="calibre1">While we only need one graphic file in this program, it’s a good idea </p>
<p class="calibre1">to use a consistent approach to handling graphic and sound files, so I’ll lay </p>
<p class="calibre1">one out for you here. First, create a project folder. Place your main program </p>
<p class="calibre1">in that folder, along with any related files containing Python classes and </p>
<p class="calibre1">functions. Then, inside the project folder, create an  <i class="calibre4">images</i> folder into which you’ll place any image files you want to use in your program. Also create </p>
<p class="calibre1">a  <i class="calibre4">sounds</i> folder and place any sound files you want to use there. Figure 5-6 </p>
<p class="calibre1">shows the suggested structure.  All of the example programs in this book </p>
<p class="calibre1">will use this project folder layout. </p>
<p class="calibre1"> <i class="calibre4">Figure 5-6: Suggested project folder hierarchy </i></p>
<p class="calibre1">A  <i class="calibre4">path</i> (also called a  <i class="calibre4">pathname</i>) is a string that uniquely identifies the location of a file or folder on a computer. To load a graphic or sound file </p>
<p class="calibre1">into your program, you must specify the path to the file. There are two </p>
<p class="calibre1">types of paths: relative and absolute. </p>
<p class="calibre1">A  <i class="calibre4">relative path</i> is a relative to the current folder, often called the  <i class="calibre4">current</i> <i class="calibre4">working directory</i>. When you run a program using an IDE such as IDLE or </p>
<p class="calibre1"><b class="calibre3">100</b>   Chapter 5</p>
<p class="calibre1"><a id="p130"/>PyCharm, it sets the current folder to the one containing your main Python program so you can use relative paths with ease. In this book, I will assume </p>
<p class="calibre1">you’re using an IDE and will represent all paths as relative paths. </p>
<p class="calibre1">The relative path for a graphic file (for example,  <i class="calibre4">ball.png</i>) in the same </p>
<p class="calibre1">folder as your main Python file would be just the filename as a string (for </p>
<p class="calibre1">example, 'ball.png'). Using the suggested project structure, the relative </p>
<p class="calibre1">path would be 'images/ball.png'. </p>
<p class="calibre1">This says that inside the project folder will be another folder named </p>
<p class="calibre1"> <i class="calibre4">images</i>, and inside that folder is a file named  <i class="calibre4">ball.png</i>. In path strings, folder names are separated by the slash character. </p>
<p class="calibre1">However, if you expect to run your program from the command line, </p>
<p class="calibre1">then you need to construct absolute paths for all files. An  <i class="calibre4">absolute path</i> is one that starts from the root of the filesystem and includes the full hierarchy of folders to your file. To build an absolute path to any file, you can use </p>
<p class="calibre1">code like this, which builds an absolute path string to the  <i class="calibre4">ball.png</i> file in the  <i class="calibre4">images</i> folder inside the project folder:</p>
<p class="calibre1">from pathlib import Path </p>
<p class="calibre1"># Place this in section #2, defining a constant</p>
<p class="calibre1">BASE_PATH = Path(__file__).resolve().parent</p>
<p class="calibre1"># Build a path to the file in the images folder</p>
<p class="calibre1">pathToBall = BASE_PATH + 'images/ball.png' </p>
<p class="calibre1">Now we’ll create the code of the ball program, starting with the ear-</p>
<p class="calibre1">lier 12-step template and adding just two new lines of code, as shown in </p>
<p class="calibre1">Listing 5-2. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo1_OneImage/PygameOneImage.py</b></p>
<p class="calibre1"># pygame demo 1 – draw one image </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">1 ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1"/>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1"># draw ball at position 100 across (x) and 200 down (y)</p>
<p class="calibre1">2 window.blit(ballImage, (100, 200))  </p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">101</b></p>
<p class="calibre1"><a id="p131"/>    pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 5-2: Load one image and draw it in every frame. </i></p>
<p class="calibre1">First, we tell pygame to find the file containing the image of the ball </p>
<p class="calibre1">and load that image into memory 1. The variable ballImage now refers to </p>
<p class="calibre1">the image of the ball. Notice that this assignment statement is only exe-</p>
<p class="calibre1">cuted once, before the main loop starts. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">In the official documentation of pygame, every image, including the application window, is known as a </i> surface <i class="calibre4">. I’ll use more specific terms: I will refer to the application</i> <i class="calibre4">window simply as a </i> window <i class="calibre4"> and to any picture loaded from an external file as an</i> image <i class="calibre4">. I reserve the term </i> surface <i class="calibre4"> for any picture drawn on the fly. </i></p>
<p class="calibre1">We then tell the program to draw the ball 2 every time we go through </p>
<p class="calibre1">the main loop. We specify the location representing the position to place </p>
<p class="calibre1">the upper-left corner of the image’s bounding rectangle, typically as a tuple </p>
<p class="calibre1">of x- and y-coordinates. </p>
<p class="calibre1">The function name blit() is a very old reference to the words  <i class="calibre4">bit block </i></p>
<p class="calibre1"> <i class="calibre4">transfer</i>, but in this context it really just means “draw.” Since the program loaded the ball image earlier, pygame knows how big the image is, so we </p>
<p class="calibre1">just need to tell it where to draw the ball. In Listing 5-2, we give an x value </p>
<p class="calibre1">of 100 and a y value of 200. </p>
<p class="calibre1">When you run the program, on each iteration through the loop (30 </p>
<p class="calibre1">times per second) every pixel in the window is set to black, then the ball </p>
<p class="calibre1">is drawn over the background. From the user’s point of view, it looks like </p>
<p class="calibre1">nothing is happening—the ball just stays in one spot with the upper-left </p>
<p class="calibre1">corner of its bounding rectangle at location (100, 200). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Detecting a Mouse Click</b></i></p>
<p class="calibre1">Next, we’ll allow our program to detect and react to a mouse click. The user </p>
<p class="calibre1">will be able to click on the ball to make it appear somewhere else in the </p>
<p class="calibre1">window. When the program detects a mouse click on the ball, it randomly </p>
<p class="calibre1">picks new coordinates and draws the ball at that new location. Instead of </p>
<p class="calibre1">using hardcoded coordinates of (100, 200), we’ll create two variables, ballX </p>
<p class="calibre1">and ballY, and refer to the coordinates of the ball in the window as the </p>
<p class="calibre1">tuple (ballX, ballY). Listing 5-3 provides the code. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo2_ImageClickAndMove/PygameImageClickAndMove.py</b></p>
<p class="calibre1"># pygame demo 2 - one image, click and move</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1"><b class="calibre3">102</b>   Chapter 5</p>
<p class="calibre1"><a id="p132"/>1 import random</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">2 BALL_WIDTH_HEIGHT = 100</p>
<p class="calibre1">MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT</p>
<p class="calibre1">MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">3 ballX = random.randrange(MAX_WIDTH)</p>
<p class="calibre1">ballY = random.randrange(MAX_HEIGHT)</p>
<p class="calibre1">4 ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)</p>
<p class="calibre1"/>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program</p>
<p class="calibre1">if event.type == pygame.QUIT:           </p>
<p class="calibre1">pygame.quit()  </p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># See if user clicked</p>
<p class="calibre1">5 if event.type == pygame.MOUSEBUTTONUP:</p>
<p class="calibre1"># mouseX, mouseY = event.pos  # Could do this if we needed it</p>
<p class="calibre1"/>
<p class="calibre1"># Check if the click was in the rect of the ball</p>
<p class="calibre1"># If so, choose a random new location</p>
<p class="calibre1">6 if ballRect.collidepoint(event.pos):</p>
<p class="calibre1">ballX = random.randrange(MAX_WIDTH)</p>
<p class="calibre1">ballY = random.randrange(MAX_HEIGHT)</p>
<p class="calibre1">ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT, </p>
<p class="calibre1">BALL_WIDTH_HEIGHT)</p>
<p class="calibre1"># 8  Do any "per frame" actions</p>
<p class="calibre1"/>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1"># Draw the ball at the randomized location</p>
<p class="calibre1">7 window.blit(ballImage, (ballX, ballY)) </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">103</b></p>
<p class="calibre1"><a id="p133"/>    # 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 5-3: Detecting a mouse click and acting on it</i></p>
<p class="calibre1">Since we need to generate random numbers for the ball coordinates, </p>
<p class="calibre1">we import the random package 1. </p>
<p class="calibre1">We then add a new constant to define the height and width of our </p>
<p class="calibre1">image as 100 pixels 2. We also create two more constants to limit the maxi-</p>
<p class="calibre1">mum width and height coordinates. By using these constants rather than </p>
<p class="calibre1">the size of the window, we ensure that our ball image will always appear </p>
<p class="calibre1">fully within the window (remember that when we refer to the location of an </p>
<p class="calibre1">image, we are specifying the position of its upper-left corner). We use those </p>
<p class="calibre1">constants to choose random values for the starting x- and y-coordinates for </p>
<p class="calibre1">our ball 3. </p>
<p class="calibre1">Next, we call pygame.Rect() to create a rectangle 4. Defining a rectangle </p>
<p class="calibre1">requires four parameters—an x-coordinate, a y-coordinate, a width, and a </p>
<p class="calibre1">height, in that order: </p>
<p class="calibre1"> <i class="calibre4">&lt;rectObject&gt; </i> = pygame.Rect( <i class="calibre4">&lt;x&gt; </i>,  <i class="calibre4">&lt;y&gt; </i>,  <i class="calibre4">&lt;width&gt; </i>,  <i class="calibre4">&lt;height&gt; </i>) This returns a pygame rectangle object, or rect. We’ll use the rectangle </p>
<p class="calibre1">of the ball in the processing of events. </p>
<p class="calibre1">We also add code to check if the user clicked the mouse. As mentioned, </p>
<p class="calibre1">a mouse click is actually made up of two different events: a mouse down </p>
<p class="calibre1">event and a mouse up event. Since the mouse up event is typically used to </p>
<p class="calibre1">signal activation, we’ll only look for that event here. This event is signaled </p>
<p class="calibre1">by a new event.type value of pygame.MOUSEBUTTONUP 5. When we find that a </p>
<p class="calibre1">mouse up event has occurred, we’ll then check to see if the location where </p>
<p class="calibre1">the user clicked was inside the current rectangle of the ball. </p>
<p class="calibre1">When pygame detects that an event has happened, it builds an event </p>
<p class="calibre1">object containing a lot of data. In this case, we only care about the x- and </p>
<p class="calibre1">y-coordinates where the event happened. We retrieve the (x, y) position of </p>
<p class="calibre1">the click using event.pos, which provides a tuple of two values. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">If we need to separate the x- and y-coordinates of the click, we can unpack the tuple</i> <i class="calibre4">and store the values into two variables like this:</i></p>
<p class="calibre1">mouseX, mouseY = event.pos</p>
<p class="calibre1">Now we check to see if the event happened inside the rectangle of the </p>
<p class="calibre1">ball using collidepoint() 6, whose syntax is:</p>
<p class="calibre1"> <i class="calibre4">&lt;booleanVariable&gt; </i> =  <i class="calibre4">&lt;someRectangle&gt; </i>.collidepoint( <i class="calibre4">&lt;someXYLocation&gt; </i>) <b class="calibre3">104</b>   Chapter 5</p>
<p class="calibre1"><a id="p134"/>The method returns a Boolean True if the given point is inside the rectangle. If  the user has clicked the ball, we randomly select new values for </p>
<p class="calibre1">ballX and ballY. We use those values to create a new rectangle for the ball at </p>
<p class="calibre1">the new random location. </p>
<p class="calibre1">The only change here is that we always draw the ball at the location </p>
<p class="calibre1">given by the tuple (ballX, ballY) 7. The effect is that whenever the user </p>
<p class="calibre1">clicks inside the rectangle of the ball, the ball appears to move to some new </p>
<p class="calibre1">random spot in the window. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Handling the Keyboard</b></i></p>
<p class="calibre1">The next step is to allow the user to control some aspect of the program </p>
<p class="calibre1">through the keyboard. There are two different ways to handle user key-</p>
<p class="calibre1">board interactions: as individual key presses, and when a user holds down a </p>
<p class="calibre1">key to indicate that an action should happen for as long as that key is down </p>
<p class="calibre1">(known as  <i class="calibre4">continuous mode</i>). </p>
<p class="calibre1"><b class="calibre3">Recognizing Individual Key Presses</b></p>
<p class="calibre1">Like the mouse clicks, each key press generates two events: key down and key </p>
<p class="calibre1">up. The two events have different event types: pygame.KEYDOWN and pygame.KEYUP. </p>
<p class="calibre1">Listing 5-4 shows a small sample program that allows the user to move </p>
<p class="calibre1">the ball image in the window using the keyboard. The program also shows </p>
<p class="calibre1">a target rectangle in the window. The user’s goal is to move the ball image </p>
<p class="calibre1">so that it overlaps with the target image. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardOncePerKey.py</b></p>
<p class="calibre1"># pygame demo 3(a) - one image, move by keyboard</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import random</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">BALL_WIDTH_HEIGHT = 100</p>
<p class="calibre1">MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT</p>
<p class="calibre1">MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT</p>
<p class="calibre1">1 TARGET_X = 400</p>
<p class="calibre1">TARGET_Y = 320</p>
<p class="calibre1">TARGET_WIDTH_HEIGHT = 120</p>
<p class="calibre1">N_PIXELS_TO_MOVE = 3</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">105</b></p>
<p class="calibre1"><a id="p135"/>window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1">2 targetImage = pygame.image.load('images/target.jpg')</p>
<p class="calibre1"/>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">ballX = random.randrange(MAX_WIDTH)</p>
<p class="calibre1">ballY = random.randrange(MAX_HEIGHT)</p>
<p class="calibre1">targetRect = pygame.Rect(TARGET_X, TARGET_Y, TARGET_WIDTH_HEIGHT, TARGET_</p>
<p class="calibre1">WIDTH_HEIGHT)</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program</p>
<p class="calibre1">if event.type == pygame.QUIT:           </p>
<p class="calibre1">pygame.quit()  </p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># See if the user pressed a key           </p>
<p class="calibre1">3 elif event.type == pygame.KEYDOWN:</p>
<p class="calibre1">if event.key == pygame.K_LEFT:</p>
<p class="calibre1">ballX = ballX - N_PIXELS_TO_MOVE</p>
<p class="calibre1">elif event.key == pygame.K_RIGHT:</p>
<p class="calibre1">ballX = ballX + N_PIXELS_TO_MOVE</p>
<p class="calibre1">elif event.key == pygame.K_UP:</p>
<p class="calibre1">ballY = ballY - N_PIXELS_TO_MOVE</p>
<p class="calibre1">elif event.key == pygame.K_DOWN:</p>
<p class="calibre1">ballY = ballY + N_PIXELS_TO_MOVE</p>
<p class="calibre1"># 8  Do any "per frame" actions</p>
<p class="calibre1"># Check if the ball is colliding with the target</p>
<p class="calibre1">4 ballRect = pygame.Rect(ballX, ballY, </p>
<p class="calibre1">BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)</p>
<p class="calibre1">5 if ballRect.colliderect(targetRect):</p>
<p class="calibre1">print('Ball is touching the target')</p>
<p class="calibre1"/>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">6 window.blit(targetImage, (TARGET_X, TARGET_Y))  # draw the target</p>
<p class="calibre1">window.blit(ballImage, (ballX, ballY))  # draw the ball</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 5-4: Detecting and acting on single key presses</i></p>
<p class="calibre1"><b class="calibre3">106</b>   Chapter 5</p>
<p class="calibre1"><a id="p136"/>First we add a few new constants 1 to define the x- and y-coordinates of the upper-left corner of the target rectangle and the width and height of </p>
<p class="calibre1">the target. We then load the image of the target rectangle 2. </p>
<p class="calibre1">In the loop where we look for for events, we add a test for a key press </p>
<p class="calibre1">by checking for an event of type pygame.KEYDOWN 3. If a key down event is </p>
<p class="calibre1">detected, we look into the event to find out what key was pressed. Each </p>
<p class="calibre1">key has an associated constant in pygame, so here we check if the user has </p>
<p class="calibre1">pressed the left, up, down, or right arrow. For each of these keys, we modify </p>
<p class="calibre1">the value of the ball’s x- or y-coordinate appropriately by a small number </p>
<p class="calibre1">of pixels. </p>
<p class="calibre1">Next we create a pygame rect object for the ball based on its x- and </p>
<p class="calibre1">y-coordinates and its height and width 4. We can check to see if two rect-</p>
<p class="calibre1">angles overlap with the following call:</p>
<p class="calibre1"> <i class="calibre4">&lt;booleanVariable&gt; </i> =  <i class="calibre4">&lt;rect1&gt; </i>.colliderect( <i class="calibre4">&lt;rect2&gt; </i>) This call compares two rectangles and returns True if they overlap at all </p>
<p class="calibre1">or False if they don’t. We compare the ball rectangle with the target rectan-</p>
<p class="calibre1">gle 5, and if they overlap, the program prints “Ball is touching the target” </p>
<p class="calibre1">to the shell window. </p>
<p class="calibre1">The last change is where we draw both the target and the ball. The </p>
<p class="calibre1">target is drawn first so that when the two overlap, the ball appears over </p>
<p class="calibre1">the target 6. </p>
<p class="calibre1">When the program is run, if the rectangle of the ball overlaps the rect-</p>
<p class="calibre1">angle of the target, the message is written to the shell window. If you move </p>
<p class="calibre1">the ball away from the target, the message stops being written out. </p>
<p class="calibre1"><b class="calibre3">Dealing with Repeating Keys in Continuous Mode</b></p>
<p class="calibre1">The second way to handle keyboard interactions in pygame is to  <i class="calibre4">poll</i> the </p>
<p class="calibre1">keyboard. This involves asking pygame for a list representing which keys </p>
<p class="calibre1">are currently down in every frame using the following call:</p>
<p class="calibre1"> <i class="calibre4">&lt;aTuple&gt; </i> = pygame.key.get_pressed()</p>
<p class="calibre1">This call returns a tuple of 0s and 1s representing the state of each key: </p>
<p class="calibre1">0 if the key is up, 1 if the key is down. You can then use constants defined </p>
<p class="calibre1">within pygame as an index into the returned tuple to see if a  <i class="calibre4">particular</i> key is down. For example, the following lines can be used to determine the </p>
<p class="calibre1">state of the A key:</p>
<p class="calibre1">keyPressedTuple = pygame.key.get_pressed()</p>
<p class="calibre1"># Now use a constant to get the appropriate element of the tuple</p>
<p class="calibre1">aIsDown = keyPressedTuple[pygame.K_a]</p>
<p class="calibre1">The full listing of constants representing all keys defined in pygame </p>
<p class="calibre1">can be found a<a href="https://www.pygame.org/docs/ref/key.html">t  <i class="calibre4">https://www.pygame.org/docs/ref/key.html</i>. </a></p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">107</b></p>
<p class="calibre1"><a id="p137"/>The code in Listing 5-5 shows how we can use this technique to move an image continuously rather than once per key press. In this version, we </p>
<p class="calibre1">move the keyboard handling from section #7 to section #8. The rest of the </p>
<p class="calibre1">code is identical to the previous version in Listing 5-4. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardContinuous.py</b></p>
<p class="calibre1"># pygame demo 3(b) - one image, continuous mode, move as long as a key is down</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program</p>
<p class="calibre1">if event.type == pygame.QUIT:           </p>
<p class="calibre1">pygame.quit()  </p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1"># Check for user pressing keys</p>
<p class="calibre1">1 keyPressedTuple = pygame.key.get_pressed()</p>
<p class="calibre1"/>
<p class="calibre1">if keyPressedTuple[pygame.K_LEFT]:  # moving left</p>
<p class="calibre1">ballX = ballX - N_PIXELS_TO_MOVE</p>
<p class="calibre1">if keyPressedTuple[pygame.K_RIGHT]:  # moving right</p>
<p class="calibre1">ballX = ballX + N_PIXELS_TO_MOVE</p>
<p class="calibre1">if keyPressedTuple[pygame.K_UP]:  # moving up</p>
<p class="calibre1">ballY = ballY - N_PIXELS_TO_MOVE</p>
<p class="calibre1">if keyPressedTuple[pygame.K_DOWN]:  # moving down</p>
<p class="calibre1">ballY = ballY + N_PIXELS_TO_MOVE            </p>
<p class="calibre1"># Check if the ball is colliding with the target</p>
<p class="calibre1">ballRect = pygame.Rect(ballX, ballY, </p>
<p class="calibre1">BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)</p>
<p class="calibre1">if ballRect.colliderect(targetRect):</p>
<p class="calibre1">print('Ball is touching the target')</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"> <i class="calibre4">Listing 5-5: Handling keys being held down</i></p>
<p class="calibre1">The keyboard-handling code in Listing 5-5 does not rely on events, </p>
<p class="calibre1">so we place the new code outside of the for loop that iterates through all </p>
<p class="calibre1">events returned by pygame 1. </p>
<p class="calibre1">Because we are doing this check in every frame, the movement of the </p>
<p class="calibre1">ball will appear to be continuous as long as the user holds down a key. For </p>
<p class="calibre1">example, if the user presses and holds the right arrow key, this code will </p>
<p class="calibre1">add 3 to the value of the ballX coordinate in every frame, and the user will </p>
<p class="calibre1">see the ball moving smoothly to the right. When they stop pressing the key, </p>
<p class="calibre1">the movement stops. </p>
<p class="calibre1"><b class="calibre3">108</b>   Chapter 5</p>
<p class="calibre1"><a id="p138"/>The other change is that this approach allows you to check for multiple keys being down at the same time. For example, if the user presses and holds </p>
<p class="calibre1">the left and down arrow keys, the ball will move diagonally down and to the </p>
<p class="calibre1">left. You can check for as many keys being held down as you wish. However, </p>
<p class="calibre1">the number of  <i class="calibre4">simultaneous</i> key presses that can be detected is limited by the operating system, the keyboard hardware, and many other factors. The </p>
<p class="calibre1">typical limit is around four keys, but your mileage may vary. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating a Location-Based Animation</b></i></p>
<p class="calibre1">Next, we’ll build a location-based animation. This code will allow us to </p>
<p class="calibre1">move an image diagonally and then have it appear to bounce off the edges </p>
<p class="calibre1">of the window. This was a favorite technique of screensavers on old CRT-</p>
<p class="calibre1">based monitors, to avoid burning in a static image. </p>
<p class="calibre1">We’ll change the location of our image slightly in every frame. We’ll </p>
<p class="calibre1">also check if the result of that movement would place any part of the image </p>
<p class="calibre1">outside one of the window boundaries and, if so, reverse the movement in </p>
<p class="calibre1">that direction. For example, if the image was moving down and would cross </p>
<p class="calibre1">the bottom of the window, we would reverse the direction and make the </p>
<p class="calibre1">image start moving up. </p>
<p class="calibre1">We’ll again use the same starting template. Listing 5-6 gives the full </p>
<p class="calibre1">source code. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo4_OneBal Bounce/PygameOneBal BounceXY.py</b></p>
<p class="calibre1"># pygame demo 4(a) - one image, bounce around the window using (x, y) coords</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import random</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">BALL_WIDTH_HEIGHT = 100</p>
<p class="calibre1">N_PIXELS_PER_FRAME = 3</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">109</b></p>
<p class="calibre1"><a id="p139"/>MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT</p>
<p class="calibre1">MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT</p>
<p class="calibre1">1 ballX = random.randrange(MAX_WIDTH)</p>
<p class="calibre1">ballY = random.randrange(MAX_HEIGHT)</p>
<p class="calibre1">xSpeed = N_PIXELS_PER_FRAME</p>
<p class="calibre1">ySpeed = N_PIXELS_PER_FRAME</p>
<p class="calibre1"/>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"/>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">2 if (ballX &lt; 0) or (ballX &gt;= MAX_WIDTH):</p>
<p class="calibre1">xSpeed = -xSpeed  # reverse X direction</p>
<p class="calibre1">if (ballY &lt; 0) or (ballY &gt;= MAX_HEIGHT):</p>
<p class="calibre1">ySpeed = -ySpeed  # reverse Y direction</p>
<p class="calibre1"># Update the ball's location, using the speed in two directions</p>
<p class="calibre1">3 ballX = ballX + xSpeed</p>
<p class="calibre1">ballY = ballY + ySpeed</p>
<p class="calibre1"># 9 - Clear the window before drawing it again</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw the window elements</p>
<p class="calibre1">window.blit(ballImage, (ballX, ballY))</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  </p>
<p class="calibre1"> <i class="calibre4">Listing 5-6: A location-based animation, bouncing a ball around the window</i></p>
<p class="calibre1">We start by creating and initializing the two variables xSpeed and ySpeed 1, </p>
<p class="calibre1">which determine how far and in what direction the image should move in </p>
<p class="calibre1">each frame. We initialize both variables to the number of pixels to move per </p>
<p class="calibre1">frame (3), so the image will start by moving three pixels to the right (the posi-</p>
<p class="calibre1">tive x direction) and three pixels down (the positive y direction). </p>
<p class="calibre1">In the key part of the program, we handle the x- and y-coordinates </p>
<p class="calibre1">separately 2. First, we check to see if the x-coordinate of the ball is less </p>
<p class="calibre1">than zero, meaning that part of the image is off the left edge, or past the </p>
<p class="calibre1">MAX_WIDTH pixel and so effectively off the right edge. If either of these is the </p>
<p class="calibre1">case, we reverse the sign of the speed in the x direction, meaning it will go </p>
<p class="calibre1">in the opposite direction. For example, if the ball was moving to the right </p>
<p class="calibre1"><b class="calibre3">110</b>   Chapter 5</p>
<p class="calibre1"><a id="p140"/>and went off the right edge, we would change the value of xSpeed from 3 to </p>
<p class="calibre1">–3 to cause the ball to start moving to the left, and vice versa. </p>
<p class="calibre1">Then we do a similar check for the y-coordinate to make the ball </p>
<p class="calibre1">bounce off the top or bottom edge, as needed. </p>
<p class="calibre1">Finally, we update the position of the ball by adding the xSpeed to the </p>
<p class="calibre1">ballX coordinate and adding the ySpeed to the ballY coordinate 3. This posi-</p>
<p class="calibre1">tions the ball at a new location on both axes. </p>
<p class="calibre1">At the bottom of the main loop, we draw the ball. Since we’re updat-</p>
<p class="calibre1">ing the values of ballX and ballY in every frame, the ball appears to ani-</p>
<p class="calibre1">mate smoothly. Try it out. Whenever the ball reaches any edge, it seems to </p>
<p class="calibre1">bounce off. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using Pygame rects </b></i></p>
<p class="calibre1">Next I’ll present a different way to achieve the same result. Rather than </p>
<p class="calibre1">keeping track of the current x- and y-coordinates of the ball in separate </p>
<p class="calibre1">variables, we’ll use the rect of the ball, update the rect every frame, and </p>
<p class="calibre1">check if performing the update would cause any part of the rect to move </p>
<p class="calibre1">outside an edge of the window. This results in fewer variables, and because </p>
<p class="calibre1">we’ll start by making a call to get the rect of an image, it will work with </p>
<p class="calibre1">images of any size. </p>
<p class="calibre1">When you create a rect object, in addition to remembering the left, top, </p>
<p class="calibre1">width, and height as attributes of the rectangle, that object also calculates </p>
<p class="calibre1">and maintains a number of other attributes for you. You can access any of </p>
<p class="calibre1">these attributes directly by name using  <i class="calibre4">dot syntax</i>, as shown in Table 5-1. (I’ll provide more detail on this i<a href="index_split_003.html#p192">n Chapter 8.) </a></p>
<p class="calibre1"><b class="calibre3">Table 5-1:</b> Direct Access to Attributes of a rect </p>
<p class="calibre1"><b class="calibre3">Attribute</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.x</p>
<p class="calibre1">The x-coordinate of the left edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.y</p>
<p class="calibre1">The y-coordinate of the top edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.left</p>
<p class="calibre1">The x-coordinate of the left edge of the rect (same as  </p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.x)</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.top</p>
<p class="calibre1">The y-coordinate of the top edge of the rect (same as </p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.y)</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.right</p>
<p class="calibre1">The x-coordinate of the right edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.bottom</p>
<p class="calibre1">The y-coordinate of the bottom edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.topleft</p>
<p class="calibre1">A two-integer tuple: the coordinates of the upper-left corner of </p>
<p class="calibre1">the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.bottomleft</p>
<p class="calibre1">A two-integer tuple: the coordinates of the lower-left corner of </p>
<p class="calibre1">the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.topright</p>
<p class="calibre1">A two-integer tuple: the coordinates of the upper-right corner of </p>
<p class="calibre1">the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.bottomright</p>
<p class="calibre1">A two-integer tuple: the coordinates of the lower-right corner of </p>
<p class="calibre1">the rect</p>
<p class="calibre1"> <i class="calibre4">(continued)</i></p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">111</b></p>
<p class="calibre1"><a id="p141"/><b class="calibre3">Table 5-1:</b> Direct Access to Attributes of a rect <i class="calibre4"> (continued)</i> <b class="calibre3">Attribute</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.midtop</p>
<p class="calibre1">A two-integer tuple: the coordinates of the midpoint of the top </p>
<p class="calibre1">edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.midleft</p>
<p class="calibre1">A two-integer tuple: the coordinates of the midpoint of the left </p>
<p class="calibre1">edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.midbottom</p>
<p class="calibre1">A two-integer tuple: the coordinates of the midpoint of the bot-</p>
<p class="calibre1">tom edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.midright</p>
<p class="calibre1">A two-integer tuple: the coordinates of the midpoint of the right </p>
<p class="calibre1">edge of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.center</p>
<p class="calibre1">A two-integer tuple: the coordinates at the center of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.centerx</p>
<p class="calibre1">The x-coordinate of the center of the width of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.centery</p>
<p class="calibre1">The y-coordinate of the center of the height of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.size</p>
<p class="calibre1">A two-integer tuple: the (width, height) of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.width</p>
<p class="calibre1">The width of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.height</p>
<p class="calibre1">The height of the rect</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.w</p>
<p class="calibre1">The width of the rect (same as  <i class="calibre4">&lt;rect&gt; </i>.width)</p>
<p class="calibre1"> <i class="calibre4">&lt;rect&gt; </i>.h</p>
<p class="calibre1">The height of the rect (same as  <i class="calibre4">&lt;rect&gt; </i>.height)</p>
<p class="calibre1">A pygame rect also can be thought of, and accessed as, a list of four ele-</p>
<p class="calibre1">ments. Specifically, you can use an index to get or set any individual part </p>
<p class="calibre1">of a rect. For instance, using the ballRect, the individual elements can be </p>
<p class="calibre1">accessed as: </p>
<p class="calibre1">•  ballRect[0] is the x value (but you could also use ballRect.left)</p>
<p class="calibre1">•  ballRect[1] is the y value (but you could also use ballRect.top)</p>
<p class="calibre1">•  ballRect[2] is the width (but you could also use ballRect.width)</p>
<p class="calibre1">•  ballRect[3] is the height (but you could also use ballRect.height)</p>
<p class="calibre1">Listing 5-7 is an alternative version of our bouncing ball program that </p>
<p class="calibre1">maintains all the information about the ball in a rectangle object. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo4_OneBal Bounce/PygameOneBal BounceRects.py</b></p>
<p class="calibre1"># pygame demo 4(b) - one image, bounce around the window using rects</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import random</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1"><b class="calibre3">112</b>   Chapter 5</p>
<p class="calibre1"><a id="p142"/>FRAMES_PER_SECOND = 30</p>
<p class="calibre1">N_PIXELS_PER_FRAME = 3</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">1 ballRect = ballImage.get_rect()</p>
<p class="calibre1">MAX_WIDTH = WINDOW_WIDTH - ballRect.width</p>
<p class="calibre1">MAX_HEIGHT = WINDOW_HEIGHT - ballRect.height</p>
<p class="calibre1">ballRect.left = random.randrange(MAX_WIDTH)</p>
<p class="calibre1">ballRect.top = random.randrange(MAX_HEIGHT)</p>
<p class="calibre1">xSpeed = N_PIXELS_PER_FRAME</p>
<p class="calibre1">ySpeed = N_PIXELS_PER_FRAME </p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"/>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">2 if (ballRect.left &lt; 0) or (ballRect.right &gt;= WINDOW_WIDTH):</p>
<p class="calibre1">xSpeed = -xSpeed  # reverse X direction</p>
<p class="calibre1">if (ballRect.top &lt; 0) or (ballRect.bottom &gt;= WINDOW_HEIGHT):</p>
<p class="calibre1">ySpeed = -ySpeed  # reverse Y direction</p>
<p class="calibre1"># Update the ball's rectangle using the speed in two directions</p>
<p class="calibre1">ballRect.left = ballRect.left + xSpeed</p>
<p class="calibre1">ballRect.top = ballRect.top + ySpeed</p>
<p class="calibre1"># 9 - Clear the window before drawing it again</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw the window elements</p>
<p class="calibre1">3 window.blit(ballImage, ballRect)</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  </p>
<p class="calibre1"> <i class="calibre4">Listing 5-7: A location-based animation, bouncing a ball around the window, using rects</i> Introduction to Pygame   <b class="calibre3">113</b></p>
<p class="calibre1"><a id="p143"/>This approach of using a rect object is neither better nor worse than using separate variables. The resulting program works exactly the same as </p>
<p class="calibre1">the original. The important lesson here is how you can use and manipulate </p>
<p class="calibre1">attributes of a rect object. </p>
<p class="calibre1">After loading the image of the ball, we call the get_rect() method 1 </p>
<p class="calibre1">to get the bounding rectangle of the image. That call returns a rect object, </p>
<p class="calibre1">which we store into a variable called ballRect. We use ballRect.width and </p>
<p class="calibre1">ballRect.height to get direct access to the width and height of the ball image. </p>
<p class="calibre1">(In the previous version, we used a constant of 100 for the width and the </p>
<p class="calibre1">height.) Getting these values from the image that was loaded makes our code </p>
<p class="calibre1">much more adaptable because it means we can use a graphic of any size. </p>
<p class="calibre1">The code also uses the attributes of the rectangle rather than using </p>
<p class="calibre1">separate variables for checking if any part of the ball’s rectangle goes over </p>
<p class="calibre1">an edge. We can use ballRect.left and ballRect.right to see if the ballRect is </p>
<p class="calibre1">off the left or right edges 2. We do a similar test with ballRect.top and ball-</p>
<p class="calibre1">Rect.bottom. Rather than updating individual x- and y-coordinate variables, </p>
<p class="calibre1">we update the left and top of the ballRect. </p>
<p class="calibre1">The other subtle but important change is in the call to draw the ball 3. </p>
<p class="calibre1">The second argument in the call to blit() can be either an (x, y) tuple or a </p>
<p class="calibre1">rect. The code inside blit() uses the left and top position in the rect as the </p>
<p class="calibre1">x- and y-coordinates. </p>
<p class="calibre1"><b class="calibre3">Playing Sounds</b></p>
<p class="calibre1">There are two types of sounds that you might want to play in your pro-</p>
<p class="calibre1">grams: short sound effects and background music. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Playing Sound Effects</b></i></p>
<p class="calibre1">All sound effects must live in external files and must be in either  <i class="calibre4">.wav</i> or </p>
<p class="calibre1"> <i class="calibre4">.ogg</i> format. Playing a relatively short sound effect consists of two steps: load the sound from an external sound file once; then at the appropriate time(s) </p>
<p class="calibre1">play your sound. </p>
<p class="calibre1">To load a sound effect into memory, you use a line like this:</p>
<p class="calibre1"> <i class="calibre4">&lt;soundVariable&gt; </i> = pygame.mixer.Sound( <i class="calibre4">&lt;path to sound file&gt; </i>) To play the sound effect, you only need to call its play() method:</p>
<p class="calibre1"> <i class="calibre4">&lt;soundVariable&gt; </i>.play()</p>
<p class="calibre1">We’ll modify Listing 5-7 to add a “boing” sound effect whenever the </p>
<p class="calibre1">ball bounces off a side of the window. There is a  <i class="calibre4">sounds</i> folder in the project folder at the same level as the main program. Right after loading the ball </p>
<p class="calibre1">image, we load the sound file by adding this code:</p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1">bounceSound = pygame.mixer.Sound('sounds/boing.wav')</p>
<p class="calibre1"><b class="calibre3">114</b>   Chapter 5</p>
<p class="calibre1"><a id="p144"/>To play the “boing” sound effect whenever we change either the horizontal or vertical direction of the ball, we modify section #8 to look like this:</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">if (ballRect.left &lt; 0) or (ballRect.right &gt;= WINDOW_WIDTH):</p>
<p class="calibre1">xSpeed = -xSpeed  # reverse X direction</p>
<p class="calibre1">bounceSound.play()</p>
<p class="calibre1">if (ballRect.top &lt; 0) or (ballRect.bottom &gt;= WINDOW_HEIGHT):</p>
<p class="calibre1">ySpeed = -ySpeed  # reverse Y direction</p>
<p class="calibre1">bounceSound.play()</p>
<p class="calibre1">When you find a condition that should play a sound effect, you add a </p>
<p class="calibre1">call to the play() method of the sound. There are many more options for </p>
<p class="calibre1">controlling sound effects; you can find details in the official documentation </p>
<p class="calibre1">at<a href="https://www.pygame.org/docs/ref/mixer.html">  <i class="calibre4">https://www.pygame.org/docs/ref/mixer.html</i></a>. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Playing Background Music</b></i></p>
<p class="calibre1">Playing background music involves two lines of code using calls to the </p>
<p class="calibre1">pygame.mixer.music module. First, you need this to load the sound file into </p>
<p class="calibre1">memory:</p>
<p class="calibre1">pygame.mixer.music.load( <i class="calibre4">&lt;path to sound file&gt; </i>)</p>
<p class="calibre1">The  <i class="calibre4">&lt;path to sound file&gt; </i> is a path string where the sound file can be found. You can use  <i class="calibre4">.mp3</i> files, which seem to work best, as well as  <i class="calibre4">.wav</i> or  <i class="calibre4">.ogg</i> files. When you want to start the music playing, you need to make this call:</p>
<p class="calibre1">pygame.mixer.music.play( <i class="calibre4">&lt;number of loops&gt; </i>,  <i class="calibre4">&lt;starting position&gt; </i>) To play some background music repeatedly, you can pass in a -1 for </p>
<p class="calibre1"> <i class="calibre4">&lt;number of loops&gt; </i> to run the music forever. The  <i class="calibre4">&lt;starting position&gt; </i> is typically set to 0 to indicate that you want to play the sound from the beginning. </p>
<p class="calibre1">There is a downloadable, modified version of the bouncing ball pro-</p>
<p class="calibre1">gram that properly loads the sound effect and background music files and </p>
<p class="calibre1">starts the background sound playing. The only changes are in section #4, as </p>
<p class="calibre1">shown here. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo4_OneBal Bounce/PyGameOneBal BounceWithSound.py</b></p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">ballImage = pygame.image.load('images/ball.png')</p>
<p class="calibre1">bounceSound = pygame.mixer.Sound('sounds/boing.wav')</p>
<p class="calibre1">pygame.mixer.music.load('sounds/background.mp3')</p>
<p class="calibre1">pygame.mixer.music.play(-1, 0.0)</p>
<p class="calibre1">Pygame allows for much more intricate handling of background </p>
<p class="calibre1">sounds. You can find the full documentation a<a href="https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music">t  <i class="calibre4">https://www.pygame.org/docs/</i></a></p>
<p class="calibre1"><a href="https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music"> <i class="calibre4">ref/music.html#module-pygame.mixer.music</i></a>. </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">115</b></p>
<p class="calibre1"><a id="p145"/><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">In order to make future examples more clearly focused on OOP, I’ll leave out calls to</i> <i class="calibre4">play sound effects and background music. But adding sounds greatly enhances the</i> <i class="calibre4">user experience of a game, and I strongly encourage including them. </i></p>
<p class="calibre1"><b class="calibre3">Drawing Shapes </b></p>
<p class="calibre1">Pygame offers a number of built-in functions that allow you to draw certain </p>
<p class="calibre1">shapes known as  <i class="calibre4">primitives</i>, which include lines, circles, ellipses, arcs, polygons, and rectangles. Table 5-2 provides a list of these functions. Note that </p>
<p class="calibre1">there are two calls that draw  <i class="calibre4">anti-aliased</i> lines. These are lines that include blended colors at the edges to make the lines look smooth and less jagged. </p>
<p class="calibre1">There are two key advantages to using these drawing functions: they exe-</p>
<p class="calibre1">cute extremely quickly, and they allow you to draw simple shapes without </p>
<p class="calibre1">having to create or load images from external files. </p>
<p class="calibre1"><b class="calibre3">Table 5-2:</b> Functions for Drawing Shapes</p>
<p class="calibre1"><b class="calibre3">Function</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1">pygame.draw.aaline() </p>
<p class="calibre1">Draws an anti-aliased line</p>
<p class="calibre1">pygame.draw.aalines() </p>
<p class="calibre1">Draws a series of anti-aliased lines</p>
<p class="calibre1">pygame.draw.arc()</p>
<p class="calibre1">Draws an arc</p>
<p class="calibre1">pygame.draw.circle() </p>
<p class="calibre1">Draws a circle</p>
<p class="calibre1">pygame.draw.ellipse() </p>
<p class="calibre1">Draws an ellipse</p>
<p class="calibre1">pygame.draw.line()</p>
<p class="calibre1">Draws a line</p>
<p class="calibre1">pygame.draw.lines()</p>
<p class="calibre1">Draws a series of lines</p>
<p class="calibre1">pygame.draw.polygon() </p>
<p class="calibre1">Draws a polygon</p>
<p class="calibre1">pygame.draw.rect()</p>
<p class="calibre1">Draws a rectangle </p>
<p class="calibre1">Figure 5-7 shows the output of a sample program that demonstrates </p>
<p class="calibre1">calls to these primitive drawing functions. </p>
<p class="calibre1">Listing 5-8 is the code of the sample program, using the same 12-step </p>
<p class="calibre1">template that produced the output in Figure 5-7. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo5_DrawingShapes.py</b></p>
<p class="calibre1"># pygame demo 5 - drawing</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># Clicked the close button? Quit pygame and end the program</p>
<p class="calibre1">if event.type == pygame.QUIT:           </p>
<p class="calibre1">pygame.quit()  </p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"><b class="calibre3">116</b>   Chapter 5</p>
<p class="calibre1"><a id="p146"/>    # 8 - Do any "per frame" actions</p>
<p class="calibre1"/>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(GRAY)</p>
<p class="calibre1"/>
<p class="calibre1">1 # 10 - Draw all window elements</p>
<p class="calibre1"># Draw a box</p>
<p class="calibre1">pygame.draw.line(window, BLUE, (20, 20), (60, 20), 4)  # top</p>
<p class="calibre1">pygame.draw.line(window, BLUE, (20, 20), (20, 60), 4)  # left</p>
<p class="calibre1">pygame.draw.line(window, BLUE, (20, 60), (60, 60), 4)  # right</p>
<p class="calibre1">pygame.draw.line(window, BLUE, (60, 20), (60, 60), 4)  # bottom</p>
<p class="calibre1"># Draw an X in the box</p>
<p class="calibre1">pygame.draw.line(window, BLUE, (20, 20), (60, 60), 1)</p>
<p class="calibre1">pygame.draw.line(window, BLUE, (20, 60), (60, 20), 1)</p>
<p class="calibre1"/>
<p class="calibre1"># Draw a filled circle and an empty circle</p>
<p class="calibre1">pygame.draw.circle(window, GREEN, (250, 50), 30, 0) # filled</p>
<p class="calibre1">pygame.draw.circle(window, GREEN, (400, 50), 30, 2) # 2 pixel edge</p>
<p class="calibre1"># Draw a filled rectangle and an empty rectangle</p>
<p class="calibre1">pygame.draw.rect(window, RED, (250, 150, 100, 50), 0) # filled</p>
<p class="calibre1">pygame.draw.rect(window, RED, (400, 150, 100, 50), 1) # 1 pixel edge</p>
<p class="calibre1"/>
<p class="calibre1"># Draw a filled ellipse and an empty ellipse</p>
<p class="calibre1">pygame.draw.ellipse(window, YELLOW, (250, 250, 80, 40), 0) # filled</p>
<p class="calibre1">pygame.draw.ellipse(window, YELLOW, (400, 250, 80, 40), 2) # 2 pixel edge</p>
<p class="calibre1"># Draw a six-sided polygon</p>
<p class="calibre1">pygame.draw.polygon(window, TEAL, ((240, 350), (350, 350), </p>
<p class="calibre1">(410, 410), (350, 470), </p>
<p class="calibre1">(240, 470), (170, 410)))</p>
<p class="calibre1"># Draw an arc</p>
<p class="calibre1">pygame.draw.arc(window, BLUE, (20, 400, 100, 100), 0, 2, 5)</p>
<p class="calibre1"/>
<p class="calibre1"># Draw anti-aliased lines: a single line, then a list of points</p>
<p class="calibre1">pygame.draw.aaline(window, RED, (500, 400),  (540, 470), 1)</p>
<p class="calibre1">pygame.draw.aalines(window, BLUE, True, </p>
<p class="calibre1">((580, 400), (587, 450), </p>
<p class="calibre1">(595, 460), (600, 444)), 1)</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 5-8: A program to demonstrate cal s to primitive drawing functions in pygame</i> The drawing of all the primitives occurs in section #10 1. We make </p>
<p class="calibre1">calls to pygame’s drawing functions to draw a box with two diagonals, filled </p>
<p class="calibre1">and empty circles, filled and empty rectangles, filled and empty ovals, a six-</p>
<p class="calibre1">sided polygon, an arc, and two anti-aliased lines. </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">117</b></p>
<p class="calibre1"><a id="p147"/><img src="index-147_1.png" alt="Image 20" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 5-7: A sample program that demonstrates using cal s to draw primitive shapes</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Reference for Primitive Shapes </b></i></p>
<p class="calibre1">For your reference, here is the documentation for the pygame methods to </p>
<p class="calibre1">draw these primitives. In all of the following, the color argument expects </p>
<p class="calibre1">you to pass in a tuple of RGB values:</p>
<p class="calibre1"><b class="calibre3">Anti-aliased line</b></p>
<p class="calibre1">pygame.draw.aaline(window, color, startpos, endpos, blend=True)</p>
<p class="calibre1">Draws an anti-aliased line in the window. If blend is True, the shades will </p>
<p class="calibre1">be blended with existing pixel shades instead of overwriting pixels. </p>
<p class="calibre1"><b class="calibre3">Anti-aliased lines</b></p>
<p class="calibre1">pygame.draw.aalines(window, color, closed, points, blend=True)</p>
<p class="calibre1">Draws a sequence of anti-aliased lines in the window. The closed argu-</p>
<p class="calibre1">ment is a simple Boolean; if it’s True, a line will be drawn between the </p>
<p class="calibre1">first and last points to complete the shape. The points argument is a list </p>
<p class="calibre1">or tuple of (x, y) coordinates to be connected by line segments (there </p>
<p class="calibre1">must be at least two). The Boolean blend argument, if set to True, will </p>
<p class="calibre1">blend the shades with existing pixel shades instead of overwriting them. </p>
<p class="calibre1"><b class="calibre3">118</b>   Chapter 5</p>
<p class="calibre1"><a id="p148"/><b class="calibre3">Arc</b></p>
<p class="calibre1">pygame.draw.arc(window, color, rect, angle_start, angle_stop, width=0)</p>
<p class="calibre1">Draws an arc in the window. The arc will fit inside the given rect. The </p>
<p class="calibre1">two angle arguments are the initial and final angles (in radians, with </p>
<p class="calibre1">zero on the right). The width argument is the thickness to draw the </p>
<p class="calibre1">outer edge. </p>
<p class="calibre1"><b class="calibre3">Circle</b></p>
<p class="calibre1">pygame.draw.circle(window, color, pos, radius, width=0)</p>
<p class="calibre1">Draws a circle in the window. The pos is the center of the circle, and </p>
<p class="calibre1">radius is the radius. The width argument is the thickness to draw the </p>
<p class="calibre1">outer edge. If width is 0, then the circle will be filled. </p>
<p class="calibre1"><b class="calibre3">Ellipse</b></p>
<p class="calibre1">pygame.draw.ellipse(window, color, rect, width=0)</p>
<p class="calibre1">Draws an ellipse in the window. The given rect is the area that the </p>
<p class="calibre1">ellipse will fill. The width argument is the thickness to draw the outer </p>
<p class="calibre1">edge. If width is 0, then the ellipse will be filled. </p>
<p class="calibre1"><b class="calibre3">Line</b></p>
<p class="calibre1">pygame.draw.line(window, color, startpos, endpos, width=1)</p>
<p class="calibre1">Draws a line in a window. The width argument is the thickness of the line. </p>
<p class="calibre1"><b class="calibre3">Lines</b></p>
<p class="calibre1">pygame.draw.lines(window, color, closed, points, width=1)</p>
<p class="calibre1">Draws a sequence of lines in the window. The closed argument is a simple </p>
<p class="calibre1">Boolean; if it’s True, a line will be drawn between the first and last points </p>
<p class="calibre1">to complete the shape. The points argument is a list or tuple of (x, y) </p>
<p class="calibre1">coordinates to be connected by line segments (there must be at least </p>
<p class="calibre1">two). The width argument is the thickness of the line. Note that specify-</p>
<p class="calibre1">ing a line width wider than 1 does not fill in the gaps between the lines. </p>
<p class="calibre1">Therefore, wide lines and sharp corners won’t be joined seamlessly. </p>
<p class="calibre1"><b class="calibre3">Polygon</b></p>
<p class="calibre1">pygame.draw.polygon(window, color, pointslist, width=0)</p>
<p class="calibre1">Draws a polygon in the window. The pointslist specifies the vertices </p>
<p class="calibre1">of the polygon. The width argument is the thickness to draw the outer </p>
<p class="calibre1">edge. If width is 0, then the polygon will be filled. </p>
<p class="calibre1">Introduction to Pygame   <b class="calibre3">119</b></p>
<p class="calibre1"><a id="p149"/><b class="calibre3">Rectangle</b></p>
<p class="calibre1">pygame.draw.rect(window, color, rect, width=0)</p>
<p class="calibre1">Draws a rectangle in the window. The rect is the area of the rectangle. </p>
<p class="calibre1">The width argument is the thickness to draw the outer edge. If width is 0, </p>
<p class="calibre1">then the rectangle will be filled. </p>
<p class="calibre1"><b class="calibre3">N O T E</b></p>
<p class="calibre1"> <i class="calibre4">For additional information, see </i><a href="http://www.pygame.org/docs/ref/draw.html">http://www.pygame.org/docs/ref/draw.html <i class="calibre4">. </i></a></p>
<p class="calibre1">The set of primitive calls allows you the flexibility to draw any shapes </p>
<p class="calibre1">you wish. Again, the order in which you make calls is important. Think of </p>
<p class="calibre1">the order of your calls as layers; elements that are drawn early can be over-</p>
<p class="calibre1">laid by later calls to any other drawing primitive function. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter I introduced the basics of pygame. You installed pygame on </p>
<p class="calibre1">your computer, then learned about the model of event-driven programming </p>
<p class="calibre1">and the use of events, which is very different from coding text-based pro-</p>
<p class="calibre1">grams. I explained the coordinate system of pixels in a window and the way </p>
<p class="calibre1">that colors are represented in code. </p>
<p class="calibre1">To start right at the beginning with pygame, I introduced a 12-section </p>
<p class="calibre1">template that does nothing but bring up a window and can be used to build </p>
<p class="calibre1">any pygame-based program. Using that framework, we then built sample </p>
<p class="calibre1">programs that showed how to draw an image in the window (using blit()), </p>
<p class="calibre1">how to detect mouse events, and how to handle keyboard input. The next </p>
<p class="calibre1">demonstration explained how to build a location-based animation. </p>
<p class="calibre1">Rectangles are highly important in pygame, so I covered how the attri-</p>
<p class="calibre1">butes of a rect object can be used. I also provided some example code to </p>
<p class="calibre1">show how to play sound effects and background music to enhance the user’s </p>
<p class="calibre1">enjoyment of your programs. Finally, I introduced how to use pygame meth-</p>
<p class="calibre1">ods to draw primitive shapes in a window. </p>
<p class="calibre1">While I have introduced many concepts within pygame, almost every-</p>
<p class="calibre1">thing I showed in this chapter has essentially been procedural. The rect </p>
<p class="calibre1">object is an example of object-oriented code built directly into pygame. In </p>
<p class="calibre1">the next chapter, I’ll show how to use OOP in code to use pygame more </p>
<p class="calibre1">effectively. </p>
<p class="calibre1"><b class="calibre3">120</b>   Chapter 5</p>
<p class="calibre1"><a id="p150"/><b class="calibre3">6</b></p>
<p class="calibre1"><b class="calibre3">O B J E C T- O R I E N T E D   P Y G A M E</b></p>
<p class="calibre1">In this chapter I’ll demonstrate how you </p>
<p class="calibre1">can use OOP techniques effectively within </p>
<p class="calibre1">the pygame framework. We’ll start off with </p>
<p class="calibre1">an example of procedural code, then split that </p>
<p class="calibre1">code into a single class and some main code that calls </p>
<p class="calibre1">the methods of that class. After that, we’ll build two </p>
<p class="calibre1">classes, SimpleButton and SimpleText, that implement </p>
<p class="calibre1">basic user interface widgets: a button and a field for </p>
<p class="calibre1">displaying text. I’ll also introduce the concept of a </p>
<p class="calibre1">callback. </p>
<p class="calibre1"><b class="calibre3">Building the Screensaver Ball with OOP Pygame </b></p>
<p class="calibre1">I<a href="#p118">n Chapter 5, w</a>e created an old-school screensaver where a ball bounced around inside a window (Listing 5-6, if you need to refresh your memory). </p>
<p class="calibre1"><a id="p151"/>That code works, but the data for the ball and the code to manipu-</p>
<p class="calibre1">late the ball are intertwined, meaning there’s a lot of initialization code, </p>
<p class="calibre1">and the code to update and draw the ball are embedded in the 12-step </p>
<p class="calibre1">framework. </p>
<p class="calibre1">A more modular approach is to split the code into a Ball class and a </p>
<p class="calibre1">main program that instantiates a Ball object and makes calls to its methods. </p>
<p class="calibre1">In this section we’ll make this split, and I’ll show you how to create multiple </p>
<p class="calibre1">balls from the Ball class. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating a Ball Class</b></i></p>
<p class="calibre1">We’ll start by extracting all code relating to the ball from the main pro-</p>
<p class="calibre1">gram and moving it into a separate Ball class. Looking at the original code, </p>
<p class="calibre1">we can see that the sections that deal with the ball are:</p>
<p class="calibre1">•  Section #4, which loads the image of the ball </p>
<p class="calibre1">•  Section #5, which creates and initializes all the variables that have </p>
<p class="calibre1">something to do with the ball</p>
<p class="calibre1">•  Section #8, which includes code for moving the ball, detecting an edge </p>
<p class="calibre1">bounce, and changing speed and direction</p>
<p class="calibre1">•  Section #10, which draws the ball</p>
<p class="calibre1">From this we can conclude that our Ball class will require the following </p>
<p class="calibre1">methods:</p>
<p class="calibre1"><b class="calibre3">create()  </b>Loads an image, sets a location, and initializes all instance </p>
<p class="calibre1">variables</p>
<p class="calibre1"><b class="calibre3">update()  </b>Changes the location of the ball in every frame, based on the </p>
<p class="calibre1">x speed and y speed of the ball</p>
<p class="calibre1"><b class="calibre3">draw()  </b>Draws the ball in the window </p>
<p class="calibre1">The first step is to create a project folder, in which you need a  <i class="calibre4">Ball.py</i> </p>
<p class="calibre1">for the new Ball class, the main code file  <i class="calibre4">Main_BallBounce.py</i>, and an  <i class="calibre4">images</i> folder containing the  <i class="calibre4">ball.png</i> image file. </p>
<p class="calibre1">Listing 6-1 shows the code of the new Ball class. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo6_Bal BounceObjectOriented/Bal .py</b></p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import random</p>
<p class="calibre1"># Ball class </p>
<p class="calibre1">class Ball():</p>
<p class="calibre1">1 def __init__(self, window, windowWidth, windowHeight):</p>
<p class="calibre1">self.window = window  # remember the window, so we can draw later</p>
<p class="calibre1">self.windowWidth = windowWidth</p>
<p class="calibre1">self.windowHeight = windowHeight</p>
<p class="calibre1"><b class="calibre3">122</b>   Chapter 6</p>
<p class="calibre1"><a id="p152"/>      2 self.image = pygame.image.load('images/ball.png')</p>
<p class="calibre1"># A rect is made up of [x, y, width, height]</p>
<p class="calibre1">ballRect = self.image.get_rect()</p>
<p class="calibre1">self.width = ballRect.width</p>
<p class="calibre1">self.height = ballRect.height</p>
<p class="calibre1">self.maxWidth = windowWidth - self.width</p>
<p class="calibre1">self.maxHeight = windowHeight - self.height</p>
<p class="calibre1"/>
<p class="calibre1"># Pick a random starting position </p>
<p class="calibre1">3 self.x = random.randrange(0, self.maxWidth)</p>
<p class="calibre1">self.y = random.randrange(0, self.maxHeight)</p>
<p class="calibre1"/>
<p class="calibre1"># Choose a random speed between -4 and 4, but not zero, </p>
<p class="calibre1"># in both the x and y directions</p>
<p class="calibre1">4 speedsList = [-4, -3, -2, -1, 1, 2, 3, 4] </p>
<p class="calibre1">self.xSpeed = random.choice(speedsList)</p>
<p class="calibre1">self.ySpeed = random.choice(speedsList)</p>
<p class="calibre1">5 def update(self):</p>
<p class="calibre1"># Check for hitting a wall. If so, change that direction. </p>
<p class="calibre1">if (self.x &lt; 0) or (self.x &gt;= self.maxWidth):</p>
<p class="calibre1">self.xSpeed = -self.xSpeed</p>
<p class="calibre1">if (self.y &lt; 0) or (self.y &gt;= self.maxHeight):</p>
<p class="calibre1">self.ySpeed = -self.ySpeed</p>
<p class="calibre1"># Update the Ball's x and y, using the speed in two directions</p>
<p class="calibre1">self.x = self.x + self.xSpeed</p>
<p class="calibre1">self.y = self.y + self.ySpeed</p>
<p class="calibre1">6 def draw(self):</p>
<p class="calibre1">self.window.blit(self.image, (self.x, self.y))</p>
<p class="calibre1"> <i class="calibre4">Listing 6-1: The new Ball class </i></p>
<p class="calibre1">When we instantiate a Ball object, the __init__() method receives three </p>
<p class="calibre1">pieces of data: the window to draw into, the width of the window, and the </p>
<p class="calibre1">height of the window 1. We save the window variable into the instance vari-</p>
<p class="calibre1">able self.window so that we can use it later in the draw() method, and we do </p>
<p class="calibre1">the same with the self.windowHeight and self.windowWidth instance variables. </p>
<p class="calibre1">We then load the image of the ball using the path to the file and get the </p>
<p class="calibre1">rect of that ball image 2. We need the rect to calculate the maximum val-</p>
<p class="calibre1">ues for x and y so that the ball will always fully appear in the window. Next, </p>
<p class="calibre1">we pick a randomized starting location for the ball 3. Finally, we set the </p>
<p class="calibre1">speed in the x and y directions to a random value between –4 and 4 (but </p>
<p class="calibre1">not 0), representing the number of pixels to move per frame 4. Because </p>
<p class="calibre1">of these numbers, the ball may move differently each time we run the pro-</p>
<p class="calibre1">gram. All these values are saved in instance variables to be used by other </p>
<p class="calibre1">methods. </p>
<p class="calibre1">In the main program, we’ll call the update() method in each frame of </p>
<p class="calibre1">the main loop, so this is where we place the code that checks for the ball </p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">123</b></p>
<p class="calibre1"><a id="p153"/>hitting any border of the window 5. If it does hit an edge, we reverse the speed in that direction and modify the x- and y-coordinates (self.x and </p>
<p class="calibre1">self.y) by the current speed in the x and y directions. </p>
<p class="calibre1">We’ll also call the draw() method, which simply calls blit() to draw the </p>
<p class="calibre1">ball at its current x- and y-coordinates 6, in every frame of the main loop. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using the Ball Class</b></i></p>
<p class="calibre1">Now all functionality associated with a ball has been placed in the Ball </p>
<p class="calibre1">class code. All the main program needs to do is create the ball, then call </p>
<p class="calibre1">its update() and draw() methods in every frame. Listing 6-2 shows the greatly </p>
<p class="calibre1">simplified code of the main program. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo6_Bal BounceObjectOriented/Main_Bal Bounce.py</b></p>
<p class="calibre1"># pygame demo 6(a) - using the Ball class, bounce one ball</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import random</p>
<p class="calibre1">1 from Ball import *  # bring in the Ball class code</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30 </p>
<p class="calibre1"/>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()  </p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"/>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()          </p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">3 oBall.update()  # tell the Ball to update itself</p>
<p class="calibre1"><b class="calibre3">124</b>   Chapter 6</p>
<p class="calibre1"><a id="p154"/>    # 9 - Clear the window before drawing it again</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw the window elements</p>
<p class="calibre1">4 oBall.draw()  # tell the Ball to draw itself</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  </p>
<p class="calibre1"> <i class="calibre4">Listing 6-2: The new main program that instantiates a Ball and makes cal s to its methods</i> If you compare this new main program with the original code in </p>
<p class="calibre1">Listing 5-6, you’ll see that it’s much simpler and clearer. We use an import </p>
<p class="calibre1">statement to bring in the Ball class code 1. We create a Ball object, passing </p>
<p class="calibre1">in the window that we created and the width and height of that window 2, </p>
<p class="calibre1">and we save the resulting Ball object in a variable named oBall. </p>
<p class="calibre1">The responsibility of moving the ball is now in the Ball class code, so </p>
<p class="calibre1">here we only need to call the update() method of the oBall object 3. Since </p>
<p class="calibre1">the Ball object knows how big the window is, how big the image of the ball </p>
<p class="calibre1">is, and the location and the speed of the ball, it can do all the calculations it </p>
<p class="calibre1">needs to do to move the ball and bounce it off the walls. </p>
<p class="calibre1">The main code calls the draw() method of the oBall object 4, but the </p>
<p class="calibre1">actual drawing is done in the oBall object. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating Many Ball Objects</b></i></p>
<p class="calibre1">Now let’s make a slight but important modification to the main program to </p>
<p class="calibre1">create multiple Ball objects. This is one of the real powers of object orien-</p>
<p class="calibre1">tation: to create three balls, we only have to instantiate three Ball objects </p>
<p class="calibre1">from the Ball class. Here we’ll use a basic approach and build a list of Ball </p>
<p class="calibre1">objects. In each frame, we’ll iterate through the list of Ball objects, tell each </p>
<p class="calibre1">one to update its location, then iterate again to tell each one to draw itself. </p>
<p class="calibre1">Listing 6-3 shows a modified main program that creates and updates three </p>
<p class="calibre1">Ball objects. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo6_BallBounceObjectOriented/Main_BallBounceManyBalls.py</b></p>
<p class="calibre1"># pygame demo 6(b) - using the Ball class, bounce many balls</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">N_BALLS = 3</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">1 ballList = []</p>
<p class="calibre1">for oBall in range(0, N_BALLS):</p>
<p class="calibre1"># Each time through the loop, create a Ball object</p>
<p class="calibre1">oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)</p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">125</b></p>
<p class="calibre1"><a id="p155"/>    ballList.append(oBall)  # append the new Ball to the list of Balls   </p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"/>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">2 for oBall in ballList:</p>
<p class="calibre1">oBall.update()  # tell each Ball to update itself</p>
<p class="calibre1"># 9 - Clear the window before drawing it again</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw the window elements</p>
<p class="calibre1">3 for oBall in ballList:</p>
<p class="calibre1">oBall.draw()   # tell each Ball to draw itself</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  </p>
<p class="calibre1"> <i class="calibre4">Listing 6-3: Creating, moving, and displaying three bal s</i></p>
<p class="calibre1">We start with an empty list of Ball objects 1. Then we have a loop </p>
<p class="calibre1">that creates three Ball objects, each of which we append to our list of Ball </p>
<p class="calibre1">objects, ballList. Each Ball object chooses and remembers a randomized </p>
<p class="calibre1">starting location and a randomized speed in both the x and y directions. </p>
<p class="calibre1">Inside the main loop, we iterate through all the Ball objects and tell </p>
<p class="calibre1">each one to update itself 2, changing the x- and y-coordinates of each Ball </p>
<p class="calibre1">object to a new location. We then iterate through the list again, calling the </p>
<p class="calibre1">draw() method of each Ball object 3. </p>
<p class="calibre1">When we run the program, we see three balls, each starting at a ran-</p>
<p class="calibre1">domized location and each moving with a randomized x and y speed. Each </p>
<p class="calibre1">ball bounces correctly off the boundaries of the window. </p>
<p class="calibre1">Using this object-oriented approach, we made no changes to the Ball </p>
<p class="calibre1">class, but just changed our main program to now manage a list of Ball </p>
<p class="calibre1">objects instead of a single Ball object. This is a common, and very positive, </p>
<p class="calibre1">side effect of OOP code: well-written classes can often be reused without </p>
<p class="calibre1">change. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating Many, Many Ball Objects</b></i></p>
<p class="calibre1">We can change the value of the constant N_BALLS from 3 to some much </p>
<p class="calibre1">larger value, like 300, to quickly create that many balls (Figure 6-1). By </p>
<p class="calibre1">changing just a single constant, we make a major change to the behavior </p>
<p class="calibre1">of the program. Each ball maintains its own speed and location and draws </p>
<p class="calibre1">itself. </p>
<p class="calibre1"><b class="calibre3">126</b>   Chapter 6</p>
<p class="calibre1"><a id="p156"/><img src="index-156_1.png" alt="Image 21" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 6-1: Creating, updating, and drawing 300 Ball objects </i></p>
<p class="calibre1">The fact that we can instantiate any number of objects from a single </p>
<p class="calibre1">script will be vital not only in defining game objects like spaceships, zom-</p>
<p class="calibre1">bies, bullets, treasures, and so on, but also in building GUI controls such as </p>
<p class="calibre1">buttons, checkboxes, text input fields, and text outputs. </p>
<p class="calibre1"><b class="calibre3">Building a Reusable Object-Oriented Button</b></p>
<p class="calibre1">The simple button is one of the most recognizable elements of a graphical </p>
<p class="calibre1">user interface. The standard behavior of a button consists of the user using </p>
<p class="calibre1">their mouse to click down on the button image and then releasing it. </p>
<p class="calibre1">Buttons typically consist of at least two images: one to represent the  <i class="calibre4">up</i> </p>
<p class="calibre1">or normal state of the button and another to represent the  <i class="calibre4">down</i> or pressed </p>
<p class="calibre1">state of the button. The sequence of a click can be broken down into the </p>
<p class="calibre1">following steps: </p>
<p class="calibre1">1.  User moves the mouse pointer over the button </p>
<p class="calibre1">2.  User presses the mouse button down</p>
<p class="calibre1">3.  Program reacts by changing the image to the down state</p>
<p class="calibre1">4.  User releases the mouse button</p>
<p class="calibre1">5.  Program reacts by showing the up image of the button</p>
<p class="calibre1">6.  Program performs some action based on the button click</p>
<p class="calibre1">Good GUIs also allow the user to click down on a button, temporarily </p>
<p class="calibre1">roll off the button, changing the button to the up state, and then, with the </p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">127</b></p>
<p class="calibre1"><a id="p157"/>mouse button still down, roll back over the image so the button changes back to the down image. If the user clicks down on a button but then rolls </p>
<p class="calibre1">the mouse off and lifts up on the mouse button, that is not considered a </p>
<p class="calibre1">click. This means the program takes action only when the user presses </p>
<p class="calibre1">down and releases while the mouse is positioned over the image of a button. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Building a Button Class </b></i></p>
<p class="calibre1">The button behavior should be common and consistent for all buttons used </p>
<p class="calibre1">in a GUI, so we’ll build a class that takes care of the behavior details. Once </p>
<p class="calibre1">we’ve built a simple button class, we can instantiate any number of buttons </p>
<p class="calibre1">and they’ll all work exactly the same way. </p>
<p class="calibre1">Let’s consider what behaviors our button class must support. We’ll need </p>
<p class="calibre1">methods to:</p>
<p class="calibre1">•  Load the images of the up and down states, then initialize any instance </p>
<p class="calibre1">variables needed to track the button’s state. </p>
<p class="calibre1">•  Tell the button about all events that the main program has detected </p>
<p class="calibre1">and check whether there are any that the button needs to react to. </p>
<p class="calibre1">•  Draw the current image representing the button. </p>
<p class="calibre1">Listing 6-4 presents the code of a SimpleButton class. (We’ll build a </p>
<p class="calibre1">more complicated button class i<a href="index_split_003.html#p172">n Chapter 7.) T</a>his class has three methods, __init__(), handleEvent(), and draw(), that implement the behaviors mentioned. The code of the handleEvent() method does get a little tricky, but </p>
<p class="calibre1">once you have it working, it’s incredibly easy to use. Feel free to work your </p>
<p class="calibre1">way through it, but know that the implementation of the code is not that </p>
<p class="calibre1">relevant. The important thing here is to understand the purpose and usage </p>
<p class="calibre1">of the different methods. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo7_SimpleButton/SimpleButton.py</b></p>
<p class="calibre1"># SimpleButton class</p>
<p class="calibre1">#</p>
<p class="calibre1"># Uses a "state machine" approach</p>
<p class="calibre1">#</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">class SimpleButton():</p>
<p class="calibre1"># Used to track the state of the button</p>
<p class="calibre1">STATE_IDLE = 'idle' # button is up, mouse not over button</p>
<p class="calibre1">STATE_ARMED = 'armed' # button is down, mouse over button</p>
<p class="calibre1">STATE_DISARMED = 'disarmed' # clicked down on button, rolled off</p>
<p class="calibre1"/>
<p class="calibre1">def __init__(self, window, loc, up, down): 1 </p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.loc = loc</p>
<p class="calibre1">self.surfaceUp = pygame.image.load(up)</p>
<p class="calibre1"><b class="calibre3">128</b>   Chapter 6</p>
<p class="calibre1"><a id="p158"/>        self.surfaceDown = pygame.image.load(down)</p>
<p class="calibre1"># Get the rect of the button (used to see if the mouse is over the button)</p>
<p class="calibre1">self.rect = self.surfaceUp.get_rect()</p>
<p class="calibre1">self.rect[0] = loc[0]</p>
<p class="calibre1">self.rect[1] = loc[1]</p>
<p class="calibre1">self.state = SimpleButton.STATE_IDLE</p>
<p class="calibre1">def handleEvent(self, eventObj): 2 </p>
<p class="calibre1"># This method will return True if user clicks the button. </p>
<p class="calibre1"># Normally returns False. </p>
<p class="calibre1">if eventObj.type not in (MOUSEMOTION, MOUSEBUTTONUP, MOUSEBUTTONDOWN): 3 </p>
<p class="calibre1"># The button only cares about mouse-related events</p>
<p class="calibre1">return False</p>
<p class="calibre1">eventPointInButtonRect = self.rect.collidepoint(eventObj.pos)</p>
<p class="calibre1">if self.state == SimpleButton.STATE_IDLE:</p>
<p class="calibre1">if (eventObj.type == MOUSEBUTTONDOWN) and eventPointInButtonRect:</p>
<p class="calibre1">self.state = SimpleButton.STATE_ARMED</p>
<p class="calibre1">elif self.state == SimpleButton.STATE_ARMED:</p>
<p class="calibre1">if (eventObj.type == MOUSEBUTTONUP) and eventPointInButtonRect:</p>
<p class="calibre1">self.state = SimpleButton.STATE_IDLE</p>
<p class="calibre1">return True  # clicked! </p>
<p class="calibre1">if (eventObj.type == MOUSEMOTION) and (not eventPointInButtonRect):</p>
<p class="calibre1">self.state = SimpleButton.STATE_DISARMED</p>
<p class="calibre1">elif self.state == SimpleButton.STATE_DISARMED:</p>
<p class="calibre1">if eventPointInButtonRect:</p>
<p class="calibre1">self.state = SimpleButton.STATE_ARMED</p>
<p class="calibre1">elif eventObj.type == MOUSEBUTTONUP:</p>
<p class="calibre1">self.state = SimpleButton.STATE_IDLE</p>
<p class="calibre1">return False</p>
<p class="calibre1">def draw(self): 4 </p>
<p class="calibre1"># Draw the button's current appearance to the window</p>
<p class="calibre1">if self.state == SimpleButton.STATE_ARMED:</p>
<p class="calibre1">self.window.blit(self.surfaceDown, self.loc)</p>
<p class="calibre1">else:  # IDLE or DISARMED</p>
<p class="calibre1">self.window.blit(self.surfaceUp, self.loc)</p>
<p class="calibre1"> <i class="calibre4">Listing 6-4: The SimpleButton class</i></p>
<p class="calibre1">The __init__() method begins by saving all values passed in into </p>
<p class="calibre1">instance variables 1 to use in other methods. It then initializes a few </p>
<p class="calibre1">more instance variables. </p>
<p class="calibre1">Whenever the main program detects any event, it calls the handleEvent() </p>
<p class="calibre1">method 2. This method first checks that the event is one of MOUSEMOTION, </p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">129</b></p>
<p class="calibre1"><a id="p159"/><img src="index-159_1.png" alt="Image 22" class="calibre2"/></p>
<p class="calibre1">MOUSEBUTTONUP, or MOUSEBUTTONDOWN 3. The rest of the method is implemented </p>
<p class="calibre1">as a  <i class="calibre4">state machine</i>, a technique that I will go into more detail about in </p>
<p class="calibre1"><a href="index_split_006.html#p340">Chapter 15. </a>The code is a little complicated, and you should feel free to study how it works, but for now note that it uses the instance variable  </p>
<p class="calibre1">self.state (over the course of multiple calls) to detect if the user has </p>
<p class="calibre1">clicked on the button. The handleEvent() method returns True when the </p>
<p class="calibre1">user completes a mouse click by pressing down on the button, then later </p>
<p class="calibre1">releasing on the same button. In all other cases, handleEvent() returns </p>
<p class="calibre1">False. </p>
<p class="calibre1">Finally, the draw() method uses the state of the object’s instance variable </p>
<p class="calibre1">self.state to decide which image (up or down) to draw 4. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main Code Using a SimpleButton</b></i></p>
<p class="calibre1">To use a SimpleButton in the main code, we first instantiate one from the </p>
<p class="calibre1">SimpleButton class before the main loop starts with a line like this:</p>
<p class="calibre1">oButton = SimpleButton(window, (150, 30), </p>
<p class="calibre1">'images/buttonUp.png', </p>
<p class="calibre1">'images/buttonDown.png')</p>
<p class="calibre1">This line creates a SimpleButton object, specifying a location to draw </p>
<p class="calibre1">it (as usual, the coordinates are for the top-left corner of the bounding </p>
<p class="calibre1">rectangle) and providing the paths to both the up and down images of the </p>
<p class="calibre1">button. In the main loop, any time any event happens we need to call the </p>
<p class="calibre1">handleEvent() method to see if the user has clicked the button. If the user </p>
<p class="calibre1">clicks the button, the program should perform some action. Also in the </p>
<p class="calibre1">main loop, we need to call the draw() method to make the button show in </p>
<p class="calibre1">the window. </p>
<p class="calibre1">We’ll build a small test program, which will generate a user interface </p>
<p class="calibre1">like Figure 6-2, to incorporate one instance of a SimpleButton. </p>
<p class="calibre1"> <i class="calibre4">Figure 6-2: The user interface of a program with a single instance of a SimpleButton</i> Whenever the user completes a click on the button, the program </p>
<p class="calibre1">outputs a line of text in the shell saying that the button has been clicked. </p>
<p class="calibre1">Listing 6-5 contains the main program code. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo7_SimpleButton/Main_SimpleButton.py</b></p>
<p class="calibre1"># Pygame demo 7 - SimpleButton test </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1"># Create an instance of a SimpleButton</p>
<p class="calibre1"><b class="calibre3">130</b>   Chapter 6</p>
<p class="calibre1"><a id="p160"/>1 oButton = SimpleButton(window, (150, 30), </p>
<p class="calibre1">'images/buttonUp.png', </p>
<p class="calibre1">'images/buttonDown.png')</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># Pass the event to the button, see if it has been clicked on</p>
<p class="calibre1">2 if oButton.handleEvent(event):</p>
<p class="calibre1">3 print('User has clicked the button')</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1"/>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(GRAY)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">4 oButton.draw() # draw the button</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  </p>
<p class="calibre1"> <i class="calibre4">Listing 6-5: The main program that creates and reacts to a SimpleButton</i></p>
<p class="calibre1">Again, we start with the standard pygame template from <a href="#p118">Chapter 5. </a></p>
<p class="calibre1">Before the main loop, we create an instance of our SimpleButton 1, specify-</p>
<p class="calibre1">ing a window to draw into, a location, a path to the up image, and a path to </p>
<p class="calibre1">the down image. </p>
<p class="calibre1">Every time through the main loop, we need to react to events detected </p>
<p class="calibre1">in the main program. To implement this, we call the SimpleButton class’s </p>
<p class="calibre1">handleEvent() method 2 and pass in the event from the main program. </p>
<p class="calibre1">The handleEvent() method tracks all of the user’s actions on the button </p>
<p class="calibre1">(pressing down, releasing, rolling off, rolling back on). When handleEvent() </p>
<p class="calibre1">returns True, indicating that a click has occurred, we perform the action </p>
<p class="calibre1">associated with clicking that button. Here, we just print a message 3. </p>
<p class="calibre1">Finally we call the button’s draw() method 4 to draw an image to repre-</p>
<p class="calibre1">sent the appropriate state of the button (up or down). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating a Program with Multiple Buttons</b></i></p>
<p class="calibre1">With our SimpleButton class, we can instantiate as many buttons as we wish. </p>
<p class="calibre1">For example, we can modify our main program to incorporate three </p>
<p class="calibre1">SimpleButton instances, as shown in Figure 6-3. </p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">131</b></p>
<p class="calibre1"><a id="p161"/><img src="index-161_1.png" alt="Image 23" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 6-3: The main program with three SimpleButton objects</i></p>
<p class="calibre1">We don’t need to make any changes to the SimpleButton class file to </p>
<p class="calibre1">do this. We simply modify our main code to instantiate three SimpleButton </p>
<p class="calibre1">objects instead of one. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo7_SimpleButton/Main_SimpleButton3Buttons.py</b></p>
<p class="calibre1">oButtonA = SimpleButton(window, (25, 30), </p>
<p class="calibre1">'images/buttonAUp.png', </p>
<p class="calibre1">'images/buttonADown.png')</p>
<p class="calibre1">oButtonB = SimpleButton(window, (150, 30), </p>
<p class="calibre1">'images/buttonBUp.png', </p>
<p class="calibre1">'images/buttonBDown.png')</p>
<p class="calibre1">oButtonC = SimpleButton(window, (275, 30), </p>
<p class="calibre1">'images/buttonCUp.png', </p>
<p class="calibre1">'images/buttonCDown.png')</p>
<p class="calibre1">We now need to call the handleEvent() method of all three buttons:</p>
<p class="calibre1"># Pass the event to each button, see if one has been clicked</p>
<p class="calibre1">if oButtonA.handleEvent(event):</p>
<p class="calibre1">print('User clicked button A.')</p>
<p class="calibre1">elif oButtonB.handleEvent(event):</p>
<p class="calibre1">print('User clicked button B.')</p>
<p class="calibre1">elif oButtonC.handleEvent(event):</p>
<p class="calibre1">print('User clicked button C.')</p>
<p class="calibre1">Finally, we tell each button to draw itself:</p>
<p class="calibre1">oButtonA.draw()</p>
<p class="calibre1">oButtonB.draw()</p>
<p class="calibre1">oButtonC.draw()</p>
<p class="calibre1">When you run the program, you’ll see a window with three buttons. </p>
<p class="calibre1">Clicking any of the buttons prints a message showing the name of the but-</p>
<p class="calibre1">ton that was clicked. </p>
<p class="calibre1">The key idea here is that since we are using three instances of the </p>
<p class="calibre1">same SimpleButton class, the behavior of each button will be identical. An </p>
<p class="calibre1">important benefit of this approach is that any change to the code in the </p>
<p class="calibre1">SimpleButton class will affect all buttons instantiated from the class. The </p>
<p class="calibre1">main program does not need to worry about any details of the inner work-</p>
<p class="calibre1">ings of the button code, needing only to call the handleEvent() method of </p>
<p class="calibre1">each button in the main loop. Each button will return True or False to say </p>
<p class="calibre1">that it has or has not been clicked. </p>
<p class="calibre1"><b class="calibre3">132</b>   Chapter 6</p>
<p class="calibre1"><a id="p162"/><b class="calibre3">Building a Reusable Object-Oriented Text Display</b></p>
<p class="calibre1">There are two different types of text in a pygame program: display text and </p>
<p class="calibre1">input text. Display text is output from your program, equivalent to a call to the </p>
<p class="calibre1">print() function, except it’s displayed in a pygame window. Input text is string </p>
<p class="calibre1">input from the user, equivalent to a call to input(). In this section, I’ll discuss display text. We’ll look at how to deal with input text in the next chapter. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Steps to Display Text </b></i></p>
<p class="calibre1">Displaying text in a window is a fairly complicated process in pygame </p>
<p class="calibre1">because it’s not simply displayed as a string in the shell, but requires you to </p>
<p class="calibre1">choose a location, fonts and sizes, and other attributes. For example, you </p>
<p class="calibre1">might use code like the following:</p>
<p class="calibre1">pygame.font.init()</p>
<p class="calibre1">myFont = pygame.font.SysFont('Comic Sans MS', 30)</p>
<p class="calibre1">textSurface = myfont.render('Some text', True, (0, 0, 0))</p>
<p class="calibre1">window.blit(textSurface, (10, 10))</p>
<p class="calibre1">We start by initializing the font system within pygame; we do this before </p>
<p class="calibre1">the main loop starts. Then we tell pygame to load a particular font from the </p>
<p class="calibre1">system by name. Here, we request Comic Sans with a font size of 30. </p>
<p class="calibre1">The next step is the key one: we use that font to  <i class="calibre4">render</i> our text, which </p>
<p class="calibre1">creates a graphical image of the text, called a  <i class="calibre4">surface</i> in pygame. We supply the text we want to output, a Boolean that says whether we want our text to </p>
<p class="calibre1">be anti-aliased, and a color in RGB format. Here, (0, 0, 0) indicates that </p>
<p class="calibre1">we want our text to be black. Finally, using blit(), we draw the image of the </p>
<p class="calibre1">text into the window at some (x, y) location. </p>
<p class="calibre1">This code works well to show the provided text in the window at the </p>
<p class="calibre1">given location. However, if the text doesn’t change, there will be a lot of </p>
<p class="calibre1">wasted work done re-creating the textSurface on each iteration through the </p>
<p class="calibre1">main loop. There are also a lot of details to remember, and you must get </p>
<p class="calibre1">them all correct to draw the text properly. We can hide most of this com-</p>
<p class="calibre1">plexity by building a class. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating a SimpleText Class</b></i></p>
<p class="calibre1">The idea is to build a set of methods that take care of font loading and text </p>
<p class="calibre1">rendering in pygame, meaning we no longer have to remember the details </p>
<p class="calibre1">of the implementation. Listing 6-6 contains a new class called SimpleText </p>
<p class="calibre1">that does this work. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo8_SimpleTextDisplay/SimpleText.py</b></p>
<p class="calibre1"># SimpleText class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">133</b></p>
<p class="calibre1"><a id="p163"/>class SimpleText():</p>
<p class="calibre1"/>
<p class="calibre1">1 def __init__(self, window, loc, value, textColor):</p>
<p class="calibre1">2 pygame.font.init()</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.loc = loc</p>
<p class="calibre1">3 self.font = pygame.font.SysFont(None, 30)</p>
<p class="calibre1">self.textColor = textColor</p>
<p class="calibre1">self.text = None # so that the call to setText below will </p>
<p class="calibre1"># force the creation of the text image</p>
<p class="calibre1">self.setValue(value) # set the initial text for drawing</p>
<p class="calibre1">4 def setValue(self, newText):  </p>
<p class="calibre1">if self.text == newText:</p>
<p class="calibre1">return  # nothing to change</p>
<p class="calibre1">self.text = newText  # save the new text</p>
<p class="calibre1">self.textSurface = self.font.render(self.text, True, self.textColor)</p>
<p class="calibre1">5 def draw(self):</p>
<p class="calibre1">self.window.blit(self.textSurface, self.loc)</p>
<p class="calibre1"> <i class="calibre4">Listing 6-6: The SimpleText class for displaying text</i></p>
<p class="calibre1">You can think of a SimpleText object as a field in the window where you </p>
<p class="calibre1">want text to be displayed. You can use one to display unchanging label text </p>
<p class="calibre1">or to display text that changes throughout a program. </p>
<p class="calibre1">The SimpleText class has only three methods. The __init__() method 1 </p>
<p class="calibre1">expects the window to draw into, the location at which to draw the text in </p>
<p class="calibre1">the window, any initial text you want to see displayed in the field, and a text </p>
<p class="calibre1">color. Calling pygame.font.init() 2 starts up pygame’s font system. The call </p>
<p class="calibre1">in the first instantiated SimpleText object actually does the initialization; any </p>
<p class="calibre1">additional SimpleText objects will also make this call, but since fonts have </p>
<p class="calibre1">already been initialized, the call returns immediately. We create a new Font </p>
<p class="calibre1">object with pygame.font.SysFont() 3. Rather than providing a specific font </p>
<p class="calibre1">name, None indicates that we will use whatever the standard system font is. </p>
<p class="calibre1">The setValue() method renders an image of the text to display and saves </p>
<p class="calibre1">that image in the self.textSurface instance variable 4. As the program runs, </p>
<p class="calibre1">any time you want to change the text that’s displayed, you call the  setValue() </p>
</body></html>