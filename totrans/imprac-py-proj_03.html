<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_35"/><strong><span class="big">3</span><br/>SOLVING ANAGRAMS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">An <em>anagram</em> is a word formed by rearranging the letters of another word. For example, <em>Elvis</em> yields the eerie trio <em>evils</em>, <em>lives</em>, and <em>veils</em>. Does this mean Elvis still lives but veils his evil existence? In the book <em>Harry Potter and the Chamber of Secrets</em>, “I am Lord Voldemort” is an anagram of the evil wizard’s real name, Tom Marvolo Riddle. “Lord Earldom Vomit” is also an anagram of Tom Marvolo Riddle, but author J.K. Rowling had the good sense to pass on that one.</p>
<p class="indent">In this chapter, first you’ll find all the anagrams for a given word or name. Then, you’ll write a program that lets a user interactively build an anagram phrase from their own name. Finally, you’ll play computer wizard and see what it takes to extract “I am Lord Voldemort” from “Tom Marvolo Riddle.”</p>
<h3 class="h3a" id="lev50"><span epub:type="pagebreak" id="page_36"/><strong>Project #4: Finding Single-Word Anagrams</strong></h3>
<p class="noindent">You’ll start by analyzing simple single-word anagrams and figuring out how to identify them programmatically. Having accomplished this, you’ll be ready to take on anagram phrases in the following section.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use Python and a dictionary file to find all the single-word anagrams for a given English word or single name. You can read instructions for finding and loading dictionary files at the start of <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>
</div>
<h4 class="h4" id="lev51"><strong><em>The Strategy and Pseudocode</em></strong></h4>
<p class="noindent">More than 600 newspapers and 100 internet sites carry an anagram game called <em>Jumble</em>. Created in 1954, it’s now the most recognized word-scramble game in the world. <em>Jumble</em> can be really frustrating, but finding anagrams is almost as easy as finding palindromes—you just need to know the common characteristic of all anagrams: they must have the same number of the same letters.</p>
<h5 class="h5" id="lev52"><strong>Identifying an Anagram</strong></h5>
<p class="noindent">Python doesn’t contain a built-in anagram operator, but you can easily write one. For the projects in this chapter, you’ll load the dictionary file from <a href="ch02.xhtml#ch02">Chapter 2</a> as a list of strings. So the program needs to verify that two strings are anagrams of each other.</p>
<p class="indent">Let’s look at an example. <em>Pots</em> is an anagram of <em>stop</em>, and you can verify that <em>stop</em> and <em>pots</em> have the same number of letters with the <span class="literal">len()</span> function. But there’s no way for Python to know whether two strings have the same number of any single character—at least not without converting the strings to another data structure or using a counting function. So, instead of looking at these two words simply as strings, you can represent them as two lists containing single-character strings. Create these lists in a shell, like IDLE, and name them <span class="literal">word</span> and <span class="literal">anagram</span>, as I’ve done here:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">word = list('stop')</span><br/>&gt;&gt;&gt; <span class="codestrong1">word</span><br/>['s', 't', 'o', 'p']<br/>&gt;&gt;&gt; <span class="codestrong1">anagram = list('pots')</span><br/>&gt;&gt;&gt; <span class="codestrong1">anagram</span><br/>['p', 'o', 't', 's']</p>
<p class="indent">These two lists match our description of an anagram pair; that is, they contain the same number of the same letters. But if you try to equate them with the comparison operator <span class="literal">==</span>, the result is <span class="literal">False</span>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_37"/>&gt;&gt;&gt; <span class="codestrong1">anagram == word</span><br/>False</p>
<p class="indent">The problem is that the operator (<span class="literal">==</span>) considers two lists equivalent only if they have the same number of the same list items and those items occur in the same order. You can easily solve this problem with the built-in function <span class="literal">sorted()</span>, which can take a list as an argument and reorder its contents alphabetically. So, if you call <span class="literal">sorted()</span> twice—once for each of the lists—and then compare the sorted lists, they will be equivalent. In other words, <span class="literal">==</span> returns <span class="literal">True</span>.</p>
<p class="programs"><span class="literal">&gt;&gt;&gt;</span> <span class="codestrong1">word = sorted(word)</span><br/>&gt;&gt;&gt; <span class="codestrong1">word</span><br/>['o', 'p', 's', 't']<br/>&gt;&gt;&gt; <span class="codestrong1">anagram = sorted(anagram)</span><br/>&gt;&gt;&gt; <span class="codestrong1">anagram</span><br/>['o', 'p', 's', 't']<br/>&gt;&gt;&gt; <span class="codestrong1">anagram == word</span><br/>True</p>
<p class="indent">You can also pass a string to <span class="literal">sorted()</span> to create a sorted list like the ones in the preceding code snippet. This will be useful for converting the words from the dictionary file into sorted lists of single-character strings.</p>
<p class="indent">Now that you know how to verify that you’ve found an anagram, let’s design the script in its entirety—from loading a dictionary and prompting the user for a word (or name) to searching for and printing all the anagrams.</p>
<h5 class="h5" id="lev53"><strong>Using Pseudocode</strong></h5>
<p class="noindent">Remember that planning with pseudocode will help you spot potential issues and spotting those issues early will save you time. The following pseudocode should help you better understand the script we’ll write in the next section, <em>anagrams.py</em>.</p>
<p class="programs">Load digital dictionary file as a list of words<br/>Accept a word from user<br/>Create an empty list to hold anagrams<br/>Sort the user-word<br/>Loop through each word in the word list:<br/>    Sort the word<br/>    if word sorted is equal to user-word sorted:<br/>        Append word to anagrams list<br/>Print anagrams list</p>
<p class="indent">The script will start by loading words from a dictionary file into a list as strings. Before you loop through the dictionary in search of anagrams, you need to know which word you want anagrams of, and you need a place to store anagrams when you find them. So, first ask the user to input a word <span epub:type="pagebreak" id="page_38"/>and then create an empty list to store the anagrams. Once the program has looped through every word in the dictionary, it will print that list of anagrams.</p>
<h4 class="h4" id="lev54"><strong><em>Anagram-Finder Code</em></strong></h4>
<p class="noindent"><a href="ch03.xhtml#ch03list1">Listing 3-1</a> loads a dictionary file, accepts a word or name <em>specified within the program</em>, and finds all the anagrams in the dictionary file for that word or name. You’ll also need the dictionary-loading code from <a href="ch02.xhtml#ch02">Chapter 2</a>. You can download these from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> as <em>anagrams.py</em> and <em>load_dictionary.py</em>, respectively. Keep both files in the same folder. You can use the same dictionary file you used in <a href="ch02.xhtml#ch02">Chapter 2</a> or download another one (see <a href="ch02.xhtml#ch02tab1">Table 2-1</a> on <a href="ch02.xhtml#page_20">page 20</a> for suggestions).</p>
<p class="margin"><em>anagrams.py</em></p>
<p class="programs"><span class="ent">➊</span> import load_dictionary<br/><br/><span class="ent">➋</span> word_list = load_dictionary.load('2of4brif.txt')<br/><br/><span class="ent">➌</span> anagram_list = []<br/><br/>   # input a SINGLE word or SINGLE name below to find its anagram(s):<br/><span class="ent">➍</span> name = 'Foster'<br/>   print("Input name = {}".format (name))<br/><span class="ent">➎</span> name = name.lower()<br/>   print("Using name = {}".format(name))<br/><br/>   # sort name &amp; find anagrams<br/><span class="ent">➏</span> name_sorted = sorted(name)<br/><span class="ent">➐</span> for word in word_list:<br/>       word = word.lower()<br/>       if word != name:<br/>           if sorted(word) == name_sorted:<br/>               anagram_list.append(word)<br/><br/>   # print out list of anagrams<br/>   print()<br/><span class="ent">➑</span> if len(anagram_list) == 0:<br/>       print("You need a larger dictionary or a new name!")<br/>   else:<br/>    <span class="ent">➒</span> print("Anagrams =", *anagram_list, sep='\n')</p>
<p class="listing" id="ch03list1"><em>Listing 3-1: Given a word (or name) and a dictionary file, this program searches for and prints a list of anagrams.</em></p>
<p class="indent">You start by importing the <span class="literal">load_dictionary</span> module you created in <a href="ch02.xhtml#ch02">Chapter 2</a> <span class="ent">➊</span>. This module will open a dictionary text file and, with its <span class="literal">load()</span> function, load all the words into a list <span class="ent">➋</span>. The <em>*.txt</em> file you use may be different, depending on which dictionary file you downloaded (see “<a href="ch02.xhtml#lev33">Finding and Opening a Dictionary</a>” on <a href="ch02.xhtml#page_20">page 20</a>).</p>
<p class="indent">Next, create an empty list, called <span class="literal">anagram_list</span>, to hold any anagrams you find <span class="ent">➌</span>. Have the user add a <em>single</em> word, such as their first name <span class="ent">➍</span>. This <span epub:type="pagebreak" id="page_39"/>doesn’t have to be a proper name, but we’ll refer to it as <span class="literal">name</span> in the code to distinguish it from a dictionary <span class="literal">word</span>. Print this name so the user can see what was entered.</p>
<p class="indent">The next line anticipates a problematic user action. People tend to type their name with an uppercase first letter, but dictionary files may not include uppercase letters, and that matters to Python. So, first convert all letters to lowercase with the <span class="literal">.lower()</span> string method <span class="ent">➎</span>.</p>
<p class="indent">Now sort the name <span class="ent">➏</span>. As mentioned previously, you can pass <span class="literal">sorted()</span> a string as well as a list.</p>
<p class="indent">With the input sorted alphabetically in a list, it’s time to find anagrams. Start a loop through each word in the dictionary word list <span class="ent">➐</span>. To be safe, convert the word to lowercase, as comparison operations are case-sensitive. After the conversion, compare the word to the unsorted name, because a word can’t be an anagram of itself. Next, sort the dictionary word and compare it to the sorted name. If it passes, append that dictionary word to <span class="literal">anagram_list</span>.</p>
<p class="indent">Now display the results. First, check whether the anagram list is empty. If it is, print a whimsical reply so you don’t just leave the user hanging <span class="ent">➑</span>. If the program found at least one anagram, print the list using the splat (<span class="literal">*</span>) operator. Remember from <a href="ch02.xhtml#ch02">Chapter 2</a> that splat lets you print each member of a list on a separate line <span class="ent">➒</span>.</p>
<p class="indent">The following is example output for this program, using the input name <em>Foster</em>:</p>
<p class="programs">Input name = Foster<br/>Using name = foster<br/><br/>Anagrams =<br/>forest<br/>fortes<br/>softer</p>
<p class="indent">If you’d like to use another input, change the value of the <span class="literal">name</span> variable in the source code. As an exercise, try to adjust the code so that the user is prompted to input the name (or word); you can do this with the <span class="literal">input()</span> function.</p>
<h3 class="h3a" id="lev55"><strong>Project #5: Finding Phrase Anagrams</strong></h3>
<p class="noindent">In the previous project, you took a single name or word and rearranged all the letters to find single-word anagrams. Now you will derive multiple words from a name. The words in these <em>phrase anagrams</em> form only part of the input name, and you will need several words to exhaust the available letters.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Write a Python program that lets a user interactively build an anagram phrase from the letters in their name.</p>
</div>
<h4 class="h4" id="lev56"><span epub:type="pagebreak" id="page_40"/><strong><em>The Strategy and Pseudocode</em></strong></h4>
<p class="noindent">The very best phrase anagrams are those that describe some well-known characteristic or action associated with the name bearer. For example, the letters in Clint Eastwood can be rearranged to form <em>old west action</em>, Alec Guinness yields <em>genuine class</em>, Madam Curie produces <em>radium came</em>, George Bush gives <em>he bugs Gore</em>, and Statue of Liberty contains <em>built to stay free</em>. My own name yields <em>a huge navel</em>, which is not really one of my characteristics.</p>
<p class="indent">At this point, you may see a strategic challenge ahead: how does a computer handle contextual content? The folks at IBM who invented Watson seem to know, but for the rest of us, that boulder is a little hard to lift.</p>
<p class="indent">The <em>brute-force method</em> is a common approach used in online anagram generators. These algorithms take a name and return lots of random anagram phrases (generally, 100s to 10,000+). Most of the returned phrases are nonsense, and scrolling through hundreds of these can be a chore.</p>
<p class="indent">An alternative approach is to acknowledge that humans are best at contextual issues and write a program that helps the human work through the problem. The computer can take the initial name and provide words that can be made from some (or all) the letters in it; the user can then choose a word that “makes sense.” The program will then recalculate the word choices from the remaining letters in the name, repeating the process until every letter is used or the possible word choices are exhausted. This design plays to the strengths of both participants.</p>
<p class="indent">You’ll need a simple interface that prompts the user to input the initial name, displays potential word choices, and displays any remaining letters. The program will also need to keep track of the growing anagram phrase and let the user know when every letter has been used. There will likely be lots of failed attempts, so the interface should allow the user to restart the process at any time.</p>
<p class="indent">Since anagrams have the same number of the same letters, another way to identify them is to count individual letters. If you think of your name as a collection of letters, then a word can be built from your name if (1) all its letters occur in your name and (2) they occur <em>at the same frequency or less</em>. Obviously, if <em>e</em> occurs three times in a word and twice in your name, the word can’t be derived from your name. So, if the collection of letters that make up a word is not a subset of the collection of letters in your name, then that word cannot be part of your name anagram.</p>
<h5 class="h5" id="lev57"><strong>Using Counter to Tally Letters</strong></h5>
<p class="noindent">Fortunately for us, Python ships with a module named <span class="literal">collections</span> that includes several container data types. One of these types, <span class="literal">Counter</span>, counts the occurrences of an item. Python stores the items as dictionary keys and the counts as dictionary values. For example, the following code snippet counts how many of each bonsai tree type is in a list.</p>
<p class="programs">   &gt;&gt;&gt; <span class="codestrong1">from collections import Counter</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">my_bonsai_trees = ['maple', 'oak', 'elm', 'maple', 'elm', 'elm', 'elm', 'elm']</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">count = Counter(my_bonsai_trees)</span><br/><span epub:type="pagebreak" id="page_41"/>   &gt;&gt;&gt; <span class="codestrong1">print(count)</span><br/><span class="ent">➌</span> Counter({'elm': 5, 'maple': 2, 'oak': 1})</p>
<p class="indent">The <span class="literal">my_bonsai_trees</span> list contains multiples of the same type of tree <span class="ent">➊</span>. <span class="literal">Counter</span> tallies up the trees <span class="ent">➋</span> and creates an easy-to-reference dictionary <span class="ent">➌</span>. Note that the <span class="literal">print()</span> function is optional and is used here for clarity. Entering <span class="literal">count</span>, alone, will also display the dictionary contents.</p>
<p class="indent">You can use <span class="literal">Counter</span>, instead of the <span class="literal">sorted()</span> method, to find single-word anagrams. Rather than two sorted lists, the output will be two dictionaries, which can also be directly compared with <span class="literal">==</span>. Here’s an example:</p>
<p class="programs">   &gt;&gt;&gt; <span class="codestrong1">name = 'foster'</span><br/>   &gt;&gt;&gt; <span class="codestrong1">word = 'forest'</span><br/>   &gt;&gt;&gt; <span class="codestrong1">name_count = Counter(name)</span><br/>   &gt;&gt;&gt; <span class="codestrong1">print(name_count)</span><br/><span class="ent">➊</span> Counter({'f': 1, 't': 1, 'e': 1, 'o': 1, 'r': 1, 's': 1})<br/>   &gt;&gt;&gt; <span class="codestrong1">word_count = Counter(word)</span><br/>   &gt;&gt;&gt; <span class="codestrong1">print(word_count)</span><br/><span class="ent">➋</span> Counter({'f': 1, 't': 1, 'o': 1, 'e': 1, 'r': 1, 's': 1})</p>
<p class="indent"><span class="literal">Counter</span> produces a dictionary for each word that maps each letter in the word to the number of times it occurs <span class="ent">➊</span><span class="ent">➋</span>. The dictionaries are unsorted, but despite the lack of sorting, Python correctly identifies each dictionary as being equal if the dictionaries contain the same letters and the same counts:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">if word_count == name_count:</span><br/><span class="codestrong1">        print("It's a match!")</span><br/><br/>It's a match!</p>
<p class="indent">A <span class="literal">Counter</span> gives you a wonderful way to find words that “fit” in a name. If the count for each letter in a word is less than or equal to the count for the same letter in the name, then the word can be derived from the name!</p>
<h5 class="h5" id="lev58"><strong>The Pseudocode</strong></h5>
<p class="noindent">We’ve now made two important design decisions: (1) let the user interactively build their anagram one word at a time and (2) use the <span class="literal">Counter</span> method to find anagrams. This is enough to start thinking about high-level pseudocode:</p>
<p class="programs">Load a dictionary file<br/>Accept a name from user<br/>Set limit = length of name<br/>Start empty list to hold anagram phrase<br/>While length of phrase &lt; limit:<br/>    Generate list of dictionary words that fit in name<br/>    Present words to user<br/>    Present remaining letters to user<br/>    Present current phrase to user<br/>    Ask user to input word or start over<br/><span epub:type="pagebreak" id="page_42"/>    If user input can be made from remaining letters:<br/>        Accept choice of new word or words from user<br/>        Remove letters in choice from letters in name<br/>        Return choice and remaining letters in name<br/>    If choice is not a valid selection:<br/>        Ask user for new choice or let user start over<br/>    Add choice to phrase and show to user<br/>    Generate new list of words and repeat process<br/>When phrase length equals limit value:<br/>    Display final phrase<br/>    Ask user to start over or to exit</p>
<h5 class="h5" id="lev59"><strong>Divvying Up the Work</strong></h5>
<p class="noindent">As procedural code becomes more complex, it becomes necessary to encapsulate much of it in functions. This makes it easier to manage input and output, perform recursion, and read the code.</p>
<p class="indent">A <em>main function</em> is where a program starts its execution, and enables high-level organization, such as managing all the bits and pieces of the code, including dealing with the user. In the phrase anagram program, the main function will wrap all the “worker bee” functions, take <em>most</em> of the user input, keep track of the growing anagram phrase, determine when the phrase is complete, and show the user the result.</p>
<p class="indent">Sketching out the tasks and their flow with pencil and paper is a great way to figure out what you want to do and where (like “graphical pseudocode”). <a href="ch03.xhtml#ch03fig1">Figure 3-1</a> is a flowchart with function assignments highlighted. In this case, three functions should be sufficient: <span class="literal">main()</span>, <span class="literal">find_anagrams()</span>, and <span class="literal">process_choice()</span>.</p>
<p class="indent">The <span class="literal">main()</span> function’s primary task is to set the letter count limit and manage the <span class="literal">while</span> loop responsible for the general phrase anagram build. The <span class="literal">find_anagrams()</span> function will take the current collection of letters remaining in a name and return all possible words that can be made from those letters. The words are then displayed for the user, along with the current phrase, which is “owned” and displayed by the <span class="literal">main()</span> function. Then, the <span class="literal">process_choice()</span> function prompts the user to start over or choose a word for the anagram phrase. If the user makes a choice, this function determines whether the letters in the choice are available. If they aren’t, the user is prompted to choose again or start over. If the user makes a valid choice, the letters in the user’s choice are removed from the list of remaining letters, and both the choice and list of leftovers are returned. The <span class="literal">main()</span> function adds the returned choice to the existing phrase. If the limit is reached, the completed phrase anagram is displayed, and the user is asked to start over or exit.</p>
<p class="indent">Note that you ask for the initial name in the <em>global</em> scope, rather than in the <span class="literal">main()</span> function. This allows the user to start over fresh at any time without having to re-enter their name. For now, if the user wants to choose a brand-new name, they’ll have to exit the program and start over. In <a href="ch09.xhtml#ch09">Chapter 9</a>, you’ll use a menu system that lets users completely reset what they’re doing without exiting.</p>
<div class="image"><span epub:type="pagebreak" id="page_43"/><a id="ch03fig1"/><img src="../images/f0043-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 3-1: Flowchart for finding phrase anagrams with function assignments highlighted</em></p>
<h4 class="h4" id="lev60"><strong><em>The Anagram Phrase Code</em></strong></h4>
<p class="noindent">The code in this section takes a name from a user and helps them build an anagram phrase of that name. You can download the entire script from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> as <em>phrase_anagrams.py</em>. You’ll also need to download the <em>load_dictionary.py</em> program. Save both files in the same folder. You can use the same dictionary file you used in “<a href="ch03.xhtml#lev50">Project #4: Finding Single-Word Anagrams</a>” on <a href="ch03.xhtml#page_36">page 36</a>.</p>
<h5 class="h5" id="lev61"><span epub:type="pagebreak" id="page_44"/><strong>Setting Up and Finding Anagrams</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list2">Listing 3-2</a> imports the modules that <em>phrase_anagrams.py</em> uses, loads a dictionary file, asks the user for an input name, and defines the <span class="literal">find_anagrams()</span> function, which does most of the work related to finding anagrams.</p>
<p class="margin"><em>phrase_anagrams.py,</em> part 1</p>
<p class="programs"><span class="ent">➊</span> import sys<br/>   from collections import Counter<br/>   import load_dictionary<br/><br/><span class="ent">➋</span> dict_file = load_dictionary.load('2of4brif.txt')<br/>   # ensure "a" &amp; "I" (both lowercase) are included<br/>   dict_file.append('a')<br/>   dict_file.append('i')<br/>   dict_file = sorted(dict_file)<br/><br/><span class="ent">➌</span> ini_name = input("Enter a name: ")<br/><br/><span class="ent">➍</span> def find_anagrams(name, word_list):<br/>       """Read name &amp; dictionary file &amp; display all anagrams IN name."""<br/>    <span class="ent">➎</span> name_letter_map = Counter(name)<br/>       anagrams = []<br/>    <span class="ent">➏</span> for word in word_list:<br/>        <span class="ent">➐</span> test = ''<br/>        <span class="ent">➑</span> word_letter_map = Counter(word.lower())<br/>        <span class="ent">➒</span> for letter in word:<br/>               if word_letter_map[letter] &lt;= name_letter_map[letter]:<br/>                   test += letter<br/>           if Counter(test) == word_letter_map:<br/>               anagrams.append(word)<br/>    <span class="ent">➓</span> print(*anagrams, sep='\n')<br/>       print()<br/>       print("Remaining letters = {}".format(name))<br/>       print("Number of remaining letters = {}".format(len(name)))<br/>       print("Number of remaining (real word) anagrams = {}".format(len(anagrams)))</p>
<p class="listing" id="ch03list2"><em>Listing 3-2: Imports modules, loads dictionary, and defines the</em> <span class="codeitalic">find_anagrams()</span> <em>function</em></p>
<p class="indent">Start with the <span class="literal">import</span> statements <span class="ent">➊</span>, using the recommended order of Python Standard Library, third-party modules, and then locally developed modules. You need <span class="literal">sys</span> for coloring specific outputs red in the IDLE window and for letting the user exit the program with a keystroke. You’ll use <span class="literal">Counter</span> to help identify anagrams of the input name.</p>
<p class="indent">Next load the dictionary file using the imported module <span class="ent">➋</span>. The filename argument should be the filename of the dictionary you’re using. Because some dictionary files omit <em>a</em> and <em>I</em>, append these (if needed), and sort the list so that they can be found at the proper alphabetical locations, rather than at the end of the list.</p>
<p class="indent">Now get a name from the user and assign it to the variable <span class="literal">ini_name</span> (or “initial name”) <span class="ent">➌</span>. You’ll derive a <span class="literal">name</span> variable from this initial name, and <span epub:type="pagebreak" id="page_45"/><span class="literal">name</span> will be progressively changed as the user builds up the name anagram. Preserving the initial name as a separate variable will let you reset everything if the user wants to start over or try again.</p>
<p class="indent">The next block of code is <span class="literal">find_anagrams()</span> <span class="ent">➍</span>, the function for finding anagrams in the name. The parameters for this function consist of a name and a word list. The function starts by using <span class="literal">Counter</span> to count the number of times a given letter appears in the name and then assigns the count to the variable <span class="literal">name_letter_map</span> <span class="ent">➎</span>; <span class="literal">Counter</span> uses a dictionary structure with the letter as the key and the count as the value. The function then creates an empty list to hold the anagrams and starts a <span class="literal">for</span> loop through each word in the dictionary file <span class="ent">➏</span>.</p>
<p class="indent">The <span class="literal">for</span> loop starts by creating an empty string called <span class="literal">test</span> <span class="ent">➐</span>. Use this variable to accumulate all the letters in the <span class="literal">word</span> that “fit” in <span class="literal">name</span>. Then make a <span class="literal">Counter</span> for the current word, as you did for <span class="literal">name</span>, and call it <span class="literal">word_</span><span class="literal">letter</span><span class="literal">_map</span> <span class="ent">➑</span>. Loop through the letters in <span class="literal">word</span> <span class="ent">➒</span>, checking that the count of each letter is the same as, or less than, the count in <span class="literal">name</span>. If the letter meets this condition, then it is added to the test string. Since some letters might get rejected, end the loop by running <span class="literal">Counter</span> on <span class="literal">test</span> and comparing it to <span class="literal">word_letter_map</span>. If they match, append the word to the anagrams list.</p>
<p class="indent">The function ends by displaying the list of words, using the splat operator with <span class="literal">print</span>, along with some statistics for the user <span class="ent">➓</span>. Note that <span class="literal">find_</span><span class="literal">anagrams()</span> doesn’t return anything. This is where the human interaction part comes in. The program will continue to run, but nothing will happen until the user chooses a word from the displayed list.</p>
<h5 class="h5" id="lev62"><strong>Processing the User’s Choice</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list3">Listing 3-3</a> defines <span class="literal">process_choice()</span>, the function in <em>phrase_anagrams.py</em> that takes the user’s choice of word (or words), checks it against the remaining letters in the <span class="literal">name</span> variable, and returns acceptable choices—along with any leftover letters—to the <span class="literal">main()</span> function. Like <span class="literal">main()</span>, this function gets to talk directly to the user.</p>
<p class="margin"><em>phrase_anagrams.py,</em> part 2</p>
<p class="programs"><span class="ent">➊</span> def process_choice(name):<br/>       """Check user choice for validity, return choice &amp; leftover letters."""<br/>       while True:<br/>        <span class="ent">➋</span> choice = input('\nMake a choice else Enter to start over or # to end: ')<br/>           if choice == '':<br/>               main()<br/>           elif choice == '#':<br/>               sys.exit()<br/>           else:<br/>            <span class="ent">➌</span> candidate = ''.join(choice.lower().split())<br/>        <span class="ent">➍</span> left_over_list = list(name)<br/>        <span class="ent">➎</span> for letter in candidate:<br/>               if letter in left_over_list:<br/>                   left_over_list.remove(letter)<br/>        <span class="ent">➏</span> if len(name) - len(left_over_list) == len(candidate):<br/>               break<br/><span epub:type="pagebreak" id="page_46"/>           else:<br/>               print("Won't work! Make another choice!", file=sys.stderr)<br/>    <span class="ent">➐</span> name = ''.join(left_over_list)  # makes display more readable<br/>    <span class="ent">➑</span> return choice, name</p>
<p class="listing" id="ch03list3"><em>Listing 3-3: Defines the</em> <span class="codeitalic">process_choice()</span> <em>function</em></p>
<p class="indent">Start by defining the function with one parameter called <span class="literal">name</span> <span class="ent">➊</span>. The first time the program is run, this parameter will be the same as the <span class="literal">ini_name</span> variable—the full name entered by the user when the program starts up. After the user has chosen a word (or words) to use in the anagram phrase, it will represent the remaining letters in the name.</p>
<p class="indent">Start the function with a <span class="literal">while</span> loop that will run until the user makes a valid choice and then get input from the user <span class="ent">➋</span>. The user has a choice of entering one or more words from the current anagram list, pressing <small>ENTER</small> to start over, or pressing # to quit. Use #, rather than a word or letter, so that it can’t be confused for a valid choice.</p>
<p class="indent">If the user makes a choice, the string is assigned to the variable <span class="literal">candidate</span>, stripped of whitespace, and converted to all lowercase <span class="ent">➌</span>. This is so it can be directly compared to the <span class="literal">name</span> variable. After that, a list is built from the <span class="literal">name</span> variable to hold any remaining letters <span class="ent">➍</span>.</p>
<p class="indent">Now begin a loop to subtract the letters used in <span class="literal">candidate</span> <span class="ent">➎</span>. If a chosen letter is present in the list, it’s removed.</p>
<p class="indent">If the user entered a word that isn’t in the displayed list, or entered multiple words, a letter may not be present in the list. To check for this, subtract the leftover letters from <span class="literal">name</span> and, if the result is the number of letters in <span class="literal">candidate</span>, determine that the input is valid and break out of the <span class="literal">while</span> loop <span class="ent">➏</span>. Otherwise, display a warning and color it red for those using the IDLE window. The <span class="literal">while</span> loop will keep prompting the user until an acceptable choice is made.</p>
<p class="indent">If all the letters in the user’s choice pass the test, the list of leftovers is converted back into a string and used to update the <span class="literal">name</span> variable <span class="ent">➐</span>. Converting the list into a string isn’t strictly necessary, but it keeps the <span class="literal">name</span> variable type consistent and lets you display the remaining letters in a clearly readable format without the need for additional <span class="literal">print</span> arguments.</p>
<p class="indent">Finish by returning both the user’s choice and the string of remaining letters (<span class="literal">name</span>) to the <span class="literal">main()</span> function <span class="ent">➑</span>.</p>
<h5 class="h5" id="lev63"><strong>Defining the main() Function</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list4">Listing 3-4</a> defines the <span class="literal">main()</span> function in <em>phrase_anagrams.py</em>. This function wraps the previous functions, runs a <span class="literal">while</span> loop, and determines when the user has successfully created an anagram phrase.</p>
<p class="margin"><em>phrase_anagrams.py,</em> part 3</p>
<p class="programs">   def main():<br/>       """Help user build anagram phrase from their name."""<br/>    <span class="ent">➊</span> name = ''.join(ini_name.lower().split())<br/>       name = name.replace('-', '')<br/><span epub:type="pagebreak" id="page_47"/>    <span class="ent">➋</span> limit = len(name)<br/>       phrase = ''<br/>       running = True<br/><br/>    <span class="ent">➌</span> while running:<br/>        <span class="ent">➍</span> temp_phrase = phrase.replace(' ', '')<br/>        <span class="ent">➎</span> if len(temp_phrase) &lt; limit:<br/>               print("Length of anagram phrase = {}".format(len(temp_phrase)))<br/><br/>            <span class="ent">➏</span> find_anagrams(name, dict_file)<br/>               print("Current anagram phrase =", end=" ")<br/>               print(phrase, file=sys.stderr)<br/>              <br/>            <span class="ent">➐</span> choice, name = process_choice(name)<br/>               phrase += choice + ' '<br/><br/>        <span class="ent">➑</span> elif len(temp_phrase) == limit:<br/>               print("\n*****FINISHED!!!*****\n")<br/>               print("Anagram of name =", end=" ")<br/>               print(phrase, file=sys.stderr)<br/>               print()<br/>            <span class="ent">➒</span> try_again = input('\n\nTry again? (Press Enter else "n" to quit)\n ')<br/>               if try_again.lower() == "n":<br/>                   running = False<br/>                   sys.exit()<br/>               else:<br/>                   main()<br/><br/><span class="ent">➓</span> if __name__ == '__main__':<br/>       main()</p>
<p class="listing" id="ch03list4"><em>Listing 3-4: Defines and calls</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">The first order of business is to turn the <span class="literal">ini_name</span> variable into a continuous string of lowercase characters with no whitespace <span class="ent">➊</span>. Remember, case matters to Python, so convert all strings to lowercase wherever they occur; that way, comparisons will work as intended. Python also recognizes spaces as characters, so you need to remove these, as well as hyphens in hyphenated names, before doing any letter counts. By declaring this new <span class="literal">name</span> variable, you preserve the initial name in case the user wants to start over. Only <span class="literal">name</span> will be altered in the <span class="literal">process_choice()</span> function.</p>
<p class="indent">Next, get the length of the name <span class="ent">➋</span> to use as a limit in the <span class="literal">while</span> loop. This will let you know when the anagram phrase has used all the letters in the name and it’s time to end the loop. Do this outside the <span class="literal">while</span> loop to ensure you are using the full initial name. Then assign a variable to hold the anagram phrase and set a <span class="literal">running</span> variable to <span class="literal">True</span> to control the <span class="literal">while</span> loop.</p>
<p class="indent">Now begins the big loop that lets you iterate over the name and build an anagram phrase <span class="ent">➌</span>. First, prepare a string to hold the growing phrase and strip it of whitespace <span class="ent">➍</span>. Spaces will count as letters and throw off the operator when the length of the phrase is compared to the <span class="literal">limit</span> variable. <span epub:type="pagebreak" id="page_48"/>Next, make the comparison, and if the length of the phrase is less than the limit, display the current length of the phrase as a prelude to engaging with the user <span class="ent">➎</span>.</p>
<p class="indent">It’s time to put the other functions to work. Call <span class="literal">find_anagrams()</span> <span class="ent">➏</span> and pass it the name and dictionary file to get the list of anagrams in the name. At the bottom of the displayed list, show the user the current phrase. Use the <span class="literal">print()</span> function’s <span class="literal">end</span> parameter to display two <span class="literal">print</span> statements on the same line. This way, you can use a red font on the phrase in the IDLE window to distinguish it from all the other information in the display.</p>
<p class="indent">Next, call the <span class="literal">process_choice()</span> function <span class="ent">➐</span> to get the user’s word choice and add it to the growing anagram phrase. This also gets the updated version of the <span class="literal">name</span> variable so that the program can use it again in the <span class="literal">while</span> loop in the event that the phrase isn’t complete.</p>
<p class="indent">If the length of the phrase is equal to the <span class="literal">limit</span> variable <span class="ent">➑</span>, the name anagram is complete. Let the user know they’re finished and present the phrase using red font. Note that you don’t have a conditional for the length of the phrase being greater than the <span class="literal">limit</span> variable. That’s because the <span class="literal">process_choice()</span> function is already handling this outcome (choosing more letters than are available would not pass the validation criterion).</p>
<p class="indent">The <span class="literal">main()</span> function ends by asking the user whether they want to try again. If they type <span class="literal">n</span>, the program ends; if they press <small>ENTER</small>, the <span class="literal">main()</span> function is called again <span class="ent">➒</span>. As stated earlier, the only way for the user to change the initial name is to exit and relaunch the program.</p>
<p class="indent">Outside of the <span class="literal">main()</span> function, end with the standard two lines for calling the <span class="literal">main()</span> function when the program is not imported as a module <span class="ent">➓</span>.</p>
<h5 class="h5" id="lev64"><strong>Running an Example Session</strong></h5>
<p class="noindent">In this section, I’ve included an example interactive session, using <em>phrase_anagrams.py</em> and the name <em>Bill Bo</em>. <span class="codestrong">Bold</span> font indicates user input, and <span class="codestrongitalic">italic bold</span> font indicates where red font is used in the display.</p>
<p class="programs">Enter a name: <span class="codestrong1">Bill Bo</span><br/>
Length of anagram phrase = 0<br/>
bib<br/>
bill<br/>
blob<br/>
bob<br/>
boil<br/>
boll<br/>
i<br/>
ill<br/>
lib<br/>
lilo<br/>
lo<br/>
lob<br/>
oi<br/>
oil<br/>
<span epub:type="pagebreak" id="page_49"/>Remaining letters = billbo<br/>
Number of remaining letters = 6<br/>
Number of remaining (real word) anagrams = 14<br/>
Current anagram phrase =<br/>
<br/>
Make a choice else Enter to start over or # to end: <span class="codestrong1">ill</span><br/>
Length of anagram phrase = 3<br/>
bob<br/>
<br/>
Remaining letters = bbo<br/>
Number of remaining letters = 3<br/>
Number of remaining (real word) anagrams = 1<br/>
Current anagram phrase = <span class="codestrongitalic1">ill</span><br/>
<br/>
Make a choice else Enter to start over or # to end: <span class="codestrong1">Bob</span><br/>
<br/>
***** FINISHED!!! *****<br/>
<br/>
Anagram of name = <span class="codestrongitalic1">ill Bob</span><br/>
<br/>
<br/>
Try again? (Press Enter else "n" to quit)</p>
<p class="indent">The number of anagrams found depends on the dictionary file you use. If you’re having a hard time building anagram phrases, try using a larger dictionary.</p>
<h3 class="h3a" id="lev65"><strong>Project #6: Finding Voldemort: The Gallic Gambit</strong></h3>
<p class="noindent">Did you ever wonder how Tom Riddle came up with the anagram “I am Lord Voldemort”? Did he put quill to parchment or just wave a wand? Could the magic of Python have helped?</p>
<p class="indent">Let’s pretend for a moment that you’re the professor of computer wizardry at Hogwarts, and Tom Riddle, school prefect and model student, has come to you for help. Using your <em>phrase_anagrams.py</em> spell from the previous section, he could find <em>I am Lord</em> in the very first list of anagrams, much to his delight. But the remaining letters, <em>tmvoordle</em>, yield only trivial words like <em>dolt</em>, <em>drool</em>, <em>looter</em>, and <em>lover</em>. Riddle would not be pleased.</p>
<p class="indent">In hindsight, the problem is apparent: <em>Voldemort</em> is French and won’t be found in any English dictionary file. <em>Vol de la mort</em> means “flight of death” in French, so Voldemort is loosely “death flight.” But Riddle is 100 percent English, and so far, you have been working with English. Without reverse engineering, you have no more reason to suddenly switch out your English dictionary for a French one than you have to use Dutch, German, Italian, or Spanish.</p>
<p class="indent">You <em>could</em> try randomly shuffling the remaining letters and seeing what falls out. Unfortunately, the number of possible combinations is the factorial of the number of letters divided by the factorial of the number of repeats (<em>o</em> occurs twice): 9! / 2! = 181,440. If you were to scroll through all <span epub:type="pagebreak" id="page_50"/>those permutations, taking only one second to review each, it would take you over two days to complete the list! And if you asked Tom Riddle to do this, he would probably use you to make a horcrux!</p>
<p class="indent">At this point, I would like to explore two logical paths ahead. One I call the “Gallic Gambit” and the other the “British Brute-Force.” We’ll look at the first one here and the second one in the next section.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep">Marvolo <em>is clearly a</em> fabricated word <em>used to make the Voldemort anagram work. J.K. Rowling could have gained additional latitude by using</em> Thomas <em>for</em> Tom <em>or by leaving off the</em> Lord <em>or</em> I am <em>parts. Tricks like these are used when the book is translated into non-English languages. In some languages, one or both names may need to be changed. In French, the anagram is “I am Voldemort.” In Norwegian, “Voldemort the Great.” In Dutch, “My name is Voldemort.” In others, like Chinese, the anagram can’t be used at all!</em></p>
</div>
<p class="indent">Tom Riddle was obsessed with beating death, and if you go looking for death in <em>tmvoordle</em>, you will find both the old French <em>morte</em> (as in the famous book <em>Le Morte d’Arthur</em> by Sir Thomas Malory) and the modern French <em>mort</em>. Removing <em>mort</em> leaves <em>vodle</em>, five letters with a very manageable number of permutations. In fact, you can easily find <em>volde</em> right in the interpreter window:</p>
<p class="programs"><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">from itertools import permutations</span><br/>   &gt;&gt;&gt; <span class="codestrong1">name = 'vodle'</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">perms = [''.join(i) for i in permutations(name)]</span><br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong1">print(len(perms))</span><br/>   120<br/><span class="ent">➍</span> &gt;&gt;&gt; <span class="codestrong1">print(perms)</span><br/>   ['vodle', 'vodel', 'volde', 'voled', 'voedl', 'voeld', 'vdole', 'vdoel',<br/>   'vdloe', 'vdleo', 'vdeol', 'vdelo', 'vlode', 'vloed', 'vldoe', 'vldeo',<br/>   'vleod', 'vledo', 'veodl', 'veold', 'vedol', 'vedlo', 'velod', 'veldo',<br/>   'ovdle', 'ovdel', 'ovlde', 'ovled', 'ovedl', 'oveld', 'odvle', 'odvel',<br/>   'odlve', 'odlev', 'odevl', 'odelv', 'olvde', 'olved', 'oldve', 'oldev',<br/>   'olevd', 'oledv', 'oevdl', 'oevld', 'oedvl', 'oedlv', 'oelvd', 'oeldv',<br/>   'dvole', 'dvoel', 'dvloe', 'dvleo', 'dveol', 'dvelo', 'dovle', 'dovel',<br/>   'dolve', 'dolev', 'doevl', 'doelv', 'dlvoe', 'dlveo', 'dlove', 'dloev',<br/>   'dlevo', 'dleov', 'devol', 'devlo', 'deovl', 'deolv', 'delvo', 'delov',<br/>   'lvode', 'lvoed', 'lvdoe', 'lvdeo', 'lveod', 'lvedo', 'lovde', 'loved',<br/>   'lodve', 'lodev', 'loevd', 'loedv', 'ldvoe', 'ldveo', 'ldove', 'ldoev',<br/>   'ldevo', 'ldeov', 'levod', 'levdo', 'leovd', 'leodv', 'ledvo', 'ledov',<br/>   'evodl', 'evold', 'evdol', 'evdlo', 'evlod', 'evldo', 'eovdl', 'eovld',<br/>   'eodvl', 'eodlv', 'eolvd', 'eoldv', 'edvol', 'edvlo', 'edovl', 'edolv',<br/>   'edlvo', 'edlov', 'elvod', 'elvdo', 'elovd', 'elodv', 'eldvo', 'eldov']<br/>   &gt;&gt;&gt;<br/><span class="ent">➎</span> &gt;&gt;&gt; <span class="codestrong1">print(*perms, sep='\n')</span><br/>   vodle<br/>   vodel<br/>   volde<br/>   voled<br/>   voedl<br/>   --<span class="codeitalic1">snip</span>--</p>
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Start by importing <span class="literal">permutations</span> from <span class="literal">itertools</span> <span class="ent">➊</span>. The <span class="literal">itertools</span> module is a group of functions in the Python Standard Library that create iterators for efficient looping. You generally think of permutations of <em>numbers</em>, but the <span class="literal">itertools</span> version works on <em>elements</em> in an iterable, which includes letters.</p>
<p class="indent">After entering the name or, in this case, the remaining letters in the name, use list comprehension to create a list of permutations of the name <span class="ent">➋</span>. Join each element in a permutation so each item in the final list will be a unique permutation of <em>vodle</em>. Using <span class="literal">join</span> yields the new name as an element, <span class="literal">'vodle'</span>, versus a hard-to-read tuple of single-character elements,<span class="literal">('v', 'o', 'd', 'l', 'e')</span>.</p>
<p class="indent">Get the length of the permutations as a check; that way, you can confirm that it is, indeed, the factorial of 5 <span class="ent">➌</span>. At the end, no matter how you print it <span class="ent">➍</span><span class="ent">➎</span>, <em>volde</em> is easy to find.</p>
<h3 class="h3a" id="lev66"><strong>Project #7: Finding Voldemort: The British Brute-Force</strong></h3>
<p class="noindent">Now let’s assume Tom Riddle is bad at anagrams (or French). He doesn’t recognize <em>mort</em> or <em>morte</em>, and you’re back to shuffling the remaining nine letters thousands and thousands of times, looking for a combination of letters that he would find pleasing.</p>
<p class="indent">On the bright side, this is a more interesting problem programmatically than the interactive solution you just saw. You just need to whittle down all the permutations using some form of filtering.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Reduce the number of anagrams of <em>tmvoordle</em> to a manageable number that will still contain <em>Voldemort</em>.</p>
</div>
<h4 class="h4" id="lev67"><strong><em>Strategy</em></strong></h4>
<p class="noindent">Per the <em>Oxford English Dictionary, 2nd Edition</em>, there are 171,476 English words currently in use, which is fewer than the total number of permutations in <em>tmvoordle</em>! Regardless of the language, you can surmise that most of the anagrams generated by the <span class="literal">permutations()</span> function are nonsense.</p>
<p class="indent">With <em>cryptography</em>, the science of codes and ciphers, you can safely eliminate many useless, unpronounceable combinations, such as <em>ldtmvroeo</em>, and you won’t even have to inspect them visually. Cryptographers have long studied languages and compiled statistics on recurring patterns of words and letters. We can use many cryptanalytical techniques for this project, but let’s focus on three: consonant-vowel mapping, trigram frequency, and digram frequency.</p>
<h5 class="h5" id="lev68"><span epub:type="pagebreak" id="page_52"/><strong>Filtering with Consonant-Vowel Mapping</strong></h5>
<p class="noindent">A <em>consonant-vowel map</em> (<em>c-v map</em>) simply replaces the letters in a word with a <em>c</em> or a <em>v</em>, as appropriate. <em>Riddle</em>, for example, becomes <em>cvcccv</em>. You can write a program that goes through a dictionary file and creates c-v maps for each word. By default, impossible combinations, like <em>ccccccvvv</em>, will be excluded. You can further exclude membership by removing words with c-v maps that are <em>possible</em> but that have a low frequency of occurrence.</p>
<p class="indent">C-v maps are fairly inclusive, but that’s good. An option for <em>Riddle</em> at this point is to make up a new proper name, and proper names don’t have to be words that occur in a dictionary. So you don’t want to be <em>too</em> exclusive early in the process.</p>
<h5 class="h5" id="lev69"><strong>Filtering with Trigrams</strong></h5>
<p class="noindent">Since the initial filter needs a relatively wide aperture, you’ll need to filter again at a lower level to safely remove more anagrams from the permutations. <em>Trigrams</em> are triplets comprising three consecutive letters. It should come as no surprise that the most common trigram in English is the word <em>the</em>, followed closely by <em>and</em> and <em>ing</em>. At the other end of the scale are trigrams like <em>zvq</em>.</p>
<p class="indent">You can find statistics on the frequency of occurrence of trigrams online at sites like <em><a href="http://norvig.com/ngrams/count_3l.txt">http://norvig.com/ngrams/count_3l.txt</a></em>. For any group of letters, like <em>tmvoordle</em>, you can generate and use a list of the least common trigrams to further reduce the number of permutations. For this project, you can use the <em>least-likely_trigrams.txt</em> file, downloadable from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. This text file contains the trigrams in <em>tmvoordle</em> that occur in the bottom 10 percent of trigrams in the English language, based on frequency of occurrence.</p>
<h5 class="h5" id="lev70"><strong>Filtering with Digrams</strong></h5>
<p class="noindent"><em>Digrams</em> (also called <em>bigrams</em>) are letter pairs. Commonly occurring digrams in English include <em>an</em>, <em>st</em>, and <em>er</em>. On the other hand, you rarely see pairs like <em>kg</em>, <em>vl</em>, or <em>oq</em>. You can find statistics on the frequency of occurrence of digrams at websites such as <em><a href="https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html">https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html</a></em> and <em><a href="http://practicalcryptography.com/">http://practicalcryptography.com/</a></em>.</p>
<p class="indent"><a href="ch03.xhtml#ch03tab1">Table 3-1</a> was built from the <em>tmvoordle</em> collection of letters and a 60,000-word English dictionary file. The letters along the left side of the chart are the starting letters for the digrams; those along the top represent the end letter. For example, to find <em>vo</em>, start with the <em>v</em> on the left and read across to the column beneath the <em>o</em>. For the digrams found in <em>tmvoordle</em>, <em>vo</em> occurs only 0.8 percent of the time.</p>
<p class="tabcap" id="ch03tab1"><span epub:type="pagebreak" id="page_53"/><strong>Table 3-1:</strong> Relative Frequency of Digrams from the Letters <em>tmvoordle</em> in a 60,000-Word Dictionary (Black Squares Indicate No Occurrences)</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-haa"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>d</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>e</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>l</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>m</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>o</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>r</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>t</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>v</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>d</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.5%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>e</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">6.6%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">8.9%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.6%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>l</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">4.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">4.2%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>m</strong></p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.2%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.8%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>o</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.2%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">5.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">7.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.4%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>r</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.9%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">6.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">5.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.3%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>t</strong></p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">6.2%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.6%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.6%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>v</strong></p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.5%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.8%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
</tr>
</tbody>
</table>
<p class="indent">Assuming you’re looking for “English-like” letter combinations, you can use frequency maps like this to exclude letter pairs that are unlikely to occur. Think of it as a “digram sieve” that lets only the unshaded squares pass.</p>
<p class="indent">To be safe, just exclude digrams that occur less than 0.1 percent of the time. I’ve shaded these in black. Notice that it would be very easy to eliminate the required <em>vo</em> pairing in <em>Voldemort</em>, if you cut too close to the bone!</p>
<p class="indent">You can design your filter to be even more selective by tagging digrams that are unlikely to occur at the start of a word. For example, while it’s not unusual for the digram <em>lm</em> to occur <em>within</em> a word (as in <em>almanac</em> and <em>balmy</em>), you’ll need a lot of luck finding a word that <em>starts</em> with <em>lm</em>. You don’t need cryptography to find these digrams; just try to pronounce them! Some starting-point choices for these are shaded gray in <a href="ch03.xhtml#ch03tab2">Table 3-2</a>.</p>
<p class="tabcap" id="ch03tab2"><strong>Table 3-2:</strong> Update of <a href="ch03.xhtml#ch03tab1">Table 3-1</a>, Where Gray-Shaded Squares Indicate Digrams Unlikely to Occur at the Start of a Word</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-haa"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>d</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>e</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>l</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>m</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>o</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>r</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>t</strong></p></td>
<td style="vertical-align: top;" class="table-ha"><p class="tabc"><strong>v</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>d</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.5%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.1%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>e</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">6.6%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">8.9%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.6%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>l</strong></p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">4.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">4.2%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.4%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.1%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>m</strong></p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.2%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.8%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>o</strong></p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.5%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.2%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">5.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">7.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.4%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">1.4%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>r</strong></p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.9%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">6.0%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.4%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">5.7%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">1.3%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.3%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>t</strong></p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">6.2%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.6%</p></td>
<td style="vertical-align: top;" class="table-abd"><p class="tabc">0.1%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">3.6%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.3%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="tabc"><strong>v</strong></p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">2.5%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc">0.8%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-abc"><p class="tabc">0.0%</p></td>
<td style="vertical-align: top;" class="table-ab"><p class="tabc"> </p></td>
</tr>
</tbody>
</table>
<p class="indent"><span epub:type="pagebreak" id="page_54"/>You now have three filters you can use on the 181,440 permutations of <em>tmvoordle</em>: c-v maps, trigrams, and digrams. As a final filter, you should give the user the option of viewing only anagrams that start with a given letter. This will let the user divide the remaining anagrams into more manageable “chunks,” or focus on the more intimidating-sounding anagrams, like those that begin with <em>v</em>!</p>
<h4 class="h4" id="lev71"><strong><em>The British Brute-Force Code</em></strong></h4>
<p class="noindent">The upcoming code generates permutations of <em>tmvoordle</em> and passes them through the filters just described. It then gives the user the option to view either all the permutations or only those starting with a given letter.</p>
<p class="indent">You can download all the programs you’ll need from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. The code in this section is one script named <em>voldemort_british.py</em>. You’ll also need the <em>load_dictionary.py</em> program in the same folder, along with the same dictionary file you used for the projects earlier in this chapter. Finally, you’ll need a new file named <em>least-likely_trigrams.txt</em>, a text file of trigrams with a low frequency of occurrence in English. Download all these files into the same folder.</p>
<h5 class="h5" id="lev72"><strong>Defining the main() Function</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list5">Listing 3-5</a> imports the modules that <em>voldemort_british.py</em> needs and defines its <span class="literal">main()</span> function. In the <em>phrase_anagrams.py</em> program, you defined the <span class="literal">main()</span> function at the end of the code. Here we put it at the start. The advantage is that you can see what the function is doing—how it’s running the program—from the start. The disadvantage is that you don’t know what any of the helper functions do yet.</p>
<p class="margin"><em>voldemort_british.py,</em> part 1</p>
<p class="programs"><span class="ent">➊</span> import sys<br/>   from itertools import permutations<br/>   from collections import Counter<br/>   import load_dictionary<br/><br/><span class="ent">➋</span> def main():<br/>       """Load files, run filters, allow user to view anagrams by 1st letter."""<br/>    <span class="ent">➌</span> name = 'tmvoordle'<br/>       name = name.lower()<br/><br/>    <span class="ent">➍</span> word_list_ini = load_dictionary.load('2of4brif.txt')<br/>       trigrams_filtered = load_dictionary.load('least-likely_trigrams.txt')<br/><br/>    <span class="ent">➎</span> word_list = prep_words(name, word_list_ini)<br/>       filtered_cv_map = cv_map_words(word_list)<br/>       filter_1 = cv_map_filter(name, filtered_cv_map)<br/>       filter_2 = trigram_filter(filter_1, trigrams_filtered)<br/>       filter_3 = letter_pair_filter(filter_2)<br/>       view_by_letter(name, filter_3)</p>
<p class="listing" id="ch03list5"><em>Listing 3-5: Imports modules and defines the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Start by importing modules you’ve used in the previous projects <span class="ent">➊</span>. Now define the <span class="literal">main()</span> function <span class="ent">➋</span>. The <span class="literal">name</span> variable is a string of the remaining letters <em>tmvoordle</em> <span class="ent">➌</span>. Set it to lowercase to guard against a user input error. Next, use the <span class="literal">load_dictionary</span> module to load your dictionary file and the trigrams file as lists <span class="ent">➍</span>. Your dictionary filename may be different from that shown.</p>
<p class="indent">Finally, call all the various functions in order <span class="ent">➎</span>. I’ll describe each of these functions momentarily, but basically, you need to prepare the word list, prepare the c-v maps, apply the three filters, and let the user view all the anagrams at once or view a subset based on the anagram’s first letter.</p>
<h5 class="h5" id="lev73"><strong>Preparing the Word List</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list6">Listing 3-6</a> prepares the word list by including just the words that have as many letters as in the <span class="literal">name</span> variable (in this case, nine). You should also ensure that all the words are lowercase, to be consistent.</p>
<p class="margin"><em>voldemort_british.py,</em> part 2</p>
<p class="programs"><span class="ent">➊</span> def prep_words(name, word_list_ini):<br/>       """Prep word list for finding anagrams."""<br/>    <span class="ent">➋</span> print("length initial word_list = {}".format(len(word_list_ini)))<br/>       len_name = len(name)<br/>    <span class="ent">➌</span> word_list = [word.lower() for word in word_list_ini<br/>                    if len(word) == len_name]<br/>    <span class="ent">➍</span> print("length of new word_list = {}".format(len(word_list)))<br/>    <span class="ent">➎</span> return word_list</p>
<p class="listing" id="ch03list6"><em>Listing 3-6: Creates lists of words that are equal in length to the</em> <span class="codeitalic">name</span> <em>variable</em></p>
<p class="indent">Define the <span class="literal">prep_words()</span> function to take a name string and list of dictionary words as arguments <span class="ent">➊</span>. I suggest that you print the lengths of your various word lists before and after they’ve gone through a filter; that way, you can track how much impact the filters are having. So print the length of the dictionary <span class="ent">➋</span>. Assign a variable to hold the length of the name and then use list comprehension to create a new list by looping through the words in <span class="literal">word_list_ini</span>, keeping those whose length is the same as the number of letters in <span class="literal">name</span>, and converting them to lowercase <span class="ent">➌</span>. Next, print the length of this new word list <span class="ent">➍</span>, and finally, return this new list for use in the next function <span class="ent">➎</span>.</p>
<h5 class="h5" id="lev74"><strong>Generating the C-V Map</strong></h5>
<p class="noindent">You need to convert the prepared word list to a c-v map. Remember that you’re no longer interested in actual words in the dictionary; those have been reviewed and rejected. Your goal is to shuffle the remaining letters until they form something that resembles a proper noun.</p>
<p class="indent"><a href="ch03.xhtml#ch03list7">Listing 3-7</a> defines a function that generates c-v maps for each word in <span class="literal">word_list</span>. The program, <em>voldemort_british.py</em>, will use the c-v map to judge whether a shuffled letter combination is reasonable based on consonant-vowel patterns in the English language.</p>
<p class="margin"><span epub:type="pagebreak" id="page_56"/><em>voldemort_british.py,</em> part 3</p>
<p class="programs"><span class="ent">➊</span> def cv_map_words(word_list):<br/>       """Map letters in words to consonants &amp; vowels."""<br/>    <span class="ent">➋</span> vowels = 'aeiouy'<br/>    <span class="ent">➌</span> cv_mapped_words = []<br/>    <span class="ent">➍</span> for word in word_list:<br/>           temp = ''<br/>           for letter in word:<br/>               if letter in vowels:<br/>                   temp += 'v'<br/>               else:<br/>                   temp += 'c'<br/>           cv_mapped_words.append(temp)<br/><br/>       # determine number of UNIQUE c-v patterns<br/>    <span class="ent">➎</span> total = len(set(cv_mapped_words))<br/>       # target fraction to eliminate<br/>    <span class="ent">➏</span> target = 0.05<br/>       # get number of items in target fraction<br/>    <span class="ent">➐</span> n = int(total * target)<br/>    <span class="ent">➑</span> count_pruned = Counter(cv_mapped_words).most_common(total - n)<br/>    <span class="ent">➒</span> filtered_cv_map = set()<br/>       for pattern, count in count_pruned:<br/>           filtered_cv_map.add(pattern)<br/>       print("length filtered_cv_map = {}".format(len(filtered_cv_map)))<br/>    <span class="ent">➓</span> return filtered_cv_map</p>
<p class="listing" id="ch03list7"><em>Listing 3-7: Generates c-v maps from the words in</em> <span class="codeitalic">word_list</span></p>
<p class="indent">Define the <span class="literal">cv_map_words()</span> function to take the prepped word list as an argument <span class="ent">➊</span>. Since consonants and vowels form a binary system, you can define the vowels with a string <span class="ent">➋</span>. Create an empty list to hold the maps <span class="ent">➌</span>. Then loop through the words and the letters in each word, converting the letters to either a <em>c</em> or <em>v</em> <span class="ent">➍</span>. Use a variable called <span class="literal">temp</span> to accumulate the map; then append it to the list. Note that <span class="literal">temp</span> is reinitialized each time the loop repeats.</p>
<p class="indent">You want to know the frequency of occurrence of a given c-v map pattern (for example, <em>cvcv</em>), so you can remove those with a low likelihood of occurrence. Before calculating the frequency, you need to collapse your list down to unique c-v maps—as it is now, <em>cvcv</em> may be repeated many, many times. So, turn the <span class="literal">cv_mapped_words</span> list into a set, to remove duplicates, and get its length <span class="ent">➎</span>. Now you can define a target percentage to eliminate, using fractional values <span class="ent">➏</span>. Start with a low number like <span class="literal">0.05</span>—equivalent to 5 percent—so you’re less likely to eliminate anagrams that can form usable proper names. Multiply this target value by the total length of the <span class="literal">cv_mapped_words</span> set and assign the result to the variable <span class="literal">n</span> <span class="ent">➐</span>. Be sure to convert <span class="literal">n</span> to an integer; since it will represent a count value, it can’t be a float.</p>
<p class="indent">The <span class="literal">Counter</span> module data type has a handy method, <span class="literal">most_common()</span>, that will return the most common items in a list based on a <em>count</em> value that you provide; in this case, that value will be the length of the c-v map list, <span class="literal">total</span>, minus <span class="literal">n</span>. The value you pass <span class="literal">most_common()</span> must be an integer. If you pass <span epub:type="pagebreak" id="page_57"/>the <span class="literal">most_common()</span> function the length of the list, it will return all the items in the list. If you subtract the count for the least likely 5 percent, you will effectively eliminate these c-v maps from the list <span class="ent">➑</span>.</p>
<p class="indent">Remember, <span class="literal">Counter</span> returns a dictionary, but all you need are the final c-v maps, not their associated frequency counts. So initialize an empty set called <span class="literal">filtered-cv-map</span> <span class="ent">➒</span> and loop through each key-value pair in <span class="literal">count_pruned()</span>, adding only the key to the new set. Print the length of this set, so you can see the impact of the filter. Then finish by returning the filtered c-v map for use in the next function <span class="ent">➓</span>.</p>
<h5 class="h5" id="lev75"><strong>Defining the C-V Map Filter</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list8">Listing 3-8</a> applies the c-v map filter: anagrams are generated based on permutations of the letters in the <span class="literal">name</span> variable, and then the program converts them to c-v maps and compares those anagrams to the filtered c-v maps built with the <span class="literal">cv_map_words()</span> function. If an anagram’s c-v map is found in <span class="literal">filtered_cv_map</span>, then the program stores the anagram for the next filter.</p>
<p class="margin"><em>voldemort_british.py,</em> part 4</p>
<p class="programs"><span class="ent">➊</span> def cv_map_filter(name, filtered_cv_map):<br/>       """Remove permutations of words based on unlikely cons-vowel combos."""<br/>    <span class="ent">➋</span> perms = {''.join(i) for i in permutations(name)}<br/>       print("length of initial permutations set = {}".format(len(perms)))<br/>       vowels = 'aeiouy'<br/>    <span class="ent">➌</span> filter_1 = set()<br/>    <span class="ent">➍</span> for candidate in perms:<br/>           temp = ''<br/>           for letter in candidate:<br/>               if letter in vowels:<br/>                   temp += 'v'<br/>               else:<br/>                   temp += 'c'<br/>        <span class="ent">➎</span> if temp in filtered_cv_map:<br/>               filter_1.add(candidate)<br/>       print("# choices after filter_1 = {}".format(len(filter_1)))<br/>    <span class="ent">➏</span> return filter_1</p>
<p class="listing" id="ch03list8"><em>Listing 3-8: Defines</em> <span class="codeitalic">cv_map_filter()</span> <em>function</em></p>
<p class="indent">Define the function <span class="literal">cv_map_filter()</span> to take two arguments: the name, followed by the set of c-v maps returned by <span class="literal">cv_map_words()</span> <span class="ent">➊</span>. Use set comprehension and the <span class="literal">permutations</span> module to generate the set of permutations <span class="ent">➋</span>. I described this process in “<a href="ch03.xhtml#lev65">Project #6: Finding Voldemort: The Gallic Gambit</a>” on <a href="ch03.xhtml#page_49">page 49</a>. Use a set here to permit later use of set operations, like taking the difference between two filter sets. This also removes duplicates, as <span class="literal">permutations</span> treats each <em>o</em> as a separate item, and returns 9!, rather than 9! / 2!. Note that <span class="literal">permutations</span> considers <em>tmv<strong>o</strong>ordle</em> and <em>tmvo<strong>o</strong>rdle</em> different strings.</p>
<p class="indent">Now initialize an empty set to hold the contents of the first filter <span class="ent">➌</span> and begin looping through the permutations <span class="ent">➍</span>. Use the term <em>candidate</em>, as most of these aren’t words but just strings of random letters. For each candidate, <span epub:type="pagebreak" id="page_58"/>loop through the letters and map them to a <em>c</em> or a <em>v</em>, as you did with the <span class="literal">cv_words()</span> function. Check each c-v map, <span class="literal">temp</span>, for membership in <span class="literal">filtered_cv_map</span>. This is one reason for using sets: membership checks are very fast. If the candidate meets the condition, add it to <span class="literal">filter_1</span> <span class="ent">➎</span>. Finish by returning your new anagram set <span class="ent">➏</span>.</p>
<h5 class="h5" id="lev76"><strong>Defining the Trigram Filter</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list9">Listing 3-9</a> defines the trigram filter, which removes the permutations with unlikely three-letter triplets. It uses a text file derived from various cryptography websites that has been tailored to the letters in <em>tmvoordle</em>. This function will return only permutations that include one of these trigrams; the <span class="literal">main()</span> function will pass the new set to the next filter function.</p>
<p class="margin"><em>voldemort_british.py,</em> part 5</p>
<p class="programs"><span class="ent">➊</span> def trigram_filter(filter_1, trigrams_filtered):<br/>       """Remove unlikely trigrams from permutations."""<br/>    <span class="ent">➋</span> filtered = set()<br/>    <span class="ent">➌</span> for candidate in filter_1:<br/>        <span class="ent">➍</span> for triplet in trigrams_filtered:<br/>               triplet = triplet.lower()<br/>               if triplet in candidate:<br/>                   filtered.add(candidate)<br/>    <span class="ent">➎</span> filter_2 = filter_1 - filtered<br/>       print("# of choices after filter_2 = {}".format(len(filter_2)))<br/>    <span class="ent">➏</span> return filter_2</p>
<p class="listing" id="ch03list9"><em>Listing 3-9: Defines the</em> <span class="codeitalic">trigram_filter()</span> <em>function</em></p>
<p class="indent">Parameters for the trigram filter include the output from the c-v map filter and the external list of unlikely trigrams, <span class="literal">trigrams_filtered</span> <span class="ent">➊</span>.</p>
<p class="indent">Initialize an empty set to hold permutations that contain one of the forbidden trigrams <span class="ent">➋</span>. Then start another <span class="literal">for</span> loop that looks through the candidates that survived the last filter <span class="ent">➌</span>. A nested <span class="literal">for</span> loop looks at each triplet in the trigrams list <span class="ent">➍</span>. If the triplet is in the candidate, it is added to the filter.</p>
<p class="indent">Now you can use set operations to subtract the new filter from <span class="literal">filter_1</span> <span class="ent">➎</span> and then return the difference for use with the next filter <span class="ent">➏</span>.</p>
<h5 class="h5" id="lev77"><strong>Defining the Digram Filter</strong></h5>
<p class="noindent"><a href="ch03.xhtml#ch03list10">Listing 3-10</a> defines the digram filter, which removes unlikely letter pairs. Some will trigger the filter if they occur anywhere within the permutation; others will do so only if they occur at the start of the permutation. The disallowed digrams are based on the shaded cells in <a href="ch03.xhtml#ch03tab2">Table 3-2</a>. The function returns the results of this filter for use in the final filter function.</p>
<p class="margin"><em>voldemort_british.py,</em> part 6</p>
<p class="programs"><span class="ent">➊</span> def letter_pair_filter(filter_2):<br/>       """Remove unlikely letter-pairs from permutations."""<br/>    <span class="ent">➋</span> filtered = set()<br/>    <span class="ent">➌</span> rejects = ['dt', 'lr', 'md', 'ml', 'mr', 'mt', 'mv',<br/>                  'td', 'tv', 'vd', 'vl', 'vm', 'vr', 'vt']<br/><span epub:type="pagebreak" id="page_59"/>    <span class="ent">➍</span> first_pair_rejects = ['ld', 'lm', 'lt', 'lv', 'rd',<br/>                             'rl', 'rm', 'rt', 'rv', 'tl', 'tm']<br/>    <span class="ent">➎</span> for candidate in filter_2:<br/>        <span class="ent">➏</span> for r in rejects:<br/>               if r in candidate:<br/>                   filtered.add(candidate)<br/>        <span class="ent">➐</span> for fp in first_pair_rejects:<br/>               if candidate.startswith(fp):<br/>                   filtered.add(candidate)<br/>    <span class="ent">➑</span> filter_3 = filter_2 - filtered<br/>       print("# of choices after filter_3 = {}".format(len(filter_3)))<br/>    <span class="ent">➒</span> if 'voldemort' in filter_3:<br/>           print("Voldemort found!", file=sys.stderr)<br/>    <span class="ent">➓</span> return filter_3</p>
<p class="listing" id="ch03list10"><em>Listing 3-10: Defines the</em> <span class="codeitalic">letter_pair_filter()</span> <em>function</em></p>
<p class="indent">This filter accepts the results of the previous filter as an argument <span class="ent">➊</span>. An empty set is initialized to hold any discarded permutations <span class="ent">➋</span>. Then two lists of rejected pairs are assigned to the variables <span class="literal">rejects</span> <span class="ent">➌</span> and <span class="literal">first_pair_rejects</span> <span class="ent">➍</span>. Both lists were entered manually. The first represents cells shaded black in <a href="ch03.xhtml#ch03tab2">Table 3-2</a>; the second references cells shaded gray. Any permutation that contains a member of the first list—anywhere—will be discarded; permutations that <em>start with</em> a member of the second list will not be allowed. You can add or remove digrams to these lists to change how the filter behaves.</p>
<p class="indent">Begin looping through the permutations—continue to refer to these as “candidates,” as they aren’t necessarily words <span class="ent">➎</span>. A nested <span class="literal">for</span> loop goes through the pairs in <span class="literal">rejects</span>, determines whether any are in <span class="literal">candidate</span>, and adds them to the <span class="literal">filtered</span> set <span class="ent">➏</span>. A second nested <span class="literal">for</span> loop repeats this process for the <span class="literal">first_pair_rejects</span> <span class="ent">➐</span>. Subtract <span class="literal">filtered</span> from the set returned from the previous function, <span class="literal">filter_2</span> <span class="ent">➑</span>.</p>
<p class="indent">For fun <em>and</em> to ensure you haven’t filtered too far, check whether <em>voldemort</em> is included in <span class="literal">filter_3</span> <span class="ent">➒</span> and print an announcement to highlight the discovery, using eye-catching red font for IDLE users. Then finish by returning the final filtered set <span class="ent">➓</span>.</p>
<h5 class="h5" id="lev78"><strong>Letting the User Choose the Starting Letter</strong></h5>
<p class="noindent">You don’t know ahead of time whether your filtering will be successful. You may still end up with thousands of permutations. Providing the option to look at only a subset of the output won’t reduce the overall number, but it will make it <em>psychologically</em> easier to face. <a href="ch03.xhtml#ch03list11">Listing 3-11</a> adds, to <em>voldemort_british.py</em>, the ability to view a list of anagrams that begin with a certain input letter.</p>
<p class="margin"><em>voldemort_british.py,</em> part 7</p>
<p class="programs"><span class="ent">➊</span> def view_by_letter(name, filter_3):<br/>       """Filter to anagrams starting with input letter."""<br/>    <span class="ent">➋</span> print("Remaining letters = {}".format(name))<br/>    <span class="ent">➌</span> first = input("select a starting letter or press Enter to see all: ")<br/>    <span class="ent">➍</span> subset = []<br/><span epub:type="pagebreak" id="page_60"/>    <span class="ent">➎</span> for candidate in filter_3:<br/>           if candidate.startswith(first):<br/>               subset.append(candidate)<br/>    <span class="ent">➏</span> print(*sorted(subset), sep='\n')<br/>       print("Number of choices starting with {} = {}".format(first, len(subset)))<br/>    <span class="ent">➐</span> try_again = input("Try again? (Press Enter else any other key to Exit):")<br/>       if try_again.lower() == '':<br/>        <span class="ent">➑</span> view_by_letter(name, filter_3)<br/>       else:<br/>        <span class="ent">➒</span> sys.exit()</p>
<p class="listing" id="ch03list11"><em>Listing 3-11: Defines the</em> <span class="codeitalic">view_by_letter()</span> <em>function</em></p>
<p class="indent">Define the <span class="literal">view_by_letter()</span> function to take both the <span class="literal">name</span> variable and <span class="literal">filter_3</span> as arguments <span class="ent">➊</span>. You need the name so you can show the user the available letter choices on which to filter <span class="ent">➋</span>. Get the user’s input on whether they want to see all the remaining permutations or just those beginning with a certain letter <span class="ent">➌</span>. Then start an empty list to hold the latter subset <span class="ent">➍</span>.</p>
<p class="indent">A <span class="literal">for</span> loop, with a conditional, checks whether a candidate starts with the chosen letter and appends those letters that pass to <span class="literal">subset</span> <span class="ent">➎</span>. This list is printed with the splat operator <span class="ent">➏</span>. Then the program asks the user whether they want to try again or exit <span class="ent">➐</span>. If they press <small>ENTER</small>, then <span class="literal">view_by_letter()</span> is called, recursively, and runs again from the start <span class="ent">➑</span>. Otherwise, the program exits <span class="ent">➒</span>. Note that Python has a default recursion depth limit of 1,000, which we’ll ignore in this project.</p>
<h5 class="h5" id="lev79"><strong>Running the main() Function</strong></h5>
<p class="noindent">Back in the global space, <a href="ch03.xhtml#ch03list12">Listing 3-12</a> completes the code by calling the <span class="literal">main()</span> function if the user runs the program in stand-alone mode versus importing into another program.</p>
<p class="margin"><em>voldemort_british.py,</em> part 8</p>
<p class="programs">if __name__ == '__main__':<br/>    main()</p>
<p class="listing" id="ch03list12"><em>Listing 3-12: Calls the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">Example output from the completed program is shown below. After the program applies the third filter, there are 248 permutations remaining, of which a very manageable 73 start with <em>v</em>. I’ve omitted the printout of the permutations for brevity. As noted in the output, <em>voldemort</em> survives the filtering.</p>
<p class="programs">length initial word_list = 60388<br/>length of new word_list = 8687<br/>length filtered_cv_map = 234<br/>length of initial permutations set = 181440<br/># choices after filter_1 = 123120<br/># of choices after filter_2 = 674<br/><span epub:type="pagebreak" id="page_61"/># of choices after filter_3 = 248<br/>Voldemort found!<br/>Remaining letters = tmvoordle<br/>select a starting letter or Enter to see all: <span class="codestrong1">v</span></p>
<p class="indent">Interestingly, another surviving permutation is <em>lovedmort</em>. Given how many people Voldemort killed—or had killed—this may be the most appropriate moniker of all.</p>
<h3 class="h3" id="lev80"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you first wrote code that found the anagrams for a given word or name. You then expanded on this to find phrasal name anagrams, working interactively with the user. Finally, you employed cryptanalytical techniques to tease <em>Voldemort</em> out of almost 200,000 possible anagrams. Along the way, you applied useful functionality in the <span class="literal">collections</span> and <span class="literal">itertools</span> modules.</p>
<h3 class="h3" id="lev81"><strong>Further Reading</strong></h3>
<p class="noindent">The <em>Jumble</em> website is <em><a href="http://www.jumble.com/">http://www.jumble.com/</a></em>.</p>
<p class="indent">You can find some representative online anagram generators at the following sites:</p>
<ul>
<li class="noindent"><em><a href="http://wordsmith.org/anagram/">http://wordsmith.org/anagram/</a></em></li>
<li class="noindent"><em><a href="https://www.dcode.fr/anagram-generator">https://www.dcode.fr/anagram-generator</a></em></li>
<li class="noindent"><em><a href="http://www.wordplays.com/anagrammer/">http://www.wordplays.com/anagrammer/</a></em></li>
</ul>
<p class="indent">More anagram programs are found in <em>Think Python, 2nd Edition</em> (O’Reilly, 2015) by Allen Downey.</p>
<p class="indent"><em>Cracking Codes with Python</em> (No Starch Press, 2017) by Al Sweigart provides more code for computing word patterns, such as those used for filtering in the <em>voldemort_british.py</em> program.</p>
<h3 class="h3" id="lev82"><strong>Practice Project: Finding Digrams</strong></h3>
<p class="noindent">You <em>could</em> comb through cryptography websites looking for frequency statistics, or you could derive them for yourself. Write a Python program that finds all the digrams in <em>tmvoordle</em> and then counts their frequency of occurrence in a dictionary file. Be sure to test your code on words like <em>volvo</em>, so you don’t overlook repeating digrams in the same word. You can find a solution in the appendix or download <em>count_digrams_practice.py</em> from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h3 class="h3" id="lev83"><span epub:type="pagebreak" id="page_62"/><strong>Challenge Project: Automatic Anagram Generator</strong></h3>
<p class="noindent">Look at the online anagram generators I just referenced in “Further Reading” and write a Python program that mimics one of these. Your program should automatically generate phrase anagrams from an input name and display a subset (for example, the first 500) for the user to review.</p>
</body></html>