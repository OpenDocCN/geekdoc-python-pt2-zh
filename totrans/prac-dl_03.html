<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_29"/><strong><span class="big">3</span><br/>USING NUMPY</strong></h2>&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="189" height="189"/></div>&#13;
<p class="noindents">NumPy is foundational to all of the machine learning we’ll explore in this book. If you’re already comfortable with NumPy, you can skip this chapter. If you’re not, don’t be shy; consider this chapter a refresher and dive in.</p>&#13;
<p class="indent">A full tutorial of NumPy is beyond what we can cover here, so if you’re interested, you can look further at <em><a href="https://docs.scipy.org/doc/numpy/user/quickstart.html">https://docs.scipy.org/doc/numpy/user/quickstart.html</a></em>.</p>&#13;
<h3 class="h3" id="lev1_17">Why NumPy?</h3>&#13;
<p class="noindent">Python is an elegant programming language but it lacks an important data structure that’s fundamental to scientific and mathematical programming: the array. Yes, you could use a dictionary as an array, or a sizeable predefined list, but this would be an abuse of those data structures—and, more practically, it would be slow. Let’s look at the difference in implementation between an array and a list. Python lists are more advanced than the notion of a list we’re using here, but in essence they’re the same.</p>&#13;
<h4 class="h4" id="lev2_21"><span epub:type="pagebreak" id="page_30"/>Arrays vs. Lists</h4>&#13;
<p class="noindent">The <em>array</em> is simply a fixed-size block of <em>contiguous</em> memory, a single block of RAM with no gaps, used to represent a set of <em>n</em> elements, each of which uses exactly <em>m</em> bytes. For example, an IEEE 754 double precision floating-point number occupies 64 bits of memory, 8 bytes, and is what Python uses under the hood for its <code>float</code> data type. Therefore, an array of <em>n</em> = 100 Python floats would occupy, at a minimum, <em>nm</em> = 100(8) = 800 bytes of memory. If Python had arrays as a data structure, it would allocate 800 bytes of memory and point the array variable name, <code>A</code>, to the memory as in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>.</p>&#13;
<div class="image" id="ch3fig1"><img src="Images/03fig01.jpg" alt="image" width="679" height="122"/></div>&#13;
<p class="figcap"><em>Figure 3-1: An array stored in contiguous memory</em></p>&#13;
<p class="indent">Whenever we want to access an element of the array, say <code>x[3]</code>, we can very quickly calculate the exact location in memory by adding 3(8) = 24 to the memory address of the base of the array. This is the indexing operation for an array.</p>&#13;
<p class="indent">Multidimensional arrays are also stored in memory as contiguous blocks, and the indexing operation is only slightly more complicated. A <em>multi-dimensional array</em> uses two or more numbers to index the elements. Think of a chess board; two numbers are needed to determine the location of a piece: the row and the column. Therefore, the chess board is a two-dimensional array. If we add one more dimension to turn the chess board into a stack of chess boards, we need three numbers to locate a piece: the row, the column, and the board number. Therefore, we have a three-dimensional array.</p>&#13;
<p class="indent">We will use arrays with one, two, and three dimensions throughout the book. All of these are stored in memory as a single block of RAM. The point is, an array is quick to index, and therefore operations on array elements can be performed very quickly.</p>&#13;
<p class="indent">Contrast this with a list. <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> shows the basic structure of a list, <code>B</code>, in memory. In this case, the elements in the list are not in contiguous memory, but are scattered throughout RAM with pointers linking one element to the next, like a chain. Each link in the chain contains the data value we want to store and a pointer to the memory of the next link in the chain.</p>&#13;
<div class="image" id="ch3fig2"><img src="Images/03fig02.jpg" alt="image" width="677" height="106"/></div>&#13;
<p class="figcap"><em>Figure 3-2: A list stored as a collection of linked nodes scattered throughout memory</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>We can’t index into a list by just adding an offset to a base memory address. Instead, if we want the fourth element of the list, then we need to start at the head of the list, use the link there to the next element, and the next, and the next, to reach the memory associated with the fourth element, the <code>3</code> in <a href="ch03.xhtml#ch3fig2">Figure 3-2</a>. This isn’t too bad until we want to index the 1,000,000th element and have to repeat the process 1 million times instead of adding 8 million once to a base address.</p>&#13;
<p class="indent">Most machine learning involves arrays. If the array has a single dimension, we call it a <em>vector</em>; vectors are the inputs to many of our models. If the array has two dimensions, it’s a <em>matrix</em>. A matrix can be thought of as a chess board or an image where each pixel of the image is one of the board locations. Matrices can also be an input to our models, or used internally by the model; for example, the weight matrices of a neural network, or the convolution kernels and filter outputs of a convolutional neural network are matrices.</p>&#13;
<p class="indent">Therefore, it’s critically important to be able to quickly operate on array data. This is where the <code>numpy</code> library comes in. It adds the missing array data type to Python so that we can perform calculations rapidly. Frankly, without it, Python would be unsuitable for implementing anything but the simplest of machine learning algorithms. However, with NumPy, Python immediately becomes the premier environment for machine learning research.</p>&#13;
<h4 class="h4" id="lev2_22">Testing Array and List Speed</h4>&#13;
<p class="noindent">Let’s see a quick example of how much speed NumPy gives us over pure Python. The code we’ll execute is in <a href="ch03.xhtml#ch3lis1">Listing 3-1</a>.</p>&#13;
<p class="programs" id="ch3lis1"><span class="ent">❶</span> import numpy as np<br/>&#13;
   import time<br/>&#13;
   import random<br/>&#13;
<br/>&#13;
   n = 1000000<br/>&#13;
   a = [random.random() for i in range(n)]<br/>&#13;
   b = [random.random() for i in range(n)]<br/>&#13;
<br/>&#13;
   s = time.time()<br/>&#13;
<span class="ent">❷</span> c = [a[i]*b[i] for i in range(n)]<br/>&#13;
   print("comprehension:", time.time()-s)<br/>&#13;
<br/>&#13;
   s = time.time()<br/>&#13;
   c = []<br/>&#13;
<span class="ent">❸</span> for i in range(n):<br/>&#13;
       c.append(a[i]*b[i])<br/>&#13;
  print("for loop:", time.time()-s)<br/>&#13;
<br/>&#13;
   s = time.time()<br/>&#13;
<span class="ent">❹</span> c = [0]*n<br/>&#13;
   for i in range(n):<br/>&#13;
<span epub:type="pagebreak" id="page_32"/>       c[i] = a[i]*b[i]<br/>&#13;
   print("existing list:", time.time()-s)<br/>&#13;
<br/>&#13;
<span class="ent">❺</span> x = np.array(a)<br/>&#13;
   y = np.array(b)<br/>&#13;
   s = time.time()<br/>&#13;
   c = x*y<br/>&#13;
   print("NumPy time", time.time()-s)</p>&#13;
<p class="figcap"><em>Listing 3-1: Comparing NumPy to pure Python. See <code>numpy_speed_test.py</code>.</em></p>&#13;
<p class="indent">In <a href="ch03.xhtml#ch3lis1">Listing 3-1</a>, we first import the <code>numpy</code> library <span class="ent">❶</span> and then create two lists of random numbers using a list comprehension. These lists include 1,000,000 elements each. Our goal is to multiply the two lists together, element by element, as quickly as possible.</p>&#13;
<p class="indent">We can measure the time the program takes to run by logging our starting time in <code>s</code> and subtracting it from our ending time when we print. The <code>time</code> function of the <code>time</code> module returns the number of seconds, including fractions of a second, since a set origin time (January 1, 1970). We print <code>time.time()-s</code> after each operation we run.</p>&#13;
<p class="indent">In our first attempt to multiply <code>a</code> and <code>b</code>, we use a list comprehension <span class="ent">❷</span>. Next, we use a loop <span class="ent">❸</span> to select each element from <code>a</code> and <code>b</code> and append their product to the list <code>c</code>. Note that this approach starts with an empty list and appends each new product to it so that the list needs to grow in memory.</p>&#13;
<p class="indent">As a third approach, we pre-allocate the output list so that instead of appending each output to <code>c</code>, we update the corresponding element of <code>c</code> <span class="ent">❹</span>. This approach might be a bit faster—we’ll see.</p>&#13;
<p class="indent">Finally, we use NumPy to do the calculation <span class="ent">❺</span>. We exclude the time it takes to make the two lists into NumPy arrays (lines 25–26) since we could have easily created the random arrays (vectors since they are 1D) with a call to the NumPy random number module. The entire operation with NumPy vectors is <code>c = x*y</code>. Notice that there’s no explicit looping. NumPy is an array-processing library, and it will automatically iterate over all the elements of the arrays for you.</p>&#13;
<p class="indent">If we run the code in <a href="ch03.xhtml#ch3lis1">Listing 3-1</a> ten times to get an average runtime for each of the four approaches, we find the following:</p>&#13;
<table class="box">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="borderb">&#13;
<th style="vertical-align: top;" class="borderr"><p class="tab"><strong><em>Approach</em></strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong><em>Runtime (seconds, mean</em> ± <em>SE)</em></strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="borderr"><p class="tab">List comprehension</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0.158855 ± 0.000426</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="borderr"><p class="tab"><code>for</code> loop</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0.226371 ± 0.000823</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="borderr"><p class="tab"><code>for</code> loop w/existing list</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0.201825 ± 0.000409</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="borderr"><p class="tab">NumPy</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0.009253 ± 0.000027</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">This table shows that NumPy is on average just under 25× faster than pure Python with a naïve implementation. This is why we want to use NumPy for machine learning in Python! Here, <em>SE</em> means <em>standard error of the mean</em>, which is the standard deviation divided by the square root of the number of values that went into the mean, 10 in this case. The <em>standard deviation</em> is <span epub:type="pagebreak" id="page_33"/>a measure of how the values differ from the mean. A large standard deviation means that the values are spread over a broad range. These standard deviations are small, meaning the times are consistent from run to run.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3lis1">Listing 3-1</a> shows us the true power of NumPy. Operations are immediately broadcast across compatible dimensions without requiring explicit loops. The normal linear algebra operations on vectors and matrices are also present, but in general, operations on NumPy arrays are performed automatically element-wise, without looping.</p>&#13;
<p class="indent">Now that you’ve seen why we’re using NumPy, let’s take a look at some of its features.</p>&#13;
<h3 class="h3" id="lev1_18">Basic Arrays</h3>&#13;
<p class="noindent">NumPy is all about arrays, so we’ll start there. Let’s dive right in with some basic examples and then explain what they do and why they look the way they do.</p>&#13;
<h4 class="h4" id="lev2_23">Defining an Array with np.array</h4>&#13;
<p class="noindent">Let’s start with some basic array creation:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import numpy as np</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a = np.array([1,2,3,4])</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
    array([1, 2, 3, 4])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a.size</span><br/>&#13;
    4<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a.shape</span><br/>&#13;
    (4,)<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a.dtype</span><br/>&#13;
    dtype('int64')</pre>&#13;
<p class="indent">Here we define an array, <code>a</code>, using the <code>array</code> function. The argument to the <code>array</code> function needs to be something that NumPy can turn into an array. A list is something that NumPy can turn into an array, as is a tuple, so these are most often the arguments to the <code>array</code> function.</p>&#13;
<p class="indent">If we ask Python to show us what’s in <code>a</code>, we’re told it’s an array and given the values. NumPy will display the contents of an array, but if the array has many elements, it will show us only the first and last few.</p>&#13;
<p class="indent">We next ask for the three most common properties of a NumPy array: the size, the shape, and the data type (<code>dtype</code>). The array <code>a</code> has four elements, so its size is 4. The size of an array is the number of elements it contains. The array <code>a</code> is a vector, meaning it’s only one-dimensional, so the shape is returned as a tuple, always, where the first and only dimension is 4, meaning there are four elements along the first dimension.</p>&#13;
<p class="indent">The data type is new in that Python normally doesn’t care about data types. But to be memory efficient, the <code>numpy</code> library has to care about them. When we created <code>a</code> using <code>array</code>, we didn’t specify a data type, so NumPy <span epub:type="pagebreak" id="page_34"/>defaulted to 64-bit integers because all the values in the list we gave to <code>array</code> were integers. If even one of them had been a float, NumPy would have instead defaulted to 64-bit floating-point numbers, the same as the <code>double</code> type in languages like C, C++, and Java.</p>&#13;
<p class="indent">Now let’s be explicit about the type of data that we want the NumPy array to hold:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">b = np.array([1,2,3,4], dtype="uint8")</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b.dtype</span><br/>&#13;
    dtype('uint8')<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c = np.array([1,2,3,4], dtype="float64")</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c.dtype</span><br/>&#13;
    dtype('float64')</pre>&#13;
<p class="indent">Here we define two arrays, <code>b</code> and <code>c</code>. Both arrays contain the same elements from the list <code>[1,2,3,4]</code>. However, notice the <code>dtype</code> keyword argument to <code>array</code>. This tells NumPy the data type to use for the array. For <code>b</code>, we are telling NumPy to use an unsigned 8-bit integer (<code>uint8</code>). This is a byte or a single ASCII character. If we ask for the <code>dtype</code> property, we are told that the array <code>b</code> is, indeed, of data type unsigned 8-bit integer.</p>&#13;
<p class="indent">The array <code>c</code> contains the same elements as <code>b</code>, but here we tell NumPy to make the array hold 64-bit floating-point numbers. Again, asking for the data type tells us that the array <code>c</code> is of the requested type. When working with NumPy, we must be aware of the type of data our arrays will hold.</p>&#13;
<p class="indent">The most commonly used NumPy data types, and their C equivalents, are given in <a href="ch03.xhtml#ch3tab1">Table 3-1</a>. When defining arrays, specify the NumPy data type as a string with the data type name. We will see examples of this next.</p>&#13;
<p class="tabcap" id="ch3tab1"><strong>Table 3-1:</strong> NumPy Data Type Names, C Equivalents, and Range</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="borderb">&#13;
<th style="vertical-align: top"><p class="tab"><strong>NumPy name</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Equivalent C type</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Range</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">float64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">double</p></td>&#13;
<td style="vertical-align: top"><p class="tab">± [2.225 × 10<sup>–308</sup>, 1.798 × 10<sup>308</sup>]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">float32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">float</p></td>&#13;
<td style="vertical-align: top"><p class="tab">± [1.175 × 10<sup>–38</sup>, 3.403 × 10<sup>38</sup>]</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">int64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">long long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[–2<sup>63</sup>, 2<sup>63</sup>–1]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">uint64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">unsigned long long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[0, 2<sup>64</sup>–1]</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">int32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[–2<sup>31</sup>, 2<sup>31</sup>–1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">uint32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">unsigned long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[0, 2<sup>32</sup>–1]</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">uint8</p></td>&#13;
<td style="vertical-align: top"><p class="tab">unsigned char</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[0, 255 = 2<sup>8</sup>–1]</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">So far, we’ve created only vectors with NumPy. Let’s look at how to create a matrix, a two-dimensional array:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = np.array([[1,2,3],[4,5,6],[7,8,9]])</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">d.shape</span><br/>&#13;
    (3, 3)<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">d.size</span><br/>&#13;
<span epub:type="pagebreak" id="page_35"/>    9<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;
    array([[1, 2, 3],<br/>&#13;
           [4, 5, 6],<br/>&#13;
           [7, 8, 9]])</pre>&#13;
<p class="indent">We use the <code>array</code> function as before, but instead of a single list, we pass in a list of lists. Each element of the supplied list is itself a list of three elements, and there are three such lists. Therefore, the resulting NumPy array will be a 3×3 matrix. The first row of the matrix is the first list of three elements (<code>[1,2,3]</code>), the second row is the second list (<code>[4,5,6]</code>), and the third row is the third list (<code>[7,8,9]</code>).</p>&#13;
<p class="indent">If we ask for the shape of <code>d</code>, we’re told that it’s <code>(3, 3)</code>. This tuple says that there are two dimensions to the array, since there are two elements in the tuple, and that the first dimension has length 3 (three rows) and that the second dimension also has length 3 (three columns). Asking for the size of <code>d</code> tells us that there are nine elements. The size of a NumPy array is equal to the product of all the values in the tuple returned by <code>shape</code>, here 3 × 3 = 9.</p>&#13;
<p class="indent">Asking for the array itself causes NumPy to print it. As the array is small, NumPy shows us the entire array as a two-dimensional matrix:</p>&#13;
<div class="imagec"><img src="Images/035equ01.jpg" alt="image" width="110" height="75"/></div>&#13;
<p class="indent">NumPy is not limited to two-dimensional arrays. For example, here’s a three-dimensional array:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = np.array([[[1,11,111],[2,22,222]],</span><br/>&#13;
                 <span class="codestrong1">[[3,33,333],[4,44,444]]])</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">d.shape</span><br/>&#13;
    (2, 2, 3)<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">d</span><br/>&#13;
    array([[[  1,  11, 111],<br/>&#13;
            [  2,  22, 222]],<br/>&#13;
<br/>&#13;
           [[  3,  33, 333],<br/>&#13;
            [  4,  44, 444]]])</pre>&#13;
<p class="indent">We know that <code>d</code> is three-dimensional because <code>shape</code> returns a tuple with three elements. We also know that <code>d</code> is three-dimensional because the list we passed to <code>array</code> contains two sublists, each of which contains two sublists with three elements each, hence a shape of <code>(2, 2, 3)</code>. NumPy displays <code>d</code> using a blank line between the two 2×2 subarrays. We can think of a three-dimensional array as a vector where each element of the vector is a matrix. We will use three-dimensional NumPy arrays to hold collections of images. For this example, <code>d</code> can be thought of as holding two images, each of two rows by three columns.</p>&#13;
<h4 class="h4" id="lev2_24"><span epub:type="pagebreak" id="page_36"/>Defining Arrays with 0s and 1s</h4>&#13;
<p class="noindent">Defining NumPy arrays with the <code>array</code> function would be very tedious if we wanted a large array since we need to supply the elements of the array. Fortunately, NumPy is not so cruel. Let’s look now at two NumPy workhorse functions that we’ll use often in this book. The first builds arrays where every element is initialized to 0:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = np.zeros((2,3,4))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">x.shape</span><br/>&#13;
    <span class="codestrong1">(2, 3, 4)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">x.dtype</span><br/>&#13;
    dtype('float64')<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = np.zeros((10,10),dtype="uint32")</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b.shape</span><br/>&#13;
    (10, 10)<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b.dtype</span><br/>&#13;
    dtype('uint32')</pre>&#13;
<p class="indent">The <code>zeros</code> function returns new arrays with every element set to 0. The example defines <code>x</code> to be a three-dimensional array since the argument to <code>zeros</code> is the shape of the new array—in this case, the tuple <code>(2,3,4)</code>. This array can be thought of as a pair of tiny images, each 3×4 pixels. Notice that the default type for an array created with <code>zeros</code> is a 64-bit float (<code>dtype</code>). This means each element of the array uses 8 bytes in memory.</p>&#13;
<p class="indent">The array <code>b</code> has two dimensions, 10×10 elements, and we’ve explicitly declared it to be of 32-bit unsigned integers. This means that each element uses only 4 bytes in memory. When using NumPy, we need to be aware of how much memory an array might be using to avoid allocating arrays that are exceptionally large or of a large data type, such as <code>float64</code>, that wastes memory.</p>&#13;
<p class="indent">Our second workhorse function is similar to <code>zeros</code> but instead initializes each element to 1:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">y = np.ones((3,3))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">y</span><br/>&#13;
    array([[1., 1., 1.],<br/>&#13;
           [1., 1., 1.],<br/>&#13;
           [1., 1., 1.]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">y = 10*np.ones((3,3))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">y</span><br/>&#13;
    array([[10., 10., 10.],<br/>&#13;
           [10., 10., 10.],<br/>&#13;
           [10., 10., 10.]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">y.dtype</span><br/>&#13;
    dtype('float64')<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">y.astype("uint8")</span><br/>&#13;
    array([[10, 10, 10],<br/>&#13;
<span epub:type="pagebreak" id="page_37"/>           [10, 10, 10],<br/>&#13;
           [10, 10, 10]], dtype=uint8)</pre>&#13;
<p class="indent">Just like <code>zeros</code>, <code>ones</code> takes a tuple specifying the number of elements along each dimension of the array, here a 3×3 matrix. We can also optionally specify a <code>dtype</code> to make the array hold something other than 64-bit floats.</p>&#13;
<p class="indent">The real utility of <code>ones</code> is creating arrays initialized to any value. We do this by multiplying the <code>ones</code> array by the value we want, here 10. Notice how NumPy realizes that we’re multiplying by a scalar value and performs the operation on every element of the array automatically—no loops required.</p>&#13;
<p class="indent">We slipped in something new, the <code>astype</code> method. This method on an array returns a copy of the array, casting each element to the given data type. Note, casting to a data type that cannot hold the original values, like casting 64-bit floats to unsigned bytes, will result in data being lost. NumPy will do its best, but this is also something to be aware of when using NumPy.</p>&#13;
<p class="indent">Finally, in Python, a list or dictionary object is passed by reference so that assigning one to a new variable doesn’t make a copy; it simply creates an alias that points back to the original memory. This saves time and space but can lead to unintended consequences if we get careless. The same is true with NumPy arrays. They can be very large, so it doesn’t make sense to copy them every time they are passed to a function. If you want to actually create a new copy of a NumPy array, use the <code>copy</code> method or an array slice that represents all the elements of the array. Unlike Python lists, NumPy arrays are flat: the value in a particular place in the array cannot be another array.</p>&#13;
<p class="indent">So, all the following statements, except the second, create a copy of the array <code>a</code>:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = np.arange(10)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = a</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c = a.copy()</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">d = a[:]</span></pre>&#13;
<p class="indent">Changing an element of <code>a</code> will change the corresponding element of <code>b</code> since <code>b</code> is pointing to the same memory as <code>a</code>, but the elements of <code>c</code> and <code>d</code> will be unaffected.</p>&#13;
<h3 class="h3" id="lev1_19">Accessing Elements in an Array</h3>&#13;
<p class="noindent">In this section, we’ll look at two different ways to access elements in an array.</p>&#13;
<h4 class="h4" id="lev2_25">Indexing into an Array</h4>&#13;
<p class="noindent">Arrays aren’t much use if we can’t refer to the elements within them and update them when necessary. This is called <em>array indexing</em>. Understanding array indexing is critical to making good use of NumPy. Let’s jump in with some examples:</p>&#13;
<pre>  &gt;&gt;&gt; <span class="codestrong1">b = np.zeros((3,4),dtype='uint8')</span><br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
<span epub:type="pagebreak" id="page_38"/>      array([[0, 0, 0, 0],<br/>&#13;
             [0, 0, 0, 0],<br/>&#13;
             [0, 0, 0, 0]], dtype=uint8)<br/>&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">b[0,1] = 1</span><br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">b[1,0] = 2</span><br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
      array([[0, 1, 0, 0],<br/>&#13;
             [2, 0, 0, 0],<br/>&#13;
             [0, 0, 0, 0]], dtype=uint8)</pre>&#13;
<p class="indent">We index arrays in the same way that we index lists, with square brackets: <code>[</code> begins the index and <code>]</code> ends it. In between the square brackets goes an expression that tells NumPy which elements of the array to return or assign—this is the <em>subscript</em>. A subscript is appended to an array name to specify one or more elements of the array.</p>&#13;
<p class="indent">In the example above, <code>b</code> is a matrix of three rows and four columns with each element initialized to 0. We see this when we evaluate <code>b</code>.</p>&#13;
<p class="indent">Next, we do something new: we set up an assignment statement <span class="ent">❶</span> where the left-hand side of the statement is not a single variable name but a variable name with a subscript, the text <code>[0,1]</code>. This subscript tells NumPy that the value of the right-hand side of the statement, here just 1, should be put into the element of <code>b</code> at row 0 and column 1. Likewise, NumPy should put a 2 into the element at row 1, column 0. We see that NumPy did as we asked when we look at <code>b</code> and see that the second column of row 0 is now 1, and the first column of row 1 is now 2.</p>&#13;
<p class="indent">If we continue working with <code>b</code> as defined previously, we see how to ask NumPy for elements from the array:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">b[1,0]</span><br/>&#13;
    2<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b[1]</span><br/>&#13;
    array([2, 0, 0, 0], dtype=uint8)<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b[1][0]</span><br/>&#13;
    2</pre>&#13;
<p class="indent">Since <code>b</code> is a matrix, we need subscripts to select a specific element of it, one for the row, another for the column. Therefore, <code>b[1,0]</code> should return the value in the second row and first column, as we see it does.</p>&#13;
<p class="indent">The next line uses a single subscript, <code>b[1]</code>, and returns the entire second row of <code>b</code>. This is a very useful feature that we’ll see in our own code throughout the book.</p>&#13;
<p class="indent">Lastly, if <code>b[1]</code> returns the entire second row of the matrix, <code>b</code>, then we can use <code>b[1][0]</code> to ask for the first element of that row. We see that it matches the result of the <code>b[1,0]</code> syntax we started with.</p>&#13;
<h4 class="h4" id="lev2_26"><span epub:type="pagebreak" id="page_39"/>Slicing an Array</h4>&#13;
<p class="noindent">Accessing individual elements of an array, or an entire subarray, with a single index is useful, but NumPy is far more flexible than that. It’s possible to specify parts of the array by using <em>slicing</em>, which returns subarrays carved out of the larger array as if with a knife. Let’s look at how it works:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = np.arange(10)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a[1:4]</span><br/>&#13;
    array([1, 2, 3])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a[3:7]</span><br/>&#13;
    array([3, 4, 5, 6])</pre>&#13;
<p class="indent">Here we use <code>arange</code>, which is the NumPy analogue of the Python <code>range</code> function, to set <code>a</code> to a vector of the digits [0,9]. We then ask for a slice of this vector, <code>a[1:4]</code>, and see that it returns <code>[1, 2, 3]</code>. The slice was specified with two values: the first is the starting index, 1, and the second is the ending index, 4.</p>&#13;
<p class="indent">Wait—if the ending index is 4,then shouldn’t the slice have returned <code>[1, 2, 3, 4]</code> instead? NumPy follows the Python convention for lists, so the ending index is never included in the returned subarray. We can read the slice as asking for all the elements of <code>a</code> starting at index 1 and up to <em>but not including</em> index 4. Mathematically, a slice given as <code>a[x:y]</code> means all elements, <em>i</em>, of <code>a</code> such that <em>x</em> ≤ <em>i</em> &lt; <em>y</em>. Therefore, the second example, <code>a[3:7]</code>, now makes sense as it’s asking for all elements of <code>a</code> starting with index 3 up to but not including index 7.</p>&#13;
<p class="indent">The slices selected all elements in the given range. NumPy allows for an optional third slice argument that specifies a step size. If not given, the step size is 1. Therefore, with <code>a</code> as a vector of the digits as before, we get this:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a[0:8:2]</span><br/>&#13;
    array([0, 2, 4, 6])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a[3:7:2]</span><br/>&#13;
    array([3, 5])</pre>&#13;
<p class="indent">The first slice starts at the beginning of the array, index 0, and goes to index 8 (but not including index 8) returning every second element. The second example does the same starting with index 3.</p>&#13;
<p class="indent">Any part of the full slice syntax, <code>[x:y:z]</code>, may be omitted, but at least one colon must remain. If so, the default value is the first index (for <code>x</code>), the last index (for <code>y</code>), and 1 (for <code>z</code>). For example:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a[:6]</span><br/>&#13;
    array([0, 1, 2, 3, 4, 5])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a[6:]</span><br/>&#13;
    array([6, 7, 8, 9])</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_40"/>In the first example, the starting index is omitted so it defaults to 0 and we’re given the first six elements of <code>a</code>. In the second example, the ending index is omitted so it defaults to the last index, meaning “return everything from index 6 to the end.” In both cases, the increment was omitted and defaulted to 1.</p>&#13;
<p class="indent">Array slicing leads to some handy shortcuts. Two are given here:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a[-1]</span><br/>&#13;
    9<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a[::-1]</span><br/>&#13;
    array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])</pre>&#13;
<p class="indent">The first example shows us that like Python lists, NumPy arrays can be indexed with negative values to count from the end of an axis. So, asking for index –1 will always return the last element.</p>&#13;
<p class="indent">The second example is a bit mysterious at first. We know that <code>a</code> is a vector of the digits from 0 through 9. The example returns the vector in reverse order. How? Let’s break down the meaning of <code>::-1</code>. We said that any part of the array slice notation can be omitted, and if it is, the default is either the first index, the last index, or the increment. In this case, the first index is omitted so it defaults to 0. The required colon (<code>:</code>) is present, and then the last index is omitted so it defaults to the last index. Then there’s a <code>:</code> for the increment, which is given as –1, to count backward from the ending index to the starting index. This is what counts backward and reverses the elements of the array.</p>&#13;
<p class="indent">Naturally, array slicing works with NumPy arrays with any number of dimensions. Let’s look at slicing a two-dimensional matrix:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">b = np.arange(20).reshape((4,5))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
    array([[ 0,  1,  2,  3,  4],<br/>&#13;
           [ 5,  6,  7,  8,  9],<br/>&#13;
           [10, 11, 12, 13, 14],<br/>&#13;
           [15, 16, 17, 18, 19]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b[1:3,:]</span><br/>&#13;
    array([[ 5,  6,  7,  8,  9],<br/>&#13;
           [10, 11, 12, 13, 14]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b[2:,2:]</span><br/>&#13;
    array([[12, 13, 14],<br/>&#13;
           [17, 18, 19]])</pre>&#13;
<p class="indent">We define <code>b</code> to be a vector of the numbers [0,19] by using <code>arange</code> and then immediately use <code>reshape</code> to change the vector into a matrix of four rows and five columns. The argument to <code>reshape</code> is a tuple specifying the new shape for the array. There must be exactly as many elements in the array as the new shape. The vector had 20 elements, and the new shape has 4 × 5 = 20 elements, so we are okay in this case.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_41"/>Array slicing applies per dimension, so the second example, <code>b[1:3,:]</code> is asking for rows 1 and 2 and all the columns in those rows. That is what : by itself means—all the elements along that axis.</p>&#13;
<p class="indent">The next example asks for all the rows and columns starting with row 2 and column 2. This is the submatrix pulled from the lower-right corner of the full matrix <code>b</code>.</p>&#13;
<h4 class="h4" id="lev2_27">The Ellipsis</h4>&#13;
<p class="noindent">NumPy supports a shorthand notation for slicing that’s sometimes useful. Let’s show it and then discuss what it’s doing. First, however, we need to define some arrays to work with:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c = np.arange(27).reshape((3,3,3))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c</span><br/>&#13;
    array([[[ 0,  1,  2],<br/>&#13;
            [ 3,  4,  5],<br/>&#13;
            [ 6,  7,  8]],<br/>&#13;
           [[ 9, 10, 11],<br/>&#13;
            [12, 13, 14],<br/>&#13;
            [15, 16, 17]],<br/>&#13;
           [[18, 19, 20],<br/>&#13;
            [21, 22, 23],<br/>&#13;
            [24, 25, 26]]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a = np.ones((3,3))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
    array([[1., 1., 1.],<br/>&#13;
           [1., 1., 1.],<br/>&#13;
           [1., 1., 1.]])</pre>&#13;
<p class="indent">First we define <code>c</code> to be a three-dimensional array with three elements along each dimension. We use the same <code>reshape</code> trick that we used previously, and we know it will work because 3 × 3 × 3 = 27 and there are 27 elements in the initial vector produced by <code>arange</code>. Again, we can think of <code>c</code> as three 3×3 images stacked together. Next we use <code>ones</code> to define a simple 3×3 matrix with every value set to 1.</p>&#13;
<p class="indent">From our discussion of array slicing so far, we know that we can replace the 3×3 subarray in <code>c</code> for any particular “image” by using the colon notation. For example, let’s replace the second “image” of <code>c</code> by <code>a</code>:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c[1,:,:] = a</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c</span><br/>&#13;
array([[[ 0,  1,  2],<br/>&#13;
        [ 3,  4,  5],<br/>&#13;
        [ 6,  7,  8]],<br/>&#13;
       [[ 1,  1,  1],<br/>&#13;
        [ 1,  1,  1],<br/>&#13;
        [ 1,  1,  1]],<br/>&#13;
<span epub:type="pagebreak" id="page_42"/>       [[18, 19, 20],<br/>&#13;
        [21, 22, 23],<br/>&#13;
        [24, 25, 26]]])</pre>&#13;
<p class="indent">Here we tell NumPy to replace the second subarray, which is 3×3, with the 3×3 array in <code>a</code>. It’s the second subarray because the first index is given as 1. When we print <code>c</code>, we see that the second 3×3 subarray is now all 1s.</p>&#13;
<p class="indent">Now for the shorthand notation. This time, we want to replace the first 3×3 subarray of <code>c</code> with <code>a</code>. We could do this with a syntax of <code>c[0,:,:]</code> but instead we’ll use the shorthand notation:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c[0,...] = a</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c</span><br/>&#13;
    array([[[ 1,  1,  1],<br/>&#13;
            [ 1,  1,  1],<br/>&#13;
            [ 1,  1,  1]],<br/>&#13;
           [[ 1,  1,  1],<br/>&#13;
            [ 1,  1,  1],<br/>&#13;
            [ 1,  1,  1]],<br/>&#13;
           [[18, 19, 20],<br/>&#13;
            [21, 22, 23],<br/>&#13;
            [24, 25, 26]]])</pre>&#13;
<p class="indent">Notice that instead of <code>c[0,:,:]</code>, where we specified all the indices of all the remaining dimensions of <code>c</code>, we used <code>c[0,...]</code> which NumPy interprets as meaning “and as many colons as necessary to cover all the remaining dimensions.” Of course, the shape of <code>a</code> must match the shape of the subarray specified by all the remaining dimensions. In this example, there are two remaining dimensions and <code>a</code> is a two-dimensional array, so we do match. The ellipsis notation (<code>...</code>) is commonly used in Python code related to machine learning, so that’s why I mention it here. You could argue that from a readability standpoint, using <code>...</code> is not a good idea because it requires the reader of the code to remember how many dimensions a particular array has.</p>&#13;
<h3 class="h3" id="lev1_20">Operators and Broadcasting</h3>&#13;
<p class="noindent">NumPy uses all the standard math operators as well as a heap of other methods and functions that implement more advanced operations. NumPy also uses a concept called <em>broadcasting</em> to decide how to apply an operator to arrays. Let’s look at some simple operators and broadcasting:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = np.arange(5)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
    array([ 0, 1, 2, 3, 4])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c = np.arange(5)[::-1]</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">c</span><br/>&#13;
    array([ 4, 3, 2, 1, 0])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a*3.14</span><br/>&#13;
    array([ 0., 3.14, 6.28, 9.42, 12.56])<br/>&#13;
<span epub:type="pagebreak" id="page_43"/>&gt;&gt;&gt; <span class="codestrong1">a*a</span><br/>&#13;
    array([ 0,  1,  4,  9, 16])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a*c</span><br/>&#13;
    array([0, 3, 4, 3, 0])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a//(c+1)</span><br/>&#13;
    array([0, 0, 0, 1, 4])</pre>&#13;
<p class="indent">From earlier examples, we know that <code>a</code> is a vector of the digits 0 through 4. And, we know because of our discussion of array slicing, that <code>c</code> is a vector of the digits 4 down to 0, the reverse of <code>a</code>.</p>&#13;
<p class="indent">With that in mind, we see that multiplying <code>a</code> by 3.14 multiplies each element by 3.14. NumPy has broadcast the scalar 3.14 across all the elements of the array <code>a</code>. NumPy would do this no matter what shape <code>a</code> has. Operating on an array with a scalar performs the operation on all elements of the array, regardless of its shape.</p>&#13;
<p class="indent">The expression <code>a*a</code> multiplies <code>a</code> by itself. In this case, NumPy sees that the two arrays have the same shape, so it multiplies corresponding elements, thereby squaring each element of <code>a</code>. Multiplying <code>a</code> by <code>c</code> is also straightforward because <code>c</code> has the same shape as <code>a</code>.</p>&#13;
<p class="indent">The last example uses broadcasting twice. First, it broadcasts the scalar 1 across <code>c</code> to add one to each element of <code>c</code>. This operation does not change the shape of <code>c</code>, so dividing <code>a</code> by using integer division (<code>//</code> not <code>/</code>), by the expression <code>(c+1)</code>, works since each has the same shape.</p>&#13;
<p class="indent">Let’s look at some more examples. There’s no end to the number of examples we could give, but one more small set should cement the concepts for us. First a more complex broadcasting example:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
    array([0, 1, 2, 3, 4])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b=np.arange(25).reshape((5,5))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
    array([[ 0,  1,  2,  3,  4],<br/>&#13;
           [ 5,  6,  7,  8,  9],<br/>&#13;
           [10, 11, 12, 13, 14],<br/>&#13;
           [15, 16, 17, 18, 19],<br/>&#13;
           [20, 21, 22, 23, 24]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a*b</span><br/>&#13;
    array([[ 0,  1,  4,  9, 16],<br/>&#13;
           [ 0,  6, 14, 24, 36],<br/>&#13;
           [ 0, 11, 24, 39, 56],<br/>&#13;
           [ 0, 16, 34, 54, 76],<br/>&#13;
           [ 0, 21, 44, 69, 96]])</pre>&#13;
<p class="indent">Remember that <code>a</code> is a vector of digits. We then define <code>b</code> to be a 5×5 matrix of the numbers 0 through 24. Next, we multiply <code>a</code> and <code>b</code>.</p>&#13;
<p class="indent">At this point, you should object. How can we multiply these two arrays when their shapes don’t match? The array <code>a</code> has only 5 elements, while <code>b</code> has 25. This is where broadcasting comes into play. NumPy recognizes that the <span epub:type="pagebreak" id="page_44"/>five-element vector in <code>a</code> matches the size of each <em>row</em> of <code>b</code> so it multiplies each row of <code>b</code> by <code>a</code> to return a new 5×5 matrix. This sort of broadcasting is actually quite handy. We’ll be storing our datasets primarily as two-dimensional NumPy arrays, where each row is a sample and the columns correspond to input values for that sample.</p>&#13;
<p class="indent">NumPy also supports matrix math operations. These are the operations on vectors and matrices that we find in linear algebra. For example:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = np.arange(5)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">x</span><br/>&#13;
    array([0, 1, 2, 3, 4])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">np.dot(x,x)</span><br/>&#13;
    30</pre>&#13;
<p class="indent">Here we define <code>x</code> to be a simple vector of five elements. We then introduce NumPy’s primary vector and matrix product function, <code>dot</code>, to multiply <code>x</code> by itself. We already know that if we multiply <code>x</code> by itself in the standard way, using <code>x*x</code>, we’ll get each element times itself, giving <code>[0,1,4,9,16]</code>, but that’s not what we get here. Instead we get the scalar value, 30. Why?</p>&#13;
<p class="indent">The answer has to do with what <code>dot</code> does. It doesn’t implement element-wise multiplication but instead implements linear algebra multiplication. Specifically, because both arguments to <code>dot</code> are vectors, it implements vector times vector, which is known as the <em>dot product</em>, hence the name of the NumPy function. The dot product for vectors multiplies each element of the first vector by the corresponding element of the second vector and then adds all those products together. So, for <code>dot(x,x)</code> NumPy is calculating as follows:</p>&#13;
<p class="center">[0, 1, 2, 3, 4] × [0, 1, 2, 3, 4] = [0, 1, 4, 9, 16]; 0 + 1 + 4 + 9 + 16 = 30</p>&#13;
<p class="indent">The <code>dot</code> function can be used to multiply two vectors, a vector and a matrix, or two matrices, all following the rules of linear algebra, which are beyond the scope of this book to explore in detail. That said, the <code>dot</code> function is of great importance to us because it is the workhorse function of machine learning with NumPy. In the end, most of modern machine learning boils down to math with vectors and matrices.</p>&#13;
<p class="indent">Let’s look at an example using <code>dot</code> with two matrices:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = np.arange(9).reshape((3,3))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = np.arange(9).reshape((3,3))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
    array([[0, 1, 2],<br/>&#13;
           [3, 4, 5],<br/>&#13;
           [6, 7, 8]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">np.dot(a,b)</span><br/>&#13;
    array([[ 15,  18,  21],<br/>&#13;
           [ 42,  54,  66],<br/>&#13;
           [ 69,  90, 111]])<br/>&#13;
&gt;&gt;&gt; a*b<br/>&#13;
<span epub:type="pagebreak" id="page_45"/>    array([[ 0,  1,  4],<br/>&#13;
           [ 9, 16, 25],<br/>&#13;
           [36, 49, 64]])</pre>&#13;
<p class="indent">Here we define both <code>a</code> and <code>b</code> to be the same 3×3 matrix of the digits 0 through 9. We then use <code>dot</code> with these two matrices. For comparison purposes, we also show normal multiplication of the two matrices.</p>&#13;
<p class="indent">The two results are not the same. The first uses linear algebra rules for multiplying two 3×3 matrices, which says that the first element of the 3×3 output will be the first column of <code>b</code>, [0, 3, 6], multiplied element by element with the first row of <code>a</code>, [0, 1, 2], with each product summed:</p>&#13;
<p class="center">[0, 3, 6] × [0, 1, 2] = [0, 3, 12]; 0 + 3 + 12 = 15</p>&#13;
<p class="noindent">A similar process creates each of the other entries. For the simple multiplication, the first element of the 3×3 output is simply 0 × 0 = 0.</p>&#13;
<p class="indent">If the inputs to <code>dot</code> are matrices, then <code>dot</code> acts as we expect: it’s matrix multiplication. It’s when one of the inputs is a vector and the other a matrix that things get a little sloppy. NumPy is somewhat careless about whether the vector is a row or column vector—it produces the correct result regardless, though the shape of the result might not follow linear algebra rules precisely.</p>&#13;
<p class="indent">We trudged through the linear algebra examples because as you continue to explore machine learning, you’ll encounter code using <code>dot</code> quite frequently. It’s good to know what it does, but because of its tolerance of the shape of its inputs, you might need to work through the code paying careful attention to the actual shapes of your arrays to avoid getting lost.</p>&#13;
<h3 class="h3" id="lev1_21">Array Input and Output</h3>&#13;
<p class="noindent">NumPy would be difficult to use if it didn’t provide the means for storing arrays on disk and reading arrays from disk. Sure, we could use a standard Python module like <code>pickle</code>, but that’s inefficient and makes interchange between software packages difficult. Fortunately for us, the creators of NumPy were thorough and included input/output functions.</p>&#13;
<p class="indent">In the following, we’ll refer to several disk files. The first is <em>abc.txt</em>, which looks like this:</p>&#13;
<pre>1 2 3<br/>&#13;
4 5 6<br/>&#13;
7 8 9</pre>&#13;
<p class="noindent">It’s a file of three lines with three numbers per line separated by a space. The second is <em>abc_tab.txt</em>, which is identical to <em>abc.txt</em>, but the spaces have been replaced by a tab character, <code>\t</code> in Python. Tab-delimited files are commonly used to store data in files. The last file is <em>abc.csv</em>, which is a comma-separated values (CSV) file often used by spreadsheet programs. It’s also the same as <em>abc.txt</em>, but the spaces have been replaced by commas. Now, let’s look at NumPy’s basic input/output capabilities.</p>&#13;
<pre><span epub:type="pagebreak" id="page_46"/>  &gt;&gt;&gt; <span class="codestrong1">a = np.loadtxt("abc.txt")</span><br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">a = np.loadtxt("abc_tab.txt")</span><br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">a = np.loadtxt("abc.csv", delimiter=",")</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
<span class="ent">❷</span> &gt;&gt;&gt; <span class="codestrong1">np.save("abc.npy", a)</span><br/>&#13;
<span class="ent">❸</span> &gt;&gt;&gt; <span class="codestrong1">b = np.load("abc.npy")</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
<span class="ent">❹</span> &gt;&gt;&gt; <span class="codestrong1">np.savetxt("ABC.txt", b)</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">np.savetxt("ABC.csv", b, delimiter=",")</span></pre>&#13;
<p class="indent">The first three examples use <code>loadtxt</code>, which reads text files and produces NumPy arrays from them. The first two examples show that <code>loadtxt</code> knows how to parse files with values separated by spaces and tab characters. The function uses the rows of the text file as rows of the matrix, and the values on each line as the elements in each row.</p>&#13;
<p class="indent">The third example explicitly states that the delimiter (separator) between values in the text file is the comma character (<code>,</code>) <span class="ent">❶</span>. This is how to read a <em>.csv</em> file in NumPy.</p>&#13;
<p class="indent">NumPy uses the <code>save</code> function to write arrays to disk <span class="ent">❷</span>. This function writes a single array to the given filename. NumPy uses a <em>.npy</em> file extension to identify the file as containing a NumPy array. We’ll make extensive use of <em>.npy</em> files throughout this book.</p>&#13;
<p class="indent">To read an array back into memory from disk, use <code>load</code> <span class="ent">❸</span>. Note that the data in the array is loaded, but you must assign it to a new variable name. The <em>.npy</em> file doesn’t store the original name of the array.</p>&#13;
<p class="indent">Sometimes we’ll want to write arrays in a format that will be readable by other programs or humans. On those occasions, we’ll use the <code>savetxt</code> function <span class="ent">❹</span>. These examples write text files, first using spaces between values and then using a comma between values.</p>&#13;
<p class="indent">What if we want to write multiple arrays to disk? Are we forced to use a single file for each array? Fortunately, no, we can use <code>savez</code> and read them with <code>load</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>For example:</p>&#13;
<pre>  &gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">np.savez("arrays.npz", a=a, b=b)</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">q = np.load("arrays.npz")</span><br/>&#13;
<span class="ent">❷</span> &gt;&gt;&gt; <span class="codestrong1">list(q.keys())</span><br/>&#13;
      ['a', 'b']<br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">q['a']</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])<br/>&#13;
  &gt;&gt;&gt; <span class="codestrong1">q['b']</span><br/>&#13;
      array([[1., 2., 3.],<br/>&#13;
             [4., 5., 6.],<br/>&#13;
             [7., 8., 9.]])</pre>&#13;
<p class="indent">Here we store the two arrays, <code>a</code> and <code>b</code>, to a single file, <em>arrays.npz</em> <span class="ent">❶</span>. We still read the file with <code>load</code>, but instead of the arrays, <code>q</code> is more like a dictionary so that if we ask for the keys as a list <span class="ent">❷</span>, we get a list of the names of the arrays read from the file. Referencing an array by its name returns it.</p>&#13;
<p class="indent">Look again at the call to <code>savez</code> <span class="ent">❶</span>. Notice how we specified the arrays? This is the keyword approach, and it gives the arrays the keyword name, which we made the same as the variable name so that when we asked for the keys after opening the file, we got back the names we expect. We could have dispensed with the keyword names and simply used the following:</p>&#13;
<pre>&gt;&gt;&gt; np.savez("arrays.npz", a, b)</pre>&#13;
<p class="noindent">This would write the arrays to the file by using default names of <code>arr_0</code> and <code>arr_1</code>. Lastly, since arrays can be quite large, we might want to compress them (losslessly!), and for that, we’d have used <code>savez_compressed</code> in place of <code>savez</code>.</p>&#13;
<p class="indent">Compression might be worth it, but it does slow reading and writing. For example, a 64-bit floating-point array of 10 million element requires at a minimum 80,000,000 bytes of memory. Using <code>savez</code> to write such an array to disk uses 80,000,244 bytes and takes only a fraction of a second. The extra 244 bytes are overhead for the structure of the dictionary. Writing the compressed file to disk takes a second or two but results in a file of 11,960,115 bytes, considerably smaller. Since this example was made using <code>arange</code>, each element of the output array was unique so the compression is not the result of storing an array of 10 million zeros. For the curious, storing 10 million zeros uncompressed still uses 80,000,244 bytes but compressed uses only <span epub:type="pagebreak" id="page_48"/>77,959 bytes on disk. So, the more redundant the array, the more the savings when compressed.</p>&#13;
<h3 class="h3" id="lev1_22">Random Numbers</h3>&#13;
<p class="noindent">NumPy has extensive support for pseudorandom number generation. We’ll be sloppy and simply call them <em>random numbers</em>, understanding that computers are not capable by any algorithmic process of producing actual random numbers—if you’re curious about pseudorandom number generation, you can read my book, <em>Random Numbers and Computers</em> (Springer 2018). The NumPy random number library is under <code>random</code> and can generate samples from many different distributions, the most common being a uniform distribution, [0,1). This means that any (representable) floating-point number in that range is equally likely. Usually, this is what we want. At other times we might want to use a normal distribution that looks like the classic bell-shaped curve. Many physical processes follow this curve. NumPy can generate such samples as well.</p>&#13;
<p class="indent">The random number functions we’ll use in this book are <code>random.random</code> to generate random numbers from [0,1), <code>random.normal</code> to generate random numbers drawn from a bell-shaped curve, and <code>random.seed</code> to set the seed of the generator so we can produce the same sequence of random numbers over and over. We’ll leave it to the philosophers to decide if such a sequence still deserves the label <em>random</em> or, for that matter, if it ever did, regardless of the seed value.</p>&#13;
<h3 class="h3" id="lev1_23">NumPy and Images</h3>&#13;
<p class="noindent">Some of the datasets we’ll use are image based. We’ll want to work with the datasets in NumPy, so we need to know something about how to work with images in Python and how to get images into and out of NumPy arrays. Fortunately, it’s pretty straightforward. Besides NumPy, we’ll need to work with the Pillow module (<code>PIL</code>) to read and write images. We have Pillow installed already—it comes with the installation of our main toolkits. We also have some sample images as part of <code>sklearn</code>.</p>&#13;
<p class="indent">We need to think in terms of two worlds when working with images. There’s the “NumPy” world, where the image has been converted into a NumPy array, and there’s the <code>PIL</code> world that reads and writes images in common graphics formats like JPEG and PNG. The distinction really isn’t so black-and-white—we can do image processing in <code>PIL</code> too, and sometimes that is more convenient; but for now, we’ll use <code>PIL</code> only as a way to read and write image files.</p>&#13;
<p class="indent">Images are two-dimensional arrays of numbers, but if the image is color, we will have three or even four numbers for each pixel, each a byte value representing the intensity of the red, green, blue, and sometimes, alpha, channels of the image. We’ll assume that all of our images are either one-channel grayscale or three-channel RGB. We’ll eliminate any alpha channel when we encounter one. The alpha channel determines how transparent the pixel is.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>First, let’s see how to get at the example images <code>sklearn</code> provides and how to turn them into <code>PIL</code> images, store them on disk, and display them:</p>&#13;
<pre><span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">from PIL import Image</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">from sklearn.datasets import load_sample_images</span><br/>&#13;
<span class="ent">❷</span> &gt;&gt;&gt; <span class="codestrong1">china = load_sample_images().images[0]</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">flower = load_sample_images().images[1]</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">china.shape, china.dtype</span><br/>&#13;
       ((427, 640, 3), dtype('uint8'))<br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">flower.shape, flower.dtype</span><br/>&#13;
       ((427, 640, 3), dtype('uint8'))<br/>&#13;
<span class="ent">❸</span> &gt;&gt;&gt; <span class="codestrong1">imChina = Image.fromarray(china)</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">imFlower = Image.fromarray(flower)</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">imChina.show()</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">imFlower.show()</span><br/>&#13;
<span class="ent">❹</span> &gt;&gt;&gt; <span class="codestrong1">imChina.save("china.png")</span><br/>&#13;
   &gt;&gt;&gt; imFlower.save("flower.png")<br/>&#13;
<span class="ent">❺</span> &gt;&gt;&gt; <span class="codestrong1">im = Image.open("china.png")</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">im.show()</span></pre>&#13;
<p class="indent">First, we need to import <code>PIL</code> <span class="ent">❶</span> and the sample images function from <code>sklearn</code>. Once we have those, we can get at the actual images as NumPy arrays <span class="ent">❷</span>. We see that the <em>china</em> and <em>flower</em> images are three-dimensional arrays, meaning they are RGB images. The images are 427×640 pixels. The third dimension is 3, corresponding to the red, green, and blue channels. If the images were grayscale, they would have only two dimensions.</p>&#13;
<p class="indent">We can convert the NumPy arrays to <code>PIL</code> image objects <span class="ent">❸</span> by using the <code>fromarray</code> function. The argument is assumed to be a NumPy array of the proper format for conversion. Usually this means that the array must have a data type of <code>uint8</code>. Once we have the <code>PIL</code> image objects, we can view the images with the <code>show</code> method.</p>&#13;
<p class="indent">To write the images to disk as actual graphics files, not NumPy arrays, we use the <code>save</code> method on the <code>PIL</code> objects <span class="ent">❹</span>. The format of the output file is determined by the file extension. Here we’re using PNG.</p>&#13;
<p class="indent">To read an image file from disk, we use the <code>open</code> function <span class="ent">❺</span>. Note that <code>open</code> returns a <code>PIL</code> image object, not a NumPy array.</p>&#13;
<p class="indent">Let’s see how to turn the <code>PIL</code> image object into a NumPy array. Also, let’s see how to use <code>PIL</code> to make a color image grayscale before turning it into a NumPy array. We’ll use each of these steps later in the book:</p>&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">im = Image.open("china.png")</span><br/>&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">img = np.array(im)</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">img.shape, img.dtype</span><br/>&#13;
       ((427, 640, 3), dtype('uint8'))<br/>&#13;
<span class="ent">❷</span> &gt;&gt;&gt; <span class="codestrong1">gray = im.convert("L")</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">gray.show()</span><br/>&#13;
<span epub:type="pagebreak" id="page_50"/>   &gt;&gt;&gt; <span class="codestrong1">g = np.array(gray)</span><br/>&#13;
   &gt;&gt;&gt; <span class="codestrong1">g.shape, g.dtype</span><br/>&#13;
       ((427, 640), dtype('uint8'))</pre>&#13;
<p class="indent">We first load the image from disk into a <code>PIL</code> image object, <code>im</code>. We then pass the image object to NumPy via the <code>array</code> function <span class="ent">❶</span>. This function is savvy enough to recognize a <code>PIL</code> image object and make the proper conversion to a NumPy array.</p>&#13;
<p class="indent">We can also turn the <code>PIL</code> RGB image into a grayscale image using the <code>convert</code> method. Note that <code>PIL</code> uses <code>L</code> for <em>luminance</em> to refer to grayscale images <span class="ent">❷</span>. Again, <code>array</code> converts the now grayscale image into a NumPy array. We see that the image has only two dimensions, as we would expect from a grayscale image, where each pixel value is just a shade of gray, not a color.</p>&#13;
<p class="indent">The <code>PIL</code> module has many other abilities. It’s a good idea to look at the Pillow website, <em><a href="https://pillow.readthedocs.io/en/5.1.x/">https://pillow.readthedocs.io/en/5.1.x/</a></em>, to see the other things you can do with PIL.</p>&#13;
<h3 class="h3" id="lev1_24">Summary</h3>&#13;
<p class="noindent">In this chapter, we reviewed how to work with NumPy, the foundational toolkit used by both <code>sklearn</code> and Keras. This gives us the background we need to understand the code examples we’ll see later in the book. It’s essential to understand how to use NumPy, at least at a basic level. The examples in this chapter should help.</p>&#13;
<p class="indent">Now that we’re familiar with NumPy, we are ready to dive into working with data.</p>&#13;
</div></body></html>