- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaclasses and ABCs
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Python developers are well familiar with the mantra, “Everything is an object.”
    When looking at the class system in Python, however, this becomes a paradox: If
    everything is an object, then what is a class? The seemingly arcane answer to
    that question unlocks another powerful tool in the Python toolbox: abstract base
    classes, which are one way of outlining expected behaviors of a type when using
    duck typing.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll be digging into metaclasses, abstract base classes, and
    how you can use them to write more maintainable classes.
  prefs: []
  type: TYPE_NORMAL
- en: Metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes are instances of *metaclasses*, in the same way that objects are instances
    of classes. More precisely, every class is an instance of `type`, and `type` is
    a metaclass. Metaclasses allow you to override how a class is created.
  prefs: []
  type: TYPE_NORMAL
- en: To build on the analogy from Chapter 13, just as a house can be constructed
    from a blueprint, the blueprint can be made from a template. A metaclass is that
    template. One template can be used to produce many different blueprints, and many
    different houses can be built from any one of those blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I go any further, a disclaimer is appropriate: you may reasonably go
    through your entire career without even once using metaclasses directly. By themselves,
    they’re almost certainly not the solution to whatever problem you’re thinking
    about using them for. Tim Peters summarizes this warning exceptionally well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Metaclasses] are deeper magic than 99% of users should ever worry about. If
    you wonder whether you need them, you don’t (the people who actually need them
    know with certainty that they need them, and don’t need an explanation about why).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, understanding metaclasses *does* help with comprehending other Python
    features, including abstract base classes. Django, a Python web framework, also
    makes frequent use of metaclasses internally. Rather than trying to contrive a
    somewhat believable usage for metaclasses, I’ll stick to the bare minimum to demonstrate
    how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Classes with type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have used the `type()` callable in the past to return the type of
    a value or object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: *types.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `type()` callable is actually a metaclass, rather than a function, meaning
    it can be used to create classes the same way in which a class is used to create
    instances. Here’s an example of creating a class from `type()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: *classes_from_type.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I create a class `Food`. It inherits from nothing and has no methods
    or attributes. I’m literally instantiating the metaclass. This is an effective
    equivalent to the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '(In production code, I’d never define an empty base class, but doing so here
    is helpful for demonstration purposes.) Next, I’ll instantiate the `type` metaclass
    again to create another class, `Pizza`, which derives from `Food`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: *classes_from_type.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: I define the function `__init__()`, which will be the initializer of the upcoming
    `Pizza` class. I named the first parameter `obj`, since this isn’t *actually*
    a member of a class yet.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I create the `Pizza` class by calling `type()` and passing the name for
    the class ❶, a tuple of base classes ❷, and a dictionary of methods and class
    attributes ❸. This is where I pass the `__init__` function I wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the functional equivalent of the preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the normal syntax for creating a class is a lot more readable
    and practical. The benefit of the `type` metaclass is that you can create classes
    somewhat dynamically during runtime, although there is seldom a practical reason
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The familiar approach of creating a class with the `class` keyword is really
    just syntactic sugar for instantiating the `type` metaclass. Either way, the end
    result is the same, as this usage indicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: *classes_from_type.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Metaclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a custom metaclass to use as a blueprint for classes. In this
    way, metaclasses are really only useful for modifying the deep internal behavior
    of how the language instantiates and works with the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A metaclass will often override the `__new__()` method, as this is the constructor
    method that governs the creation of the class. Here’s an example of this, via
    an admittedly pointless metaclass, `Gadget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-5: *metaclass.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: The special method `__new__()` is what is called behind the scenes when you
    invoke `type()` or any other metaclass, such as you saw in [Listing 14-2](#listing14-2).
    The `__new__()` method here prints a message that the class is being created,
    and it then invokes the `__new__()` method from the `type` base metaclass. This
    method is expected by the language to accept four arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter here is `self`. The `__new__()` method is written as an
    instance method on the metaclass, because it is supposed to be a class method
    on any instance of this metaclass. If you’re feeling lost, read that a few times
    and let it sink in, remembering that a class is an instance of a metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another special method often implemented by metaclasses is `__prepare__()`.
    Its purpose is to create the dictionary that stores all the methods and class
    attributes for the class being created (see Chapter 15). Here’s one for my `Gadget`
    metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-6: *metaclass.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The `@classmethod` decorator indicates that this method belongs to the metaclass
    itself, not to a class instantiated from this metaclass. (If your brain starts
    to overheat at this point, I highly recommend eating a scoop of ice cream.) The
    `__prepare__()` method also must accept two more parameters, conventionally named
    `name` and `bases`.
  prefs: []
  type: TYPE_NORMAL
- en: The `__prepare__()` special method returns the dictionary that stores all the
    attributes and methods on the class. In this case, I’m returning a dictionary
    that already has a value, so all classes created from the `Gadget` metaclass will
    have a `color` class attribute, with the value `'white'`.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, I would just return an empty dictionary that each class can fill.
    In fact, I can omit the `__prepare__()` method in that case; the `type` metaclass
    already provides this method via inheritance, and the Python interpreter is smart
    about handling a lack of a `__prepare__` method anyway.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the `Gadget` metaclass!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I’ll create an ordinary class using the `Gadget` metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-7: *metaclass.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: The interesting feature here is that I’ve specified the metaclass in the inheritance
    list using `metaclass=Gadget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The added behavior from the `Gadget` metaclass is present, as you can see from
    this example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-8: *metaclass.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Thingamajig` class is instantiated, and I can use it in the same way as
    any other class, except for certain key differences: instantiating the class prints
    a message, and `Thingamajig` has a `color` class attribute with the default value
    `"white"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Those are the basic principles of creating and using metaclasses. If you are
    still tracking with me, congratulate yourself, as this is a difficult topic.
  prefs: []
  type: TYPE_NORMAL
- en: You may have observed that I could have implemented those same behaviors with
    `Gadget` and `Thingamajig` via ordinary inheritance, instead of mucking about
    with a custom metaclass, and you are absolutely right! The trouble is, it’s nearly
    impossible to think of good uses for metaclasses, so we always wind up contriving
    some awful example like the above, just to demonstrate *how* they work. As Tim
    Peters said, “The people who actually need them know with certainty that they
    need them, and don’t need an explanation about why.”
  prefs: []
  type: TYPE_NORMAL
- en: In my own work, I once used a metaclass to implement `__getattr__()` (discussed
    in Chapter 15), which provides fallback behavior when a class attribute is not
    defined. A metaclass was undeniably the right solution to the problem. (Then my
    co-worker Patrick Viafore pointed out that I was also solving the wrong problem.
    Go figure.)
  prefs: []
  type: TYPE_NORMAL
- en: Metaclasses are also the best way to implement the singleton design pattern
    in Python, wherein you only ever have one instance of an object in existence.
    However, the singleton is almost never useful in Python, as you can accomplish
    the same thing with static methods.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a reason Python developers have struggled to come up with viable examples
    for metaclasses for decades. Metaclasses are something you will seldom, if ever,
    use directly, except in that rare instance when you instinctively *know* it’s
    the right tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Type Expectations with Duck Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metaclasses do enable the powerful concept of abstract base classes in Python.
    These allow you to codify expectations for a type in terms of their behaviors.
    Before I can explain abstract base classes, however, I need to unpack some important
    principles of duck typing in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 13, I asserted that in Python, you do not need to use inheritance
    in order to write a function that accepts objects of different types as arguments.
    Python employs duck typing, meaning that instead of caring about an object’s *type*,
    it only expects an object to provide the needed interface. When working with duck
    typing, there are three ways of ensuring a particular argument has the necessary
    functionality: catching exceptions, testing for attributes, or checking for a
    particular interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'EAFP: Catching Exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back in Chapter 8, I introduced the philosophy of *Easier to Ask Forgiveness
    than Permission (EAFP)*, which advocates raising an exception if an argument is
    missing functionality. This is ideal in situations where you’re providing the
    arguments yourself in your code, since unhandled exceptions will alert you to
    the places where the code needs to be improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is unwise to use this technique anywhere an unhandled exception
    might evade detection until a user attempts to use the program in an unexpected
    or untested way. This consideration is known as *fail-fast*: a program in an erroneous
    state should fail as early in the call stack as possible, to reduce the chances
    of bugs evading detection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'LBYL: Checking for Attributes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more complex or brittle code, it may be better to adhere to the philosophy
    of *Look Before You Leap (LBYL)*, in which you check for the functionality you
    need on an argument or value before proceeding. There are two ways to do this.
    For situations where you rely on one or two methods on an object, you can use
    the `hasattr()` function to check for the methods, or even attributes, that you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, using `hasattr()` isn’t necessarily as simple or clear as one might
    hope. Here’s an example of a function that multiplies every third element in the
    collection passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-9: *product_of_thirds.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: Right at the top of my `product_of_thirds` function, I use the `hasattr()` function
    to check that the argument sequence has an attribute named `__iter__` ❶. This
    works because all methods are technically attributes. If the argument doesn’t
    have an attribute by that name, I raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this technique can be subtly wrong. For one thing, not everything
    that is iterable is necessarily subscriptable, and the code in [Listing 14-9](#listing14-9)
    is erroneously assuming that it is. Meanwhile, consider what would happen if I
    passed an instance of the following class to `product_of_thirds()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While this example is contrived, there is nothing stopping a developer from
    hackishly repurposing a name that is assumed to mean something else—yes, nasty
    things like this show up in real code. The result would cause the `hasattr()`
    test to pass anyway. The `hasattr()` function only checks that the object has
    *some* attribute with that name; it doesn’t concern itself with the attribute’s
    type or interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, one must be careful about making assumptions regarding what any single
    function will actually do. Building on my example in [Listing 14-9](#listing14-9),
    I might add the following logic to try to check that my sequence contained values
    that could be multiplied by one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-10: *product_of_thirds.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: By checking for `__getitem__()` along with `__iter__()`, I know the object has
    to be subscriptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still another problem is that a string object does implement `__mul__()` but
    doesn’t use it as expected. Trying to run this version of the code raises a `TypeError`
    when passing a string to `product_of_thirds()`, but with the wrong message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Hmm, that’s not the message I specified. The problem is that the test failed
    to identify that the function logic—namely, multiplication between collection
    items—makes no sense on a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, sometimes inheritance itself can create situations where a `hasattr()`
    test result can be subtly wrong. For example, if you wanted to ensure that an
    object implemented the special method `__ge__` (for the `>=` operator), you might
    expect this to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately for this test, `__ge__` is implemented on the base class `object`,
    from which all classes inherit, so this test will *virtually never fail*, even
    when you expect it should.
  prefs: []
  type: TYPE_NORMAL
- en: All this is to say that while `hasattr()` is appropriate for extremely simple
    scenarios, as soon as your expectations about an argument’s type get complicated,
    you need a better way to look before leaping with duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *abstract base class (ABC)* allows you to specify particular interfaces
    that must be implemented by any class that inherits from the ABC. If the derived
    class does not provide the expected interface, the class instantiation will fail.
    This provides a more robust means of checking whether an object has particular
    traits, such as being iterable or subscriptable. In one sense, you can consider
    an ABC to be a sort of interface contract: the class agrees to implement the methods
    specified by the ABC.'
  prefs: []
  type: TYPE_NORMAL
- en: ABCs cannot be directly instantiated; they can only be inherited by another
    class. Typically, an ABC only defines what methods are expected, and it leaves
    the actual implementation of those methods to the derived class. Under some circumstances,
    an ABC may provide the implementations of some methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can use ABCs to check that your object actually implements an interface.
    This technique avoids the subtly wrong situation of a method being defined on
    some distant base class. If an ABC mandates that `__str__()` be implemented, any
    class that inherits from that ABC will be expected to implement `__str__()` itself,
    or else I won’t be able to instantiate the class; it will not matter that `object.__str__()`
    is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution: Python’s concept of abstract base classes should not be
    compared to virtual and abstract inheritance in C++, Java, or other object-oriented
    languages. Despite some similarities, they work in fundamentally different ways.
    Treat them as separate concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in ABCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python provides an ABC for iterators and a few other common interfaces, but
    it doesn’t *require* you to inherit from a particular base class to make your
    object an iterator. The distinction between an ABC and ordinary inheritance is
    that an ABC seldom provides the actual functionality—instead, inheriting from
    the ABC means the class is required to implement the expected methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `collections.abc` and `numbers` modules contain nearly all of the built-in
    abstract classes, with a few others floating around `contextlib` (for `with` statements),
    `selectors`, and `asyncio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how ABCs fit into an LBYL strategy, I’ll rewrite the example
    I started in [Listing 14-10](#listing14-10). I will use two ABCs to ensure the
    argument `sequence` has the interface my `product_of_thirds()` function expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-11: *product_of_thirds.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `product_of_thirds()` function expects the argument
    `sequence` to be a sequence, and thus an iterable—or else it wouldn’t work with
    the `for` loop—and its elements to support multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: I check for an expected interface using `isinstance()` to find out if the given
    object is an instance of a class or an instance of a subclass thereof. I ensure
    that `sequence` itself is derived from `collections.abc.Sequence`, meaning it
    implements the `__iter__()` instance method.
  prefs: []
  type: TYPE_NORMAL
- en: I also check the first element of the sequence to ensure it is derived from
    `numeric.Complex`, which implies (among other things) that it supports basic numeric
    operations, including multiplication. Although a string implements the special
    method `__mul__()`, it does *not* derive from `numeric.Complex`. It couldn’t reasonably
    do so, since it doesn’t support the rest of the expected mathematical operators
    and methods. Thus, it fails the test here, as it should.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving from ABCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ABCs are useful for identifying which classes implement a particular interface,
    so it’s beneficial to consider which ABCs your own classes should inherit from,
    especially when you are writing a library for other Python developers to use.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, I’ll rewrite my example from the end of Chapter 9 with
    custom iterable and iterator classes to use ABCs, thereby allowing the interface
    checking with `isinstance()`.
  prefs: []
  type: TYPE_NORMAL
- en: First, I need to import a few ABCs from the `collections.abc` module. I’ll explain
    why I’m importing these ABCs shortly, when I actually use them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-12: *cafe_queue_**abc**.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I’ll modify my `CafeQueue` class from the Chapter 9 example to use three
    abstract base classes that promise important components of the class’s functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-13: *cafe_queue_**abc**.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve made no changes to the implementation of this class, but I am now inheriting
    from three different ABCs, all of which come from the ``collections.abc module.
    I selected these particular ABCs based on the methods I’m implementing on the
    class. The `CafeQueue` class implements `__iter__()` to work with iteration, so
    I inherit from the ABC `Iterable`. The `Container` ABC requires `__contains__()`,
    which allows `CafeQueue` to work with the `in` operator. The `Sized` ABC requires
    `__len__()`, which means `CafeQueue` objects work with `len()`. The functionality
    is the same as it was in Chapter 9, but now, there is a reliable way of testing
    that this class supports iteration, `in`, and `len()`.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18] from collections.abc import **Collection**, Iterator [PRE19] class
    CafeQueue(**Collection**):      def __init__(self):         self._queue = []         self._orders
    = {}         self._togo = {}      def __iter__(self):         return CafeQueueIterator(self)      def
    __len__(self):         return len(self._queue)      def __contains__(self, customer):         return
    (customer in self._queue)      def add_customer(self, customer, *orders, to_go=True):         self._queue.append(customer)         self._orders[customer]
    = tuple(orders)         self._togo[customer] = to_go [PRE20] class CafeQueueIterator(**Iterator**):      def
    __init__(self, iterable):  self._iterable = iterable         self._position =
    0      def __next__(self):         if self._position >= len(self._iterable):             raise
    StopIteration          customer = self._iterable._queue[self._position]         orders
    = self._iterable._orders[customer]         togo = self._iterable._togo[customer]          self._position
    += 1          return (customer, orders, togo)      def __iter__(self):         return
    self [PRE21] def serve_customers(queue):   ❶ if not isinstance(queue, Collection):         raise
    TypeError("serve_next() requires a collection.")      if not len(queue):         print("Queue
    is empty.")         return      def brew(order):         print(f"(Making {order}...)")      for
    customer, orders, to_go in queue:         for order in orders: brew(order)         if
    to_go:             print(f"Order for {customer}!")         else:             print(f"(Takes
    order to {customer})")   queue = CafeQueue() queue.add_customer(''Raquel'', ''double
    macchiato'', to_go=False) queue.add_customer(''Naomi'', ''large mocha, skim'')
    queue.add_customer(''Anmol'', ''mango lassi'')  serve_customers(queue) [PRE22]
    (Making double macchiato...) (Takes order to Raquel) (Making large mocha, skim...)
    Order for Naomi! (Making mango lassi...) Order for Anmol! [PRE23] from collections.abc
    import Collection, Iterator **from abc import abstractmethod**   **class CustomerQueue(Collection):**   **@abstractmethod**  **def
    add_customer(self, customer): pass**   **@property**  **@abstractmethod**  **def
    first(self): pass** [PRE24] class CafeQueue(**CustomerQueue**):      def __init__(self):         self._queue
    = []         self._orders = {}         self._togo = {}      def __iter__(self):         return
    CafeQueueIterator(self)      def __len__(self):         return len(self._queue)      def
    __contains__(self, customer):         return (customer in self._queue)      def
    add_customer(self, customer, *orders, to_go=True):         self._queue.append(customer)         self._orders[customer]
    = tuple(orders)         self._togo[customer] = to_go   **@property**  **def first(self):**  **return
    self._queue[0]** [PRE25] TypeError: Can''t instantiate abstract class CafeQueue
    with abstract method first [PRE26] def serve_customers(queue):     if not isinstance(queue,
    **CustomerQueue**):         raise TypeError(**"serve_next() requires a customer
    queue."**)      if not len(queue):         print("Queue is empty.")         return      def
    brew(order):         print(f"(Making {order}...)")      for customer, orders,
    to_go in queue:         for order in orders: brew(order)         if to_go:             print(f"Order
    for {customer}!")         else:             print(f"(Takes order to {customer})")   queue
    = CafeQueue() queue.add_customer(''Raquel'', ''double macchiato'', to_go=False)
    queue.add_customer(''Naomi'', ''large mocha, skim'') queue.add_customer(''Anmol'',
    ''mango lassi'')  **print(f"The first person in line is {queue.first}.")** serve_customers(queue)
    [PRE27] The first person in line is Raquel. (Making double macchiato...) (Takes
    order to Raquel) (Making large mocha, skim...) Order for Naomi! (Making mango
    lassi...) Order for Anmol! [PRE28] from abc import ABC, abstractmethod   class
    Palindromable(ABC):      @abstractmethod     def __reversed__(self): pass      @abstractmethod     def
    __iter__(self): pass      @abstractmethod     def __str__(self): pass [PRE29]
    class LetterPalindrome(Palindromable):      def __init__(self, string):         self._raw
    = string         self._stripped = ''''.join(filter(str.isalpha, string.lower()))      def
    __str__(self):         return self._raw      def __iter__(self):         return
    self._stripped.__iter__()      def __reversed__(self):         return reversed(self._stripped)
    [PRE30] def check_palindrome(sequence):      if not isinstance(sequence, Palindromable):         raise
    TypeError("Cannot check for palindrome on that type.")      for c, r in zip(sequence,
    reversed(sequence)):         if c != r:  print(f"NON-PALINDROME: {sequence}")             return
    False     print(f"PALINDROME: {sequence}")     return True [PRE31] canal = LetterPalindrome("A
    man, a plan, a canal - Panama!") print(check_palindrome(canal))   # prints ''True''  bolton
    = LetterPalindrome("Bolton") print(check_palindrome(bolton))  # prints ′False''
    [PRE32] PALINDROME: A man, a plan, a canal - Panama! True NON-PALINDROME: Bolton
    False [PRE33] print(check_palindrome([1, 2, 3, 2, 1]))  # raises TypeError [PRE34]
    **Palindromable.register(list)** print(check_palindrome([1, 2, 3, 2, 1]))  # prints
    ''True'' [PRE35] **from collections.abc import Sequence  # This should be at the
    top of the file**  # `--snip--`  Palindromable.register(**Sequence**) print(check_palindrome([1,
    2, 3, 2, 1]))  # prints ''True'' [PRE36] from abc import ABC, abstractmethod from
    collections.abc import Sequence  class Palindromable(ABC):      @abstractmethod  def
    __reversed__(self): pass      @abstractmethod     def __iter__(self): pass      @abstractmethod     def
    __str__(self): pass      **@classmethod**  **def __subclasshook__(cls, C):**  **if
    issubclass(C, Sequence):**  **return True**  **return NotImplemented** [PRE37]
    print(check_palindrome([1, 2, 3, 2, 1]))               # prints ′True′ print(check_palindrome((1,
    2, 3, 2, 1)))               # prints ′True′  print(check_palindrome(''racecar''))                     #
    prints ''True'' print(check_palindrome(''race car''))                    # prints
    ''False'' print(check_palindrome(LetterPalindrome(''race car'')))  # prints ''True''  print(check_palindrome({1,
    2, 3, 2, 1}))               # raises TypeError [PRE38]`'
  prefs: []
  type: TYPE_NORMAL
