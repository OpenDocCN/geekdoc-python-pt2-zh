- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: LINEAR EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: Many engineering problems require resolving a system of linear equations. These
    equations arise in structural analysis, electric circuits, statistics, and optimization
    problems, just to name a few. Implementing algorithms to solve these ubiquitous
    systems of equations is key for our *Mechanics* project to deal with real-world
    engineering problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工程问题需要求解线性方程组。这些方程出现在结构分析、电路、统计和优化问题中，仅举几例。实现解决这些普遍存在的方程组的算法是我们 *力学* 项目应对现实工程问题的关键。
- en: 'In this chapter, we’ll explore the concept of *numerical methods*: existing
    algorithms that use computers to solve systems of equations. We’ll implement a
    powerful method to solve systems of linear equations: the Cholesky decomposition.
    We’ll use this method when we need to solve the big systems of equations from
    the structural analysis problems in [Part V](part05.xhtml#part05) of the book.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨 *数值方法* 的概念：使用计算机求解方程组的现有算法。我们将实现一种强大的方法来求解线性方程组：Cholesky 分解。当我们需要解决书中[第五部分](part05.xhtml#part05)中的结构分析问题中的大型方程组时，我们将使用这种方法。
- en: '**Systems of Linear Equations**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**线性方程组**'
- en: A linear equation with *n* unknowns *x*[1], *x*[2], …, *x*[*n*] can be expressed
    as shown in [Equation 14.1](ch14.xhtml#ch14eqa01).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 具有 *n* 个未知数 *x*[1]、*x*[2]、…、*x*[*n*] 的线性方程可以表示为[方程 14.1](ch14.xhtml#ch14eqa01)所示。
- en: '![Image](../images/14eqa01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/14eqa01.jpg)'
- en: Here, *m*[1], *m*[2], …, *m*[*n*] are the equation’s coefficients, known numbers
    that multiply each of the unknowns, and *b* is a known number that doesn’t multiply
    any unknown. We call this last number *b* the *free term*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*m*[1]、*m*[2]、…、*m*[*n*] 是方程的系数，即乘以每个未知数的已知数字，而 *b* 是一个已知数字，不与任何未知数相乘。我们将这个最后的数字
    *b* 称为 *自由项*。
- en: If the unknowns are only multiplied by a scalar, added, or subtracted, then
    we say the equation is *linear*. The coefficients are always known quantities.
    An alternative way of expressing a linear equation is shown here,
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未知数只是与标量相乘、相加或相减，则我们称该方程为 *线性* 方程。系数始终是已知量。另一种表示线性方程的方式如下，
- en: '![Image](../images/f0360-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0360-01.jpg)'
- en: where *m*[*i*] is the coefficients, *x*[*i*] is the unknowns, and *b* is the
    free term.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *m*[*i*] 是系数，*x*[*i*] 是未知数，*b* 是自由项。
- en: By contrast, a nonlinear equation includes things like unknowns with an exponent
    (*x*³), trigonometric functions (sin(*x*)), or the product of several unknowns
    (*x*[1] ⋅ *x*[2]). These equations are considerably harder to solve than linear
    ones, so we’ll stay focused on linear equations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，非线性方程包括未知数带有指数（*x*³）、三角函数（sin(*x*)）或多个未知数的乘积（*x*[1] ⋅ *x*[2]）。这些方程比线性方程更难求解，因此我们将专注于线性方程。
- en: A system of linear equations has the form shown in [Equation 14.2](ch14.xhtml#ch14eqa02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程组的形式如[方程 14.2](ch14.xhtml#ch14eqa02)所示。
- en: '![Image](../images/14eqa02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/14eqa02.jpg)'
- en: Here, a coefficient *m*[*i,j*] is the term that multiplies the *j*^(*th*) unknown
    in the *i*^(*th*) equation. These systems can be conveniently expressed in their
    matrix form as shown in [Equation 14.3](ch14.xhtml#ch14eqa03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，系数 *m*[*i,j*] 是乘以第 *i* 个方程中第 *j* 个未知数的项。这些方程组可以方便地表示为矩阵形式，如[方程 14.3](ch14.xhtml#ch14eqa03)所示。
- en: '![Image](../images/14eqa03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/14eqa03.jpg)'
- en: Here, [*M*] is the matrix of coefficients,
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，[*M*] 是系数矩阵，
- en: '![Image](../images/f0360-02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0360-02.jpg)'
- en: 'and [*x*] and [*b*] are the unknown and the free-term column vectors:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 [*x*] 和 [*b*] 是未知数和自由项列向量：
- en: '![Image](../images/f0360-03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0360-03.jpg)'
- en: 'A solution for [Equation 14.3](ch14.xhtml#ch14eqa03) is a set of numbers *x*[1],
    *x*[2], …, *x*[*n*] that satisfies all *n* equations. Finding solutions for big
    systems of equations by hand can take a long time, but don’t worry: there are
    plenty of algorithms for solving systems like this using a computer.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[方程 14.3](ch14.xhtml#ch14eqa03)的解是一个由数字 *x*[1]、*x*[2]、…、*x*[*n*] 组成的集合，满足所有
    *n* 个方程。手动求解大型方程组可能需要很长时间，但不用担心：有很多算法可以用计算机求解这样的方程组。'
- en: 'A quick note on nomenclature. We’ll use uppercase letters inside square brackets
    to denote matrices: [*M*]. The items in a matrix will be named using the same
    letter used for the matrix but lowercase. Items will include as a subscript two
    comma-separated numbers, which are the row and column indices of their position
    inside the matrix. For example, the number in row 3 and column 5 of the matrix
    [*M*] will be referred to as *m*[3, 5]. Column and row vectors are denoted as
    lowercase letters inside square brackets: [*x*]. Remember that column and row
    vectors are also matrices.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名法的简要说明。我们将在方括号内使用大写字母表示矩阵：[*M*]。矩阵中的元素将使用与矩阵相同字母的小写形式命名，并且在下标中包含两个用逗号分隔的数字，表示它们在矩阵中的行列索引。例如，矩阵[*M*]中第3行第5列的数字将被称为*m*[3,
    5]。列向量和行向量用方括号内的小写字母表示：[*x*]。请记住，列向量和行向量也是矩阵。
- en: '**Numerical Methods**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数值方法**'
- en: '*Numerical methods* are algorithms that find an approximate solution for a
    system of equations using the computational power of a computer.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值方法*是使用计算机的计算能力找到方程组近似解的算法。'
- en: There are numerical methods designed to solve systems of linear, nonlinear,
    and differential systems of equations. Most numerical methods, nevertheless, are
    limited to solving specific types of systems. For instance, the Cholesky decomposition
    works only with linear systems whose coefficient matrix is symmetric and positive
    definite (we’ll see what this means in a bit). If we need to solve a nonlinear
    system of equations, or even one that is linear but with a nonsymmetric coefficient
    matrix, Cholesky decomposition simply won’t work.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数值方法旨在求解线性、非线性和微分方程系统。然而，大多数数值方法仅限于求解特定类型的方程组。例如，Cholesky分解仅适用于系数矩阵是对称且正定的线性方程组（稍后我们将了解这意味着什么）。如果我们需要求解一个非线性方程组，或者一个线性但系数矩阵非对称的方程组，Cholesky分解将无法使用。
- en: 'There are two big families of numerical methods: *direct* and *iterative*.
    Direct methods use algebraic modifications on the original system to solve it.
    Iterative methods, on the other hand, start with an approximate solution for the
    system and improve it step-by-step until the solution has the desired accuracy.
    The Cholesky decomposition is a direct numerical method.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法有两大类：*直接法*和*迭代法*。直接法通过对原始系统进行代数修改来求解系统。另一方面，迭代法从方程组的近似解开始，通过逐步改进，直到解达到所需的精度为止。Cholesky分解是一种直接数值方法。
- en: 'Numerical methods are a big topic: entire books have been written about it.
    There are many technical details about numerical methods that we won’t be covering
    here. But this isn’t a theory book; we’re much more interested in the practice,
    so we’ll implement an algorithm that solves the kinds of systems of equations
    that’ll arise in the structural analysis application we’ll create in the next
    part of the book. In this case, that means we’ll be working with linear systems
    with symmetric, positive-definite coefficient matrices.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法是一个庞大的主题：已有专门的书籍讨论它。数值方法涉及许多技术细节，我们这里不会一一介绍。但这不是一本理论书籍；我们更关心实践，因此我们将实现一个算法，用于求解在接下来的结构分析应用中可能出现的方程组。在这种情况下，这意味着我们将处理具有对称、正定系数矩阵的线性方程组。
- en: '**Cholesky Decomposition**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Cholesky分解**'
- en: The *Cholesky decomposition* is a direct (noniterative) method that solves linear
    systems of equations provided their [*M*] (the coefficient matrix) is *symmetric*
    and *positive definite*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cholesky分解*是一种直接（非迭代）方法，用于求解线性方程组，前提是它们的[*M*]（系数矩阵）是*对称*和*正定*的。'
- en: 'A symmetric matrix [*M*] is one that is equal to its transpose: [*M*] = [*M*]^′.
    That is the same as saying that the values in the matrix are symmetric with respect
    to the main diagonal. In a symmetric matrix, every row contains the same values
    as the column with the same index, and vice versa. Note that to be symmetric,
    a matrix needs to be square. The following is an example of a symmetric matrix:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对称矩阵[*M*]是指其等于其转置矩阵：[*M*] = [*M*]^′。这意味着矩阵中的数值相对于主对角线是对称的。在对称矩阵中，每一行包含与同一索引的列相同的值，反之亦然。注意，要成为对称矩阵，矩阵必须是方阵。以下是一个对称矩阵的例子：
- en: '![Image](../images/f0361-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0361-01.jpg)'
- en: A square matrix [*M*] with *n* rows and columns is *positive definite* if for
    any column vector [*x*] made of *n* real numbers (with the exception of a vector
    filled with zeros), the expression in [Equation 14.4](ch14.xhtml#ch14eqa04) is
    satisfied.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有 *n* 行和列的方阵 [*M*] 被称为 *正定矩阵*，如果对于任何由 *n* 个实数（除了一个全零向量）构成的列向量 [*x*]，[方程 14.4](ch14.xhtml#ch14eqa04)
    中的表达式成立。
- en: '![Image](../images/14eqa04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa04.jpg)'
- en: If you find a nonzero vector [*x*] that doesn’t satisfy the previous equation,
    then the matrix [*M*] is not positive definite.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到一个不满足上述方程的非零向量 [*x*]，那么矩阵 [*M*] 就不是正定的。
- en: We can also say that a matrix is positive definite if it’s symmetric and all
    its eigenvalues are positive. If you remember the process of obtaining the eigenvalues
    of a matrix, you might agree that it’s painful and a bit boring. In either case,
    proving that [*x*]^′[*M*][*x*] > 0 for every possible [*x*] or obtaining all eigenvalues
    of the matrix and making sure all are positive is an involved process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以说，如果一个矩阵是对称的，并且它的所有特征值都是正的，那么它是正定的。如果你记得获得矩阵特征值的过程，你可能会同意这既痛苦又有点无聊。无论如何，证明对于每个可能的
    [*x*]，[*x*]^′[*M*][*x*] > 0，或者获得矩阵的所有特征值并确保它们都为正，都是一个复杂的过程。
- en: 'We are going to skip all that technical complexity and won’t be demonstrating
    that the matrices we’ll work with are positive definite. We’ll apply the Cholesky
    factorization to a problem that is well-known for yielding systems of equations
    with a symmetric and positive-definite matrix: truss structure analysis using
    the direct stiffness method. If you ever need to apply this algorithm to any another
    problem, you’ll first need to figure out whether the system of equations derived
    for it has a matrix that Cholesky can work with. If it’s not the case, don’t worry:
    there are plenty of other numerical methods that you can use.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过所有这些技术复杂性，不会演示我们将使用的矩阵是正定的。我们将应用 Cholesky 分解来解决一个众所周知的问题，该问题会产生一个对称正定矩阵的方程组：使用直接刚度法进行的桁架结构分析。如果你需要将这个算法应用到其他问题中，你首先需要确定为该问题导出的方程组是否具有
    Cholesky 可以处理的矩阵。如果不是，也不用担心：你可以使用很多其他数值方法。
- en: After we implement Cholesky’s algorithm together, I hope you feel empowered
    to implement any other numerical method on your own. As you’ll see, the most powerful
    resource we have at our disposal to make sure we get these tricky algorithms right
    is unit testing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一起实现 Cholesky 算法后，希望你能够自己实现其他数值方法。正如你所看到的，确保我们正确处理这些复杂算法的最强大工具就是单元测试。
- en: '***LU Factorization Methods***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LU 分解方法***'
- en: Cholesky is a computation method from the family of so-called *LU* factorization
    or decomposition methods. An *LU* factorization of a given square matrix [*M*]
    has the form shown in [Equation 14.5](ch14.xhtml#ch14eqa05).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Cholesky 是属于所谓 *LU* 分解或分解方法家族中的一种计算方法。给定方阵 [*M*] 的 *LU* 分解形式如 [方程 14.5](ch14.xhtml#ch14eqa05)
    所示。
- en: '![Image](../images/14eqa05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa05.jpg)'
- en: 'Here, [*L*] is a *lower-triangular matrix*, and [*U*] is an *upper-triangular
    matrix*. A lower-triangular matrix is one where all nonzero values are on and
    below the main diagonal. Conversely, an upper-triangular matrix has the nonzero
    values on and above the main diagonal. Here’s an example of a lower-and an upper-triangular
    matrix:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，[*L*] 是一个 *下三角矩阵*，而 [*U*] 是一个 *上三角矩阵*。下三角矩阵是指所有非零值都位于主对角线及其下方。相反，上三角矩阵的非零值位于主对角线及其上方。以下是一个下三角矩阵和上三角矩阵的示例：
- en: '![Image](../images/f0362-01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0362-01.jpg)'
- en: Every *nonsingular matrix* (a matrix that has an inverse) always has an *LU*
    factorization. For example, the matrices from the previous example are the *LU*
    factorization for the matrix
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *非奇异矩阵*（具有逆矩阵的矩阵）总是可以进行 *LU* 分解。例如，前面的矩阵就是该矩阵的 *LU* 分解：
- en: '![Image](../images/f00363-p1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00363-p1.jpg)'
- en: 'which you can verify by multiplying the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过乘以以下内容来验证这一点：
- en: '![Image](../images/f00363-p2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00363-p2.jpg)'
- en: 'The Cholesky algorithm will provide us with a lower-and an upper-triangular
    matrix. Besides Cholesky, there are two well-known methods for obtaining the factorization
    of any nonsingular matrix: the Doolittle and Crout algorithms. These algorithms
    define the formulas necessary to compute the *l*[*i,j*] and *u*[*i,j*] values
    for the lower- and upper-triangular matrices. The benefit of these methods is
    that they work for any kind of matrix, not just symmetric, positive-definite matrices.
    We won’t be covering them here, but I encourage you to take a look and try to
    implement one of them yourself in our *Mechanics* project. You may want to try
    that as an exercise after we’ve implemented Cholesky’s algorithm.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Cholesky算法将为我们提供一个下三角矩阵和一个上三角矩阵。除了Cholesky之外，还有两种著名的方法可以用于获得任何非奇异矩阵的分解：Doolittle算法和Crout算法。这些算法定义了计算下三角矩阵和上三角矩阵的*l*[*i,j*]和*u*[*i,j*]值所需的公式。这些方法的好处是它们适用于任何类型的矩阵，而不仅仅是对称正定矩阵。我们在这里不讨论这些方法，但我鼓励你了解它们，并尝试在我们的*力学*项目中自己实现其中之一。你可以在我们实现Cholesky算法之后，把它作为练习来尝试。
- en: It’s fair to ask, why not use the Doolittle or Crout algorithms that work with
    every nonsingular matrix instead of the more restrictive Cholesky? For symmetric
    and positive-definite matrices, Cholesky’s decomposition is about twice as fast
    as these other algorithms. Since we’ll use the method with the type of matrices
    required, we’ll want to benefit from the execution speed offered by Cholesky’s
    method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得问一下，为什么不使用可以处理任何非奇异矩阵的Doolittle或Crout算法，而非使用更具限制性的Cholesky算法呢？对于对称正定矩阵，Cholesky分解的速度大约是这些其他算法的两倍。由于我们将使用适用此方法的矩阵类型，我们希望能够从Cholesky方法所提供的执行速度中获益。
- en: 'Once we obtain the *LU* factorization for the matrix, we can solve our system
    of equations in two steps. Suppose our original system was as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了矩阵的*LU*分解，我们就可以通过两步解决方程组。假设我们的原始系统如下：
- en: '[*M*][*x*] = [*b*]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[*M*][*x*] = [*b*]'
- en: After factorizing [*M*], we have [Equation 14.6](ch14.xhtml#ch14eqa06).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在对[*M*]进行分解后，我们得到了[方程 14.6](ch14.xhtml#ch14eqa06)。
- en: '![Image](../images/14eqa06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa06.jpg)'
- en: 'We can extract two systems from [Equation 14.6](ch14.xhtml#ch14eqa06) if we
    take the product [*U*][*x*] and substitute it with a new unknown vector [*y*]:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取[*U*][*x*]的乘积并用一个新的未知向量[*y*]代替它，就可以从[方程 14.6](ch14.xhtml#ch14eqa06)中提取出两个系统：
- en: '![Image](../images/f0363-02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0363-02.jpg)'
- en: We now have a lower-triangular matrix system, as shown in [Equation 14.7](ch14.xhtml#ch14eqa07),
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个下三角矩阵系统，如[方程 14.7](ch14.xhtml#ch14eqa07)所示，
- en: '![Image](../images/14eqa07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa07.jpg)'
- en: and an upper-triangular matrix system, as shown in [Equation 14.8](ch14.xhtml#ch14eqa08).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有一个上三角矩阵系统，如[方程 14.8](ch14.xhtml#ch14eqa08)所示。
- en: '![Image](../images/14eqa08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa08.jpg)'
- en: 'By first solving [Equation 14.7](ch14.xhtml#ch14eqa07), we find [*y*], which
    plugged into [Equation 14.8](ch14.xhtml#ch14eqa08) allows us to compute the unknown
    vector [*x*]: the system’s solution. Both [Equation 14.7](ch14.xhtml#ch14eqa07)
    and [Equation 14.8](ch14.xhtml#ch14eqa08) are systems with a triangular matrix,
    and they can be easily solved by forward and backward substitution.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先求解[方程 14.7](ch14.xhtml#ch14eqa07)，我们得到[*y*]，然后将其代入[方程 14.8](ch14.xhtml#ch14eqa08)，可以计算出未知向量[*x*]：即系统的解。
    [方程 14.7](ch14.xhtml#ch14eqa07)和[方程 14.8](ch14.xhtml#ch14eqa08)都是具有三角矩阵的方程组，且可以通过前向和后向替代法轻松求解。
- en: 'Take this system of equations whose coefficient matrix is lower triangular:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 取这个系数矩阵是下三角矩阵的方程组：
- en: '![Image](../images/f00364-p1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00364-p1.jpg)'
- en: 'The first unknown *y*[1] can be computed from the first equation as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个未知数*y*[1]可以通过以下方式从第一个方程计算得出：
- en: '![Image](../images/f0364-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0364-01.jpg)'
- en: From the second equation we have the following,
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二个方程我们得到了以下内容，
- en: '![Image](../images/f0364-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0364-02.jpg)'
- en: 'which can be solved, as we already computed the value for *y*[1] in the previous
    step. We do the same for the third equation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统可以求解，因为我们已经在前一步计算出了*y*[1]的值。我们对第三个方程做同样的处理：
- en: '![Image](../images/f0364-03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0364-03.jpg)'
- en: We have the values for *y*[1] and *y*[2], so the value for *y*[3] can be computed.
    This process is known as *forward substitution*. A formula to obtain the *y*^(*ith*)
    solution term using forward substitution is shown in [Equation 14.9](ch14.xhtml#ch14eqa09)
    (using zero-based indices).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了*y*[1]和*y*[2]的值，因此可以计算出*y*[3]的值。这个过程称为*前向替代*。使用前向替代法得到*y*^(*第i项*)解的公式见于[方程
    14.9](ch14.xhtml#ch14eqa09)（采用零基索引）。
- en: '![Image](../images/14eqa09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa09.jpg)'
- en: 'In a system whose coefficient matrix is upper triangular, we can use a similar
    substitution process, but starting from the bottom this time. The process is called
    *backward substitution*. This time we have the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个系数矩阵为上三角矩阵的系统中，我们可以使用类似的替代过程，但这次从底部开始。这个过程叫做*逆向替代*。这时我们得到：
- en: '![Image](../images/f0364-04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0364-04.jpg)'
- en: 'Starting from the last equation, we can compute *x*[3]:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一个方程开始，我们可以计算*x*[3]：
- en: '![Image](../images/f0364-05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0364-05.jpg)'
- en: 'With this value we can move to the second equation to obtain *x*[2]:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个值，我们可以进入第二个方程，计算*x*[2]：
- en: '![Image](../images/f0365-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0365-01.jpg)'
- en: 'Lastly, from the first equation in the system, we have this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从系统中的第一个方程我们得到：
- en: '![Image](../images/f0365-02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0365-02.jpg)'
- en: For the backward substitution, the formula to compute the *x*^(*ith*) term is
    described by [Equation 14.10](ch14.xhtml#ch14eqa10), with *n* being the size of
    the system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逆向替代，计算*x*^(*ith*)项的公式由[公式14.10](ch14.xhtml#ch14eqa10)描述，其中*n*是系统的大小。
- en: '![Image](../images/14eqa10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa10.jpg)'
- en: We’ll need to implement these formulas in our code soon. You’ll see that it’s
    actually simpler than it looks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就需要在代码中实现这些公式。你会发现它比看起来简单。
- en: '***Understanding Cholesky***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解Cholesky***'
- en: 'As we discussed, the Cholesky decomposition is an *LU* method that works with
    symmetric, positive-definite matrices. Thanks to those properties, a matrix [*M*]
    can be decomposed into an [*L*][*U*] form where the upper-triangular matrix is
    the transpose of the lower-triangular one: [*U*] = [*L*]^′. This means we only
    need to compute the lower-triangular matrix [*L*]: [*U*] is just its transpose.
    Using the Cholesky method, the [*M*] matrix factorization has the form shown in
    [Equation 14.11](ch14.xhtml#ch14eqa11).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的，Cholesky分解是一种与对称正定矩阵配合使用的*LU*方法。由于这些特性，矩阵[*M*]可以分解成[*L*][*U*]形式，其中上三角矩阵是下三角矩阵的转置：[*U*]
    = [*L*]^′。这意味着我们只需要计算下三角矩阵[*L*]：[*U*]只是其转置。使用Cholesky方法，[*M*]矩阵的分解形式如[公式14.11](ch14.xhtml#ch14eqa11)所示。
- en: '![Image](../images/14eqa11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa11.jpg)'
- en: So, the system of equations now looks like [Equation 14.12](ch14.xhtml#ch14eqa12).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，方程组现在看起来像[公式14.12](ch14.xhtml#ch14eqa12)。
- en: '![Image](../images/14eqa12.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa12.jpg)'
- en: 'In this case, we obtain the two systems we need to solve by substituting [*L*]^′[*x*]
    with [*y*]:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过将[*L*]^′[*x*]替换为[*y*]，得到我们需要求解的两个方程组：
- en: '![Image](../images/f00365-p1.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00365-p1.jpg)'
- en: As we already know, this transformation yields a lower system, which we’ll solve
    first using forward substitution (see [Equation 14.13](ch14.xhtml#ch14eqa13)),
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已经知道的，这个变换会产生一个下三角系统，我们将首先使用前向替代法来求解（见[公式14.13](ch14.xhtml#ch14eqa13)），
- en: '![Image](../images/14eqa13.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa13.jpg)'
- en: and then using an upper system that we’ll solve by backward substitution to
    obtain the solution vector [*x*] (see [Equation 14.14](ch14.xhtml#ch14eqa14)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用一个上三角系统，通过逆向替代法求解，得到解向量[*x*]（见[公式14.14](ch14.xhtml#ch14eqa14)）。
- en: '![Image](../images/14eqa14.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa14.jpg)'
- en: Given a symmetric, positive-definite matrix [*M*], we can compute the lower-triangular
    matrix terms of its Cholesky decomposition, the *l*[*i,j*] terms, using the formulas
    in [Equation 14.15](ch14.xhtml#ch14eqa15).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个对称正定矩阵[*M*]，我们可以使用[公式14.15](ch14.xhtml#ch14eqa15)中的公式计算其Cholesky分解的下三角矩阵项，即*l*[*i,j*]项。
- en: '![Image](../images/14eqa15.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa15.jpg)'
- en: '[Equation 14.15](ch14.xhtml#ch14eqa15) may look intimidating, but it’s actually
    not that complicated. The best way to see this is by doing an exercise by hand.
    Grab a pen and some paper and let’s factor a matrix together.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[公式14.15](ch14.xhtml#ch14eqa15)可能看起来令人畏惧，但实际上并没有那么复杂。最好的理解方式是通过手动做一个练习。拿起一支笔和一些纸，我们一起进行矩阵分解。'
- en: '***A Factorization by Hand***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***手动因式分解***'
- en: Given the symmetric and positive-definite matrix
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 给定对称正定矩阵
- en: '![Image](../images/f0366-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0366-01.jpg)'
- en: let’s find its Cholesky factorization, a lower-triangular matrix [*L*],
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到它的Cholesky分解，一个下三角矩阵[*L*]，
- en: '![Image](../images/f0366-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0366-02.jpg)'
- en: such that [*M*] = [*L*][*L*]^′. To compute the *l*[*i,j*] terms, we use [Equation
    14.15](ch14.xhtml#ch14eqa15). Don’t forget that index *i* represents the rows
    of the matrix, and *j* represents its columns. Let’s do it step-by-step.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使得[*M*] = [*L*][*L*]^′。为了计算*l*[*i,j*]项，我们使用[公式14.15](ch14.xhtml#ch14eqa15)。别忘了，索引*i*表示矩阵的行，*j*表示矩阵的列。我们一步一步来。
- en: '**Step 1:** *i* = 0,*j* = 0\. Since *i* = *j*, we use the first formula:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：** *i* = 0，*j* = 0。由于 *i* = *j*，我们使用第一个公式：'
- en: '![Image](../images/f0366-03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0366-03.jpg)'
- en: Note that the summation is struck through because it doesn’t yield any term.
    This is because the summation’s end value *k* = –1 is smaller than the start one
    *k* = 0\. As you probably know, for the summation to yield any term, the end value
    for *k* (the iterating variable) needs to be equal to or greater than the start
    value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，求和符号被划掉了，因为它没有产生任何项。这是因为求和的结束值 *k* = –1 小于开始值 *k* = 0。如你所知，为了让求和产生任何项，*k*（迭代变量）的结束值必须等于或大于开始值。
- en: '**Step 2:** *i* = 1,*j* = 0\. In this case, *i*≠*j*, so we use the second formula:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：** *i* = 1，*j* = 0。此时，*i*≠*j*，所以我们使用第二个公式：'
- en: '![Image](../images/f0366-04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0366-04.jpg)'
- en: '**Step 3:** *i* = 1,*j* = 1.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：** *i* = 1，*j* = 1。'
- en: '![Image](../images/f0367-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-01.jpg)'
- en: '**Step 4:** *i* = 2,*j* = 0.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4：** *i* = 2，*j* = 0。'
- en: '![Image](../images/f0367-02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-02.jpg)'
- en: '**Step 5:** *i* = 2,*j* = 1.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5：** *i* = 2，*j* = 1。'
- en: '![Image](../images/f0367-03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-03.jpg)'
- en: '**Step 6:** *i* = 2,*j* = 2.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 6：** *i* = 2，*j* = 2。'
- en: '![Image](../images/f0367-04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-04.jpg)'
- en: 'If we combine all the computed *l*[*i,j*] values, the resulting matrix is as
    follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有计算出的 *l*[*i,j*] 值合并，得到的矩阵如下：
- en: '![Image](../images/f0367-05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-05.jpg)'
- en: 'This means that the original system’s matrix [*M*] can be factorized as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着原始系统的矩阵 [*M*] 可以如下因式分解：
- en: '![Image](../images/f0367-06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-06.jpg)'
- en: You can do the matrix multiplication to verify that the product [*L*][*L*]^′
    is actually equal to [*M*]. To complete the exercise, let’s suppose this matrix
    is the coefficient matrix of a system of equations and solve it using the forward
    and backward substitutions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行矩阵乘法验证，*L*[*L*]^′ 的积实际上等于 *M*。为了完成这个练习，假设这个矩阵是一个方程组的系数矩阵，并使用前向和后向替代法来求解它。
- en: '***A Resolution by Hand***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***手动解法***'
- en: 'Let’s suppose the matrix we decomposed earlier into its [*L*][*L*]^′ form is
    part of the following system of equations:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们之前分解的矩阵 [*L*][*L*]^′ 形式是以下方程组的一部分：
- en: '![Image](../images/f0367-07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0367-07.jpg)'
- en: 'We need to find the values of *x*[1], *x*[2], and *x*[3] that satisfy all three
    equations. Using the Cholesky factorization we just obtained, we can rewrite the
    system as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到满足所有三个方程的 *x*[1]、*x*[2] 和 *x*[3] 的值。使用我们刚刚获得的 Cholesky 分解，我们可以将系统重写为如下形式：
- en: '![Image](../images/f0368-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0368-01.jpg)'
- en: 'The first of the two subsystems we have to solve, [*L*][*y*] = [*b*], results
    from substituting [*L*]^′[*x*] with a new unknown vector [*y*]:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解的两个子系统中的第一个是 [*L*][*y*] = [*b*]，这是通过将 [*L*]^′[*x*] 替换为新的未知向量 [*y*] 得到的：
- en: '![Image](../images/f0368-02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0368-02.jpg)'
- en: 'This results in the first system (the lower system):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就得到了第一个系统（下系统）：
- en: '![Image](../images/f0368-03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0368-03.jpg)'
- en: We have to solve this system using the forward-substitution formula from [Equation
    14.9](ch14.xhtml#ch14eqa09).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 [方程 14.9](ch14.xhtml#ch14eqa09) 中的前向替代公式来求解这个系统。
- en: '**Lower System: Forward Substitution**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**下系统：前向替代**'
- en: 'Let’s apply [Equation 14.9](ch14.xhtml#ch14eqa09) step-by-step:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步应用 [方程 14.9](ch14.xhtml#ch14eqa09)：
- en: '**Step 1:** *i* = 0.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：** *i* = 0。'
- en: '![Image](../images/f0368-04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0368-04.jpg)'
- en: '**Step 2:** *i* = 1.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：** *i* = 1。'
- en: '![Image](../images/f0368-05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0368-05.jpg)'
- en: '**Step 3:** *i* = 2.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：** *i* = 2。'
- en: '![Image](../images/f0368-06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0368-06.jpg)'
- en: 'Thus, the solution for the first system is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个系统的解如下：
- en: '![Image](../images/f0369-01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-01.jpg)'
- en: 'With this solution, we can use backward substitution to compute [*x*]: the
    solution to our system of equations.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个解，我们可以使用后向替代法计算 [*x*]：即我们的方程组的解。
- en: '**Upper System: Backward Substitution**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**上系统：后向替代**'
- en: 'Let’s use [Equation 14.10](ch14.xhtml#ch14eqa10) to compute the solution vector
    step-by-step. This time we have to solve the following system using the backward-substitution
    process:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 [方程 14.10](ch14.xhtml#ch14eqa10) 逐步计算解向量。这一次，我们需要使用后向替代法来求解以下方程组：
- en: '![Image](../images/f0369-02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-02.jpg)'
- en: Since the substitution is backward, we have to start from the last row (*i*
    = 2) and go up to the first one (*i* = 0).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于替代过程是反向的，我们必须从最后一行（*i* = 2）开始，一直到第一行（*i* = 0）。
- en: '**Step 1:** *i* = 2.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：** *i* = 2。'
- en: '![Image](../images/f0369-03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-03.jpg)'
- en: '**Step 2:** *i* = 1.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：** *i* = 1。'
- en: '![Image](../images/f0369-04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-04.jpg)'
- en: '**Step 3:** *i* = 0.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：** *i* = 0。'
- en: '![Image](../images/f0369-05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-05.jpg)'
- en: 'Then, the solution to the initial system is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，初始系统的解如下：
- en: '![Image](../images/f0369-06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-06.jpg)'
- en: 'You can test if the solution is correct by checking if the equality holds:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查等式是否成立来测试解是否正确：
- en: '![Image](../images/f0369-07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0369-07.jpg)'
- en: Now that we know how the Cholesky algorithm works and we’ve worked out an example
    by hand, let’s implement the algorithm in our code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Cholesky算法的工作原理，并且已经通过手算做了一个示例，让我们在代码中实现这个算法。
- en: '***Implementing Cholesky***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现Cholesky***'
- en: Start by creating a new file in the *eqs* package named *cholesky.py*. In it,
    include the cholesky_solve function in [Listing 14-1](ch14.xhtml#ch14lis1).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在*eqs*包中创建一个名为*cholesky.py*的新文件。在该文件中，包含[清单 14-1](ch14.xhtml#ch14lis1)中的cholesky_solve函数。
- en: '[PRE0]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 14-1: Cholesky decomposition algorithm*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-1：Cholesky分解算法*'
- en: 'This function takes a Matrix and a Vector as inputs. These are the coefficient
    matrix and free vector of a system: the [*M*] and the [*b*] from the system of
    equations [*M*][*x*] = [*b*]. The returned Vector is [*x*], the solution to the
    system found applying Cholesky’s method.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受矩阵和向量作为输入。这些是系统的系数矩阵和自由向量：来自方程组[*M*][*x*] = [*b*]中的[*M*]和[*b*]。返回的向量是[*x*]，即通过Cholesky方法求得的系统解。
- en: 'This cholesky_solve function defines the highest-level algorithm, which has
    three main steps plus a validation of the input system. We haven’t implemented
    any of these functions yet; we’ll get to this shortly. The following are the three
    main steps to the algorithm:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个cholesky_solve函数定义了最高层的算法，包含三个主要步骤和一个输入系统的验证。我们还没有实现这些函数；我们稍后会实现。以下是算法的三个主要步骤：
- en: lower_matrix_decomposition Obtain [*L*], the lower-triangular matrix, by applying
    [Equation 14.15](ch14.xhtml#ch14eqa15).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: lower_matrix_decomposition 通过应用[方程 14.15](ch14.xhtml#ch14eqa15)获得[*L*]，即下三角矩阵。
- en: solve_lower_sys Solve the first subsystem, the lower-triangular system, by applying
    the forward-substitution technique (see [Equation 14.9](ch14.xhtml#ch14eqa09)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: solve_lower_sys 通过应用前向代入法（见[方程 14.9](ch14.xhtml#ch14eqa09)）解第一个子系统，即下三角系统。
- en: solve_upper_sys Solve the second subsystem, the upper-triangular system, by
    applying the backward-substitution technique (see [Equation 14.10](ch14.xhtml#ch14eqa10)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: solve_upper_sys 通过应用回代法（见[方程 14.10](ch14.xhtml#ch14eqa10)）解第二个子系统，即上三角系统。
- en: From the function names, it’s easy enough to see what the code in cholesky _solve
    is doing. Note that we broke the function into several smaller functions. If we
    had thrown all the code for the Cholesky resolution into the cholesky_solve function,
    the result would be a long pile of source code with no readily identifiable structure.
    This code would be extremely hard to understand.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数名称来看，很容易看出cholesky_solve中的代码在做什么。请注意，我们将函数拆分成了几个较小的函数。如果我们把所有用于Cholesky分解的代码都丢进cholesky_solve函数中，结果将是一个没有明显结构的长代码块。这段代码将非常难以理解。
- en: As a general rule, you want to divide your big algorithms into smaller subalgorithms,
    each contained in a small function with a descriptive name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你需要将大的算法分解成较小的子算法，每个子算法都包含在一个具有描述性名称的小函数中。
- en: Notice the visibility of the subfunctions used by cholesky_solve. All the subfunctions
    are public. This is so that they can be unit tested individually. The resolution
    algorithm is a bit complex; we’re safer if we know that each of its subparts does
    its job without errors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意cholesky_solve使用的子函数的可见性。所有子函数都是公开的。这是为了能够单独对它们进行单元测试。分解算法稍显复杂，如果我们知道每个子部分都能正确执行其功能，处理起来会更安全。
- en: '**Validating the System**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证系统**'
- en: Let’s implement a function that validates that the system is square and has
    a number of columns equal to the size of the vector. Enter the code for the validate_system
    function, found in [Listing 14-2](ch14.xhtml#ch14lis2).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个函数，验证系统是否是方阵，并且列数是否等于向量的大小。输入[清单 14-2](ch14.xhtml#ch14lis2)中的validate_system函数代码。
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-2: System validation*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-2：系统验证*'
- en: We first check that the matrix has the same number columns as the vector’s length.
    If this condition isn’t satisfied, the system can’t be solved, so we raise an
    error. The same applies if the system’s matrix is not square.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查矩阵的列数是否与向量的长度相同。如果这个条件不满足，系统就无法解，因此我们会抛出一个错误。如果系统的矩阵不是方阵，情况也是如此。
- en: We’re not doing any check to ensure the matrix is symmetric or positive definite;
    if the matrix passed to our function isn’t, the function will simply fail at some
    point with a by-zero division error or something similar. It’d be a nice idea
    to add those guards, at least the check for symmetry, but checking that the system’s
    matrix is positive definite may be more challenging. The symmetry check is easy
    to implement, but it has the downside of being computationally expensive. I encourage
    you to think about ways of doing these checks and maybe add them in your code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有检查矩阵是否对称或正定；如果传递给我们函数的矩阵不满足这些条件，函数最终会因为除零错误或类似问题而失败。添加这些保护措施是一个不错的主意，至少要检查对称性，但检查矩阵是否正定可能会更具挑战性。对称性检查容易实现，但缺点是计算开销大。我鼓励你考虑如何进行这些检查，并可能将它们添加到你的代码中。
- en: 'Now we’re going to do something a little backward. We’re going to start with
    a unit test instead of the code itself. This is so that we know when our code
    is ready: once the tests pass. We can keep running the test to check whether the
    logic we’re writing is ready or not; we can refactor it until it looks readable,
    with the safety net of the test that will warn us if we did something wrong. This
    technique where the test is written before the code is known as *test-driven development*,
    or TDD for short.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做点反向操作。我们将从单元测试开始，而不是直接从代码本身开始。这样我们就能知道何时代码准备好：一旦测试通过。我们可以不断运行测试来检查我们编写的逻辑是否已经准备好；我们可以重构代码，直到它变得可读，并且有测试的安全网，当我们做错了什么时，测试会警告我们。这种在编写代码之前编写测试的技术称为*测试驱动开发*，简称TDD。
- en: We’ll start by looking at the system of equations we’ll use in the unit tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看我们将在单元测试中使用的方程组。
- en: '**System of Equations for Testing**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试用方程组**'
- en: To make sure we implement all the logic without bugs, we’re going to use tests
    for each of the subfunctions in the Cholesky algorithm. We’ll also implement a
    test to check that all the subfunctions work together to compute the final solution.
    For these tests we want to use a system of equations whose solution we know in
    advance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们实现的所有逻辑没有错误，我们将为Cholesky算法中的每个子函数编写测试。我们还将实现一个测试，检查所有子函数是否能够协同工作以计算最终解。对于这些测试，我们希望使用一个我们事先知道解的方程组。
- en: 'Let’s use the following size 4 system:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下大小为4的系统：
- en: '![Image](../images/f0372-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0372-01.jpg)'
- en: 'For this system’s matrix [*M*], the Cholesky [*L*][*L*]^′ factorization is
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该系统的矩阵[*M*]，Cholesky [*L*][*L*]^′ 分解如下：
- en: '![Image](../images/f0372-02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0372-02.jpg)'
- en: The solution of the lower system,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下层系统的解，
- en: '![Image](../images/f0372-03.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0372-03.jpg)'
- en: 'is the following vector:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 是以下向量：
- en: '![Image](../images/f0372-04.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0372-04.jpg)'
- en: The final solution, resulting from the resolution of the upper system,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最终解，来自上层系统的求解，
- en: '![Image](../images/f0372-05.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0372-05.jpg)'
- en: 'is the following vector:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 是以下向量：
- en: '![Image](../images/f0372-06.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0372-06.jpg)'
- en: It’s a good idea to take some time to check all those numbers and make sure
    you understand the resolution process. Once you’re solid on the fundamentals of
    the process, let’s code it up, starting with a unit test.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间检查所有这些数字，并确保你理解解算过程是一个好主意。一旦你掌握了这个过程的基本原理，我们就开始编码，从单元测试开始。
- en: '**Lower Matrix Factorization**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**下三角矩阵分解**'
- en: As we’re about to implement the most complex algorithm in the book so far, let’s
    first write a unit test. We’ll know our factorization logic is well implemented
    once the test passes. Chances are we’ll need to debug our code, and having a test
    will help.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们即将实现本书迄今为止最复杂的算法，首先让我们编写一个单元测试。我们会知道我们的分解逻辑是否正确实现，一旦测试通过。很可能我们需要调试代码，拥有一个测试会帮助我们。
- en: Create a new file for our test, *cholesky_test.py*, and place it inside the
    *eqs/tests* directory. Then enter the test code in [Listing 14-3](ch14.xhtml#ch14lis3).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件用于我们的测试，*cholesky_test.py*，并将其放入*eqs/tests*目录下。然后在[Listing 14-3](ch14.xhtml#ch14lis3)中输入测试代码。
- en: '[PRE2]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-3: Testing the lower matrix factorization*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-3：测试下三角矩阵分解*'
- en: 'This test defines both the original matrix, sys_matrix, and the expected decomposition,
    low_matrix. Using a function we haven’t defined yet, lower _matrix_decomposition,
    we compute the decomposition matrix and compare it against the known solution.
    Your IDE should complain that you’re trying to import a function it can’t find
    in the *eqs.cholesky* module:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试定义了原始矩阵sys_matrix和期望的分解矩阵low_matrix。使用一个我们尚未定义的函数lower_matrix_decomposition，我们计算分解矩阵并将其与已知解进行比较。你的IDE应该会报错，提示你试图导入一个在*eqs.cholesky*模块中找不到的函数：
- en: Cannot find reference 'lower_matrix_decomposition' in 'cholesky.py'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在'cholesky.py'中找不到引用'lower_matrix_decomposition'
- en: Let’s implement the function. Go back to the *cholesky.py* file, and after validate_system,
    enter the code in [Listing 14-4](ch14.xhtml#ch14lis4).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现这个函数。返回到 *cholesky.py* 文件，在validate_system之后，输入[Listing 14-4](ch14.xhtml#ch14lis4)中的代码。
- en: '[PRE3]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 14-4: Lower matrix decomposition*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-4：下三角矩阵分解*'
- en: We start by storing the size of the system in a variable named size. The size
    is the number of rows or columns—it doesn’t matter which since the matrix is square.
    Then we create a new square matrix, low_mat, of that same size. Recall that our
    matrices are filled with zeros when they’re instantiated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将系统的大小存储在一个名为size的变量中。大小是行数或列数——由于矩阵是方阵，因此二者无关。接着我们创建一个相同大小的新方阵low_mat。回顾一下，我们的矩阵在实例化时是用零填充的。
- en: The algorithm has two main nested loops. These loops iterate through all the
    positions in the matrix that are in the main diagonal and below it, that is, all
    *m*[*i,j*] where *i* ≥ *j*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法有两个主要的嵌套循环。这些循环遍历矩阵中主对角线及其下方的所有位置，也就是说，遍历所有*m*[*i,j*]，其中*i* ≥ *j*。
- en: '**NOTE**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t forget that Python’s* range(n) *function generates a sequence starting
    from 0 up to* n *– 1, not* n.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要忘记，Python的* range(n) *函数生成的是从0到*n - 1*的序列，而不是*n*。'
- en: 'Inside the j loop, we store the value of the system’s matrix at position (*i,j*)
    in m_ij ➊. Then, we distinguish between the case where we’re on the main diagonal
    (i == j) or below it using an if else statement. Recall that the formula to compute
    a term in the main diagonal of the decomposition matrix is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在j循环内部，我们将系统矩阵在位置(*i,j*)的值存储在m_ij ➊中。然后，我们通过if else语句区分是在主对角线（i == j）上，还是在其下方。回顾一下，计算分解矩阵主对角线上一个项的公式如下：
- en: '![Image](../images/f0374-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0374-01.jpg)'
- en: We used that expression to compute the value, which we store in diag _val ➋
    and set in the matrix ➌. In the calculation we used the m_ij value and sq_sum.
    The latter is initialized as 0 for every new iteration of *i* (for each row) and
    updated for every new value below the main diagonal ➏.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个表达式来计算值，将其存储在diag_val ➋中，并设置在矩阵中 ➌。计算中我们使用了m_ij值和sq_sum。后者在每次新的*i*（每一行）迭代时初始化为0，并在主对角线下方的每个新值更新
    ➏。
- en: 'For the case where we’re under the main diagonal (i > j, the else branch),
    the formula to compute the *l*[*i,j*] term is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主对角线下方的情况（i > j，即else分支），计算*l*[*i,j*]项的公式如下：
- en: '![Image](../images/f0375-01.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0375-01.jpg)'
- en: Note that to compute this *l*[*i,j*] value, we need to have *l*[*j,j*], which
    is a value from a previous row since *i* > *j*. The first term that we compute
    is the sum of *l*[*i,k*]*l*[*j,k*] with *k* going from 0 to *j –* 1\. The loop
    in ➍ does exactly this. Before entering the loop, we initialize a variable non_diag_sum
    to zero. Inside the loop this variable gets added to the product of l_ik and l_jk
    for every value of *k*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了计算这个*l*[*i,j*]值，我们需要有*l*[*j,j*]，这是来自前一行的一个值，因为*i* > *j*。我们计算的第一个项是*l*[*i,k*]*l*[*j,k*]的和，*k*从0到*j
    - 1*。步骤 ➍ 中的循环正是这样做的。在进入循环之前，我们将一个名为non_diag_sum的变量初始化为零。在循环内部，这个变量在每次循环中都会加上l_ik和l_jk的乘积。
- en: With non_diag_sum computed, we have everything we need. The value of *l*[*j,j*]
    is extracted from low_mat and stored in variable l_jj. Then the value for the
    decomposition is computed and stored in variable non_diag_val ➎. This value is
    first used to update the sq_sum ➏ and then stored in the decomposition matrix
    ➐.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出non_diag_sum后，我们就拥有了所需的一切。*l*[*j,j*]的值从low_mat中提取，并存储在变量l_jj中。然后，分解的值被计算出来并存储在变量non_diag_val
    ➎中。这个值首先用于更新sq_sum ➏，然后存储在分解矩阵 ➐中。
- en: That’s it. Run the test we wrote earlier and make sure your code passes it.
    Don’t worry if it doesn’t; in fact, it’s a bit hard to get this algorithm right
    the first time you write it, but that’s exactly why we implemented the test first.
    Use the test to debug the code and carefully compare what you wrote with the printed
    version of the code in this book. You can also refer to the code distributed with
    the book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。运行我们之前编写的测试，确保你的代码能够通过测试。如果没有通过，不用担心；事实上，第一次编写这个算法时，可能很难完全正确，但这正是我们先实现测试的原因。使用测试来调试代码，并仔细对比你编写的代码和本书中打印出的代码版本。你也可以参考书中附带的代码。
- en: 'To run the test in the shell, use this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中运行测试，使用以下命令：
- en: '[PRE4]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve obtained the [*L*] decomposition matrix using Cholesky’s algorithm. Let’s
    now implement the resolution of the lower and upper systems.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过 Cholesky 算法得到了 [*L*] 分解矩阵。现在让我们实现下三角和上三角系统的求解。
- en: '**Lower System Resolution**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**下三角系统求解**'
- en: 'To solve the lower-triangular system using forward substitution, we need to
    implement the algorithm in [Equation 14.9](ch14.xhtml#ch14eqa09). We’ll repeat
    the formula here for convenience:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用前向代换法求解下三角系统，我们需要实现[方程 14.9](ch14.xhtml#ch14eqa09)中的算法。为了方便起见，我们在这里重复公式：
- en: '![Image](../images/f0375-02.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0375-02.jpg)'
- en: We’re going to follow the same approach as before and write the test before
    we write the main code. In the *cholesky_test.py* file, enter the new test in
    [Listing 14-5](ch14.xhtml#ch14lis5).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用与之前相同的方法，先编写测试，再编写主代码。在 *cholesky_test.py* 文件中，在[清单 14-5](ch14.xhtml#ch14lis5)中输入新的测试。
- en: '[PRE5]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-5: Testing the lower system resolution*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-5：测试下三角系统求解*'
- en: 'We’ve first imported the Vector class from eqs.vector. Then we’ve added two
    new vectors that we need for the new test: sys_vec ➊, which is the free vector
    of the system of equations, and low_solution ➋, the expected solution for the
    lower-triangular system.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 eqs.vector 导入了 Vector 类。然后我们添加了两个新向量，这些向量是新测试所需的：sys_vec ➊，这是方程组的自由向量，以及
    low_solution ➋，这是下三角系统的预期解。
- en: With the test in place ➌, let’s now implement the missing solve_lower_sys function.
    After the factorization function in the *cholesky.py* file, enter the code in
    [Listing 14-6](ch14.xhtml#ch14lis6).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试就位 ➌ 后，现在让我们实现缺失的 solve_lower_sys 函数。在 *cholesky.py* 文件中的分解函数后，输入[清单 14-6](ch14.xhtml#ch14lis6)中的代码。
- en: '[PRE6]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-6: Solving the lower system*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-6：求解下三角系统*'
- en: The first thing we do is save the size of the system in a variable size and
    create the solution vector of that size. The main loop that iterates through all
    values in the sys_vector is the i loop ➊. In it, we start by initializing a sum
    to zero. The j loop ➋ iterates through all values from 0 to *i –* 1, updating
    the sum for each iteration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是将系统的大小保存在一个变量 size 中，并创建一个该大小的解向量。主循环是 i 循环 ➊，它遍历 sys_vector 中的所有值。在循环中，我们首先将和初始化为零。j
    循环 ➋ 遍历从 0 到 *i –* 1 的所有值，并在每次迭代时更新和。
- en: Having obtained the sum part of the equation, we can compute the solution value,
    which is stored in solution_val ➌. Then we set in the solution vector in the next
    line.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 得到方程的和部分后，我们可以计算出解值，并将其存储在 solution_val ➌ 中。然后我们在下一行设置解向量。
- en: 'Run the two tests in *cholesky_test.py* to make sure both pass. It seems reasonable
    that the first one will pass: we haven’t modified the factorization function in
    any way, but it’s good practice to run all tests in the file, just in case we
    modified something that we shouldn’t have. I hope the second test also passes
    for you, in which case you got the new function right! You’ll need to debug your
    code otherwise. Take your time to do so; it’s a great exercise.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *cholesky_test.py* 中的两个测试，确保都通过。第一个测试通过似乎是合理的：我们没有以任何方式修改分解函数，但最好运行文件中的所有测试，以防我们修改了不该修改的东西。我希望第二个测试对你来说也能通过，这样你就成功实现了新函数！否则，你需要调试你的代码。请花时间这样做，这是一个很好的练习。
- en: 'To run the tests from the shell, use this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shell 运行测试，使用以下命令：
- en: '[PRE7]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s now work out the upper system resolution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理上三角系统的求解。
- en: '**Upper System Resolution**'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**上三角系统求解**'
- en: 'The resolution of the upper-triangular system using backward substitution can
    be carried out using [Equation 14.10](ch14.xhtml#ch14eqa10). As a reminder, the
    formula is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回代法求解上三角系统可以通过[方程 14.10](ch14.xhtml#ch14eqa10)来实现。为了提醒你，公式如下：
- en: '![Image](../images/f0377-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0377-01.jpg)'
- en: 'One important thing to recall is that the upper-triangular matrix [*U*], with
    values *u*[*i,j*], is the transpose of Cholesky’s lower-triangular decomposition:
    [*L*]^′.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件重要事是，上三角矩阵 [*U*]，其值为 *u*[*i,j*]，是 Cholesky 下三角分解的转置：[*L*]^′。
- en: Once again we’ll start with the test. Open your *cholesky_test.py* file and
    enter the new test in [Listing 14-7](ch14.xhtml#ch14lis7).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从测试开始。打开你的 *cholesky_test.py* 文件，并在 [清单 14-7](ch14.xhtml#ch14lis7) 中输入新的测试。
- en: '[PRE8]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-7: Testing the upper system resolution*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-7：测试上三角系统的求解*'
- en: In this new test ➋, we call solve_upper_sys (still to be written), passing it
    in both the factorized matrix low_matrix and the lower system solution low_solution.
    Then, we assert that the vector we get returned is the one we expect, which we’ve
    defined as part of the test’s data in the solution variable ➊.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新测试中 ➋，我们调用 solve_upper_sys（尚未编写），传入分解后的矩阵 low_matrix 和下三角系统的解 low_solution。然后，我们断言返回的向量是我们期望的那个，即我们在测试数据中的
    solution 变量中定义的向量 ➊。
- en: 'We’re now ready to implement the last part to complete Cholesky’s method: the
    resolution of the upper system. Open the *cholesky.py* file again and enter the
    solve_upper_sys function in [Listing 14-8](ch14.xhtml#ch14lis8).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实现最后一部分，以完成 Cholesky 方法：求解上三角系统。再次打开 *cholesky.py* 文件，并进入 [清单 14-8](ch14.xhtml#ch14lis8)
    中的 solve_upper_sys 函数。
- en: '[PRE9]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 14-8: Solving the upper system*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-8：求解上三角系统*'
- en: This function is similar to the previous solve_lower_sys function. We start
    by initializing the solution vector, solution, with the same size as the passed-in
    low_vector. This time, as we’ll iterate starting from the last row, we save its
    index in the last_index variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数类似于之前的 solve_lower_sys 函数。我们首先初始化解向量 solution，大小与传入的 low_vector 相同。这一次，因为我们从最后一行开始迭代，所以我们将其索引保存在
    last_index 变量中。
- en: The loop that iterates through all row indices goes from last_index all the
    way down to –1 (noninclusive) ➊. The inner loop going from *i* + 1 to size (again,
    noninclusive) computes the sum of the *u*[*i,j*]*x*[*j*] products ➋. To obtain
    u_ij, we ask the lower-triangular matrix for the value as if it were transposed
    ➌. Thanks to this neat trick, we avoid transposing [*L*], a process that is computationally
    expensive. This is the optimization we talked about in the previous chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代所有行索引的循环从 last_index 一直到 -1（不包括） ➊。内部循环从 *i* + 1 到 size（同样不包括），计算 *u*[*i,j*]*x*[*j*]
    的乘积之和 ➋。为了得到 u_ij，我们像访问转置矩阵一样访问下三角矩阵的值 ➌。多亏了这个巧妙的技巧，我们避免了转置 [*L*]，这一过程计算开销很大。这就是我们在前一章中讨论的优化方法。
- en: To get the divisor in [Equation 14.10](ch14.xhtml#ch14eqa10), we use the value_transposed_at
    function again ➍. With this value we can already compute the solution at each
    row ➎ and store it in the result vector.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到 [公式 14.10](ch14.xhtml#ch14eqa10) 中的除数，我们再次使用 value_transposed_at 函数 ➍。有了这个值，我们就可以计算每一行的解
    ➎，并将其存储在结果向量中。
- en: Run all the tests in the file to check whether the implementation is bug-free.
    Just for your reference, [Listing 14-9](ch14.xhtml#ch14lis9) is the complete *cholesky.py*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件中的所有测试，检查实现是否没有错误。仅供参考，[清单 14-9](ch14.xhtml#ch14lis9) 是完整的 *cholesky.py*
    文件。
- en: '[PRE10]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 14-9: Cholesky method result*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-9：Cholesky 方法结果*'
- en: 'Each of the three subfunctions that take part in the resolution of a system
    of equations using Cholesky’s method has been tested separately: we can be sure
    those work properly. Does this mean that the cholesky_solve function is free of
    bugs itself? Not necessarily. We may still make mistakes when putting all those
    well-tested functions together.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 参与 Cholesky 方法求解线性方程组的三个子函数已经分别经过测试：我们可以确保它们正常工作。难道这就意味着 cholesky_solve 函数本身没有
    bug 吗？不一定。将这些经过充分测试的函数组合在一起时，我们可能仍会犯错。
- en: Checking that the cholesky_solve function works as a whole requires one more
    test. This a test that ensures that each of the subfunctions behaves well when
    combined; it’s called an *integration test*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 cholesky_solve 函数整体是否正常工作需要进行一次额外的测试。这是一个确保每个子函数在组合时能正常工作的重要测试，称为 *集成测试*。
- en: '***Testing Cholesky: An Integration Test***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试 Cholesky：集成测试***'
- en: Open your *cholesky_test.py* file one last time. Let’s add a final test (shown
    in [Listing 14-10](ch14.xhtml#ch14lis10)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次打开你的 *cholesky_test.py* 文件。让我们添加一个最终的测试（如 [清单 14-10](ch14.xhtml#ch14lis10)
    所示）。
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 14-10: Testing the Cholesky decomposition method*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-10：测试 Cholesky 分解方法*'
- en: '[Listing 14-10](ch14.xhtml#ch14lis10) is the resulting test file. We included
    the last test: test_solve _system. This test exercises the Cholesky algorithm
    as a whole by calling cholesky_solve.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-10](ch14.xhtml#ch14lis10)是生成的测试文件。我们加入了最后一个测试：test_solve_system。这个测试通过调用cholesky_solve来整体测试Cholesky算法。'
- en: Run all the tests in the file. If all four tests pass, you got all the code
    right. You should be proud of yourself for following along with the code in this
    long chapter. Congratulations!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件中的所有测试。如果所有四个测试都通过了，那就说明你写的代码完全正确。你应该为自己在这一长章中跟随代码而感到自豪。恭喜你！
- en: 'If you want to run the tests from the command line, use this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从命令行运行测试，请使用以下命令：
- en: '[PRE12]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Summary**'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we discussed numerical methods and then centered the discussion
    around those that solve linear systems of equations. In particular, we analyzed
    the Cholesky decomposition method. This [*L*][*U*] decomposition algorithm works
    with symmetric, positive-definite matrices and can be twice as fast as other [*L*][*U*]
    alternatives.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了数值方法，然后将讨论重点放在了解决线性方程组的算法上。特别地，我们分析了Cholesky分解方法。这个[*L*][*U*]分解算法适用于对称正定矩阵，且速度是其他[*L*][*U*]算法的两倍。
- en: We paid special attention to the code’s readability. To make the algorithm easy
    to follow, we broke it down into smaller functions, each of which was tested separately.
    We started writing the test before the main algorithm’s logic, a technique referred
    to as test-driven development. We included one last test integrating the complete
    resolution of a system of equations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注代码的可读性。为了使算法易于理解，我们将其拆分成更小的函数，每个函数都进行了单独测试。我们在编写主算法逻辑之前就开始编写测试，这种方法被称为测试驱动开发。我们加入了最后一个测试，集成了完整的线性方程组求解。
- en: We’ve implemented a powerful resolution algorithm, and we’ll put it to work
    in [Part V](part05.xhtml#part05) of the book.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个强大的求解算法，并将在本书的[第五部分](part05.xhtml#part05)中使用它。
