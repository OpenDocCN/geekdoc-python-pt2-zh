- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINEAR EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Many engineering problems require resolving a system of linear equations. These
    equations arise in structural analysis, electric circuits, statistics, and optimization
    problems, just to name a few. Implementing algorithms to solve these ubiquitous
    systems of equations is key for our *Mechanics* project to deal with real-world
    engineering problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the concept of *numerical methods*: existing
    algorithms that use computers to solve systems of equations. We’ll implement a
    powerful method to solve systems of linear equations: the Cholesky decomposition.
    We’ll use this method when we need to solve the big systems of equations from
    the structural analysis problems in [Part V](part05.xhtml#part05) of the book.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Systems of Linear Equations**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A linear equation with *n* unknowns *x*[1], *x*[2], …, *x*[*n*] can be expressed
    as shown in [Equation 14.1](ch14.xhtml#ch14eqa01).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: Here, *m*[1], *m*[2], …, *m*[*n*] are the equation’s coefficients, known numbers
    that multiply each of the unknowns, and *b* is a known number that doesn’t multiply
    any unknown. We call this last number *b* the *free term*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: If the unknowns are only multiplied by a scalar, added, or subtracted, then
    we say the equation is *linear*. The coefficients are always known quantities.
    An alternative way of expressing a linear equation is shown here,
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0360-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: where *m*[*i*] is the coefficients, *x*[*i*] is the unknowns, and *b* is the
    free term.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, a nonlinear equation includes things like unknowns with an exponent
    (*x*³), trigonometric functions (sin(*x*)), or the product of several unknowns
    (*x*[1] ⋅ *x*[2]). These equations are considerably harder to solve than linear
    ones, so we’ll stay focused on linear equations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: A system of linear equations has the form shown in [Equation 14.2](ch14.xhtml#ch14eqa02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Here, a coefficient *m*[*i,j*] is the term that multiplies the *j*^(*th*) unknown
    in the *i*^(*th*) equation. These systems can be conveniently expressed in their
    matrix form as shown in [Equation 14.3](ch14.xhtml#ch14eqa03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Here, [*M*] is the matrix of coefficients,
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0360-02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'and [*x*] and [*b*] are the unknown and the free-term column vectors:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0360-03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'A solution for [Equation 14.3](ch14.xhtml#ch14eqa03) is a set of numbers *x*[1],
    *x*[2], …, *x*[*n*] that satisfies all *n* equations. Finding solutions for big
    systems of equations by hand can take a long time, but don’t worry: there are
    plenty of algorithms for solving systems like this using a computer.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick note on nomenclature. We’ll use uppercase letters inside square brackets
    to denote matrices: [*M*]. The items in a matrix will be named using the same
    letter used for the matrix but lowercase. Items will include as a subscript two
    comma-separated numbers, which are the row and column indices of their position
    inside the matrix. For example, the number in row 3 and column 5 of the matrix
    [*M*] will be referred to as *m*[3, 5]. Column and row vectors are denoted as
    lowercase letters inside square brackets: [*x*]. Remember that column and row
    vectors are also matrices.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名法的简要说明。我们将在方括号内使用大写字母表示矩阵：[*M*]。矩阵中的元素将使用与矩阵相同字母的小写形式命名，并且在下标中包含两个用逗号分隔的数字，表示它们在矩阵中的行列索引。例如，矩阵[*M*]中第3行第5列的数字将被称为*m*[3,
    5]。列向量和行向量用方括号内的小写字母表示：[*x*]。请记住，列向量和行向量也是矩阵。
- en: '**Numerical Methods**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数值方法**'
- en: '*Numerical methods* are algorithms that find an approximate solution for a
    system of equations using the computational power of a computer.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值方法*是使用计算机的计算能力找到方程组近似解的算法。'
- en: There are numerical methods designed to solve systems of linear, nonlinear,
    and differential systems of equations. Most numerical methods, nevertheless, are
    limited to solving specific types of systems. For instance, the Cholesky decomposition
    works only with linear systems whose coefficient matrix is symmetric and positive
    definite (we’ll see what this means in a bit). If we need to solve a nonlinear
    system of equations, or even one that is linear but with a nonsymmetric coefficient
    matrix, Cholesky decomposition simply won’t work.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数值方法旨在求解线性、非线性和微分方程系统。然而，大多数数值方法仅限于求解特定类型的方程组。例如，Cholesky分解仅适用于系数矩阵是对称且正定的线性方程组（稍后我们将了解这意味着什么）。如果我们需要求解一个非线性方程组，或者一个线性但系数矩阵非对称的方程组，Cholesky分解将无法使用。
- en: 'There are two big families of numerical methods: *direct* and *iterative*.
    Direct methods use algebraic modifications on the original system to solve it.
    Iterative methods, on the other hand, start with an approximate solution for the
    system and improve it step-by-step until the solution has the desired accuracy.
    The Cholesky decomposition is a direct numerical method.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法有两大类：*直接法*和*迭代法*。直接法通过对原始系统进行代数修改来求解系统。另一方面，迭代法从方程组的近似解开始，通过逐步改进，直到解达到所需的精度为止。Cholesky分解是一种直接数值方法。
- en: 'Numerical methods are a big topic: entire books have been written about it.
    There are many technical details about numerical methods that we won’t be covering
    here. But this isn’t a theory book; we’re much more interested in the practice,
    so we’ll implement an algorithm that solves the kinds of systems of equations
    that’ll arise in the structural analysis application we’ll create in the next
    part of the book. In this case, that means we’ll be working with linear systems
    with symmetric, positive-definite coefficient matrices.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法是一个庞大的主题：已有专门的书籍讨论它。数值方法涉及许多技术细节，我们这里不会一一介绍。但这不是一本理论书籍；我们更关心实践，因此我们将实现一个算法，用于求解在接下来的结构分析应用中可能出现的方程组。在这种情况下，这意味着我们将处理具有对称、正定系数矩阵的线性方程组。
- en: '**Cholesky Decomposition**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Cholesky分解**'
- en: The *Cholesky decomposition* is a direct (noniterative) method that solves linear
    systems of equations provided their [*M*] (the coefficient matrix) is *symmetric*
    and *positive definite*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cholesky分解*是一种直接（非迭代）方法，用于求解线性方程组，前提是它们的[*M*]（系数矩阵）是*对称*和*正定*的。'
- en: 'A symmetric matrix [*M*] is one that is equal to its transpose: [*M*] = [*M*]^′.
    That is the same as saying that the values in the matrix are symmetric with respect
    to the main diagonal. In a symmetric matrix, every row contains the same values
    as the column with the same index, and vice versa. Note that to be symmetric,
    a matrix needs to be square. The following is an example of a symmetric matrix:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对称矩阵[*M*]是指其等于其转置矩阵：[*M*] = [*M*]^′。这意味着矩阵中的数值相对于主对角线是对称的。在对称矩阵中，每一行包含与同一索引的列相同的值，反之亦然。注意，要成为对称矩阵，矩阵必须是方阵。以下是一个对称矩阵的例子：
- en: '![Image](../images/f0361-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0361-01.jpg)'
- en: A square matrix [*M*] with *n* rows and columns is *positive definite* if for
    any column vector [*x*] made of *n* real numbers (with the exception of a vector
    filled with zeros), the expression in [Equation 14.4](ch14.xhtml#ch14eqa04) is
    satisfied.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有 *n* 行和列的方阵 [*M*] 被称为 *正定矩阵*，如果对于任何由 *n* 个实数（除了一个全零向量）构成的列向量 [*x*]，[方程 14.4](ch14.xhtml#ch14eqa04)
    中的表达式成立。
- en: '![Image](../images/14eqa04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa04.jpg)'
- en: If you find a nonzero vector [*x*] that doesn’t satisfy the previous equation,
    then the matrix [*M*] is not positive definite.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到一个不满足上述方程的非零向量 [*x*]，那么矩阵 [*M*] 就不是正定的。
- en: We can also say that a matrix is positive definite if it’s symmetric and all
    its eigenvalues are positive. If you remember the process of obtaining the eigenvalues
    of a matrix, you might agree that it’s painful and a bit boring. In either case,
    proving that [*x*]^′[*M*][*x*] > 0 for every possible [*x*] or obtaining all eigenvalues
    of the matrix and making sure all are positive is an involved process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以说，如果一个矩阵是对称的，并且它的所有特征值都是正的，那么它是正定的。如果你记得获得矩阵特征值的过程，你可能会同意这既痛苦又有点无聊。无论如何，证明对于每个可能的
    [*x*]，[*x*]^′[*M*][*x*] > 0，或者获得矩阵的所有特征值并确保它们都为正，都是一个复杂的过程。
- en: 'We are going to skip all that technical complexity and won’t be demonstrating
    that the matrices we’ll work with are positive definite. We’ll apply the Cholesky
    factorization to a problem that is well-known for yielding systems of equations
    with a symmetric and positive-definite matrix: truss structure analysis using
    the direct stiffness method. If you ever need to apply this algorithm to any another
    problem, you’ll first need to figure out whether the system of equations derived
    for it has a matrix that Cholesky can work with. If it’s not the case, don’t worry:
    there are plenty of other numerical methods that you can use.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过所有这些技术复杂性，不会演示我们将使用的矩阵是正定的。我们将应用 Cholesky 分解来解决一个众所周知的问题，该问题会产生一个对称正定矩阵的方程组：使用直接刚度法进行的桁架结构分析。如果你需要将这个算法应用到其他问题中，你首先需要确定为该问题导出的方程组是否具有
    Cholesky 可以处理的矩阵。如果不是，也不用担心：你可以使用很多其他数值方法。
- en: After we implement Cholesky’s algorithm together, I hope you feel empowered
    to implement any other numerical method on your own. As you’ll see, the most powerful
    resource we have at our disposal to make sure we get these tricky algorithms right
    is unit testing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一起实现 Cholesky 算法后，希望你能够自己实现其他数值方法。正如你所看到的，确保我们正确处理这些复杂算法的最强大工具就是单元测试。
- en: '***LU Factorization Methods***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LU 分解方法***'
- en: Cholesky is a computation method from the family of so-called *LU* factorization
    or decomposition methods. An *LU* factorization of a given square matrix [*M*]
    has the form shown in [Equation 14.5](ch14.xhtml#ch14eqa05).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Cholesky 是属于所谓 *LU* 分解或分解方法家族中的一种计算方法。给定方阵 [*M*] 的 *LU* 分解形式如 [方程 14.5](ch14.xhtml#ch14eqa05)
    所示。
- en: '![Image](../images/14eqa05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14eqa05.jpg)'
- en: 'Here, [*L*] is a *lower-triangular matrix*, and [*U*] is an *upper-triangular
    matrix*. A lower-triangular matrix is one where all nonzero values are on and
    below the main diagonal. Conversely, an upper-triangular matrix has the nonzero
    values on and above the main diagonal. Here’s an example of a lower-and an upper-triangular
    matrix:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，[*L*] 是一个 *下三角矩阵*，而 [*U*] 是一个 *上三角矩阵*。下三角矩阵是指所有非零值都位于主对角线及其下方。相反，上三角矩阵的非零值位于主对角线及其上方。以下是一个下三角矩阵和上三角矩阵的示例：
- en: '![Image](../images/f0362-01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0362-01.jpg)'
- en: Every *nonsingular matrix* (a matrix that has an inverse) always has an *LU*
    factorization. For example, the matrices from the previous example are the *LU*
    factorization for the matrix
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *非奇异矩阵*（具有逆矩阵的矩阵）总是可以进行 *LU* 分解。例如，前面的矩阵就是该矩阵的 *LU* 分解：
- en: '![Image](../images/f00363-p1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00363-p1.jpg)'
- en: 'which you can verify by multiplying the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过乘以以下内容来验证这一点：
- en: '![Image](../images/f00363-p2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00363-p2.jpg)'
- en: 'The Cholesky algorithm will provide us with a lower-and an upper-triangular
    matrix. Besides Cholesky, there are two well-known methods for obtaining the factorization
    of any nonsingular matrix: the Doolittle and Crout algorithms. These algorithms
    define the formulas necessary to compute the *l*[*i,j*] and *u*[*i,j*] values
    for the lower- and upper-triangular matrices. The benefit of these methods is
    that they work for any kind of matrix, not just symmetric, positive-definite matrices.
    We won’t be covering them here, but I encourage you to take a look and try to
    implement one of them yourself in our *Mechanics* project. You may want to try
    that as an exercise after we’ve implemented Cholesky’s algorithm.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: It’s fair to ask, why not use the Doolittle or Crout algorithms that work with
    every nonsingular matrix instead of the more restrictive Cholesky? For symmetric
    and positive-definite matrices, Cholesky’s decomposition is about twice as fast
    as these other algorithms. Since we’ll use the method with the type of matrices
    required, we’ll want to benefit from the execution speed offered by Cholesky’s
    method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we obtain the *LU* factorization for the matrix, we can solve our system
    of equations in two steps. Suppose our original system was as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[*M*][*x*] = [*b*]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: After factorizing [*M*], we have [Equation 14.6](ch14.xhtml#ch14eqa06).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'We can extract two systems from [Equation 14.6](ch14.xhtml#ch14eqa06) if we
    take the product [*U*][*x*] and substitute it with a new unknown vector [*y*]:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0363-02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: We now have a lower-triangular matrix system, as shown in [Equation 14.7](ch14.xhtml#ch14eqa07),
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: and an upper-triangular matrix system, as shown in [Equation 14.8](ch14.xhtml#ch14eqa08).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'By first solving [Equation 14.7](ch14.xhtml#ch14eqa07), we find [*y*], which
    plugged into [Equation 14.8](ch14.xhtml#ch14eqa08) allows us to compute the unknown
    vector [*x*]: the system’s solution. Both [Equation 14.7](ch14.xhtml#ch14eqa07)
    and [Equation 14.8](ch14.xhtml#ch14eqa08) are systems with a triangular matrix,
    and they can be easily solved by forward and backward substitution.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this system of equations whose coefficient matrix is lower triangular:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00364-p1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'The first unknown *y*[1] can be computed from the first equation as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0364-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: From the second equation we have the following,
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0364-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'which can be solved, as we already computed the value for *y*[1] in the previous
    step. We do the same for the third equation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0364-03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: We have the values for *y*[1] and *y*[2], so the value for *y*[3] can be computed.
    This process is known as *forward substitution*. A formula to obtain the *y*^(*ith*)
    solution term using forward substitution is shown in [Equation 14.9](ch14.xhtml#ch14eqa09)
    (using zero-based indices).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'In a system whose coefficient matrix is upper triangular, we can use a similar
    substitution process, but starting from the bottom this time. The process is called
    *backward substitution*. This time we have the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0364-04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Starting from the last equation, we can compute *x*[3]:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0364-05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'With this value we can move to the second equation to obtain *x*[2]:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0365-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, from the first equation in the system, we have this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0365-02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: For the backward substitution, the formula to compute the *x*^(*ith*) term is
    described by [Equation 14.10](ch14.xhtml#ch14eqa10), with *n* being the size of
    the system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: We’ll need to implement these formulas in our code soon. You’ll see that it’s
    actually simpler than it looks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Cholesky***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we discussed, the Cholesky decomposition is an *LU* method that works with
    symmetric, positive-definite matrices. Thanks to those properties, a matrix [*M*]
    can be decomposed into an [*L*][*U*] form where the upper-triangular matrix is
    the transpose of the lower-triangular one: [*U*] = [*L*]^′. This means we only
    need to compute the lower-triangular matrix [*L*]: [*U*] is just its transpose.
    Using the Cholesky method, the [*M*] matrix factorization has the form shown in
    [Equation 14.11](ch14.xhtml#ch14eqa11).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: So, the system of equations now looks like [Equation 14.12](ch14.xhtml#ch14eqa12).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa12.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we obtain the two systems we need to solve by substituting [*L*]^′[*x*]
    with [*y*]:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00365-p1.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: As we already know, this transformation yields a lower system, which we’ll solve
    first using forward substitution (see [Equation 14.13](ch14.xhtml#ch14eqa13)),
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa13.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: and then using an upper system that we’ll solve by backward substitution to
    obtain the solution vector [*x*] (see [Equation 14.14](ch14.xhtml#ch14eqa14)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa14.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Given a symmetric, positive-definite matrix [*M*], we can compute the lower-triangular
    matrix terms of its Cholesky decomposition, the *l*[*i,j*] terms, using the formulas
    in [Equation 14.15](ch14.xhtml#ch14eqa15).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14eqa15.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '[Equation 14.15](ch14.xhtml#ch14eqa15) may look intimidating, but it’s actually
    not that complicated. The best way to see this is by doing an exercise by hand.
    Grab a pen and some paper and let’s factor a matrix together.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '***A Factorization by Hand***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the symmetric and positive-definite matrix
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0366-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: let’s find its Cholesky factorization, a lower-triangular matrix [*L*],
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0366-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: such that [*M*] = [*L*][*L*]^′. To compute the *l*[*i,j*] terms, we use [Equation
    14.15](ch14.xhtml#ch14eqa15). Don’t forget that index *i* represents the rows
    of the matrix, and *j* represents its columns. Let’s do it step-by-step.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1:** *i* = 0,*j* = 0\. Since *i* = *j*, we use the first formula:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0366-03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Note that the summation is struck through because it doesn’t yield any term.
    This is because the summation’s end value *k* = –1 is smaller than the start one
    *k* = 0\. As you probably know, for the summation to yield any term, the end value
    for *k* (the iterating variable) needs to be equal to or greater than the start
    value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2:** *i* = 1,*j* = 0\. In this case, *i*≠*j*, so we use the second formula:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0366-04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '**Step 3:** *i* = 1,*j* = 1.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: '**Step 4:** *i* = 2,*j* = 0.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: '**Step 5:** *i* = 2,*j* = 1.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '**Step 6:** *i* = 2,*j* = 2.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'If we combine all the computed *l*[*i,j*] values, the resulting matrix is as
    follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'This means that the original system’s matrix [*M*] can be factorized as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: You can do the matrix multiplication to verify that the product [*L*][*L*]^′
    is actually equal to [*M*]. To complete the exercise, let’s suppose this matrix
    is the coefficient matrix of a system of equations and solve it using the forward
    and backward substitutions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '***A Resolution by Hand***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s suppose the matrix we decomposed earlier into its [*L*][*L*]^′ form is
    part of the following system of equations:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'We need to find the values of *x*[1], *x*[2], and *x*[3] that satisfy all three
    equations. Using the Cholesky factorization we just obtained, we can rewrite the
    system as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'The first of the two subsystems we have to solve, [*L*][*y*] = [*b*], results
    from substituting [*L*]^′[*x*] with a new unknown vector [*y*]:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'This results in the first system (the lower system):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: We have to solve this system using the forward-substitution formula from [Equation
    14.9](ch14.xhtml#ch14eqa09).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower System: Forward Substitution**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s apply [Equation 14.9](ch14.xhtml#ch14eqa09) step-by-step:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1:** *i* = 0.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '**Step 2:** *i* = 1.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '**Step 3:** *i* = 2.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Thus, the solution for the first system is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'With this solution, we can use backward substitution to compute [*x*]: the
    solution to our system of equations.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**Upper System: Backward Substitution**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s use [Equation 14.10](ch14.xhtml#ch14eqa10) to compute the solution vector
    step-by-step. This time we have to solve the following system using the backward-substitution
    process:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Since the substitution is backward, we have to start from the last row (*i*
    = 2) and go up to the first one (*i* = 0).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1:** *i* = 2.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '**Step 2:** *i* = 1.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: '**Step 3:** *i* = 0.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Then, the solution to the initial system is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'You can test if the solution is correct by checking if the equality holds:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0369-07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Now that we know how the Cholesky algorithm works and we’ve worked out an example
    by hand, let’s implement the algorithm in our code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing Cholesky***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start by creating a new file in the *eqs* package named *cholesky.py*. In it,
    include the cholesky_solve function in [Listing 14-1](ch14.xhtml#ch14lis1).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 14-1: Cholesky decomposition algorithm*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes a Matrix and a Vector as inputs. These are the coefficient
    matrix and free vector of a system: the [*M*] and the [*b*] from the system of
    equations [*M*][*x*] = [*b*]. The returned Vector is [*x*], the solution to the
    system found applying Cholesky’s method.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'This cholesky_solve function defines the highest-level algorithm, which has
    three main steps plus a validation of the input system. We haven’t implemented
    any of these functions yet; we’ll get to this shortly. The following are the three
    main steps to the algorithm:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: lower_matrix_decomposition Obtain [*L*], the lower-triangular matrix, by applying
    [Equation 14.15](ch14.xhtml#ch14eqa15).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: solve_lower_sys Solve the first subsystem, the lower-triangular system, by applying
    the forward-substitution technique (see [Equation 14.9](ch14.xhtml#ch14eqa09)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: solve_upper_sys Solve the second subsystem, the upper-triangular system, by
    applying the backward-substitution technique (see [Equation 14.10](ch14.xhtml#ch14eqa10)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: From the function names, it’s easy enough to see what the code in cholesky _solve
    is doing. Note that we broke the function into several smaller functions. If we
    had thrown all the code for the Cholesky resolution into the cholesky_solve function,
    the result would be a long pile of source code with no readily identifiable structure.
    This code would be extremely hard to understand.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, you want to divide your big algorithms into smaller subalgorithms,
    each contained in a small function with a descriptive name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Notice the visibility of the subfunctions used by cholesky_solve. All the subfunctions
    are public. This is so that they can be unit tested individually. The resolution
    algorithm is a bit complex; we’re safer if we know that each of its subparts does
    its job without errors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating the System**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s implement a function that validates that the system is square and has
    a number of columns equal to the size of the vector. Enter the code for the validate_system
    function, found in [Listing 14-2](ch14.xhtml#ch14lis2).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-2: System validation*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We first check that the matrix has the same number columns as the vector’s length.
    If this condition isn’t satisfied, the system can’t be solved, so we raise an
    error. The same applies if the system’s matrix is not square.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We’re not doing any check to ensure the matrix is symmetric or positive definite;
    if the matrix passed to our function isn’t, the function will simply fail at some
    point with a by-zero division error or something similar. It’d be a nice idea
    to add those guards, at least the check for symmetry, but checking that the system’s
    matrix is positive definite may be more challenging. The symmetry check is easy
    to implement, but it has the downside of being computationally expensive. I encourage
    you to think about ways of doing these checks and maybe add them in your code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to do something a little backward. We’re going to start with
    a unit test instead of the code itself. This is so that we know when our code
    is ready: once the tests pass. We can keep running the test to check whether the
    logic we’re writing is ready or not; we can refactor it until it looks readable,
    with the safety net of the test that will warn us if we did something wrong. This
    technique where the test is written before the code is known as *test-driven development*,
    or TDD for short.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at the system of equations we’ll use in the unit tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**System of Equations for Testing**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make sure we implement all the logic without bugs, we’re going to use tests
    for each of the subfunctions in the Cholesky algorithm. We’ll also implement a
    test to check that all the subfunctions work together to compute the final solution.
    For these tests we want to use a system of equations whose solution we know in
    advance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following size 4 system:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'For this system’s matrix [*M*], the Cholesky [*L*][*L*]^′ factorization is
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: The solution of the lower system,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-03.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'is the following vector:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-04.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: The final solution, resulting from the resolution of the upper system,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-05.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'is the following vector:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-06.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: It’s a good idea to take some time to check all those numbers and make sure
    you understand the resolution process. Once you’re solid on the fundamentals of
    the process, let’s code it up, starting with a unit test.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower Matrix Factorization**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As we’re about to implement the most complex algorithm in the book so far, let’s
    first write a unit test. We’ll know our factorization logic is well implemented
    once the test passes. Chances are we’ll need to debug our code, and having a test
    will help.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file for our test, *cholesky_test.py*, and place it inside the
    *eqs/tests* directory. Then enter the test code in [Listing 14-3](ch14.xhtml#ch14lis3).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-3: Testing the lower matrix factorization*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'This test defines both the original matrix, sys_matrix, and the expected decomposition,
    low_matrix. Using a function we haven’t defined yet, lower _matrix_decomposition,
    we compute the decomposition matrix and compare it against the known solution.
    Your IDE should complain that you’re trying to import a function it can’t find
    in the *eqs.cholesky* module:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Cannot find reference 'lower_matrix_decomposition' in 'cholesky.py'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement the function. Go back to the *cholesky.py* file, and after validate_system,
    enter the code in [Listing 14-4](ch14.xhtml#ch14lis4).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 14-4: Lower matrix decomposition*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We start by storing the size of the system in a variable named size. The size
    is the number of rows or columns—it doesn’t matter which since the matrix is square.
    Then we create a new square matrix, low_mat, of that same size. Recall that our
    matrices are filled with zeros when they’re instantiated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm has two main nested loops. These loops iterate through all the
    positions in the matrix that are in the main diagonal and below it, that is, all
    *m*[*i,j*] where *i* ≥ *j*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t forget that Python’s* range(n) *function generates a sequence starting
    from 0 up to* n *– 1, not* n.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the j loop, we store the value of the system’s matrix at position (*i,j*)
    in m_ij ➊. Then, we distinguish between the case where we’re on the main diagonal
    (i == j) or below it using an if else statement. Recall that the formula to compute
    a term in the main diagonal of the decomposition matrix is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0374-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: We used that expression to compute the value, which we store in diag _val ➋
    and set in the matrix ➌. In the calculation we used the m_ij value and sq_sum.
    The latter is initialized as 0 for every new iteration of *i* (for each row) and
    updated for every new value below the main diagonal ➏.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'For the case where we’re under the main diagonal (i > j, the else branch),
    the formula to compute the *l*[*i,j*] term is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0375-01.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Note that to compute this *l*[*i,j*] value, we need to have *l*[*j,j*], which
    is a value from a previous row since *i* > *j*. The first term that we compute
    is the sum of *l*[*i,k*]*l*[*j,k*] with *k* going from 0 to *j –* 1\. The loop
    in ➍ does exactly this. Before entering the loop, we initialize a variable non_diag_sum
    to zero. Inside the loop this variable gets added to the product of l_ik and l_jk
    for every value of *k*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: With non_diag_sum computed, we have everything we need. The value of *l*[*j,j*]
    is extracted from low_mat and stored in variable l_jj. Then the value for the
    decomposition is computed and stored in variable non_diag_val ➎. This value is
    first used to update the sq_sum ➏ and then stored in the decomposition matrix
    ➐.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. Run the test we wrote earlier and make sure your code passes it.
    Don’t worry if it doesn’t; in fact, it’s a bit hard to get this algorithm right
    the first time you write it, but that’s exactly why we implemented the test first.
    Use the test to debug the code and carefully compare what you wrote with the printed
    version of the code in this book. You can also refer to the code distributed with
    the book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test in the shell, use this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve obtained the [*L*] decomposition matrix using Cholesky’s algorithm. Let’s
    now implement the resolution of the lower and upper systems.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower System Resolution**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To solve the lower-triangular system using forward substitution, we need to
    implement the algorithm in [Equation 14.9](ch14.xhtml#ch14eqa09). We’ll repeat
    the formula here for convenience:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0375-02.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: We’re going to follow the same approach as before and write the test before
    we write the main code. In the *cholesky_test.py* file, enter the new test in
    [Listing 14-5](ch14.xhtml#ch14lis5).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-5: Testing the lower system resolution*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve first imported the Vector class from eqs.vector. Then we’ve added two
    new vectors that we need for the new test: sys_vec ➊, which is the free vector
    of the system of equations, and low_solution ➋, the expected solution for the
    lower-triangular system.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: With the test in place ➌, let’s now implement the missing solve_lower_sys function.
    After the factorization function in the *cholesky.py* file, enter the code in
    [Listing 14-6](ch14.xhtml#ch14lis6).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-6: Solving the lower system*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is save the size of the system in a variable size and
    create the solution vector of that size. The main loop that iterates through all
    values in the sys_vector is the i loop ➊. In it, we start by initializing a sum
    to zero. The j loop ➋ iterates through all values from 0 to *i –* 1, updating
    the sum for each iteration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Having obtained the sum part of the equation, we can compute the solution value,
    which is stored in solution_val ➌. Then we set in the solution vector in the next
    line.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the two tests in *cholesky_test.py* to make sure both pass. It seems reasonable
    that the first one will pass: we haven’t modified the factorization function in
    any way, but it’s good practice to run all tests in the file, just in case we
    modified something that we shouldn’t have. I hope the second test also passes
    for you, in which case you got the new function right! You’ll need to debug your
    code otherwise. Take your time to do so; it’s a great exercise.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the tests from the shell, use this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s now work out the upper system resolution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Upper System Resolution**'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The resolution of the upper-triangular system using backward substitution can
    be carried out using [Equation 14.10](ch14.xhtml#ch14eqa10). As a reminder, the
    formula is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0377-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'One important thing to recall is that the upper-triangular matrix [*U*], with
    values *u*[*i,j*], is the transpose of Cholesky’s lower-triangular decomposition:
    [*L*]^′.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Once again we’ll start with the test. Open your *cholesky_test.py* file and
    enter the new test in [Listing 14-7](ch14.xhtml#ch14lis7).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-7: Testing the upper system resolution*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this new test ➋, we call solve_upper_sys (still to be written), passing it
    in both the factorized matrix low_matrix and the lower system solution low_solution.
    Then, we assert that the vector we get returned is the one we expect, which we’ve
    defined as part of the test’s data in the solution variable ➊.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to implement the last part to complete Cholesky’s method: the
    resolution of the upper system. Open the *cholesky.py* file again and enter the
    solve_upper_sys function in [Listing 14-8](ch14.xhtml#ch14lis8).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 14-8: Solving the upper system*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: This function is similar to the previous solve_lower_sys function. We start
    by initializing the solution vector, solution, with the same size as the passed-in
    low_vector. This time, as we’ll iterate starting from the last row, we save its
    index in the last_index variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The loop that iterates through all row indices goes from last_index all the
    way down to –1 (noninclusive) ➊. The inner loop going from *i* + 1 to size (again,
    noninclusive) computes the sum of the *u*[*i,j*]*x*[*j*] products ➋. To obtain
    u_ij, we ask the lower-triangular matrix for the value as if it were transposed
    ➌. Thanks to this neat trick, we avoid transposing [*L*], a process that is computationally
    expensive. This is the optimization we talked about in the previous chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: To get the divisor in [Equation 14.10](ch14.xhtml#ch14eqa10), we use the value_transposed_at
    function again ➍. With this value we can already compute the solution at each
    row ➎ and store it in the result vector.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Run all the tests in the file to check whether the implementation is bug-free.
    Just for your reference, [Listing 14-9](ch14.xhtml#ch14lis9) is the complete *cholesky.py*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 14-9: Cholesky method result*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the three subfunctions that take part in the resolution of a system
    of equations using Cholesky’s method has been tested separately: we can be sure
    those work properly. Does this mean that the cholesky_solve function is free of
    bugs itself? Not necessarily. We may still make mistakes when putting all those
    well-tested functions together.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Checking that the cholesky_solve function works as a whole requires one more
    test. This a test that ensures that each of the subfunctions behaves well when
    combined; it’s called an *integration test*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Cholesky: An Integration Test***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open your *cholesky_test.py* file one last time. Let’s add a final test (shown
    in [Listing 14-10](ch14.xhtml#ch14lis10)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 14-10: Testing the Cholesky decomposition method*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-10](ch14.xhtml#ch14lis10) is the resulting test file. We included
    the last test: test_solve _system. This test exercises the Cholesky algorithm
    as a whole by calling cholesky_solve.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Run all the tests in the file. If all four tests pass, you got all the code
    right. You should be proud of yourself for following along with the code in this
    long chapter. Congratulations!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the tests from the command line, use this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Summary**'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we discussed numerical methods and then centered the discussion
    around those that solve linear systems of equations. In particular, we analyzed
    the Cholesky decomposition method. This [*L*][*U*] decomposition algorithm works
    with symmetric, positive-definite matrices and can be twice as fast as other [*L*][*U*]
    alternatives.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We paid special attention to the code’s readability. To make the algorithm easy
    to follow, we broke it down into smaller functions, each of which was tested separately.
    We started writing the test before the main algorithm’s logic, a technique referred
    to as test-driven development. We included one last test integrating the complete
    resolution of a system of equations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We’ve implemented a powerful resolution algorithm, and we’ll put it to work
    in [Part V](part05.xhtml#part05) of the book.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
