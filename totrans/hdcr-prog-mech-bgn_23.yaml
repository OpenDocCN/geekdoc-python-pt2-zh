- en: '18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PRODUCING AN SVG IMAGE AND TEXT FILE
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we solve one of our truss structures, we construct a new model with the
    solution values. If we want to explore the stress on each bar or the displacement
    of each node, we need to produce some kind of output with this information. Diagrams
    are one good way of displaying the information that results from engineering calculations,
    but we may also want a text file with the detailed values.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll write a module for our structural analysis application
    that produces both a vector image with all the relevant pieces of data in the
    solution, and a simpler textual representation of the structure solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a new package in *structures* named *out*; this package will contain
    all the solution output code. Your *structures* package directory should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: structures
  prefs: []
  type: TYPE_NORMAL
- en: '|- generation'
  prefs: []
  type: TYPE_NORMAL
- en: '|- model'
  prefs: []
  type: TYPE_NORMAL
- en: '|- out'
  prefs: []
  type: TYPE_NORMAL
- en: '|- parse'
  prefs: []
  type: TYPE_NORMAL
- en: '|- solution'
  prefs: []
  type: TYPE_NORMAL
- en: '|- tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by implementing the function that produces an SVG image from the
    structure solution. Let’s create a new Python file named *svg.py* and another
    one named *config.json* that’ll contain the configuration for the drawing. Your
    *out* directory should now contain the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: structures
  prefs: []
  type: TYPE_NORMAL
- en: '|- out'
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- config.json'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, don’t forget to include an *__init__.py* file if you didn’t use the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '**From Structure Solution to SVG**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When our output code is finished, it should produce diagrams like the one in
    [Figure 18-1](ch18.xhtml#ch18fig1). Although you can’t see it in the print version
    of the book, the compression bars are red, and the tension bars are green. The
    external forces are yellow, and we’re using purple for the reactions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: Truss result diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: This image was generated using the code we’re going to write together in the
    rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Configuration File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once your code is ready and working, you may want to play with the diagram’s
    colors and sizes to get a result you find satisfying. We want to have the liberty
    of changing these colors without needing to read through our code, so we’ll move
    them to a separate configuration file, like we’ve already done in [Chapter 9](ch09.xhtml#ch09)
    and [Chapter 12](ch12.xhtml#ch12). In fact, any parameter we want to tweak can
    be placed in the configuration file. We’ll include things such as the radius of
    the nodes, their stroke width, and the margin of the image in the configuration,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-2](ch18.xhtml#ch18fig2) illustrates some of the properties we want
    to be configurable and the values we’ll assign them. Colors are represented using
    hexadecimal values prefixed with a #.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Output configuration values*'
  prefs: []
  type: TYPE_NORMAL
- en: Open the *config.json* file we just created and enter the configuration values
    in [Listing 18-1](ch18.xhtml#ch18lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-1: The default configuration for our output image*'
  prefs: []
  type: TYPE_NORMAL
- en: These configuration values are the defaults we’ll use when no others are given.
    Feel free to personalize your app’s diagrams using different colors, sizes, or
    text font.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need a way of reading the configuration JSON file into our main
    *svg.py* script. Let’s write a function to do this. In *svg.py*, enter the code
    in [Listing 18-2](ch18.xhtml#ch18lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-2: Reading the configuration JSON file*'
  prefs: []
  type: TYPE_NORMAL
- en: The __read_config function uses resource_string from the pkg_resources package
    (from Python’s standard library) to load our *config.json* file into a string.
    Then, we use json.loads to parse the string into a dictionary. We’ll use this
    function later.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can allow the user to pass some parameters to the application;
    these will modify how the resulting diagram is drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Settings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have the configuration, which contains values that determine how the diagram
    will look. These values are defined by the application, and users don’t need to
    worry about them. We allow users to pass a configuration dictionary to the application
    with values that override the default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the configuration, there are some other values our application needs
    to draw the solution diagram for a given structure. These values include the scales
    used to draw the geometry and loads, for example. We can’t guess these beforehand,
    so we need the user to provide them to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call these one-time values *settings*. We’ll pass our function a settings
    dictionary, but these settings won’t have default values because there are no
    sensible defaults we can use here; they completely depend on the structure being
    computed and what the user wants the result to look like. Does the user want to
    exaggerate the deformations? Or do they want to see the deformations without a
    scale to get an idea of what the deformed structure actually looks like? We can’t
    guess this ourselves, and thus, we’ll let the user of the app decide on these
    values.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve included all the settings we want to make available to the user in [Table
    18-1](ch18.xhtml#ch18tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Output Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| scale | Number | Changes the scale of the resulting drawing |'
  prefs: []
  type: TYPE_TB
- en: '| disp_scale | Number | Changes the scale of the node displacements |'
  prefs: []
  type: TYPE_TB
- en: '| load_scale | Number | Changes the scale of load representation |'
  prefs: []
  type: TYPE_TB
- en: '| no_draw_original | Boolean | Specifies whether to draw the original geometry
    |'
  prefs: []
  type: TYPE_TB
- en: Let’s write a function to validate that the dictionary contains values for all
    these settings. In your *svg.py* file, enter the function in [Listing 18-3](ch18.xhtml#ch18lis3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-3: Validating the settings dictionary*'
  prefs: []
  type: TYPE_NORMAL
- en: This __validate_settings function ensures all the expected settings are in the
    settings dictionary. If any of the functions are not, we raise an error with a
    message for the user. Let’s now write the function to produce the SVG image.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Solution Drawing Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the *svg.py* file, before the __read_config function, enter the code in [Listing
    18-4](ch18.xhtml#ch18lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-4: Structure solution to SVG function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the structure_solution_to_svg function, but it doesn’t draw anything
    yet; it just produces an empty SVG image. The function receives three parameters:
    the structure solution (a StructureSolution class instance), the settings dictionary,
    and the configuration dictionary. The configuration dictionary is optional, so
    we give it a default value of None.'
  prefs: []
  type: TYPE_NORMAL
- en: In the function, we first validate the passed-in settings using the function
    we wrote in the previous section. If the validation fails, we raise an error and
    halt execution of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we load the default configuration using the __read_config function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is merging the passed-in configuration dictionary with the default
    one ➊. The dictionaries are merged using Python’s dictionary unpacking operator:
    **. If a and b are dictionaries, using {**a, **b} will create a new dictionary
    containing all the entries from a and b. If there’s a key that’s in both dictionaries,
    the version in b, the second dictionary, is kept. Therefore, in our usage, if
    a configuration value is given by the user, this overrides the default one. We
    store the merged configuration dictionary in the config variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The dictionary unpacking operator was added in Python version 3.5\. You can
    read more about it in PEP-448:* [https://www.python.org/dev/peps/pep-0448](https://www.python.org/dev/peps/pep-0448)*.
    PEP stands for “Python Enhancement Proposal.” These are the documents the Python
    community writes to propose new features for the language, among others.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the viewbox for the SVG image using the structure solution’s
    bounding rectangle ➋. If you recall, the StructureSolution bounds_rect method’s
    first parameter is the margin for the bounds, and the second is the scale. We
    take the value for the margin from the configuration and the scale from the settings.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an affine transformation that we’ll use to flip the image’s y-axis
    so that it points up.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we create and return the SVG image using svg_content from our svg package
    ➌. The size of the image is given by the viewbox size; the list of primitives
    is empty at the moment. In the next sections, we’ll fill this list with the SVG
    primitives that represent the nodes, bars, and loads. First, though, let’s look
    at captions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Captions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re going to use captions in a few places: to note the bars’ stresses, to
    number the nodes, and to give forces coordinates. Positioning these captions is
    going to be a bit tricky since we’ll want to rotate them so they align with the
    element they caption, as you can see in [Figure 18-3](ch18.xhtml#ch18fig3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Captions in our diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, since we applied an affine transformation to the SVG image that
    flips the y-axis, the captions we add will also be flipped, and if we don’t undo
    that flip, they’ll be impossible to read. We’ll correct this by scaling the caption
    so that its y-axis is flipped back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python file in *structures/out* named *captions_svg.py*. Your
    *out* directory should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: In this new file, enter the code in [Listing 18-5](ch18.xhtml#ch18lis5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-5: From captions to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement a function named caption_to_svg. This function has five parameters:
    the caption’s text, a point at which the caption is located, the angle it’s rotated,
    the color, and the configuration dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll extract the font family and size from the configuration dictionary. The
    first two lines save these values into the font and size variables, respectively
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do is compute an affine transformation that scales and rotates
    the caption. We first generate the rotation with the make_rotation function and
    then the scaling with the make_scale function; lastly, these are combined into
    a single transformation ➋. Note how both transformations are done with respect
    to the caption’s position point (see [Figure 18-4](ch18.xhtml#ch18fig4)). This
    is key. If we scaled and rotated the caption around the global origin (the ⟨0,
    0⟩ point), it would appear somewhere unexpected in the drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Caption rotation*'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we create the SVG text element using the svg.text function, passing
    it the caption, the center point, a zero displacement vector, and a list of attributes
    ➌. In the attributes we include the fill color, the transformation, the font family,
    and the font size.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Bars***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s now work on producing the SVG code to draw the original and deformed
    bar geometries. Bars are straight lines, so representing them won’t be too complicated.
    In the *out* directory, create a new file named *bar_svg.py*. Your *out* directory
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- bar_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: As we know, both the original and deformed bar geometries are straight lines.
    We’ll start by writing a helper function to generate the SVG segments that represent
    bars, both in their original and deformed states. In the file, enter the code
    in [Listing 18-6](ch18.xhtml#ch18lis6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-6: Single bar to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve written the __bar_svg function to generate an SVG segment using the passed-in
    geometry, which should be an instance of our Segment class; we’ve also passed
    in the color to use and the cross section of the bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need the cross-section value? We’ll use a line thickness that roughly
    represents the cross section of the bar so that bars with a larger cross section
    are drawn with a thicker line. [Figure 18-5](ch18.xhtml#ch18fig5) shows our approximation:
    we’re computing the line thickness as if it was the side of a square cross section.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Calculating line thickness from the cross section*'
  prefs: []
  type: TYPE_NORMAL
- en: In the section_height variable, we store the height of the bar as if its section
    was square ➊. This value is computed from the square root of the bar’s cross section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we return an SVG segment using the passed-in geometry and adding two
    attributes: the stroke color and the line thickness we’ve computed ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue and write the first version of the bars_to_svg function. In your
    file and before the __bar_svg function we just wrote, enter the code in [Listing
    18-7](ch18.xhtml#ch18lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-7: Bar to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this listing, we merely outline the main algorithm to generate SVG primitives
    representing the bars. There are three functions that do most of the work, but
    we haven’t written them yet: original_bar_to_svg, bar_to_svg, and bar_stress_to_svg.
    We’ll write these shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Our bars_to_svg function first saves the negated value of the no_draw _original
    setting in the should_draw_original variable. If should_draw_original is true,
    our function will also include the segments representing the original bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare three empty lists: original, final, and stresses ➊. The first
    one, original, stores the segments that represent the original bars; the second
    one, final, contains the final or solution bars; and the last list, stresses,
    stores the stress captions. We’ll put all the SVG primitives we generate in these
    lists.'
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate through the bars. For each one, if should_draw_original is true,
    we append the result of original_bar_to_svg to the original list ➋; original_bar_to_svg
    is a function we haven’t written yet that generates the SVG segment for the original
    bar. We append the SVG representing the solution bar to the final list ➌ and the
    stress caption to stresses ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the loop, the three lists are filled with the SVG primitives that represent
    the bars of the original and solution structures. We concatenate and return those
    lists ➎. As noted by the comment in the code, the order here is important: the
    elements that appear last in the list will be drawn on top of the rest. We want
    the original bars to be behind the solution bars; thus, they need to appear first
    in the list. You can imagine these bars as being distributed by layers, as depicted
    in [Figure 18-6](ch18.xhtml#ch18fig6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-6: Drawing the bar SVGs in layers*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the three functions we used to generate the SVG primitives.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Original Bars**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For these functions, we’re going to use a technique we explored in the “Functions
    Inside Other Functions” section on [page 28](ch02.xhtml#ch00lev2sec21). We’ll
    define them as internal functions inside the bars_to_svg function so they gain
    access to the parameters passed to bars_to_svg. This spares us from having to
    pass around the settings and config dictionaries. The resulting internal functions
    will have a shorter parameter list, which makes them simpler. As the functions
    are effectively kept private in bars_to_svg, only the host function has access
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the original_bar_to_svg function first. In your file, enter the
    missing code in [Listing 18-8](ch18.xhtml#ch18lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-8: Original (nonsolution) bar to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve written the original_bar_to_svg function inside the bars_to_svg function,
    at the beginning of it. This function requires only one argument: a bar from the
    solution structure (of type StrBarSolution), which contains the original bar inside
    its original_geometry attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we extract the color for the original bar from the configuration dictionary
    ➊. Then, we return the result of calling the __bar_svg function with the original
    bar’s geometry, the color, and the bar’s cross section ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Solution Bars**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s write the code to draw the solution bars. These will have a different
    color depending on if their stress is compressive or tensile. In the bars_to_svg
    function, after the original_bar_to_svg function we just wrote, enter the missing
    code in [Listing 18-9](ch18.xhtml#ch18lis9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-9: Solution bar to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bar_to_svg function returns the result of calling __bar_svg with the displaced
    bar as first argument, computed using the final_geometry_scaling _displacement
    method we implemented in the StrBarSolution class ➊. The second argument is the
    color, which we compute using another function that we implemented later in the
    code: bar_color ➋. The third and last argument is the bar’s cross section ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: The bar_color function returns the correct color from the configuration dictionary
    depending on the sign of the bar’s stress. Note, once again, how we don’t need
    the config dictionary to be passed to this function. We already have access to
    it because we are inside the bars_to_svg function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Stress Captions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Lastly, we need to draw the stress captions. These are a bit tricky to position
    inside the drawing, but we solved the hardest part earlier in the caption_to_svg
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the missing code in [Listing 18-10](ch18.xhtml#ch18lis10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-10: Bar stress to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import Vector from *geom2d* and the caption_to_svg function we implemented
    earlier in this chapter. Then, we declare three constants:'
  prefs: []
  type: TYPE_NORMAL
- en: __I_VERSOR is the *î* versor to represent the horizontal direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __STRESS_DISP is the distance we use to separate the caption from the bar’s
    geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __DECIMAL_POS is the number of decimals we use to format the stress values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then comes the implementation of the bar_stress_to_svg function. The first thing
    we want to do in this function is compute the geometry of the bar we’re adding
    a caption to, with exactly the same scale as the drawing itself ➊. We want our
    caption to be aligned with the drawing of the bar; thus, we need its geometry
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the bar’s geometry normal versor; we need this direction to
    compute the caption’s position. Then, we compute the caption’s origin point, called
    position, by displacing the bar’s middle point in the direction of the normal
    versor an amount equal to __STRESS_DISP ➋. [Figure 18-7](ch18.xhtml#ch18fig7)
    illustrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-7: Positioning the bar caption*'
  prefs: []
  type: TYPE_NORMAL
- en: We also need the bar’s angle with the *î* versor ➌; this is the angle we’ll
    rotate the caption to align it with the bar.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the center point and the rotation angle, we simply need to
    return the result of calling the caption_to_svg function with these values as
    arguments ➍. For the caption’s text, we use the Greek letter *σ* (sigma), which
    is typically used to refer to mechanical stresses, followed by the bar’s stress
    value rounded to four decimals.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note that the label color is the same as the bar, and thus we get it
    from the bar_color function.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Result**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After all the code we’ve written, your *bar_svg.py* file should look like [Listing
    18-11](ch18.xhtml#ch18lis11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-11: Bar to SVG result*'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your code looks the same as [Listing 18-11](ch18.xhtml#ch18lis11),
    because we won’t be writing unit tests in this chapter. Covering our SVG generation
    functions with tests would be a great idea; there is quite a bit of logic here.
    But to keep the chapter a reasonable length, we won’t be doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time for the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Nodes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the *out* directory, create a new file named *node_svg.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- bar_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- node_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: In this file, enter the code in [Listing 18-12](ch18.xhtml#ch18lis12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-12: Node to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import a few things—make sure you get them all. Then, we define the
    nodes_to_svg function with the list of StrNodeSolution instances and the settings
    and config dictionaries as input parameters. This function maps each node in the
    nodes list to its SVG representation, which is obtained by calling an internal
    function: node_to_svg ➏. The mapping is done using a list comprehension.'
  prefs: []
  type: TYPE_NORMAL
- en: The node_to_svg internal function operates on a single node, and it has access
    to the host function parameters ➊. The first thing it does is save some configuration
    parameters in variables.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the displaced position of the node ➋ and the position for the
    caption, which will be the node’s ID ➌. The caption’s position is obtained by
    displacing the node’s position an amount equal to its radius both horizontally
    and vertically. [Figure 18-8](ch18.xhtml#ch18fig8) illustrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-8: Node caption positioning*'
  prefs: []
  type: TYPE_NORMAL
- en: The node_to_svg function returns an SVG group consisting of a circle representing
    the node itself ➍ and the caption ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Our nodes are ready! Let’s add their external reaction forces.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Node Reactions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll also include the reaction forces of the externally constrained nodes in
    our SVG diagram. We’ll represent these as arrows with a caption, similar to [Figure
    18-9](ch18.xhtml#ch18fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-9: Node reaction*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ll draw external loads and reactions the same way, let’s write a function
    that draws a Vector geometric primitive as an arrow with a caption; that way we
    can use it for both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Vectors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the *out* directory, create a new file named *vector_svg.py*. Your *out*
    directory should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- bar_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- node_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- vector_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: In this file, enter the code in [Listing 18-13](ch18.xhtml#ch18lis13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-13: Vector to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define three constants:'
  prefs: []
  type: TYPE_NORMAL
- en: __I_VERSOR is used to compute an angle with the horizontal direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __CAPTION_DISP is the separation between the vector’s baseline and the caption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __DECIMAL_POS formats the vector coordinates using a fixed number of decimals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then comes the vector_to_svg function, which has the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: position is the vector’s base point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vector is the vector itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scale is applied to the vector to shorten or lengthen it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: color is the stroke and font colors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: config is the configuration dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the function, we create a segment to represent the vector’s baseline ➊. The
    start point for the segment is the passed-in position displaced by the vector
    (also passed as an argument to the function) and using a scale of -scale. We want
    the vector’s arrow located at the origin point; thus, the end point for the segment
    is in the opposite direction of the vector. You can see this configuration of
    the vector segment points illustrated in [Figure 18-10](ch18.xhtml#ch18fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-10: Vector segment end points*'
  prefs: []
  type: TYPE_NORMAL
- en: We also compute the caption’s origin point using the segment’s start point displaced
    in the normal direction of the segment’s direction ➋ (see [Figure 18-11](ch18.xhtml#ch18fig11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-11: Node reaction caption’s position*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then there are two functions we haven’t implemented yet: svg_arrow and svg_caption.
    These are the functions that will draw the arrow and the caption. We’ll get to
    them shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we return an SVG group consisting of the results of the svg_arrow and
    svg_caption functions ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement the two missing functions. Enter the missing code in [Listing
    18-14](ch18.xhtml#ch18lis14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-14: Vector to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: The svg_arrow function first saves the width and arrow_size configuration values
    inside variables. Then it returns our SVG arrow primitive, passing it the segment,
    the arrow_size for both the arrow width and length, and the list of attributes
    including the stroke color and width ➊. Recall that our svg.arrow function draws
    the arrow located at the segment’s end point.
  prefs: []
  type: TYPE_NORMAL
- en: The svg_caption function returns the result of calling the svg_caption function
    with the caption string, origin point, rotation angle, color, and configuration
    dictionary ➋. The caption with the right format is computed using our Vector class’s
    to_formatted_str method. This method isn’t implemented yet, so let’s write it
    to create a string with the vector components and norm.
  prefs: []
  type: TYPE_NORMAL
- en: Open the *geom2d/vector.py* file and enter the code in [Listing 18-15](ch18.xhtml#ch18lis15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-15: Vector to formatted string*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also need a similar method in the Point class to format the position of
    the nodes in the text representation of the solution. Open *geom2d/point.py* and
    enter the code in [Listing 18-16](ch18.xhtml#ch18lis16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-16: Point to formatted string*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented a way of drawing vectors with a caption for their
    coordinates, let’s use our implementation to display the node reactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Reaction Forces**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the *out* directory, create a new file named *reaction_svg.py*. Your *out*
    directory should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- bar_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- node_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- reaction_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- vector_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: In this newly created file, enter the code in [Listing 18-17](ch18.xhtml#ch18lis17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-17: Node reactions to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: In this file, we define node_reactions_to_svg. Each externally constrained node
    in the structure solution is mapped to its SVG reaction using a list comprehension
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using an inner function to produce the SVG representation of each solution
    node: reaction_svg. This function first obtains the displaced position of the
    resulting node (with disp_scale applied) ➊. Then it asks the solution structure
    for the reaction in the node ➋. With these pieces of information, we can create
    the SVG representation of the reaction vector using the vector_to_svg function
    ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Loads***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last things we want to draw in the result image are the loads applied to
    the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *out* directory, create a new file named *load_svg.py*. Your *out* directory
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- bar_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- load_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- node_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- reaction_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- vector_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: In *load_svg.py*, enter the code in [Listing 18-18](ch18.xhtml#ch18lis18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-18: Loads to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we define a function, loads_to_svg, receiving three arguments:
    the StrNodeSolution list and the settings and config dictionaries. The function
    relies on two inner functions: svg_node_loads and svg_load. We use a list comprehension
    to map each node that has external loads in the passed-in nodes list to its SVG
    representation ➍. We use the is_loaded property of each node to filter the nodes
    that are externally loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The svg_node_loads internal function first gets the displaced position of the
    solution node ➊ and then returns an SVG group of all the loads in the node ➋.
    Each load is mapped to an SVG vector using the second internal function: svg_load.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The svg_load function is straightforward: it simply calls the vector_to_svg
    function passing the appropriate parameters ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have all of our SVG generation code ready! We just need to put
    it all together, and we can finally start drawing structure solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Putting It All Together***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now open the *svg.py* file and add the functions we’ve written into the
    structure_solution_to_svg function. Enter the missing code, following [Listing
    18-19](ch18.xhtml#ch18lis19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-19: Structure solution to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the bars_to_svg, loads_to_svg, nodes_to_svg, and node _reactions_to_svg
    functions ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside structure_solution_to_svg, we call each of the functions to generate
    the corresponding SVG code ➋. The results are stored in svg_bars, svg_nodes, svg_react,
    and svg_loads. These are concatenated in one list that we pass to the svg_content
    function ➌. The order is important: the SVG primitives toward the end of the list
    will appear in front of those at the beginning of it.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Final Result***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve followed along, your *svg.py* file should be similar to [Listing 18-20](ch18.xhtml#ch18lis20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-20: Structure solution to SVG*'
  prefs: []
  type: TYPE_NORMAL
- en: We have everything that we need, but before we put it to work in the next chapter,
    let’s also prepare a textual representation of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**From Structure Solution to Text**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A visual diagram helps us understand the structural deformations; because we
    color the bars depending on the stress they’re subject to, it’s also a good way
    to see which bars are compressed and which are stretched. At the same time, it
    may be simpler to study the numeric results in a text format, and we may want
    to have them do some other calculations. The formats are complementary, and our
    structural analysis program will output both.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write the displacement of each node in a text file using the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the node has external constraints, we want to check its reactions as well.
    In this case, we can include one last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The bars will follow this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s write a function that generates this plaintext representation of a structure
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: '***Structure Solution’s String***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we write the function that generates the plaintext representation, let’s
    write a useful helper function that takes a list of strings and returns a single
    string with all those strings concatenated by a “newline” character.
  prefs: []
  type: TYPE_NORMAL
- en: We want to define each of the result values as a string of its own, but the
    function we’ll implement returns one and only one string, which is then written
    into a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new file for this helper function. In your *utils* package,
    create a new Python file named *strings.py*. This package should now have the
    following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: utils
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- lists.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- pairs.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- strings.py'
  prefs: []
  type: TYPE_NORMAL
- en: In this *strings.py* file, enter the function in [Listing 18-21](ch18.xhtml#ch18lis21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-21: List to string*'
  prefs: []
  type: TYPE_NORMAL
- en: This list_to_string function maps a list of strings into a single string where
    each entry is separated from the next using the ’\n’ (newline) character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now outline the text output function’s logic. First, create a new *text.py*
    file inside the *structures/out* package, which now should have the following
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- bar_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- captions_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- load_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- node_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- reaction_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- text.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- vector_svg.py'
  prefs: []
  type: TYPE_NORMAL
- en: In this *text.py* file, enter the code in [Listing 18-22](ch18.xhtml#ch18lis22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-22: Structure solution to text*'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we import the StrBarSolution, StrNodeSolution, and Structure
    Solution classes, as well as the list_to_string function. We define two constants,
    one to specify the number of decimal positions we want to use to format the resulting
    values, __DECIMAL_POS ➊, and a separation string list, __SEPARATION, which we
    use to separate the different sections in the result string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes the main function, structure_solution_to_string. This function receives
    only one parameter: the structure solution. It uses two private functions: one
    to convert the string representation of the nodes ➋ and another to convert the
    bars ➌. The results are stored as list strings in the nodes_text and bars_text
    variables. These lists are concatenated with the __SEPARATION strings in the middle
    and passed to list_to_string ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: After this main function, we define the rest of the private functions, but they’ve
    yet to be implemented. Let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Nodes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with the nodes. Fill the __nodes_to_string and __node_to_string
    functions with the code in [Listing 18-23](ch18.xhtml#ch18lis23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-23: Nodes to text*'
  prefs: []
  type: TYPE_NORMAL
- en: The first function, __nodes_to_string, uses a list comprehension to map each
    node in the result to its textual representation, for which it uses the __node_to_string
    function ➊. This function requires not only the node but also the entire structure
    object as parameters. Recall that the reaction force of a node is computed by
    the structure solution instances, not by the nodes themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The __node_to_string function first obtains the formatted strings for the node’s
    original position ➋, the global displacement vector, and the displaced position.
    We use the to_formatted_str method from the Point and Vector classes to handle
    the point coordinates formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare a list, strings ➌, where we place the strings we just obtained.
    Note that, except for the first one, which serves as header, the strings all start
    with the tab (\t) character. With this, we achieve the nice formatting we defined
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we generate the reaction force string if the node is externally constrained
    ➍. For this, we first use the structure solution class to compute the reaction
    for the given node, then format it using the to_formatted_str method, and lastly
    append it to the strings list.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to convert the obtained string list into a single string using
    the helper list_to_string function with a newline character appended to the end
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Bars***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now fill in the functions for the bars. We’ll use some UTF-8 characters
    to make the text a bit more visual. These characters are optional; you can decide
    not to add them in your code and just go with the labels. If you decide to use
    them, we’ll explain how to do this in the section “The Unicode Characters” on
    [page 18](ch01.xhtml#page_18).
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code in [Listing 18-24](ch18.xhtml#ch18lis24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-24: Bars to text*'
  prefs: []
  type: TYPE_NORMAL
- en: The __bars_to_string function uses a list comprehension to map each bar in the
    list to its textual representation ➊. This text is produced by the second function,
    __bar_to_string.
  prefs: []
  type: TYPE_NORMAL
- en: In __bar_to_string, we first prepare some strings ➋ that we later return concatenated
    using the list_to_string function ➌ and nodes_str indicates the bar’s node IDs,
    with a → character separating them.
  prefs: []
  type: TYPE_NORMAL
- en: The type_str indicates whether the bar is in traction or compression, depending
    on the sign of the bar’s stress. We’re using the ⊕ symbol to decorate the TENSION
    text and ⊖ for the COMPRESSION text. This detail makes the result stand out more
    to the eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes the elongation, strain, and stress strings. These are the bar’s
    result values formatted to have __DECIMAL_POS decimal positions. Here strain is
    the exception; instead of rounding it, we want to use scientific notation with
    three decimal positions (’{:.3e}’). The strain is usually a small value, orders
    of magnitude smaller than the stress, so if we try to round it to, say, four decimal
    positions, the result will still be zero: 0.0000$. Using the ’{:.3e}’ format,
    we’ll get things like 1.259e–05 instead.'
  prefs: []
  type: TYPE_NORMAL
- en: When formatting values in our engineering applications, we have to be aware
    of the orders of magnitude. A wrongly formatted value, where the precision required
    is lost, renders the app useless.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Unicode Characters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The icons we’re using in the code, →, *Δ*, *ϵ*, ⊕, and ⊖, are all Unicode characters.
    Every operating system has a way of inserting these characters. If you do a quick
    Google search, you should be able to find how to access them in your OS. For instance,
    macOS uses the CMD-CTRL-spacebar key combination to open the symbols dialog, which
    is how I inserted those in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also insert these characters using their code in a Python string like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you opt for this alternative, you’ll need to replace the characters in the
    listings with their code. [Table 18-2](ch18.xhtml#ch18tab2) shows the characters
    we’ve used and their Unicode code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Unicode Characters'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Unicode** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| ⊕ | \u2295 | Tension stress |'
  prefs: []
  type: TYPE_TB
- en: '| ⊖ | \u2296 | Compression stress |'
  prefs: []
  type: TYPE_TB
- en: '| → | \u279c | Separates the node IDs of a bar (1 →2) |'
  prefs: []
  type: TYPE_TB
- en: '| *Δ* | \u0394 | Length increment (*Δl*) |'
  prefs: []
  type: TYPE_TB
- en: '| *ϵ* | \u03f5 | Strain |'
  prefs: []
  type: TYPE_TB
- en: '| *σ* | \u03c3 | Stress |'
  prefs: []
  type: TYPE_TB
- en: '***Putting It All Together***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve followed along, your result should look like [Listing 18-25](ch18.xhtml#ch18lis25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-25: Structure solution to text*'
  prefs: []
  type: TYPE_NORMAL
- en: In less than 70 lines of code we’ve written a function capable of generating
    a text representation of the structure solution model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we implemented the code that creates vector diagrams representing
    the structure solution model. We split the resulting drawing process into chunks
    to make the code more manageable, and then we put it all together in the *svg.py*
    file, specifically, in the structure_solution_to_svg function.
  prefs: []
  type: TYPE_NORMAL
- en: We then implemented a function, structure_solution_to_string, that produces
    a plaintext representation of the structure solution.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have everything we need to put our application together. In the final
    chapter, we’ll do just that.
  prefs: []
  type: TYPE_NORMAL
