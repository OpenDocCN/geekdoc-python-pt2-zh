["```py\nmin_dist = MAX_VAL\nfor val in vals:\n    dist = distance(query, val)\n    if dist < MAX_VAL:\n        min_dist = dist\n\n```", "```py\ndef getImages(imageDir):\n    \"\"\"\n    given a directory of images, return a list of Images\n    \"\"\"\n  ❶ files = os.listdir(imageDir)\n    images = []\n    for file in files:\n      ❷ filePath = os.path.abspath(os.path.join(imageDir, file))\n        try:\n            # explicit load so we don't run into resource crunch\n          ❸ fp = open(filePath, \"rb\")\n            im = Image.open(fp)\n            images.append(im)\n            # force loading the image data from file\n          ❹ im.load()\n            # close the file\n          ❺ fp.close()\n        except:\n            # skip\n            print(\"Invalid image: %s\" % (filePath,))\n    return images\n\n```", "```py\ndef getAverageRGB(image):\n    \"\"\"\n    return the average color value as (r, g, b) for each input image\n    \"\"\"\n    # get each tile image as a numpy array\n  ❶ im = np.array(image)\n    # get the shape of each input image\n  ❷ w,h,d = im.shape\n    # get the average RGB value\n  ❸ return tuple(np.average(im.reshape(w*h, d), axis=0))\n\n```", "```py\ndef splitImage(image, size):\n    \"\"\"\n    given the image and dimensions (rows, cols), return an m*n list of images\n    \"\"\"\n  ❶ W, H = image.size[0], image.size[1]\n  ❷ m, n = size\n  ❸ w, h = int(W/n), int(H/m)\n    # image list\n    imgs = []\n    # generate a list of images\n    for j in range(m):\n        for i in range(n):\n            # append cropped image\n      ❹ imgs.append(image.crop((i*w, j*h, (i+1)*w, (j+1)*h)))\n    return imgs\n\n```", "```py\ndef getBestMatchIndex(input_avg, avgs):\n    \"\"\"\n    return index of the best image match based on average RGB value distance\n    \"\"\"\n    # input image average\n    avg = input_avg\n    # get the closest RGB value to input, based on RGB distance\n    index = 0\n  ❶ min_index = 0\n  ❷ min_dist = float(\"inf\")\n  ❸ for val in avgs:\n      ❹ dist = ((val[0] - avg[0])*(val[0] - avg[0]) +\n                (val[1] - avg[1])*(val[1] - avg[1]) +\n                (val[2] - avg[2])*(val[2] - avg[2]))\n      ❺ if dist < min_dist:\n            min_dist = dist\n            min_index = index\n        index += 1\n    return min_index\n\n```", "```py\ndef getBestMatchIndicesKDT(qavgs, kdtree):\n    \"\"\"\n    return indices of best Image matches based on RGB value distance\n    uses a k-d tree\n    \"\"\"\n    # e.g., [array([2.]), array([9], dtype=int64)]\n  ❶ res = list(kdtree.query(qavgs, k=1))\n  ❷ min_indices = res[1]\n    return min_indices\n\n```", "```py\ndef createImageGrid(images, dims):\n    \"\"\"\n    given a list of images and a grid size (m, n), create a grid of images\n    \"\"\"\n  ❶ m, n = dims\n    # sanity check\n    assert m*n == len(images)\n    # get the maximum height and width of the images\n    # don't assume they're all equal\n  ❷ width = max([img.size[0] for img in images])\n    height = max([img.size[1] for img in images])\n    # create the target image\n  ❸ grid_img = Image.new('RGB', (n*width, m*height))\n    # paste the tile images into the image grid\n    for index in range(len(images)):\n      ❹ row = int(index/n)\n      ❺ col = index - n*row\n      ❻ grid_img.paste(images[index], (col*width, row*height))\n    return grid_img\n\n```", "```py\ndef createPhotomosaic(target_image, input_images, grid_size,\n                      reuse_images, use_kdt):\n    \"\"\"\n    creates photomosaic given target and input images\n    \"\"\"\n    print('splitting input image...')\n    # split target image\n  ❶ target_images = splitImage(target_image, grid_size)\n    print('finding image matches...')\n    # for each target image, pick one from input\n    output_images = []\n    # for user feedback\n    count = 0\n  ❷ batch_size = int(len(target_images)/10)\n    # calculate input image averages\n    avgs = []\n  ❸ for img in input_images:\n        avgs.append(getAverageRGB(img))\n    # compute target averages\n    avgs_target = []\n  ❹ for img in target_images:\n        # target subimage average\n        avgs_target.append(getAverageRGB(img))\n\n```", "```py\n    # use k-d tree for average match?\n    if use_kdt:\n        # create k-d tree\n      ❶ kdtree = KDTree(avgs)\n        # query k-d tree\n      ❷ match_indices = getBestMatchIndicesKDT(avgs_target, kdtree)\n        # process matches\n      ❸ for match_index in match_indices:\n          ❹ output_images.append(input_images[match_index])\n\n```", "```py\n    else:\n        # use linear search\n      ❶ for avg in avgs_target:\n            # find match index\n          ❷ match_index = getBestMatchIndex(avg, avgs)\n          ❸ output_images.append(input_images[match_index])\n            # user feedback\n          ❹ if count > 0 and batch_size > 10 and count % batch_size == 0:\n                print('processed %d of %d...' %(count, len(target_images)))\n            count += 1\n            # remove selected image from input if flag set\n          ❺ if not reuse_images:\n                input_images.remove(match)\n\n```", "```py\n    print('creating mosaic...')\n    # draw mosaic to image\n  ❶ mosaic_image = createImageGrid(output_images, grid_size)\n    # return mosaic\n    return mosaic_image\n\n```", "```py\n    # parse arguments\n    parser = argparse.ArgumentParser(description='Creates a photomosaic from\n                                     input images')\n    # add arguments\n    parser.add_argument('--target-image', dest='target_image', required=True)\n    parser.add_argument('--input-folder', dest='input_folder', required=True)\n    parser.add_argument('--grid-size', nargs=2, dest='grid_size',\n                        required=True)\n    parser.add_argument('--output-file', dest='outfile', required=False)\n    parser.add_argument('--kdt', action='store_true', required=False)\n\n```", "```py\n        print('resizing images...')\n        # for given grid size, compute the maximum width and height of tiles\n      ❶ dims = (int(target_image.size[0]/grid_size[1]),\n                int(target_image.size[1]/grid_size[0]))\n        print(\"max tile dims: %s\" % (dims,))\n        # resize\n        for img in input_images:\n          ❷ img.thumbnail(dims)\n\n```", "```py\nimport timeit\n# start timing\n❶ start = timeit.default_timer()\n# run some code here...\n--`snip`--\n# stop timing\n❷ stop = timeit.default_timer()\nprint('Execution time: %f seconds' % (stop - start, ))\n\n```", "```py\n$ `python photomosaic.py --target-image test-data/cherai.jpg --input-folder`\n`  test-data/set6/ --grid-size 128 128`\nreading input folder...\nstarting photomosaic creation...\nresizing images...\nmax tile dims: (23, 15)\nsplitting input image...\nfinding image matches...\nprocessed 1638 of 16384...\nprocessed 3276 of 16384...\nprocessed 4914 of 16384...\nprocessed 6552 of 16384...\nprocessed 8190 of 16384...\nprocessed 9828 of 16384...\nprocessed 11466 of 16384...\nprocessed 13104 of 16384...\nprocessed 14742 of 16384...\nprocessed 16380 of 16384...\ncreating mosaic...\nsaved output to mosaic.png\ndone.\nExecution time:    setup: 0.402047 seconds\n❶ Execution time: creation: 2.123931 seconds\nExecution time:    total: 2.525978 seconds\n\n```", "```py\n$ `python photomosaic.py --target-image test-data/cherai.jpg --input-folder`\n`  test-data/set6/ --grid-size 128 128 --kdt`\nreading input folder...\nstarting photomosaic creation...\nresizing images...\nmax tile dims: (23, 15)\nsplitting input image...\nfinding image matches...\ncreating mosaic...\nsaved output to mosaic.png\ndone.\nExecution time:    setup: 0.410334 seconds\n❶ Execution time: creation: 1.089237 seconds\nExecution time:    total: 1.499571 seconds\n\n```", "```py\n\"\"\"\nphotomosaic.py\nCreates a photomosaic given a target image and a folder of input images.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport os, random, argparse\nfrom PIL import Image\nimport numpy as np\nfrom scipy.spatial import KDTree\nimport timeit\ndef getAverageRGBOld(image):\n    \"\"\"\n    given PIL Image, return average value of color as (r, g, b)\n    \"\"\"\n    # no. of pixels in image\n    npixels = image.size[0]*image.size[1]\n    # get colors as [(cnt1, (r1, g1, b1)), ...]\n    cols = image.getcolors(npixels)\n    # get [(c1*r1, c1*g1, c1*g2), ...]\n    sumRGB = [(x[0]*x[1][0], x[0]*x[1][1], x[0]*x[1][2]) for x in cols]\n    # calculate (sum(ci*ri)/np, sum(ci*gi)/np, sum(ci*bi)/np)\n    # the zip gives us [(c1*r1, c2*r2, ...), (c1*g1, c1*g2, ...), ...]\n    avg = tuple([int(sum(x)/npixels) for x in zip(*sumRGB)])\n    return avg\ndef getAverageRGB(image):\n    \"\"\"\n    given PIL Image, return average value of color as (r, g, b)\n    \"\"\"\n    # get image as numpy array\n    im = np.array(image)\n    # get shape\n    w,h,d = im.shape\n    # get average\n    return tuple(np.average(im.reshape(w*h, d), axis=0))\ndef splitImage(image, size):\n    \"\"\"\n    given Image and dims (rows, cols) returns an m*n list of Images\n    \"\"\"\n    W, H = image.size[0], image.size[1]\n    m, n = size\n    w, h = int(W/n), int(H/m)\n    # image list\n    imgs = []\n    # generate list of images\n    for j in range(m):\n        for i in range(n):\n            # append cropped image\n            imgs.append(image.crop((i*w, j*h, (i+1)*w, (j+1)*h)))\n    return imgs\ndef getImages(imageDir):\n    \"\"\"\n    given a directory of images, return a list of Images\n    \"\"\"\n    files = os.listdir(imageDir)\n    images = []\n    for file in files:\n        filePath = os.path.abspath(os.path.join(imageDir, file))\n        try:\n            # explicit load so we don't run into resource crunch\n            fp = open(filePath, \"rb\")\n            im = Image.open(fp)\n            images.append(im)\n            # force loading image data from file\n            im.load()\n            # close the file\n            fp.close()\n        except:\n            # skip\n            print(\"Invalid image: %s\" % (filePath,))\n    return images\ndef getBestMatchIndex(input_avg, avgs):\n    \"\"\"\n    return index of best Image match based on RGB value distance\n    \"\"\"\n    # input image average\n    avg = input_avg\n    # get the closest RGB value to input, based on x/y/z distance\n    index = 0\n    min_index = 0\n    min_dist = float(\"inf\")\n    for val in avgs:\n        dist = ((val[0] - avg[0])*(val[0] - avg[0]) +\n                (val[1] - avg[1])*(val[1] - avg[1]) +\n                (val[2] - avg[2])*(val[2] - avg[2]))\n        if dist < min_dist:\n            min_dist = dist\n            min_index = index\n        index += 1\n    return min_index\ndef getBestMatchIndicesKDT(qavgs, kdtree):\n    \"\"\"\n    return indices of best Image matches based on RGB value distance\n    using a k-d tree\n    \"\"\"\n    # e.g., [array([2.]), array([9], dtype=int64)]\n    res = list(kdtree.query(qavgs, k=1))\n    min_indices = res[1]\n    return min_indices\ndef createImageGrid(images, dims):\n    \"\"\"\n    given a list of images and a grid size (m, n), create\n    a grid of images\n    \"\"\"\n    m, n = dims\n    # sanity check\n    assert m*n == len(images)\n    # get max height and width of images\n    # i.e., not assuming they are all equal\n    width = max([img.size[0] for img in images])\n    height = max([img.size[1] for img in images])\n    # create output image\n    grid_img = Image.new('RGB', (n*width, m*height))\n    # paste images\n    for index in range(len(images)):\n        row = int(index/n)\n        col = index - n*row\n        grid_img.paste(images[index], (col*width, row*height))\n    return grid_img\ndef createPhotomosaic(target_image, input_images, grid_size,\n                      reuse_images, use_kdt):\n    \"\"\"\n    creates photomosaic given target and input images\n    \"\"\"\n    print('splitting input image...')\n    # split target image\n    target_images = splitImage(target_image, grid_size)\n    print('finding image matches...')\n    # for each target image, pick one from input\n    output_images = []\n    # for user feedback\n    count = 0\n    batch_size = int(len(target_images)/10)\n    # calculate input image averages\n    avgs = []\n    for img in input_images:\n        avgs.append(getAverageRGB(img))\n    # compute target averages\n    avgs_target = []\n    for img in target_images:\n        # target subimage average\n        avgs_target.append(getAverageRGB(img))\n    # use k-d tree for average match?\n    if use_kdt:\n        # create k-d tree\n        kdtree = KDTree(avgs)\n        # query k-d tree\n        match_indices = getBestMatchIndicesKDT(avgs_target, kdtree)\n        # process matches\n        for match_index in match_indices:\n            output_images.append(input_images[match_index])\n    else:\n        # use linear search\n        for avg in avgs_target:\n            # find match index\n            match_index = getBestMatchIndex(avg, avgs)\n            output_images.append(input_images[match_index])\n            # user feedback\n            if count > 0 and batch_size > 10 and count % batch_size == 0:\n                print('processed {} of {}...'.format(count,\n                                                     len(target_images)))\n            count += 1\n            # remove selected image from input if flag set\n            if not reuse_images:\n                input_images.remove(match)\n    print('creating mosaic...')\n    # draw mosaic to image\n    mosaic_image = createImageGrid(output_images, grid_size)\n    # return mosaic\n    return mosaic_image\n# gather our code in a main() function\ndef main():\n    # command line args are in sys.argv[1], sys.argv[2]...\n    # sys.argv[0] is the script name itself and can be ignored\n    # parse arguments\n    parser = argparse.ArgumentParser(description='Creates a photomosaic\n                                                      from input images')\n    # add arguments\n    parser.add_argument('--target-image', dest='target_image', required=True)\n    parser.add_argument('--input-folder', dest='input_folder', required=True)\n    parser.add_argument('--grid-size', nargs=2, dest='grid_size',\n                        required=True)\n    parser.add_argument('--output-file', dest='outfile', required=False)\n    parser.add_argument('--kdt', action='store_true', required=False)\n    args = parser.parse_args()\n    # start timing\n    start = timeit.default_timer()\n    ###### INPUTS ######\n    # target image\n    target_image = Image.open(args.target_image)\n    # input images\n    print('reading input folder...')\n    input_images = getImages(args.input_folder)\n    # check if any valid input images found\n    if input_images == []:\n        print('No input images found in %s. Exiting.' % (args.input_folder, ))\n        exit()\n    # shuffle list - to get a more varied output?\n    random.shuffle(input_images)\n    # size of grid\n    grid_size = (int(args.grid_size[0]), int(args.grid_size[1]))\n    # output\n    output_filename = 'mosaic.png'\n    if args.outfile:\n        output_filename = args.outfile\n    # reuse any image in input\n    reuse_images = True\n    # resize the input to fit original image size?\n    resize_input = True\n    # use k-d trees for matching\n    use_kdt = False\n    if args.kdt:\n        use_kdt = True\n    ##### END INPUTS #####\n    print('starting photomosaic creation...')\n    # if images can't be reused, ensure m*n <= num_of_images\n    if not reuse_images:\n        if grid_size[0]*grid_size[1] > len(input_images):\n            print('grid size less than number of images')\n            exit()\n    # resizing input\n    if resize_input:\n        print('resizing images...')\n        # for given grid size, compute max dims w,h of tiles\n        dims = (int(target_image.size[0]/grid_size[1]),\n                int(target_image.size[1]/grid_size[0]))\n        print(\"max tile dims: %s\" % (dims,))\n        # resize\n        for img in input_images:\n            img.thumbnail(dims)\n    # setup time\n    t1 = timeit.default_timer()\n    # create photomosaic\n    mosaic_image = createPhotomosaic(target_image, input_images, grid_size,\n                                     reuse_images, use_kdt)\n    # write out mosaic\n    mosaic_image.save(output_filename, 'PNG')\n    print(\"saved output to %s\" % (output_filename,))\n    print('done.')\n    # creation time\n    t2 = timeit.default_timer()\n    print('Execution time:    setup: %f seconds' % (t1 - start, ))\n    print('Execution time: creation: %f seconds' % (t2 - t1, ))\n    print('Execution time:    total: %f seconds' % (t2 - start, ))\n# standard boilerplate to call the main() function to begin\n# the program.\nif __name__ == '__main__':\n    main()\n\n```"]