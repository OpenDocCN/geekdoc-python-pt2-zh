<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_265"/><strong><span class="big">13</span><br/>SIMULATING AN ALIEN VOLCANO</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Quick! Name the most volcanically active body in the solar system! If you thought Earth, then you’d be mistaken—it’s Io (“EYE-oh”), one of Jupiter’s four Galilean moons.</p>
<p class="indent">The first evidence of volcanism on Io came in 1979, when <em>Voyager 1</em> made its famous fly-by of the Jovian system. But the spectacular photographs it recorded were no real surprise. Astrophysicist Stan Peale and two coauthors had already published this result based on models of Io’s interior.</p>
<p class="indent">Computer modeling is a powerful tool for understanding nature and making predictions. Here’s the general workflow:</p>
<ol>
<li class="noindent">Gather data.</li>
<li class="noindent">Analyze, interpret, and integrate the data.</li>
<li class="noindent">Generate numerical equations that explain the data.</li>
<li class="noindent">Construct a computer model that best “fits” the data.</li>
<li class="noindent">Use the model to make predictions and investigate error ranges.</li>
</ol>
<p class="indent"><span epub:type="pagebreak" id="page_266"/>Applications of computer modeling are far-reaching and include such areas as wildlife management, weather forecasts, climate predictions, hydrocarbon production, and black-hole simulations.</p>
<p class="indent">In this chapter, you’ll use a Python package called <span class="literal">pygame</span>—normally used to create games—to simulate one of Io’s volcanoes. You’ll also experiment with different types of <em>ejecta</em> (erupted particles) and compare their simulated behaviors to a photo of Io’s mammoth Tvashtar plume.</p>
<h3 class="h3a" id="lev295"><strong>Project #21: The Plumes of Io</strong></h3>
<p class="noindent"><em>Tidal heating</em> is responsible for the volcanism on Io. As its elliptical orbit carries it through the gravity fields of Jupiter and its sister moons, Io experiences variations in tidal pull. Its surface flexes up and down by as much as 100 meters, resulting in significant friction-related heating and melting in its interior. Hot magma migrates to the surface and forms great lava lakes from which degassing sulfur (S<sub>2</sub>) and sulfur dioxide (SO<sub>2</sub>) are sprayed skyward with speeds of 1 km/s. Because of Io’s low gravity and lack of atmosphere, these plumes of gas can reach heights of hundreds of kilometers (see the Tvashtar plume in <a href="ch13.xhtml#ch13fig1">Figure 13-1a</a>).</p>
<div class="image"><a id="ch13fig1"/><img src="../images/f0266-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-1: a) Io with the 330 km Tvashtar plume at the top and the shorter Prometheus plume at the 9 o’clock position; b) Io with volcanic ring deposits (NASA images)</em></p>
<p class="indent">The plumes’ pleasing umbrella shape is produced as gas and dust shoot upward, then fall back in every direction. The resulting surface deposits form concentric rings of red, green, black, and yellow. If <a href="ch13.xhtml#ch13fig1">Figure 13-1b</a> were in color, it would look a bit like a moldy pepperoni pizza.</p>
<h3 class="h3" id="lev296"><span epub:type="pagebreak" id="page_267"/><strong>A Slice of pygame</strong></h3>
<p class="noindent">The <span class="literal">pygame</span> package is a cross-platform set of Python modules that are typically used to program 2D arcade-style video games. It supports graphics, animations, sound effects, music, and multiple input devices, such as the keyboard and mouse. Learning <span class="literal">pygame</span> is more than just a fun way to learn programming. Arcade-style games have seen a resurgence in popularity thanks to the proliferation of smartphones and tablets, and mobile gaming now earns almost as much as console and PC gaming combined.</p>
<p class="indent">The <span class="literal">pygame</span> package uses the <em>Simple DirectMedia Library (SDL)</em>, which is an <em>application programming interface (API)</em>. APIs are reusable code libraries that make handling graphics fairly easy, allowing you to focus on game design while using a high-level language like Python. The Microsoft <em>DirectX</em> API is used for creating games and multimedia apps for the Windows platform. For working across multiple platforms, two open source libraries are SDL, mainly for 2D work, and <em>OpenGL (Open Graphics Library)</em> for 3D applications. As mentioned, you’ll be working with SDL, which officially supports Windows, macOS, Linux, iOS, and Android.</p>
<p class="indent">The <span class="literal">pygame</span> package also uses object-oriented programming (OOP). If you are unfamiliar with OOP or need a refresher, see “<a href="ch11.xhtml#lev256">A Brief Introduction to Object-Oriented Programming</a>” on <a href="ch11.xhtml#page_223">page 223</a>. Additionally, introductory books on Python often include a section on <span class="literal">pygame</span>, and there are whole books written on the package (see “<a href="ch13.xhtml#lev309">Further Reading</a>” on <a href="ch13.xhtml#page_281">page 281</a> for some examples).</p>
<p class="indent">Before you can continue, you’ll need to install <span class="literal">pygame</span> onto your system. Instructions for installing a free copy on your preferred platform are available at <em><a href="http://pygame.org/wiki/GettingStarted#Pygame%20Installation">http://pygame.org/wiki/GettingStarted#Pygame%20Installation</a></em>.</p>
<p class="indent">Video tutorials on how to install <span class="literal">pygame</span> are also available online. To ensure a video is appropriate to your situation, be sure to check the date of the video, the platform discussed, and the versions of <span class="literal">pygame</span> and Python in use. You can find additional instructions for Mac users with older Python installs at <em><a href="http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/">http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/</a></em>.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use <span class="literal">pygame</span> to build a 2D, gravity-based simulation of Io’s Tvashtar volcanic plume. Calibrate the plume dimensions using a NASA image. Use multiple particle types in the plume, trace the particles’ flight paths and allow the eruption to run automatically until stopped.</p>
</div>
<h3 class="h3" id="lev297"><span epub:type="pagebreak" id="page_268"/><strong>The Strategy</strong></h3>
<p class="noindent">Building a comprehensive, full-physics simulation of one of Io’s plumes is best accomplished with a supercomputer. Since you probably don’t have one of those and since your goal is to make a cool <span class="literal">pygame</span> display, you’re going to cheat by reverse-engineering the parameters you need to make SO<sub>2</sub> fit the Tvashtar plume. Remember, cheating is the gift humans give ourselves; it’s what separates us from the animals—except for the cheetahs!</p>
<p class="indent">Since the composition of Io’s plumes is already known, you’re going to calibrate your gravity field to SO<sub>2</sub> and sulfur (S<sub>2</sub>) gas, which conveniently have the same atomic weight. When the flight paths of these particles match the dimensions of the Tvashtar plume in the NASA photograph, you will scale the velocity of other ejected particles, based on the difference in atomic weight between the new particle and SO<sub>2</sub>, to see how particle type affects plume dimensions. Lighter particles will be ejected higher and vice versa.</p>
<h4 class="h4" id="lev298"><strong><em>Using a Game Sketch to Plan</em></strong></h4>
<p class="noindent">I suggest you begin any <span class="literal">pygame</span> project with a sketch of how the game should look and how the action should progress. Even the simplest arcade games can become complicated, and a sketch will help you manage the complexity. Among the many things you must consider in a typical game are player actions, scorekeeping, messages and instructions, game entities and their interactions (such as collisions, sound effects, and music), and game-ending conditions.</p>
<p class="indent">Sketching the game—or in this case, the simulation—is best done on a whiteboard, either real or digital. My layout for the Io volcano simulator is shown in <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>.</p>
<div class="image"><a id="ch13fig2"/><img src="../images/f0268-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-2: Game sketch of Io volcano simulator</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_269"/>The sketch in <a href="ch13.xhtml#ch13fig2">Figure 13-2</a> contains guidelines and key behaviors for the volcano simulator:</p>
<ul>
<li class="noindent"><strong>No direct player interactions.</strong> You’ll control the simulation by editing the Python code, not through the mouse or keyboard.</li>
<li class="noindent"><strong>The background will be a NASA image of a plume.</strong> To calibrate the simulation to SO<sub>2</sub>/S<sub>2</sub> particles, you’ll need a backdrop of the actual Tvashtar plume.</li>
<li class="noindent"><strong>The launch point pivots.</strong> The particles should be ejected from the central base of the plume image and should spray out over a range of angles, rather than just straight up.</li>
<li class="noindent"><strong>Particles are chosen at random.</strong> The program will choose the type of particle at random. Each particle will have a unique color that distinguishes it from others.</li>
<li class="noindent"><strong>The particle flight path should be visible and persistent.</strong> The flight of each particle should be recorded as a line that remains visible throughout the simulation, and the line color should match the particle color.</li>
<li class="noindent"><strong>A color-coded legend lists the particle types.</strong> The program should post a legend with the particle names in the upper-left corner of the screen. The font colors should match the particle colors, and the legend should print on top of particle paths so that it’s always visible.</li>
<li class="noindent"><strong>Particle motion should stop at the level at which SO</strong><sub>2</sub> <strong>particles intersect the surface of Io.</strong> The simulation is tuned to the behavior of SO<sub>2</sub>, so falling particles should stop at the appropriate location for an SO<sub>2</sub> plume.</li>
<li class="noindent"><strong>There are no sound effects.</strong> In space, no one can hear you scream.</li></ul>
<p class="indent">Once you complete your diagram, you can begin picking parts from it and listing them in logical order; this breaks the plan into a series of manageable steps. For example, you’ll need to find and prepare an appropriate background image, decide which particles you want to simulate and look up their atomic weights, locate a launch point, calibrate SO<sub>2</sub> behavior to the plume image, and so on. You’re still writing pseudocode, but a game sketch makes it a much more enjoyable process!</p>
<h4 class="h4" id="lev299"><strong><em>Planning the Particle Class</em></strong></h4>
<p class="noindent">Since this simulation is based on <em>particles</em>, it makes sense to have an OOP <span class="literal">Particle</span> class to serve as a blueprint for multiple particle types. The class should support the random generation of particle types, and constants and other attributes common to all particles can be stored as <em>class attributes</em>. These are attributes assigned at the same indentation level as methods. The <span class="literal">Particle</span> class should also contain methods that allow instances of the class to be ejected, affected by gravity, made visible, and destroyed when they move beyond the boundaries of the simulation.</p>
<p class="indent"><span epub:type="pagebreak" id="page_270"/>The attributes and methods used in the class are shown in <a href="ch13.xhtml#ch13tab1">Tables 13-1</a> and <a href="ch13.xhtml#ch13tab2">13-2</a>, respectively. Class attributes—that is, those shared by all instances of the class—are shown in italics; otherwise, instance attributes are shown.</p>
<p class="tabcap" id="ch13tab1"><strong>Table 13-1:</strong> Attributes of the <span class="literal">Particle</span> Class (<em>Italics</em> = Class Attribute)</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Attributes</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Attribute description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>gases_colors</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Dictionary of available particle types and their colors</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>VENT_LOCATION_XY</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">x- and y-location of mouth of Tvashtar volcano in image</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>IO_SURFACE_Y</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Io surface y-value at SO<sub>2</sub> plume margin in image</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>VELOCITY_SO2</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Speed (pixels per frame) of SO<sub>2</sub> particle</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>GRAVITY</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Acceleration of gravity in pixels per frame</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>vel_scalar</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Dictionary of ratios of SO<sub>2</sub>/particle atomic weights</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">screen</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The game screen</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">background</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">A NASA image of the Tvashtar plume</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">image</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">A square <span class="literal">pygame</span> surface representing a particle</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">rect</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">A rectangular object used to get surface dimensions</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">gas</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The type of an individual particle (SO<sub>2</sub>, CO<sub>2</sub>, etc.)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">color</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Color of an individual particle type</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">vel</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Particle’s velocity relative to SO<sub>2</sub> velocity</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">x</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Particle’s x-location</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">y</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Particle’s y-location</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">dx</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Particle’s delta-x</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">dy</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Particle’s delta-y</p></td>
</tr>
</tbody>
</table>
<p class="tabcap" id="ch13tab2"><strong>Table 13-2:</strong> Methods of the <span class="literal">Particle</span> Class</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">__init__()</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Initializes and sets up parameters for randomly selected particle type</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">vector()</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Randomly selects ejection orientation and calculates motion vector (dx and dy)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">update()</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Adjusts particle trajectory for gravity, draws path behind particle, and destroys particles that move beyond the boundaries of the simulation</p></td>
</tr>
</tbody>
</table>
<p class="indent">I will explain each of these attributes and methods in more detail in the next section.</p>
<h3 class="h3" id="lev300"><span epub:type="pagebreak" id="page_271"/><strong>The Code</strong></h3>
<p class="noindent">The <em>tvashtar.py</em> code will generate a <span class="literal">pygame</span>-based simulation of Io’s Tvashtar plume. You will also need the background image, <em>tvashtar_plume.gif</em>. Download both files from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> and keep them in the same folder.</p>
<h4 class="h4" id="lev301"><strong><em>Importing Modules, Initiating pygame, and Defining Colors</em></strong></h4>
<p class="noindent">Begin with several set-up steps, such as choosing colors, as shown in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>.</p>
<p class="margin"><em>tvashtar.py,</em> part 1</p>
<p class="programs"><span class="ent">➊</span> import sys<br/>   import math<br/>   import random<br/>   import pygame as pg<br/><br/><span class="ent">➋</span> pg.init()  # initialize pygame<br/><br/><span class="ent">➌</span> # define color table<br/>   BLACK = (0, 0, 0)<br/>   WHITE = (255, 255, 255)<br/>   LT_GRAY = (180, 180, 180)<br/>   GRAY = (120, 120, 120)<br/>   DK_GRAY = (80, 80, 80)</p>
<p class="listing" id="ch13list1"><em>Listing 13-1: Imports modules, initiates</em> <span class="codeitalic">pygame</span>, <em>and defines a table of colors</em></p>
<p class="indent">Start with some familiar <span class="literal">import</span>s and one for <span class="literal">pygame</span> <span class="ent">➊</span>. Next, call the <span class="literal">pygame.init()</span> function. This initializes the <span class="literal">pygame</span> module and starts up all the underlying parts that let it use sounds, check keyboard input, run graphics, and so on <span class="ent">➋</span>. Note that <span class="literal">pygame</span> can be initialized from multiple places, such as the first line in a <span class="literal">main()</span> function:</p>
<p class="programs">def main():<br/>    pg.init()</p>
<p class="noindent">or at the end of the program when <span class="literal">main()</span> is called in stand-alone mode:</p>
<p class="programs">if __name__ == "__main__":<br/>    pg.init()<br/>    main()</p>
<p class="indent">Stop and assign some color variables using the RGB color model <span class="ent">➌</span>. This model mixes red, green, and blue, where each color consists of values from 0 to 255. If you do an online search for “RGB color codes,” you can find the numerical codes for millions of colors. But since the NASA image you’ll calibrate against is in grayscale, stick with black, white, and shades of gray. Defining this table now will allow you to simply enter a name when <span class="literal">pygame</span> needs a color defined later.</p>
<h4 class="h4" id="lev302"><span epub:type="pagebreak" id="page_272"/><strong><em>Defining the Particle Class</em></strong></h4>
<p class="noindent"><a href="ch13.xhtml#ch13list2">Listing 13-2</a> defines the <span class="literal">Particle</span> class and its initializer method. You’ll use these to instantiate a particle object. The particle’s key attributes, such as type, velocity, color, and so on, are established with the initializer method.</p>
<p class="margin"><em>tvashtar.py,</em> part 2</p>
<p class="programs"><span class="ent">➊</span> class Particle(pg.sprite.Sprite):<br/>       """Builds ejecta particles for volcano simulation."""<br/><br/>    <span class="ent">➋</span> gases_colors = {'SO2': LT_GRAY, 'CO2': GRAY, 'H2S': DK_GRAY, 'H2O': WHITE}<br/><br/>    <span class="ent">➌</span> VENT_LOCATION_XY = (320, 300)<br/>       IO_SURFACE_Y = 308<br/>       GRAVITY = 0.5  # pixels-per-frame; added to dy each game loop<br/>       VELOCITY_SO2 = 8  # pixels-per-frame<br/><br/>       # scalars (SO2 atomic weight/particle atomic weight) used for velocity<br/>    <span class="ent">➍</span> vel_scalar = {'SO2': 1, 'CO2': 1.45, 'H2S': 1.9, 'H2O': 3.6}<br/><br/>    <span class="ent">➎</span> def __init__(self, screen, background):<br/>           super().__init__()<br/>           self.screen = screen<br/>           self.background = background<br/>        <span class="ent">➏</span> self.image = pg.Surface((4, 4))<br/>           self.rect = self.image.get_rect()<br/>        <span class="ent">➐</span> self.gas = random.choice(list(Particle.gases_colors.keys()))<br/>           self.color = Particle.gases_colors[self.gas]<br/>        <span class="ent">➑</span> self.vel = Particle.VELOCITY_SO2 * Particle.vel_scalar[self.gas]<br/>        <span class="ent">➒</span> self.x, self.y = Particle.VENT_LOCATION_XY<br/>        <span class="ent">➓</span> self.vector()</p>
<p class="listing" id="ch13list2"><em>Listing 13-2: Defines the</em> <span class="codeitalic">Particle</span> <em>class and the</em> <span class="codeitalic">Particle</span> <em>initializer method</em></p>
<p class="indent">Define a class called <span class="literal">Particle</span> to represent <em>any</em> molecule of gas that might form the volcanic plume <span class="ent">➊</span>. The <em>ancestor</em> for this class, shown in parentheses, will be a <span class="literal">Sprite</span> class. This means that the <span class="literal">Particle</span> class is derived from a built-in <span class="literal">pygame</span> type called <span class="literal">Sprite</span>. Sprites are just 2D bitmaps that represent discrete game objects, like missiles or asteroids. You <em>inherit</em> from the <span class="literal">Sprite</span> class—that is, add its attributes and methods to your new class—by passing <span class="literal">pg.sprite.Sprite</span> to your <span class="literal">Particle</span> class, just as you would pass an argument to a function.</p>
<p class="indent">Assign properties common to all particles as class attributes. The first is a dictionary that maps particle types to a color, so that you can differentiate the particles during the simulation <span class="ent">➋</span>. These colors will be used for the particle, its path, and its name in the legend.</p>
<p class="indent">Now, assign four constants, <span class="literal">VENT_LOCATION_XY</span>, <span class="literal">IO_SURFACE_Y</span>, <span class="literal">GRAVITY</span>, and <span class="literal">VELOCITY_SO2</span> <span class="ent">➌</span>. The first constant is the x- and y-coordinates for the mouth of the Tvashtar volcano in the image, which will represent the “launch point” for all the particles (see <a href="ch13.xhtml#ch13fig3">Figure 13-3</a>). I initially guessed at these values and then fine-tuned them when the simulation was up and running.</p>
<div class="image"><span epub:type="pagebreak" id="page_273"/><a id="ch13fig3"/><img src="../images/f0273-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-3: Background image for the simulation with the particle launch point annotated</em></p>
<p class="indent">The second constant is the y-value for the highest point on Io’s surface (in the image) that intersects with the outer edge of the SO<sub>2</sub> plume (see <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>). You will stop all the falling particles at this y-value, so the view will be optimized for SO<sub>2</sub>.</p>
<p class="indent">The third constant represents the acceleration of gravity, which on Earth is 9.86 m/s<sup>2</sup> and on Io is 1.796 m/s<sup>2</sup>. But you’re dealing with pixels and frames here, not real-world units, so you need to experiment to find a value that looks good at the scale of your game/simulation. My choice of <span class="literal">0.5</span> was arbitrary, though guided by knowledge of what works well in arcade games.</p>
<p class="indent">The fourth constant is the speed, in pixels per frame, of an SO<sub>2</sub> particle when it is ejected. Remember, the plumes are composed primarily of SO<sub>2</sub>, so you want to use parameters that will allow the SO<sub>2</sub> particles to “fit” the image of the Tvashtar plume, then adjust the speed of the remaining particles <em>relative</em> to SO<sub>2</sub>. Neither the <span class="literal">GRAVITY</span> nor the <span class="literal">VELOCITY_SO2</span> value is unique. Had I chosen a larger value for <span class="literal">GRAVITY</span>, I would’ve needed to increase <span class="literal">VELOCITY_SO2</span> so that the SO<sub>2</sub> particles still “fill out” the area of the plume in the NASA image.</p>
<p class="indent">Next, build a dictionary of scalars for particle velocity <span class="ent">➍</span>. For each particle, dividing the atomic weight of SO<sub>2</sub> (64) by the atomic weight of the particle gives you the scalar. Since SO<sub>2</sub> is the reference particle, its scalar is 1. Later, to get the velocity of non-SO<sub>2</sub> particles, you will multiply the <span class="literal">VELOCITY_SO2</span> constant by the scalar. As you can see, all of the other particles are lighter than SO<sub>2</sub> and should produce a larger plume.</p>
<p class="indent">Define a constructor method for the particle object <span class="ent">➎</span>. You’ll need a <span class="literal">self</span> parameter and <span class="literal">screen</span> to draw on and check the simulation's boundaries, and you’ll need a <span class="literal">background</span>, which will be an image of the Tvashtar plume. You’ll assign <span class="literal">screen</span> and <span class="literal">background</span> later in the <span class="literal">main()</span> function, defined near the end of the program. Note that while I’m using one-line <span epub:type="pagebreak" id="page_274"/>docstrings in this book for brevity, you would want to include these types of parameters in the class docstring. For more guidelines on class docstrings, see <em><a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a></em>.</p>
<p class="indent">Inside the <span class="literal">__init__()</span> method, immediately invoke the initialization method for the built-in <span class="literal">Sprite</span> class using <span class="literal">super</span>. This will initialize the sprite and establish the <span class="literal">rect</span> and <span class="literal">image</span> attributes it needs. With <span class="literal">super</span>, you don’t need to refer to the base class (<span class="literal">Sprite</span>) explicitly. For more on <span class="literal">super</span>, visit the docs at <em><a href="https://docs.python.org/3/library/functions.html#super">https://docs.python.org/3/library/functions.html#super</a></em>.</p>
<p class="indent">Next, let the particle (<span class="literal">self</span>) know that it will be using the <span class="literal">screen</span> and <span class="literal">background</span> variables by assigning them to attributes.</p>
<p class="indent">The images and drawings are placed on a rectangular surface by <span class="literal">pygame</span>. In fact, the <span class="literal">Surface</span> object is the heart and soul of <span class="literal">pygame</span>; even the <span class="literal">screen</span> attribute represents an instance of <span class="literal">Surface</span>. Assign the particle image to a <span class="literal">Surface</span> object and make it a square with 4-pixel-length sides <span class="ent">➏</span>.</p>
<p class="indent">Next, you need to get a <span class="literal">rect</span> object for your image surface. This is basically a rectangle <em>associated</em> with the <span class="literal">Surface</span> object, which <span class="literal">pygame</span> needs to determine the dimensions and position of your <span class="literal">Surface</span> object.</p>
<p class="indent">Choose a particle (<span class="literal">gas</span>) type by randomly choosing from the keys in the <span class="literal">gases_colors</span> dictionary <span class="ent">➐</span>. Note that you turn it into a list to do this. Since it’s possible to assign an instance attribute named <span class="literal">gases_colors</span> from within the <span class="literal">__init__()</span> method, include the class name—rather than <span class="literal">self</span>—to ensure the <em>class</em> attribute is being referenced.</p>
<p class="indent">Once you have a type, you can use it as the key in the dictionaries you built earlier to access things like colors and scalars. Start by getting the correct color for the chosen particle, then get its <span class="literal">vel_scalar</span> value and use that to determine the particle’s velocity <span class="ent">➑</span>.</p>
<p class="indent">The particle object will be instantiated in the mouth of the volcano, so get its initial x- and y-location by unpacking the <span class="literal">VENT_LOCATION_XY</span> tuple <span class="ent">➒</span>. Finish by calling the <span class="literal">vector()</span> method, which will calculate the particle’s motion vector <span class="ent">➓</span>.</p>
<h4 class="h4" id="lev303"><strong><em>Ejecting a Particle</em></strong></h4>
<p class="noindent"><a href="ch13.xhtml#ch13list3">Listing 13-3</a> defines the <span class="literal">vector()</span> method, which determines a particle’s launch orientation and calculates its initial delta-x and delta-y vector components.</p>
<p class="margin"><em>tvashtar.py,</em> part 3</p>
<p class="programs">    <span class="ent">➊</span> def vector(self):<br/>           """Calculate particle vector at launch."""<br/>        <span class="ent">➋</span> orient = random.uniform(60, 120)  # 90 is vertical<br/>        <span class="ent">➌</span> radians = math.radians(orient)<br/>        <span class="ent">➍</span> self.dx = self.vel * math.cos(radians)<br/>           self.dy = -self.vel * math.sin(radians)</p>
<p class="listing" id="ch13list3"><em>Listing 13-3: Defines the</em> <span class="codeitalic">vector()</span> <em>method of the</em> <span class="codeitalic">Particle</span> <em>class</em></p>
<p class="indent">The <span class="literal">vector()</span> method <span class="ent">➊</span> calculates the motion vector for a particle. Start by choosing a launch direction for the particle and assigning it to an <span class="literal">orient</span> <span epub:type="pagebreak" id="page_275"/>variable <span class="ent">➋</span>. Because explosive volcanic eruptions blast material in multiple directions rather than straight up, choose the direction at random, using a range that is 30 degrees to either side of 90 degrees, where 90 represents a vertical launch.</p>
<p class="indent">The range for the <span class="literal">orient</span> variable was chosen through trial and error. This parameter, along with the <span class="literal">VELOCITY_SO2</span> and <span class="literal">GRAVITY</span> constants, represents the “knobs” you can turn to calibrate the behavior of the SO<sub>2</sub> particle to the plume image. After you’ve adjusted the constants so that the particle’s maximum height corresponds to the apex of the plume, you can adjust the range of angles so that the SO<sub>2</sub> particles reach—but don’t exceed—the lateral limits of the plume (see <a href="ch13.xhtml#ch13fig4">Figure 13-4</a>).</p>
<div class="image"><a id="ch13fig4"/><img src="../images/f0275-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-4: Calibrating the</em> <span class="codeitalic">orient</span> <em>variable to the Tvashtar plume</em></p>
<p class="indent">The <span class="literal">math</span> module uses <em>radians</em> rather than degrees, so convert <span class="literal">orient</span> to radians <span class="ent">➌</span>. A radian is a standard unit of angular measurement equal to the angle made when the radius is wrapped around a circle (see the left-hand side of <a href="ch13.xhtml#ch13fig5">Figure 13-5</a>). One radian is slightly less than 57.3 degrees. The right-hand side of <a href="ch13.xhtml#ch13fig5">Figure 13-5</a> is a comparison of radians and degrees for some common angles. To convert degrees to radians, you can either multiply the degrees by π and divide by 180—like a chump—or just use the <span class="literal">math</span> module!</p>
<div class="image"><a id="ch13fig5"/><img src="../images/f0275-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-5: Definition of a radian (left) and common angles in radians and degrees (right)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_276"/>Objects move in <span class="literal">pygame</span> by increments of x and y. The direction and speed of a particle are used to get its <em>delta-x (dx)</em> and <em>delta-y (dy)</em> vector components. These represent the difference between a particle’s initial position and its position after completion of a single game loop.</p>
<p class="indent">You calculate vector components using trigonometry. Useful trigonometric equations are provided in <a href="ch13.xhtml#ch13fig6">Figure 13-6</a>.</p>
<div class="image"><a id="ch13fig6"/><img src="../images/f0276-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-6: Common trigonometric equations used in gaming</em></p>
<p class="indent">For the angle θ, you use the <span class="literal">orient</span> variable. The <span class="literal">self.vel</span> attribute equates to <em>r</em>. Knowing these two components, you can use a trigonometric equation to derive <span class="literal">self.dx</span> and <span class="literal">self.dy</span> <span class="ent">➍</span>. To derive <span class="literal">self.dx</span>, multiply <span class="literal">self.vel</span> by the cosine of <span class="literal">orient</span>, and to derive <span class="literal">self.dy</span>, multiply <span class="literal">self.vel</span> by the sine of <span class="literal">orient</span>. Note that you must make <span class="literal">self.dy</span> negative, as the particles are ejected upward and y-values in <span class="literal">pygame</span> increase <em>downward</em>.</p>
<h4 class="h4" id="lev304"><strong><em>Updating the Particle and Handling Boundary Conditions</em></strong></h4>
<p class="noindent"><a href="ch13.xhtml#ch13list4">Listing 13-4</a> completes the <span class="literal">Particle</span> class by defining a method to update particles as they move across the screen. This includes applying the force of gravity, drawing a line to trace the particle’s path, and “killing” the particle when it moves offscreen or below the surface of Io.</p>
<p class="margin"><em>tvashtar.py,</em> part 4</p>
<p class="programs">    <span class="ent">➊</span> def update(self):<br/>           """Apply gravity, draw path, and handle boundary conditions."""<br/>        <span class="ent">➋</span> self.dy += Particle.GRAVITY<br/>        <span class="ent">➌</span> pg.draw.line(self.background, self.color,(self.x, self.y),<br/>                          (self.x + self.dx, self.y + self.dy))<br/>        <span class="ent">➍</span> self.x += self.dx<br/>           self.y += self.dy<br/><br/>        <span class="ent">➎</span> if self.x &lt; 0 or self.x &gt; self.screen.get_width():<br/>            <span class="ent">➏</span> self.kill()<br/><span epub:type="pagebreak" id="page_277"/>        <span class="ent">➐</span> if self.y &lt; 0 or self.y &gt; Particle.IO_SURFACE_Y:<br/>               self.kill()</p>
<p class="listing" id="ch13list4"><em>Listing 13-4: Defines the</em> <span class="codeitalic">update()</span> <em>method and completes the</em> <span class="codeitalic">Particle</span> <em>class</em></p>
<p class="indent">Define the <span class="literal">update()</span> method, which takes <span class="literal">self</span> as an argument <span class="ent">➊</span>. Apply the force of gravity by adding the <span class="literal">GRAVITY</span> class attribute to <span class="literal">self.dy</span> during each game loop <span class="ent">➋</span>. Gravity is a force vector that works only in the vertical direction, so only <span class="literal">self.dy</span> is affected.</p>
<p class="indent">To draw a path behind the particle, use <span class="literal">pygame</span>’s <span class="literal">draw.line()</span> method, which takes the background image of Io, the color of the particle, and the coordinates for the previous and current locations of the particle as arguments <span class="ent">➌</span>. To get the current location, you add the <span class="literal">self.dx</span> and <span class="literal">self.dy</span> attributes to <span class="literal">self.x</span> and <span class="literal">self.y</span>.</p>
<p class="indent">Next, update the particle’s <span class="literal">self.x</span> and <span class="literal">self.y</span> attributes by adding <span class="literal">self.dx</span> and <span class="literal">self.dy</span>, just as you did in the <span class="literal">draw.line()</span> method <span class="ent">➍</span>.</p>
<p class="indent">Now, check to see if the particle has passed the left or right boundaries of the screen <span class="ent">➎</span>. Use a <span class="literal">self.x</span> equal to zero for the left side and get the width of the <span class="literal">screen</span> attribute for the right side. If the particle has passed off either side of the screen, use the built-in <span class="literal">kill()</span> method to remove it from all the groups that contain it <span class="ent">➏</span>. As you will see later, <span class="literal">pygame</span> uses containers—called <em>groups</em>—to manage sprites, and removing a sprite from a group takes it out of play.</p>
<p class="indent">Repeat this process for the y-direction <span class="ent">➐</span>, but for a maximum value, use the <span class="literal">IO_SURFACE_Y</span> constant of the <span class="literal">Particle</span> class, which will stop the particle near the surface of Io, where an SO<sub>2</sub> particle would stop (see <a href="ch13.xhtml#ch13fig2">Figures 13-2</a> and <a href="ch13.xhtml#ch13fig4">13-4</a>).</p>
<h4 class="h4" id="lev305"><strong><em>Defining the main() Function</em></strong></h4>
<p class="noindent"><a href="ch13.xhtml#ch13list5">Listing 13-5</a> defines the first part of the <span class="literal">main()</span> function that sets up the game screen, the window caption, the legend, the sprite group, and the game clock.</p>
<p class="margin"><em>tvashtar.py,</em> part 5</p>
<p class="programs">def main():<br/>    """Set up and run game screen and loop."""<br/> <span class="ent">➊</span> screen = pg.display.set_mode((639, 360))<br/> <span class="ent">➋</span> pg.display.set_caption('Io Volcano Simulator')<br/> <span class="ent">➌</span> background = pg.image.load('tvashtar_plume.gif')<br/><br/>    # Set up color-coded legend<br/> <span class="ent">➍</span> legend_font = pg.font.SysFont('None', 24)<br/> <span class="ent">➎</span> water_label = legend_font.render('--- H2O', True, WHITE, BLACK)<br/>    h2s_label = legend_font.render('--- H2S', True, DK_GRAY, BLACK)<br/>    co2_label = legend_font.render('--- CO2', True, GRAY, BLACK)<br/>    so2_label = legend_font.render('--- SO2/S2', True, LT_GRAY, BLACK)<br/><br/> <span class="ent">➏</span> particles = pg.sprite.Group()<br/><br/> <span class="ent">➐</span> clock = pg.time.Clock()</p>
<p class="listing" id="ch13list5"><em>Listing 13-5: Defines the first part of the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_278"/>The first step is to assign the <span class="literal">screen</span> variable using <span class="literal">pygame</span>’s <span class="literal">display.set_mode()</span> method <span class="ent">➊</span>. The arguments are pixel dimensions; in this case, you use values slightly smaller than those for the NASA image to ensure a good fit. Note that the dimensions must be provided as a tuple, so you need to include two sets of parentheses.</p>
<p class="indent">Next, name your game window using <span class="literal">pygame</span>’s <span class="literal">display.set_caption()</span> method <span class="ent">➋</span>, then assign the <span class="literal">background</span> variable to the NASA photo of the Tvashtar plume <span class="ent">➌</span>. Use <span class="literal">pygame</span>’s <span class="literal">image.load()</span> method to create a new <span class="literal">Surface</span> object from the image. The <span class="literal">pygame</span> package supports several image formats, including PNG, JPG, and GIF. The returned <span class="literal">Surface</span> will inherit color and transparency information from the image file. Since you’re importing a grayscale image here, your color choices will be limited.</p>
<p class="indent">Now, add some code to build the legend that will be displayed in the upper left of the screen.</p>
<p class="indent">Name a <span class="literal">legend_font</span> variable and use <span class="literal">pygame</span>’s <span class="literal">font.SysFont()</span> method to choose <span class="literal">None</span> at size 24 <span class="ent">➍</span>. You will use this when you render the text. The <span class="literal">pygame</span> package’s <span class="literal">font</span> module lets you render a new set of fonts, called TrueType fonts, onto a new <span class="literal">Surface</span> object. If you don’t want to specify a font, <span class="literal">pygame</span> comes with a built-in default font, which you can access by passing <span class="literal">None</span> as the font name.</p>
<p class="indent">Post the particle names in order of weight, with the lightest on the top. To make a label, call <span class="literal">render()</span> on the <span class="literal">legend_font</span> object you made earlier to generate a new surface object <span class="ent">➎</span>. Pass it some text, then <span class="literal">True</span> (to turn on anti-aliasing so the text looks smoother), and then the color of the particle being described. The last argument, <span class="literal">BLACK</span>, is optional and sets the background color of the label to black so the text will be legible above all the particle paths drawn on the screen. Repeat this process for the three remaining particles and add <span class="literal">S2</span> to the <span class="literal">so2_label</span>, as both gases share the same atomic weight and will behave the same in the simulation.</p>
<p class="indent">Now, start a sprite group named <span class="literal">particles</span> <span class="ent">➏</span>. Since games typically have multiple sprites moving around the screen, <span class="literal">pygame</span> uses a container—the sprite group—to manage them. In fact, you <em>must</em> put sprites in a group or else they won’t do anything.</p>
<p class="indent">Finish this section by creating a <span class="literal">Clock</span> object to track and control the frame rate of the simulation <span class="ent">➐</span>. A <span class="literal">pygame</span> “clock” controls how fast the game runs, based on the number of <em>frames per second (fps)</em> being displayed. You’ll set this value in the next section.</p>
<h4 class="h4" id="lev306"><strong><em>Completing the main() Function</em></strong></h4>
<p class="noindent"><a href="ch13.xhtml#ch13list6">Listing 13-6</a> completes <span class="literal">main()</span> by setting the speed the simulation will run—in frames per second—and starting the <span class="literal">while</span> loop that actually runs the simulation. It also handles <em>events</em>, which occur when a user exerts control on the program using a mouse, joystick, or keyboard. Since this is a simulation and not a true game, user control is limited to closing the window. The listing ends in the global scope with the standard code for running the program as a module or in stand-alone mode.</p>
<p class="margin"><span epub:type="pagebreak" id="page_279"/><em>tvashtar.py,</em> part 6</p>
<p class="programs">    <span class="ent">➊</span> while True:<br/>        <span class="ent">➋</span> clock.tick(25)<br/>        <span class="ent">➌</span> particles.add(Particle(screen, background))<br/>        <span class="ent">➍</span> for event in pg.event.get():<br/>               if event.type == pg.QUIT:<br/>                   pg.quit()<br/>                   sys.exit()<br/><br/>        <span class="ent">➎</span> screen.blit(background, (0, 0))<br/>           screen.blit(water_label, (40, 20))<br/>           screen.blit(h2s_label, (40, 40))<br/>           screen.blit(co2_label, (40, 60))<br/>           screen.blit(so2_label, (40, 80))<br/><br/>        <span class="ent">➏</span> particles.update()<br/>           particles.draw(screen)<br/><br/>        <span class="ent">➐</span> pg.display.flip()<br/><br/><span class="ent">➑</span> if __name__ == "__main__":<br/>       main()</p>
<p class="listing" id="ch13list6"><em>Listing 13-6: Starts the game clock and loop and handles events in the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">Start a <span class="literal">while</span> loop to run the simulation <span class="ent">➊</span>. Then use the <span class="literal">clock.tick()</span> method to set the speed limit for the simulation <span class="ent">➋</span>. Pass it <span class="literal">25</span>, which sets the maximum frame rate at 25 frames per second. Feel free to increase this value if you want a more energetic volcano.</p>
<p class="indent">It’s now time for the star of the show to make its appearance. Instantiate a particle using the <span class="literal">Particle</span> class, passing it the <span class="literal">screen</span> and <span class="literal">background</span> as arguments, and add the new particle to the <span class="literal">particles</span> sprite group <span class="ent">➌</span>. With each frame, a new particle will be created at random and launched from the volcanic vent, producing a pleasing spray of particles (see <a href="ch13.xhtml#ch13fig7">Figure 13-7</a>).</p>
<div class="image"><a id="ch13fig7"/><img src="../images/f0279-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-7: Startup of the simulation, with random particles being generated at the rate of 25 frames per second</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_280"/>Start a <span class="literal">for</span> loop to handle events <span class="ent">➍</span>. All the events that happened during the current frame are recorded by <span class="literal">pygame</span> and kept in an <em>event buffer</em>. Its <span class="literal">event.get()</span> method creates a list of all these events so that you can evaluate them in turn. If a <span class="literal">QUIT</span> event occurs (when a user closes the game window), the <span class="literal">pygame</span> <span class="literal">quit()</span> and system <span class="literal">exit()</span> methods are called to end the simulation.</p>
<p class="indent">To render the game objects and update the visual display, <span class="literal">pygame</span> uses a process called <em>blitting</em>. <em>Blit</em> stands for <em>block transfer</em>, which is just copying pixels from one rectangular <span class="literal">Surface</span> object onto another. By blitting the background onto the screen, you cover the screen with the Io image. With blitting, you can take the same image and draw it multiple times at different places on the screen. It can be a slow process, so game developers use clever techniques to address this deficiency, such as blitting only around areas that are currently being updated, rather than blitting the whole screen in every game loop.</p>
<p class="indent">To blit the background onto the screen, call the <span class="literal">blit()</span> method on the screen and pass it the required arguments for source and destination <span class="ent">➎</span>. In the first example, the <span class="literal">background</span> variable is the source, and the destination is the coordinates for where you want the <em>upper left-hand corner</em> of the background. Since the background will cover the whole screen, use the origin point for the screen, which is <span class="literal">(0, 0)</span>. Repeat this for the legend labels, placing them in the upper-left corner of the screen.</p>
<p class="indent">Next, call the <span class="literal">update()</span> method on the <span class="literal">particles</span> group <span class="ent">➏</span>. This method doesn’t update the screen but has the sprites run their own <span class="literal">self.update()</span> methods. After this, you use the <span class="literal">draw()</span> method to blit the sprites onto the screen based on each sprite’s <span class="literal">rect</span> attributes. This method needs a drawing surface, so pass it the <span class="literal">screen</span>.</p>
<p class="indent">The <span class="literal">draw()</span> method took care of blitting sprites, so all you need to do now is use the <span class="literal">flip()</span> method to update the actual game graphics <span class="ent">➐</span>. <em>Flipping</em> is a type of double buffering where you blit everything from the <span class="literal">screen</span> object to the actual display. Flipping gets around the inherently slow process of displaying graphics, which can cause the screen to flicker, by doing the work on a behind-the-scenes rectangle and then using a version of the <span class="literal">blit()</span> method to copy to the final display</p>
<p class="indent">The listing ends outside the <span class="literal">main()</span> function with the code that lets the program run as a module or in stand-alone mode <span class="ent">➑</span>.</p>
<h3 class="h3" id="lev307"><strong>Running the Simulation</strong></h3>
<p class="noindent"><a href="ch13.xhtml#ch13fig8">Figure 13-8</a> shows the result of running the simulator for about a minute. The water vapor plume extends beyond the top of the window. The next highest plume is formed by hydrogen sulfide, followed by carbon dioxide, and then sulfur dioxide/sulfur (S<sub>2</sub>) gas, which by design perfectly matches the Tvashtar plume.</p>
<div class="image"><span epub:type="pagebreak" id="page_281"/><a id="ch13fig8"/><img src="../images/f0281-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-8: Results of running</em> tvashtar.py <em>for one minute</em></p>
<p class="indent">To run the simulator with <em>only</em> SO<sub>2</sub>, go to the <span class="literal">__init__</span> method of the <span class="literal">Particle</span> class and change the lines where you select the <span class="literal">gas</span> and <span class="literal">color</span> instance attributes:</p>
<p class="programs">        self.gas = 'SO2'<br/>        self.color = random.choice(list(Particle.gases_colors.values()))</p>
<p class="indent">By choosing a color at random, you maintain a sense of movement in the plume after all of the possible <span class="literal">self.orient</span> angles have been exhausted. And if you want to speed up or slow down the eruption, go to the <span class="literal">main()</span> function and experiment with the <span class="literal">clock.tick()</span> method’s frames-per-second parameter.</p>
<p class="indent">In real life, the composition of plume material was inferred with <em>spectroscopy</em>, a measurement technique that analyzes how light interacts with matter. This includes both visible and nonvisible wavelengths that are absorbed, emitted, or scattered. The “spectra of the ejecta,” together with the colors painted on the surface, provided the key evidence for sulfur-rich plumes.</p>
<h3 class="h3" id="lev308"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you learned how to use the <span class="literal">pygame</span> package to simulate gravity and build an animation of an extraterrestrial volcano. In the next chapter, you’ll use <span class="literal">pygame</span> to build a true arcade game with player interactions and win-lose conditions.</p>
<h3 class="h3" id="lev309"><strong>Further Reading</strong></h3>
<p class="noindent"><em>Game Programming: The L-Line, The Express Line to Learning</em> (Wiley, 2007) by Andy Harris is a tremendously useful and thorough 570-page introduction to <span class="literal">pygame</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_282"/><em>More Python for the Absolute Beginner</em> (Cengage Learning Course Technology, 2012) by Jonathon Harbour builds on the prequel, <em>Python for the Absolute Beginner</em>, using a (py)game-focused approach.</p>
<p class="indent"><em>Invent Your Own Computer Games with Python, 4th Edition</em> (No Starch Press, 2016) by Al Sweigart is a good introduction to both Python and game design for beginners.</p>
<p class="indent">An online “newbie guide” for <span class="literal">pygame</span> is available at <em><a href="https://www.pygame.org/docs/tut/newbieguide.html">https://www.pygame.org/docs/tut/newbieguide.html</a></em>, and a “cheat sheet” can be found at <em><a href="http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf">http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf</a></em>.</p>
<p class="indent"><em>Three-Dimensional Simulation of Gas and Dust in Io’s Pele Plume</em>, by William J. McDoniel and others, documents the simulation of Io’s Pele Plume using direct Monte Carlo simulation and supercomputers at the Texas Advanced Computing Center at the University of Texas. The article is available at <em><a href="http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf">http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf</a></em>.</p>
<h3 class="h3" id="lev310"><strong>Practice Project: Going the Distance</strong></h3>
<p class="noindent">You’re one of King Henry’s archers at the battle of Agincourt. The French are charging, and you want to strike them as far away as possible. At what angle do you hold your longbow?</p>
<p class="indent">If you’ve ever had a physics class, you probably know the answer is 45 degrees. But can you trust that pencil-necked physicist? Better run a quick computer simulation to check it out. Copy and edit the <em>tvashtar.py</em> code to randomly fire particles at 25, 35, 45, 55, and 65 degrees. Set <span class="literal">self.color</span> to <span class="literal">WHITE</span> for 45 degrees and <span class="literal">GRAY</span> for all other angles (see <a href="ch13.xhtml#ch13fig9">Figure 13-9</a>).</p>
<div class="image"><a id="ch13fig9"/><img src="../images/f0282-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-9: Io volcano simulator modified for ejection angles of 25, 35, 45, 55, and 65 degrees</em></p>
<p class="indent">You can find a solution, <em>practice_45.py</em>, in the appendix or for download at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. Keep it in the same folder as the <em>tvashtar_plume.gif</em> file.</p>
<h3 class="h3" id="lev311"><span epub:type="pagebreak" id="page_283"/><strong>Challenge Projects</strong></h3>
<p class="noindent">Continue your experiments with these challenge projects. No solutions are provided.</p>
<h4 class="h4" id="lev312"><strong><em>Shock Canopy</em></strong></h4>
<p class="noindent">The visibility of Io’s giant plumes is believed to be enhanced by gas condensing into dust in the <em>shock canopy</em>, the point where the gas particles reach their apex and begin falling back to the surface. Use the <span class="literal">self.dy</span> attribute to edit the path colors in a copy of the <em>tvashtar.py</em> program. Paths in the apex of the plume should be brighter than those below (see <a href="ch13.xhtml#ch13fig10">Figure 13-10</a>). As with all Challenge Projects, no solution is provided.</p>
<div class="image"><a id="ch13fig10"/><img src="../images/f0283-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-10: Highlighting the shock canopy using lighter path colors</em></p>
<h4 class="h4" id="lev313"><strong><em>The Fountainhead</em></strong></h4>
<p class="noindent">Copy and edit <em>tvashtar.py</em> so that only SO<sub>2</sub> is simulated and particles are represented by small white circles with no trailing paths (see <a href="ch13.xhtml#ch13fig11">Figure 13-11</a>).</p>
<div class="image"><a id="ch13fig11"/><img src="../images/f0283-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 13-11: Screenshot of SO<sub>2</sub> simulation with circles representing individual particles</em></p>
<h4 class="h4" id="lev314"><span epub:type="pagebreak" id="page_284"/><strong><em>With a Bullet</em></strong></h4>
<p class="noindent">If you fire a gun straight up on a planet with no atmosphere, will the bullet hit the ground with the same velocity as when it left the muzzle? Many people struggle with this question, but you can answer it with Python. Copy and edit the <em>tvashtar.py</em> code so that it ejects a single SO<sub>2</sub> particle with an orientation of 90 degrees. Print the particle’s <span class="literal">self.y</span> attribute and the absolute value of <span class="literal">self.dy</span> at the launch point coordinate (y = 300). Compare the starting and ending velocity values at this point to see whether they are the same or similar.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Episode 50 of the TV show</em> MythBusters <em>addressed the myth that bullets fired into the air maintain their lethal capability when they eventually fall back down. They found that bullets fired perfectly vertical on Earth would tumble and slow on their way back down due to wind resistance. If fired slightly off-vertical, the bullets would maintain their spin and ballistic trajectory and return to Earth at lethal speed. It was the only myth that ever received all three ratings (Busted, Plausible, and Confirmed)!</em></p>
</div>
</body></html>