- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TRANSFORMING AND STORING NUMBERS WITH ALGEBRA
  prefs: []
  type: TYPE_NORMAL
- en: '*“Mathematics may be defined as the subject in which we never know what we
    are talking about, nor whether what we are saying is true.”'
  prefs: []
  type: TYPE_NORMAL
- en: —Bertrand Russell*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you learned algebra in school, you’re probably familiar with the idea of
    replacing numbers with letters. For example, you can write 2*x* where *x* is a
    placeholder that can represent any number. So 2*x* represents the idea of multiplying
    two by some unknown number. In math
  prefs: []
  type: TYPE_NORMAL
- en: class, variables become “mystery numbers” and you’re required to find what numbers
    the letters represent. [Figure 4-1](ch04.xhtml#ch04fig1) shows a student’s cheeky
    response to the problem “Find *x*.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f053-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Locating the* x *variable instead of solving for its value*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this student has located the variable *x* in the diagram instead
    of *solving* for its value. Algebra class is all about solving equations like
    this: solve 2*x* + 5 = 13\. In this context, “to solve” means to figure out which
    number, when you replace *x* with that number, makes the equation true. You can
    solve algebra problems by balancing equations, which requires a lot of rules you
    have to memorize and follow.'
  prefs: []
  type: TYPE_NORMAL
- en: Using letters as placeholders in this way is just like using variables in Python.
    In fact, you already learned how to use variables to store and calculate numerical
    values in previous chapters. The important skill math students should learn is
    not solving for variables but rather *using* variables. In fact, solving equations
    by hand is only of limited value. In this chapter you use variables to write programs
    that find unknown values quickly and automatically without having to balance equations!
    You also learn to use a programming environment called Processing to graph functions
    to help you explore algebra visually.
  prefs: []
  type: TYPE_NORMAL
- en: SOLVING FIRST-DEGREE EQUATIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to solve a simple equation like 2*x* + 5 = 13 with programming is by
    using *brute force* (that is, plugging in random numbers until we find the right
    one). For this particular equation we need to find a number, *x*, that when we
    multiply it by 2 and then add 5, returns 13\. I’ll make an educated guess that
    *x* is a value between −100 and 100, since we’re working with mostly double-digit
    numbers or lower.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can write a program that plugs all the integers between −100
    and 100 into the equation, checks the output, and prints the number that makes
    the equation true. Open a new file in IDLE, save it as *plug.py*, and enter the
    code in [Listing 4-1](ch04.xhtml#ch04list1) to see such a program in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'def plug():'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ x = -100 #start at -100'
  prefs: []
  type: TYPE_NORMAL
- en: 'while x < 100: #go up to 100'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ if 2*x + 5 == 13: #if it makes the equation true'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("x =",x) #print it out'
  prefs: []
  type: TYPE_NORMAL
- en: '➌ x += 1 #make x go up by 1 to test the next number'
  prefs: []
  type: TYPE_NORMAL
- en: 'plug() #run the plug function'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-1: Brute-force program that plugs in numbers to see which one satisfies
    the equation*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define the plug() function and initialize the x variable at -100 ➊.
    On the next line we start a while loop that repeats until x equals 100, which
    is the upper limit of the range we set. We then multiply x by 2 and add 5 ➋. If
    the output equals 13, we tell the program to print the number, because that’s
    the solution. If the output does not equal 13, we tell the program to keep going
    through the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop then starts over, and the program tests the next number, which we
    get by incrementing x by 1 ➌. We continue the loop until we hit a match. Be sure
    to include the last line, which makes the program run the plug() function we just
    defined; if you don’t, your program won’t do anything! The output should be this:'
  prefs: []
  type: TYPE_NORMAL
- en: x = 4
  prefs: []
  type: TYPE_NORMAL
- en: Using the guess-and-check method is a perfectly valid way to solve this problem.
    Plugging in all the digits by hand can be laborious, but using Python makes it
    a cinch! If you suspect the solution isn’t an integer, you might have to increment
    by smaller numbers by changing the line at ➌ to x += .25 or some other decimal
    value.
  prefs: []
  type: TYPE_NORMAL
- en: FINDING THE FORMULA FOR FIRST-DEGREE EQUATIONS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to solve an equation like 2*x* + 5 = 13 is to find a general formula
    for this type of equation. We can then use this formula to write a program in
    Python. You might recall from math class that the equation 2*x* + 5 = 13 is an
    example of a *first-degree equation*, because the highest exponent a variable
    has in this equation is 1\. And you probably know that a number raised to the
    first power equals the number itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, all first-degree equations fit into this general formula: a*x* + b =
    c*x* + d, where a, b, c, and d represent different numbers. Here are some examples
    of other first-degree equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e055-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On each side of the equal sign, you can see an *x* term and a *constant*, which
    is a number with no *x* attached to it. The number that precedes the *x* variable
    is called a *coefficient*. For example, the coefficient of 3*x* is 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'But sometimes there’s no *x* term at all on one side of the equation, which
    means that the coefficient of that *x* is zero. You can see this in the first
    example, 3*x* − 5 = 22, where 22 is the only term on the right side of the equal
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e055-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the general formula, you can see that a = 3, b = −5, and d = 22\. The
    only thing that seems to be missing is the value of c. But it’s not actually missing.
    In fact, the fact that there’s nothing there means c*x* = 0, which means that
    c must equal zero.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s use a little algebra to solve the equation a*x* + b = c*x* + d for
    *x*. If we can find what *x* is in the formula, we can use it to solve virtually
    all equations of this form.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this equation, we first get all the *x*’s on one side of the equal
    sign by subtracting c*x* and b from both sides of the equation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: a*x* − c*x* = d − b
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can factor out the *x* from a*x* and c*x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(a − c) = d − b'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, divide both sides by a − c to isolate *x*, which gives us the value
    of *x* in terms of a, b, c, and d:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e056-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can use this general equation to solve for any variable *x* when the
    equation is a first-degree equation and all coefficients (a, b, c, and d) are
    known. Let’s use this to write a Python program that can solve first-degree algebraic
    equations for us.
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE EQUATION() FUNCTION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write a program that will take the four coefficients of the general equation
    and print out the solution for *x*, open a new Python file in IDLE. Save it as
    *algebra.py*. We’ll write a function that takes the four numbers a, b, c, and
    d as parameters and plug them into the formula (see [Listing 4-2](ch04.xhtml#ch04list2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'def equation(a,b,c,d):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''''solves equations of the'
  prefs: []
  type: TYPE_NORMAL
- en: form ax + b = cx + d''''
  prefs: []
  type: TYPE_NORMAL
- en: return (d - b)/(a - c)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-2: Using programming to solve for x*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the general formula of a first-degree equation is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e056-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that for any equation with the form a*x* + b = c*x* + d, if we take
    the coefficients and plug them into this formula, we can calculate the *x* value.
    First, we set the equation() function to take the four coefficients as its parameters.
    Then we use the expression (d - b)/(a − c) to represent the general equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test our program with an equation you’ve already seen: 2*x* + 5 =
    13\. Open the Python shell, type the following code at the >>> prompt, and press
    ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> equation(2,5,0,13)'
  prefs: []
  type: TYPE_NORMAL
- en: '4.0'
  prefs: []
  type: TYPE_NORMAL
- en: If you input the coefficients of this equation into the function, you get 4
    as the solution. You can confirm that it’s correct by plugging in 4 in place of
    *x*. It works!
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 4-1: SOLVING MORE EQUATIONS FOR X'
  prefs: []
  type: TYPE_NORMAL
- en: Solve 12x + 18 = –34x + 67 using the program you wrote in [Listing 4-2](ch04.xhtml#ch04list2).
  prefs: []
  type: TYPE_NORMAL
- en: USING PRINT() INSTEAD OF RETURN
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Listing 4-2](ch04.xhtml#ch04list2), we used return instead of print() to
    display our results. This is because return gives us our result as a number that
    we can assign to a variable and then use again. [Listing 4-3](ch04.xhtml#ch04list3)
    shows what would happen if we used print() instead of return to find *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def equation(a,b,c,d):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''''solves equations of the'
  prefs: []
  type: TYPE_NORMAL
- en: form ax + b = cx + d''''
  prefs: []
  type: TYPE_NORMAL
- en: print((d - b)/(a − c))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-3: Using print() doesn’t let us save the output*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this, you get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = equation(2,5,0,13)'
  prefs: []
  type: TYPE_NORMAL
- en: '4.0'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(x)'
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs: []
  type: TYPE_NORMAL
- en: But when you try to call the x value using print(), the program doesn’t recognize
    your command because it hasn’t saved the result. As you can see, return can be
    more useful in programming because it lets you save the output of a function so
    you can apply it elsewhere. This is why we used return in [Listing 4-2](ch04.xhtml#ch04list2).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how you can work with the returned output, use the equation 12*x* +
    18 = −34*x* + 67 from Exercise 4-1 and assign the result to the x variable, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = equation(12,18,-34,67)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x'
  prefs: []
  type: TYPE_NORMAL
- en: '1.065217391304348'
  prefs: []
  type: TYPE_NORMAL
- en: First, we pass the coefficients and constants of our equation to the equation()
    function so that it solves the equation for us and assigns the solution to the
    variable x. Then we can simply enter x to see its value. Now that the variable
    x stores the solution, we can plug it back into the equation to check that it’s
    the correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following to find out what 12*x* + 18, the left side of the equation,
    evaluates to:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> 12*x + 18'
  prefs: []
  type: TYPE_NORMAL
- en: '30.782608695652176'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get 30.782608695652176. Now enter the following to do the same for −34*x*
    + 67, the right side of the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> -34*x + 67'
  prefs: []
  type: TYPE_NORMAL
- en: '30.782608695652172'
  prefs: []
  type: TYPE_NORMAL
- en: Except for a slight rounding discrepancy at the 15th decimal place, you can
    see that both sides of the equation evaluate to around 30.782608\. So we can be
    confident that 1.065217391304348 is indeed the correct solution for *x*! Good
    thing we returned the solution and saved the value instead of just printing it
    out once. After all, who wants to type in a number like 1.065217391304348 again
    and again?
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 4-2: FRACT IONS AS COEFFICIENTS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the equation() function to solve the last, most sinister-looking equation
    you saw on [page 55](ch04.xhtml#page_55):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e058-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SOLVING HIGHER-DEGREE EQUATIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to write programs that solve for unknown values in first-degree
    equations, let’s try something harder. For example, things get a little more complicated
    when an equation has a term raised to the second degree, like *x*² + 3*x* − 10 = 0\.
    These are called *quadratic equations*, and their general form looks like a*x*²
    + b*x* + c = 0, where a, b, and c can be any number: positive or negative, whole
    numbers, fractions, or decimals. The only exception is that a can’t be 0 because
    that would make this a first-degree equation. Unlike first-degree equations, which
    have one solution, quadratic equations have two possible solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve an equation with a squared term, you can use the *quadratic formula*,
    which is what you get when you isolate *x* by balancing the equation a*x*² + b*x*
    + c = 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e058-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The quadratic formula is a very powerful tool for solving equations, because
    no matter what a, b, and c are in a*x*² + b*x* + c = 0, you can just plug them
    in to the formula and use basic arithmetic to find your solutions.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the coefficients of *x*² + 3*x* − 10 = 0 are 1, 3, and −10\. When
    we plug those in to the formula, we get
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e059-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Isolate *x* and this simplifies to
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e059-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e059-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which is equal to 2, and
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e059-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which is equal to −5.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that replacing *x* in the quadratic formula with either of these
    solutions makes the equation true:'
  prefs: []
  type: TYPE_NORMAL
- en: (*2*)² + 3(*2*) − 10 = 4 + 6 − 10 = 0
  prefs: []
  type: TYPE_NORMAL
- en: (*−5*)² + 3(*−5*) − 10 = 25 − 15 − 10 = 0
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write a function that uses this formula to return two solutions
    for any quadratic equation.
  prefs: []
  type: TYPE_NORMAL
- en: USING QUAD() TO SOLVE QUADRATIC EQUATIONS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say we want to use Python to solve the following quadratic equation:'
  prefs: []
  type: TYPE_NORMAL
- en: 2*x*² + 7*x* − 15 = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we’ll write a function called quad() that takes the three coefficients
    (a, b, and c) and returns two solutions. But before we do anything, we need to
    import the sqrt method from the math module. The sqrt method allows us to find
    the square root of a number in Python, just like a square root button on a calculator.
    It works great for positive numbers, but if you try finding the square root of
    a negative number, you’ll see an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> frommath importsqrt'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sqrt(-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<pyshell#11>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: sqrt(-4)
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: math domain error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Python file in IDLE and name it *polynomials.py*. Add the following
    line to the top of your file to import the sqrt function from the math module:'
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: Then enter the code in [Listing 4-4](ch04.xhtml#ch04list4) to create the quad()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'def quad(a,b,c):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''''Returns the solutions of an equation'
  prefs: []
  type: TYPE_NORMAL
- en: of the form a*x**2 + b*x + c = 0''''
  prefs: []
  type: TYPE_NORMAL
- en: x1 = (-b + sqrt(b**2 - 4*a*c))/(2*a)
  prefs: []
  type: TYPE_NORMAL
- en: x2 = (-b - sqrt(b**2 - 4*a*c))/(2*a)
  prefs: []
  type: TYPE_NORMAL
- en: return x1,x2
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-4: Using the quadratic formula to solve an equation*'
  prefs: []
  type: TYPE_NORMAL
- en: The quad() function takes the numbers a, b, and c as parameters and plugs them
    in to the quadratic formula. We use x1 to assign the result of (the first solution),
    and x2 will store the value of (the second solution).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test this program to solve for *x* in 2*x*² + 7*x* − 15 = 0\. Plugging
    in the numbers 2, 7, and −15 for a, b, and c should return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> quad(2,7,-15)'
  prefs: []
  type: TYPE_NORMAL
- en: (1.5, -5.0)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the two solutions for *x* are 1.5 and −5, which means both
    values should satisfy the equation 2*x*² + 7*x* − 15 = 0\. To test this, replace
    all the *x* variables in the original equation 2*x*² + 7*x* − 15 = 0 with 1.5,
    the first solution, and then with −5, the second solution, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> 2*1.5**2 + 7*1.5 - 15'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> 2*(-5)**2 + 7*(-5) - 15'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Success! This confirms that both values work in the original equation. You can
    use the equation() and quad() functions any time in the future. Now that you’ve
    learned to write functions to solve first-degree and second-degree equations,
    let’s discuss how to solve even higher-degree equations!
  prefs: []
  type: TYPE_NORMAL
- en: USING PLUG() TO SOLVE A CUBIC EQUATION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In algebra class, students are often asked to solve a *cubic equation* like
    6*x*³ + 31*x*² + 3*x* − 10 = 0, which has a term raised to the third degree. We
    can tweak the plug() function we wrote in [Listing 4-1](ch04.xhtml#ch04list1)
    to solve this cubic equation using the brute-force method. Enter the code shown
    in [Listing 4-5](ch04.xhtml#ch04list5) into IDLE to see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: '*plug.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def g(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return 6*x**3 + 31*x**2 + 3*x − 10
  prefs: []
  type: TYPE_NORMAL
- en: 'def plug():'
  prefs: []
  type: TYPE_NORMAL
- en: x = -100
  prefs: []
  type: TYPE_NORMAL
- en: 'while x < 100:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if g(x) == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("x =",x)
  prefs: []
  type: TYPE_NORMAL
- en: x += 1
  prefs: []
  type: TYPE_NORMAL
- en: print("done.")
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-5: Using plug() to solve a cubic equation*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define g(x) to be a function that evaluates the expression 6*x**3
    + 31*x**2 + 3*x − 10, the left side of our cubic equation. Then we tell the program
    to plug all numbers between −100 and 100 into the g(x) function we just defined.
    If the program finds a number that makes g(x) equal zero, then it has found the
    solution and prints it for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call plug(), you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plug()'
  prefs: []
  type: TYPE_NORMAL
- en: x = -5
  prefs: []
  type: TYPE_NORMAL
- en: done.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you −5 as the solution, but as you might suspect from working with
    quadratic equations previously, the *x*³ term means there could be as many as
    three solutions to this equation. As you can see, you can brute-force your way
    to a solution like this, but you won’t be able to determine whether other solutions
    exist or what they are. Fortunately, there’s a way to see all the possible inputs
    and corresponding outputs of a function; it’s called *graphing*.
  prefs: []
  type: TYPE_NORMAL
- en: SOLVING EQUATIONS GRAPHICALLY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll use a nifty tool called Processing to graph higher-degree
    equations. This tool will help us find solutions to higher-degree equations in
    a fun and visual way! If you haven’t already installed Processing, follow the
    instructions in “Installing Processing” on [page xxiii](ch00.xhtml#page_xxiii).
  prefs: []
  type: TYPE_NORMAL
- en: GETTING STARTED WITH PROCESSING
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Processing is a programming environment and a graphics library that makes it
    easy to visualize your code. You can see the cool, dynamic, interactive art you
    can make with Processing in the examples page at *[https://processing.org/examples/](https://processing.org/examples/)*.
    You can think of Processing as a sketchbook for your programming ideas. In fact,
    each Processing program you create is called a *sketch*. [Figure 4-2](ch04.xhtml#ch04fig2)
    shows what a short Processing sketch in Python mode looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f062-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Example of a Processing sketch*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there’s a programming environment where you enter code and
    a separate *display window* that shows the visualization of the code. This is
    a sketch of a simple program that creates a small circle. Every one of the Processing
    sketches we’ll create will contain two of Processing’s built-in functions: setup()
    and draw(). The code we put in the setup() function will be run once, when you
    click the play button, the arrow at the top left of the interface. Whatever we
    put in draw() will be repeated as an infinite loop until you click the stop button
    next to the play button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 4-2](ch04.xhtml#ch04fig2) you can see in the setup() function we
    declared the size of the display screen to be 600 pixels by 600 pixels using the
    size() function. In the draw() function we told the program to draw a circle using
    the ellipse() function. Where? How big? We have to tell the ellipse() function
    four numbers: the x-coordinate of the ellipse, its y-coordinate, its width, and
    its height.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the circle shows up in the middle of the screen, which in math class
    is the *origin* (0,0). But in Processing and in many other graphics libraries,
    (0,0) is in the top left corner of the screen. So to put a circle in the middle,
    I had to divide the length of the window (600) and the width of the window (600)
    in half. So its location is (300,300), and not (0,0).
  prefs: []
  type: TYPE_NORMAL
- en: Processing has a number of functions, like ellipse(), that make it easy to draw
    shapes. To see the full list, look at the reference pages at *[https://processing.org/reference/](https://processing.org/reference/)*
    to find functions for drawing ellipses, triangles, rectangles, arcs, and much
    more. We’ll explore drawing shapes with Processing in more detail in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The code colors in Processing appear different from those used in IDLE. For
    example, you can see that def appears green in Processing in [Figure 4-2](ch04.xhtml#ch04fig2),
    whereas it is orange in IDLE*.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### CREATING YOUR OWN GRAPHING TOOL'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve downloaded Processing, let’s use it to create a graphing tool
    that allows us to see how many solutions an equation has. First, we create a grid
    of blue lines that looks like graphing paper. Then, we create the x- and y-axes
    using black lines.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Graph Dimensions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In order to make a grid for our graphing tool, we first need to set the dimensions
    of the display window. In Processing, you can use the size() function to indicate
    the width and height of the screen in pixels. The default screen size is 600 pixels
    by 600 pixels, but for our graphing tool we’ll create a graph that includes x-
    and y-values ranging from −10 to 10.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file in Processing and save it as *grid.pyde*. Make sure you’re in
    Python mode. Enter the code in [Listing 4-6](ch04.xhtml#ch04list6) to declare
    the range of x- and y-values we’re interested in displaying for our graph.
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: '#set the range of x-values'
  prefs: []
  type: TYPE_NORMAL
- en: xmin = -10
  prefs: []
  type: TYPE_NORMAL
- en: xmax = 10
  prefs: []
  type: TYPE_NORMAL
- en: '#range of y-values'
  prefs: []
  type: TYPE_NORMAL
- en: ymin = -10
  prefs: []
  type: TYPE_NORMAL
- en: ymax = 10
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the range'
  prefs: []
  type: TYPE_NORMAL
- en: rangex = xmax - xmin
  prefs: []
  type: TYPE_NORMAL
- en: rangey = ymax - ymin
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-6: Setting the range of x- and y-values for the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-6](ch04.xhtml#ch04list6) we create two variables, xmin and xmax,
    for the minimum and maximum x-values in our grid, then we repeat the process for
    the y-values. Next we declare rangex for the x-range and rangey variable for the
    y-range. We calculate the value of rangex by subtracting xmin from xmax and do
    the same for the y-values.
  prefs: []
  type: TYPE_NORMAL
- en: Because we don’t need a graph that’s 600 units by 600 units, we need to scale
    the coordinates down by multiplying the x- and y-coordinates by scale factors.
    When graphing we have to remember to multiply all our x-coordinates and y-coordinates
    by these scale factors; otherwise, they won’t show up correctly on the screen.
    To do this, update the existing code in the setup() function with the lines of
    code in [Listing 4-7](ch04.xhtml#ch04list7).
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: def setup()
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: xscl = width / rangex
  prefs: []
  type: TYPE_NORMAL
- en: yscl = -height / rangey
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-7: Scaling coordinates using scale factors*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare the global variables xscl and yscl, which we’ll use to scale
    our screen. xscl and yscl stand for the x-scale factor and y-scale factor, respectively.
    For example, the x-scale factor would be 1 if we want our x-range to be 600 pixels,
    or the full width of the screen. But if we want our screen to be between −300
    and 300, the x-scale factor would be 2, which we get by dividing the width (600)
    by the rangex (300).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we can calculate the scale factor by dividing 600 by the x-range,
    which is 20 (−10 to 10). So the scale factor has to be 30\. From now on, we need
    to scale up all of our x- and y-coordinates by a factor of 30 so that they show
    on the screen. The good news is that the computer will do all the dividing and
    scaling for us. We just have to remember to use xscl and yscl when graphing!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a Grid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve set the proper dimensions for our graph, we can draw grid lines
    like the ones you see on graphing paper. Everything in the setup() function will
    be run once. Then we create an infinite loop with a function called draw(). Setup()
    and draw() are built-in Processing functions, and you can’t change their names
    if you want the sketch to run. Add the code in [Listing 4-8](ch04.xhtml#ch04list8)
    to create the draw() function.
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: '#set the range of x-values'
  prefs: []
  type: TYPE_NORMAL
- en: xmin = -10
  prefs: []
  type: TYPE_NORMAL
- en: xmax = 10
  prefs: []
  type: TYPE_NORMAL
- en: '#range of y-values'
  prefs: []
  type: TYPE_NORMAL
- en: ymin = -10
  prefs: []
  type: TYPE_NORMAL
- en: ymax = 10
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the range'
  prefs: []
  type: TYPE_NORMAL
- en: rangex = xmax - xmin
  prefs: []
  type: TYPE_NORMAL
- en: rangey = ymax - ymin
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: xscl = width / rangex
  prefs: []
  type: TYPE_NORMAL
- en: yscl = height / rangey
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: 'background(255) #white'
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  prefs: []
  type: TYPE_NORMAL
- en: '#cyan lines'
  prefs: []
  type: TYPE_NORMAL
- en: strokeWeight(1)
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(xmin,xmax + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-8: Creating blue grid lines for the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use global xscl, yscl to tell Python we’re not creating new variables
    but just using the global ones we already created. Then we set the background
    color to white using the value 255\. We use Processing’s translate() function
    to move shapes up and down, or left and right. The code translate(width/2,height/2)
    will move the origin (where x and y are both 0) from the top left to the center
    of the screen. Then we set the thickness of the lines with strokeWeight, where
    1 is the thinnest. You can make them thicker if you want by using higher numbers.
    You can also change the color of the lines using stroke. Here, we’re using cyan
    (“sky blue”), whose RGB value is (0,255,255), which means no red values, maximum
    green, and maximum blue.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we use a for loop to avoid having to type 40 lines of code to draw
    40 blue lines. We want the blue lines to go from xmin to xmax, including xmax,
    because that’s how wide our graph should be.
  prefs: []
  type: TYPE_NORMAL
- en: RGB VALUES
  prefs: []
  type: TYPE_NORMAL
- en: An RGB value is a mixture of red, green, and blue, in that order. The values
    range from 0 to 255\. For example, (255,0,0) means “maximum red, no green, no
    blue.” Yellow is a mixture of red and green only, and cyan (“sky blue”) is a mixture
    of green and blue only.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f065-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Other colors are a mixture of different levels of red, green, and blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f065-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can do a web search for “RGB Tables” to get RGB values for many more colors!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Processing, you can draw a line by declaring four numbers: the x- and y-coordinates
    of the beginning and endpoints of the line. The vertical lines would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: line(-10,-10, -10,10)
  prefs: []
  type: TYPE_NORMAL
- en: line(-9,-10, -9,10)
  prefs: []
  type: TYPE_NORMAL
- en: line(-8,-10, -8,10)
  prefs: []
  type: TYPE_NORMAL
- en: But because range(x) doesn’t include x (as you learned previously), our for
    loop needs to go from xmin to xmax + 1 to include xmax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the horizontal lines would go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: line(-10,-10, 10,-10)
  prefs: []
  type: TYPE_NORMAL
- en: line(-10,-9, 10,-9)
  prefs: []
  type: TYPE_NORMAL
- en: line(-10,-8, 10,-8)
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, you can see that the y-values are −10, −9, −8 and so on, whereas
    the x-values stay constant at −10 and 10, which are xmin and xmax. Let’s add another
    loop to go from ymin to ymax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(xmin,xmax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(i,ymin,i,ymax)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ymin,ymax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin,i,xmax,i)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you graphed this right, you would now see a tiny splotch in the middle of
    the screen because the x- and y-coordinates go from −10 to 10, but the screen
    goes from 0 to 600 by default. This is because we haven’t multiplied all our x-
    and y-coordinates by their scale factor yet! To display the grid properly, update
    your code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(xmin,xmax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ymin,ymax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to create the x- and y-axes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the X- and Y-Axes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To add the two black lines for the x- and y-axes, we first set the stroke color
    to black by calling the stroke() function (with 0 being black and 255 being white).
    Then we draw a vertical line from (0,−10) to (0,10) and a horizontal line from
    (−10,0) to (10,0). Don’t forget to multiply the values by their respective scale
    factors, unless they’re 0, in which case multiplying them wouldn’t change them
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-9 shows the complete code for creating the grid.
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: '#cyan lines'
  prefs: []
  type: TYPE_NORMAL
- en: strokeWeight(1)
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(xmin,xmax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ymin,ymax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black axes'
  prefs: []
  type: TYPE_NORMAL
- en: line(0,ymin*yscl,0,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,0,xmax*xscl,0)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-9: Creating the grid lines*'
  prefs: []
  type: TYPE_NORMAL
- en: When you click **Run**, you should get a nice grid, like in [Figure 4-3](ch04.xhtml#ch04fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f067-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: You’ve created a grid for graphing—and you only have to do it
    once!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks done, but if we try to put a point (a tiny ellipse, actually) at
    (3,6), we see a problem. Add the following code to the end of the draw() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: '#test with a circle'
  prefs: []
  type: TYPE_NORMAL
- en: fill(0)
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(3*xscl,6*yscl,10,10)
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, you’ll see the output in [Figure 4-4](ch04.xhtml#ch04fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f067-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Checking our graphing program. Almost there!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the point ends up on (3,−6) instead of at (3,6). Our graph
    is upside-down! To fix this, we can add a negative sign to the y-scale factor
    in the setup() function to flip it over:'
  prefs: []
  type: TYPE_NORMAL
- en: yscl = -height/rangey
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should see the point at the correct location, like in [Figure 4-5](ch04.xhtml#ch04fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f068-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The grapher is working properly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve written the graphing tool, let’s put it into a function so we
    can reuse it whenever we need to graph an equation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the grid() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To keep our code organized, we’ll separate all the code that makes the grid
    and place it in its own function, which we’ll call grid(). Then we’ll call the
    grid() function in the draw() function like in [Listing 4-10](ch04.xhtml#ch04list10).
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  prefs: []
  type: TYPE_NORMAL
- en: 'grid(xscl,yscl) #draw the grid'
  prefs: []
  type: TYPE_NORMAL
- en: 'def grid(xscl,yscl):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Draws a grid for graphing'
  prefs: []
  type: TYPE_NORMAL
- en: '#cyan lines'
  prefs: []
  type: TYPE_NORMAL
- en: strokeWeight(1)
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(xmin,xmax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ymin,ymax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black axes'
  prefs: []
  type: TYPE_NORMAL
- en: line(0,ymin*yscl,0,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,0,xmax*xscl,0)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-10: Moving all the grid code into a separate function*'
  prefs: []
  type: TYPE_NORMAL
- en: In programming we often organize our code into functions. Notice in [Listing
    4-10](ch04.xhtml#ch04list10) we can easily see what we’re executing in our draw()
    function. Now we’re ready to solve our cubic equation, 6*x*³ + 31*x*² + 3*x* −
    10 = 0.
  prefs: []
  type: TYPE_NORMAL
- en: GRAPHING AN EQUATION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plotting graphs is a fun and visual way to find solutions of polynomials that
    have more than one potential solution for *x*. But before we try to graph a complicated
    equation like 6*x*³ + 31*x*² + 3*x* − 10 = 0, let’s plot a simple parabola.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting Points
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Add this function after the draw() function from [Listing 4-10](ch04.xhtml#ch04list10):'
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return x**2
  prefs: []
  type: TYPE_NORMAL
- en: This defines the function we’re calling f(x). We’re telling Python what to do
    with the number *x* to produce the output of the function. In this case, we’re
    telling it to square the number *x* and return the output. Math classes have traditionally
    called functions f(x), g(x), h(x) and so on. Using a programming language, you
    can call functions whatever you like! We could have given this function a descriptive
    name like parabola(x), but since f(x) is commonly used, we’ll stick to that for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple parabola that we’ll graph before getting into more complicated
    functions. All the points on this curve are simply the values for x and its corresponding
    y-value. We could use a loop and draw small ellipses for points at all the whole-number
    values for x, but that would look like an unconnected group of points, as in [Figure
    4-6](ch04.xhtml#ch04fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f069-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: A graph of disconnected dots*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a different kind of loop, we could draw dots closer together, as in [Figure
    4-7](ch04.xhtml#ch04fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f070-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: The dots are closer together, but it’s still not a convincing
    curve*.'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to make a connected curve is to draw lines from point to point.
    If the points are close enough together, they’ll look curved. First, we’ll create
    a graphFunction() function after f(x).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the Points
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the graphFunction() function, start x at xmin, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def graphFunction():'
  prefs: []
  type: TYPE_NORMAL
- en: x = xmin
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the graph extend across the whole grid, we’ll keep increasing x until
    it’s equal to xmax. That means we’ll keep this loop going “while x is less than
    or equal to xmax,” as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def graphFunction():'
  prefs: []
  type: TYPE_NORMAL
- en: x = xmin
  prefs: []
  type: TYPE_NORMAL
- en: 'while x <= xmax:'
  prefs: []
  type: TYPE_NORMAL
- en: To draw the curve itself, we’ll draw lines from every point to every next point,
    going up a tenth of a unit at a time. Even if our function produces a curve, you
    probably won’t notice if we’re drawing a straight line between two points that
    are really close together. For example, the distance from (2, f(2)) to (2.1, f(2.1))
    is tiny, so overall the output will look curved.
  prefs: []
  type: TYPE_NORMAL
- en: 'def graphFunction():'
  prefs: []
  type: TYPE_NORMAL
- en: x = xmin
  prefs: []
  type: TYPE_NORMAL
- en: 'while x <= xmax:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(0)
  prefs: []
  type: TYPE_NORMAL
- en: line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: x += 0.1
  prefs: []
  type: TYPE_NORMAL
- en: This code defines a function that draws a graph of f(x) by starting at xmin
    and going all the way up to xmax. While the x-value is less than or equal to xmax,
    we’ll draw a line from (x, f(x)) to ((x + 0.1), f(x + 0.1)). We can’t forget to
    increment x by 0.1 at the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4-11 shows the whole code for *grid.pyde*.
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: '#set the range of x-values'
  prefs: []
  type: TYPE_NORMAL
- en: xmin = -10
  prefs: []
  type: TYPE_NORMAL
- en: xmax = 10
  prefs: []
  type: TYPE_NORMAL
- en: '#range of y-values'
  prefs: []
  type: TYPE_NORMAL
- en: ymin = -10
  prefs: []
  type: TYPE_NORMAL
- en: ymax = 10
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the range'
  prefs: []
  type: TYPE_NORMAL
- en: rangex = xmax - xmin
  prefs: []
  type: TYPE_NORMAL
- en: rangey = ymax - ymin
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: xscl = width / rangex
  prefs: []
  type: TYPE_NORMAL
- en: yscl = -height / rangey
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: 'background(255) #white'
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  prefs: []
  type: TYPE_NORMAL
- en: grid(xscl,yscl)
  prefs: []
  type: TYPE_NORMAL
- en: graphFunction()
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return x**2
  prefs: []
  type: TYPE_NORMAL
- en: 'def graphFunction():'
  prefs: []
  type: TYPE_NORMAL
- en: x = xmin
  prefs: []
  type: TYPE_NORMAL
- en: 'while x <= xmax:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(0)
  prefs: []
  type: TYPE_NORMAL
- en: line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: x += 0.1
  prefs: []
  type: TYPE_NORMAL
- en: 'def grid(xscl, yscl):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Draws a grid for graphing'
  prefs: []
  type: TYPE_NORMAL
- en: '#cyan lines'
  prefs: []
  type: TYPE_NORMAL
- en: strokeWeight(1)
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(xmin,xmax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ymin,ymax+1):'
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black axes'
  prefs: []
  type: TYPE_NORMAL
- en: line(0,ymin*yscl,0,ymax*yscl)
  prefs: []
  type: TYPE_NORMAL
- en: line(xmin*xscl,0,xmax*xscl,0)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-11: Complete code for graphing the parabola*'
  prefs: []
  type: TYPE_NORMAL
- en: This gets us the curve we’re looking for, as shown in [Figure 4-8](ch04.xhtml#ch04fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f072-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: A nice continuous graph of a parabola!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can change our function to something more complicated, and the grapher
    will easily draw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*grid.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return 6*x**3 + 31*x**2 + 3*x − 10
  prefs: []
  type: TYPE_NORMAL
- en: With this simple change, you’ll see the output in [Figure 4-9](ch04.xhtml#ch04fig9),
    but the function will be in black. If you prefer a red curve, change the stroke(0)
    line in graphFunction() to stroke(255,0,0), and you’ll get a red function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f072-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Graphing a polynomial function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s great to be able to simply change one line in the f() function and have
    the program automatically graph a different function! The solutions (called the
    *roots*) of the equation are where the graph crosses the x-axis. We can see three
    places: one where *x* = −5, another where *x* is between −1 and 0, and a third
    where *x* is between 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Guess and Check to Find the Roots
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We already saw how effective our guess-and-check method was for guessing numbers
    in [Chapter 3](ch03.xhtml#ch03). Now we can use it to approximate the roots, or
    solutions, for the equation 6*x*³ + 31*x*² + 3*x* − 10 = 0\. Let’s start with
    the root between 0 and 1\. Is it 0.5 or something else? To test this, we can easily
    plug 0.5 into the equation. Create a new file in IDLE, name it *guess.py*, and
    enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*guess.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return 6*x**3 + 31*x**2 + 3*x − 10
  prefs: []
  type: TYPE_NORMAL
- en: '>>> f(0.5)'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when *x* equals 0.5, it makes the function equal 0, so another
    solution of our equation is *x* = 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s try to find the root between −1 and 0\. We’ll try the average of
    −1 and 0 to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> f(-0.5)'
  prefs: []
  type: TYPE_NORMAL
- en: '-4.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'At *x* = −0.5, the function is negative, not zero. Looking at the graph, we
    can tell we guessed too high, so the root must be somewhere between −1 and −0.5\.
    We’ll average those endpoints and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> f(-0.75)'
  prefs: []
  type: TYPE_NORMAL
- en: '2.65625'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get a positive number, so we guessed too low. Therefore, the solution must
    be between −0.75 and −0.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> f(-0.625)'
  prefs: []
  type: TYPE_NORMAL
- en: '-1.23046875'
  prefs: []
  type: TYPE_NORMAL
- en: Still too high. This is getting a bit tedious. Let’s see how we might use Python
    to do these steps for us.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the guess() Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create a function that will find the roots of an equation by averaging
    the lower and upper values and adjusting its next guesses accordingly. This will
    work for our current task, where the function is passing through the x-axis from
    positive to negative. For a function going up, from negative to positive, we’d
    have to change it around a little. [Listing 4-12](ch04.xhtml#ch04list12) shows
    the complete code for this function.
  prefs: []
  type: TYPE_NORMAL
- en: '''''''The guess method'''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return 6*x**3 + 31*x**2 + 3*x - 10
  prefs: []
  type: TYPE_NORMAL
- en: 'def average(a,b):'
  prefs: []
  type: TYPE_NORMAL
- en: return (a + b)/2.0
  prefs: []
  type: TYPE_NORMAL
- en: 'def guess():'
  prefs: []
  type: TYPE_NORMAL
- en: lower = -1
  prefs: []
  type: TYPE_NORMAL
- en: upper = 0
  prefs: []
  type: TYPE_NORMAL
- en: '➊ for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: midpt = average(lower,upper)
  prefs: []
  type: TYPE_NORMAL
- en: 'if f(midpt) == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: return midpt
  prefs: []
  type: TYPE_NORMAL
- en: 'elif f(midpt) < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: upper = midpt
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: lower = midpt
  prefs: []
  type: TYPE_NORMAL
- en: return midpt
  prefs: []
  type: TYPE_NORMAL
- en: x = guess()
  prefs: []
  type: TYPE_NORMAL
- en: print(x,f(x))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-12: The guess method for solving equations*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare the function for the equation we’re trying to solve using
    f(x). Then we create the average() function to find the average of two numbers,
    which we’ll be using at every step. Finally, we write a guess() function that
    starts with a lower limit of −1 and an upper limit of 0, since that’s where our
    graph crossed the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use for i in range(20): ➊ to create a loop that cuts the range by half
    20 times. Our guess will be the average, or midpoint, of the upper and lower limits.
    We put that midpoint into f(x) and if the output equals 0, we know that’s our
    root. If the output is negative, we know we guessed too high. Then the midpoint
    will replace our upper limit and we’ll take another guess. Otherwise, if we guessed
    too low, the midpoint will become our lower limit and we’ll guess again.'
  prefs: []
  type: TYPE_NORMAL
- en: If we haven’t returned the solution in 20 guesses, we return the latest midpoint
    and the function of that midpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this, we should get two values as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: -0.6666669845581055 9.642708896251406e-06
  prefs: []
  type: TYPE_NORMAL
- en: The first output is the x-value, which is very close to −2/3\. The second output
    is what f(x) evaluates to when we plug in −2/3 as the x-value. The e-06 at the
    end is scientific notation, which means you take 9.64 and move the decimal place
    to the left six places. So f(x) evaluates to 0.00000964, which is very close to
    zero. To go through this guess-and-check program and get this solution, or rather
    an approximation accurate to within a millionth of the actual solution, to pop
    up in less than a second is still surprising and wonderful to me! Can you see
    the power in exploring math problems using free software like Python and Processing?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we increase the number of iterations from 20 to 40, we get a number even
    closer to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: -0.6666666666669698 9.196199357575097e-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check f(-0.6666666666669698), or f(-2/3):'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> f(-2/3)'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: This checks out, so the three solutions to 6*x*³ + 31*x*² + 3*x* − 10 = 0 are
    *x* = −5, −2/3, and 1/2.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 4-3: FINDING MORE ROOTS'
  prefs: []
  type: TYPE_NORMAL
- en: Use the graphing tool you just created to find the roots of 2x² + 7x – 15 =
    0\. Remember, the roots are where the graph crosses the x-axis, or where the function
    equals 0\. Check your answers using your quad() function.
  prefs: []
  type: TYPE_NORMAL
- en: SUMMARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Math class used to be all about taking years to learn how to solve equations
    of higher and higher degree. In this chapter you learned that this isn’t so hard
    to do programmatically using our guess-and-check method. You also wrote programs
    that solve equations in other ways, like using the quadratic formula and graphing.
    In fact, you learned that all we have to do to solve an equation, no matter how
    complicated, is to graph it and approximate where it crosses the x-axis. By iterating
    and halving the range of values that work, we can get as accurate as we want.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, we use algebra to create variables to represent values that
    will change, like the size or coordinates of an object. The user can then change
    the value of a variable in one place, and the program will automatically change
    the value of that variable everywhere in the program. The user can also change
    these variables using a loop or declare the value in a function call. In future
    chapters we’ll model real-life situations where we need to use variables to represent
    parameters and constraints on the model, like energy content and force of gravity.
    Using variables lets us change values easily, to vary different aspects of the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter you’ll use Processing to create interactive graphics, like
    rotating triangles and colorful grids!
  prefs: []
  type: TYPE_NORMAL
