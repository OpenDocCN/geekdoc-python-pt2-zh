- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: TRANSFORMING AND STORING NUMBERS WITH ALGEBRA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用代数变换和存储数字
- en: '*“Mathematics may be defined as the subject in which we never know what we
    are talking about, nor whether what we are saying is true.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“数学可以定义为我们永远不知道自己在谈论什么，也不知道我们说的是否真实的学科。”*'
- en: —Bertrand Russell*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —伯特兰·罗素*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: If you learned algebra in school, you’re probably familiar with the idea of
    replacing numbers with letters. For example, you can write 2*x* where *x* is a
    placeholder that can represent any number. So 2*x* represents the idea of multiplying
    two by some unknown number. In math
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在学校学过代数，你可能对用字母替代数字的概念很熟悉。例如，你可以写2*x*，其中*x*是一个占位符，可以代表任何数字。所以2*x*表示将2乘以某个未知数字的概念。在数学中
- en: class, variables become “mystery numbers” and you’re required to find what numbers
    the letters represent. [Figure 4-1](ch04.xhtml#ch04fig1) shows a student’s cheeky
    response to the problem “Find *x*.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在课堂上，变量变成了“神秘数字”，你需要找到字母所代表的数字。[Figure 4-1](ch04.xhtml#ch04fig1)展示了一个学生对“找到*x*”问题的顽皮回答。
- en: '![image](../images/f053-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f053-01.jpg)'
- en: '*Figure 4-1: Locating the* x *variable instead of solving for its value*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 4-1: 定位*x*变量，而不是求解其值*'
- en: 'As you can see, this student has located the variable *x* in the diagram instead
    of *solving* for its value. Algebra class is all about solving equations like
    this: solve 2*x* + 5 = 13\. In this context, “to solve” means to figure out which
    number, when you replace *x* with that number, makes the equation true. You can
    solve algebra problems by balancing equations, which requires a lot of rules you
    have to memorize and follow.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这位学生在图中定位了变量*x*，而不是*求解*它的值。代数课的重点是解决像这样的方程：解2*x* + 5 = 13。在这个上下文中，“求解”意味着找出哪个数字，当你把*x*替换成这个数字时，方程就成立。你可以通过平衡方程来解代数问题，这需要大量你必须记住并遵循的规则。
- en: Using letters as placeholders in this way is just like using variables in Python.
    In fact, you already learned how to use variables to store and calculate numerical
    values in previous chapters. The important skill math students should learn is
    not solving for variables but rather *using* variables. In fact, solving equations
    by hand is only of limited value. In this chapter you use variables to write programs
    that find unknown values quickly and automatically without having to balance equations!
    You also learn to use a programming environment called Processing to graph functions
    to help you explore algebra visually.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用字母作为占位符就像在Python中使用变量一样。事实上，你已经学会了如何在前几章中使用变量来存储和计算数值。数学学生应该学习的重要技能不是解变量的值，而是*使用*变量。事实上，手工解方程的价值是有限的。在本章中，你将使用变量编写程序，快速而自动地找到未知值，而不需要平衡方程！你还将学习使用名为Processing的编程环境，来绘制函数图像，帮助你以视觉方式探索代数。
- en: SOLVING FIRST-DEGREE EQUATIONS
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解一元一次方程
- en: One way to solve a simple equation like 2*x* + 5 = 13 with programming is by
    using *brute force* (that is, plugging in random numbers until we find the right
    one). For this particular equation we need to find a number, *x*, that when we
    multiply it by 2 and then add 5, returns 13\. I’ll make an educated guess that
    *x* is a value between −100 and 100, since we’re working with mostly double-digit
    numbers or lower.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决像2*x* + 5 = 13这样的简单方程的一种方法是使用*暴力破解*（即随机代入数字直到找到正确的数字）。对于这个特定的方程，我们需要找出一个数字，*x*，当我们将其乘以2并加上5时，结果是13。我将做一个有根据的猜测，认为*x*是介于−100和100之间的数字，因为我们主要处理的是两位数或更小的数字。
- en: This means that we can write a program that plugs all the integers between −100
    and 100 into the equation, checks the output, and prints the number that makes
    the equation true. Open a new file in IDLE, save it as *plug.py*, and enter the
    code in [Listing 4-1](ch04.xhtml#ch04list1) to see such a program in action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写一个程序，将介于−100和100之间的所有整数代入方程，检查输出，并打印出使方程成立的数字。在IDLE中打开一个新文件，保存为*plug.py*，并输入[Listing
    4-1](ch04.xhtml#ch04list1)中的代码，来看到这个程序的实际运行效果。
- en: 'def plug():'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'def plug():'
- en: '➊ x = -100 #start at -100'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ x = -100 #从-100开始'
- en: 'while x < 100: #go up to 100'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '当x < 100时: #直到100'
- en: '➋ if 2*x + 5 == 13: #if it makes the equation true'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ 如果2*x + 5 == 13: #如果它使方程成立'
- en: 'print("x =",x) #print it out'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("x =",x) #输出结果'
- en: '➌ x += 1 #make x go up by 1 to test the next number'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ x += 1 #让x增加1以测试下一个数字'
- en: 'plug() #run the plug function'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'plug() #运行plug函数'
- en: '*Listing 4-1: Brute-force program that plugs in numbers to see which one satisfies
    the equation*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-1: 使用暴力破解的程序，通过代入数字查看哪个数字满足方程*'
- en: Here, we define the plug() function and initialize the x variable at -100 ➊.
    On the next line we start a while loop that repeats until x equals 100, which
    is the upper limit of the range we set. We then multiply x by 2 and add 5 ➋. If
    the output equals 13, we tell the program to print the number, because that’s
    the solution. If the output does not equal 13, we tell the program to keep going
    through the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了plug()函数，并将x变量初始化为-100 ➊。在下一行，我们开始一个while循环，直到x等于100，这是我们设定的范围的上限。然后我们将x乘以2并加上5 ➋。如果输出等于13，我们告诉程序打印这个数字，因为那就是解。如果输出不等于13，我们告诉程序继续执行代码。
- en: 'The loop then starts over, and the program tests the next number, which we
    get by incrementing x by 1 ➌. We continue the loop until we hit a match. Be sure
    to include the last line, which makes the program run the plug() function we just
    defined; if you don’t, your program won’t do anything! The output should be this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后循环重新开始，程序测试下一个数字，我们通过将x增加1来得到这个数字 ➌。我们继续循环，直到找到匹配项。一定要包括最后一行，它会让程序运行我们刚才定义的plug()函数；如果你不包括这一行，程序就不会做任何事情！输出应该是这样的：
- en: x = 4
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: x = 4
- en: Using the guess-and-check method is a perfectly valid way to solve this problem.
    Plugging in all the digits by hand can be laborious, but using Python makes it
    a cinch! If you suspect the solution isn’t an integer, you might have to increment
    by smaller numbers by changing the line at ➌ to x += .25 or some other decimal
    value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用猜测和检验法是解决这个问题的完全有效的方法。手动插入所有数字可能很费力，但使用Python就轻松多了！如果你怀疑解不是整数，你可能需要通过更小的数字增量来调整，把 ➌行改为x
    += .25或其他小数值。
- en: FINDING THE FORMULA FOR FIRST-DEGREE EQUATIONS
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 求解一阶方程的公式
- en: Another way to solve an equation like 2*x* + 5 = 13 is to find a general formula
    for this type of equation. We can then use this formula to write a program in
    Python. You might recall from math class that the equation 2*x* + 5 = 13 is an
    example of a *first-degree equation*, because the highest exponent a variable
    has in this equation is 1\. And you probably know that a number raised to the
    first power equals the number itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决像2*x* + 5 = 13这样的方程的方法是找到这种类型方程的通用公式。然后我们可以使用这个公式写一个Python程序。你可能还记得在数学课上，方程2*x*
    + 5 = 13是一个*一阶方程*的例子，因为在这个方程中变量的最高指数是1。而且你可能知道，任何数的1次方等于它本身。
- en: 'In fact, all first-degree equations fit into this general formula: a*x* + b =
    c*x* + d, where a, b, c, and d represent different numbers. Here are some examples
    of other first-degree equations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，所有一阶方程都符合这个通用公式：a*x* + b = c*x* + d，其中a、b、c和d代表不同的数字。这里有一些其他一阶方程的例子：
- en: '![image](../images/e055-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e055-01.jpg)'
- en: On each side of the equal sign, you can see an *x* term and a *constant*, which
    is a number with no *x* attached to it. The number that precedes the *x* variable
    is called a *coefficient*. For example, the coefficient of 3*x* is 3.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号的两边，你可以看到一个*x*项和一个*常数*，常数是没有*x*的数字。前面跟在*x*变量前面的数字叫做*系数*。例如，3*x*的系数是3。
- en: 'But sometimes there’s no *x* term at all on one side of the equation, which
    means that the coefficient of that *x* is zero. You can see this in the first
    example, 3*x* − 5 = 22, where 22 is the only term on the right side of the equal
    sign:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候方程的一边根本没有*x*项，这意味着该*x*的系数为零。你可以在第一个例子中看到这一点，3*x* − 5 = 22，其中22是等号右侧唯一的项：
- en: '![image](../images/e055-02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e055-02.jpg)'
- en: Using the general formula, you can see that a = 3, b = −5, and d = 22\. The
    only thing that seems to be missing is the value of c. But it’s not actually missing.
    In fact, the fact that there’s nothing there means c*x* = 0, which means that
    c must equal zero.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用公式，你可以看到a = 3, b = −5, 和d = 22。唯一缺失的似乎是c的值。但实际上它并不缺失。事实上，什么都没有意味着c*x* =
    0，这意味着c必须等于零。
- en: Now let’s use a little algebra to solve the equation a*x* + b = c*x* + d for
    *x*. If we can find what *x* is in the formula, we can use it to solve virtually
    all equations of this form.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用一些代数来解这个方程a*x* + b = c*x* + d，求解*x*。如果我们能找到*x*的值，我们就可以用它来解所有这种形式的方程。
- en: 'To solve this equation, we first get all the *x*’s on one side of the equal
    sign by subtracting c*x* and b from both sides of the equation, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解这个方程，我们首先通过从方程两边减去c*x*和b，将所有*x*移到等号的一边，像这样：
- en: a*x* − c*x* = d − b
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: a*x* − c*x* = d − b
- en: 'Then we can factor out the *x* from a*x* and c*x*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将*x*从a*x*和c*x*中提取出来：
- en: '*x*(a − c) = d − b'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*(a − c) = d − b'
- en: 'Finally, divide both sides by a − c to isolate *x*, which gives us the value
    of *x* in terms of a, b, c, and d:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将两边同时除以 a − c 来孤立 *x*，这就得到了 *x* 关于 a、b、c 和 d 的值：
- en: '![image](../images/e056-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e056-01.jpg)'
- en: Now you can use this general equation to solve for any variable *x* when the
    equation is a first-degree equation and all coefficients (a, b, c, and d) are
    known. Let’s use this to write a Python program that can solve first-degree algebraic
    equations for us.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个一般方程在已知方程是一次方程且所有系数（a、b、c 和 d）已知的情况下，解出任何变量 *x*。我们来写一个 Python 程序，帮助我们解一次代数方程。
- en: WRITING THE EQUATION() FUNCTION
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 `equation()` 函数
- en: To write a program that will take the four coefficients of the general equation
    and print out the solution for *x*, open a new Python file in IDLE. Save it as
    *algebra.py*. We’ll write a function that takes the four numbers a, b, c, and
    d as parameters and plug them into the formula (see [Listing 4-2](ch04.xhtml#ch04list2)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个程序，接受一般方程的四个系数并输出 *x* 的解，首先在 IDLE 中打开一个新的 Python 文件，保存为 *algebra.py*。我们将编写一个函数，接受四个数字
    a、b、c 和 d 作为参数，并将它们代入公式中（参见[示例 4-2](ch04.xhtml#ch04list2)）。
- en: 'def equation(a,b,c,d):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'def equation(a,b,c,d):'
- en: '''''''''solves equations of the'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''''解方程的'
- en: form ax + b = cx + d''''
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 形式 ax + b = cx + d''''
- en: return (d - b)/(a - c)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: return (d - b)/(a - c)
- en: '*Listing 4-2: Using programming to solve for x*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-2：使用编程求解 x*'
- en: 'Recall that the general formula of a first-degree equation is this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一次方程的一般公式是这样的：
- en: '![image](../images/e056-02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e056-02.jpg)'
- en: This means that for any equation with the form a*x* + b = c*x* + d, if we take
    the coefficients and plug them into this formula, we can calculate the *x* value.
    First, we set the equation() function to take the four coefficients as its parameters.
    Then we use the expression (d - b)/(a − c) to represent the general equation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于任何形式为 a*x* + b = c*x* + d 的方程，如果我们将系数代入这个公式，就可以计算出 *x* 的值。首先，我们设置 `equation()`
    函数来接收四个系数作为参数。然后我们使用表达式 (d - b)/(a − c) 来表示一般方程。
- en: 'Now let’s test our program with an equation you’ve already seen: 2*x* + 5 =
    13\. Open the Python shell, type the following code at the >>> prompt, and press
    ENTER:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用你已经看到的方程进行测试：2*x* + 5 = 13。打开 Python shell，在 >>> 提示符下输入以下代码，然后按回车键：
- en: '>>> equation(2,5,0,13)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> equation(2,5,0,13)'
- en: '4.0'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '4.0'
- en: If you input the coefficients of this equation into the function, you get 4
    as the solution. You can confirm that it’s correct by plugging in 4 in place of
    *x*. It works!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个方程的系数输入到函数中，你会得到 4 作为解。你可以通过将 4 代入 *x* 来确认它是正确的。它能工作！
- en: 'EXERCISE 4-1: SOLVING MORE EQUATIONS FOR X'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4-1：解更多关于 x 的方程
- en: Solve 12x + 18 = –34x + 67 using the program you wrote in [Listing 4-2](ch04.xhtml#ch04list2).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[示例 4-2](ch04.xhtml#ch04list2)中编写的程序解方程 12x + 18 = –34x + 67。
- en: USING PRINT() INSTEAD OF RETURN
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `print()` 代替 `return`
- en: 'In [Listing 4-2](ch04.xhtml#ch04list2), we used return instead of print() to
    display our results. This is because return gives us our result as a number that
    we can assign to a variable and then use again. [Listing 4-3](ch04.xhtml#ch04list3)
    shows what would happen if we used print() instead of return to find *x*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-2](ch04.xhtml#ch04list2)中，我们使用了 `return` 而不是 `print()` 来显示结果。因为 `return`
    会给我们一个数字结果，可以将其赋值给变量并再次使用。[示例 4-3](ch04.xhtml#ch04list3)展示了如果我们使用 `print()` 而不是
    `return` 来求解 *x* 时会发生什么：
- en: 'def equation(a,b,c,d):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'def equation(a,b,c,d):'
- en: '''''''''solves equations of the'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''''解方程的'
- en: form ax + b = cx + d''''
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 形式 ax + b = cx + d''''
- en: print((d - b)/(a − c))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: print((d - b)/(a − c))
- en: '*Listing 4-3: Using print() doesn’t let us save the output*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-3：使用 `print()` 无法保存输出*'
- en: 'When you run this, you get the same output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，你会得到相同的输出：
- en: '>>> x = equation(2,5,0,13)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = equation(2,5,0,13)'
- en: '4.0'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '4.0'
- en: '>>> print(x)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(x)'
- en: None
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: But when you try to call the x value using print(), the program doesn’t recognize
    your command because it hasn’t saved the result. As you can see, return can be
    more useful in programming because it lets you save the output of a function so
    you can apply it elsewhere. This is why we used return in [Listing 4-2](ch04.xhtml#ch04list2).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你尝试使用 `print()` 调用 x 值时，程序无法识别你的命令，因为它没有保存结果。正如你所看到的，`return` 在编程中更有用，因为它允许你保存函数的输出结果，这样你就可以在其他地方使用它。这就是我们在[示例
    4-2](ch04.xhtml#ch04list2)中使用 `return` 的原因。
- en: 'To see how you can work with the returned output, use the equation 12*x* +
    18 = −34*x* + 67 from Exercise 4-1 and assign the result to the x variable, as
    shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何使用返回的输出，使用练习 4-1 中的方程 12*x* + 18 = −34*x* + 67，并将结果赋值给 x 变量，如下所示：
- en: '>>> x = equation(12,18,-34,67)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = equation(12,18,-34,67)'
- en: '>>> x'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '1.065217391304348'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '1.065217391304348'
- en: First, we pass the coefficients and constants of our equation to the equation()
    function so that it solves the equation for us and assigns the solution to the
    variable x. Then we can simply enter x to see its value. Now that the variable
    x stores the solution, we can plug it back into the equation to check that it’s
    the correct answer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将方程的系数和常数传递给`equation()`函数，使其为我们求解方程并将解赋值给变量x。然后我们只需输入x就能看到其值。现在，变量x已经存储了解，我们可以将其代回方程中检查它是否是正确的答案。
- en: 'Enter the following to find out what 12*x* + 18, the left side of the equation,
    evaluates to:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容，看看12*x* + 18，即方程左侧的值，是多少：
- en: '>>> 12*x + 18'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 12*x + 18'
- en: '30.782608695652176'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '30.782608695652176'
- en: 'We get 30.782608695652176. Now enter the following to do the same for −34*x*
    + 67, the right side of the equation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到30.782608695652176。现在输入以下内容，做同样的操作来求解−34*x* + 67，即方程右侧的值：
- en: '>>> -34*x + 67'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -34*x + 67'
- en: '30.782608695652172'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '30.782608695652172'
- en: Except for a slight rounding discrepancy at the 15th decimal place, you can
    see that both sides of the equation evaluate to around 30.782608\. So we can be
    confident that 1.065217391304348 is indeed the correct solution for *x*! Good
    thing we returned the solution and saved the value instead of just printing it
    out once. After all, who wants to type in a number like 1.065217391304348 again
    and again?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在第15位小数处有轻微的四舍五入差异，你可以看到方程的两边都约等于30.782608。所以我们可以确信，1.065217391304348确实是*x*的正确解！幸好我们返回了解并保存了这个值，而不是仅仅打印出来一次。毕竟，谁愿意一遍又一遍地输入像1.065217391304348这样的数字呢？
- en: 'EXERCISE 4-2: FRACT IONS AS COEFFICIENTS'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4-2：系数为分数的方程
- en: 'Use the equation() function to solve the last, most sinister-looking equation
    you saw on [page 55](ch04.xhtml#page_55):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`equation()`函数来解你在[第55页](ch04.xhtml#page_55)看到的最后一个看起来最棘手的方程：
- en: '![image](../images/e058-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e058-01.jpg)'
- en: SOLVING HIGHER-DEGREE EQUATIONS
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求解高次方程
- en: 'Now that you know how to write programs that solve for unknown values in first-degree
    equations, let’s try something harder. For example, things get a little more complicated
    when an equation has a term raised to the second degree, like *x*² + 3*x* − 10 = 0\.
    These are called *quadratic equations*, and their general form looks like a*x*²
    + b*x* + c = 0, where a, b, and c can be any number: positive or negative, whole
    numbers, fractions, or decimals. The only exception is that a can’t be 0 because
    that would make this a first-degree equation. Unlike first-degree equations, which
    have one solution, quadratic equations have two possible solutions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何编写程序来解一元一次方程中的未知数，让我们来试试更复杂的内容。例如，当方程中有二次项时，事情就变得有些复杂，比如*x*² + 3*x* −
    10 = 0。这些被称为*二次方程*，它们的一般形式是a*x*² + b*x* + c = 0，其中a、b和c可以是任意数字：正数或负数、整数、分数或小数。唯一的例外是a不能为0，因为这会使得方程变成一元一次方程。与只有一个解的一元一次方程不同，二次方程有两个可能的解。
- en: 'To solve an equation with a squared term, you can use the *quadratic formula*,
    which is what you get when you isolate *x* by balancing the equation a*x*² + b*x*
    + c = 0:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解带有平方项的方程，你可以使用*二次公式*，这是通过将方程a*x*² + b*x* + c = 0中的*x*孤立出来得到的：
- en: '![image](../images/e058-02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e058-02.jpg)'
- en: The quadratic formula is a very powerful tool for solving equations, because
    no matter what a, b, and c are in a*x*² + b*x* + c = 0, you can just plug them
    in to the formula and use basic arithmetic to find your solutions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 二次公式是一个非常强大的解方程工具，因为无论a、b和c在a*x*² + b*x* + c = 0中是什么值，你都可以将它们代入公式，并使用基本的算术运算来找到解。
- en: We know that the coefficients of *x*² + 3*x* − 10 = 0 are 1, 3, and −10\. When
    we plug those in to the formula, we get
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，方程*x*² + 3*x* − 10 = 0的系数分别是1、3和−10。当我们将这些值代入公式时，得到：
- en: '![image](../images/e059-01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-01.jpg)'
- en: Isolate *x* and this simplifies to
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将*x*孤立，简化为：
- en: '![image](../images/e059-02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-02.jpg)'
- en: 'There are two solutions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个解：
- en: '![image](../images/e059-03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-03.jpg)'
- en: which is equal to 2, and
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其值为2，并且
- en: '![image](../images/e059-04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-04.jpg)'
- en: which is equal to −5.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其值为−5。
- en: 'We can see that replacing *x* in the quadratic formula with either of these
    solutions makes the equation true:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，将二次方程式中的*x*替换为这些解中的任意一个，可以使方程成立：
- en: (*2*)² + 3(*2*) − 10 = 4 + 6 − 10 = 0
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (*2*)² + 3(*2*) − 10 = 4 + 6 − 10 = 0
- en: (*−5*)² + 3(*−5*) − 10 = 25 − 15 − 10 = 0
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (*−5*)² + 3(*−5*) − 10 = 25 − 15 − 10 = 0
- en: Next, we’ll write a function that uses this formula to return two solutions
    for any quadratic equation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个函数，使用这个公式返回任何二次方程的两个解。
- en: USING QUAD() TO SOLVE QUADRATIC EQUATIONS
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 QUAD() 求解二次方程
- en: 'Let’s say we want to use Python to solve the following quadratic equation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想用 Python 求解以下二次方程：
- en: 2*x*² + 7*x* − 15 = 0
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x*² + 7*x* − 15 = 0
- en: 'To do this, we’ll write a function called quad() that takes the three coefficients
    (a, b, and c) and returns two solutions. But before we do anything, we need to
    import the sqrt method from the math module. The sqrt method allows us to find
    the square root of a number in Python, just like a square root button on a calculator.
    It works great for positive numbers, but if you try finding the square root of
    a negative number, you’ll see an error like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将编写一个名为 quad() 的函数，该函数接受三个系数（a、b 和 c）并返回两个解。但在开始之前，我们需要导入 math 模块中的
    sqrt 方法。sqrt 方法可以帮助我们在 Python 中计算平方根，就像计算器上的平方根按钮一样。它对正数很好用，但如果你尝试对负数求平方根，就会出现如下错误：
- en: '>>> frommath importsqrt'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from math import sqrt'
- en: '>>> sqrt(-4)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sqrt(-4)'
- en: 'Traceback (most recent call last):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<pyshell#11>", line 1, in <module>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#11>"，第 1 行，在 <module> 中：
- en: sqrt(-4)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: sqrt(-4)
- en: 'ValueError: math domain error'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: 数学域错误'
- en: 'Open a new Python file in IDLE and name it *polynomials.py*. Add the following
    line to the top of your file to import the sqrt function from the math module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 中打开一个新的 Python 文件，并命名为 *polynomials.py*。在文件顶部添加以下行以导入 math 模块中的 sqrt
    函数：
- en: from math import sqrt
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: from math import sqrt
- en: Then enter the code in [Listing 4-4](ch04.xhtml#ch04list4) to create the quad()
    function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 [清单 4-4](ch04.xhtml#ch04list4) 中输入代码，创建 quad() 函数。
- en: 'def quad(a,b,c):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'def quad(a,b,c):'
- en: '''''''''Returns the solutions of an equation'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''''返回方程的解'
- en: of the form a*x**2 + b*x + c = 0''''
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 a*x**2 + b*x + c = 0''''
- en: x1 = (-b + sqrt(b**2 - 4*a*c))/(2*a)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = (-b + sqrt(b**2 - 4*a*c))/(2*a)
- en: x2 = (-b - sqrt(b**2 - 4*a*c))/(2*a)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = (-b - sqrt(b**2 - 4*a*c))/(2*a)
- en: return x1,x2
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: return x1,x2
- en: '*Listing 4-4: Using the quadratic formula to solve an equation*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：使用二次公式求解方程*'
- en: The quad() function takes the numbers a, b, and c as parameters and plugs them
    in to the quadratic formula. We use x1 to assign the result of (the first solution),
    and x2 will store the value of (the second solution).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: quad() 函数接受 a、b 和 c 这三个数字作为参数，并将它们代入二次公式中。我们使用 x1 来存储第一个解的结果，x2 将存储第二个解的值。
- en: 'Now, let’s test this program to solve for *x* in 2*x*² + 7*x* − 15 = 0\. Plugging
    in the numbers 2, 7, and −15 for a, b, and c should return the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这个程序来求解 2*x*² + 7*x* − 15 = 0 中的 *x*。将 2、7 和 −15 代入 a、b 和 c 应该返回以下输出：
- en: '>>> quad(2,7,-15)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> quad(2, 7, -15)'
- en: (1.5, -5.0)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (1.5, -5.0)
- en: 'As you can see, the two solutions for *x* are 1.5 and −5, which means both
    values should satisfy the equation 2*x*² + 7*x* − 15 = 0\. To test this, replace
    all the *x* variables in the original equation 2*x*² + 7*x* − 15 = 0 with 1.5,
    the first solution, and then with −5, the second solution, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*x* 的两个解是 1.5 和 −5，这意味着这两个值应该都满足方程 2*x*² + 7*x* − 15 = 0。为了验证这一点，先将第一个解
    1.5 代入原方程 2*x*² + 7*x* − 15 = 0，再将第二个解 −5 代入，结果如下所示：
- en: '>>> 2*1.5**2 + 7*1.5 - 15'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2*1.5**2 + 7*1.5 - 15'
- en: '0.0'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '>>> 2*(-5)**2 + 7*(-5) - 15'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2*(-5)**2 + 7*(-5) - 15'
- en: '0'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Success! This confirms that both values work in the original equation. You can
    use the equation() and quad() functions any time in the future. Now that you’ve
    learned to write functions to solve first-degree and second-degree equations,
    let’s discuss how to solve even higher-degree equations!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！这确认了这两个值在原方程中都成立。以后你可以随时使用 equation() 和 quad() 函数。现在你已经学会了如何写函数来求解一阶和二阶方程，接下来我们来讨论如何求解更高阶的方程！
- en: USING PLUG() TO SOLVE A CUBIC EQUATION
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 PLUG() 求解三次方程
- en: In algebra class, students are often asked to solve a *cubic equation* like
    6*x*³ + 31*x*² + 3*x* − 10 = 0, which has a term raised to the third degree. We
    can tweak the plug() function we wrote in [Listing 4-1](ch04.xhtml#ch04list1)
    to solve this cubic equation using the brute-force method. Enter the code shown
    in [Listing 4-5](ch04.xhtml#ch04list5) into IDLE to see this in action.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数课上，学生们常常被要求求解像 6*x*³ + 31*x*² + 3*x* − 10 = 0 这样的 *三次方程*，它包含了一个三次项。我们可以修改在
    [清单 4-1](ch04.xhtml#ch04list1) 中编写的 plug() 函数，使用暴力法来求解这个三次方程。在 IDLE 中输入 [清单 4-5](ch04.xhtml#ch04list5)
    中的代码，看看实际效果。
- en: '*plug.py*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*plug.py*'
- en: 'def g(x):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'def g(x):'
- en: return 6*x**3 + 31*x**2 + 3*x − 10
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: return 6*x**3 + 31*x**2 + 3*x − 10
- en: 'def plug():'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'def plug():'
- en: x = -100
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: x = -100
- en: 'while x < 100:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x < 100:'
- en: 'if g(x) == 0:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 g(x) == 0：
- en: print("x =",x)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: print("x =", x)
- en: x += 1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x += 1
- en: print("done.")
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: print("done.")
- en: '*Listing 4-5: Using plug() to solve a cubic equation*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：使用 plug() 求解三次方程*'
- en: First, we define g(x) to be a function that evaluates the expression 6*x**3
    + 31*x**2 + 3*x − 10, the left side of our cubic equation. Then we tell the program
    to plug all numbers between −100 and 100 into the g(x) function we just defined.
    If the program finds a number that makes g(x) equal zero, then it has found the
    solution and prints it for the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义g(x)为一个函数，计算表达式6*x**3 + 31*x**2 + 3*x − 10，即我们的三次方程的左边。然后我们告诉程序将所有−100到100之间的数字代入我们刚定义的g(x)函数中。如果程序找到一个使得g(x)等于零的数字，那么它就找到了一个解，并将其打印出来。
- en: 'When you call plug(), you should see the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用plug()时，你应该看到以下输出：
- en: '>>> plug()'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plug()'
- en: x = -5
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: x = −5
- en: done.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: This gives you −5 as the solution, but as you might suspect from working with
    quadratic equations previously, the *x*³ term means there could be as many as
    three solutions to this equation. As you can see, you can brute-force your way
    to a solution like this, but you won’t be able to determine whether other solutions
    exist or what they are. Fortunately, there’s a way to see all the possible inputs
    and corresponding outputs of a function; it’s called *graphing*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出的解是−5，但正如你之前处理二次方程时可能猜到的那样，*x*³项意味着这个方程可能有多达三个解。正如你所看到的，你可以通过暴力破解的方式找到解，但你无法确定是否存在其他解，或者它们是什么。幸运的是，有一种方法可以查看函数的所有可能输入及其对应的输出；这叫做*图形化*。
- en: SOLVING EQUATIONS GRAPHICALLY
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过图形化解决方程
- en: In this section, we’ll use a nifty tool called Processing to graph higher-degree
    equations. This tool will help us find solutions to higher-degree equations in
    a fun and visual way! If you haven’t already installed Processing, follow the
    instructions in “Installing Processing” on [page xxiii](ch00.xhtml#page_xxiii).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个叫做Processing的巧妙工具来图形化处理高次方程。这个工具将帮助我们以有趣且直观的方式找到高次方程的解！如果你还没有安装Processing，请按照[第xxiii页](ch00.xhtml#page_xxiii)中的“安装Processing”说明进行安装。
- en: GETTING STARTED WITH PROCESSING
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始使用Processing
- en: Processing is a programming environment and a graphics library that makes it
    easy to visualize your code. You can see the cool, dynamic, interactive art you
    can make with Processing in the examples page at *[https://processing.org/examples/](https://processing.org/examples/)*.
    You can think of Processing as a sketchbook for your programming ideas. In fact,
    each Processing program you create is called a *sketch*. [Figure 4-2](ch04.xhtml#ch04fig2)
    shows what a short Processing sketch in Python mode looks like.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Processing是一个编程环境和图形库，它使得可视化代码变得非常容易。你可以在* [https://processing.org/examples/](https://processing.org/examples/)*的示例页面上看到你可以用Processing制作的炫酷、动态、互动艺术。你可以把Processing看作是一个程序设计创意的草图本。事实上，每个你创建的Processing程序都叫做*草图*。[图4-2](ch04.xhtml#ch04fig2)展示了Python模式下一个简短Processing草图的样子。
- en: '![image](../images/f062-01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f062-01.jpg)'
- en: '*Figure 4-2: Example of a Processing sketch*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：Processing草图示例*'
- en: 'As you can see, there’s a programming environment where you enter code and
    a separate *display window* that shows the visualization of the code. This is
    a sketch of a simple program that creates a small circle. Every one of the Processing
    sketches we’ll create will contain two of Processing’s built-in functions: setup()
    and draw(). The code we put in the setup() function will be run once, when you
    click the play button, the arrow at the top left of the interface. Whatever we
    put in draw() will be repeated as an infinite loop until you click the stop button
    next to the play button.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个编程环境，你在其中输入代码，另有一个*显示窗口*用于展示代码的可视化效果。这是一个简单程序的草图，创建了一个小圆圈。我们将要创建的每一个Processing草图都会包含两个Processing的内置函数：setup()和draw()。我们在setup()函数中写的代码会在你点击播放按钮后运行一次，播放按钮位于界面左上角。我们在draw()中写的代码会无限循环执行，直到你点击播放按钮旁边的停止按钮。
- en: 'In [Figure 4-2](ch04.xhtml#ch04fig2) you can see in the setup() function we
    declared the size of the display screen to be 600 pixels by 600 pixels using the
    size() function. In the draw() function we told the program to draw a circle using
    the ellipse() function. Where? How big? We have to tell the ellipse() function
    four numbers: the x-coordinate of the ellipse, its y-coordinate, its width, and
    its height.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-2](ch04.xhtml#ch04fig2)中，你可以看到在setup()函数中我们使用size()函数声明了显示屏的大小为600像素×600像素。在draw()函数中，我们告诉程序使用ellipse()函数绘制一个圆圈。在哪里绘制？多大？我们需要告诉ellipse()函数四个数字：椭圆的x坐标、y坐标、宽度和高度。
- en: Notice the circle shows up in the middle of the screen, which in math class
    is the *origin* (0,0). But in Processing and in many other graphics libraries,
    (0,0) is in the top left corner of the screen. So to put a circle in the middle,
    I had to divide the length of the window (600) and the width of the window (600)
    in half. So its location is (300,300), and not (0,0).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，圆形出现在屏幕的中央，在数学课上这就是*原点*（0,0）。但在Processing和许多其他图形库中，（0,0）位于屏幕的左上角。因此，要将圆形放在中间，我必须将窗口的长度（600）和宽度（600）各除以2。所以它的位置是（300,300），而不是（0,0）。
- en: Processing has a number of functions, like ellipse(), that make it easy to draw
    shapes. To see the full list, look at the reference pages at *[https://processing.org/reference/](https://processing.org/reference/)*
    to find functions for drawing ellipses, triangles, rectangles, arcs, and much
    more. We’ll explore drawing shapes with Processing in more detail in the next
    chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Processing有许多函数，如ellipse()，可以方便地绘制形状。要查看完整的函数列表，可以访问* [https://processing.org/reference/](https://processing.org/reference/)*，在那里你可以找到用于绘制椭圆、三角形、矩形、弧形等形状的函数。在下一章中，我们将详细探讨如何使用Processing绘制形状。
- en: '**NOTE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The code colors in Processing appear different from those used in IDLE. For
    example, you can see that def appears green in Processing in [Figure 4-2](ch04.xhtml#ch04fig2),
    whereas it is orange in IDLE*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Processing中的代码颜色与IDLE中的颜色有所不同。例如，你可以看到在[图4-2](ch04.xhtml#ch04fig2)中，def在Processing中显示为绿色，而在IDLE中则为橙色*。'
- en: '#### CREATING YOUR OWN GRAPHING TOOL'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 创建你自己的绘图工具'
- en: Now that you’ve downloaded Processing, let’s use it to create a graphing tool
    that allows us to see how many solutions an equation has. First, we create a grid
    of blue lines that looks like graphing paper. Then, we create the x- and y-axes
    using black lines.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载了Processing，让我们用它创建一个绘图工具，让我们能够看到一个方程有多少解。首先，我们创建一个蓝色线条的网格，看起来像绘图纸。然后，我们用黑线创建x轴和y轴。
- en: Setting Graph Dimensions
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置图表尺寸
- en: In order to make a grid for our graphing tool, we first need to set the dimensions
    of the display window. In Processing, you can use the size() function to indicate
    the width and height of the screen in pixels. The default screen size is 600 pixels
    by 600 pixels, but for our graphing tool we’ll create a graph that includes x-
    and y-values ranging from −10 to 10.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作我们的绘图工具网格，首先需要设置显示窗口的尺寸。在Processing中，可以使用size()函数来指定屏幕的宽度和高度（以像素为单位）。默认的屏幕尺寸为600像素乘600像素，但为了我们的绘图工具，我们将创建一个x值和y值范围从−10到10的图表。
- en: Open a new file in Processing and save it as *grid.pyde*. Make sure you’re in
    Python mode. Enter the code in [Listing 4-6](ch04.xhtml#ch04list6) to declare
    the range of x- and y-values we’re interested in displaying for our graph.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Processing中的新文件，并将其保存为*grid.pyde*。确保你处于Python模式。输入[清单4-6](ch04.xhtml#ch04list6)中的代码，声明我们希望在图表中显示的x值和y值的范围。
- en: '*grid.pyde*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: '#set the range of x-values'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置x值的范围'
- en: xmin = -10
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -10
- en: xmax = 10
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 10
- en: '#range of y-values'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#y值的范围'
- en: ymin = -10
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -10
- en: ymax = 10
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = 10
- en: '#calculate the range'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算范围'
- en: rangex = xmax - xmin
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: rangex = xmax - xmin
- en: rangey = ymax - ymin
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: rangey = ymax - ymin
- en: 'def setup():'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '*Listing 4-6: Setting the range of x- and y-values for the graph*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-6：设置图表的x值和y值范围*'
- en: In [Listing 4-6](ch04.xhtml#ch04list6) we create two variables, xmin and xmax,
    for the minimum and maximum x-values in our grid, then we repeat the process for
    the y-values. Next we declare rangex for the x-range and rangey variable for the
    y-range. We calculate the value of rangex by subtracting xmin from xmax and do
    the same for the y-values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单4-6](ch04.xhtml#ch04list6)中，我们创建了两个变量xmin和xmax，分别表示网格中的最小和最大x值，然后对y值执行相同的操作。接着，我们声明rangex作为x值范围，rangey作为y值范围。我们通过从xmax中减去xmin来计算rangex的值，对y值也执行同样的操作。
- en: Because we don’t need a graph that’s 600 units by 600 units, we need to scale
    the coordinates down by multiplying the x- and y-coordinates by scale factors.
    When graphing we have to remember to multiply all our x-coordinates and y-coordinates
    by these scale factors; otherwise, they won’t show up correctly on the screen.
    To do this, update the existing code in the setup() function with the lines of
    code in [Listing 4-7](ch04.xhtml#ch04list7).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不需要一个600单位乘600单位的图表，所以我们需要通过将x和y坐标乘以比例因子来缩放坐标。在绘图时，我们必须记得将所有的x坐标和y坐标乘以这些比例因子，否则它们将无法正确显示在屏幕上。为此，请在setup()函数中更新现有代码，使用[清单4-7](ch04.xhtml#ch04list7)中的代码行。
- en: '*grid.pyde*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: def setup()
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: def setup()
- en: global xscl, yscl
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: size(600,600)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: xscl = width / rangex
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: xscl = width / rangex
- en: yscl = -height / rangey
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = -height / rangey
- en: '*Listing 4-7: Scaling coordinates using scale factors*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-7: 使用缩放因子缩放坐标*'
- en: First, we declare the global variables xscl and yscl, which we’ll use to scale
    our screen. xscl and yscl stand for the x-scale factor and y-scale factor, respectively.
    For example, the x-scale factor would be 1 if we want our x-range to be 600 pixels,
    or the full width of the screen. But if we want our screen to be between −300
    and 300, the x-scale factor would be 2, which we get by dividing the width (600)
    by the rangex (300).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明全局变量xscl和yscl，稍后我们将用它们来缩放我们的屏幕。xscl和yscl分别表示x缩放因子和y缩放因子。例如，如果我们希望x范围是600像素，或屏幕的完整宽度，那么x缩放因子就是1。但如果我们希望屏幕范围在−300到300之间，那么x缩放因子将是2，这是通过将宽度（600）除以范围x（300）得到的。
- en: In our case, we can calculate the scale factor by dividing 600 by the x-range,
    which is 20 (−10 to 10). So the scale factor has to be 30\. From now on, we need
    to scale up all of our x- and y-coordinates by a factor of 30 so that they show
    on the screen. The good news is that the computer will do all the dividing and
    scaling for us. We just have to remember to use xscl and yscl when graphing!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以通过将600除以x范围（20，范围是从−10到10）来计算缩放因子。所以，缩放因子必须是30。从现在开始，我们需要将所有的x和y坐标按30的比例缩放，以便它们能在屏幕上显示。好消息是，计算机会为我们做所有的除法和缩放。我们只需要记得在绘图时使用xscl和yscl！
- en: Drawing a Grid
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制网格
- en: Now that we’ve set the proper dimensions for our graph, we can draw grid lines
    like the ones you see on graphing paper. Everything in the setup() function will
    be run once. Then we create an infinite loop with a function called draw(). Setup()
    and draw() are built-in Processing functions, and you can’t change their names
    if you want the sketch to run. Add the code in [Listing 4-8](ch04.xhtml#ch04list8)
    to create the draw() function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为图形设置了合适的尺寸，可以像绘制图纸上的网格线一样绘制网格线。setup()函数中的所有内容都会被执行一次。然后，我们创建一个无限循环，使用一个名为draw()的函数。setup()和draw()是Processing的内置函数，如果你希望草图能够运行，不能更改它们的名称。添加[Listing
    4-8](ch04.xhtml#ch04list8)中的代码来创建draw()函数。
- en: '*grid.pyde*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: '#set the range of x-values'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置x值的范围'
- en: xmin = -10
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -10
- en: xmax = 10
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 10
- en: '#range of y-values'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#y值的范围'
- en: ymin = -10
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -10
- en: ymax = 10
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = 10
- en: '#calculate the range'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算范围'
- en: rangex = xmax - xmin
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: rangex = xmax - xmin
- en: rangey = ymax - ymin
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: rangey = ymax - ymin
- en: 'def setup():'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global xscl, yscl
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: size(600,600)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: xscl = width / rangex
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: xscl = width / rangex
- en: yscl = height / rangey
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = height / rangey
- en: 'def draw():'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: 'background(255) #white'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色'
- en: translate(width/2,height/2)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: '#cyan lines'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '#青色线条'
- en: strokeWeight(1)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(1)
- en: stroke(0,255,255)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(0,255,255)
- en: 'for i in range(xmin,xmax + 1):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin, xmax + 1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: '*Listing 4-8: Creating blue grid lines for the graph*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-8: 创建图形的蓝色网格线*'
- en: First, we use global xscl, yscl to tell Python we’re not creating new variables
    but just using the global ones we already created. Then we set the background
    color to white using the value 255\. We use Processing’s translate() function
    to move shapes up and down, or left and right. The code translate(width/2,height/2)
    will move the origin (where x and y are both 0) from the top left to the center
    of the screen. Then we set the thickness of the lines with strokeWeight, where
    1 is the thinnest. You can make them thicker if you want by using higher numbers.
    You can also change the color of the lines using stroke. Here, we’re using cyan
    (“sky blue”), whose RGB value is (0,255,255), which means no red values, maximum
    green, and maximum blue.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用全局的xscl、yscl告诉Python我们不是创建新的变量，而是使用我们已经创建的全局变量。然后，我们使用值255将背景颜色设置为白色。我们使用Processing的translate()函数来移动图形，可以上下移动，也可以左右移动。代码translate(width/2,height/2)将原点（x和y都是0）从左上角移到屏幕中心。接着，我们用strokeWeight设置线条的粗细，1是最细的。如果你想要更粗的线条，可以使用更高的数字。你也可以通过使用stroke改变线条的颜色。在这里，我们使用的是青色（“天蓝色”），其RGB值为(0,255,255)，这意味着没有红色值，最大绿色和最大蓝色。
- en: After that, we use a for loop to avoid having to type 40 lines of code to draw
    40 blue lines. We want the blue lines to go from xmin to xmax, including xmax,
    because that’s how wide our graph should be.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用for循环来避免键入40行代码来绘制40条蓝色线条。我们希望蓝色线条从xmin延伸到xmax，包括xmax，因为这就是我们图形应该的宽度。
- en: RGB VALUES
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 值
- en: An RGB value is a mixture of red, green, and blue, in that order. The values
    range from 0 to 255\. For example, (255,0,0) means “maximum red, no green, no
    blue.” Yellow is a mixture of red and green only, and cyan (“sky blue”) is a mixture
    of green and blue only.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: RGB值是红、绿、蓝的混合，顺序为红、绿、蓝。它们的值范围是0到255。例如，（255,0,0）表示“最大红色，没有绿色，没有蓝色。”黄色是红色和绿色的混合，青色（“天蓝色”）是绿色和蓝色的混合。
- en: '![image](../images/f065-01.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f065-01.jpg)'
- en: 'Other colors are a mixture of different levels of red, green, and blue:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其他颜色是不同等级的红、绿、蓝的混合：
- en: '![image](../images/f065-02.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f065-02.jpg)'
- en: You can do a web search for “RGB Tables” to get RGB values for many more colors!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过网上搜索“RGB Tables”来获取更多颜色的RGB值！
- en: 'In Processing, you can draw a line by declaring four numbers: the x- and y-coordinates
    of the beginning and endpoints of the line. The vertical lines would look something
    like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中，你可以通过声明四个数字来绘制一条线：线的起点和终点的x和y坐标。竖直的线会像这样：
- en: line(-10,-10, -10,10)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: line(-10,-10, -10,10)
- en: line(-9,-10, -9,10)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: line(-9,-10, -9,10)
- en: line(-8,-10, -8,10)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: line(-8,-10, -8,10)
- en: But because range(x) doesn’t include x (as you learned previously), our for
    loop needs to go from xmin to xmax + 1 to include xmax.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为range(x)不包括x（正如你之前学到的），我们的for循环需要从xmin到xmax + 1，以包括xmax。
- en: 'Similarly, the horizontal lines would go like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，水平线会像这样：
- en: line(-10,-10, 10,-10)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: line(-10,-10, 10,-10)
- en: line(-10,-9, 10,-9)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: line(-10,-9, 10,-9)
- en: line(-10,-8, 10,-8)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: line(-10,-8, 10,-8)
- en: 'This time, you can see that the y-values are −10, −9, −8 and so on, whereas
    the x-values stay constant at −10 and 10, which are xmin and xmax. Let’s add another
    loop to go from ymin to ymax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你可以看到y值是−10，−9，−8，以此类推，而x值保持不变，分别是−10和10，它们是xmin和xmax。让我们再添加一个循环，从ymin到ymax：
- en: 'for i in range(xmin,xmax+1):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax+1):'
- en: line(i,ymin,i,ymax)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: line(i,ymin,i,ymax)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin,i,xmax,i)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin,i,xmax,i)
- en: 'If you graphed this right, you would now see a tiny splotch in the middle of
    the screen because the x- and y-coordinates go from −10 to 10, but the screen
    goes from 0 to 600 by default. This is because we haven’t multiplied all our x-
    and y-coordinates by their scale factor yet! To display the grid properly, update
    your code as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地绘制了这个图形，你现在应该能在屏幕中央看到一个小的斑点，因为x轴和y轴的坐标范围是从−10到10，而屏幕的默认显示范围是从0到600。这是因为我们还没有将所有的x轴和y轴坐标乘以它们的缩放因子！为了正确显示网格，请按照以下步骤更新代码：
- en: 'for i in range(xmin,xmax+1):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax+1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: Now you’re ready to create the x- and y-axes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好创建x轴和y轴了。
- en: Creating the X- and Y-Axes
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建X轴和Y轴
- en: To add the two black lines for the x- and y-axes, we first set the stroke color
    to black by calling the stroke() function (with 0 being black and 255 being white).
    Then we draw a vertical line from (0,−10) to (0,10) and a horizontal line from
    (−10,0) to (10,0). Don’t forget to multiply the values by their respective scale
    factors, unless they’re 0, in which case multiplying them wouldn’t change them
    anyway.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加x轴和y轴的两条黑色线条，我们首先通过调用stroke()函数将描边颜色设置为黑色（0为黑色，255为白色）。然后我们从(0,−10)到(0,10)画一条垂直线，从(−10,0)到(10,0)画一条水平线。别忘了将这些值乘以它们各自的缩放因子，除非它们是0，这样乘上去也不会改变。
- en: Listing 4-9 shows the complete code for creating the grid.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-9显示了创建网格的完整代码。
- en: '*grid.pyde*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: '#cyan lines'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '#青色线条'
- en: strokeWeight(1)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(1)
- en: stroke(0,255,255)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(0,255,255)
- en: 'for i in range(xmin,xmax+1):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax+1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: 'stroke(0) #black axes'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色坐标轴'
- en: line(0,ymin*yscl,0,ymax*yscl)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,ymin*yscl,0,ymax*yscl)
- en: line(xmin*xscl,0,xmax*xscl,0)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,0,xmax*xscl,0)
- en: '*Listing 4-9: Creating the grid lines*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-9：创建网格线条*'
- en: When you click **Run**, you should get a nice grid, like in [Figure 4-3](ch04.xhtml#ch04fig3).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**运行**时，你应该能看到一个漂亮的网格，像[图4-3](ch04.xhtml#ch04fig3)一样。
- en: '![image](../images/f067-01.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f067-01.jpg)'
- en: '*Figure 4-3: You’ve created a grid for graphing—and you only have to do it
    once!*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：你已经创建了一个用于绘制图表的网格—而且只需要做一次！*'
- en: 'This looks done, but if we try to put a point (a tiny ellipse, actually) at
    (3,6), we see a problem. Add the following code to the end of the draw() function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来已经完成了，但如果我们尝试在(3,6)处放置一个点（实际上是一个小椭圆），我们会看到一个问题。将以下代码添加到draw()函数的末尾：
- en: '*grid.pyde*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: '#test with a circle'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '#test with a circle'
- en: fill(0)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: ellipse(3*xscl,6*yscl,10,10)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(3*xscl,6*yscl,10,10)
- en: When you run this, you’ll see the output in [Figure 4-4](ch04.xhtml#ch04fig4).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，你将在 [图 4-4](ch04.xhtml#ch04fig4) 中看到输出。
- en: '![image](../images/f067-02.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f067-02.jpg)'
- en: '*Figure 4-4: Checking our graphing program. Almost there!*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：检查我们的绘图程序。快到了！*'
- en: 'As you can see, the point ends up on (3,−6) instead of at (3,6). Our graph
    is upside-down! To fix this, we can add a negative sign to the y-scale factor
    in the setup() function to flip it over:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，点位于 (3,−6) 而不是 (3,6)。我们的图形是颠倒的！为了修正这个问题，我们可以在 setup() 函数中的 y 轴比例因子前面加一个负号来翻转它：
- en: yscl = -height/rangey
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = -height/rangey
- en: Now, you should see the point at the correct location, like in [Figure 4-5](ch04.xhtml#ch04fig5).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能看到正确位置的点，就像在 [图 4-5](ch04.xhtml#ch04fig5) 中一样。
- en: '![image](../images/f068-01.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f068-01.jpg)'
- en: '*Figure 4-5: The grapher is working properly!*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：绘图器正常工作！*'
- en: Now that we’ve written the graphing tool, let’s put it into a function so we
    can reuse it whenever we need to graph an equation.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了绘图工具，让我们将其放入一个函数中，这样我们可以在需要绘制方程时重复使用它。
- en: Writing the grid() Function
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 grid() 函数
- en: To keep our code organized, we’ll separate all the code that makes the grid
    and place it in its own function, which we’ll call grid(). Then we’ll call the
    grid() function in the draw() function like in [Listing 4-10](ch04.xhtml#ch04list10).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为保持代码的整洁，我们将所有创建网格的代码放入一个名为 grid() 的单独函数中，并在 draw() 函数中调用 grid() 函数，就像在 [代码清单
    4-10](ch04.xhtml#ch04list10) 中一样。
- en: '*grid.pyde*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: 'def draw():'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 xscl, yscl
- en: background(255)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(width/2,height/2)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: 'grid(xscl,yscl) #draw the grid'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid(xscl,yscl) #绘制网格'
- en: 'def grid(xscl,yscl):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grid(xscl,yscl):'
- en: '#Draws a grid for graphing'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#为绘图绘制网格'
- en: '#cyan lines'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#青色线'
- en: strokeWeight(1)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(1)
- en: stroke(0,255,255)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(0,255,255)
- en: 'for i in range(xmin,xmax+1):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax+1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: 'stroke(0) #black axes'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色轴线'
- en: line(0,ymin*yscl,0,ymax*yscl)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,ymin*yscl,0,ymax*yscl)
- en: line(xmin*xscl,0,xmax*xscl,0)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,0,xmax*xscl,0)
- en: '*Listing 4-10: Moving all the grid code into a separate function*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 4-10：将所有网格代码移至单独的函数中*'
- en: In programming we often organize our code into functions. Notice in [Listing
    4-10](ch04.xhtml#ch04list10) we can easily see what we’re executing in our draw()
    function. Now we’re ready to solve our cubic equation, 6*x*³ + 31*x*² + 3*x* −
    10 = 0.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们经常将代码组织成函数。请注意在 [代码清单 4-10](ch04.xhtml#ch04list10) 中，我们可以轻松看到我们在 draw()
    函数中执行的内容。现在我们准备解决我们的三次方程，6*x*³ + 31*x*² + 3*x* − 10 = 0。
- en: GRAPHING AN EQUATION
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制方程图
- en: Plotting graphs is a fun and visual way to find solutions of polynomials that
    have more than one potential solution for *x*. But before we try to graph a complicated
    equation like 6*x*³ + 31*x*² + 3*x* − 10 = 0, let’s plot a simple parabola.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图形是一种有趣且视觉化的方法，用于找出具有多个潜在解的多项式方程的解 *x*。但在我们尝试绘制像 6*x*³ + 31*x*² + 3*x* − 10
    = 0 这样复杂的方程之前，让我们先绘制一个简单的抛物线。
- en: Plotting Points
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制点
- en: 'Add this function after the draw() function from [Listing 4-10](ch04.xhtml#ch04list10):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [代码清单 4-10](ch04.xhtml#ch04list10) 的 draw() 函数之后添加此函数：
- en: '*grid.pyde*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: 'def f(x):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f(x):'
- en: return x**2
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: return x**2
- en: This defines the function we’re calling f(x). We’re telling Python what to do
    with the number *x* to produce the output of the function. In this case, we’re
    telling it to square the number *x* and return the output. Math classes have traditionally
    called functions f(x), g(x), h(x) and so on. Using a programming language, you
    can call functions whatever you like! We could have given this function a descriptive
    name like parabola(x), but since f(x) is commonly used, we’ll stick to that for
    now.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们正在调用的函数 f(x)。我们告诉 Python 如何处理数字 *x* 以生成函数的输出。在这种情况下，我们告诉它对数字 *x* 进行平方运算并返回输出。数学课程传统上称函数为
    f(x)、g(x)、h(x) 等。使用编程语言，您可以根据需要命名函数！我们本可以为这个函数取一个描述性的名字，比如 parabola(x)，但由于 f(x)
    常用，我们现在就坚持使用这个名字。
- en: This is a simple parabola that we’ll graph before getting into more complicated
    functions. All the points on this curve are simply the values for x and its corresponding
    y-value. We could use a loop and draw small ellipses for points at all the whole-number
    values for x, but that would look like an unconnected group of points, as in [Figure
    4-6](ch04.xhtml#ch04fig6).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的抛物线，我们将在深入研究更复杂的函数之前绘制它。曲线上的所有点只是x值及其对应的y值。我们可以使用循环在所有整数x值的点上绘制小椭圆，但那样看起来会像是一组不连贯的点，如同[图4-6](ch04.xhtml#ch04fig6)所示。
- en: '![image](../images/f069-01.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f069-01.jpg)'
- en: '*Figure 4-6: A graph of disconnected dots*.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：不连贯点的图形*。'
- en: Using a different kind of loop, we could draw dots closer together, as in [Figure
    4-7](ch04.xhtml#ch04fig7).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同种类的循环，我们可以将点绘得更紧凑，如同[图4-7](ch04.xhtml#ch04fig7)所示。
- en: '![image](../images/f070-01.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f070-01.jpg)'
- en: '*Figure 4-7: The dots are closer together, but it’s still not a convincing
    curve*.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：点之间更靠近，但仍然不像一个有说服力的曲线*。'
- en: The best way to make a connected curve is to draw lines from point to point.
    If the points are close enough together, they’ll look curved. First, we’ll create
    a graphFunction() function after f(x).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制连接曲线的最佳方法是从一个点绘制到下一个点。如果点之间足够接近，它们看起来会是弯曲的。首先，我们将在f(x)之后创建一个graphFunction()函数。
- en: Connecting the Points
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接点
- en: 'In the graphFunction() function, start x at xmin, like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在graphFunction()函数中，像这样从xmin开始x值：
- en: '*grid.pyde*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: 'def graphFunction():'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphFunction():'
- en: x = xmin
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: x = xmin
- en: 'To make the graph extend across the whole grid, we’ll keep increasing x until
    it’s equal to xmax. That means we’ll keep this loop going “while x is less than
    or equal to xmax,” as shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让图形覆盖整个网格，我们将不断增加x值，直到它等于xmax。这意味着我们将持续这个循环，“只要x小于或等于xmax”，如这里所示：
- en: 'def graphFunction():'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphFunction():'
- en: x = xmin
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: x = xmin
- en: 'while x <= xmax:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x <= xmax:'
- en: To draw the curve itself, we’ll draw lines from every point to every next point,
    going up a tenth of a unit at a time. Even if our function produces a curve, you
    probably won’t notice if we’re drawing a straight line between two points that
    are really close together. For example, the distance from (2, f(2)) to (2.1, f(2.1))
    is tiny, so overall the output will look curved.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制曲线本身，我们将从每个点绘制到下一个点，每次上升十分之一单位。即使我们的函数生成了曲线，你可能也不会注意到我们在绘制两个非常接近的点之间的直线。例如，(2,
    f(2))到(2.1, f(2.1))的距离非常小，所以最终的输出看起来是弯曲的。
- en: 'def graphFunction():'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphFunction():'
- en: x = xmin
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: x = xmin
- en: 'while x <= xmax:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x <= xmax:'
- en: fill(0)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)
- en: x += 0.1
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: x += 0.1
- en: This code defines a function that draws a graph of f(x) by starting at xmin
    and going all the way up to xmax. While the x-value is less than or equal to xmax,
    we’ll draw a line from (x, f(x)) to ((x + 0.1), f(x + 0.1)). We can’t forget to
    increment x by 0.1 at the end of the loop.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个函数，通过从xmin开始一直到xmax来绘制f(x)的图形。当x值小于或等于xmax时，我们将绘制一条从(x, f(x))到((x +
    0.1), f(x + 0.1))的线。我们不能忘记在循环结束时将x增加0.1。
- en: Listing 4-11 shows the whole code for *grid.pyde*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-11展示了*grid.pyde*的完整代码。
- en: '*grid.pyde*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: '#set the range of x-values'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '#设定x值范围'
- en: xmin = -10
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -10
- en: xmax = 10
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 10
- en: '#range of y-values'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '#y值范围'
- en: ymin = -10
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -10
- en: ymax = 10
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = 10
- en: '#calculate the range'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算范围'
- en: rangex = xmax - xmin
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: rangex = xmax - xmin
- en: rangey = ymax - ymin
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: rangey = ymax - ymin
- en: 'def setup():'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global xscl, yscl
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: size(600,600)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: xscl = width / rangex
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: xscl = width / rangex
- en: yscl = -height / rangey
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = -height / rangey
- en: 'def draw():'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: 'background(255) #white'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色'
- en: translate(width/2,height/2)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: grid(xscl,yscl)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: grid(xscl,yscl)
- en: graphFunction()
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: graphFunction()
- en: 'def f(x):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f(x):'
- en: return x**2
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: return x**2
- en: 'def graphFunction():'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphFunction():'
- en: x = xmin
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: x = xmin
- en: 'while x <= xmax:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x <= xmax:'
- en: fill(0)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)
- en: x += 0.1
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: x += 0.1
- en: 'def grid(xscl, yscl):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grid(xscl, yscl):'
- en: '#Draws a grid for graphing'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '#为绘制图形绘制网格'
- en: '#cyan lines'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '#青色线条'
- en: strokeWeight(1)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(1)
- en: stroke(0,255,255)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(0,255,255)
- en: 'for i in range(xmin,xmax+1):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax+1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: 'stroke(0) #black axes'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色坐标轴'
- en: line(0,ymin*yscl,0,ymax*yscl)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,ymin*yscl,0,ymax*yscl)
- en: line(xmin*xscl,0,xmax*xscl,0)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,0,xmax*xscl,0)
- en: '*Listing 4-11: Complete code for graphing the parabola*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-11：绘制抛物线的完整代码*'
- en: This gets us the curve we’re looking for, as shown in [Figure 4-8](ch04.xhtml#ch04fig8).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了所需的曲线，如[图 4-8](ch04.xhtml#ch04fig8)所示。
- en: '![image](../images/f072-01.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f072-01.jpg)'
- en: '*Figure 4-8: A nice continuous graph of a parabola!*'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：漂亮的连续抛物线图！*'
- en: 'Now we can change our function to something more complicated, and the grapher
    will easily draw it:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将函数改成更复杂的形式，绘图程序会轻松绘制出来：
- en: '*grid.pyde*'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*grid.pyde*'
- en: 'def f(x):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f(x):'
- en: return 6*x**3 + 31*x**2 + 3*x − 10
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: return 6*x**3 + 31*x**2 + 3*x − 10
- en: With this simple change, you’ll see the output in [Figure 4-9](ch04.xhtml#ch04fig9),
    but the function will be in black. If you prefer a red curve, change the stroke(0)
    line in graphFunction() to stroke(255,0,0), and you’ll get a red function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的修改，你会看到[图 4-9](ch04.xhtml#ch04fig9)中的输出，不过函数将显示为黑色。如果你更喜欢红色曲线，只需将 graphFunction()
    中的 stroke(0) 行改为 stroke(255,0,0)，你就会看到红色曲线。
- en: '![image](../images/f072-02.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f072-02.jpg)'
- en: '*Figure 4-9: Graphing a polynomial function*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：绘制多项式函数*'
- en: 'It’s great to be able to simply change one line in the f() function and have
    the program automatically graph a different function! The solutions (called the
    *roots*) of the equation are where the graph crosses the x-axis. We can see three
    places: one where *x* = −5, another where *x* is between −1 and 0, and a third
    where *x* is between 0 and 1.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 只需修改 f() 函数中的一行，就能让程序自动绘制不同的函数，真是太棒了！方程的解（称为 *根*）是图像与 x 轴交点的位置。我们可以看到三个位置：一个是在
    *x* = −5，另一个是在 −1 和 0 之间，第三个是在 0 和 1 之间。
- en: Using Guess and Check to Find the Roots
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用猜测和检查方法来寻找根
- en: 'We already saw how effective our guess-and-check method was for guessing numbers
    in [Chapter 3](ch03.xhtml#ch03). Now we can use it to approximate the roots, or
    solutions, for the equation 6*x*³ + 31*x*² + 3*x* − 10 = 0\. Let’s start with
    the root between 0 and 1\. Is it 0.5 or something else? To test this, we can easily
    plug 0.5 into the equation. Create a new file in IDLE, name it *guess.py*, and
    enter the following code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第 3 章](ch03.xhtml#ch03)中看到，猜测和检查方法在猜数字时是多么有效。现在，我们可以用它来近似方程 6*x³ + 31*x²
    + 3*x − 10 = 0 的根或解。让我们从 0 和 1 之间的根开始。它是 0.5 还是别的什么？为了测试这个，我们可以轻松地将 0.5 代入方程中。创建一个新的
    IDLE 文件，将其命名为 *guess.py*，并输入以下代码：
- en: '*guess.py*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*guess.py*'
- en: 'def f(x):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f(x):'
- en: return 6*x**3 + 31*x**2 + 3*x − 10
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: return 6*x**3 + 31*x**2 + 3*x − 10
- en: '>>> f(0.5)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f(0.5)'
- en: '0.0'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: As you can see, when *x* equals 0.5, it makes the function equal 0, so another
    solution of our equation is *x* = 0.5.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当 *x* 等于 0.5 时，它使得函数的值等于 0，因此我们的方程的另一个解是 *x* = 0.5。
- en: 'Next, let’s try to find the root between −1 and 0\. We’ll try the average of
    −1 and 0 to start:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试找到 −1 和 0 之间的根。我们将先尝试 −1 和 0 的平均值：
- en: '>>> f(-0.5)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f(-0.5)'
- en: '-4.5'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '-4.5'
- en: 'At *x* = −0.5, the function is negative, not zero. Looking at the graph, we
    can tell we guessed too high, so the root must be somewhere between −1 and −0.5\.
    We’ll average those endpoints and try again:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x* = −0.5 时，函数值为负数，而不是零。通过观察图像，我们可以看出我们的猜测太高了，因此根必须位于 −1 和 −0.5 之间。我们将这两个端点取平均值，再试一次：
- en: '>>> f(-0.75)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f(-0.75)'
- en: '2.65625'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '2.65625'
- en: 'We get a positive number, so we guessed too low. Therefore, the solution must
    be between −0.75 and −0.5:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个正数，所以我们的猜测太低了。因此，解必须在 −0.75 和 −0.5 之间：
- en: '>>> f(-0.625)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f(-0.625)'
- en: '-1.23046875'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '-1.23046875'
- en: Still too high. This is getting a bit tedious. Let’s see how we might use Python
    to do these steps for us.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然太高了。这个过程有点乏味。让我们看看如何利用 Python 来完成这些步骤。
- en: Writing the guess() Function
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 guess() 函数
- en: Let’s create a function that will find the roots of an equation by averaging
    the lower and upper values and adjusting its next guesses accordingly. This will
    work for our current task, where the function is passing through the x-axis from
    positive to negative. For a function going up, from negative to positive, we’d
    have to change it around a little. [Listing 4-12](ch04.xhtml#ch04list12) shows
    the complete code for this function.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，通过平均较低和较高的值并相应调整下一次猜测来找到方程的根。这对于我们当前的任务是有效的，在此任务中，函数从正值过渡到负值。对于一个上升的函数，从负值到正值，我们需要稍微调整一下。[列表
    4-12](ch04.xhtml#ch04list12)展示了这个函数的完整代码。
- en: '''''''The guess method'''''''
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''猜测方法'''''''
- en: 'def f(x):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f(x):'
- en: return 6*x**3 + 31*x**2 + 3*x - 10
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: return 6*x**3 + 31*x**2 + 3*x - 10
- en: 'def average(a,b):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'def average(a,b):'
- en: return (a + b)/2.0
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: return (a + b)/2.0
- en: 'def guess():'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 'def guess():'
- en: lower = -1
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: lower = -1
- en: upper = 0
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: upper = 0
- en: '➊ for i in range(20):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for i in range(20):'
- en: midpt = average(lower,upper)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: midpt = average(lower,upper)
- en: 'if f(midpt) == 0:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'if f(midpt) == 0:'
- en: return midpt
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: return midpt
- en: 'elif f(midpt) < 0:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif f(midpt) < 0:'
- en: upper = midpt
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: upper = midpt
- en: 'else:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: lower = midpt
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: lower = midpt
- en: return midpt
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: return midpt
- en: x = guess()
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: x = guess()
- en: print(x,f(x))
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: print(x,f(x))
- en: '*Listing 4-12: The guess method for solving equations*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-12：解方程的猜测方法*'
- en: First, we declare the function for the equation we’re trying to solve using
    f(x). Then we create the average() function to find the average of two numbers,
    which we’ll be using at every step. Finally, we write a guess() function that
    starts with a lower limit of −1 and an upper limit of 0, since that’s where our
    graph crossed the x-axis.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们尝试求解的方程的函数f(x)。然后我们创建average()函数来找到两个数字的平均值，这将在每一步中使用。最后，我们编写一个guess()函数，初始的下限为−1，上限为0，因为这是我们的图形与x轴交叉的地方。
- en: 'We then use for i in range(20): ➊ to create a loop that cuts the range by half
    20 times. Our guess will be the average, or midpoint, of the upper and lower limits.
    We put that midpoint into f(x) and if the output equals 0, we know that’s our
    root. If the output is negative, we know we guessed too high. Then the midpoint
    will replace our upper limit and we’ll take another guess. Otherwise, if we guessed
    too low, the midpoint will become our lower limit and we’ll guess again.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们使用for i in range(20): ➊来创建一个循环，将范围每次减半20次。我们的猜测将是上下限的平均值，或中点。我们将这个中点代入f(x)，如果输出为0，我们知道这就是我们的根。如果输出为负数，我们知道猜得太高了。然后中点将替代我们的上限，我们会再猜一次。否则，如果我们猜得太低，中点将成为我们的下限，我们会再次猜测。'
- en: If we haven’t returned the solution in 20 guesses, we return the latest midpoint
    and the function of that midpoint.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在20次猜测内没有找到解，我们就返回最新的中点及该中点的函数值。
- en: 'When we run this, we should get two values as the output:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们应该得到两个值作为输出：
- en: -0.6666669845581055 9.642708896251406e-06
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: -0.6666669845581055 9.642708896251406e-06
- en: The first output is the x-value, which is very close to −2/3\. The second output
    is what f(x) evaluates to when we plug in −2/3 as the x-value. The e-06 at the
    end is scientific notation, which means you take 9.64 and move the decimal place
    to the left six places. So f(x) evaluates to 0.00000964, which is very close to
    zero. To go through this guess-and-check program and get this solution, or rather
    an approximation accurate to within a millionth of the actual solution, to pop
    up in less than a second is still surprising and wonderful to me! Can you see
    the power in exploring math problems using free software like Python and Processing?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出是x值，它非常接近−2/3。第二个输出是当我们将−2/3代入x值时f(x)的值。结尾的e-06是科学计数法，表示将9.64的小数点向左移动六位。因此，f(x)的值是0.00000964，接近于零。通过这个猜测与检查的程序，并在不到一秒钟的时间内获得这个解，或者说是一个精确到实际解的百万分之一的近似值，依然让我感到惊讶和欣喜！你能感受到使用像Python和Processing这样的免费软件来探索数学问题的强大吗？
- en: 'If we increase the number of iterations from 20 to 40, we get a number even
    closer to 0:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将迭代次数从20次增加到40次，我们会得到一个更接近0的数字：
- en: -0.6666666666669698 9.196199357575097e-12
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: -0.6666666666669698 9.196199357575097e-12
- en: 'Let’s check f(-0.6666666666669698), or f(-2/3):'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查f(-0.6666666666669698)，即f(-2/3)：
- en: '>>> f(-2/3)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f(-2/3)'
- en: '0.0'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: This checks out, so the three solutions to 6*x*³ + 31*x*² + 3*x* − 10 = 0 are
    *x* = −5, −2/3, and 1/2.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的，所以6*x*³ + 31*x*² + 3*x* − 10 = 0的三个解是*x* = −5, −2/3和1/2。
- en: 'EXERCISE 4-3: FINDING MORE ROOTS'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4-3：寻找更多的根
- en: Use the graphing tool you just created to find the roots of 2x² + 7x – 15 =
    0\. Remember, the roots are where the graph crosses the x-axis, or where the function
    equals 0\. Check your answers using your quad() function.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你刚刚创建的图形工具来找出2x² + 7x − 15 = 0的根。记住，根是图形与x轴交叉的地方，或者说是函数等于0的地方。用你的quad()函数来检查答案。
- en: SUMMARY
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Math class used to be all about taking years to learn how to solve equations
    of higher and higher degree. In this chapter you learned that this isn’t so hard
    to do programmatically using our guess-and-check method. You also wrote programs
    that solve equations in other ways, like using the quadratic formula and graphing.
    In fact, you learned that all we have to do to solve an equation, no matter how
    complicated, is to graph it and approximate where it crosses the x-axis. By iterating
    and halving the range of values that work, we can get as accurate as we want.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 数学课曾经是关于学习如何解高次方程，花费了许多年。 在这一章，你学会了使用我们的猜测与检查方法，在程序中并不难做到这一点。你还编写了使用其他方法解方程的程序，比如使用二次方程公式和图形法。事实上，你已经学会了解方程的解决方法，不论它有多复杂，只需要绘制它的图形并估算它在哪里与x轴交叉。通过迭代并不断缩小有效值的范围，我们可以得到任何我们想要的精度。
- en: In programming, we use algebra to create variables to represent values that
    will change, like the size or coordinates of an object. The user can then change
    the value of a variable in one place, and the program will automatically change
    the value of that variable everywhere in the program. The user can also change
    these variables using a loop or declare the value in a function call. In future
    chapters we’ll model real-life situations where we need to use variables to represent
    parameters and constraints on the model, like energy content and force of gravity.
    Using variables lets us change values easily, to vary different aspects of the
    model.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们使用代数来创建变量，表示会变化的值，例如对象的大小或坐标。用户可以在一个地方修改变量的值，程序会自动在整个程序中更新该变量的值。用户还可以通过循环改变这些变量，或者在函数调用中声明变量的值。在后续章节中，我们将模拟现实生活中的情境，在这些情境中，我们需要使用变量来表示模型中的参数和约束条件，例如能量含量和重力。使用变量使我们能够轻松地改变值，从而改变模型的不同方面。
- en: In the next chapter you’ll use Processing to create interactive graphics, like
    rotating triangles and colorful grids!
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将使用Processing来创建交互式图形，比如旋转的三角形和多彩的网格！
