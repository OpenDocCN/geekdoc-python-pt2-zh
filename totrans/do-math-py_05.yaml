- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**Playing with Sets and Probability**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩转集合与概率**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this chapter, we’ll start by learning how we can make our programs understand
    and manipulate sets of numbers. We’ll then see how sets can help us understand
    basic concepts in probability. Finally, we’ll learn about generating random numbers
    to simulate random events. Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先学习如何让我们的程序理解和操作数字集合。接着，我们将看到集合如何帮助我们理解概率的基本概念。最后，我们将学习如何生成随机数来模拟随机事件。让我们开始吧！
- en: '**What’s a Set?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是集合？**'
- en: A *set* is a collection of distinct objects, often called *elements* or *members*.
    Two characteristics of a set make it different from just any collection of objects.
    A set is “well defined,” meaning the question “Is a particular object in this
    collection?” always has a clear yes or no answer, usually based on a rule or some
    given criteria. The second characteristic is that no two members of a set are
    the same. A set can contain anything—numbers, people, things, words, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *集合* 是一组不同的对象，通常称为 *元素* 或 *成员*。集合的两个特点使它与任何其他对象集合不同。集合是“定义明确的”，意味着问题“某个特定的对象在这个集合中吗？”总是有一个明确的是或否的答案，通常基于规则或某些给定的标准。第二个特点是集合中的成员不能重复。集合可以包含任何东西——数字、人物、物品、词语等等。
- en: Let’s walk through some basic properties of sets as we learn how to work with
    sets in Python using SymPy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些基本的集合属性来学习如何使用 SymPy 在 Python 中操作集合。
- en: '***Set Construction***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合构建***'
- en: 'In mathematical notation, you represent a set by writing the set members enclosed
    in curly brackets. For example, {2, 4, 6} represents a set with 2, 4, and 6 as
    its members. To create a set in Python, we can use the FiniteSet class from the
    sympy package, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学表示法中，你通过将集合成员用花括号括起来来表示一个集合。例如，{2, 4, 6} 表示一个集合，包含 2、4 和 6 作为其成员。要在 Python
    中创建一个集合，我们可以使用 sympy 包中的 FiniteSet 类，如下所示：
- en: '>>> from sympy import FiniteSet'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(2, 4, 6)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(2, 4, 6)'
- en: '>>> s'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{2, 4, 6}'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '{2, 4, 6}'
- en: Here, we first import the FiniteSet class from SymPy and then create an object
    of this class by passing in the set members as arguments. We assign the label
    s to the set we just created.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先从 SymPy 导入 FiniteSet 类，然后通过传入集合成员作为参数来创建该类的对象。我们将刚创建的集合赋值给标签 s。
- en: 'We can store different types of numbers—including integers, floating point
    numbers, and fractions—in the same set:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将不同类型的数字——包括整数、浮点数和分数——存储在同一个集合中：
- en: '>>> from sympy import FiniteSet'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> from fractions import Fraction'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from fractions import Fraction'
- en: '>>> s = FiniteSet(1, 1.5, Fraction(1, 5))'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 1.5, Fraction(1, 5))'
- en: '>>> s'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{1/5, 1, 1.5}'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '{1/5, 1, 1.5}'
- en: 'The *cardinality* of a set is the number of members in the set, which you can
    find by using the len() function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合的基数*是集合中成员的数量，可以使用 len() 函数来找到：'
- en: '>>> s = FiniteSet(1, 1.5, 3)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 1.5, 3)'
- en: '>>> len(s)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(s)'
- en: '3'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '**Checking Whether a Number Is in a Set**'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查一个数字是否在集合中**'
- en: 'To check whether a number is a member of an existing set, use the in operator.
    This operator asks Python, “Is this number in this set?” It returns True if the
    number belongs to the set and False if it doesn’t. If, for example, we wanted
    to check whether 4 was in the previous set, we’d do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个数字是否是现有集合的成员，可以使用 in 操作符。这个操作符会问 Python：“这个数字在这个集合中吗？”如果数字属于集合，它会返回 True；如果不属于，则返回
    False。例如，如果我们想检查 4 是否在前面的集合中，我们可以这样做：
- en: '>>> 4 in s'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 in s'
- en: 'False'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: Because 4 is not present in the set, the operator returns False.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 4 不在集合中，所以操作符返回 False。
- en: '**Creating an Empty Set**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建空集合**'
- en: 'If you want to make an *empty set*, which is a set that doesn’t have any elements
    or members, create a FiniteSet object without passing any arguments. The result
    is an EmptySet object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个 *空集合*，即一个没有任何元素或成员的集合，可以创建一个不传递任何参数的 FiniteSet 对象。结果是一个 EmptySet 对象：
- en: '>>> s = FiniteSet()'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet()'
- en: '>>> s'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: EmptySet()
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: EmptySet()
- en: '**Creating Sets from Lists or Tuples**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从列表或元组创建集合**'
- en: 'You can also create a set by passing in a list or a tuple of set members as
    an argument to FiniteSet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将一个包含集合成员的列表或元组作为参数传递给 FiniteSet 来创建集合：
- en: '>>> members = [1, 2, 3]'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> members = [1, 2, 3]'
- en: '>>> s = FiniteSet(*members)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(*members)'
- en: '>>> s'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{1, 2, 3}'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3}'
- en: Here, instead of passing in the set members directly to FiniteSet, we first
    stored them in a list, which we called members. Then, we passed the list to FiniteSet
    using this special Python syntax, which basically translates to creating a FiniteSet
    object that passes the list members as separate arguments and not as a list. That
    is, this approach to creating a FiniteSet object is equivalent to FiniteSet(1,
    2, 3). We will make use of this syntax when the set members are computed at runtime.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里， instead of passing in the set members directly to FiniteSet，我们首先将它们存储在一个列表中，并将该列表命名为
    `members`。然后，我们将这个列表通过特殊的 Python 语法传递给 FiniteSet，这实际上是创建一个 FiniteSet 对象，将列表中的成员作为单独的参数传递，而不是作为一个列表。也就是说，这种创建
    FiniteSet 对象的方法等价于 FiniteSet(1, 2, 3)。当集合成员在运行时计算时，我们将使用这种语法。
- en: '**Set Repetition and Order**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**集合的重复和顺序**'
- en: 'Sets in Python (like mathematical sets) ignore any repeats of a member, and
    they don’t keep track of the order of set members. For example, if you create
    a set from a list that has multiple instances of a number, the number is added
    to the set only once, and the other instances are discarded:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的集合（像数学集合一样）忽略任何成员的重复，而且它们不会追踪集合成员的顺序。例如，如果你从一个包含多个相同数字的列表创建集合，那么数字只会添加一次，其余的重复实例会被丢弃：
- en: '>>> from sympy import FiniteSet'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> members = [1, 2, 3, 2]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> members = [1, 2, 3, 2]'
- en: '>>> FiniteSet(*members)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> FiniteSet(*members)'
- en: '{1, 2, 3}'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3}'
- en: Here, even though we passed in a list that had two instances of the number 2,
    the number 2 appears only once in the set created from that list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，即使我们传入了一个包含两次数字 2 的列表，数字 2 在由该列表创建的集合中只会出现一次。
- en: 'In Python lists and tuples, each element is stored in a particular order, but
    the same is not always true for sets. For example, we can print out each member
    of a set by iterating through it as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 列表和元组中，每个元素都按特定顺序存储，但集合并不总是如此。例如，我们可以通过如下方式遍历集合并打印出每个成员：
- en: '>>> from sympy import FiniteSet'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2, 3)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3)'
- en: '>>> for member in s:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for member in s:'
- en: print(member)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: print(member)
- en: '2'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: When you run this code, the elements could be printed in any possible order.
    This is because of how sets are stored by Python—it keeps track of what members
    are in the set, but it doesn’t keep track of any particular order for those members.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，元素可能会以任何可能的顺序打印出来。这是因为 Python 存储集合的方式——它跟踪集合中的成员，但不跟踪这些成员的任何特定顺序。
- en: 'Let’s see another example. Two sets are *equal* when they have the same elements.
    In Python, you can use the equality operator, ==, to check whether two sets are
    equal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个不同的例子。当两个集合拥有相同的元素时，它们是*相等*的。在 Python 中，你可以使用相等运算符 == 来检查两个集合是否相等：
- en: '>>> from sympy import FiniteSet'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(3, 4, 5)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(3, 4, 5)'
- en: '>>> t = FiniteSet(5, 4, 3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(5, 4, 3)'
- en: '>>> s == t'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s == t'
- en: 'True'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: Although the members of these two sets appear in different orders, the sets
    are still equal.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个集合的成员顺序不同，但它们仍然是相等的。
- en: '***Subsets, Supersets, and Power Sets***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***子集、超集和幂集***'
- en: 'A set, *s*, is a *subset* of another set, *t*, if all the members of *s* are
    also members of *t*. For example, the set {1} is a subset of the set {1, 2}. You
    can check whether a set is a subset of another set using the is_subset() method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合 *s* 是另一个集合 *t* 的*子集*，如果 *s* 的所有成员都是 *t* 的成员。例如，集合 {1} 是集合 {1, 2} 的子集。你可以使用
    is_subset() 方法来检查一个集合是否是另一个集合的子集：
- en: '>>> s = FiniteSet(1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1)'
- en: '>>> t = FiniteSet(1,2)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(1, 2)'
- en: '>>> s.is_subset(t)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.is_subset(t)'
- en: 'True'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> t.is_subset(s)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t.is_subset(s)'
- en: 'False'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Note that an empty set is a subset of every set. Also, any set is a subset
    of itself, as you can see in the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空集合是每个集合的子集。此外，任何集合都是其自身的子集，如下所示：
- en: '>>> s.is_subset(s)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.is_subset(s)'
- en: 'True'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> t.is_subset(t)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t.is_subset(t)'
- en: 'True'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'Similarly, a set, *t*, is said to be a *superset* of another set, *s*, if *t*
    contains all of the members contained in *s*. You can check whether one set is
    a superset of another using the is_superset() method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，集合 *t* 被称为另一个集合 *s* 的*超集*，如果 *t* 包含 *s* 中的所有成员。你可以使用 is_superset() 方法来检查一个集合是否是另一个集合的超集：
- en: '>>> s.is_superset(t)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.is_superset(t)'
- en: 'False'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> t.is_superset(s)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t.is_superset(s)'
- en: 'True'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'The *power set* of a set, *s*, is the set of all possible subsets of *s*. Any
    set, *s*, has precisely 2^(|*s*|) subsets, where |*s*| is the cardinality of the
    set. For example, the set {1, 2, 3} has a cardinality of 3, so it has 2³ or 8
    subsets: {} (the empty set), {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3}, and {1, 2,
    3}.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合 *s* 的*幂集合*是 *s* 的所有可能子集的集合。任何集合 *s* 都恰好有 2^(|*s*|) 个子集，其中 |*s*| 是集合的基数。例如，集合
    {1, 2, 3} 的基数是 3，因此它有 2³ 或 8 个子集：{}（空集合）、{1}、{2}、{3}、{1, 2}、{2, 3}、{1, 3} 和 {1,
    2, 3}。
- en: 'The set of all these subsets form the power set, and we can find the power
    set using the powerset() method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些子集构成了幂集合，我们可以使用 powerset() 方法找到幂集合：
- en: '>>> s = FiniteSet(1, 2, 3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3)'
- en: '>>> ps = s.powerset()'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ps = s.powerset()'
- en: '>>> ps'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ps'
- en: '{{1}, {1, 2}, {1, 3}, {1, 2, 3}, {2}, {2, 3}, {3}, EmptySet()}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1}, {1, 2}, {1, 3}, {1, 2, 3}, {2}, {2, 3}, {3}, EmptySet()}'
- en: 'As the power set is a set itself, you can find its cardinality using the len()
    function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于幂集合本身也是一个集合，你可以使用 len() 函数来找到它的基数：
- en: '>>> len(ps)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(ps)'
- en: '8'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: The cardinality of the power set is 2^(|*s*|), which is 2³ = 8.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 幂集合的基数是 2^(|*s*|)，即 2³ = 8。
- en: 'Based on our definition of a subset, any two sets with the exact same members
    would be subsets as well as supersets of each other. By contrast, a set, *s*,
    is a *proper subset* of *t* only if all the members of *s* are also in *t* and
    *t* has at least one member that is not in *s*. So if *s* = {1, 2, 3}, it’s only
    a proper subset of *t* if *t* contains 1, 2, and 3 plus at least one more member.
    This would also mean that *t* is a *proper superset* of *s*. You can use the is_proper_subset()
    method and the is_proper_superset() method to check for these relationships:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对子集的定义，任何两个具有完全相同成员的集合都是彼此的子集和超集。相比之下，集合 *s* 只有在 *s* 的所有成员都在 *t* 中且 *t*
    至少有一个不在 *s* 中的成员时，*s* 才是 *t* 的*真子集*。因此，如果 *s* = {1, 2, 3}，只有当 *t* 包含 1、2 和 3 外加至少一个其他成员时，*s*
    才是 *t* 的真子集。这也意味着 *t* 是 *s* 的*真超集*。你可以使用 is_proper_subset() 方法和 is_proper_superset()
    方法来检查这些关系：
- en: '>>> from sympy import FiniteSet'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2, 3)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3)'
- en: '>>> t = FiniteSet(1, 2, 3)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(1, 2, 3)'
- en: '>>> s.is_proper_subset(t)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.is_proper_subset(t)'
- en: 'False'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> t.is_proper_superset(s)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t.is_proper_superset(s)'
- en: 'False'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Now, if we re-create the set t to include another member, s will be considered
    a proper subset of t and t a proper superset of s:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新创建集合 t 并加入另一个成员，那么 s 将被认为是 t 的真子集，t 则是 s 的真超集：
- en: '>>> t = FiniteSet(1, 2, 3, 4)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(1, 2, 3, 4)'
- en: '>>> s.is_proper_subset(t)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.is_proper_subset(t)'
- en: 'True'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> t.is_proper_superset(s)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t.is_proper_superset(s)'
- en: 'True'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '**COMMON NUMBER SETS**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见的数字集合**'
- en: In the first chapter, we learned that there are different kinds of numbers—
    integers, floating point numbers, fractions, and complex numbers. All these numbers
    form different sets of numbers, which have special names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们学习了不同种类的数字——整数、浮动点数、分数和复数。这些数字形成了不同的数字集合，并且每个集合都有特殊的名称。
- en: All positive and negative whole numbers form the set of *integers*. All positive
    integers form the set of *natural numbers* (sometimes 0 is included in this set
    of numbers even though it’s not positive, but sometimes not). This means the set
    of natural numbers is a proper subset of the set of integers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正整数和负整数组成了 *整数* 集合。所有正整数组成了 *自然数* 集合（有时 0 会被包括在这个集合中，尽管它不是正数，但有时也不包括）。这意味着自然数集合是整数集合的真子集。
- en: The set of *rational numbers* includes any number that can be expressed as a
    fraction, which includes all integers, plus any number with a decimal ending that
    terminates or repeats (including numbers like 1/4 or 0.25, and 1/3 or 0.33333
    ...). By contrast, nonrepeating, nonterminating decimal numbers are known as *irrational
    numbers*. The square root of 2 and *π* are both examples of irrational numbers
    because they go on forever without repeating.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*有理数* 集合包括任何可以表示为分数的数字，这包括所有整数，以及任何小数部分终止或重复的数字（如 1/4 或 0.25，以及 1/3 或 0.33333
    ...）。相比之下，不重复且不终止的小数被称为 *无理数*。2 的平方根和 *π* 都是无理数的例子，因为它们无限延续且不重复。'
- en: If you put together all the rational and irrational numbers, you get the set
    of *real numbers*. But even larger than that is the set of *complex numbers*,
    which includes all real numbers and all numbers with an imaginary component.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把所有有理数和无理数放在一起，你得到的就是 *实数* 集合。而更大的集合是 *复数* 集合，它包括所有实数以及所有具有虚数部分的数。
- en: All of these sets of numbers are infinite sets because they have infinite members.
    In contrast, the sets we’ve discussed in this chapter have a finite number of
    members, which is why the SymPy class we’re using is called FiniteSet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数集都是无限集，因为它们有无限个成员。与此相对的是，本章讨论的集合都是有限集合，拥有有限的成员，这也是我们使用的SymPy类被称为FiniteSet的原因。
- en: '***Set Operations***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合操作***'
- en: Set operations such as union, intersection, and the Cartesian product allow
    you to combine sets in certain methodical ways. These set operations are extremely
    useful in real-world problem-solving situations when we have to consider multiple
    sets together. Later in this chapter, we’ll see how to use these operations to
    apply a formula to multiple sets of data and calculate the probabilities of random
    events.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作如并集、交集和笛卡尔积可以让你以某种有规律的方式合并集合。这些集合操作在实际问题解决中非常有用，特别是当我们需要考虑多个集合时。本章后面我们将看到如何使用这些操作对多个数据集合应用公式并计算随机事件的概率。
- en: '**Union and Intersection**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**并集与交集**'
- en: 'The *union* of two sets is a set that contains all of the *distinct* members
    of the two sets. In set theory, we use the symbol ∪ to refer to the union operation.
    For example, {1, 2} ∪ {2, 3} will result in a new set, {1, 2, 3}. In SymPy, the
    union of these two sets can be created using the union() method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*并集*是一个包含两个集合所有*不同*成员的集合。在集合论中，我们使用符号∪来表示并集操作。例如，{1, 2} ∪ {2, 3}将得到一个新的集合{1,
    2, 3}。在SymPy中，可以使用union()方法创建这两个集合的并集：
- en: '>>> from sympy import FiniteSet'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2, 3)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3)'
- en: '>>> t = FiniteSet(2, 4, 6)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(2, 4, 6)'
- en: '>>> s.union(t)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.union(t)'
- en: '{1, 2, 3, 4, 6}'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3, 4, 6}'
- en: We find the union of s and t by applying the union method to s and passing in
    t as an argument. The result is a third set with all the distinct members of the
    two sets. In other words, each member of this third set is a member of one or
    both of the first two sets.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过对s应用union方法并传入t作为参数，找到了s和t的并集。结果是第三个集合，包含了两个集合中所有不同的成员。换句话说，这个第三个集合中的每个成员要么是第一个集合的成员，要么是第二个集合的成员，或者是两个集合的成员。
- en: The *intersection* of two sets creates a new set from the elements common to
    both sets. For example, the intersection of the sets {1, 2} and {2, 3} will result
    in a new set with the only common element, {2}. Mathematically, this operation
    is written as {1, 2} ∩ {2, 3}.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*交集*是由两个集合中共有的元素组成的新集合。例如，集合{1, 2}和{2, 3}的交集将得到一个包含唯一共同元素{2}的新集合。数学上，这个操作写作{1,
    2} ∩ {2, 3}。
- en: 'In SymPy, use the intersect() method to find the intersection:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy中，可以使用intersect()方法来找到交集：
- en: '>>> s = FiniteSet(1, 2)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2)'
- en: '>>> t = FiniteSet(2, 3)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(2, 3)'
- en: '>>> s.intersect(t)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.intersect(t)'
- en: '{2}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '{2}'
- en: 'Whereas the union operation finds members that are in one set *or* another,
    the intersection operation finds elements that are present in both. Both of these
    operations can also be applied to more than two sets. For example, here’s how
    you’d find the union of three sets:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 而并集操作找到的是在一个集合*或*另一个集合中的成员，交集操作找到的是同时出现在两个集合中的元素。这两个操作也可以应用于多个集合。例如，下面是如何找到三个集合的并集：
- en: '>>> from sympy import FiniteSet'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2, 3)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3)'
- en: '>>> t = FiniteSet(2, 4, 6)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(2, 4, 6)'
- en: '>>> u = FiniteSet(3, 5, 7)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> u = FiniteSet(3, 5, 7)'
- en: '>>> s.union(t).union(u)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.union(t).union(u)'
- en: '{1, 2, 3, 4, 5, 6, 7}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3, 4, 5, 6, 7}'
- en: 'Similarly, here’s how you’d find the intersection of three sets:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，下面是如何找到三个集合的交集：
- en: '>>> s.intersect(t).intersect(u)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.intersect(t).intersect(u)'
- en: EmptySet()
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: EmptySet()
- en: The intersection of the sets s, t, and u turns out to be an empty set because
    there are no elements that all three sets share.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 集合s、t和u的交集是一个空集合，因为这三个集合没有任何共同的元素。
- en: '**Cartesian Product**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**笛卡尔积**'
- en: 'The *Cartesian product* of two sets creates a set that consists of all possible
    pairs made by taking an element from each set. For example, the Cartesian product
    of the sets {1, 2} and {3, 4} is {(1, 3), (1, 4), (2, 3), (2, 4)}. In SymPy, you
    can find the Cartesian product of two sets by simply using the multiplication
    operator:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*笛卡尔积*是一个由每个集合中的元素配对组成的集合。例如，集合{1, 2}和{3, 4}的笛卡尔积是{(1, 3), (1, 4), (2,
    3), (2, 4)}。在SymPy中，你可以通过使用乘法运算符来找到两个集合的笛卡尔积：
- en: '>>> from sympy import FiniteSet'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2)'
- en: '>>> t = FiniteSet(3, 4)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = FiniteSet(3, 4)'
- en: '>>> p = s*t'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = s * t'
- en: '>>> p'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p'
- en: '{1, 2} x {3, 4}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2} x {3, 4}'
- en: 'This takes the Cartesian product of the sets s and t and stores it as p. To
    actually see each pair in that Cartesian product, we can iterate through and print
    them out as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将集合 s 和 t 的笛卡尔积存储为 p。为了实际查看笛卡尔积中的每一对元素，我们可以通过迭代并打印它们，如下所示：
- en: '>>> for elem in p:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for elem in p:'
- en: print(elem)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: print(elem)
- en: (1, 3)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 3)
- en: (1, 4)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 4)
- en: (2, 3)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 3)
- en: (2, 4)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 4)
- en: Each element of the product is a tuple consisting of a member from the first
    set and a member from the second set.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个笛卡尔积的元素是一个元组，包含了第一个集合和第二个集合中的一个成员。
- en: 'The cardinality of the Cartesian product is the product of the cardinality
    of the individual sets. We can demonstrate this in Python:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积的基数是各个集合基数的乘积。我们可以通过 Python 来展示这一点：
- en: '>>> len(p) == len(s)*len(t)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(p) == len(s)*len(t)'
- en: 'True'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: If we apply the exponential operator (**) to a set, we get the Cartesian product
    of that set times itself the specified number of times.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个集合应用指数运算符（**），我们得到的是该集合与自身笛卡尔积的指定次数。
- en: '>>> from sympy import FiniteSet'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2)'
- en: '>>> p = s**3'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = s**3'
- en: '>>> p'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p'
- en: '{1, 2} x {1, 2} x {1, 2}'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2} x {1, 2} x {1, 2}'
- en: 'Here, for example, we raised the set s to the power of 3\. Because we’re taking
    the Cartesian product of three sets, this gives us a set of all possible triplets
    that contain a member of each set:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里我们将集合 s 的每个元素都提升到 3 次方。因为我们正在进行三个集合的笛卡尔积操作，这样我们就得到了一个包含每个集合成员的所有可能三元组的集合：
- en: '>>> for elem in p:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for elem in p:'
- en: print(elem)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: print(elem)
- en: (1, 1, 1)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 1, 1)
- en: (1, 1, 2)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 1, 2)
- en: (1, 2, 1)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 2, 1)
- en: (1, 2, 2)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 2, 2)
- en: (2, 1, 1)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 1, 1)
- en: (2, 1, 2)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 1, 2)
- en: (2, 2, 1)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 2, 1)
- en: (2, 2, 2)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 2, 2)
- en: Finding the Cartesian product of sets is useful for finding all possible combinations
    of the set members, which we’ll explore next.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找集合的笛卡尔积对找到集合成员的所有可能组合非常有用，我们将在接下来进行探讨。
- en: '**Applying a Formula to Multiple Sets of Variables**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**对多个变量集合应用公式**'
- en: Consider a simple pendulum of length *L*. The *time period*, *T*, of this pendulum—that
    is, the amount of time it takes for the pendulum to complete one full swing—is
    given by the formula
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个长度为 *L* 的简单摆。这个摆的*周期*，*T*，也就是摆完成一次完整摆动所需的时间，可以用以下公式表示：
- en: '![image](images/e0129-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0129-01.jpg)'
- en: Here, *π* is the mathematical constant, *pi*, and *g* is the local gravitational
    acceleration, which is around 9.8 m/s² on Earth. Because *π* and *g* are constants,
    the length, *L*, is the only variable on the right side of the equation that doesn’t
    have a constant value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*π* 是数学常数 *pi*，*g* 是局部重力加速度，地球上的值大约为 9.8 m/s²。由于 *π* 和 *g* 是常数，长度 *L* 是方程右侧唯一没有常数值的变量。
- en: 'If you wanted to see how the time period of a simple pendulum varies with its
    length, you’d assume different values for the length and measure the corresponding
    time period at each of these values using the formula. A typical high school experiment
    is to compare the time period you get using the preceding formula, which is the
    theoretical result, to the one you measure in the laboratory, which is the experimental
    result. For example, let’s choose five different values: 15, 18, 21, 22.5, and
    25 (all expressed in centimeters). With Python, we can write a quick program that’ll
    speed through the calculations for the theoretical results:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想观察简单摆的周期如何随长度变化，你可以假设不同的长度值，并使用公式测量这些值对应的时间周期。一个典型的高中实验是将你使用上述公式得到的理论结果与在实验室测得的实验结果进行比较。例如，我们选择五个不同的值：15、18、21、22.5
    和 25（单位为厘米）。使用 Python，我们可以编写一个快速的程序来进行理论结果的计算：
- en: from sympy import FiniteSet, pi
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import FiniteSet, pi
- en: '➊ def time_period(length):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def time_period(length):'
- en: g = 9.8
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: g = 9.8
- en: T = 2*pi*(length/g)**0.5
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: T = 2*pi*(length/g)**0.5
- en: return T
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: return T
- en: 'if __name__ == ''__main__'':'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: ➋     L = FiniteSet(15, 18, 21, 22.5, 25)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     L = FiniteSet(15, 18, 21, 22.5, 25)
- en: 'for l in L:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'for l in L:'
- en: ➌         t = time_period(l/100)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ➌         t = time_period(l/100)
- en: print('Length: {0} cm Time Period: {1:.3f} s'. format(float(l), float(t)))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: print('长度: {0} cm 周期: {1:.3f} s'. format(float(l), float(t)))
- en: 'We first define the function time_period at ➊. This function applies the formula
    shown earlier to a given length, which is passed in as length. Then, our program
    defines a set of lengths at ➋ and applies the time_period function to each value
    at ➌. Notice that when we pass in the length values to time_period, we divide
    them by 100\. This operation converts the lengths from centimeters to meters so
    that they match the unit of gravitational acceleration, which is expressed in
    units of meters/second². Finally, we print the calculated time period. When you
    run the program, you’ll see the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 ➊ 定义了时间周期函数 time_period。该函数使用之前提到的公式来处理给定的长度，该长度作为参数传入。然后，程序在 ➋ 定义了一组长度，并在
    ➌ 对每个值应用 time_period 函数。注意，在将长度值传递给 time_period 时，我们将其除以 100。这一操作将长度从厘米转换为米，以匹配重力加速度的单位，后者的单位是米/秒²。最后，我们打印出计算出的时间周期。当你运行程序时，你将看到以下输出：
- en: Length: 15.0 cm Time Period: 0.777 s
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 长度：15.0 厘米 周期：0.777 秒
- en: Length: 18.0 cm Time Period: 0.852 s
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 长度：18.0 厘米 周期：0.852 秒
- en: Length: 21.0 cm Time Period: 0.920 s
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 长度：21.0 厘米 周期：0.920 秒
- en: Length: 22.5 cm Time Period: 0.952 s
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 长度：22.5 厘米 周期：0.952 秒
- en: Length: 25.0 cm Time Period: 1.004 s
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 长度：25.0 厘米 周期：1.004 秒
- en: '**Different Gravity, Different Results**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**不同的重力，不同的结果**'
- en: 'Now, imagine we conducted this experiment in three different places— my current
    location, Brisbane, Australia; the North Pole; and the equator. The force of gravity
    varies slightly depending on the latitude of your location: it’s a bit lower (approximately
    9.78 m/s²) at the equator and higher (9.83 m/s²) at the North Pole. This means
    we can treat the force of gravity as a variable in our formula, rather than a
    constant, and calculate results for three different values of gravitational acceleration:
    {9.8, 9.78, 9.83}.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们在三个不同的地方进行此实验——我目前所在的地点，澳大利亚布里斯班；北极；以及赤道。重力的大小会略有不同，具体取决于你所在的纬度：在赤道，重力略低（大约
    9.78 m/s²），而在北极则较高（9.83 m/s²）。这意味着我们可以将重力作为公式中的一个变量，而不是常量，并计算出三种不同重力加速度值的结果：{9.8,
    9.78, 9.83}。
- en: 'If we want to calculate the period of a pendulum for each of our five lengths
    at each of these three locations, a systematic way to work out all of these combinations
    of the values is to take the Cartesian product, as shown in the following program:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为每个长度在这三个位置计算钟摆的周期，一个系统的方法是计算所有这些值的笛卡尔积，如下面的程序所示：
- en: from sympy import FiniteSet, pi
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import FiniteSet, pi
- en: 'def time_period(length, g):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'def time_period(length, g):'
- en: T = 2*pi*(length/g)**0.5
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: T = 2*pi*(length/g)**0.5
- en: return T
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 T
- en: 'if __name__ == ''__main__'':'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: L = FiniteSet(15, 18, 21, 22.5, 25)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: L = FiniteSet(15, 18, 21, 22.5, 25)
- en: g_values = FiniteSet(9.8, 9.78, 9.83)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: g_values = FiniteSet(9.8, 9.78, 9.83)
- en: ➊     print('{0:^15}{1:^15}{2:^15}'.format('Length(cm)', 'Gravity(m/s^2)', 'Time Period(s)'))
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     print('{0:^15}{1:^15}{2:^15}'.format('长度(cm)', '重力(m/s^2)', '周期(s)'))
- en: '➋     for elem in L*g_values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '➋     for elem in L*g_values:'
- en: ➌         l = elem[0]
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➌         l = elem[0]
- en: ➍         g = elem[1]
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ➍         g = elem[1]
- en: t = time_period(l/100, g)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: t = time_period(l/100, g)
- en: ➎         print('{0:^15}{1:^15}{2:^15.3f}'.format(float(l), float(g), float(t)))
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ➎         print('{0:^15}{1:^15}{2:^15.3f}'.format(float(l), float(g), float(t)))
- en: At ➋, we take the Cartesian product of our two sets of variables, L and g_values,
    and we iterate through each resulting combination of values to calculate the time
    period. Each combination is represented as a tuple, and for each tuple, we extract
    the first value, the length, at ➌ and the second value, the gravity, at ➍. Then,
    just as before, we call the time_period() function with these two labels as parameters,
    and we print the values of length (l), gravity (g), and the corresponding time
    period (T).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋，我们计算了两个变量集 L 和 g_values 的笛卡尔积，并通过每一个结果组合来计算时间周期。每个组合表示为一个元组，对于每个元组，我们提取第一个值——长度（l）在
    ➌，第二个值——重力（g）在 ➍。然后，像之前一样，我们使用这两个值调用 time_period() 函数，并打印出长度（l）、重力（g）和相应的时间周期（T）。
- en: The output is presented in a table to make it easy to follow. The table is formatted
    by the print statements at ➊ and ➎. The format string {0:^15} {1:^15}{2:^15.3f}
    creates three fields, each 15 spaces wide, and the ^ symbol centers each entry
    in each field. In the last field of the print statement at ➎, '.3f' limits the
    number of digits after the decimal point to three.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以表格的形式呈现，方便查看。表格是通过 ➊ 和 ➎ 的 print 语句格式化的。格式字符串 {0:^15} {1:^15}{2:^15.3f} 创建了三个宽度为
    15 个空格的字段，^ 符号将每个条目居中对齐。在 ➎ 的最后一个字段中，'.3f' 限制了小数点后的数字为三位。
- en: 'When you run the program, you’ll see the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到以下输出：
- en: Length(cm)   Gravity(m/s^2)   Time Period(s)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 长度（cm）   重力（m/s^2）   周期（s）
- en: 15.0           9.78             0.778
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 15.0           9.78             0.778
- en: 15.0            9.8             0.777
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 15.0            9.8             0.777
- en: 15.0           9.83             0.776
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 15.0           9.83             0.776
- en: 18.0           9.78             0.852
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 18.0           9.78             0.852
- en: 18.0            9.8             0.852
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 18.0            9.8             0.852
- en: 18.0           9.83             0.850
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 18.0           9.83             0.850
- en: 21.0           9.78             0.921
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 21.0           9.78             0.921
- en: 21.0            9.8             0.920
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 21.0            9.8             0.920
- en: 21.0           9.83             0.918
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 21.0           9.83             0.918
- en: 22.5           9.78             0.953
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 22.5           9.78             0.953
- en: 22.5            9.8             0.952
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 22.5            9.8             0.952
- en: 22.5           9.83             0.951
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 22.5           9.83             0.951
- en: 25.0           9.78             1.005
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 25.0           9.78             1.005
- en: 25.0            9.8             1.004
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 25.0            9.8             1.004
- en: 25.0           9.83             1.002
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 25.0           9.83             1.002
- en: This experiment presents a simple scenario where you need all possible combinations
    of the elements of multiple sets (or a group of numbers). In this type of situation,
    the Cartesian product is exactly what you need.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验展示了一个简单的场景，你需要计算多个集合（或一组数字）元素的所有可能组合。在这种情况下，笛卡尔积正是你所需要的。
- en: '**Probability**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率**'
- en: 'Sets allow us to reason about the basic concepts of probability. We’ll begin
    with a few definitions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 集合让我们能够推理概率的基本概念。我们将从一些定义开始：
- en: '**Experiment** The *experiment* is simply the test we want to perform. We perform
    the test because we’re interested in the probability of each possible outcome.
    Rolling a die, flipping a coin, and pulling a card from a deck of cards are all
    examples of experiments. A single run of an experiment is referred to as a *trial*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验** *实验* 只是我们想要进行的测试。我们进行测试是因为我们对每种可能结果的概率感兴趣。掷骰子、抛硬币和从一副扑克牌中抽取一张牌都是实验的例子。一次实验的单次运行称为*试验*。'
- en: '**Sample space** All possible outcomes of an experiment form a set known as
    the *sample space*, which we’ll usually call *S* in our formulas. For example,
    when a six-sided die is rolled once, the sample space is {1, 2, 3, 4, 5, 6}.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**样本空间** 实验的所有可能结果形成一个称为*样本空间*的集合，通常我们在公式中称它为*S*。例如，当掷一个六面骰子时，样本空间为{1, 2, 3,
    4, 5, 6}。'
- en: '**Event** An *event* is a set of outcomes that we want to calculate the probability
    of and that form a *subset* of the sample space. For example, we might want to
    know the probability of a particular outcome, like rolling a 3, or the probability
    of a set of multiple outcomes, such as rolling an even number (either 2, 4, or
    6). We’ll use the letter *E* in our formulas to stand for an event.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件** *事件* 是我们希望计算其概率的一组结果，它构成样本空间的*子集*。例如，我们可能想知道某个特定结果的概率，比如掷出3，或者一组多个结果的概率，比如掷出一个偶数（2、4或6）。在公式中，我们将使用字母
    *E* 来代表一个事件。'
- en: 'If there’s a *uniform distribution*—that is, if each outcome in the sample
    space is equally likely to occur—then the probability of an event, *P*(*E*), occurring
    is calculated using the following formula (I’ll talk about nonuniform distributions
    a bit later in this chapter):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在*均匀分布*——也就是说，样本空间中的每个结果发生的概率相等——那么事件*P*(*E*)发生的概率可以使用以下公式计算（稍后我会谈到非均匀分布）：
- en: '![image](images/e0131-01.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0131-01.jpg)'
- en: Here, *n*(*E*) and *n*(*S*) are the cardinality of the sets *E*, the event,
    and *S*, the sample space, respectively. The value of *P*(*E*) ranges from 0 to
    1, with higher values indicating a higher chance of the event happening.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*n*(*E*) 和 *n*(*S*) 分别是*E*（事件）和*S*（样本空间）这两个集合的基数。*P*(*E*)的值范围是从0到1，值越高表示事件发生的可能性越大。
- en: 'We can apply this formula to a die roll to calculate the probability of a particular
    roll—say, 3:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个公式应用于掷骰子来计算某个特定掷骰子的概率——比如掷出3：
- en: '![image](images/e0132-01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0132-01.jpg)'
- en: 'This confirms what was obvious all along: the probability of a particular die
    roll is 1/6\. You could easily do this calculation in your head, but we can use
    this formula to write the following function in Python that calculates the probability
    of any event, event, in any sample space, space:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了一个显而易见的事实：某次特定掷骰子的概率是1/6。你可以很容易地用脑算出这个结果，但我们可以使用这个公式编写以下Python函数来计算任何事件的概率，事件发生在任何样本空间中：
- en: 'def probability(space, event):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'def probability(space, event):'
- en: return len(event)/len(space)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: return len(event)/len(space)
- en: In this function, the two arguments space and event—the sample space and event—need
    not be sets created using FiniteSet. They can also be lists or, for that matter,
    any other Python object that supports the len() function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，两个参数space和event——样本空间和事件——不必是通过FiniteSet创建的集合。它们也可以是列表，或者任何其他支持len()函数的Python对象。
- en: 'Using this function, let’s write a program to find the probability of a prime
    number appearing when a 20-sided die is rolled:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，让我们编写一个程序来找出掷20面骰子时出现素数的概率：
- en: 'def probability(space, event):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 概率(space, event):'
- en: return len(event)/len(space)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: return len(event)/len(space)
- en: '➊   def check_prime(number):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '➊   def check_prime(number):'
- en: 'if number != 1:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'if number != 1:'
- en: 'for factor in range(2, number):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'for factor in range(2, number):'
- en: 'if number % factor == 0:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'if number % factor == 0:'
- en: return False
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'else:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return False
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'if __name__ == ''__main__'':'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: ➋       space = FiniteSet(*range(1, 21))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ➋       space = 有限集合(*range(1, 21))
- en: primes = []
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: primes = []
- en: 'for num in s:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'for num in s:'
- en: '➌           if check_prime(num):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '➌           if check_prime(num):'
- en: primes.append(num)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: primes.append(num)
- en: ➍           event= FiniteSet(*primes)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ➍           event= 有限集合(*primes)
- en: p = probability(space, event)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: p = 概率(space, event)
- en: print('Sample space: {0}'.format(space))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: print('样本空间：{0}'.format(space))
- en: print('Event: {0}'.format(event))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: print('事件：{0}'.format(event))
- en: print('Probability of rolling a prime: {0:.5f}'.format(p))
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: print('掷骰子得到素数的概率：{0:.5f}'.format(p))
- en: We first create a set representing the sample space, space, using the range()
    function at ➋. To create the event set, we need to find the prime numbers from
    the sample space, so we define a function, check_prime(), at ➊. This function
    takes an integer and checks to see whether it’s divisible (with no remainder)
    by any number between 2 and itself. If so, it returns False. Because a prime number
    is only divisible by 1 and itself, this function returns True if an integer is
    prime and False otherwise.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用range()函数在➋处创建了表示样本空间space的集合。为了创建事件集，我们需要从样本空间中找出素数，因此在➊处定义了一个函数check_prime()。该函数接受一个整数并检查它是否能被2到该整数自身之间的任何数字整除（且没有余数）。如果能，返回False。由于素数只能被1和它自身整除，如果一个整数是素数，这个函数返回True，否则返回False。
- en: 'We call this function for each of the numbers in the sample space at ➌ and
    add the prime numbers to a list, primes. Then, we create our event set, event,
    from this list at ➍. Finally, we call the probability() function we created earlier.
    We get the following output when we run the program:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➌处为样本空间中的每个数字调用此函数，并将素数添加到列表primes中。然后，我们从这个列表中创建事件集event，位置在➍。最后，我们调用之前创建的概率()函数。运行程序时，我们得到以下输出：
- en: Sample space: {1, 2, 3, ..., 18, 19, 20}
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 样本空间：{1, 2, 3, ..., 18, 19, 20}
- en: Event: {2, 3, 5, 7, 11, 13, 17, 19}
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 事件：{2, 3, 5, 7, 11, 13, 17, 19}
- en: Probability of rolling a prime: 0.40000
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 掷骰子得到素数的概率：0.40000
- en: Here, *n*(*E*) = 8 and *n*(*S*) = 20, so the probability, *P*, is 0.4.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*n*(*E*) = 8 和 *n*(*S*) = 20，所以概率 *P* 是 0.4。
- en: 'In our 20-sided die program, we really didn’t need to create the sets; instead,
    we could have called the probability() function with the sample space and events
    as lists:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的20面骰子程序中，实际上我们不需要创建这些集合；相反，我们可以将样本空间和事件作为列表传入概率()函数：
- en: 'if __name__ == ''__main__'':'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: space = range(1, 21)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: space = range(1, 21)
- en: primes = []
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: primes = []
- en: 'for num in space:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'for num in space:'
- en: 'if check_prime(num):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'if check_prime(num):'
- en: primes.append(num)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: primes.append(num)
- en: p = probability(space, primes)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: p = 概率(space, primes)
- en: The probability() function works equally well in this case.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 概率()函数在这种情况下同样适用。
- en: '***Probability of Event A or Event B***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事件A或事件B的概率***'
- en: 'Let’s say we’re interested in two possible events, and we want to find the
    probability of *either* one of them happening. For example, going back to a simple
    die roll, let’s consider the following two events:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对两个可能发生的事件感兴趣，并且我们想要找到*其中*一个事件发生的概率。例如，回到简单的掷骰子，我们考虑以下两个事件：
- en: A = The number is a prime number.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: A = 这个数字是素数。
- en: B = The number is odd.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: B = 这个数字是奇数。
- en: 'As it was earlier, the sample space, *S*, is {1, 2, 3, 4, 5, 6}. Event A can
    be represented as the subset {2, 3, 5}, the set of prime numbers in the sample
    space, and event B can be represented as {1, 3, 5}, the odd numbers in the sample
    space. To calculate the probability of either set of outcomes, we can find the
    probability of the *union* of the two sets. In our notation, we could say:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前一样，样本空间 *S* 是 {1, 2, 3, 4, 5, 6}。事件A可以表示为子集{2, 3, 5}，即样本空间中的素数集合，事件B可以表示为{1,
    3, 5}，即样本空间中的奇数集合。为了计算这两个结果集合的概率，我们可以求得这两个集合的*并集*的概率。在我们的符号中，我们可以说：
- en: '![image](images/e0133-01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0133-01.jpg)'
- en: 'Now let’s perform this calculation in Python:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Python中进行这个计算：
- en: '>>> from sympy import FiniteSet'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2, 3, 4, 5, 6)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3, 4, 5, 6)'
- en: '>>> a = FiniteSet(2, 3, 5)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = FiniteSet(2, 3, 5)'
- en: '>>> b = FiniteSet(1, 3, 5)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = FiniteSet(1, 3, 5)'
- en: ➊ >>> e = a.union(b)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> e = a.union(b)
- en: '>>> len(e)/len(s)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(e)/len(s)'
- en: '0.6666666666666666'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '0.6666666666666666'
- en: We first create a set, s, representing the sample space, followed by the two
    sets a and b. Then, at ➊, we use the union() method to find the event set, e.
    Finally, we calculate the probability of the union of the two sets using the earlier
    formula.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个集合 s，表示样本空间，然后是两个集合 a 和 b。接着，在 ➊ 处，我们使用 union() 方法来找到事件集 e。最后，我们使用之前的公式来计算两个集合的并集的概率。
- en: '***Probability of Event A and Event B***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事件A和事件B的概率***'
- en: 'Say you have two events in mind and you want to calculate the chances of *both*
    of them happening—for example, the chances that a die roll is both prime and odd.
    To determine this, you calculate the probability of the intersection of the two
    event sets:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个事件，并且你想计算它们*都*发生的概率——例如，掷骰子时同时是质数和奇数的概率。为了计算这个，你需要计算这两个事件集合的交集概率：
- en: '*E* = *A* ∩ *B* = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = *A* ∩ *B* = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}'
- en: 'We can calculate the probability of both A and B happening by using the intersect()
    method, which is similar to what we did in the previous case:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 intersect() 方法来计算事件 A 和事件 B 同时发生的概率，这与我们在前一个例子中的做法类似：
- en: '>>> from sympy import FiniteSet'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import FiniteSet'
- en: '>>> s = FiniteSet(1, 2, 3, 4, 5, 6)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = FiniteSet(1, 2, 3, 4, 5, 6)'
- en: '>>> a = FiniteSet(2, 3, 5)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = FiniteSet(2, 3, 5)'
- en: '>>> b = FiniteSet(1, 3, 5)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = FiniteSet(1, 3, 5)'
- en: '>>> e = a.intersect(b)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> e = a.intersect(b)'
- en: '>>> len(e)/len(s)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(e)/len(s)'
- en: '0.3333333333333333'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '0.3333333333333333'
- en: '***Generating Random Numbers***'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成随机数***'
- en: Probability concepts allow us to reason about and calculate the chance of an
    event happening. To actually simulate such events—like a simple dice game—using
    computer programs, we need a way to generate random numbers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 概率概念让我们能够推理并计算事件发生的机会。为了实际模拟这样的事件——比如一个简单的掷骰子游戏——我们需要一种生成随机数的方法。
- en: '**Simulating a Die Roll**'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**模拟掷骰子**'
- en: 'To simulate a six-sided die roll, we need a way to generate a random integer
    between 1 and 6\. The random module in Python’s standard library provides us with
    various functions to generate random numbers. Two functions that we’ll use in
    this chapter are the randint() function, which generates a random integer in a
    given range, and the random() function, which generates a floating point number
    between 0 and 1\. Let’s see a quick example of how the randint() function works:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟一个六面骰子的掷骰过程，我们需要一种方法来生成介于1到6之间的随机整数。Python 标准库中的 random 模块提供了多种生成随机数的函数。本章我们将使用两个函数：randint()
    函数，它在指定范围内生成一个随机整数，和 random() 函数，它生成一个介于0和1之间的浮动数字。我们来看一下 randint() 函数的一个简单示例：
- en: '>>> import random'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import random'
- en: '>>> random.randint(1, 6)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.randint(1, 6)'
- en: '4'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'The randint() function takes two integers as arguments and returns a random
    integer that falls between these two numbers (both inclusive). In this example,
    we passed in the range (1, 6), and it returned the number 4, but if we call it
    again, we’ll very likely get a different number:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: randint() 函数接受两个整数作为参数，并返回一个介于这两个数字之间的随机整数（包括这两个数字）。在这个例子中，我们传入了范围(1, 6)，它返回了数字4，但是如果我们再次调用它，我们很可能会得到一个不同的数字：
- en: '>>> random.randint(1, 6)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.randint(1, 6)'
- en: '6'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: Calling the randint() function allows us to simulate the roll of our virtual
    die. Every time we call this function, we’re going to get a number between 1 and
    6, just as we would if we were rolling a six-sided die. Note that randint() expects
    you to supply the lower number first, so randint(6, 1) isn’t valid.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 randint() 函数允许我们模拟掷骰子的过程。每次调用这个函数时，我们都会得到一个介于1到6之间的数字，就像我们掷六面骰子时一样。注意，randint()
    期望你先提供较小的数字，所以 randint(6, 1) 是无效的。
- en: '**Can You Roll That Score?**'
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**你能掷出这个分数吗？**'
- en: 'Our next program will simulate a simple die-rolling game, where we keep rolling
    the six-sided die until we’ve rolled a total of 20:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序将模拟一个简单的掷骰子游戏，我们会不断掷六面骰子，直到总分达到20：
- en: ''''''''
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Roll a die until the total score is 20
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 继续掷骰子直到总分达到20
- en: ''''''''
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import matplotlib.pyplot as plt
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import random
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: target_score = 20
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: target_score = 20
- en: 'def roll():'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roll():'
- en: return random.randint(1, 6)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: return random.randint(1, 6)
- en: 'if __name__ == ''__main__'':'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: score = 0
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: score = 0
- en: num_rolls = 0
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: num_rolls = 0
- en: '➊     while score < target_score:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     while score < target_score:'
- en: die_roll = roll()
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: die_roll = roll()
- en: num_rolls += 1
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: num_rolls += 1
- en: print('Rolled: {0}'.format(die_roll))
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: print('投掷结果：{0}'.format(die_roll))
- en: score += die_roll
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: score += die_roll
- en: print('Score of {0} reached in {1} rolls'.format(score, num_rolls))
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: print('在 {1} 次投掷中达到 {0} 分'.format(score, num_rolls))
- en: First, we define the same roll() function we created earlier. Then, we use a
    while loop at ➊ to call this function, keep track of the number of rolls, print
    the current roll, and add up the total score. The loop repeats until the score
    reaches 20, and then the program prints the total score and number of rolls.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义与之前创建的相同的 roll() 函数。然后，在 ➊ 处使用 while 循环调用该函数，跟踪投掷次数，打印当前投掷结果，并累计总分。该循环将重复执行，直到分数达到
    20，然后程序打印总分和投掷次数。
- en: 'Here’s a sample run:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例运行：
- en: Rolled: 6
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷结果：6
- en: Rolled: 2
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷结果：2
- en: Rolled: 5
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷结果：5
- en: Rolled: 1
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷结果：1
- en: Rolled: 3
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷结果：3
- en: Rolled: 4
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷结果：4
- en: Score of 21 reached in 6 rolls
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 6 次投掷中达到 21 分
- en: If you run the program several times, you’ll notice that the number of rolls
    it takes to reach 20 varies.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行程序，你会发现达到 20 分所需的投掷次数是不同的。
- en: '**Is the Target Score Possible?**'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**目标分数是否可达？**'
- en: 'Our next program is similar, but it’ll tell us whether a certain target score
    is reachable within a maximum number of rolls:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序类似，但它将告诉我们在最大投掷次数内是否能达到某个目标分数：
- en: from sympy import FiniteSet
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import FiniteSet
- en: import random
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: 'def find_prob(target_score, max_rolls):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_prob(target_score, max_rolls):'
- en: die_sides = FiniteSet(1, 2, 3, 4, 5, 6)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: die_sides = FiniteSet(1, 2, 3, 4, 5, 6)
- en: '# Sample space'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '# 样本空间'
- en: ➊     s = die_sides**max_rolls
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ s = die_sides**max_rolls
- en: '# Find the event set'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找事件集合'
- en: 'if max_rolls > 1:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 max_rolls > 1:'
- en: success_rolls = []
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: success_rolls = []
- en: '➋         for elem in s:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for elem in s:'
- en: 'if sum(elem) >= target_score:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 sum(elem) >= target_score:'
- en: success_rolls.append(elem)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: success_rolls.append(elem)
- en: 'else:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'if target_score > 6:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 target_score > 6:'
- en: ➌             success_rolls = []
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ success_rolls = []
- en: 'else:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: success_rolls = []
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: success_rolls = []
- en: 'for roll in die_sides:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'for roll in die_sides:'
- en: '➍                 if roll >= target_score:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ 如果 roll >= target_score:'
- en: success_rolls.append(roll)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: success_rolls.append(roll)
- en: ➎     e = FiniteSet(*success_rolls)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ e = FiniteSet(*success_rolls)
- en: '# Calculate the probability of reaching target score'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算达到目标分数的概率'
- en: return len(e)/len(s)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: return len(e)/len(s)
- en: 'if __name__ == ''__main__'':'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: target_score = int(input('Enter the target score: '))
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: target_score = int(input('请输入目标分数：'))
- en: max_rolls = int(input('Enter the maximum number of rolls allowed: '))
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: max_rolls = int(input('请输入允许的最大投掷次数：'))
- en: p = find_prob(target_score, max_rolls)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: p = find_prob(target_score, max_rolls)
- en: print('Probability: {0:.5f}'.format(p))
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: print('概率：{0:.5f}'.format(p))
- en: When you run this program, it asks for the target score and the maximum number
    of allowed rolls as input, and then it prints out the probability of achieving
    that.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此程序时，它会要求输入目标分数和允许的最大投掷次数，然后它会输出达到该目标的概率。
- en: 'Here are two sample executions:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两次示例执行：
- en: Enter the target score: 25
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 输入目标分数：25
- en: Enter the maximum number of rolls allowed: 4
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 输入允许的最大投掷次数：4
- en: Probability: 0.00000
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 概率：0.00000
- en: Enter the target score: 25
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 输入目标分数：25
- en: Enter the maximum number of rolls allowed: 5
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 输入允许的最大投掷次数：5
- en: Probability: 0.03241
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 概率：0.03241
- en: Let’s understand the workings of the find_prob() function, which performs the
    probability calculation. The sample space here is the Cartesian product, die_sides^(max_rolls)
    ➊, where die_sides is the set {1, 2, 3, 4, 5, 6}, representing the numbers on
    a six-sided die, and max_rolls is the maximum number of die rolls allowed.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解 find_prob() 函数的工作原理，它执行概率计算。这里的样本空间是笛卡尔积，die_sides^(max_rolls) ➊，其中 die_sides
    是集合 {1, 2, 3, 4, 5, 6}，表示六面骰上的数字，max_rolls 是允许的最大投掷次数。
- en: 'The event set is all the sets in the sample space that help us reach this target
    score. There are two cases here: when the number of turns left is greater than
    1 and when we’re in the last turn. For the first case, at ➋, we iterate over each
    of the tuples in the Cartesian product and add the ones that add up to or exceed
    target_score in the success_rolls list. The second case is special: our sample
    space is just the set {1, 2, 3, 4, 5, 6}, and we have only one throw of the die
    left. If the value of the target score is greater than 6, it isn’t possible to
    achieve it, and we set success_rolls to be an empty list at ➌. If however, the
    target_score is less than or equal to 6, we iterate over each possible roll and
    add the ones that are greater than or equal to the value of target_score at ➍.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 事件集是样本空间中帮助我们达到目标分数的所有集合。这里有两种情况：一种是剩余的回合数大于 1，另一种是我们处于最后一回合。对于第一种情况，在 ➋ 位置，我们遍历笛卡尔积中的每个元组，并将那些总和达到或超过目标分数的元组添加到
    success_rolls 列表中。第二种情况特殊：我们的样本空间只有 {1, 2, 3, 4, 5, 6} 这一集合，并且我们只剩下最后一次掷骰的机会。如果目标分数大于
    6，则无法实现目标，我们在 ➌ 位置将 success_rolls 设置为空列表。然而，如果目标分数小于或等于 6，我们会遍历每个可能的掷骰结果，并将那些大于或等于目标分数的结果添加到
    ➍ 位置的列表中。
- en: At ➎, we calculate the event set, e, from the success_rolls list that we constructed
    earlier and then return the probability of reaching the target score.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 位置，我们从之前构建的 success_rolls 列表中计算事件集 e，然后返回达到目标分数的概率。
- en: '***Nonuniform Random Numbers***'
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非均匀随机数***'
- en: Our discussions of probability have so far assumed that each of the outcomes
    in the sample space is equally likely. The random.randint() function, for example,
    returns an integer in the specified range assuming that each integer is *equally
    likely*. We refer to such probability as *uniform probability* and to random numbers
    generated by the randint() function as *uniform random numbers*. Let’s say, however,
    that we want to simulate a biased coin toss—a loaded coin for which heads is twice
    as likely to occur as tails. We’d then need a way to generate *nonuniform* random
    numbers.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的概率假设了样本空间中的每个结果都是等可能的。例如，random.randint() 函数返回指定范围内的整数，假设每个整数的出现几率是*相等的*。我们称这种概率为*均匀概率*，由
    randint() 函数生成的随机数为*均匀随机数*。然而，假设我们想模拟一个偏置的硬币投掷——一个正面朝上的概率是反面两倍的硬币。那么，我们就需要一种方法来生成*非均匀*随机数。
- en: Before we write the program to do so, we’ll review the idea behind it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写程序之前，我们先来回顾一下其背后的思想。
- en: Consider a number line with a length of 1 and with two equally divided intervals,
    as shown in [Figure 5-1](ch05.html#ch5fig1).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个长度为 1 的数轴，分成两个相等的区间，如[图 5-1](ch05.html#ch5fig1)所示。
- en: '![image](images/f05-01.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/f05-01.jpg)'
- en: '*Figure 5-1: A number line with a length of 1 divided into two equal intervals
    corresponding to the probability of heads or tails on a coin toss*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：一个长度为 1 的数轴，分成两个相等的区间，分别对应硬币投掷时正反面的概率*'
- en: We’ll refer to this line as the *probability number line*, with each division
    representing an equally possible outcome—for example, heads or tails upon a fair
    coin toss. Now, in [Figure 5-2](ch05.html#ch5fig2), consider a different version
    of this number line.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这一行称为*概率数轴*，每个划分代表一个等可能的结果——例如，公平硬币投掷时的正反面。现在，在[图 5-2](ch05.html#ch5fig2)中，考虑这种不同版本的数轴。
- en: '![image](images/f05-02.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/f05-02.jpg)'
- en: '*Figure 5-2: A number line with a length of 1 divided into two unequal intervals
    corresponding to the probability of heads or tails on a biased coin toss*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：一个长度为 1 的数轴，分成两个不等的区间，分别对应偏置硬币投掷时正反面的概率*'
- en: 'Here, the division corresponding to heads is 2/3 of the total length and the
    division corresponding to tails is 1/3\. This represents the situation of a coin
    that’s likely to turn up heads in 2/3 of tosses and tails only in 1/3 of tosses.
    The following Python function will simulate such a coin toss, considering this
    unequal probability of heads or tails appearing:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正面对应的划分占总长度的 2/3，反面对应的划分占 1/3。这代表了一个硬币的情况，其中正面在 2/3 次投掷中出现，而反面只会在 1/3 次投掷中出现。以下的
    Python 函数将模拟这种硬币投掷，考虑到正反面出现的概率不等：
- en: import random
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 random
- en: 'def toss():'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 'def toss():'
- en: '# 0 -> Heads, 1-> Tails'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '# 0 -> 正面，1 -> 反面'
- en: '➊     if random.random() < 2/3:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     如果 random.random() < 2/3：
- en: return 0
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0
- en: 'else:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return 1
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 1
- en: We assume that the function returns 0 to indicate heads and 1 to indicate tails,
    and then we generate a random number between 0 and 1 at ➊ using the random.random()
    function. If the generated number is less than 2/3—the probability of flipping
    heads with our biased coin—the program returns 0; otherwise it returns 1 (tails).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设该函数返回0表示正面，1表示反面，然后我们在➊使用random.random()函数生成一个介于0和1之间的随机数。如果生成的数字小于2/3——我们偏置硬币翻出正面的概率——程序返回0；否则返回1（反面）。
- en: We’ll now see how we can extrapolate the preceding function to simulate a nonuniform
    event with multiple possible outcomes. Let’s consider a fictional ATM that dispenses
    a $5, $10, $20, or $50 bill when its button is pressed. The different denominations
    have varying probabilities of being dispensed, as shown in [Figure 5-3](ch05.html#ch5fig3).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到如何将之前的函数扩展到模拟一个具有多个可能结果的非均匀事件。让我们考虑一个虚构的ATM机，它在按下按钮时会发放$5、$10、$20或$50的钞票。不同面额的钞票有不同的发放概率，如[图5-3](ch05.html#ch5fig3)所示。
- en: '![image](images/f05-03.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-03.jpg)'
- en: '*Figure 5-3: A number line with a length of 1 divided into four intervals of
    different lengths corresponding to the probability of dispensing bills of different
    denominations*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-3：一个长度为1的数轴，被分成四个不同长度的区间，分别对应不同面额钞票的发放概率*'
- en: Here, the probability of a $5 bill or $10 bill being dispensed is 1/6, and the
    probability of a $20 bill or $50 bill being dispensed is 1/3.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，$5钞票或$10钞票的发放概率是1/6，而$20钞票或$50钞票的发放概率是1/3。
- en: 'We create a list to store the rolling sum of the probabilities, and then we
    generate a random number between 0 and 1\. We start from the left end of the list
    that stores the sum and return the first index of this list for which the corresponding
    sum is lesser than or equal to the random number generated. The get_index() function
    implements this idea:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个列表来存储概率的累加和，然后生成一个介于0和1之间的随机数。我们从存储累加和的列表的左端开始，返回第一个满足其对应和小于或等于生成的随机数的索引。get_index()函数实现了这个思想：
- en: ''''''''
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Simulate a fictional ATM that dispenses dollar bills
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一个虚构的ATM机，它根据不同的概率发放不同面额的钞票
- en: of various denominations with varying probability
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 返回不同面额钞票的概率
- en: ''''''''
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import random
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: 'def get_index(probability):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_index(probability):'
- en: c_probability = 0
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: c_probability = 0
- en: ➊     sum_probability = []
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     sum_probability = []
- en: 'for p in probability:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'for p in probability:'
- en: c_probability += p
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: c_probability += p
- en: sum_probability.append(c_probability)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: sum_probability.append(c_probability)
- en: ➋     r = random.random()
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     r = random.random()
- en: 'for index, sp in enumerate(sum_probability):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'for index, sp in enumerate(sum_probability):'
- en: '➌         if r <= sp:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '➌         if r <= sp:'
- en: return index
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: return index
- en: ➍     return len(probability)-1
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     return len(probability)-1
- en: 'def dispense():'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 'def dispense():'
- en: dollar_bills = [5, 10, 20, 50]
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: dollar_bills = [5, 10, 20, 50]
- en: probability = [1/6, 1/6, 1/3, 2/3]
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: probability = [1/6, 1/6, 1/3, 2/3]
- en: bill_index = get_index(probability)
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: bill_index = get_index(probability)
- en: return dollar_bills[bill_index]
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: return dollar_bills[bill_index]
- en: We call the get_index() function with a list containing the probability that
    the event in the corresponding position is expected to occur. We then, at ➊, construct
    the list sum_probability, where the ith element is the sum of the first i elements
    in the list probability. That is, the first element in sum_probability is equal
    to the first element in probability, the second element is equal to the sum of
    the first two elements in probability, and so on. At ➋, a random number between
    0 and 1 is generated using the label r. Next, at ➌, we traverse through sum_probability
    and return the index of the first element that exceeds r.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用get_index()函数，传入一个包含每个位置事件期望发生概率的列表。然后，在➊，我们构造列表sum_probability，其中第i个元素是列表probability中前i个元素的和。也就是说，sum_probability中的第一个元素等于probability中的第一个元素，第二个元素等于probability中前两个元素的和，依此类推。在➋，我们使用标签r生成一个介于0和1之间的随机数。接下来，在➌，我们遍历sum_probability，并返回第一个超过r的元素的索引。
- en: The last line of the function, at ➍, takes care of a special case best illustrated
    through an example. Consider a list of three events with percentages of occurrence
    each expressed as 0.33\. In this case, the list sum_probability would look like
    [0.33, 0.66, 0.99]. Now, consider that the random number generated, r, is 0.99314.
    For this value of r, we want the last element in the list of events to be chosen.
    You may argue that this isn’t exactly right because the last event has a higher
    than 33 percent chance of being selected. As per the condition at ➌, there’s no
    element in sum_probability that’s greater than r; hence, the function wouldn’t
    return any index at all. The statement at ➍ takes care of this and returns the
    last index.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一行，在 ➍，处理了一个特殊情况，最好通过一个例子来说明。考虑一个包含三个事件的列表，每个事件发生的百分比均为 0.33。在这种情况下，列表
    sum_probability 看起来像 [0.33, 0.66, 0.99]。现在，假设生成的随机数 r 为 0.99314。对于这个 r 值，我们希望选择列表中的最后一个事件。你可能会争辩说，这不完全正确，因为最后一个事件的被选中几率大于
    33%。根据 ➌ 中的条件，sum_probability 中没有任何元素大于 r，因此该函数不会返回任何索引。➍ 处的语句处理了这个问题，并返回最后一个索引。
- en: If you call the dispense() function to simulate a large number of dollar bills
    disbursed by the ATM, you’ll see that the ratio of the number of times each bill
    appears closely obeys the probability specified. We’ll find this technique useful
    when creating *fractals* in the next chapter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用 dispense() 函数来模拟 ATM 发放大量钞票，你会发现每种钞票出现的次数比例与指定的概率紧密符合。在下一章创建 *分形* 时，我们会发现这种技术非常有用。
- en: '**What You Learned**'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started by learning how to represent a set in Python. Then,
    we discussed the various set concepts and you learned about the union, the intersection,
    and the Cartesian product of sets. You applied some of the set concepts to explore
    the basics of probability and, finally, learned how to simulate uniform and nonuniform
    random events in your programs.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你首先学习了如何在 Python 中表示集合。然后，我们讨论了各种集合的概念，你了解了集合的并集、交集和笛卡尔积。你应用了一些集合概念来探索概率的基础知识，最后，学习了如何在程序中模拟均匀和非均匀的随机事件。
- en: '**Programming Challenges**'
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Next, you have a few programming challenges to solve that’ll give you the opportunity
    to apply what you’ve learned in this chapter.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将面临一些编程挑战，解决这些挑战将给你提供应用本章所学知识的机会。
- en: '***#1: Using Venn Diagrams to Visualize Relationships Between Sets***'
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 使用 Venn 图可视化集合之间的关系***'
- en: 'A *Venn diagram* is an easy way to see the relationship between sets graphically.
    It tells us how many elements are common between the two sets, how many elements
    are only in one set, and how many elements are in neither set. Consider a set,
    *A*, that represents the set of positive odd numbers less than 20—that is, *A*
    = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}—and consider another set, *B*, that represents
    the set of prime numbers less than 20—that is, *B* = {2, 3, 5, 7, 11, 13, 17,
    19}. We can draw Venn diagrams with Python using the matplotlib_venn package (see
    [Appendix A](app01.html#app01) for installation instructions for this package).
    Once you’ve installed it, you can draw the Venn diagram as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*Venn图* 是一种直观展示集合之间关系的方式。它告诉我们两个集合中有多少个元素是公共的，有多少个元素只在一个集合中，且有多少个元素既不在集合A也不在集合B中。考虑一个集合
    *A*，表示小于20的正奇数——即 *A* = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}——以及另一个集合 *B*，表示小于20的素数——即
    *B* = {2, 3, 5, 7, 11, 13, 17, 19}。我们可以使用 Python 的 matplotlib_venn 包来绘制 Venn 图（有关此包的安装说明，请参见
    [附录A](app01.html#app01)）。安装完成后，你可以通过以下方式绘制 Venn 图：'
- en: ''''''''
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Draw a Venn diagram for two sets
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为两个集合绘制 Venn 图
- en: ''''''''
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from matplotlib_venn import venn2
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 从 matplotlib_venn 导入 venn2
- en: import matplotlib.pyplot as plt
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: from sympy import FiniteSet
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 从 sympy 导入 FiniteSet
- en: 'def draw_venn(sets):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_venn(sets):'
- en: venn2(subsets=sets)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: venn2(subsets=sets)
- en: plt.show()
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: s1 = FiniteSet(1, 3, 5, 7, 9, 11, 13, 15, 17, 19)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: s1 = FiniteSet(1, 3, 5, 7, 9, 11, 13, 15, 17, 19)
- en: s2 = FiniteSet(2, 3, 5, 7, 11, 13, 17, 19)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: s2 = FiniteSet(2, 3, 5, 7, 11, 13, 17, 19)
- en: draw_venn([s1, s2])
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: draw_venn([s1, s2])
- en: Once we import all the required modules and functions (the venn2() function,
    matplotlib.pyplot, and the FiniteSet class), all we have to do is create the two
    sets and then call the venn2() function, using the subsets key-word argument to
    specify the sets as a tuple.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了所有所需的模块和函数（包括 venn2() 函数、matplotlib.pyplot 和 FiniteSet 类），我们所要做的就是创建这两个集合，然后调用
    venn2() 函数，使用 subsets 关键字参数将集合作为元组传入。
- en: '[Figure 5-4](ch05.html#ch5fig4) shows the Venn diagram created by the preceding
    program. The sets *A* and *B* share seven common elements, so 7 is written in
    the common area. Each of the sets also has unique elements, so the number of unique
    elements—3 and 1, respectively—is written in the individual areas. The labels
    below the two sets are shown as *A* and *B*. You can specify your own labels using
    the set_labels keyword argument:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-4](ch05.html#ch5fig4)显示了通过前面的程序创建的维恩图。集合*A*和*B*共享七个公共元素，因此在交集区域写入7。每个集合还有各自独有的元素，因此独有元素的数量——分别是3和1——被写入各自的区域。两个集合下方的标签显示为*A*和*B*。你可以使用set_labels关键字参数指定自己的标签：'
- en: '>>> venn2(subsets=(a,b), set_labels=(''S'', ''T''))'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> venn2(subsets=(a,b), set_labels=(''S'', ''T''))'
- en: This would change the set labels to S and T.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把集合标签更改为S和T。
- en: '![image](images/f05-04.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-04.jpg)'
- en: '*Figure 5-4: Venn diagram showing the relationship between two sets*, A *and*
    B'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-4：显示两个集合*A*和*B*之间关系的维恩图*'
- en: 'For your challenge, imagine you’ve created an online questionnaire asking your
    classmates the following question: *Do you play football, another sport, or no
    sports?* Once you have the results, create a CSV file, *sports.csv*, as follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的挑战，假设你已经创建了一个在线问卷，询问你的同学以下问题：*你是否踢足球，参与其他运动，还是不参与任何运动？* 一旦得到结果，创建一个CSV文件，名为*sports.csv*，内容如下：
- en: StudentID,Football,Others
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 学生ID, 足球, 其他
- en: 1,1,0
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 1,1,0
- en: 2,1,1
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 2,1,1
- en: 3,0,1
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 3,0,1
- en: --snip--
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: Create 20 such rows for the 20 students in your class. The first column is the
    student ID (the survey isn’t anonymous), the second column has a 1 if the student
    has marked “football” as the sport they love to play, and the third column has
    a 1 if the student plays any other sport or none at all. Write a program to create
    a Venn diagram to depict the summarized results of the survey, as shown in [Figure
    5-5](ch05.html#ch5fig5).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为班级中的20个学生创建20行数据。第一列是学生ID（调查不是匿名的），第二列如果学生选择了“足球”作为他们喜欢玩的运动，则填写1，第三列如果学生参与任何其他运动或完全不参与任何运动，则填写1。编写程序创建一个维恩图来表示调查结果的总结，如[图5-5](ch05.html#ch5fig5)所示。
- en: '![image](images/f05-05.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-05.jpg)'
- en: '*Figure 5-5: A Venn diagram showing the number of students who love to play
    football and the number who love to play other sports*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-5：显示喜欢踢足球的学生人数以及喜欢其他运动的学生人数的维恩图*'
- en: 'Depending on the data in the *sports.csv* file you created, the numbers in
    each set will vary. The following function reads a CSV file and returns two lists
    corresponding to the IDs of those students who play football and other sports:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你创建的*sports.csv*文件中的数据，每个集合中的数字将有所不同。以下函数读取CSV文件并返回两个列表，分别对应那些踢足球和参与其他运动的学生ID：
- en: 'def read_csv(filename):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_csv(filename):'
- en: football = []
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: football = []
- en: others = []
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: others = []
- en: 'with open(filename) as f:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(filename) as f:'
- en: reader = csv.reader(f)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: reader = csv.reader(f)
- en: next(reader)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: next(reader)
- en: 'for row in reader:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 对 row 在 reader 中：
- en: 'if row[1] == ''1'':'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 row[1] == '1'：
- en: football.append(row[0])
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: football.append(row[0])
- en: 'if row[2] == ''1'':'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 row[2] == '1'：
- en: others.append(row[0])
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: others.append(row[0])
- en: return football, others
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: return football, others
- en: '***#2: Law of Large Numbers***'
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 大数法则***'
- en: 'We’ve referred to a die roll and coin toss as two examples of random events
    that we can simulate using random numbers. We’ve used the term *event* to refer
    to a certain number showing up on a die roll or to heads or tails showing up on
    a coin toss, with each event having an associated probability value. In probability,
    a *random variable*—usually denoted by *X*—describes an event. For example, *X*
    = 1 describes the event of 1 appearing upon a die roll, and *P*(*X* = 1) describes
    the associated probability. There are two kinds of random variables: (1) *discrete*
    random variables, which take only integral values and are the only kind of random
    variables we see in this chapter, and (2) *continuous* random variables, which—as
    the name suggests—can take any real value.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过投掷骰子和抛硬币作为可以通过随机数模拟的随机事件示例。我们使用*事件*一词来指代在掷骰子时出现某个数字，或在抛硬币时出现正面或反面，每个事件都有一个相关的概率值。在概率论中，*随机变量*——通常表示为*X*——描述一个事件。例如，*X*
    = 1表示掷骰子时出现1的事件，而*P*(*X* = 1)描述了相关的概率。随机变量有两种类型：（1）*离散*随机变量，它只取整数值，是本章中我们看到的唯一类型的随机变量；（2）*连续*随机变量，顾名思义，可以取任何实数值。
- en: 'The *expectation*, *E*, of a discrete random variable is the equivalent of
    the average or mean that we learned about in [Chapter 3](ch03.html#ch03). The
    expectation can be calculated as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 离散随机变量的*期望值*，*E*，等同于我们在[第3章](ch03.html#ch03)中学习的平均值或均值。期望值可以通过以下方式计算：
- en: '*E* = *x*[1]*P*(*x*[1]) + *x*[2]*P*(*x*[2]) + *x*[3]*P*(*x*[3]) + ... + *x[n]P*(*x[n]*)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = *x*[1]*P*(*x*[1]) + *x*[2]*P*(*x*[2]) + *x*[3]*P*(*x*[3]) + ... + *x[n]P*(*x[n]*)'
- en: 'Thus, for a six-sided die, the *expected value* of a die roll can be calculated
    like this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于一个六面骰子，*期望值*可以这样计算：
- en: '>>> e = 1*(1/6) + 2*(1/6) + 3*(1/6) + 4*(1/6) + 5*(1/6) + 6*(1/6)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> e = 1*(1/6) + 2*(1/6) + 3*(1/6) + 4*(1/6) + 5*(1/6) + 6*(1/6)'
- en: '>>> e'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> e'
- en: '3.5'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '3.5'
- en: 'According to the *law of large numbers*, the average value of results over
    multiple trials approaches the expected value as the number of trials increases.
    Your challenge in this task is to verify this law when rolling a six-sided die
    for the following number of trials: 100, 1000, 10000, 100000, and 500000\. Here’s
    an expected sample run of your complete program:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*大数法则*，在多次试验中，结果的平均值随着试验次数的增加，接近期望值。你在这个任务中的挑战是验证这个法则，尝试掷一个六面骰子，进行以下次数的试验：100、1000、10000、100000
    和 500000。下面是你完整程序的一个预期示例运行：
- en: Expected value: 3.5
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 期望值：3.5
- en: Trials: 100 Trial average 3.39
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 试验次数：100 次 平均值 3.39
- en: Trials: 1000 Trial average 3.576
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 试验次数：1000 次 平均值 3.576
- en: Trials: 10000 Trial average 3.5054
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 试验次数：10000 次 平均值 3.5054
- en: Trials: 100000 Trial average 3.50201
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 试验次数：100000 次 平均值 3.50201
- en: Trials: 500000 Trial average 3.495568
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 试验次数：500000 次 平均值 3.495568
- en: '***#3: How Many Tosses Before You Run Out of Money?***'
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 你需要多少次投币才会把钱用完？***'
- en: 'Let’s consider a simple game played with a fair coin toss. A player wins $1
    for heads and loses $1.50 for tails. The game is over when the player’s balance
    reaches $0\. Given a certain starting amount specified by the user as input, your
    challenge is to write a program that simulates this game. Assume there’s an unlimited
    cash reserve with the computer—your opponent here. Here’s a possible game play
    session:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的游戏，玩家通过抛硬币获胜。如果硬币正面朝上，玩家赢得1美元；如果反面朝上，玩家亏损1.50美元。游戏在玩家的余额为0时结束。给定一个用户输入的初始金额，你的挑战是编写一个程序来模拟这个游戏。假设计算机拥有无限现金储备——你在游戏中的对手。以下是一个可能的游戏过程：
- en: Enter your starting amount: 10
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你的初始金额：10
- en: Tails! Current amount: 8.5
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 正面！当前金额：8.5
- en: Tails! Current amount: 7.0
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 正面！当前金额：7.0
- en: Tails! Current amount: 5.5
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 正面！当前金额：5.5
- en: Tails! Current amount: 4.0
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 反面！当前金额：4.0
- en: Tails! Current amount: 2.5
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 反面！当前金额：2.5
- en: Heads! Current amount: 3.5
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 正面！当前金额：3.5
- en: Tails! Current amount: 2.0
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 反面！当前金额：2.0
- en: Tails! Current amount: 0.5
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 反面！当前金额：0.5
- en: Tails! Current amount: -1.0
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 正面！当前金额：-1.0
- en: Game over :( Current amount: -1.0. Coin tosses: 9
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束 :( 当前金额：-1.0。 投币次数：9
- en: '***#4: Shuffling a Deck of Cards***'
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 洗牌一副牌***'
- en: Consider a standard deck of 52 playing cards. Your challenge here is to write
    a program to simulate the shuffling of this deck. To keep the implementation simple,
    I suggest you use the integers 1, 2, 3, ..., 52 to represent the deck. Every time
    you run the program, it should output a shuffled deck—in this case, a shuffled
    list of integers.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一副标准的52张扑克牌。你的挑战是编写一个程序来模拟洗牌过程。为了简化实现，建议你使用整数1, 2, 3, ..., 52来表示这副牌。每次运行程序时，它应输出一副洗过的牌——即一组洗乱的整数。
- en: 'Here’s a possible output of your program:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你程序的一个可能输出：
- en: '[3, 9, 21, 50, 32, 4, 20, 52, 7, 13, 41, 25, 49, 36, 23, 45, 1, 22, 40, 19, 2,'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[3, 9, 21, 50, 32, 4, 20, 52, 7, 13, 41, 25, 49, 36, 23, 45, 1, 22, 40, 19,
    2,'
- en: 35, 28, 30, 39, 44, 29, 38, 48, 16, 15, 18, 46, 31, 14, 33, 10, 6, 24, 5, 43,
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 35, 28, 30, 39, 44, 29, 38, 48, 16, 15, 18, 46, 31, 14, 33, 10, 6, 24, 5, 43,
- en: 47, 11, 34, 37, 27, 8, 17, 51, 12, 42, 26]
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 47, 11, 34, 37, 27, 8, 17, 51, 12, 42, 26]
- en: 'The random module in Python’s standard library has a function, shuffle(), for
    this exact operation:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的random模块有一个shuffle()函数，正是用来执行这个操作：
- en: '>>> import random'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import random'
- en: '>>> x = [1, 2, 3, 4]'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3, 4]'
- en: ➊ >>> random.shuffle(x)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> random.shuffle(x)
- en: '>>> x'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[4, 2, 1, 3]'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 2, 1, 3]'
- en: Create a list, x, consisting of the numbers [1, 2, 3, 4]. Then, call the shuffle()
    function ➊, passing this list as an argument. You’ll see that the numbers in x
    have been shuffled. Note that the list is shuffled “in place.” That is, the original
    order is lost.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含数字[1, 2, 3, 4]的列表x。然后，调用shuffle()函数 ➊，并将此列表作为参数传递。你会看到x中的数字已经被打乱。请注意，列表是“就地”打乱的，也就是说，原来的顺序丢失了。
- en: 'But what if you wanted to use this program in a card game? There, it’s not
    enough to simply output the shuffled list of integers. You’ll also need a way
    to map back the integers to the specific suit and rank of each card. One way you
    might do this is to create a Python class to represent a single card:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在扑克牌游戏中使用这个程序呢？在那里，单纯输出洗牌后的整数列表是不够的。你还需要一种方法将这些整数映射回每张牌的特定花色和点数。你可以通过创建一个Python类来表示一张单牌来实现：
- en: 'class Card:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Card:'
- en: 'def __init__(self, suit, rank):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, suit, rank):'
- en: self.suit = suit
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: self.suit = suit
- en: self.rank = rank
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: self.rank = rank
- en: 'To represent the ace of clubs, create a card object, card1 = Card(''clubs'',
    ''ace''). Then, do the same for all the other cards. Next, create a list consisting
    of each of the card objects and shuffle this list. The result will be a shuffled
    deck of cards where you also know the suit and rank of each card. Output of the
    program should look something like this:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示梅花A，创建一个卡片对象，card1 = Card('clubs', 'ace')。然后，对所有其他卡片执行相同操作。接下来，创建一个由每个卡片对象组成的列表并对该列表进行洗牌。程序的输出应类似于以下内容：
- en: 10 of spades
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 黑桃10
- en: 6 of clubs
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 梅花6
- en: jack of spades
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 黑桃杰克
- en: 9 of spades
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 黑桃9
- en: '***#5: Estimating the Area of a Circle***'
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5：估算圆的面积***'
- en: Consider a dartboard with a circle of radius *r* inscribed in a square with
    side 2*r*. Now let’s say you start throwing a large number of darts at it. Some
    of these will hit the board within the circle—let’s say, *N*—and others outside
    it—let’s say, *M*. If we consider the fraction of darts that land inside the circle,
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个正方形边长为 2*r*，内切圆半径为*r*的飞镖板。假设你开始向它投掷大量飞镖。其中一些飞镖会击中圆内——假设是*N*——而其他飞镖则击中圆外——假设是*M*。如果我们考虑落在圆内的飞镖比例，
- en: '![image](images/e0145-01.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0145-01.jpg)'
- en: then the value of *f* × *A*, where *A* is the area of the square, would roughly
    be equal to the area of the circle (see [Figure 5-6](ch05.html#ch5fig6)). The
    darts are represented by the small circular dots in the figure. We shall refer
    to the value of *f* × *A* as the estimated area. The actual area is, of course,
    *πr*².
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 那么*f* × *A*的值，其中*A*是正方形的面积，将大致等于圆的面积（参见[图 5-6](ch05.html#ch5fig6)）。飞镖在图中由小圆点表示。我们将*f*
    × *A*的值称为估算面积。实际的面积当然是*πr*²。
- en: '![image](images/f05-06.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-06.jpg)'
- en: '*Figure 5-6: A circle of radius* r *inscribed in a square board with side 2*r*.
    The dots represent darts randomly thrown at the board.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：一个半径为* r *的圆被内切于边长为 2*r*的正方形板中。点表示随机投掷到板上的飞镖。*'
- en: 'As part of this challenge, write a program that will find the estimated area
    of a circle, given any radius, using this approach. The program should print the
    estimated area of the circle for three different values of the number of darts:
    10³, 10⁵, and 10⁶. That’s a lot of darts! You’ll see that increasing the number
    of darts brings the estimated area close to the actual area. Here’s a sample output
    of the completed solution:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个挑战的一部分，编写一个程序，使用此方法估算给定半径的圆的面积。程序应打印出在三种不同的飞镖数值下圆的估算面积：10³，10⁵，和10⁶。这是很多飞镖！你会看到，增加飞镖的数量会使估算的面积接近实际面积。以下是完整解决方案的示例输出：
- en: Radius: 2
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 半径：2
- en: Area: 12.566370614359172, Estimated (1000 darts): 12.576
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 区域：12.566370614359172，估算值（1000 投掷）：12.576
- en: Area: 12.566370614359172, Estimated (100000 darts): 12.58176
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 区域：12.566370614359172，估算值（100000 投掷）：12.58176
- en: Area: 12.566370614359172, Estimated (1000000 darts): 12.560128
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 区域：12.566370614359172，估算值（1000000 投掷）：12.560128
- en: The dart throw can be simulated by a call to the random.uniform(a, b) function,
    which will return a random number between *a* and *b*. In this case, use the values
    *a* = 0, *b* = 2*r* (the side of the square).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷飞镖可以通过调用random.uniform(a, b)函数来模拟，该函数将返回一个介于*a*和*b*之间的随机数。在此情况下，使用值*a* = 0，*b*
    = 2*r*（正方形的边长）。
- en: '**Estimating the Value of Pi**'
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**估算圆周率的值**'
- en: Consider [Figure 5-6](ch05.html#ch5fig6) once again. The area of the square
    is 4*r*², and the area of the inscribed circle is *πr*². If we divide the area
    of the circle by the area of the square, we get *π*/4\. The fraction *f* that
    we calculated earlier,
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑[图 5-6](ch05.html#ch5fig6)。正方形的面积是 4*r*²，内切圆的面积是*πr*²。如果我们将圆的面积除以正方形的面积，得到*π*/4。我们之前计算的分数*f*，
- en: '![image](images/e0147-01.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0147-01.jpg)'
- en: is thus an approximation of *π*/4, which in turn means that the value of
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它是*π*/4的近似值，这反过来意味着
- en: '![image](images/e0147-02.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0147-02.jpg)'
- en: should be close to the value of *π*. Your next challenge is to write a program
    that will estimate the value of *π* assuming any value for the radius. As you
    increase the number of darts, the estimated value of *π* should get close to the
    known value of the constant.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 应该接近*π*的值。你的下一个挑战是编写一个程序，估算圆周率的值，假设任何半径值。随着飞镖数量的增加，估算的*π*值应该接近常数的已知值。
