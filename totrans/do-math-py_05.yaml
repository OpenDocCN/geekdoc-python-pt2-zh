- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**Playing with Sets and Probability**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩转集合与概率**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this chapter, we’ll start by learning how we can make our programs understand
    and manipulate sets of numbers. We’ll then see how sets can help us understand
    basic concepts in probability. Finally, we’ll learn about generating random numbers
    to simulate random events. Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将首先学习如何使我们的程序理解和操作数字集合。接着，我们将看到集合如何帮助我们理解概率的基本概念。最后，我们将学习如何生成随机数以模拟随机事件。让我们开始吧！
- en: '**What’s a Set?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是集合？**'
- en: A *set* is a collection of distinct objects, often called *elements* or *members*.
    Two characteristics of a set make it different from just any collection of objects.
    A set is “well defined,” meaning the question “Is a particular object in this
    collection?” always has a clear yes or no answer, usually based on a rule or some
    given criteria. The second characteristic is that no two members of a set are
    the same. A set can contain anything—numbers, people, things, words, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一个包含不同对象的集合，通常称为*元素*或*成员*。集合有两个特点使它不同于任何其他对象的集合。集合是“明确定义”的，这意味着问题“某个特定对象是否在这个集合中？”总是有一个明确的“是”或“不是”的答案，通常基于某种规则或给定的标准。第二个特点是集合的任何两个成员都不相同。集合可以包含任何东西——数字、人物、事物、单词等等。'
- en: Let’s walk through some basic properties of sets as we learn how to work with
    sets in Python using SymPy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些基本的集合特性来学习如何使用SymPy在Python中操作集合。
- en: '***Set Construction***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合构造***'
- en: 'In mathematical notation, you represent a set by writing the set members enclosed
    in curly brackets. For example, {2, 4, 6} represents a set with 2, 4, and 6 as
    its members. To create a set in Python, we can use the `FiniteSet` class from
    the `sympy` package, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学符号中，集合通常通过将集合成员括在大括号中表示。例如，{2, 4, 6}表示一个包含2、4和6作为成员的集合。要在Python中创建集合，我们可以使用来自`sympy`包的`FiniteSet`类，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we first import the `FiniteSet` class from SymPy and then create an object
    of this class by passing in the set members as arguments. We assign the label
    `s` to the set we just created.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从SymPy导入`FiniteSet`类，然后通过将集合成员作为参数传递来创建该类的一个对象。我们将标签`s`赋给我们刚创建的集合。
- en: 'We can store different types of numbers—including integers, floating point
    numbers, and fractions—in the same set:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个集合中存储不同类型的数字——包括整数、浮点数和分数：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The *cardinality* of a set is the number of members in the set, which you can
    find by using the `len()` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的*基数*是集合中成员的数量，你可以通过使用`len()`函数来找到：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Checking Whether a Number Is in a Set**'
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查一个数字是否在集合中**'
- en: 'To check whether a number is a member of an existing set, use the `in` operator.
    This operator asks Python, “Is this number in this set?” It returns `True` if
    the number belongs to the set and `False` if it doesn’t. If, for example, we wanted
    to check whether 4 was in the previous set, we’d do the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个数字是否是已存在集合的成员，可以使用`in`运算符。这个运算符会问Python：“这个数字是否在这个集合中？”如果数字属于该集合，它返回`True`，如果不属于，则返回`False`。例如，如果我们想检查4是否在之前的集合中，我们可以这样做：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because 4 is not present in the set, the operator returns `False`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于4不在集合中，因此运算符返回`False`。
- en: '**Creating an Empty Set**'
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建空集合**'
- en: 'If you want to make an *empty set*, which is a set that doesn’t have any elements
    or members, create a `FiniteSet` object without passing any arguments. The result
    is an `EmptySet` object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个*空集合*，即没有任何元素或成员的集合，只需创建一个不传递任何参数的`FiniteSet`对象。结果是一个`EmptySet`对象：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Creating Sets from Lists or Tuples**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从列表或元组创建集合**'
- en: 'You can also create a set by passing in a list or a tuple of set members as
    an argument to `FiniteSet`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将一个列表或元组作为集合成员传递给`FiniteSet`来创建一个集合：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, instead of passing in the set members directly to `FiniteSet`, we first
    stored them in a list, which we called `members`. Then, we passed the list to
    `FiniteSet` using this special Python syntax, which basically translates to creating
    a `FiniteSet` object that passes the list members as separate arguments and not
    as a list. That is, this approach to creating a `FiniteSet` object is equivalent
    to `FiniteSet(1, 2, 3)`. We will make use of this syntax when the set members
    are computed at runtime.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们并没有直接将集合成员传递给`FiniteSet`，而是先将它们存储在一个我们称为`members`的列表中。然后，我们使用这种特殊的Python语法将列表传递给`FiniteSet`，这基本上相当于创建一个`FiniteSet`对象，并将列表成员作为单独的参数传递，而不是作为列表。也就是说，这种创建`FiniteSet`对象的方法等同于`FiniteSet(1,
    2, 3)`。当集合成员在运行时计算时，我们将使用这种语法。
- en: '**Set Repetition and Order**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**集合的重复性与顺序**'
- en: 'Sets in Python (like mathematical sets) ignore any repeats of a member, and
    they don’t keep track of the order of set members. For example, if you create
    a set from a list that has multiple instances of a number, the number is added
    to the set only once, and the other instances are discarded:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的集合（像数学中的集合一样）会忽略成员的重复项，并且不跟踪集合成员的顺序。例如，如果你从一个包含多个相同数字的列表中创建集合，那么该数字只会被添加一次，其他重复的实例会被丢弃：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, even though we passed in a list that had two instances of the number 2,
    the number 2 appears only once in the set created from that list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，即使我们传入了一个包含两个数字2的列表，但从该列表创建的集合中，数字2只出现了一次。
- en: 'In Python lists and tuples, each element is stored in a particular order, but
    the same is not always true for sets. For example, we can print out each member
    of a set by iterating through it as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 列表和元组中，每个元素都是按特定顺序存储的，但集合并不总是如此。例如，我们可以通过以下方式遍历集合并打印出其中的每个成员：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you run this code, the elements could be printed in any possible order.
    This is because of how sets are stored by Python—it keeps track of what members
    are in the set, but it doesn’t keep track of any particular order for those members.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，元素可能会以任何可能的顺序打印出来。这是因为集合在 Python 中的存储方式——它跟踪集合中包含的成员，但并不跟踪这些成员的任何特定顺序。
- en: 'Let’s see another example. Two sets are *equal* when they have the same elements.
    In Python, you can use the equality operator, `==`, to check whether two sets
    are equal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。当两个集合具有相同的元素时，它们是 *相等* 的。在 Python 中，你可以使用相等运算符 `==` 来检查两个集合是否相等：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although the members of these two sets appear in different orders, the sets
    are still equal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个集合的成员顺序不同，但它们仍然是相等的。
- en: '***Subsets, Supersets, and Power Sets***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***子集、超集和幂集***'
- en: 'A set, *s*, is a *subset* of another set, *t*, if all the members of *s* are
    also members of *t*. For example, the set {1} is a subset of the set {1, 2}. You
    can check whether a set is a subset of another set using the `is_subset()` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合 *s* 中的所有成员也都是集合 *t* 的成员，那么集合 *s* 就是集合 *t* 的 *子集*。例如，集合 {1} 是集合 {1, 2} 的子集。你可以使用
    `is_subset()` 方法来检查一个集合是否是另一个集合的子集：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that an empty set is a subset of every set. Also, any set is a subset
    of itself, as you can see in the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空集合是每个集合的子集。同时，任何集合都是自身的子集，正如你在以下示例中看到的：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, a set, *t*, is said to be a *superset* of another set, *s*, if *t*
    contains all of the members contained in *s*. You can check whether one set is
    a superset of another using the `is_superset()` method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果集合 *t* 包含了集合 *s* 中的所有成员，那么集合 *t* 就是集合 *s* 的 *超集*。你可以使用 `is_superset()`
    方法来检查一个集合是否是另一个集合的超集：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The *power set* of a set, *s*, is the set of all possible subsets of *s*. Any
    set, *s*, has precisely 2^(|*s*|) subsets, where |*s*| is the cardinality of the
    set. For example, the set {1, 2, 3} has a cardinality of 3, so it has 2³ or 8
    subsets: {} (the empty set), {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3}, and {1, 2,
    3}.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 *s* 的 *幂集* 是 *s* 所有可能子集的集合。任何集合 *s* 的子集数量正好是 2^(|*s*|)，其中 |*s*| 是集合的基数。例如，集合
    {1, 2, 3} 的基数为 3，所以它有 2³ 或 8 个子集：{}（空集合）、{1}、{2}、{3}、{1, 2}、{2, 3}、{1, 3} 和 {1,
    2, 3}。
- en: 'The set of all these subsets form the power set, and we can find the power
    set using the `powerset()` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些子集的集合形成了幂集，我们可以使用 `powerset()` 方法来找出幂集：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As the power set is a set itself, you can find its cardinality using the `len()`
    function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于幂集本身就是一个集合，你可以使用 `len()` 函数来找出它的基数：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The cardinality of the power set is 2^(|*s*|), which is 2³ = 8.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幂集的基数是 2^(|*s*|)，即 2³ = 8。
- en: 'Based on our definition of a subset, any two sets with the exact same members
    would be subsets as well as supersets of each other. By contrast, a set, *s*,
    is a *proper subset* of *t* only if all the members of *s* are also in *t* and
    *t* has at least one member that is not in *s*. So if *s* = {1, 2, 3}, it’s only
    a proper subset of *t* if *t* contains 1, 2, and 3 plus at least one more member.
    This would also mean that *t* is a *proper superset* of *s*. You can use the `is_proper_subset()`
    method and the `is_proper_superset()` method to check for these relationships:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对子集的定义，任何两个具有完全相同成员的集合，既是彼此的子集，又是彼此的超集。相反，集合 *s* 只有在 *t* 中包含 *s* 的所有成员，并且
    *t* 至少有一个不在 *s* 中的成员时，*s* 才是 *t* 的 *真子集*。例如，如果 *s* = {1, 2, 3}，它只有在 *t* 包含 1、2
    和 3，并且还有至少一个额外的成员时，才是 *t* 的真子集。这也意味着 *t* 是 *s* 的 *真超集*。你可以使用 `is_proper_subset()`
    方法和 `is_proper_superset()` 方法来检查这些关系：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if we re-create the set `t` to include another member, `s` will be considered
    a proper subset of `t` and `t` a proper superset of `s`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新创建集合`t`，使其包含另一个成员，则`s`将被认为是`t`的真子集，而`t`是`s`的真超集：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**COMMON NUMBER SETS**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见数集**'
- en: In the first chapter, we learned that there are different kinds of numbers—
    integers, floating point numbers, fractions, and complex numbers. All these numbers
    form different sets of numbers, which have special names.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们学习了不同种类的数字——整数、浮动点数、分数和复数。所有这些数字构成不同的数集，并且它们有特殊的名称。
- en: All positive and negative whole numbers form the set of *integers*. All positive
    integers form the set of *natural numbers* (sometimes 0 is included in this set
    of numbers even though it’s not positive, but sometimes not). This means the set
    of natural numbers is a proper subset of the set of integers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正整数和负整数构成*整数*集合。所有正整数构成*自然数*集合（有时，0也包括在这个集合中，尽管它不是正数，但有时也不包括）。这意味着自然数集合是整数集合的一个真子集。
- en: The set of *rational numbers* includes any number that can be expressed as a
    fraction, which includes all integers, plus any number with a decimal ending that
    terminates or repeats (including numbers like 1/4 or 0.25, and 1/3 or 0.33333
    ...). By contrast, nonrepeating, nonterminating decimal numbers are known as *irrational
    numbers*. The square root of 2 and *π* are both examples of irrational numbers
    because they go on forever without repeating.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*有理数*集合包括所有可以表示为分数的数字，这包括所有整数，以及任何终止或重复的小数（包括像1/4或0.25，以及1/3或0.33333 ...这样的数字）。相比之下，不重复、不终止的小数被称为*无理数*。2的平方根和*π*都是无理数的例子，因为它们永远不会重复且无限延续。'
- en: If you put together all the rational and irrational numbers, you get the set
    of *real numbers*. But even larger than that is the set of *complex numbers*,
    which includes all real numbers and all numbers with an imaginary component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将所有有理数和无理数放在一起，你就得到了*实数*集合。比这更大的集合是*复数*集合，它包括所有实数以及所有包含虚部的数字。
- en: All of these sets of numbers are infinite sets because they have infinite members.
    In contrast, the sets we’ve discussed in this chapter have a finite number of
    members, which is why the SymPy class we’re using is called `FiniteSet`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数集都是无限集，因为它们包含无限个成员。相比之下，我们在本章中讨论的集合具有有限个成员，这也是我们使用的SymPy类被称为`FiniteSet`的原因。
- en: '***Set Operations***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合运算***'
- en: Set operations such as union, intersection, and the Cartesian product allow
    you to combine sets in certain methodical ways. These set operations are extremely
    useful in real-world problem-solving situations when we have to consider multiple
    sets together. Later in this chapter, we’ll see how to use these operations to
    apply a formula to multiple sets of data and calculate the probabilities of random
    events.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 集合运算，如并集、交集和笛卡尔积，允许你以某种有规律的方式组合集合。当我们需要一起考虑多个集合时，这些集合运算在现实世界的解决问题中非常有用。稍后在本章中，我们将看到如何使用这些运算将公式应用于多个数据集合，并计算随机事件的概率。
- en: '**Union and Intersection**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**并集与交集**'
- en: 'The *union* of two sets is a set that contains all of the *distinct* members
    of the two sets. In set theory, we use the symbol ∪ to refer to the union operation.
    For example, {1, 2} ∪ {2, 3} will result in a new set, {1, 2, 3}. In SymPy, the
    union of these two sets can be created using the `union()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*并集*是一个包含这两个集合所有*不同*成员的集合。在集合论中，我们使用符号∪来表示并集运算。例如，{1, 2} ∪ {2, 3}将得到一个新集合{1,
    2, 3}。在SymPy中，这两个集合的并集可以通过`union()`方法创建：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We find the union of `s` and `t` by applying the `union` method to `s` and passing
    in `t` as an argument. The result is a third set with all the distinct members
    of the two sets. In other words, each member of this third set is a member of
    one or both of the first two sets.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过对`s`应用`union`方法并将`t`作为参数传递给`s`，来找到`s`和`t`的并集。结果是一个包含这两个集合所有不同成员的第三个集合。换句话说，这个第三个集合中的每个成员都是前两个集合中一个或两个的成员。
- en: The *intersection* of two sets creates a new set from the elements common to
    both sets. For example, the intersection of the sets {1, 2} and {2, 3} will result
    in a new set with the only common element, {2}. Mathematically, this operation
    is written as {1, 2} ∩ {2, 3}.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*交集*从两个集合中共有的元素创建一个新的集合。例如，集合{1, 2}和{2, 3}的交集将结果为一个包含唯一公共元素{2}的新集合。在数学中，这个运算表示为{1,
    2} ∩ {2, 3}。
- en: 'In SymPy, use the `intersect()` method to find the intersection:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy中，使用`intersect()`方法来查找交集：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whereas the union operation finds members that are in one set *or* another,
    the intersection operation finds elements that are present in both. Both of these
    operations can also be applied to more than two sets. For example, here’s how
    you’d find the union of three sets:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 而并集操作找到的是属于一个集合*或*另一个集合的成员，交集操作找到的是同时存在于两个集合中的元素。这两种操作也可以应用于超过两个集合。例如，这是你如何找到三个集合的并集：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, here’s how you’d find the intersection of three sets:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这是你如何找到三个集合交集的方法：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The intersection of the sets `s`, `t`, and `u` turns out to be an empty set
    because there are no elements that all three sets share.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 集合`s`、`t`和`u`的交集实际上是一个空集合，因为没有任何元素是这三个集合共有的。
- en: '**Cartesian Product**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**笛卡尔积**'
- en: 'The *Cartesian product* of two sets creates a set that consists of all possible
    pairs made by taking an element from each set. For example, the Cartesian product
    of the sets {1, 2} and {3, 4} is {(1, 3), (1, 4), (2, 3), (2, 4)}. In SymPy, you
    can find the Cartesian product of two sets by simply using the multiplication
    operator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*笛卡尔积*创建了一个由每个集合中取一个元素组成的所有可能的对组成的集合。例如，集合{1, 2}和{3, 4}的笛卡尔积是{(1, 3), (1,
    4), (2, 3), (2, 4)}。在SymPy中，你可以通过简单地使用乘法运算符来找到两个集合的笛卡尔积：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This takes the Cartesian product of the sets `s` and `t` and stores it as `p`.
    To actually see each pair in that Cartesian product, we can iterate through and
    print them out as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这会获取集合`s`和`t`的笛卡尔积，并将其存储为`p`。为了实际查看笛卡尔积中的每一对，我们可以通过遍历并打印它们，如下所示：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each element of the product is a tuple consisting of a member from the first
    set and a member from the second set.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个笛卡尔积的每个元素是一个元组，包含来自第一个集合的成员和来自第二个集合的成员。
- en: 'The cardinality of the Cartesian product is the product of the cardinality
    of the individual sets. We can demonstrate this in Python:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积的基数是各个集合基数的乘积。我们可以在Python中演示这一点：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we apply the exponential operator (`**`) to a set, we get the Cartesian product
    of that set times itself the specified number of times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个集合应用指数运算符（`**`），我们得到的是该集合与自身的笛卡尔积，次数由指定的次数决定。
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, for example, we raised the set `s` to the power of 3\. Because we’re
    taking the Cartesian product of three sets, this gives us a set of all possible
    triplets that contain a member of each set:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们将集合`s`的指数提升到3。由于我们正在进行三个集合的笛卡尔积，这给我们带来一个包含每个集合成员的所有可能三元组的集合：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finding the Cartesian product of sets is useful for finding all possible combinations
    of the set members, which we’ll explore next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 查找集合的笛卡尔积对于找出集合成员的所有可能组合非常有用，接下来我们将探讨这一点。
- en: '**Applying a Formula to Multiple Sets of Variables**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将公式应用于多个变量集合**'
- en: Consider a simple pendulum of length *L*. The *time period*, *T*, of this pendulum—that
    is, the amount of time it takes for the pendulum to complete one full swing—is
    given by the formula
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个长度为*L*的简单摆。这个摆的*周期*，*T*，即摆完成一个完整摆动所需的时间，可以通过以下公式给出：
- en: '![image](images/e0129-01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0129-01.jpg)'
- en: Here, *π* is the mathematical constant, *pi*, and *g* is the local gravitational
    acceleration, which is around 9.8 m/s² on Earth. Because *π* and *g* are constants,
    the length, *L*, is the only variable on the right side of the equation that doesn’t
    have a constant value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*π*是数学常数*pi*，*g*是局部的重力加速度，地球上的值大约是9.8 m/s²。由于*π*和*g*是常数，长度*L*是方程右边唯一一个没有常数值的变量。
- en: 'If you wanted to see how the time period of a simple pendulum varies with its
    length, you’d assume different values for the length and measure the corresponding
    time period at each of these values using the formula. A typical high school experiment
    is to compare the time period you get using the preceding formula, which is the
    theoretical result, to the one you measure in the laboratory, which is the experimental
    result. For example, let’s choose five different values: 15, 18, 21, 22.5, and
    25 (all expressed in centimeters). With Python, we can write a quick program that’ll
    speed through the calculations for the theoretical results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看一个简单摆的周期如何随其长度变化，你可以假设不同的长度值，并使用公式测量每个这些值对应的周期。一个典型的高中实验是将你用前面的公式得到的周期（理论结果）与实验室测量的周期（实验结果）进行比较。例如，我们选择五个不同的长度值：15、18、21、22.5和25（单位是厘米）。使用Python，我们可以编写一个快速程序来加速理论结果的计算：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We first define the function `time_period` at ➊. This function applies the
    formula shown earlier to a given length, which is passed in as `length`. Then,
    our program defines a set of lengths at ➋ and applies the `time_period` function
    to each value at ➌. Notice that when we pass in the length values to `time_period`,
    we divide them by 100\. This operation converts the lengths from centimeters to
    meters so that they match the unit of gravitational acceleration, which is expressed
    in units of meters/second². Finally, we print the calculated time period. When
    you run the program, you’ll see the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在➊定义了`time_period`函数。这个函数将前面展示的公式应用于给定的长度，长度作为`length`传入。然后，我们的程序在➋定义了一个长度集合，并在➌将`time_period`函数应用于每个值。注意，当我们将长度值传递给`time_period`时，我们将其除以100。这个操作将长度从厘米转换为米，以便与重力加速度的单位（米/秒²）相匹配。最后，我们打印出计算得到的周期。当你运行程序时，你会看到如下输出：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Different Gravity, Different Results**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**不同的重力，不同的结果**'
- en: 'Now, imagine we conducted this experiment in three different places— my current
    location, Brisbane, Australia; the North Pole; and the equator. The force of gravity
    varies slightly depending on the latitude of your location: it’s a bit lower (approximately
    9.78 m/s²) at the equator and higher (9.83 m/s²) at the North Pole. This means
    we can treat the force of gravity as a variable in our formula, rather than a
    constant, and calculate results for three different values of gravitational acceleration:
    {9.8, 9.78, 9.83}.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们在三个不同的地方进行这个实验——我现在的位置，澳大利亚布里斯班；北极；以及赤道。重力的大小会根据你所在纬度略有变化：在赤道稍低（约为9.78
    m/s²），而在北极则较高（9.83 m/s²）。这意味着我们可以把重力看作公式中的一个变量，而不是常数，并根据三个不同的重力加速度值进行计算：{9.8,
    9.78, 9.83}。
- en: 'If we want to calculate the period of a pendulum for each of our five lengths
    at each of these three locations, a systematic way to work out all of these combinations
    of the values is to take the Cartesian product, as shown in the following program:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要计算每个位置的五个不同长度的摆钟周期，可以通过计算这些值的笛卡尔积来系统地得出所有组合，以下程序展示了这一过程：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At ➋, we take the Cartesian product of our two sets of variables, `L` and `g_values`,
    and we iterate through each resulting combination of values to calculate the time
    period. Each combination is represented as a tuple, and for each tuple, we extract
    the first value, the length, at ➌ and the second value, the gravity, at ➍. Then,
    just as before, we call the `time_period()` function with these two labels as
    parameters, and we print the values of length (`l`), gravity (`g`), and the corresponding
    time period (`T`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋，我们取两个变量集`L`和`g_values`的笛卡尔积，然后遍历每一个组合来计算周期。每个组合都表示为一个元组，对于每个元组，我们在➌提取第一个值，即长度，在➍提取第二个值，即重力。然后，就像之前一样，我们调用`time_period()`函数，将这两个标签作为参数传入，并打印出长度（`l`）、重力（`g`）和相应的周期（`T`）值。
- en: The output is presented in a table to make it easy to follow. The table is formatted
    by the `print` statements at ➊ and ➎. The format string `{0:^15} {1:^15}{2:^15.3f}`
    creates three fields, each 15 spaces wide, and the `^` symbol centers each entry
    in each field. In the last field of the `print` statement at ➎, `'.3f'` limits
    the number of digits after the decimal point to three.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以表格的形式呈现，便于查看。表格是通过➊和➎的`print`语句格式化的。格式化字符串`{0:^15} {1:^15}{2:^15.3f}`创建了三个字段，每个字段宽度为15个字符，`^`符号将每个条目居中。在➎的`print`语句的最后一个字段中，`'.3f'`限制小数点后数字的位数为三位。
- en: 'When you run the program, you’ll see the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到如下输出：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This experiment presents a simple scenario where you need all possible combinations
    of the elements of multiple sets (or a group of numbers). In this type of situation,
    the Cartesian product is exactly what you need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验展示了一个简单的场景，在这种情况下，你需要多个集合（或数字组）所有可能的组合。在这种情况下，笛卡尔积正是你所需要的。
- en: '**Probability**'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率**'
- en: 'Sets allow us to reason about the basic concepts of probability. We’ll begin
    with a few definitions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 集合帮助我们推理概率的基本概念。我们将从几个定义开始：
- en: '**Experiment** The *experiment* is simply the test we want to perform. We perform
    the test because we’re interested in the probability of each possible outcome.
    Rolling a die, flipping a coin, and pulling a card from a deck of cards are all
    examples of experiments. A single run of an experiment is referred to as a *trial*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验** *实验*就是我们想要进行的测试。我们进行测试是因为我们对每个可能结果的概率感兴趣。掷骰子、抛硬币和从一副扑克牌中抽牌都是实验的例子。一次实验的单次运行被称为*试验*。'
- en: '**Sample space** All possible outcomes of an experiment form a set known as
    the *sample space*, which we’ll usually call *S* in our formulas. For example,
    when a six-sided die is rolled once, the sample space is {1, 2, 3, 4, 5, 6}.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**样本空间** 所有实验的可能结果构成一个集合，称为*样本空间*，我们通常在公式中称它为*S*。例如，当掷一次六面骰子时，样本空间是{1, 2, 3,
    4, 5, 6}。'
- en: '**Event** An *event* is a set of outcomes that we want to calculate the probability
    of and that form a *subset* of the sample space. For example, we might want to
    know the probability of a particular outcome, like rolling a 3, or the probability
    of a set of multiple outcomes, such as rolling an even number (either 2, 4, or
    6). We’ll use the letter *E* in our formulas to stand for an event.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件** *事件*是我们想要计算概率的结果集合，它是样本空间的一个*子集*。例如，我们可能想知道某个特定结果的概率，比如掷出3，或者多个结果的概率，例如掷出偶数（2、4或6）。我们将在公式中使用字母*E*表示一个事件。'
- en: 'If there’s a *uniform distribution*—that is, if each outcome in the sample
    space is equally likely to occur—then the probability of an event, *P*(*E*), occurring
    is calculated using the following formula (I’ll talk about nonuniform distributions
    a bit later in this chapter):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在*均匀分布*——也就是说，样本空间中的每个结果发生的可能性相等——那么事件*P*(*E*)发生的概率可以使用以下公式计算（稍后我会在本章中讨论非均匀分布）：
- en: '![image](images/e0131-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0131-01.jpg)'
- en: Here, *n*(*E*) and *n*(*S*) are the cardinality of the sets *E*, the event,
    and *S*, the sample space, respectively. The value of *P*(*E*) ranges from 0 to
    1, with higher values indicating a higher chance of the event happening.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*n*(*E*)和*n*(*S*)分别是事件*E*和样本空间*S*的基数。*P*(*E*)的值范围从0到1，较高的值表示事件发生的可能性较大。
- en: 'We can apply this formula to a die roll to calculate the probability of a particular
    roll—say, 3:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用这个公式来计算某个特定掷骰子的概率——比如，掷出3：
- en: '![image](images/e0132-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0132-01.jpg)'
- en: 'This confirms what was obvious all along: the probability of a particular die
    roll is 1/6\. You could easily do this calculation in your head, but we can use
    this formula to write the following function in Python that calculates the probability
    of any event, `event`, in any sample space, `space`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了我们一直以来的直觉：某个特定的掷骰子结果的概率是1/6。你可以轻松地用脑算出这个计算结果，但我们可以使用这个公式在Python中写出以下函数，用来计算任何事件`event`在任何样本空间`space`中的概率：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this function, the two arguments `space` and `event`—the sample space and
    event—need not be sets created using `FiniteSet`. They can also be lists or, for
    that matter, any other Python object that supports the `len()` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，两个参数`space`和`event`——样本空间和事件——不必是通过`FiniteSet`创建的集合。它们也可以是列表，或者任何支持`len()`函数的其他Python对象。
- en: 'Using this function, let’s write a program to find the probability of a prime
    number appearing when a 20-sided die is rolled:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，让我们写一个程序来计算当掷一个20面骰子时，出现质数的概率：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We first create a set representing the sample space, `space`, using the `range()`
    function at ➋. To create the event set, we need to find the prime numbers from
    the sample space, so we define a function, `check_prime()`, at ➊. This function
    takes an integer and checks to see whether it’s divisible (with no remainder)
    by any number between 2 and itself. If so, it returns `False`. Because a prime
    number is only divisible by 1 and itself, this function returns `True` if an integer
    is prime and `False` otherwise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在➋处使用`range()`函数创建一个表示样本空间`space`的集合。为了创建事件集合，我们需要从样本空间中找到质数，因此我们在➊处定义了一个函数`check_prime()`。这个函数接受一个整数并检查它是否能被2到它自身之间的任何数字整除（没有余数）。如果能整除，则返回`False`。因为质数只能被1和它本身整除，所以如果整数是质数，这个函数返回`True`，否则返回`False`。
- en: 'We call this function for each of the numbers in the sample space at ➌ and
    add the prime numbers to a list, `primes`. Then, we create our event set, `event`,
    from this list at ➍. Finally, we call the `probability()` function we created
    earlier. We get the following output when we run the program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➌ 处调用此函数为样本空间中的每个数字生成随机数，并将素数添加到列表 `primes` 中。然后，在 ➍ 处，我们从这个列表中创建事件集合 `event`。最后，我们调用之前创建的
    `probability()` 函数。当我们运行程序时，得到以下输出：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, *n*(*E*) = 8 and *n*(*S*) = 20, so the probability, *P*, is 0.4.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*n*(*E*) = 8，*n*(*S*) = 20，因此概率 *P* 为 0.4。
- en: 'In our 20-sided die program, we really didn’t need to create the sets; instead,
    we could have called the `probability()` function with the sample space and events
    as lists:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 20 面骰子程序中，我们其实不需要创建这些集合；相反，我们可以将样本空间和事件作为列表传递给 `probability()` 函数：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `probability()` function works equally well in this case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`probability()` 函数在这种情况下同样有效。'
- en: '***Probability of Event A or Event B***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事件 A 或事件 B 的概率***'
- en: 'Let’s say we’re interested in two possible events, and we want to find the
    probability of *either* one of them happening. For example, going back to a simple
    die roll, let’s consider the following two events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对两个可能的事件感兴趣，并且想要找到*任意*一个事件发生的概率。例如，回到简单的掷骰子，让我们考虑以下两个事件：
- en: A = The number is a prime number.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: A = 数字是素数。
- en: B = The number is odd.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: B = 数字是奇数。
- en: 'As it was earlier, the sample space, *S*, is {1, 2, 3, 4, 5, 6}. Event A can
    be represented as the subset {2, 3, 5}, the set of prime numbers in the sample
    space, and event B can be represented as {1, 3, 5}, the odd numbers in the sample
    space. To calculate the probability of either set of outcomes, we can find the
    probability of the *union* of the two sets. In our notation, we could say:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，样本空间 *S* 是 {1, 2, 3, 4, 5, 6}。事件 A 可以表示为子集 {2, 3, 5}，即样本空间中的素数集合，事件 B
    可以表示为 {1, 3, 5}，即样本空间中的奇数集合。为了计算任意一个结果集合的概率，我们可以计算两个集合的*并集*的概率。在我们的符号中，我们可以这样表示：
- en: '![image](images/e0133-01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0133-01.jpg)'
- en: 'Now let’s perform this calculation in Python:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用 Python 执行这个计算：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first create a set, `s`, representing the sample space, followed by the two
    sets `a` and `b`. Then, at ➊, we use the `union()` method to find the event set,
    `e`. Finally, we calculate the probability of the union of the two sets using
    the earlier formula.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个集合 `s`，表示样本空间，接着创建两个集合 `a` 和 `b`。然后，在 ➊ 处，我们使用 `union()` 方法来找到事件集合 `e`。最后，我们使用之前的公式计算两个集合的并集的概率。
- en: '***Probability of Event A and Event B***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事件 A 和事件 B 的概率***'
- en: 'Say you have two events in mind and you want to calculate the chances of *both*
    of them happening—for example, the chances that a die roll is both prime and odd.
    To determine this, you calculate the probability of the intersection of the two
    event sets:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个事件，并且想要计算*两者*同时发生的概率——例如，骰子掷点是既是素数又是奇数的概率。要确定这一点，你需要计算两个事件集合的交集的概率：
- en: '*E* = *A* ∩ *B* = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = *A* ∩ *B* = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}'
- en: 'We can calculate the probability of both A and B happening by using the `intersect()`
    method, which is similar to what we did in the previous case:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `intersect()` 方法来计算 A 和 B 同时发生的概率，这与我们在前一个例子中做的类似：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***Generating Random Numbers***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成随机数***'
- en: Probability concepts allow us to reason about and calculate the chance of an
    event happening. To actually simulate such events—like a simple dice game—using
    computer programs, we need a way to generate random numbers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 概率概念让我们能够推理并计算事件发生的概率。为了实际模拟这些事件——比如一个简单的骰子游戏——我们需要一种生成随机数的方法。
- en: '**Simulating a Die Roll**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**模拟骰子掷点**'
- en: 'To simulate a six-sided die roll, we need a way to generate a random integer
    between 1 and 6\. The `random` module in Python’s standard library provides us
    with various functions to generate random numbers. Two functions that we’ll use
    in this chapter are the `randint()` function, which generates a random integer
    in a given range, and the `random()` function, which generates a floating point
    number between 0 and 1\. Let’s see a quick example of how the `randint()` function
    works:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟一个六面骰子的掷点，我们需要一种方法来生成一个 1 到 6 之间的随机整数。Python 标准库中的 `random` 模块提供了多种生成随机数的函数。本章将使用两个函数，`randint()`
    函数，它在给定的范围内生成一个随机整数，以及 `random()` 函数，它生成一个介于 0 和 1 之间的浮动数。让我们看一个 `randint()` 函数如何工作的简短示例：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `randint()` function takes two integers as arguments and returns a random
    integer that falls between these two numbers (both inclusive). In this example,
    we passed in the range `(1, 6)`, and it returned the number 4, but if we call
    it again, we’ll very likely get a different number:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`randint()`函数接受两个整数作为参数，返回介于这两个数字之间的一个随机整数（包括这两个数字）。在这个例子中，我们传入了范围`(1, 6)`，它返回了数字4，但如果我们再次调用它，很可能会得到不同的数字：'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Calling the `randint()` function allows us to simulate the roll of our virtual
    die. Every time we call this function, we’re going to get a number between 1 and
    6, just as we would if we were rolling a six-sided die. Note that `randint()`
    expects you to supply the lower number first, so `randint(6, 1)` isn’t valid.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`randint()`函数可以模拟我们虚拟骰子的掷骰过程。每次调用此函数时，我们都会得到一个介于1和6之间的数字，就像我们在掷一个六面骰子一样。请注意，`randint()`要求你首先提供较小的数字，所以`randint(6,
    1)`是无效的。
- en: '**Can You Roll That Score?**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**你能掷出那个分数吗？**'
- en: 'Our next program will simulate a simple die-rolling game, where we keep rolling
    the six-sided die until we’ve rolled a total of 20:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序将模拟一个简单的掷骰游戏，我们将不断掷六面骰子，直到我们总共掷出20点：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, we define the same `roll()` function we created earlier. Then, we use
    a `while` loop at ➊ to call this function, keep track of the number of rolls,
    print the current roll, and add up the total score. The loop repeats until the
    score reaches 20, and then the program prints the total score and number of rolls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义之前创建的相同的`roll()`函数。然后，在➊处我们使用`while`循环调用此函数，跟踪掷骰次数，打印当前的掷骰结果，并累计总分数。循环会一直进行，直到分数达到20，然后程序会打印总分数和掷骰次数。
- en: 'Here’s a sample run:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次示例运行：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you run the program several times, you’ll notice that the number of rolls
    it takes to reach 20 varies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行该程序，你会注意到，达到20点所需的掷骰次数是不同的。
- en: '**Is the Target Score Possible?**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**目标分数可能吗？**'
- en: 'Our next program is similar, but it’ll tell us whether a certain target score
    is reachable within a maximum number of rolls:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序类似，但它会告诉我们是否能在最大掷骰次数内达到某个目标分数：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you run this program, it asks for the target score and the maximum number
    of allowed rolls as input, and then it prints out the probability of achieving
    that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，它会要求输入目标分数和允许的最大掷骰次数，然后它会打印出达到该目标的概率。
- en: 'Here are two sample executions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个示例执行：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let’s understand the workings of the `find_prob()` function, which performs
    the probability calculation. The sample space here is the Cartesian product, `die_sides`^(`max_rolls`)
    ➊, where `die_sides` is the set {1, 2, 3, 4, 5, 6}, representing the numbers on
    a six-sided die, and `max_rolls` is the maximum number of die rolls allowed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解`find_prob()`函数的工作原理，该函数执行概率计算。这里的样本空间是笛卡尔积，`die_sides`^(`max_rolls`) ➊，其中`die_sides`是集合{1,
    2, 3, 4, 5, 6}，表示六面骰子上的数字，`max_rolls`是允许的最大掷骰次数。
- en: 'The event set is all the sets in the sample space that help us reach this target
    score. There are two cases here: when the number of turns left is greater than
    1 and when we’re in the last turn. For the first case, at ➋, we iterate over each
    of the tuples in the Cartesian product and add the ones that add up to or exceed
    `target_score` in the `success_rolls` list. The second case is special: our sample
    space is just the set {1, 2, 3, 4, 5, 6}, and we have only one throw of the die
    left. If the value of the target score is greater than 6, it isn’t possible to
    achieve it, and we set `success_rolls` to be an empty list at ➌. If however, the
    `target_score` is less than or equal to 6, we iterate over each possible roll
    and add the ones that are greater than or equal to the value of `target_score`
    at ➍.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事件集是样本空间中所有有助于我们达到目标分数的集合。这里有两种情况：当剩余的掷骰次数大于1时，以及当我们进入最后一次掷骰时。对于第一种情况，在➋处，我们遍历笛卡尔积中的每个元组，将那些总和等于或超过`target_score`的元组加入`success_rolls`列表。第二种情况是特殊的：我们的样本空间只有{1,
    2, 3, 4, 5, 6}这一集合，并且我们只剩下一次掷骰机会。如果目标分数大于6，则无法实现，且我们会在➌处将`success_rolls`设置为空列表。然而，如果`target_score`小于或等于6，我们会遍历每个可能的掷骰结果，并在➍处将那些大于或等于`target_score`的结果加入列表。
- en: At ➎, we calculate the event set, `e`, from the `success_rolls` list that we
    constructed earlier and then return the probability of reaching the target score.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎处，我们从之前构建的`success_rolls`列表中计算出事件集`e`，然后返回达到目标分数的概率。
- en: '***Nonuniform Random Numbers***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非均匀随机数***'
- en: Our discussions of probability have so far assumed that each of the outcomes
    in the sample space is equally likely. The `random.randint()` function, for example,
    returns an integer in the specified range assuming that each integer is *equally
    likely*. We refer to such probability as *uniform probability* and to random numbers
    generated by the `randint()` function as *uniform random numbers*. Let’s say,
    however, that we want to simulate a biased coin toss—a loaded coin for which heads
    is twice as likely to occur as tails. We’d then need a way to generate *nonuniform*
    random numbers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对概率的讨论至今假设样本空间中的每个结果都是等可能的。例如，`random.randint()` 函数返回一个指定范围内的整数，假设每个整数的出现是*等可能的*。我们将这种概率称为*均匀概率*，并将通过
    `randint()` 函数生成的随机数称为*均匀随机数*。但是，假设我们要模拟一个偏向的硬币投掷——一个加重的硬币，正面出现的概率是反面的两倍。那么，我们就需要一种生成*不均匀*随机数的方法。
- en: Before we write the program to do so, we’ll review the idea behind it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写程序之前，我们先回顾一下其背后的思想。
- en: Consider a number line with a length of 1 and with two equally divided intervals,
    as shown in [Figure 5-1](ch05.html#ch5fig1).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个长度为 1 的数轴，分成两个相等的区间，如 [图 5-1](ch05.html#ch5fig1) 所示。
- en: '![image](images/f05-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-01.jpg)'
- en: '*Figure 5-1: A number line with a length of 1 divided into two equal intervals
    corresponding to the probability of heads or tails on a coin toss*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：一个长度为 1 的数轴，分成两个相等的区间，分别对应于硬币投掷时正面或反面的概率*'
- en: We’ll refer to this line as the *probability number line*, with each division
    representing an equally possible outcome—for example, heads or tails upon a fair
    coin toss. Now, in [Figure 5-2](ch05.html#ch5fig2), consider a different version
    of this number line.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这条线称为*概率数轴*，其中每个分割代表一个等可能的结果——例如，公正硬币投掷时的正面或反面。现在，在 [图 5-2](ch05.html#ch5fig2)
    中，考虑这个不同版本的数轴。
- en: '![image](images/f05-02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-02.jpg)'
- en: '*Figure 5-2: A number line with a length of 1 divided into two unequal intervals
    corresponding to the probability of heads or tails on a biased coin toss*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：一个长度为 1 的数轴，分成两个不相等的区间，分别对应于偏向的硬币投掷中正面或反面的概率*'
- en: 'Here, the division corresponding to heads is 2/3 of the total length and the
    division corresponding to tails is 1/3\. This represents the situation of a coin
    that’s likely to turn up heads in 2/3 of tosses and tails only in 1/3 of tosses.
    The following Python function will simulate such a coin toss, considering this
    unequal probability of heads or tails appearing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，正面对应的分割是总长度的 2/3，反面对应的分割是 1/3。这表示在 2/3 的投掷中，硬币更可能出现正面，而在 1/3 的投掷中则更可能出现反面。以下
    Python 函数将模拟这种硬币投掷，考虑到正面或反面出现的不均匀概率：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We assume that the function returns 0 to indicate heads and 1 to indicate tails,
    and then we generate a random number between 0 and 1 at ➊ using the `random.random()`
    function. If the generated number is less than 2/3—the probability of flipping
    heads with our biased coin—the program returns 0; otherwise it returns 1 (tails).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设函数返回 0 表示正面，1 表示反面，然后在 ➊ 处使用 `random.random()` 函数生成一个介于 0 和 1 之间的随机数。如果生成的数字小于
    2/3——我们偏向硬币投掷时正面的概率——程序返回 0；否则返回 1（反面）。
- en: We’ll now see how we can extrapolate the preceding function to simulate a nonuniform
    event with multiple possible outcomes. Let’s consider a fictional ATM that dispenses
    a $5, $10, $20, or $50 bill when its button is pressed. The different denominations
    have varying probabilities of being dispensed, as shown in [Figure 5-3](ch05.html#ch5fig3).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何将前述函数推广，用于模拟具有多个可能结果的非均匀事件。假设我们有一台虚拟的自动取款机，当按下按钮时，它会发放 $5、$10、$20
    或 $50 美元的钞票。这些不同面额的钞票有不同的发放概率，如 [图 5-3](ch05.html#ch5fig3) 所示。
- en: '![image](images/f05-03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-03.jpg)'
- en: '*Figure 5-3: A number line with a length of 1 divided into four intervals of
    different lengths corresponding to the probability of dispensing bills of different
    denominations*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：一个长度为 1 的数轴，分成四个不同长度的区间，分别对应于发放不同面额钞票的概率*'
- en: Here, the probability of a $5 bill or $10 bill being dispensed is 1/6, and the
    probability of a $20 bill or $50 bill being dispensed is 1/3.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，$5 或 $10 美元钞票被发放的概率是 1/6，而 $20 或 $50 美元钞票被发放的概率是 1/3。
- en: 'We create a list to store the rolling sum of the probabilities, and then we
    generate a random number between 0 and 1\. We start from the left end of the list
    that stores the sum and return the first index of this list for which the corresponding
    sum is lesser than or equal to the random number generated. The `get_index()`
    function implements this idea:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个列表来存储概率的滚动和，然后生成一个0到1之间的随机数。我们从存储和的列表的左端开始，并返回该列表中第一个元素，其对应的和小于或等于生成的随机数。`get_index()`函数实现了这个思路：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We call the `get_index()` function with a list containing the probability that
    the event in the corresponding position is expected to occur. We then, at ➊, construct
    the list `sum_probability`, where the `i`th element is the sum of the first `i`
    elements in the list `probability`. That is, the first element in `sum_probability`
    is equal to the first element in `probability`, the second element is equal to
    the sum of the first two elements in `probability`, and so on. At ➋, a random
    number between 0 and 1 is generated using the label `r`. Next, at ➌, we traverse
    through `sum_probability` and return the index of the first element that exceeds
    `r`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`get_index()`函数，传入一个包含相应位置事件发生概率的列表。然后，在 ➊ 处构建列表`sum_probability`，其中第`i`个元素是列表`probability`中前`i`个元素的和。也就是说，`sum_probability`中的第一个元素等于`probability`中的第一个元素，第二个元素等于`probability`中前两个元素的和，以此类推。在
    ➋ 处，使用标签`r`生成一个0到1之间的随机数。接下来，在 ➌ 处，我们遍历`sum_probability`并返回第一个超过`r`的元素的索引。
- en: The last line of the function, at ➍, takes care of a special case best illustrated
    through an example. Consider a list of three events with percentages of occurrence
    each expressed as 0.33\. In this case, the list `sum_probability` would look like
    `[0.33, 0.66, 0.99]`. Now, consider that the random number generated, `r`, is
    `0.99314`. For this value of `r`, we want the last element in the list of events
    to be chosen. You may argue that this isn’t exactly right because the last event
    has a higher than 33 percent chance of being selected. As per the condition at
    ➌, there’s no element in `sum_probability` that’s greater than `r`; hence, the
    function wouldn’t return any index at all. The statement at ➍ takes care of this
    and returns the last index.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一行，在 ➍ 处，处理了一个特殊情况，最好通过一个例子来说明。考虑一个包含三个事件的列表，每个事件的发生概率为0.33。在这种情况下，列表`sum_probability`看起来像`[0.33,
    0.66, 0.99]`。现在，假设生成的随机数`r`是`0.99314`。对于这个`r`值，我们希望选择事件列表中的最后一个元素。你可能会争辩说，这并不完全正确，因为最后一个事件的选择概率超过了33%。根据
    ➌ 处的条件，`sum_probability`中没有大于`r`的元素，因此函数不会返回任何索引。 ➍处的语句处理了这个问题并返回了最后一个索引。
- en: If you call the `dispense()` function to simulate a large number of dollar bills
    disbursed by the ATM, you’ll see that the ratio of the number of times each bill
    appears closely obeys the probability specified. We’ll find this technique useful
    when creating *fractals* in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用`dispense()`函数来模拟ATM机发放大量纸币，你会看到每种纸币出现的次数比例与指定的概率紧密遵循。我们将在下一章中创建*分形*时发现这个技巧非常有用。
- en: '**What You Learned**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started by learning how to represent a set in Python. Then,
    we discussed the various set concepts and you learned about the union, the intersection,
    and the Cartesian product of sets. You applied some of the set concepts to explore
    the basics of probability and, finally, learned how to simulate uniform and nonuniform
    random events in your programs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了如何在Python中表示集合。然后，我们讨论了各种集合概念，你学习了集合的并集、交集和笛卡尔积。你将一些集合概念应用于探索概率的基础知识，并最终学习了如何在程序中模拟均匀和非均匀的随机事件。
- en: '**Programming Challenges**'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Next, you have a few programming challenges to solve that’ll give you the opportunity
    to apply what you’ve learned in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将解决一些编程挑战，这些挑战将为你提供应用本章所学内容的机会。
- en: '***#1: Using Venn Diagrams to Visualize Relationships Between Sets***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 使用维恩图可视化集合之间的关系***'
- en: 'A *Venn diagram* is an easy way to see the relationship between sets graphically.
    It tells us how many elements are common between the two sets, how many elements
    are only in one set, and how many elements are in neither set. Consider a set,
    *A*, that represents the set of positive odd numbers less than 20—that is, *A*
    = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}—and consider another set, *B*, that represents
    the set of prime numbers less than 20—that is, *B* = {2, 3, 5, 7, 11, 13, 17,
    19}. We can draw Venn diagrams with Python using the `matplotlib_venn` package
    (see [Appendix A](app01.html#app01) for installation instructions for this package).
    Once you’ve installed it, you can draw the Venn diagram as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*维恩图*是查看集合关系的一种简单方式，它以图形的形式告诉我们两个集合之间有多少共同元素，有多少元素只存在于一个集合中，以及有多少元素不属于任何集合。考虑集合*A*，它表示小于20的正奇数，即*A*
    = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}；再考虑集合*B*，它表示小于20的质数，即*B* = {2, 3, 5, 7,
    11, 13, 17, 19}。我们可以使用Python的`matplotlib_venn`包绘制维恩图（有关该包的安装说明，请参见[附录A](app01.html#app01)）。安装完成后，可以按如下方式绘制维恩图：'
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once we import all the required modules and functions (the `venn2()` function,
    `matplotlib.pyplot`, and the `FiniteSet` class), all we have to do is create the
    two sets and then call the `venn2()` function, using the `subsets` key-word argument
    to specify the sets as a tuple.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了所有必需的模块和函数（`venn2()`函数、`matplotlib.pyplot`以及`FiniteSet`类），我们所需要做的就是创建这两个集合，然后调用`venn2()`函数，使用`subsets`关键字参数将集合作为元组指定。
- en: '[Figure 5-4](ch05.html#ch5fig4) shows the Venn diagram created by the preceding
    program. The sets *A* and *B* share seven common elements, so 7 is written in
    the common area. Each of the sets also has unique elements, so the number of unique
    elements—3 and 1, respectively—is written in the individual areas. The labels
    below the two sets are shown as *A* and *B*. You can specify your own labels using
    the `set_labels` keyword argument:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.html#ch5fig4)展示了前述程序创建的维恩图。集合*A*和*B*共享七个共同元素，因此数字7被写在共同区域内。每个集合也都有独特的元素，因此唯一元素的数量——分别为3和1——被写在各自的独立区域内。两个集合下方的标签显示为*A*和*B*。你可以使用`set_labels`关键字参数指定自己的标签：'
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This would change the set labels to `S` and `T`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把集合标签更改为`S`和`T`。
- en: '![image](images/f05-04.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-04.jpg)'
- en: '*Figure 5-4: Venn diagram showing the relationship between two sets*, A *and*
    B'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：展示两个集合A和B之间关系的维恩图*'
- en: 'For your challenge, imagine you’ve created an online questionnaire asking your
    classmates the following question: *Do you play football, another sport, or no
    sports?* Once you have the results, create a CSV file, *sports.csv*, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你的挑战，假设你已经创建了一个在线问卷，询问你的同学以下问题：*你玩足球、其他运动，还是不玩运动？* 一旦你得到结果，创建一个CSV文件，*sports.csv*，如下所示：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Create 20 such rows for the 20 students in your class. The first column is the
    student ID (the survey isn’t anonymous), the second column has a 1 if the student
    has marked “football” as the sport they love to play, and the third column has
    a 1 if the student plays any other sport or none at all. Write a program to create
    a Venn diagram to depict the summarized results of the survey, as shown in [Figure
    5-5](ch05.html#ch5fig5).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的班级中的20个学生创建20行数据。第一列是学生ID（该调查并非匿名），第二列为1表示该学生标记了“足球”作为他们喜欢的运动，第三列为1表示该学生玩其他运动或根本不玩任何运动。编写程序创建一个维恩图，以显示调查结果的汇总，如[图
    5-5](ch05.html#ch5fig5)所示。
- en: '![image](images/f05-05.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-05.jpg)'
- en: '*Figure 5-5: A Venn diagram showing the number of students who love to play
    football and the number who love to play other sports*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：展示喜欢踢足球的学生人数与喜欢其他运动的学生人数的维恩图*'
- en: 'Depending on the data in the *sports.csv* file you created, the numbers in
    each set will vary. The following function reads a CSV file and returns two lists
    corresponding to the IDs of those students who play football and other sports:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你创建的*sports.csv*文件中的数据，每个集合中的数字将有所不同。以下函数读取CSV文件，并返回两个列表，对应于那些玩足球和其他运动的学生ID：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***#2: Law of Large Numbers***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2：大数法则***'
- en: 'We’ve referred to a die roll and coin toss as two examples of random events
    that we can simulate using random numbers. We’ve used the term *event* to refer
    to a certain number showing up on a die roll or to heads or tails showing up on
    a coin toss, with each event having an associated probability value. In probability,
    a *random variable*—usually denoted by *X*—describes an event. For example, *X*
    = 1 describes the event of 1 appearing upon a die roll, and *P*(*X* = 1) describes
    the associated probability. There are two kinds of random variables: (1) *discrete*
    random variables, which take only integral values and are the only kind of random
    variables we see in this chapter, and (2) *continuous* random variables, which—as
    the name suggests—can take any real value.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过掷骰子和掷硬币作为两个可以通过随机数模拟的随机事件的例子。我们使用“事件”这个术语来表示在掷骰子时出现的某个数字，或者在掷硬币时出现的正面或反面，每个事件都有一个关联的概率值。在概率论中，*随机变量*——通常表示为*X*——描述了一个事件。例如，*X*
    = 1描述了掷骰子时出现1的事件，而*P*(*X* = 1)描述了关联的概率。随机变量有两种类型：（1）*离散*随机变量，它们只取整数值，并且是我们在本章中看到的唯一类型的随机变量；（2）*连续*随机变量，正如其名所示，它们可以取任何实数值。
- en: 'The *expectation*, *E*, of a discrete random variable is the equivalent of
    the average or mean that we learned about in [Chapter 3](ch03.html#ch03). The
    expectation can be calculated as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 离散随机变量的*期望*，*E*，相当于我们在[第3章](ch03.html#ch03)学到的平均值或均值。期望值可以按以下方式计算：
- en: '*E* = *x*[1]*P*(*x*[1]) + *x*[2]*P*(*x*[2]) + *x*[3]*P*(*x*[3]) + ... + *x[n]P*(*x[n]*)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = *x*[1]*P*(*x*[1]) + *x*[2]*P*(*x*[2]) + *x*[3]*P*(*x*[3]) + ... + *x[n]*P*(*x[n]*)'
- en: 'Thus, for a six-sided die, the *expected value* of a die roll can be calculated
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于一个六面骰子，掷骰子的*期望值*可以像这样计算：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'According to the *law of large numbers*, the average value of results over
    multiple trials approaches the expected value as the number of trials increases.
    Your challenge in this task is to verify this law when rolling a six-sided die
    for the following number of trials: 100, 1000, 10000, 100000, and 500000\. Here’s
    an expected sample run of your complete program:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*大数法则*，经过多次试验后的结果的平均值会随着试验次数的增加而趋近于期望值。你在这个任务中的挑战是验证这个法则，模拟掷六面骰子时在以下试验次数下的情况：100次、1000次、10000次、100000次和500000次。以下是你完整程序的一个预期运行示例：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***#3: How Many Tosses Before You Run Out of Money?***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3：在你没钱之前需要多少次掷硬币？***'
- en: 'Let’s consider a simple game played with a fair coin toss. A player wins $1
    for heads and loses $1.50 for tails. The game is over when the player’s balance
    reaches $0\. Given a certain starting amount specified by the user as input, your
    challenge is to write a program that simulates this game. Assume there’s an unlimited
    cash reserve with the computer—your opponent here. Here’s a possible game play
    session:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的公平掷硬币的游戏。玩家掷到正面时赢得$1，掷到反面时损失$1.50。当玩家的余额达到$0时，游戏结束。给定用户指定的初始金额，你的挑战是编写一个程序来模拟这个游戏。假设计算机有一个无限的现金储备——它是你的对手。以下是一个可能的游戏过程：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***#4: Shuffling a Deck of Cards***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4：洗牌一副扑克牌***'
- en: Consider a standard deck of 52 playing cards. Your challenge here is to write
    a program to simulate the shuffling of this deck. To keep the implementation simple,
    I suggest you use the integers 1, 2, 3, ..., 52 to represent the deck. Every time
    you run the program, it should output a shuffled deck—in this case, a shuffled
    list of integers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一副标准的52张扑克牌。你的挑战是编写一个程序来模拟这副牌的洗牌过程。为了保持实现简单，我建议你使用整数1、2、3、...、52来表示这副牌。每次运行程序时，它应该输出一副洗过的牌——在这个例子中，是一组洗过的整数列表。
- en: 'Here’s a possible output of your program:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你程序的一个可能输出：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `random` module in Python’s standard library has a function, `shuffle()`,
    for this exact operation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`random`模块有一个函数`shuffle()`，用于执行这个操作：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a list, `x`, consisting of the numbers [1, 2, 3, 4]. Then, call the `shuffle()`
    function ➊, passing this list as an argument. You’ll see that the numbers in `x`
    have been shuffled. Note that the list is shuffled “in place.” That is, the original
    order is lost.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表`x`，包含数字[1, 2, 3, 4]。然后，调用`shuffle()`函数 ➊，将这个列表作为参数传入。你会看到列表`x`中的数字已经被洗牌。请注意，列表是“就地洗牌”的，也就是说，原始顺序丢失了。
- en: 'But what if you wanted to use this program in a card game? There, it’s not
    enough to simply output the shuffled list of integers. You’ll also need a way
    to map back the integers to the specific suit and rank of each card. One way you
    might do this is to create a Python class to represent a single card:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想在卡片游戏中使用这个程序呢？在游戏中，仅仅输出打乱后的整数列表是不够的。你还需要一种方法将整数映射回每张卡片的具体花色和点数。你可以通过创建一个Python类来表示一张卡片来实现这一点：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To represent the ace of clubs, create a card object, `card1 = Card(''clubs'',
    ''ace'')`. Then, do the same for all the other cards. Next, create a list consisting
    of each of the card objects and shuffle this list. The result will be a shuffled
    deck of cards where you also know the suit and rank of each card. Output of the
    program should look something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示梅花 A，创建一个卡片对象`card1 = Card('clubs', 'ace')`。然后，对其他所有卡片进行相同的操作。接着，创建一个包含每个卡片对象的列表并打乱这个列表。程序的输出应该类似于这样：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***#5: Estimating the Area of a Circle***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5: 估算圆的面积***'
- en: Consider a dartboard with a circle of radius *r* inscribed in a square with
    side 2*r*. Now let’s say you start throwing a large number of darts at it. Some
    of these will hit the board within the circle—let’s say, *N*—and others outside
    it—let’s say, *M*. If we consider the fraction of darts that land inside the circle,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个飞镖板，半径为* r *的圆内切于边长为2*r*的正方形中。现在假设你开始向其投掷大量飞镖。一部分飞镖会击中圆内——假设为*N*，而另一部分会落在圆外——假设为*M*。如果我们考虑落在圆内的飞镖的比例，
- en: '![image](images/e0145-01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0145-01.jpg)'
- en: then the value of *f* × *A*, where *A* is the area of the square, would roughly
    be equal to the area of the circle (see [Figure 5-6](ch05.html#ch5fig6)). The
    darts are represented by the small circular dots in the figure. We shall refer
    to the value of *f* × *A* as the estimated area. The actual area is, of course,
    *πr*².
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 那么*f* × *A*的值，其中*A*是正方形的面积，将大致等于圆的面积（参见[图 5-6](ch05.html#ch5fig6)）。飞镖在图中由小圆点表示。我们将*f*
    × *A*的值称为估算面积。实际的面积当然是*πr*²。
- en: '![image](images/f05-06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f05-06.jpg)'
- en: '*Figure 5-6: A circle of radius* r *inscribed in a square board with side 2*r*.
    The dots represent darts randomly thrown at the board.*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：一个半径为* r *的圆内切于边长为 2*r* 的正方形板上。点表示随机投掷在板上的飞镖。*'
- en: 'As part of this challenge, write a program that will find the estimated area
    of a circle, given any radius, using this approach. The program should print the
    estimated area of the circle for three different values of the number of darts:
    10³, 10⁵, and 10⁶. That’s a lot of darts! You’ll see that increasing the number
    of darts brings the estimated area close to the actual area. Here’s a sample output
    of the completed solution:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本次挑战的一部分，编写一个程序，给定任意半径，使用这种方法估算圆的面积。程序应该打印出三种不同飞镖数量的圆的估算面积：10³、10⁵ 和 10⁶。那可是很多飞镖！你会发现，增加飞镖数量会使估算面积越来越接近实际面积。以下是完成解决方案的示例输出：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The dart throw can be simulated by a call to the `random.uniform(a, b)` function,
    which will return a random number between *a* and *b*. In this case, use the values
    *a* = 0, *b* = 2*r* (the side of the square).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷飞镖可以通过调用`random.uniform(a, b)`函数来模拟，该函数将返回一个介于*a*和*b*之间的随机数。在此案例中，*a* = 0，*b*
    = 2*r*（正方形的边长）。
- en: '**Estimating the Value of Pi**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**估算π的值**'
- en: Consider [Figure 5-6](ch05.html#ch5fig6) once again. The area of the square
    is 4*r*², and the area of the inscribed circle is *πr*². If we divide the area
    of the circle by the area of the square, we get *π*/4\. The fraction *f* that
    we calculated earlier,
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑[图 5-6](ch05.html#ch5fig6)。正方形的面积是4*r*²，内切圆的面积是*πr*²。如果我们将圆的面积除以正方形的面积，就得到*π*/4。我们之前计算出的比例*f*，
- en: '![image](images/e0147-01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0147-01.jpg)'
- en: is thus an approximation of *π*/4, which in turn means that the value of
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是*π*/4的近似值，这也意味着
- en: '![image](images/e0147-02.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0147-02.jpg)'
- en: should be close to the value of *π*. Your next challenge is to write a program
    that will estimate the value of *π* assuming any value for the radius. As you
    increase the number of darts, the estimated value of *π* should get close to the
    known value of the constant.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值应该接近*π*的值。你接下来的挑战是编写一个程序，假设半径为任意值，来估算*π*的值。当你增加投掷飞镖的数量时，估算的*π*值应该接近已知的常数值。
