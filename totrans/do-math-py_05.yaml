- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Playing with Sets and Probability**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll start by learning how we can make our programs understand
    and manipulate sets of numbers. We’ll then see how sets can help us understand
    basic concepts in probability. Finally, we’ll learn about generating random numbers
    to simulate random events. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: '**What’s a Set?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *set* is a collection of distinct objects, often called *elements* or *members*.
    Two characteristics of a set make it different from just any collection of objects.
    A set is “well defined,” meaning the question “Is a particular object in this
    collection?” always has a clear yes or no answer, usually based on a rule or some
    given criteria. The second characteristic is that no two members of a set are
    the same. A set can contain anything—numbers, people, things, words, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through some basic properties of sets as we learn how to work with
    sets in Python using SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: '***Set Construction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In mathematical notation, you represent a set by writing the set members enclosed
    in curly brackets. For example, {2, 4, 6} represents a set with 2, 4, and 6 as
    its members. To create a set in Python, we can use the `FiniteSet` class from
    the `sympy` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first import the `FiniteSet` class from SymPy and then create an object
    of this class by passing in the set members as arguments. We assign the label
    `s` to the set we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store different types of numbers—including integers, floating point
    numbers, and fractions—in the same set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The *cardinality* of a set is the number of members in the set, which you can
    find by using the `len()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Checking Whether a Number Is in a Set**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To check whether a number is a member of an existing set, use the `in` operator.
    This operator asks Python, “Is this number in this set?” It returns `True` if
    the number belongs to the set and `False` if it doesn’t. If, for example, we wanted
    to check whether 4 was in the previous set, we’d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because 4 is not present in the set, the operator returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an Empty Set**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to make an *empty set*, which is a set that doesn’t have any elements
    or members, create a `FiniteSet` object without passing any arguments. The result
    is an `EmptySet` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating Sets from Lists or Tuples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can also create a set by passing in a list or a tuple of set members as
    an argument to `FiniteSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of passing in the set members directly to `FiniteSet`, we first
    stored them in a list, which we called `members`. Then, we passed the list to
    `FiniteSet` using this special Python syntax, which basically translates to creating
    a `FiniteSet` object that passes the list members as separate arguments and not
    as a list. That is, this approach to creating a `FiniteSet` object is equivalent
    to `FiniteSet(1, 2, 3)`. We will make use of this syntax when the set members
    are computed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set Repetition and Order**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sets in Python (like mathematical sets) ignore any repeats of a member, and
    they don’t keep track of the order of set members. For example, if you create
    a set from a list that has multiple instances of a number, the number is added
    to the set only once, and the other instances are discarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, even though we passed in a list that had two instances of the number 2,
    the number 2 appears only once in the set created from that list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python lists and tuples, each element is stored in a particular order, but
    the same is not always true for sets. For example, we can print out each member
    of a set by iterating through it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you run this code, the elements could be printed in any possible order.
    This is because of how sets are stored by Python—it keeps track of what members
    are in the set, but it doesn’t keep track of any particular order for those members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see another example. Two sets are *equal* when they have the same elements.
    In Python, you can use the equality operator, `==`, to check whether two sets
    are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although the members of these two sets appear in different orders, the sets
    are still equal.
  prefs: []
  type: TYPE_NORMAL
- en: '***Subsets, Supersets, and Power Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A set, *s*, is a *subset* of another set, *t*, if all the members of *s* are
    also members of *t*. For example, the set {1} is a subset of the set {1, 2}. You
    can check whether a set is a subset of another set using the `is_subset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that an empty set is a subset of every set. Also, any set is a subset
    of itself, as you can see in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, a set, *t*, is said to be a *superset* of another set, *s*, if *t*
    contains all of the members contained in *s*. You can check whether one set is
    a superset of another using the `is_superset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The *power set* of a set, *s*, is the set of all possible subsets of *s*. Any
    set, *s*, has precisely 2^(|*s*|) subsets, where |*s*| is the cardinality of the
    set. For example, the set {1, 2, 3} has a cardinality of 3, so it has 2³ or 8
    subsets: {} (the empty set), {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3}, and {1, 2,
    3}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of all these subsets form the power set, and we can find the power
    set using the `powerset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As the power set is a set itself, you can find its cardinality using the `len()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The cardinality of the power set is 2^(|*s*|), which is 2³ = 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our definition of a subset, any two sets with the exact same members
    would be subsets as well as supersets of each other. By contrast, a set, *s*,
    is a *proper subset* of *t* only if all the members of *s* are also in *t* and
    *t* has at least one member that is not in *s*. So if *s* = {1, 2, 3}, it’s only
    a proper subset of *t* if *t* contains 1, 2, and 3 plus at least one more member.
    This would also mean that *t* is a *proper superset* of *s*. You can use the `is_proper_subset()`
    method and the `is_proper_superset()` method to check for these relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we re-create the set `t` to include another member, `s` will be considered
    a proper subset of `t` and `t` a proper superset of `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**COMMON NUMBER SETS**'
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter, we learned that there are different kinds of numbers—
    integers, floating point numbers, fractions, and complex numbers. All these numbers
    form different sets of numbers, which have special names.
  prefs: []
  type: TYPE_NORMAL
- en: All positive and negative whole numbers form the set of *integers*. All positive
    integers form the set of *natural numbers* (sometimes 0 is included in this set
    of numbers even though it’s not positive, but sometimes not). This means the set
    of natural numbers is a proper subset of the set of integers.
  prefs: []
  type: TYPE_NORMAL
- en: The set of *rational numbers* includes any number that can be expressed as a
    fraction, which includes all integers, plus any number with a decimal ending that
    terminates or repeats (including numbers like 1/4 or 0.25, and 1/3 or 0.33333
    ...). By contrast, nonrepeating, nonterminating decimal numbers are known as *irrational
    numbers*. The square root of 2 and *π* are both examples of irrational numbers
    because they go on forever without repeating.
  prefs: []
  type: TYPE_NORMAL
- en: If you put together all the rational and irrational numbers, you get the set
    of *real numbers*. But even larger than that is the set of *complex numbers*,
    which includes all real numbers and all numbers with an imaginary component.
  prefs: []
  type: TYPE_NORMAL
- en: All of these sets of numbers are infinite sets because they have infinite members.
    In contrast, the sets we’ve discussed in this chapter have a finite number of
    members, which is why the SymPy class we’re using is called `FiniteSet`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Set Operations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Set operations such as union, intersection, and the Cartesian product allow
    you to combine sets in certain methodical ways. These set operations are extremely
    useful in real-world problem-solving situations when we have to consider multiple
    sets together. Later in this chapter, we’ll see how to use these operations to
    apply a formula to multiple sets of data and calculate the probabilities of random
    events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Union and Intersection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *union* of two sets is a set that contains all of the *distinct* members
    of the two sets. In set theory, we use the symbol ∪ to refer to the union operation.
    For example, {1, 2} ∪ {2, 3} will result in a new set, {1, 2, 3}. In SymPy, the
    union of these two sets can be created using the `union()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We find the union of `s` and `t` by applying the `union` method to `s` and passing
    in `t` as an argument. The result is a third set with all the distinct members
    of the two sets. In other words, each member of this third set is a member of
    one or both of the first two sets.
  prefs: []
  type: TYPE_NORMAL
- en: The *intersection* of two sets creates a new set from the elements common to
    both sets. For example, the intersection of the sets {1, 2} and {2, 3} will result
    in a new set with the only common element, {2}. Mathematically, this operation
    is written as {1, 2} ∩ {2, 3}.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SymPy, use the `intersect()` method to find the intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the union operation finds members that are in one set *or* another,
    the intersection operation finds elements that are present in both. Both of these
    operations can also be applied to more than two sets. For example, here’s how
    you’d find the union of three sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here’s how you’d find the intersection of three sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The intersection of the sets `s`, `t`, and `u` turns out to be an empty set
    because there are no elements that all three sets share.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cartesian Product**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *Cartesian product* of two sets creates a set that consists of all possible
    pairs made by taking an element from each set. For example, the Cartesian product
    of the sets {1, 2} and {3, 4} is {(1, 3), (1, 4), (2, 3), (2, 4)}. In SymPy, you
    can find the Cartesian product of two sets by simply using the multiplication
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes the Cartesian product of the sets `s` and `t` and stores it as `p`.
    To actually see each pair in that Cartesian product, we can iterate through and
    print them out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each element of the product is a tuple consisting of a member from the first
    set and a member from the second set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cardinality of the Cartesian product is the product of the cardinality
    of the individual sets. We can demonstrate this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we apply the exponential operator (`**`) to a set, we get the Cartesian product
    of that set times itself the specified number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, for example, we raised the set `s` to the power of 3\. Because we’re
    taking the Cartesian product of three sets, this gives us a set of all possible
    triplets that contain a member of each set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finding the Cartesian product of sets is useful for finding all possible combinations
    of the set members, which we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying a Formula to Multiple Sets of Variables**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider a simple pendulum of length *L*. The *time period*, *T*, of this pendulum—that
    is, the amount of time it takes for the pendulum to complete one full swing—is
    given by the formula
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0129-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *π* is the mathematical constant, *pi*, and *g* is the local gravitational
    acceleration, which is around 9.8 m/s² on Earth. Because *π* and *g* are constants,
    the length, *L*, is the only variable on the right side of the equation that doesn’t
    have a constant value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to see how the time period of a simple pendulum varies with its
    length, you’d assume different values for the length and measure the corresponding
    time period at each of these values using the formula. A typical high school experiment
    is to compare the time period you get using the preceding formula, which is the
    theoretical result, to the one you measure in the laboratory, which is the experimental
    result. For example, let’s choose five different values: 15, 18, 21, 22.5, and
    25 (all expressed in centimeters). With Python, we can write a quick program that’ll
    speed through the calculations for the theoretical results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define the function `time_period` at ➊. This function applies the
    formula shown earlier to a given length, which is passed in as `length`. Then,
    our program defines a set of lengths at ➋ and applies the `time_period` function
    to each value at ➌. Notice that when we pass in the length values to `time_period`,
    we divide them by 100\. This operation converts the lengths from centimeters to
    meters so that they match the unit of gravitational acceleration, which is expressed
    in units of meters/second². Finally, we print the calculated time period. When
    you run the program, you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Different Gravity, Different Results**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, imagine we conducted this experiment in three different places— my current
    location, Brisbane, Australia; the North Pole; and the equator. The force of gravity
    varies slightly depending on the latitude of your location: it’s a bit lower (approximately
    9.78 m/s²) at the equator and higher (9.83 m/s²) at the North Pole. This means
    we can treat the force of gravity as a variable in our formula, rather than a
    constant, and calculate results for three different values of gravitational acceleration:
    {9.8, 9.78, 9.83}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to calculate the period of a pendulum for each of our five lengths
    at each of these three locations, a systematic way to work out all of these combinations
    of the values is to take the Cartesian product, as shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At ➋, we take the Cartesian product of our two sets of variables, `L` and `g_values`,
    and we iterate through each resulting combination of values to calculate the time
    period. Each combination is represented as a tuple, and for each tuple, we extract
    the first value, the length, at ➌ and the second value, the gravity, at ➍. Then,
    just as before, we call the `time_period()` function with these two labels as
    parameters, and we print the values of length (`l`), gravity (`g`), and the corresponding
    time period (`T`).
  prefs: []
  type: TYPE_NORMAL
- en: The output is presented in a table to make it easy to follow. The table is formatted
    by the `print` statements at ➊ and ➎. The format string `{0:^15} {1:^15}{2:^15.3f}`
    creates three fields, each 15 spaces wide, and the `^` symbol centers each entry
    in each field. In the last field of the `print` statement at ➎, `'.3f'` limits
    the number of digits after the decimal point to three.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program, you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This experiment presents a simple scenario where you need all possible combinations
    of the elements of multiple sets (or a group of numbers). In this type of situation,
    the Cartesian product is exactly what you need.
  prefs: []
  type: TYPE_NORMAL
- en: '**Probability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets allow us to reason about the basic concepts of probability. We’ll begin
    with a few definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Experiment** The *experiment* is simply the test we want to perform. We perform
    the test because we’re interested in the probability of each possible outcome.
    Rolling a die, flipping a coin, and pulling a card from a deck of cards are all
    examples of experiments. A single run of an experiment is referred to as a *trial*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sample space** All possible outcomes of an experiment form a set known as
    the *sample space*, which we’ll usually call *S* in our formulas. For example,
    when a six-sided die is rolled once, the sample space is {1, 2, 3, 4, 5, 6}.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event** An *event* is a set of outcomes that we want to calculate the probability
    of and that form a *subset* of the sample space. For example, we might want to
    know the probability of a particular outcome, like rolling a 3, or the probability
    of a set of multiple outcomes, such as rolling an even number (either 2, 4, or
    6). We’ll use the letter *E* in our formulas to stand for an event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If there’s a *uniform distribution*—that is, if each outcome in the sample
    space is equally likely to occur—then the probability of an event, *P*(*E*), occurring
    is calculated using the following formula (I’ll talk about nonuniform distributions
    a bit later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0131-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *n*(*E*) and *n*(*S*) are the cardinality of the sets *E*, the event,
    and *S*, the sample space, respectively. The value of *P*(*E*) ranges from 0 to
    1, with higher values indicating a higher chance of the event happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply this formula to a die roll to calculate the probability of a particular
    roll—say, 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0132-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This confirms what was obvious all along: the probability of a particular die
    roll is 1/6\. You could easily do this calculation in your head, but we can use
    this formula to write the following function in Python that calculates the probability
    of any event, `event`, in any sample space, `space`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the two arguments `space` and `event`—the sample space and
    event—need not be sets created using `FiniteSet`. They can also be lists or, for
    that matter, any other Python object that supports the `len()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this function, let’s write a program to find the probability of a prime
    number appearing when a 20-sided die is rolled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We first create a set representing the sample space, `space`, using the `range()`
    function at ➋. To create the event set, we need to find the prime numbers from
    the sample space, so we define a function, `check_prime()`, at ➊. This function
    takes an integer and checks to see whether it’s divisible (with no remainder)
    by any number between 2 and itself. If so, it returns `False`. Because a prime
    number is only divisible by 1 and itself, this function returns `True` if an integer
    is prime and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this function for each of the numbers in the sample space at ➌ and
    add the prime numbers to a list, `primes`. Then, we create our event set, `event`,
    from this list at ➍. Finally, we call the `probability()` function we created
    earlier. We get the following output when we run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, *n*(*E*) = 8 and *n*(*S*) = 20, so the probability, *P*, is 0.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our 20-sided die program, we really didn’t need to create the sets; instead,
    we could have called the `probability()` function with the sample space and events
    as lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `probability()` function works equally well in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '***Probability of Event A or Event B***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say we’re interested in two possible events, and we want to find the
    probability of *either* one of them happening. For example, going back to a simple
    die roll, let’s consider the following two events:'
  prefs: []
  type: TYPE_NORMAL
- en: A = The number is a prime number.
  prefs: []
  type: TYPE_NORMAL
- en: B = The number is odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it was earlier, the sample space, *S*, is {1, 2, 3, 4, 5, 6}. Event A can
    be represented as the subset {2, 3, 5}, the set of prime numbers in the sample
    space, and event B can be represented as {1, 3, 5}, the odd numbers in the sample
    space. To calculate the probability of either set of outcomes, we can find the
    probability of the *union* of the two sets. In our notation, we could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0133-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s perform this calculation in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We first create a set, `s`, representing the sample space, followed by the two
    sets `a` and `b`. Then, at ➊, we use the `union()` method to find the event set,
    `e`. Finally, we calculate the probability of the union of the two sets using
    the earlier formula.
  prefs: []
  type: TYPE_NORMAL
- en: '***Probability of Event A and Event B***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two events in mind and you want to calculate the chances of *both*
    of them happening—for example, the chances that a die roll is both prime and odd.
    To determine this, you calculate the probability of the intersection of the two
    event sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E* = *A* ∩ *B* = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the probability of both A and B happening by using the `intersect()`
    method, which is similar to what we did in the previous case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '***Generating Random Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Probability concepts allow us to reason about and calculate the chance of an
    event happening. To actually simulate such events—like a simple dice game—using
    computer programs, we need a way to generate random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simulating a Die Roll**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To simulate a six-sided die roll, we need a way to generate a random integer
    between 1 and 6\. The `random` module in Python’s standard library provides us
    with various functions to generate random numbers. Two functions that we’ll use
    in this chapter are the `randint()` function, which generates a random integer
    in a given range, and the `random()` function, which generates a floating point
    number between 0 and 1\. Let’s see a quick example of how the `randint()` function
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `randint()` function takes two integers as arguments and returns a random
    integer that falls between these two numbers (both inclusive). In this example,
    we passed in the range `(1, 6)`, and it returned the number 4, but if we call
    it again, we’ll very likely get a different number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `randint()` function allows us to simulate the roll of our virtual
    die. Every time we call this function, we’re going to get a number between 1 and
    6, just as we would if we were rolling a six-sided die. Note that `randint()`
    expects you to supply the lower number first, so `randint(6, 1)` isn’t valid.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can You Roll That Score?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our next program will simulate a simple die-rolling game, where we keep rolling
    the six-sided die until we’ve rolled a total of 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the same `roll()` function we created earlier. Then, we use
    a `while` loop at ➊ to call this function, keep track of the number of rolls,
    print the current roll, and add up the total score. The loop repeats until the
    score reaches 20, and then the program prints the total score and number of rolls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program several times, you’ll notice that the number of rolls
    it takes to reach 20 varies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the Target Score Possible?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our next program is similar, but it’ll tell us whether a certain target score
    is reachable within a maximum number of rolls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When you run this program, it asks for the target score and the maximum number
    of allowed rolls as input, and then it prints out the probability of achieving
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two sample executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let’s understand the workings of the `find_prob()` function, which performs
    the probability calculation. The sample space here is the Cartesian product, `die_sides`^(`max_rolls`)
    ➊, where `die_sides` is the set {1, 2, 3, 4, 5, 6}, representing the numbers on
    a six-sided die, and `max_rolls` is the maximum number of die rolls allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event set is all the sets in the sample space that help us reach this target
    score. There are two cases here: when the number of turns left is greater than
    1 and when we’re in the last turn. For the first case, at ➋, we iterate over each
    of the tuples in the Cartesian product and add the ones that add up to or exceed
    `target_score` in the `success_rolls` list. The second case is special: our sample
    space is just the set {1, 2, 3, 4, 5, 6}, and we have only one throw of the die
    left. If the value of the target score is greater than 6, it isn’t possible to
    achieve it, and we set `success_rolls` to be an empty list at ➌. If however, the
    `target_score` is less than or equal to 6, we iterate over each possible roll
    and add the ones that are greater than or equal to the value of `target_score`
    at ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➎, we calculate the event set, `e`, from the `success_rolls` list that we
    constructed earlier and then return the probability of reaching the target score.
  prefs: []
  type: TYPE_NORMAL
- en: '***Nonuniform Random Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our discussions of probability have so far assumed that each of the outcomes
    in the sample space is equally likely. The `random.randint()` function, for example,
    returns an integer in the specified range assuming that each integer is *equally
    likely*. We refer to such probability as *uniform probability* and to random numbers
    generated by the `randint()` function as *uniform random numbers*. Let’s say,
    however, that we want to simulate a biased coin toss—a loaded coin for which heads
    is twice as likely to occur as tails. We’d then need a way to generate *nonuniform*
    random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write the program to do so, we’ll review the idea behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a number line with a length of 1 and with two equally divided intervals,
    as shown in [Figure 5-1](ch05.html#ch5fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f05-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: A number line with a length of 1 divided into two equal intervals
    corresponding to the probability of heads or tails on a coin toss*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll refer to this line as the *probability number line*, with each division
    representing an equally possible outcome—for example, heads or tails upon a fair
    coin toss. Now, in [Figure 5-2](ch05.html#ch5fig2), consider a different version
    of this number line.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f05-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: A number line with a length of 1 divided into two unequal intervals
    corresponding to the probability of heads or tails on a biased coin toss*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the division corresponding to heads is 2/3 of the total length and the
    division corresponding to tails is 1/3\. This represents the situation of a coin
    that’s likely to turn up heads in 2/3 of tosses and tails only in 1/3 of tosses.
    The following Python function will simulate such a coin toss, considering this
    unequal probability of heads or tails appearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We assume that the function returns 0 to indicate heads and 1 to indicate tails,
    and then we generate a random number between 0 and 1 at ➊ using the `random.random()`
    function. If the generated number is less than 2/3—the probability of flipping
    heads with our biased coin—the program returns 0; otherwise it returns 1 (tails).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now see how we can extrapolate the preceding function to simulate a nonuniform
    event with multiple possible outcomes. Let’s consider a fictional ATM that dispenses
    a $5, $10, $20, or $50 bill when its button is pressed. The different denominations
    have varying probabilities of being dispensed, as shown in [Figure 5-3](ch05.html#ch5fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f05-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: A number line with a length of 1 divided into four intervals of
    different lengths corresponding to the probability of dispensing bills of different
    denominations*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the probability of a $5 bill or $10 bill being dispensed is 1/6, and the
    probability of a $20 bill or $50 bill being dispensed is 1/3.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a list to store the rolling sum of the probabilities, and then we
    generate a random number between 0 and 1\. We start from the left end of the list
    that stores the sum and return the first index of this list for which the corresponding
    sum is lesser than or equal to the random number generated. The `get_index()`
    function implements this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We call the `get_index()` function with a list containing the probability that
    the event in the corresponding position is expected to occur. We then, at ➊, construct
    the list `sum_probability`, where the `i`th element is the sum of the first `i`
    elements in the list `probability`. That is, the first element in `sum_probability`
    is equal to the first element in `probability`, the second element is equal to
    the sum of the first two elements in `probability`, and so on. At ➋, a random
    number between 0 and 1 is generated using the label `r`. Next, at ➌, we traverse
    through `sum_probability` and return the index of the first element that exceeds
    `r`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the function, at ➍, takes care of a special case best illustrated
    through an example. Consider a list of three events with percentages of occurrence
    each expressed as 0.33\. In this case, the list `sum_probability` would look like
    `[0.33, 0.66, 0.99]`. Now, consider that the random number generated, `r`, is
    `0.99314`. For this value of `r`, we want the last element in the list of events
    to be chosen. You may argue that this isn’t exactly right because the last event
    has a higher than 33 percent chance of being selected. As per the condition at
    ➌, there’s no element in `sum_probability` that’s greater than `r`; hence, the
    function wouldn’t return any index at all. The statement at ➍ takes care of this
    and returns the last index.
  prefs: []
  type: TYPE_NORMAL
- en: If you call the `dispense()` function to simulate a large number of dollar bills
    disbursed by the ATM, you’ll see that the ratio of the number of times each bill
    appears closely obeys the probability specified. We’ll find this technique useful
    when creating *fractals* in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started by learning how to represent a set in Python. Then,
    we discussed the various set concepts and you learned about the union, the intersection,
    and the Cartesian product of sets. You applied some of the set concepts to explore
    the basics of probability and, finally, learned how to simulate uniform and nonuniform
    random events in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you have a few programming challenges to solve that’ll give you the opportunity
    to apply what you’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***#1: Using Venn Diagrams to Visualize Relationships Between Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *Venn diagram* is an easy way to see the relationship between sets graphically.
    It tells us how many elements are common between the two sets, how many elements
    are only in one set, and how many elements are in neither set. Consider a set,
    *A*, that represents the set of positive odd numbers less than 20—that is, *A*
    = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}—and consider another set, *B*, that represents
    the set of prime numbers less than 20—that is, *B* = {2, 3, 5, 7, 11, 13, 17,
    19}. We can draw Venn diagrams with Python using the `matplotlib_venn` package
    (see [Appendix A](app01.html#app01) for installation instructions for this package).
    Once you’ve installed it, you can draw the Venn diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once we import all the required modules and functions (the `venn2()` function,
    `matplotlib.pyplot`, and the `FiniteSet` class), all we have to do is create the
    two sets and then call the `venn2()` function, using the `subsets` key-word argument
    to specify the sets as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05.html#ch5fig4) shows the Venn diagram created by the preceding
    program. The sets *A* and *B* share seven common elements, so 7 is written in
    the common area. Each of the sets also has unique elements, so the number of unique
    elements—3 and 1, respectively—is written in the individual areas. The labels
    below the two sets are shown as *A* and *B*. You can specify your own labels using
    the `set_labels` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This would change the set labels to `S` and `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f05-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Venn diagram showing the relationship between two sets*, A *and*
    B'
  prefs: []
  type: TYPE_NORMAL
- en: 'For your challenge, imagine you’ve created an online questionnaire asking your
    classmates the following question: *Do you play football, another sport, or no
    sports?* Once you have the results, create a CSV file, *sports.csv*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Create 20 such rows for the 20 students in your class. The first column is the
    student ID (the survey isn’t anonymous), the second column has a 1 if the student
    has marked “football” as the sport they love to play, and the third column has
    a 1 if the student plays any other sport or none at all. Write a program to create
    a Venn diagram to depict the summarized results of the survey, as shown in [Figure
    5-5](ch05.html#ch5fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f05-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: A Venn diagram showing the number of students who love to play
    football and the number who love to play other sports*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the data in the *sports.csv* file you created, the numbers in
    each set will vary. The following function reads a CSV file and returns two lists
    corresponding to the IDs of those students who play football and other sports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '***#2: Law of Large Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve referred to a die roll and coin toss as two examples of random events
    that we can simulate using random numbers. We’ve used the term *event* to refer
    to a certain number showing up on a die roll or to heads or tails showing up on
    a coin toss, with each event having an associated probability value. In probability,
    a *random variable*—usually denoted by *X*—describes an event. For example, *X*
    = 1 describes the event of 1 appearing upon a die roll, and *P*(*X* = 1) describes
    the associated probability. There are two kinds of random variables: (1) *discrete*
    random variables, which take only integral values and are the only kind of random
    variables we see in this chapter, and (2) *continuous* random variables, which—as
    the name suggests—can take any real value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *expectation*, *E*, of a discrete random variable is the equivalent of
    the average or mean that we learned about in [Chapter 3](ch03.html#ch03). The
    expectation can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E* = *x*[1]*P*(*x*[1]) + *x*[2]*P*(*x*[2]) + *x*[3]*P*(*x*[3]) + ... + *x[n]P*(*x[n]*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, for a six-sided die, the *expected value* of a die roll can be calculated
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the *law of large numbers*, the average value of results over
    multiple trials approaches the expected value as the number of trials increases.
    Your challenge in this task is to verify this law when rolling a six-sided die
    for the following number of trials: 100, 1000, 10000, 100000, and 500000\. Here’s
    an expected sample run of your complete program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '***#3: How Many Tosses Before You Run Out of Money?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s consider a simple game played with a fair coin toss. A player wins $1
    for heads and loses $1.50 for tails. The game is over when the player’s balance
    reaches $0\. Given a certain starting amount specified by the user as input, your
    challenge is to write a program that simulates this game. Assume there’s an unlimited
    cash reserve with the computer—your opponent here. Here’s a possible game play
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '***#4: Shuffling a Deck of Cards***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a standard deck of 52 playing cards. Your challenge here is to write
    a program to simulate the shuffling of this deck. To keep the implementation simple,
    I suggest you use the integers 1, 2, 3, ..., 52 to represent the deck. Every time
    you run the program, it should output a shuffled deck—in this case, a shuffled
    list of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a possible output of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `random` module in Python’s standard library has a function, `shuffle()`,
    for this exact operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Create a list, `x`, consisting of the numbers [1, 2, 3, 4]. Then, call the `shuffle()`
    function ➊, passing this list as an argument. You’ll see that the numbers in `x`
    have been shuffled. Note that the list is shuffled “in place.” That is, the original
    order is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you wanted to use this program in a card game? There, it’s not
    enough to simply output the shuffled list of integers. You’ll also need a way
    to map back the integers to the specific suit and rank of each card. One way you
    might do this is to create a Python class to represent a single card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent the ace of clubs, create a card object, `card1 = Card(''clubs'',
    ''ace'')`. Then, do the same for all the other cards. Next, create a list consisting
    of each of the card objects and shuffle this list. The result will be a shuffled
    deck of cards where you also know the suit and rank of each card. Output of the
    program should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '***#5: Estimating the Area of a Circle***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a dartboard with a circle of radius *r* inscribed in a square with
    side 2*r*. Now let’s say you start throwing a large number of darts at it. Some
    of these will hit the board within the circle—let’s say, *N*—and others outside
    it—let’s say, *M*. If we consider the fraction of darts that land inside the circle,
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0145-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: then the value of *f* × *A*, where *A* is the area of the square, would roughly
    be equal to the area of the circle (see [Figure 5-6](ch05.html#ch5fig6)). The
    darts are represented by the small circular dots in the figure. We shall refer
    to the value of *f* × *A* as the estimated area. The actual area is, of course,
    *πr*².
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f05-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: A circle of radius* r *inscribed in a square board with side 2*r*.
    The dots represent darts randomly thrown at the board.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this challenge, write a program that will find the estimated area
    of a circle, given any radius, using this approach. The program should print the
    estimated area of the circle for three different values of the number of darts:
    10³, 10⁵, and 10⁶. That’s a lot of darts! You’ll see that increasing the number
    of darts brings the estimated area close to the actual area. Here’s a sample output
    of the completed solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The dart throw can be simulated by a call to the `random.uniform(a, b)` function,
    which will return a random number between *a* and *b*. In this case, use the values
    *a* = 0, *b* = 2*r* (the side of the square).
  prefs: []
  type: TYPE_NORMAL
- en: '**Estimating the Value of Pi**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider [Figure 5-6](ch05.html#ch5fig6) once again. The area of the square
    is 4*r*², and the area of the inscribed circle is *πr*². If we divide the area
    of the circle by the area of the square, we get *π*/4\. The fraction *f* that
    we calculated earlier,
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0147-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: is thus an approximation of *π*/4, which in turn means that the value of
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0147-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: should be close to the value of *π*. Your next challenge is to write a program
    that will estimate the value of *π* assuming any value for the radius. As you
    increase the number of darts, the estimated value of *π* should get close to the
    known value of the constant.
  prefs: []
  type: TYPE_NORMAL
