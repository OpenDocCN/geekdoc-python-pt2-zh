<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_76"/><span epub:type="pagebreak" id="page_77"/><span class="big">4</span><br/>SENDING SUPER-SECRET MESSAGES WITH A BOOK CIPHER</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent"><em>The Key to Rebecca</em> is a critically acclaimed best-selling novel by Ken Follett. Set in Cairo in World War II and based on actual events, it tells the story of a Nazi spy and the British intelligence officer who pursued him. The title refers to the spy’s cipher system, which used the famous gothic novel <em>Rebecca</em>, written by Daphne du Maurier, as a key. <em>Rebecca</em> is considered one of the greatest novels of the 20th century, and the Germans really did use it as a code book during the war.</p>&#13;
<p class="indent">The Rebecca cipher is a variation of the <em>one-time pad</em>, an unbreakable encryption technique that requires a key that is at least the same size as the message being sent. Both the sender and receiver have a copy of the pad, and after one use, the top sheet is ripped off and discarded.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_78"/>One-time pads provide absolute, perfect security—uncrackable even by a quantum computer! Despite this, the pads have several practical drawbacks that prevent widespread use. Key among these are the need to securely transport and deliver the pads to the sender and receiver, the need to safely store them, and the difficulty in manually encoding and decoding the messages.</p>&#13;
<p class="indent">In the <em>The Key to Rebecca</em>, both parties must know the encryption rules and have the same edition of the book to use the cipher. In this chapter, you’ll transfer the manual method described in the book into a more secure—and easier to use—digital technique. In the process, you’ll get to work with useful functions from the Python Standard Library, the <span class="literal">collections</span> module, and the <span class="literal">random</span> module. You’ll also learn a little more about Unicode, a standard used to ensure that characters, such as letters and numbers, are universally compatible across all platforms, devices, and applications.</p>&#13;
<h3 class="h3" id="ch00lev1sec27"><strong>The One-Time Pad</strong></h3>&#13;
<p class="noindent">A one-time pad is basically an ordered stack of sheets printed with truly random numbers, usually in groups of five (<a href="ch04.xhtml#ch04fig1">Figure 4-1</a>). To make them easy to conceal, the pads tend to be small and may require a powerful magnifying glass to read. Despite being old-school, one-time pads produce the most secure ciphers in the world, as every letter is encrypted with a unique key. As a result, cryptanalysis techniques, such as frequency analysis, simply can’t work.</p>&#13;
<div class="image"><img src="../images/fig04_01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch04fig1"/>Figure 4-1: Example of a one-time pad sheet</p>&#13;
<p class="indent">To encrypt a message with the one-time pad in <a href="ch04.xhtml#ch04fig1">Figure 4-1</a>, start by assigning each letter of the alphabet a two-digit number. <em>A</em> equals 01, <em>B</em> equals 02, and so on, as shown in the following table.</p>&#13;
<div class="image"><img src="../images/table_page_78_01.jpg" alt="Image"/></div>&#13;
<p class="indent">Next, convert the letters in your short message into numbers:</p>&#13;
<div class="image"><img src="../images/table_page_79_01.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>Starting at the upper left of the one-time pad sheet and reading left to right, assign a number pair (<em>key</em>) to each letter and add it to the number value of the letter. You’ll want to work with base 10 number pairs, so if your sum is greater than 100, use modular arithmetic to truncate the value to the last two digits (103 becomes 03). The numbers in shaded cells in the following diagrams are the result of modular arithmetic.</p>&#13;
<div class="image"><img src="../images/table_page_79_02.jpg" alt="Image"/></div>&#13;
<p class="indent">The last row in this diagram represents the ciphertext. Note that KITTY, duplicated in the plaintext, is not repeated in the ciphertext. Each encryption of KITTY is unique.</p>&#13;
<p class="indent">To decrypt the ciphertext back to plaintext, the recipient uses the same sheet from their identical one-time pad. They place their number pairs below the ciphertext pairs and subtract. When this results in a negative number, they use modular subtraction (adding 100 to the ciphertext value before subtracting). They finish by converting the resulting number pairs back to letters.</p>&#13;
<div class="image"><img src="../images/table_page_79_03.jpg" alt="Image"/></div>&#13;
<p class="indent">To ensure that no keys are repeated, the number of letters in the message can’t exceed the number of keys on the pad. This forces the use of short messages, which have the advantage of being easier to encrypt and decrypt and which offer a cryptanalyst fewer opportunities to decipher the message. Some other guidelines include the following:</p>&#13;
<ul>&#13;
<li class="noindent">Spell out numbers (for example, TWO for 2).</li>&#13;
<li class="noindent">End sentences with an <em>X</em> in place of a period (for example, CALL AT NOONX).</li>&#13;
<li class="noindent">Spell out any other punctuation that can’t be avoided (for example, COMMA).</li>&#13;
<li class="noindent">End the plaintext message with <em>XX</em>.</li>&#13;
</ul>&#13;
<h3 class="h3" id="ch00lev1sec28"><strong>The Rebecca Cipher</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_80"/>In the novel <em>The Key to Rebecca</em>, the Nazi spy uses a variant of the one-time pad. Identical editions of the novel <em>Rebecca</em> are purchased in Portugal. Two are retained by the spy; the other two are given to Field Marshal Rommel’s staff in North Africa. The encrypted messages are sent by radio on a pre-determined frequency. No more than one message is sent per day and always at midnight.</p>&#13;
<p class="indent">To use the key, the spy would take the current date—say, May 28, 1942—and add the day to the year (28 + 42 = 70). This would determine which page of the novel to use as a one-time pad sheet. Because May is the fifth month, every fifth word in a sentence would be discounted. Because the Rebecca cipher was meant to be used only during a relatively short period in 1942, the spy didn’t have to worry about repetitions in the calendar causing repetition in the keys.</p>&#13;
<p class="indent">The spy’s first message was the following: HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE. Beginning at the top of <a href="ch03.xhtml#page_70">page 70</a>, he read along until he found the letter <em>H</em>. It was the 10th character, discounting every 5th letter. The 10th letter of the alphabet is <em>J</em>, so he used this in his ciphertext to represent <em>H</em>. The next letter, <em>A</em>, was found three letters after <em>H</em>, so it was encoded using the third letter of the alphabet, <em>C</em>. This continued until the full message was encrypted. For rare letters like <em>X</em> or <em>Z</em>, author Ken Follett states that special rules were applied but does not describe them.</p>&#13;
<p class="indent">Using a book in this manner had a distinct advantage over a true one-time pad. To quote Follett, “A pad was unmistakably for the purpose of encipherment, but a book looked quite innocent.” A disadvantage remained, however: the process of encryption and decryption is tedious and potentially error prone. Let’s see if we can remedy this using Python!</p>&#13;
<h3 class="h3ab" id="ch00lev1sec29"><strong>Project #6: The Digital Key to Rebecca</strong></h3>&#13;
<p class="noindent">Turning the Rebecca technique into a digital program offers several advantages over a one-time pad:</p>&#13;
<ul>&#13;
<li class="noindent">The encoding and decoding processes become fast and error-free.</li>&#13;
<li class="noindent">Longer messages can be sent.</li>&#13;
<li class="noindent">Periods, commas, and even spaces can be directly encrypted.</li>&#13;
<li class="noindent">Rare letters, like <em>z</em>, can be chosen from anywhere in the book.</li>&#13;
<li class="noindent">The code book can be hidden among thousands of ebooks on a hard drive or in the cloud.</li>&#13;
</ul>&#13;
<p class="indent">The last item is important. In the novel, the British intelligence officer finds a copy of <em>Rebecca</em> at a captured German outpost. Through simple deductive reasoning he recognizes it as a substitute for a one-time pad. With a digital approach, this would have been much more difficult. In fact, the novel could be kept on a small, easily concealed device such as an SD card. <span epub:type="pagebreak" id="page_81"/>This would make it similar to a one-time pad, which is often no bigger than a postage stamp.</p>&#13;
<p class="indent">A digital approach does have one disadvantage, however: the program is a <em>discoverable</em> item. Whereas a spy could simply memorize the rules for a one-time pad, with a digital approach the rules must be ensconced in the software. This weakness can be minimized by writing the program so that it looks innocent—or at least cryptic—and having it request input from the user for the message and the name of the code book.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Write a Python program that encrypts and decrypts messages using a digital novel as a one-time pad.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec21"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">Unlike the spy, you won’t need all the rules used in the novel, and many wouldn’t work anyway. If you’ve ever used any kind of ebook, you know that page numbers are meaningless. Changes to screen sizes and text sizes render all such page numbers nonunique. And because you can choose letters from anywhere in the book, you don’t necessarily need special rules for rare letters or for discounting numbers in a count.</p>&#13;
<p class="indent">So, you don’t need to focus on perfectly reproducing the Rebecca cipher. You just need to produce something similar and, ideally, better.</p>&#13;
<p class="indent">Luckily, Python <em>iterables</em>, such as lists and tuples, use numerical indexes to keep track of every single item within them. By loading a novel as a list, you can use these indexes as unique starting keys for each character. You can then shift the indexes based on the day of the year, emulating the spy’s methodology in <em>The Key to Rebecca</em>.</p>&#13;
<p class="indent">Unfortunately, <em>Rebecca</em> is not yet in the public domain. In its place, we’ll substitute the text file of Sir Arthur Conan Doyle’s <em>The Lost World</em> that you used in <a href="ch02.xhtml">Chapter 2</a>. This novel contains 51 distinct characters that occur 421,545 times, so you can randomly choose indexes with little chance of duplication. This means you can use the whole book as a one-time pad each time you encrypt a message, rather than restrict yourself to a tiny collection of numbers on a single one-time pad sheet.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can download and use a digital version of <span class="normal">Rebecca</span> if you want. I just can’t provide you with a copy for free!</em></p>&#13;
</div>&#13;
<p class="indent">Because you’ll be reusing the book, you’ll need to worry about both <em>message-to-message</em> and <em>in-message</em> duplication of keys. The longer the message, the more material the cryptanalyst can study, and the easier it is to crack the code. And if each message is sent with the same encryption key, all the intercepted messages can be treated as a single large message.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>For the message-to-message problem, you can imitate the spy and shift the index numbers by the day of the year, using a range of 1 to 366 to account for leap years. In this scheme, February 1 would be 32. This will effectively turn the book into a new one-time pad sheet each time, as different keys will be used for the same characters. Shifting, by one or more increments, resets all the indexes and essentially “tears off” the previous sheet. And unlike a one-time pad, you don’t have to bother with disposing of a piece of paper!</p>&#13;
<p class="indent">For the in-message duplication problem, you can run a check before transmitting the message. It’s unlikely but possible for the program to pick the same letter twice during encryption and thus use the same index twice. Duplicate indexes are basically repeating keys, and these can help a cryptanalyst break your code. So, if duplicate indexes are found, you can rerun the program or reword the message.</p>&#13;
<p class="indent">You’ll also need similar rules to those used in <em>The Key to Rebecca</em>.</p>&#13;
<ul>&#13;
<li class="noindent">Both parties need identical digital copies of <em>The Lost World</em>.</li>&#13;
<li class="noindent">Both parties need to know how to shift the indexes.</li>&#13;
<li class="noindent">Keep messages as short as possible.</li>&#13;
<li class="noindent">Spell out numbers.</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch00lev2sec22"><strong><em>The Encryption Code</em></strong></h4>&#13;
<p class="noindent">The following <em>rebecca.py</em> code will take a message and return an encrypted or plaintext version, as specified by the user. The message can be typed in or downloaded from the book’s website. You’ll also need the <em>lost.txt</em> text file in the same folder as the code.</p>&#13;
<p class="indent">For clarity, you’ll use variable names like <em>ciphertext</em>, <em>encrypt</em>, <em>message</em>, and so on. If you were a real spy, however, you’d avoid incriminating terms in case the enemy got their hands on your laptop.</p>&#13;
<h5 class="h5"><strong>Importing Modules and Defining the main() Function</strong></h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list1">Listing 4-1</a> imports modules and defines the <span class="literal">main()</span> function, used to run the program. This function will ask for user input, call the functions needed to encrypt or decrypt text, check for duplicate keys, and print the ciphertext or plaintext.</p>&#13;
<p class="indent">Whether you define <span class="literal">main()</span> at the start or end of a program is a matter of choice. Sometimes it provides a good, easily readable summary of the whole program. Other times it may feel out of place, like the cart before the horse. From Python’s perspective, it won’t matter where you place it so long as you call the function at the end.</p>&#13;
<pre><span class="codeitalic1">rebecca.py</span>, part 1&#13;
import sys&#13;
import os&#13;
import random&#13;
from collections import defaultdict, Counter&#13;
<span epub:type="pagebreak" id="page_83"/>def main():&#13;
    message = input("Enter plaintext or ciphertext: ")&#13;
    process = input("Enter 'encrypt' or 'decrypt': ")&#13;
    while process not in ('encrypt', 'decrypt'):&#13;
        process = input("Invalid process. Enter 'encrypt' or 'decrypt': ")&#13;
    shift = int(input("Shift value (1-366) = "))&#13;
    while not 1 &lt;= shift &lt;= 366:&#13;
        shift = int(input("Invalid value. Enter digit from 1 to 366: ")&#13;
 <span class="ent">➊</span> infile = input("Enter filename with extension: ")&#13;
&#13;
    if not os.path.exists(infile):&#13;
        print("File {} not found. Terminating.".format(infile), file=sys.stderr)&#13;
        sys.exit(1)    &#13;
    text = load_file(infile)&#13;
    char_dict = make_dict(text, shift)&#13;
&#13;
    if process == 'encrypt':&#13;
        ciphertext = encrypt(message, char_dict)&#13;
     <span class="ent">➋</span> if check_for_fail(ciphertext):&#13;
            print("\nProblem finding unique keys.", file=sys.stderr)&#13;
            print("Try again, change message, or change code book.\n",         &#13;
                  file=sys.stderr)&#13;
            sys.exit()&#13;
     <span class="ent">➌</span> print("\nCharacter and number of occurrences in char_dict: \n")&#13;
        print("{: &gt;10}{: &gt;10}{: &gt;10}".format('Character', 'Unicode', 'Count'))&#13;
        for key in sorted(char_dict.keys()):&#13;
            print('{:&gt;10}{:&gt;10}{:&gt;10}'.format(repr(key)[1:-1],&#13;
                                              str(ord(key)), &#13;
                                              len(char_dict[key])))&#13;
        print('\nNumber of distinct characters: {}'.format(len(char_dict)))&#13;
        print("Total number of characters: {:,}\n".format(len(text)))&#13;
&#13;
        print("encrypted ciphertext = \n {}\n".format(ciphertext))    &#13;
        print("decrypted plaintext = ")&#13;
&#13;
     <span class="ent">➍</span> for i in ciphertext:&#13;
            print(text[i - shift], end='', flush=True)&#13;
&#13;
   elif process == 'decrypt':&#13;
       plaintext = decrypt(message, text, shift)&#13;
       print("\ndecrypted plaintext = \n {}".format(plaintext))</pre>&#13;
<p class="listing"><a id="ch04list1"/>Listing 4-1: Importing modules and defining the <span class="codeitalic">main()</span> function</p>&#13;
<p class="indent">Start by importing <span class="literal">sys</span> and <span class="literal">os</span>, two modules that let you interface with the operating system; then the <span class="literal">random</span> module; and then <span class="literal">defaultdict</span> and <span class="literal">Counter</span> from the <span class="literal">collections</span> module.</p>&#13;
<p class="indent">The <span class="literal">collections</span> module is part of the Python Standard Library and includes several container data types. You can use <span class="literal">defaultdict</span> to build a dictionary on the fly. If <span class="literal">defaultdict</span> encounters a missing key, it will supply a default value rather than throw an error. You’ll use it to build a dictionary of the characters in <em>The Lost World</em> and their corresponding index values.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>A <span class="literal">Counter</span> is a dictionary subclass for counting hashable objects. Elements are stored as dictionary keys, and their counts are stored as dictionary values. You’ll use this to check your ciphertext and ensure no indexes are duplicated.</p>&#13;
<p class="indent">At this point, you begin the definition of the <span class="literal">main()</span> function. The function starts by asking the user for the message to encrypt or decrypt. For maximum security, the user should type this in. The program then asks the user to specify whether they want encryption or decryption. Once the user chooses, the program asks for the <span class="literal">shift</span> value. The <span class="literal">shift</span> value represents the day of the year, over the inclusive and consecutive range of 1 to 366. Next, ask for the <span class="literal">infile</span>, which will be <em>lost.txt</em>, the digital version of <em>The Lost World</em> <span class="ent">➊</span>.</p>&#13;
<p class="indent">Before proceeding, the program checks that the file exists. It uses the operating system module’s <span class="literal">path.exists()</span> method and passes it the <span class="literal">infile</span> variable. If the file doesn’t exist or if the path and/or filename is incorrect, the program lets the user know, uses the <span class="literal">file=sys.stderr</span> option to color the message “error red” in the Python shell, and terminates the program with <span class="literal">sys.exit(1)</span>. The <span class="literal">1</span> is used to flag that the program terminated with an error, as opposed to a clean termination.</p>&#13;
<p class="indent">Next, you call some functions that you’ll define later. The first function loads the <em>lost.txt</em> file as a string named <span class="literal">text</span>, which includes nonletter characters such as spaces and punctuation. The second builds a dictionary of the characters and their corresponding indexes, with the shift value applied.</p>&#13;
<p class="indent">Now you start a conditional to evaluate the process being used. As I mentioned, we’re using incriminating terms like <em>encrypt</em> and <em>decrypt</em> for clarity. You’d want to disguise these for real espionage work. If the user has chosen to encrypt, call the function that encrypts the message with the character dictionary. When the function returns, the program has encrypted the message. But don’t assume it worked as planned! You need to check that it decrypted correctly and that no keys are duplicated. To do this, you start a series of quality control steps.</p>&#13;
<p class="indent">First, you check for duplicate keys <span class="ent">➋</span>. If this function returns <span class="literal">True</span>, instruct the user to try again, change the message, or change the book to something other than <em>The Lost World</em>. For each character in the message, you’ll use the <span class="literal">char_dict</span> and choose an index at random. Even with hundreds or even thousands of indexes for each character, you may still choose the same index more than once for a given character.</p>&#13;
<p class="indent">Rerunning the program with slightly different parameters, as listed earlier, should fix this, unless you have a long message with a lot of low-frequency characters. Handling this rare case may require rewording the message or finding a larger manuscript than <em>The Lost World</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Python’s random module does not produce truly random numbers but rather <span class="normal">pseudorandom</span> numbers that can be predicted. Any cipher using pseudorandom numbers can potentially be cracked by a cryptanalyst. For maximum security when generating random numbers, you should use Python’s <span class="codeitalic">os.urandom()</span> function.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>Now, print the contents of the character dictionary so you can see how many times the various characters occur in the novel <span class="ent">➌</span>. This will help guide what you put in messages, though <em>The Lost World</em> contains a healthy helping of useful characters.</p>&#13;
<pre>Character and number of occurrences in char_dict: &#13;
&#13;
 Character   Unicode     Count&#13;
        \n        10      7865&#13;
                  32     72185&#13;
         !        33       282&#13;
         "        34      2205&#13;
         '        39       761&#13;
         (        40        62&#13;
         )        41        62&#13;
         ,        44      5158&#13;
         -        45      1409&#13;
         .        46      3910&#13;
         0        48         1&#13;
         1        49         7&#13;
         2        50         3&#13;
         3        51         2&#13;
         4        52         2&#13;
         5        53         2&#13;
         6        54         1&#13;
         7        55         4&#13;
         8        56         5&#13;
         9        57         2&#13;
         :        58        41&#13;
         ;        59       103&#13;
         ?        63       357&#13;
         a        97     26711&#13;
         b        98      4887&#13;
         c        99      8898&#13;
         d       100     14083&#13;
         e       101     41156&#13;
         f       102      7705&#13;
         g       103      6535&#13;
         h       104     20221&#13;
         i       105     21929&#13;
         j       106       431&#13;
         k       107      2480&#13;
         l       108     13718&#13;
         m       109      8438&#13;
         n       110     21737&#13;
         o       111     25050&#13;
         p       112      5827&#13;
         q       113       204&#13;
         r       114     19407&#13;
         s       115     19911&#13;
         t       116     28729&#13;
         u       117     10436&#13;
         v       118      3265&#13;
         w       119      8536&#13;
         x       120       573&#13;
         y       121      5951&#13;
         z       122       296&#13;
         {       123         1&#13;
         }       125         1&#13;
&#13;
Number of distinct characters: 51&#13;
Total number of characters: 421,545</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>To generate this table, you use Python’s Format Specification Mini-Language (<em><a href="https://docs.python.org/3/library/string.html#formatspec">https://docs.python.org/3/library/string.html#formatspec</a></em>) to print headers for the three columns. The number in curly brackets denotes how many characters should be in the string, and the greater-than sign designates right justification.</p>&#13;
<p class="indent">The program then loops through the keys in the character dictionary and prints them using the same column width and justification. It prints the character, its Unicode value, and the number of times it occurs in the text.</p>&#13;
<p class="indent">You use <span class="literal">repr()</span> to print the key. This built-in function returns a string containing a printable representation of an object. That is, it returns all information about the object in a format useful for debugging and development purposes. This allows you to explicitly print characters like newline (<span class="literal">\n</span>) and space. The index range <span class="literal">[1:-1]</span> excludes the quotes on both sides of the output string.</p>&#13;
<p class="indent">The <span class="literal">ord()</span> built-in function returns an integer representing the Unicode code point for a character. Computers deal only with numbers, so they must assign a number to every possible character, such as <em>%</em>, 5, <img src="../images/icon1.jpg" alt="Image"/>, or <em>A</em>. The <em>Unicode Standard</em> ensures that every character, no matter what platform, device, application, or language, has a unique number and is universally compatible. By showing the user the Unicode values, the program lets the user pick up on anything strange happening with a text file, such as the same letter showing up as multiple distinct characters.</p>&#13;
<p class="indent">For the third column, you get the length of each dictionary key. This will represent the number of times that character appears in the novel. The program then prints the number of distinct characters and the total of all characters in the text.</p>&#13;
<p class="indent">Finally, you finish the encryption process by printing the ciphertext, and then the decrypted plaintext, as a check. To decipher the message, the program loops through each item in the ciphertext and uses the item as an index for <span class="literal">text</span> <span class="ent">➍</span>, subtracting the <span class="literal">shift</span> value, which was added earlier. When you print the results, the program uses <span class="literal">end=''</span> in place of the default newline, so each character isn’t on a separate line.</p>&#13;
<p class="indent">The <span class="literal">main()</span> function ends with a conditional statement to check whether <span class="literal">process == 'decrypt'</span>. If the user chooses to decrypt the message, the program calls the <span class="literal">decrypt()</span> function and then prints the decrypted plaintext. Note that you could simply use <span class="literal">else</span> here, but I chose to use <span class="literal">elif</span> for clarity and readability.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_87"/><strong>Loading a File and Making a Dictionary</strong></h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list2">Listing 4-2</a> defines functions to load a text file and make a dictionary of characters in the file and their corresponding indexes.</p>&#13;
<pre><span class="codeitalic1">rebecca.py</span>, part 2&#13;
   def load_file(infile):&#13;
       """Read and return text file as a string of lowercase characters."""&#13;
       with open(infile) as f:&#13;
           loaded_string = f.read().lower()&#13;
       return loaded_string&#13;
&#13;
<span class="ent">➊</span> def make_dict(text, shift):&#13;
       """Return dictionary of characters and shifted indexes."""&#13;
       char_dict = defaultdict(list)&#13;
       for index, char in enumerate(text):&#13;
         <span class="ent">➋</span> char_dict[char].append(index + shift)&#13;
       return char_dict</pre>&#13;
<p class="listing"><a id="ch04list2"/>Listing 4-2: Defining the <span class="codeitalic">load_file()</span> and <span class="codeitalic">make_dict()</span> functions</p>&#13;
<p class="indent">This listing begins by defining a function to load a text file as a string. Using <span class="literal">with</span> to open the file ensures it will close automatically when the function ends.</p>&#13;
<p class="indent">Some users may get an error, such as the following one, when loading text files:</p>&#13;
<pre>UnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position&#13;
27070:character maps to &lt;undefined&gt;</pre>&#13;
<p class="indent">In this case, try modifying the <span class="literal">open</span> function by adding the <span class="literal">encoding</span> and <span class="literal">errors</span> arguments.</p>&#13;
<pre>  with open(infile, encoding='utf-8', errors='ignore') as f:</pre>&#13;
<p class="indent">For more on this issue, see <a href="ch02.xhtml#page_35">page 35</a> in <a href="ch02.xhtml">Chapter 2</a>.</p>&#13;
<p class="indent">After opening the file, read it to a string and convert all the text to lower- case. Then return the string.</p>&#13;
<p class="indent">The next step is to turn the string into a dictionary. Define a function that takes this string and the <span class="literal">shift</span> value as arguments <span class="ent">➊</span>. The program creates a <span class="literal">char_dict</span> variable using <span class="literal">defaultdict()</span>. This variable will be a dictionary. The program then passes the type constructor for <span class="literal">list</span> to <span class="literal">defaultdict()</span>, as you want the dictionary values to be a list of indexes.</p>&#13;
<p class="indent">With <span class="literal">defaultdict()</span>, whenever an operation encounters an item that isn’t already in the dictionary, a function named <span class="literal">default_factory()</span> is called with no arguments, and the output is used as the value. Any key that doesn’t exist gets the value returned by <span class="literal">default_factory</span>, and no <span class="literal">KeyError</span> is raised.</p>&#13;
<p class="indent">If you tried to make the dictionary on the fly without the handy <span class="literal">collections</span> module, you’d get the <span class="literal">KeyError</span>, as shown in the next example.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">mylist = ['a', 'b', 'c']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">d = dict()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">for index, char in enumerate(mylist):</span>&#13;
<span class="codestrong1">    d[char].append(index)</span>&#13;
    &#13;
Traceback (most recent call last):&#13;
 File "&lt;pyshell#16&gt;", line 2, in &lt;module&gt;&#13;
  d[char].append(index)&#13;
KeyError: 'a'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>The built-in <span class="literal">enumerate()</span> function acts as an automatic counter, so you can easily get the index for each character in the string derived from <em>The Lost World</em>. The keys in <span class="literal">char_dict</span> are characters, and the characters can occur thousands of times within <span class="literal">text</span>. So, the dictionary values are lists that hold the indexes for all these character occurrences. By adding the shift value to the index when it is appended to a value list, you ensure that the indexes will be unique for each message <span class="ent">➋</span>.</p>&#13;
<p class="indent">Finish the function by returning the character dictionary.</p>&#13;
<h5 class="h5"><strong>Encrypting the Message</strong></h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list3">Listing 4-3</a> defines a function to encrypt the message. The resulting ciphertext will be a list of indexes.</p>&#13;
<pre><span class="codeitalic1">rebecca.py</span>, part 3&#13;
def encrypt(message, char_dict):&#13;
    """Return list of indexes representing characters in a message."""&#13;
    encrypted = []&#13;
    for char in message.lower():&#13;
     <span class="ent">➊</span> if len(char_dict[char]) &gt; 1:&#13;
            index = random.choice(char_dict[char])&#13;
        elif len(char_dict[char]) == 1: # Random.choice fails if only 1 choice&#13;
            index = char_dict[char][0]&#13;
     <span class="ent">➋</span> elif len(char_dict[char]) == 0:&#13;
            print("\nCharacter {} not in dictionary.".format(char),&#13;
                  file=sys.stderr)&#13;
            continue&#13;
        encrypted.append(index)&#13;
    return encrypted</pre>&#13;
<p class="listing"><a id="ch04list3"/>Listing 4-3: Defining a function to encrypt the plaintext message</p>&#13;
<p class="indent">The <span class="literal">encrypt()</span> function will take the message and <span class="literal">char_dict</span> as arguments. Start it by creating an empty list to hold the ciphertext. Next, start looping through the characters in <span class="literal">message</span> and converting them to lowercase to match the characters in <span class="literal">char_dict</span>.</p>&#13;
<p class="indent">If the number of indexes associated with the character is greater than 1, the program uses the <span class="literal">random.choice()</span> method to choose one of the character’s indexes at random <span class="ent">➊</span>.</p>&#13;
<p class="indent">If a character occurs only once in <span class="literal">char_dict</span>, <span class="literal">random.choice()</span> will throw an error. To handle this, the program uses a conditional and hardwires the choice of the index, which will be at position <span class="literal">[0]</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>If the character doesn’t exist in <em>The Lost World</em>, it won’t be in the dictionary, so use a conditional to check for this <span class="ent">➋</span>. If it evaluates to <span class="literal">True</span>, print an alert for the user and use <span class="literal">continue</span> to return to the start of the loop without choosing an index. Later, when the quality control steps run on the ciphertext, a space will appear in the decrypted plaintext where this character should be.</p>&#13;
<p class="indent">If <span class="literal">continue</span> is not called, then the program appends the index to the <span class="literal">encrypted</span> list. When the loop ends, you return the list to end the function.</p>&#13;
<p class="indent">To see how this works, let’s look at the first message the Nazi spy sends in <em>The Key to Rebecca</em>, shown here:</p>&#13;
<p class="indent">HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE.</p>&#13;
<p class="indent">Using this message and a shift value of 70 yielded the following randomly generated ciphertext:</p>&#13;
<pre>[125711, 106950, 85184, 43194, 45021, 129218, 146951, 157084, 75611, 122047,&#13;
121257, 83946, 27657, 142387, 80255, 160165, 8634, 26620, 105915, 135897,&#13;
22902, 149113, 110365, 58787, 133792, 150938, 123319, 38236, 23859, 131058,&#13;
36637, 108445, 39877, 132085, 86608, 65750, 10733, 16934, 78282]</pre>&#13;
<p class="indent">Your results may differ due to the stochastic nature of the algorithm.</p>&#13;
<h5 class="h5"><strong>Decrypting the Message</strong></h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list4">Listing 4-4</a> defines a function to decrypt the ciphertext. The user will copy and paste the ciphertext when asked for input by the <span class="literal">main()</span> function.</p>&#13;
<pre><span class="codeitalic1">rebecca.py</span>, part 4&#13;
def decrypt(message, text, shift):&#13;
    """Decrypt ciphertext list and return plaintext string."""&#13;
    plaintext = ''&#13;
    indexes = [s.replace(',', '').replace('[', '').replace(']', '')&#13;
               for s in message.split()]&#13;
    for i in indexes:&#13;
        plaintext += text[int(i) - shift]&#13;
    return plaintext</pre>&#13;
<p class="listing"><a id="ch04list4"/>Listing 4-4: Defining a function to decrypt the plaintext message</p>&#13;
<p class="indent">The listing starts by defining a function named <span class="literal">decrypt()</span> with the message, the novel (<span class="literal">text</span>), and the <span class="literal">shift</span> value as parameters. Of course, the message will be in ciphertext form, consisting of a list of numbers representing shifted indexes. You immediately create an empty string to hold the decrypted plaintext.</p>&#13;
<p class="indent">Most people will copy and paste the ciphertext when prompted for input by the <span class="literal">main()</span> function. This input may or may not contain the square brackets that came with the list. And because the user entered the ciphertext using the <span class="literal">input()</span> function, the results are a <em>string</em>. To convert the indexes to integers that can be shifted, you first need to remove the nondigit characters. Do this using the <span class="literal">string</span> <span class="literal">replace()</span> and <span class="literal">split()</span> methods, while also using list comprehension to return a list. List comprehension is a shorthand way to execute loops in Python.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>To use <span class="literal">replace()</span>, you pass it the character you want replaced followed by the character used to replace it. In this case, use a space for the replacement. Note that you can “string” these together with dot notation, handling the commas and brackets all in one go. How cool is that?</p>&#13;
<p class="indent">Next, start looping through the indexes. The program converts the current index from a string to an integer so you can subtract the shift value that was applied during encryption. You use the index to access the character list and get the corresponding character. Then you add the character to the <span class="literal">plaintext</span> string and return <span class="literal">plaintext</span> when the loop ends.</p>&#13;
<h5 class="h5"><strong>Checking for Failure and Calling the main() Function</strong></h5>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04list5">Listing 4-5</a> defines a function to check the ciphertext for duplicate indexes (keys) and finishes the program by calling the <span class="literal">main()</span> function. If the function discovers duplicate indexes, the encryption might have been compromised, and the <span class="literal">main()</span> function will tell the user how to fix it before terminating.</p>&#13;
<pre><span class="codeitalic1">rebecca.py</span>, part 5&#13;
def check_for_fail(ciphertext):&#13;
    """Return True if ciphertext contains any duplicate keys."""&#13;
    check = [k for k, v in Counter(ciphertext).items() if v &gt; 1]&#13;
    if len(check) &gt; 0:&#13;
        return True&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<p class="listing"><a id="ch04list5"/>Listing 4-5: Defining a function to check for duplicate indexes and calling <span class="codeitalic">main()</span></p>&#13;
<p class="indent">This listing defines a function named <span class="literal">check_for_fail()</span> that takes the ciphertext as an argument. It checks to see whether any of the indexes in the ciphertext are repeated. Remember, the one-time pad approach works because every key is unique; thus, every index in the ciphertext should be unique.</p>&#13;
<p class="indent">To look for repeats, the program uses <span class="literal">Counter</span> again. It employs list comprehension to build a list containing all the duplicate indexes. Here, <span class="literal">k</span> stands for (dictionary) key, and <span class="literal">v</span> stands for (dictionary) value. Since <span class="literal">Counter</span> produces a dictionary of counts for each key, what you’re saying here is this: For every key-value pair in a dictionary made from the ciphertext, create a list of all the keys that occur more than once. If there are duplicates, append the corresponding key to the <span class="literal">check</span> list.</p>&#13;
<p class="indent">Now all you need to do is get the length of <span class="literal">check</span>. If it is greater than zero, the encryption is compromised, and the program returns <span class="literal">True</span>.</p>&#13;
<p class="indent">The program ends with the boilerplate code to call the program as a module or in stand-alone mode.</p>&#13;
<h4 class="h4" id="ch00lev2sec23"><strong><em>Sending Messages</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_91"/>The following message is based on a passage from <em>The Key to Rebecca</em>. You can find it in the downloadable <em>Chapter_4</em> folder as <em>allied_attack_plan.txt</em>. As a test, try sending it with a shift of 70. Use your operating system’s Select All, Copy, and Paste commands to transfer the text when asked for input. If it doesn’t pass the <span class="literal">check_for_fail()</span> test, run it again!</p>&#13;
<pre>Allies plan major attack for Five June. Begins at oh five twenty with&#13;
bombardment from Aslagh Ridge toward Rommel east flank. Followed by tenth&#13;
Indian Brigade infantry with tanks of twenty second Armored Brigade on Sidi&#13;
Muftah. At same time, thirty second Army Tank Brigade and infantry to charge&#13;
north flank at Sidra Ridge. Three hundred thirty tanks deployed to south and&#13;
seventy to north.</pre>&#13;
<p class="indent">The nice thing about this technique is that you can use proper punctuation, at least if you type the message into the interpreter window. Text copied in from outside may need to be stripped of the newline character (such as <span class="literal">\r\n</span> or <span class="literal">\n</span>), placed wherever the carriage return was used.</p>&#13;
<p class="indent">Of course, only characters that occur in <em>The Lost World</em> can be encrypted. The program will warn you of exceptions and then replace missing characters with a space.</p>&#13;
<p class="indent">To be sneaky, you don’t want to save plaintext or ciphertext messages to a file. Cutting and pasting from the shell is the way to go. Just remember to copy something new when you’re finished so you don’t leave incriminating evidence on your clipboard!</p>&#13;
<p class="indent">If you want to get fancy, you can copy and paste text to the clipboard straight from Python using <span class="literal">pyperclip</span>, written by Al Sweigart. You can learn more at <em><a href="https://pypi.org/project/pyperclip/">https://pypi.org/project/pyperclip/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec30"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you got to work with <span class="literal">defaultdict</span> and <span class="literal">Counter</span> from the <span class="literal">collections</span> module; <span class="literal">choice()</span> from the <span class="literal">random</span> module; and <span class="literal">replace()</span>, <span class="literal">enumerate()</span>, <span class="literal">ord()</span>, and <span class="literal">repr()</span> from the Python Standard Library. The result was an encryption program, based on the one-time pad technique, that produces unbreakable ciphertext.</p>&#13;
<h3 class="h3" id="ch00lev1sec31"><strong>Further Reading</strong></h3>&#13;
<p class="noindent"><em>The Key to Rebecca</em> (Penguin Random House, 1980), by Ken Follett, is an exciting novel noted for its depth of historical detail, accurate descriptions of Cairo in World War II, and thrilling espionage storyline.</p>&#13;
<p class="indent"><em>The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography</em> (Anchor, 2000), by Simon Singh, is an interesting review of cryptography through the ages, including a discussion of the one-time pad.</p>&#13;
<p class="indent">If you enjoy working with ciphers, check out <em>Cracking Codes with Python</em> (No Starch Press, 2018), by Al Sweigart. Aimed at beginners in both cryptography and Python programming, this book covers many cipher types, including reverse, Caesar, transposition, substitution, affine, and Vigenère.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/><em>Impractical Python Projects: Playful Programming Activities to Make You Smarter</em>(No Starch Press, 2019), by Lee Vaughan, includes additional ciphers such as the Union route cipher, the rail fence cipher, and the Trevanion null cipher as well as a technique for writing with invisible electronic ink.</p>&#13;
<h3 class="h3" id="ch00lev1sec32"><strong>Practice Project: Charting the Characters</strong></h3>&#13;
<p class="noindent">If you have <span class="literal">matplotlib</span> installed (see “Installing the Python Libraries” on <a href="ch01.xhtml#page_6">page 6</a>), you can visually represent the available characters in <em>The Lost World</em>, along with their frequency of occurrence, using a bar chart. This can complement the shell printout of each character and its count currently used in the <em>rebecca.py</em> program.</p>&#13;
<p class="indent">The internet is rife with example code for <span class="literal">matplotlib</span> plots, so just search for <em>make a simple bar chart matplotlib</em>. You’ll want to sort the counts in descending order before plotting.</p>&#13;
<p class="indent">The mnemonic for remembering the most common letters in English is “etaoin.” If you plot in descending order, you’ll see that <em>The Lost World</em> dataset is no exception (<a href="ch04.xhtml#ch04fig2">Figure 4-2</a>)!</p>&#13;
<div class="image"><img src="../images/fig04_02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch04fig2"/>Figure 4-2: Frequency of occurrence of characters in the digital version of <span class="normal">The Lost World</span></p>&#13;
<p class="indent">Note that the most common character is a space. This makes it easy to encrypt spaces, further confounding any cryptanalysis!</p>&#13;
<p class="indent">You can find a solution, <em>practice_barchart.py</em>, in the appendix and on the book’s website.</p>&#13;
<h3 class="h3" id="ch00lev1sec33"><strong>Practice Project: Sending Secrets the WWII Way</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_93"/>According to the Wikipedia article on <em>Rebecca</em> (<em><a href="https://en.wikipedia.org/wiki/Rebecca_(novel">https://en.wikipedia.org/wiki/Rebecca_(novel</a>)</em>), the Germans in North Africa in World War II really did attempt to use the novel as the key to a book code. Rather than encode the message letter by letter, sentences would be made using single words in the book, referred to by page number, line, and position in the line.</p>&#13;
<p class="indent">Copy and edit the <em>rebecca.py</em> program so that it uses words rather than letters. To get you started, here’s how to load the text file as a list of words, rather than characters, using list comprehension:</p>&#13;
<pre>with open('lost.txt') as f:&#13;
  words = [word.lower() for line in f for word in line.split()]&#13;
  words_no_punct = ["".join(char for char in word if char.isalpha())&#13;
                for word in words]&#13;
&#13;
print(words_no_punct[:20])  # Print first 20 words as a QC check</pre>&#13;
<p class="indent">The output should look like this:</p>&#13;
<pre>['i', 'have', 'wrought', 'my', 'simple', 'plan', 'if', 'i', 'give', 'one',&#13;
'hour', 'of', 'joy', 'to', 'the', 'boy', 'whos', 'half', 'a', 'man']</pre>&#13;
<p class="indent">Note that all punctuation, including apostrophes, has been removed. Messages will need to follow this convention.</p>&#13;
<p class="indent">You’ll also need to handle words, such as proper names and place names, that don’t occur in <em>The Lost World</em>. One approach would be a “first-letter mode” where the recipient uses only the first letter of each word between flags. The flags should be commonly occurring words, like <em>a</em> and <em>the</em>, doubled. Alternate their use to make it easier to identify the start and end flags. In this case, <em>a a</em> indicates the start of first-letter mode, and <em>the the</em> indicates the end. For example, to handle the phrase <em>Sidi Muftah with ten tanks</em>, first run it straight up to identify missing words.</p>&#13;
<pre>Enter plaintext or ciphertext: <span class="codestrong1">sidi muftah with ten tanks</span>&#13;
Enter 'encrypt' or 'decrypt': <span class="codestrong1">encrypt</span>&#13;
Shift value (1-365) = <span class="codestrong1">5</span>&#13;
Enter filename with extension: <span class="codestrong1">lost.txt</span>&#13;
&#13;
Character sidi not in dictionary.&#13;
&#13;
Character muftah not in dictionary.&#13;
&#13;
Character tanks not in dictionary.&#13;
&#13;
encrypted ciphertext = &#13;
 [23371, 7491]&#13;
&#13;
decrypted plaintext = &#13;
with ten</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>With the missing words identified, reword the message to spell them using first-letter mode. I’ve highlighted the first letters in gray in the following snippet:</p>&#13;
<pre>Enter plaintext or ciphertext: <span class="codestrong1">a a</span> <span class="codestrong1"><span class="gray">s</span></span><span class="codestrong1">o</span> <span class="codestrong1"><span class="gray">i</span></span><span class="codestrong1">f</span> <span class="codestrong1"><span class="gray">d</span></span><span class="codestrong1">o</span> <span class="codestrong1"><span class="gray">i</span></span><span class="codestrong1">n</span> <span class="codestrong1"><span class="gray">m</span></span><span class="codestrong1">y</span> <span class="codestrong1"><span class="gray">u</span></span><span class="codestrong1">nder</span> <span class="codestrong1"><span class="gray">f</span></span><span class="codestrong1">or</span> <span class="codestrong1"><span class="gray">t</span></span><span class="codestrong1">o</span> <span class="codestrong1"><span class="gray">a</span></span><span class="codestrong1">ll</span> <span class="codestrong1"><span class="gray">h</span></span><span class="codestrong1">e the the&#13;
with ten a a</span> <span class="codestrong1"><span class="gray">t</span></span><span class="codestrong1">ell</span> <span class="codestrong1"><span class="gray">a</span></span><span class="codestrong1">ll</span> <span class="codestrong1"><span class="gray">n</span></span><span class="codestrong1">ight</span> <span class="codestrong1"><span class="gray">k</span></span><span class="codestrong1">ind</span> <span class="codestrong1"><span class="gray">s</span></span><span class="codestrong1">o the the</span>&#13;
Enter 'encrypt' or 'decrypt': <span class="codestrong1">encrypt</span>&#13;
Shift value (1-365) = <span class="codestrong1">5</span>&#13;
Enter filename with extension: <span class="codestrong1">lost.txt</span>&#13;
&#13;
encrypted ciphertext = &#13;
 [29910, 70641, 30556, 60850, 72292, 32501, 6507, 18593, 41777, 23831, 41833,&#13;
16667, 32749, 3350, 46088, 37995, 12535, 30609, 3766, 62585, 46971, 8984,&#13;
44083, 43414, 56950]&#13;
&#13;
decrypted plaintext =&#13;
a a <span class="gray">s</span>o <span class="gray">i</span>f <span class="gray">d</span>o <span class="gray">i</span>n <span class="gray">m</span>y <span class="gray">u</span>nder <span class="gray">f</span>or <span class="gray">t</span>o <span class="gray">a</span>ll <span class="gray">h</span>e the the with ten a a <span class="gray">t</span>ell <span class="gray">a</span>ll <span class="gray">n</span>ight&#13;
<span class="gray">k</span>ind <span class="gray">s</span>o the the</pre>&#13;
<p class="indent">There are 1,864 occurrences of <em>a</em> and 4,442 of <em>the</em> in <em>The Lost World</em>. If you stick to short messages, you shouldn’t duplicate keys. Otherwise, you may need to use multiple flag characters or disable the <span class="literal">check-for-fail()</span> function and accept some duplicates.</p>&#13;
<p class="indent">Feel free to come up with your own method for handling problem words. As consummate planners, the Germans surely had <em>something</em> in mind or they wouldn’t have considered a book code in the first place!</p>&#13;
<p class="indent">You can find a simple first-letter solution, <em>practice_WWII_words.py</em>, in the appendix or online at <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
&#13;
</body></html>