<html><head></head><body>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Main Program Creating Shapes</b></i></p>
<p class="calibre1">Listing 9-5 shows the source of the main program, which creates a list of </p>
<p class="calibre1">randomly chosen shape objects. </p>
<p class="calibre1"><b class="calibre3">File: Shapes/Main_ShapesExample.py</b></p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import sys</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">from Square import *</p>
<p class="calibre1">from Circle import *</p>
<p class="calibre1">from Triangle import *</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1"># Set up the constants</p>
<p class="calibre1">WHITE = (255, 255, 255)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">N_SHAPES = 10</p>
<p class="calibre1"># Set up the window</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1"><b class="calibre3">190</b>   Chapter 9</p>
<p class="calibre1"><a id="p220"/>window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock = pygame.time.Clock()</p>
<p class="calibre1">shapesList = []</p>
<p class="calibre1">shapeClassesTuple = (Square, Circle, Triangle)</p>
<p class="calibre1">for i in range(0, N_SHAPES): 1</p>
<p class="calibre1">randomlyChosenClass = random.choice(shapeClassesTuple)</p>
<p class="calibre1">oShape = randomlyChosenClass (window, WINDOW_WIDTH, WINDOW_HEIGHT)</p>
<p class="calibre1">shapesList.append(oShape)</p>
<p class="calibre1">oStatusLine = pygwidgets.DisplayText(window, (4,4), </p>
<p class="calibre1">'Click on shapes', fontSize=28)</p>
<p class="calibre1"># Main loop</p>
<p class="calibre1">while True:</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if event.type == MOUSEBUTTONDOWN: 2</p>
<p class="calibre1"># Reverse order to check last drawn shape first</p>
<p class="calibre1">for oShape in reversed(shapesList): 3</p>
<p class="calibre1">if oShape.clickedInside(event.pos): 4</p>
<p class="calibre1">area = oShape.getArea() 5</p>
<p class="calibre1">area = str(area)</p>
<p class="calibre1">theType = oShape.getType()</p>
<p class="calibre1">newText = 'Clicked on a ' + theType + ' whose area is' + area)</p>
<p class="calibre1">oStatusLine.setValue(newText)</p>
<p class="calibre1">break # only deal with topmost shape</p>
<p class="calibre1"># Tell each shape to draw itself</p>
<p class="calibre1">window.fill(WHITE)</p>
<p class="calibre1">for oShape in shapesList:</p>
<p class="calibre1">oShape.draw()</p>
<p class="calibre1">oStatusLine.draw()</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)</p>
<p class="calibre1"> <i class="calibre4">Listing 9-5: The main program that creates random shapes from three classes</i></p>
<p class="calibre1">As we saw in <a href="index_split_001.html#p86">Chapter 4, w</a>henever we have a large number of objects to manage, the typical approach is to build a list of objects. So, before the </p>
<p class="calibre1">main loop starts, the program first builds a list of shapes 1 by randomly </p>
<p class="calibre1">choosing among a circle, a square, and a triangle; creating an object of that </p>
<p class="calibre1">type; and appending it to the list. Using this approach, we can then iterate </p>
<p class="calibre1">over the list and call methods of the same name in every object in the list. </p>
<p class="calibre1">Inside the main loop, the program checks for the mouse down event 2 </p>
<p class="calibre1">that happens when the user clicks. Whenever the event is detected, the code </p>
<p class="calibre1">iterates through the shapesList 3 and calls the clickedInside() 4 method </p>
<p class="calibre1">for each shape. Because of polymorphism, it doesn’t matter which class the </p>
<p class="calibre1">object was instantiated from. Again, the key is that the implementation of </p>
<p class="calibre1">the clickedInside() method can be different for different classes. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">191</b></p>
<p class="calibre1"><a id="p221"/>When any clickedInside() method returns True 5, we call the getArea() then getType() methods of that object, without worrying about which type of </p>
<p class="calibre1">object was clicked on. </p>
<p class="calibre1">Here is the output of a typical run, after clicking on a few of the differ-</p>
<p class="calibre1">ent shapes:</p>
<p class="calibre1">Clicked on a Circle whose area is 5026.544</p>
<p class="calibre1">Clicked on a Square whose area is 1600</p>
<p class="calibre1">Clicked on a Triangle whose area is 1982.5</p>
<p class="calibre1">Clicked on a Square whose area is 1600</p>
<p class="calibre1">Clicked on a Square whose area is 100</p>
<p class="calibre1">Clicked on a Triangle whose area is 576.0</p>
<p class="calibre1">Clicked on a Circle whose area is 3019.06799</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Extending a Pattern</b></i></p>
<p class="calibre1">Building classes with commonly named methods creates a consistent pat-</p>
<p class="calibre1">tern that allows us to easily extend the program. For example, to add the </p>
<p class="calibre1">ability for our program to include ellipses, we would build an Ellipse class </p>
<p class="calibre1">that implements the getArea(), clickedInside(), draw(), and getType() meth-</p>
<p class="calibre1">ods. (The code of the clickedInside() method might be mathematically com-</p>
<p class="calibre1">plicated for an ellipse!) </p>
<p class="calibre1">Once we’ve written the code of the Ellipse class, the only change we </p>
<p class="calibre1">need to make to the setup code is to add Ellipse to the tuple of shape classes </p>
<p class="calibre1">to choose from. The code in the main loop that does the checking for clicks, </p>
<p class="calibre1">gets the area of the shape, and so on will not need to change at all. </p>
<p class="calibre1">This example demonstrates two important features of polymorphism:</p>
<p class="calibre1">•  Polymorphism extends the concept of abstraction discussed in </p>
<p class="calibre1"><a href="index_split_003.html#p192">Chapter 8 t</a>o a collection of classes. If multiple classes have the same interfaces for their methods, the client programmer can ignore the </p>
<p class="calibre1">implementation of those methods in all the classes. </p>
<p class="calibre1">•  Polymorphism can make client programming easier. If a client pro-</p>
<p class="calibre1">grammer is already familiar with the interfaces provided by one or </p>
<p class="calibre1">more classes, then calling the methods of another polymorphic class </p>
<p class="calibre1">should as be simple as following the pattern. </p>
<p class="calibre1"><b class="calibre3">pygwidgets Exhibits Polymorphism</b></p>
<p class="calibre1">All the classes in pygwidgets were designed to use polymorphism, and they </p>
<p class="calibre1">all implement two common methods. The first is the handleEvent() method </p>
<p class="calibre1">we first used i<a href="index_split_002.html#p150">n Chapter 6, w</a>hich takes an event object as a parameter. </p>
<p class="calibre1">Each class must contain its own code in this method to handle any event </p>
<p class="calibre1">that  pygame may generate. Each time through the main loop, client pro-</p>
<p class="calibre1">grams need to call the handleEvent() method for every instance of every </p>
<p class="calibre1">object instantiated from pygwidgets. </p>
<p class="calibre1"><b class="calibre3">192</b>   Chapter 9</p>
<p class="calibre1"><a id="p222"/>Second is the draw() method, which draws images to the window. A typical drawing portion of a program that uses pygwidgets might look like this:</p>
<p class="calibre1">inputTextA.draw()</p>
<p class="calibre1">inputTextB.draw()</p>
<p class="calibre1">displayTextA.draw()</p>
<p class="calibre1">displayTextB.draw()</p>
<p class="calibre1">restartButton.draw()</p>
<p class="calibre1">checkBoxA.draw()</p>
<p class="calibre1">checkBoxB.draw()</p>
<p class="calibre1">radioCustom1.draw()</p>
<p class="calibre1">radioCustom2.draw()</p>
<p class="calibre1">radioCustom3.draw()</p>
<p class="calibre1">checkBoxC.draw()</p>
<p class="calibre1">radioDefault1.draw()</p>
<p class="calibre1">radioDefault2.draw()</p>
<p class="calibre1">radioDefault3.draw()</p>
<p class="calibre1">statusButton.draw()</p>
<p class="calibre1">From the client’s point of view, each line just calls the draw() method and </p>
<p class="calibre1">passes in nothing. From an internal point of view, the code to implement </p>
<p class="calibre1">each of these methods is very different. The draw() method of the TextButton </p>
<p class="calibre1">class is completely different from that of the InputText class, for instance. </p>
<p class="calibre1">Additionally, all widgets that manage a value contain a setValue() and </p>
<p class="calibre1">optionally a getValue() method. For example, to get the text the user enters </p>
<p class="calibre1">into an InputText widget, you call the getValue() getter method. Radio button </p>
<p class="calibre1">and checkbox widgets also have a getValue() method to get their current val-</p>
<p class="calibre1">ues. To put new text into a DisplayText widget, you call the setValue() setter </p>
<p class="calibre1">method, passing in the new text. Radio button and checkbox widgets can </p>
<p class="calibre1">be set with a call to their setValue() method. </p>
<p class="calibre1">Polymorphism allows client programmers to feel comfortable with a </p>
<p class="calibre1">collection of classes. When clients see a pattern, like using methods named </p>
<p class="calibre1">handleEvent() and draw(), it makes it easy for them to predict how to use a </p>
<p class="calibre1">new class in the same collection. </p>
<p class="calibre1">As of this writing, the pygwidgets package does not provide either a hori-</p>
<p class="calibre1">zontal or a vertical Slider class widget to allow a user to easily select from a </p>
<p class="calibre1">range of numbers. If I were to add these widgets, they would certainly con-</p>
<p class="calibre1">tain the following: a handleEvent() method, where all user interaction would </p>
<p class="calibre1">take place; a getValue() and a setValue() method to get and set a current </p>
<p class="calibre1">value for the Slider;  and a draw() method. </p>
<p class="calibre1"><b class="calibre3">Polymorphism for Operators</b></p>
<p class="calibre1">Python also exhibits polymorphism with operators. Consider the following </p>
<p class="calibre1">example with the + operator:</p>
<p class="calibre1">value1 = 4</p>
<p class="calibre1">value2 = 5</p>
<p class="calibre1">result = value1 + value2</p>
<p class="calibre1">print(result)</p>
<p class="calibre1">Polymorphism   <b class="calibre3">193</b></p>
<p class="calibre1"><a id="p223"/>which prints:</p>
<p class="calibre1">9</p>
<p class="calibre1">The + operator here clearly means “add” in a mathematic sense </p>
<p class="calibre1">because both variables contain integer values. But now consider this second </p>
<p class="calibre1">example:</p>
<p class="calibre1">value1 = 'Joe' </p>
<p class="calibre1">value2 = 'Schmoe' </p>
<p class="calibre1">result = value1 + value2</p>
<p class="calibre1">print(result)</p>
<p class="calibre1">which prints:</p>
<p class="calibre1">JoeSchmoe</p>
<p class="calibre1">The line result = value1 + value2 is exactly the same as in the first exam-</p>
<p class="calibre1">ple, but it performs a completely different operation. With string values, the </p>
<p class="calibre1">+ operator performs a string concatenation. The same operator was used, </p>
<p class="calibre1">but a different action was performed. </p>
<p class="calibre1">This technique of having multiple meanings for an operator is com-</p>
<p class="calibre1">monly known as  <i class="calibre4">operator overloading</i>. For some classes, the ability to overload operators adds highly useful features and greatly improves the readability </p>
<p class="calibre1">of client code. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Magic Methods </b></i></p>
<p class="calibre1">Python reserves method names with the unusual form of two underscores, </p>
<p class="calibre1">some name, and two underscores for a particular purpose:</p>
<p class="calibre1">__ <i class="calibre4">&lt;someName&gt; </i> __()</p>
<p class="calibre1">These are officially called  <i class="calibre4">special methods</i> but are more commonly </p>
<p class="calibre1">referred to by Python programmers as  <i class="calibre4">magic methods</i>. Many of these are </p>
<p class="calibre1">already defined, such as __init__(), which is called whenever you instanti-</p>
<p class="calibre1">ate an object from a class, but all other names in this style are available for </p>
<p class="calibre1">future expansion. These are known as “magic” methods because Python </p>
<p class="calibre1">calls them behind the scenes whenever it detects an operator, a special </p>
<p class="calibre1">function call, or some other special circumstance. They are not intended to </p>
<p class="calibre1">be called by client code directly. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">Because the names of these magic methods are difficult to pronounce—for example,</i> <i class="calibre4">__init__() is read as “underscore underscore init underscore underscore”—Python</i> <i class="calibre4">programmers often refer to these as </i> dunder <i class="calibre4"> methods (a shortened version of </i> double underscore <i class="calibre4">). This method would be referred to as “dunder init.” </i></p>
<p class="calibre1"><b class="calibre3">194</b>   Chapter 9</p>
<p class="calibre1"><a id="p224"/>Continuing with the previous examples, we’ll look at how this works with the + operator. The built-in data types (integer, float, string, Boolean, </p>
<p class="calibre1">and so on) are actually implemented as classes in Python. We can see this </p>
<p class="calibre1">by testing with the built-in isinstance() function, which takes an object and </p>
<p class="calibre1">a class and returns True if the object was instantiated from the class or False </p>
<p class="calibre1">if not. These lines will both report True:</p>
<p class="calibre1">print(isinstance(123, int))</p>
<p class="calibre1">print(isinstance('some string', str))</p>
<p class="calibre1">The classes for the built-in data types contain a set of magic methods, </p>
<p class="calibre1">including ones for the basic math operators. When Python detects the + </p>
<p class="calibre1">operator with integers, it calls the magic method named __add__() in the </p>
<p class="calibre1">built-in integer class, which performs integer addition. When Python sees </p>
<p class="calibre1">the same operator used with strings, it calls the __add__() method in the </p>
<p class="calibre1">string class, which performs string concatenation. </p>
<p class="calibre1">This mechanism is generalized so that when Python encounters a + </p>
<p class="calibre1">operator when working with objects instantiated from your class, it will call </p>
<p class="calibre1">the __add__() method if one is present in your class. Therefore, as the class </p>
<p class="calibre1">developer, you can write code to invent a new meaning for this operator. </p>
<p class="calibre1">Each operator maps to a specific magic method name. While there are </p>
<p class="calibre1">many types of magic methods, let’s start with those related to the compari-</p>
<p class="calibre1">son operators. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Comparison Operator Magic Methods</b></i></p>
<p class="calibre1">Consider our Square class from Listing 9-2. You want client software to be </p>
<p class="calibre1">able to compare two Square objects to see if they are equal. It is up to you </p>
<p class="calibre1">to decide what “equal” means when comparing objects. For instance, you </p>
<p class="calibre1">might define it as two objects being the same color and at the same location </p>
<p class="calibre1">and with the same size. As a simple example, we’ll define two Square objects </p>
<p class="calibre1">as equal if they just have the same side length. This is easily implemented by </p>
<p class="calibre1">comparing the self.heightAndWidth instance variables of the two objects and </p>
<p class="calibre1">returning a Boolean. You could write your own equals() method, and client </p>
<p class="calibre1">software could then call it like this:</p>
<p class="calibre1">if oSquare1.equals(oSquare2):</p>
<p class="calibre1">This would work fine. However, it would be more natural for client soft-</p>
<p class="calibre1">ware to use the standard == comparison operator: </p>
<p class="calibre1">if oSquare1 == oSquare2:</p>
<p class="calibre1">Written this way, Python translates the == operator into a call to a magic </p>
<p class="calibre1">method of the first object. In this case, Python will attempt to call a magic </p>
<p class="calibre1">method named __eq__() in the Square class. Table 9-1 shows the magic meth-</p>
<p class="calibre1">ods for all the comparison operators. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">195</b></p>
<p class="calibre1"><a id="p225"/><b class="calibre3">Table 9-1:</b> Comparison Operator Symbols, Meanings, and Magic Method Names <b class="calibre3">Symbol</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Magic method name</b></p>
<p class="calibre1">==</p>
<p class="calibre1">Equal to</p>
<p class="calibre1">__eq__()</p>
<p class="calibre1">!=</p>
<p class="calibre1">Not equal to</p>
<p class="calibre1">__ne__()</p>
<p class="calibre1">&lt; </p>
<p class="calibre1">Less than</p>
<p class="calibre1">__lt__()</p>
<p class="calibre1">&gt; </p>
<p class="calibre1">Greater than</p>
<p class="calibre1">__gt__()</p>
<p class="calibre1">&lt;=</p>
<p class="calibre1">Less than or equal to</p>
<p class="calibre1">__le__()</p>
<p class="calibre1">&gt;=</p>
<p class="calibre1">Greater than or equal to</p>
<p class="calibre1">__ge__()</p>
<p class="calibre1">To allow the == comparison operator to check for equality between two </p>
<p class="calibre1">Square objects, you would write a method like this in the Square class:</p>
<p class="calibre1">def __eq__(self, oOtherSquare):</p>
<p class="calibre1">if not isinstance(oOtherSquare, Square):</p>
<p class="calibre1">raise TypeError('Second object was not a Square')</p>
<p class="calibre1">if self.heightAndWidth == oOtherSquare.heightAndWidth:</p>
<p class="calibre1">return True  # match</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False  # not a match</p>
<p class="calibre1">When Python detects an == comparison where the first object is a Square, </p>
<p class="calibre1">it calls this method in the Square class. Since Python is a loosely typed lan-</p>
<p class="calibre1">guage (it doesn’t require you to define variable types), the second parame-</p>
<p class="calibre1">ter could be of any data type. However, in order for the comparison to work </p>
<p class="calibre1">correctly, the second parameter must also be a Square object. We perform </p>
<p class="calibre1">a check using the isinstance() function, which works with programmer-</p>
<p class="calibre1">defined classes the same way it works with built-in classes. If the second </p>
<p class="calibre1">object is not a Square, we raise an exception. </p>
<p class="calibre1">We then compare the heightAndWidth of the current object (self) with </p>
<p class="calibre1">the heightAndWidth of a second object (oOtherSquare). This is a case where </p>
<p class="calibre1">using direct access to the instance variables of two objects is perfectly </p>
<p class="calibre1">acceptable, because both objects are of the same type, and therefore they </p>
<p class="calibre1">must contain the same instance variables. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">A Rectangle Class with Magic Methods</b></i></p>
<p class="calibre1">To expand, we’ll build a program that draws a number of rectangle </p>
<p class="calibre1">shapes using a Rectangle class. The user will be able to click on any two </p>
<p class="calibre1">rectangles, and the program will report if the rectangles have the same </p>
<p class="calibre1">area or if the area of the first one is larger or smaller than the area of the </p>
<p class="calibre1">second rectangle. We’ll use the ==, &lt;, and &gt; operators and expect the result </p>
<p class="calibre1">to be a Boolean True or False for each comparison. Listing 9-6 contains </p>
<p class="calibre1">the code of the Rectangle class, which implements magic methods for these </p>
<p class="calibre1">operators. </p>
<p class="calibre1"><b class="calibre3">196</b>   Chapter 9</p>
<p class="calibre1"><a id="p226"/><b class="calibre3">File: MagicMethods/Rectangle/Rectangle.py</b></p>
<p class="calibre1"># Rectangle class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import random</p>
<p class="calibre1"># Set up the colors</p>
<p class="calibre1">RED = (255, 0, 0)</p>
<p class="calibre1">GREEN = (0, 255, 0)</p>
<p class="calibre1">BLUE = (0, 0, 255)</p>
<p class="calibre1">class Rectangle():</p>
<p class="calibre1">def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.width = random.choice((20, 30, 40))</p>
<p class="calibre1">self.height = random.choice((20, 30, 40))</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(0, 400)</p>
<p class="calibre1">self.y = random.randrange(0, 400)</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, self.width, self.height)</p>
<p class="calibre1">self.area = self.width * self.height</p>
<p class="calibre1">def clickedInside(self, mousePoint):</p>
<p class="calibre1">clicked = self.rect.collidepoint(mousePoint)</p>
<p class="calibre1">return clicked</p>
<p class="calibre1"># Magic method called when you compare</p>
<p class="calibre1"># two Rectangle objects with the == operator</p>
<p class="calibre1">def __eq__ (self, oOtherRectangle): 1</p>
<p class="calibre1">if not isinstance(oOtherRectangle, Rectangle):</p>
<p class="calibre1">raise TypeError('Second object was not a Rectangle')</p>
<p class="calibre1">if self.area == oOtherRectangle.area:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1"># Magic method called when you compare</p>
<p class="calibre1"># two Rectangle objects with the &lt; operator</p>
<p class="calibre1">def __lt__(self, oOtherRectangle): 2</p>
<p class="calibre1">if not isinstance(oOtherRectangle, Rectangle):</p>
<p class="calibre1">raise TypeError('Second object was not a Rectangle')</p>
<p class="calibre1">if self.area &lt; oOtherRectangle.area:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1"># Magic method called when you compare </p>
<p class="calibre1"># two Rectangle objects with the &gt; operator</p>
<p class="calibre1">def __gt__(self, oOtherRectangle): 3</p>
<p class="calibre1">if not isinstance(oOtherRectangle, Rectangle):</p>
<p class="calibre1">raise TypeError('Second object was not a Rectangle')</p>
<p class="calibre1">Polymorphism   <b class="calibre3">197</b></p>
<p class="calibre1"><a id="p227"/>        if self.area &gt; oOtherRectangle.area:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1">def getArea(self):</p>
<p class="calibre1">return self.area</p>
<p class="calibre1">def draw(self):</p>
<p class="calibre1">pygame.draw.rect(self.window, self.color, (self.x, self.y, self.width, self.height)) <i class="calibre4">Listing 9-6: The Rectangle class</i></p>
<p class="calibre1">The methods __eq__() 1, __lt__() 2, and __gt__() 3 allow client code </p>
<p class="calibre1">to use standard comparison operators between Rectangle objects. To com-</p>
<p class="calibre1">pare two rectangles for equality, you would write:</p>
<p class="calibre1">if oRectangle1 == oRectangle2:</p>
<p class="calibre1">When this line runs, the __eq__() method of the first object is called, </p>
<p class="calibre1">and the second object is passed in as the second parameter. The function </p>
<p class="calibre1">returns either True or False. Similarly, to compare for less than, you would </p>
<p class="calibre1">write a line like this:</p>
<p class="calibre1">if oRectangle1 &lt; oRectangle2:</p>
<p class="calibre1">The __lt__() method then checks for the area of the first rectangle </p>
<p class="calibre1">being less than the area of the second rectangle. If client code used the &gt; </p>
<p class="calibre1">operator to compare two rectangles, the __gt__() method would be called. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main Program Using Magic Methods</b></i></p>
<p class="calibre1">Listing 9-7 shows the code of the main program that tests the magic methods. </p>
<p class="calibre1"><b class="calibre3">File: MagicMethods/Rectangle/Main_RectangleExample.py</b></p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import sys</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">from Rectangle import *</p>
<p class="calibre1"># Set up the constants</p>
<p class="calibre1">WHITE = (255, 255, 255)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">N_RECTANGLES = 10</p>
<p class="calibre1">FIRST_RECTANGLE = 'first' </p>
<p class="calibre1">SECOND_RECTANGLE = 'second' </p>
<p class="calibre1"># Set up the window</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1"><b class="calibre3">198</b>   Chapter 9</p>
<p class="calibre1"><a id="p228"/>window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), 0, 32) clock = pygame.time.Clock()</p>
<p class="calibre1">rectanglesList = []</p>
<p class="calibre1">for i in range(0, N_RECTANGLES):</p>
<p class="calibre1">oRectangle = Rectangle(window)</p>
<p class="calibre1">rectanglesList.append(oRectangle)</p>
<p class="calibre1">whichRectangle = FIRST_RECTANGLE</p>
<p class="calibre1"># Main loop</p>
<p class="calibre1">while True:</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if event.type == MOUSEBUTTONDOWN:</p>
<p class="calibre1">for oRectangle in rectanglesList:</p>
<p class="calibre1">if oRectangle.clickedInside(event.pos):</p>
<p class="calibre1">print('Clicked on', whichRectangle, 'rectangle.')</p>
<p class="calibre1">if whichRectangle == FIRST_RECTANGLE:</p>
<p class="calibre1">oFirstRectangle = oRectangle 1</p>
<p class="calibre1">whichRectangle = SECOND_RECTANGLE</p>
<p class="calibre1">elif whichRectangle == SECOND_RECTANGLE:</p>
<p class="calibre1">oSecondRectangle2 = oRectangle 2</p>
<p class="calibre1"># User has chosen 2 rectangles, let's compare</p>
<p class="calibre1">if oFirstRectangle == oSecondRectangle: 3</p>
<p class="calibre1">print('Rectangles are the same size.')</p>
<p class="calibre1">elif oFirstRectangle &lt; oSecondRectangle: 4</p>
<p class="calibre1">print('First rectangle is smaller than second rectangle.')</p>
<p class="calibre1">else:  # must be larger 5 </p>
<p class="calibre1">print('First rectangle is larger than second rectangle.')</p>
<p class="calibre1">whichRectangle = FIRST_RECTANGLE</p>
<p class="calibre1"># Clear the window and draw all rectangles</p>
<p class="calibre1">window.fill(WHITE)</p>
<p class="calibre1">for oRectangle in rectanglesList: 6 </p>
<p class="calibre1">oRectangle.draw()</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)</p>
<p class="calibre1"> <i class="calibre4">Listing 9-7: The main program that draws and then compares Rectangle objects</i></p>
<p class="calibre1">The user of the program clicks on pairs of rectangles to compare their </p>
<p class="calibre1">sizes. We store the selected rectangles in two variables 1 2. </p>
<p class="calibre1">We check for equality using the == operator 3, which resolves to calling </p>
<p class="calibre1">the __eq__() method of the Rectangle class. If the rectangles are the same </p>
<p class="calibre1">size, we print out an appropriate message. If not, we check if the first rect-</p>
<p class="calibre1">angle is smaller than the second using the &lt; operator 4, which results in </p>
<p class="calibre1">Polymorphism   <b class="calibre3">199</b></p>
<p class="calibre1"><a id="p229"/>a call to the __lt__() method. If this comparison is also not True, we print the message for the first being larger than the second 5. We didn’t need to </p>
<p class="calibre1">use the &gt; operator in this program; however, since other client code might </p>
<p class="calibre1">implement size comparisons differently, we’ve included the __gt__() method </p>
<p class="calibre1">for completeness. </p>
<p class="calibre1">Finally, we draw all the rectangles in our list 6. </p>
<p class="calibre1">Because we included the magic methods __eq__(), __lt__(), and __gt__() </p>
<p class="calibre1">in the Rectangle class, we were able to use the standard comparison opera-</p>
<p class="calibre1">tors in a highly intuitive and readable way. </p>
<p class="calibre1">Here is the output from clicking on a number of different rectangles:</p>
<p class="calibre1">Clicked on first rectangle. </p>
<p class="calibre1">Clicked on second rectangle. </p>
<p class="calibre1">Rectangles are the same size. </p>
<p class="calibre1">Clicked on first rectangle. </p>
<p class="calibre1">Clicked on second rectangle. </p>
<p class="calibre1">First rectangle is smaller than second rectangle. </p>
<p class="calibre1">Clicked on first rectangle. </p>
<p class="calibre1">Clicked on second rectangle. </p>
<p class="calibre1">First rectangle is larger than second rectangle. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Math Operator Magic Methods</b></i></p>
<p class="calibre1">You can write additional magic methods to define what happens when cli-</p>
<p class="calibre1">ent code uses the other arithmetic operators between objects instantiated </p>
<p class="calibre1">from your class. </p>
<p class="calibre1">Table 9-2 shows the methods that are called for the basic arithmetic </p>
<p class="calibre1">operators. </p>
<p class="calibre1"><b class="calibre3">Table 9-2:</b> Math Operator Symbols, Meanings, and Magic Method Names</p>
<p class="calibre1"><b class="calibre3">Symbol</b></p>
<p class="calibre1"><b class="calibre3">Meaning</b></p>
<p class="calibre1"><b class="calibre3">Magic method name</b></p>
<p class="calibre1">+</p>
<p class="calibre1">Addition</p>
<p class="calibre1">__add__()</p>
<p class="calibre1">-</p>
<p class="calibre1">Subtraction</p>
<p class="calibre1">__sub__()</p>
<p class="calibre1">*</p>
<p class="calibre1">Multiplication</p>
<p class="calibre1">__mul__()</p>
<p class="calibre1">/</p>
<p class="calibre1">Division (floating-point </p>
<p class="calibre1">__truediv__()</p>
<p class="calibre1">result)</p>
<p class="calibre1">//</p>
<p class="calibre1">Integer division</p>
<p class="calibre1">__floordiv__()</p>
<p class="calibre1">%</p>
<p class="calibre1">Modulo</p>
<p class="calibre1">__mod__()</p>
<p class="calibre1">abs</p>
<p class="calibre1">Absolute value</p>
<p class="calibre1">__abs__()</p>
<p class="calibre1">For example, to handle the + operator, you would implement a method </p>
<p class="calibre1">in your class like this:</p>
<p class="calibre1">def __add__(self, oOther):</p>
<p class="calibre1"># Your code here to determine what happens when code   </p>
<p class="calibre1"># attempts to add two of these objects. </p>
<p class="calibre1"><b class="calibre3">200</b>   Chapter 9</p>
<p class="calibre1"><a id="p230"/>A full list of all the magic or dunder methods can be found in the official documentation at <a href="https://docs.python.org/3/reference/datamodel.html"> <i class="calibre4">https://docs.python.org/3/reference/datamodel.html</i></a>. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Vector Example</b></i></p>
<p class="calibre1">In math, a  <i class="calibre4">vector</i> is an ordered pair of x and y values that is often repre-</p>
<p class="calibre1">sented on a graph as a directed line segment. In this section, we’ll build </p>
<p class="calibre1">a class that uses math operator magic methods to operate on vectors. </p>
<p class="calibre1">There are a number of math operations that can be performed on vectors. </p>
<p class="calibre1">Figure 9-2 shows an example of adding two vectors. </p>
<p class="calibre1">y–axis</p>
<p class="calibre1">6</p>
<p class="calibre1">5</p>
<p class="calibre1">4</p>
<p class="calibre1">=Vector 4, 5</p>
<p class="calibre1">3</p>
<p class="calibre1">Vector 1, 3</p>
<p class="calibre1">2</p>
<p class="calibre1">plus</p>
<p class="calibre1">1</p>
<p class="calibre1">Vector 3, 2</p>
<p class="calibre1">x–axis</p>
<p class="calibre1">–6  –5 </p>
<p class="calibre1">–4 </p>
<p class="calibre1">–3 </p>
<p class="calibre1">–2 </p>
<p class="calibre1">–1 </p>
<p class="calibre1"/>
<p class="calibre1">1 </p>
<p class="calibre1">2 </p>
<p class="calibre1">3 </p>
<p class="calibre1">4 </p>
<p class="calibre1">5 </p>
<p class="calibre1">6</p>
<p class="calibre1">–1</p>
<p class="calibre1">–2</p>
<p class="calibre1">–3</p>
<p class="calibre1">–4</p>
<p class="calibre1">–5</p>
<p class="calibre1">–6</p>
<p class="calibre1"> <i class="calibre4">Figure 9-2: Vector addition in Cartesian coordinates</i></p>
<p class="calibre1">Adding two vectors results in a new vector whose x value is the sum of </p>
<p class="calibre1">the x values of the two added vectors and whose y value is the sum of the y </p>
<p class="calibre1">values of the two added vectors. In Figure 9-2, we add the vector (3, 2) and </p>
<p class="calibre1">the vector (1, 3) to create a vector (4, 5). </p>
<p class="calibre1">Two vectors are considered equal if their x values are the same and </p>
<p class="calibre1">their y values are the same. A vector’s size is computed to be the hypotenuse </p>
<p class="calibre1">of the right triangle with one side of length x and the second side of length </p>
<p class="calibre1">y. We can use the Pythagorean theorem to compute the length and use the </p>
<p class="calibre1">lengths to compare two vectors’ sizes. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">201</b></p>
<p class="calibre1"><a id="p231"/>Listing 9-8 is a Vector class that illustrates the appropriate magic methods for doing math and comparisons between two Vector objects. (Each of </p>
<p class="calibre1">these methods has additional code using a call to isinstance() to ensure that </p>
<p class="calibre1">the second object is a Vector. These checks are included in the download-</p>
<p class="calibre1">able file, but I have omitted them here to save space.)</p>
<p class="calibre1"><b class="calibre3">File: MagicMethods/Vectors/Vector.py</b></p>
<p class="calibre1"># Vector class</p>
<p class="calibre1">import math</p>
<p class="calibre1">class Vector():</p>
<p class="calibre1">'''The Vector class represents two values as a vector, </p>
<p class="calibre1">allows for many math calculations''' </p>
<p class="calibre1">def __init__(self, x, y):</p>
<p class="calibre1">self.x = x</p>
<p class="calibre1">self.y = y</p>
<p class="calibre1">1 def __add__(self, oOther):  # called for + operator</p>
<p class="calibre1">return Vector(self.x + oOther.x, self.y + oOther.y)</p>
<p class="calibre1">def __sub__(self, oOther):  # called for - operator</p>
<p class="calibre1">return Vector(self.x - oOther.x, self.y - oOther.y)</p>
<p class="calibre1">2 def __mul__(self, oOther):  # called for * operator</p>
<p class="calibre1"># Special code to allow for multiplying by a vector or a scalar</p>
<p class="calibre1">if isInstance(oOther, Vector):  # multiply two vectors</p>
<p class="calibre1">return Vector((self.x * oOther.x), (self.y * oOther.y))</p>
<p class="calibre1">elif isinstance(oOther, (int, float)):  # multiply by a scalar</p>
<p class="calibre1">return Vector((self.x * oOther), (self.y * oOther))</p>
<p class="calibre1">else:</p>
<p class="calibre1">raise TypeError('Second value must be a vector or scalar')</p>
<p class="calibre1">def __abs__(self):</p>
<p class="calibre1">return math.sqrt((self.x ** 2) + (self.y ** 2))</p>
<p class="calibre1">def __eq__(self, oOther):  # called for == operator</p>
<p class="calibre1">return (self.x == oOther.x) and (self.y == oOther.y)</p>
<p class="calibre1">def __ne__(self, oOther):  # called for != operator</p>
<p class="calibre1">return not (self == oOther)  # calls __eq__ method</p>
<p class="calibre1">def __lt__(self, oOther):  # called for &lt; operator</p>
<p class="calibre1">if abs(self) &lt; abs(oOther):  # calls __abs__ method</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1"/>
<p class="calibre1">def __gt__(self, oOther):  # called for &gt; operator</p>
<p class="calibre1">if abs(self) &gt; abs(oOther):  # calls __abs__ method</p>
<p class="calibre1"><b class="calibre3">202</b>   Chapter 9</p>
<p class="calibre1"><a id="p232"/>            return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1"> <i class="calibre4">Listing 9-8: The Vector class that implements a number of magic methods</i></p>
<p class="calibre1">This class implements arithmetic and comparison operators as magic </p>
<p class="calibre1">methods. Client code would use standard symbols for math and compari-</p>
<p class="calibre1">son between two Vector objects. For example, the addition of vectors in </p>
<p class="calibre1">Figure 9-2 could be handled like this:</p>
<p class="calibre1">oVector1 = Vector(3, 2)</p>
<p class="calibre1">oVector2 = Vector(1, 3)</p>
<p class="calibre1">oNewVector = oVector1 + oVector2  # use the + operator to add vectors</p>
<p class="calibre1">When the third line runs, the __add__() method 1is called to add the </p>
<p class="calibre1">two Vector objects, resulting in the creation of a new Vector object. There is a </p>
<p class="calibre1">special check in the __mul__() method 2 that allows the * operator to either </p>
<p class="calibre1">multiply two Vectors or multiply one Vector by a scalar value, depending on </p>
<p class="calibre1">the type of the second value. </p>
<p class="calibre1"><b class="calibre3">Creating a String Representation of Values in an Object</b></p>
<p class="calibre1">A standard approach to debugging is to add calls to print() to write out the </p>
<p class="calibre1">values of variables at certain points in your program:</p>
<p class="calibre1">print('My variable is', myVariable)</p>
<p class="calibre1">However, if you try to use print() to help you debug the contents of an </p>
<p class="calibre1">object, the results are not particularly helpful. For example, here we create </p>
<p class="calibre1">a Vector object and print it:</p>
<p class="calibre1">oVector = Vector(3, 4)  </p>
<p class="calibre1">print('My vector is', oVector)</p>
<p class="calibre1">This is what is printed:</p>
<p class="calibre1">&lt;Vector object at 0x10361b518&gt; </p>
<p class="calibre1">This tells us that we have an object instantiated from the Vector class </p>
<p class="calibre1">and shows the memory address of that object. However, in most cases, what </p>
<p class="calibre1">we really want to know are the values of the instance variables in the object </p>
<p class="calibre1">at that moment. Luckily, we can use magic methods for that. </p>
<p class="calibre1">There are two magic methods that can be useful in getting information </p>
<p class="calibre1">(as strings) from an object: </p>
<p class="calibre1">•  The __str__() method is used to create a string representation of an </p>
<p class="calibre1">object that can be read easily by humans. If client code makes a call to </p>
<p class="calibre1">the str() built-in function and passes in an object, Python will call the </p>
<p class="calibre1">magic method __str__() if it is present in that class. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">203</b></p>
<p class="calibre1"><a id="p233"/>•  The __repr__() method is used to create an unambiguous, possibly machine-readable string representation of the object. If client code </p>
<p class="calibre1">makes a call to the repr() built-in function and passes in an object, </p>
<p class="calibre1">Python will attempt to call the magic method __repr__() in that class, </p>
<p class="calibre1">if present. </p>
<p class="calibre1">I’ll show the __str__() method, as it’s more generally used for simple </p>
<p class="calibre1">debugging. When you call the print() function, Python calls the built-in </p>
<p class="calibre1">str() function to convert each argument into a string. For any argument </p>
<p class="calibre1">that does not have a __str__() method, this function formats a string that </p>
<p class="calibre1">contains the type of the object, the words “object at,” and the memory </p>
<p class="calibre1">address, then returns the resulting string. That’s why we see the earlier out-</p>
<p class="calibre1">put containing the memory address. </p>
<p class="calibre1">Instead, you can write your own version of __str__() and have it produce </p>
<p class="calibre1">whatever string you want to help debug the code of your class. The general </p>
<p class="calibre1">approach is to build a string that contains the values of any instance vari-</p>
<p class="calibre1">ables that you want to see and return that string to be printed. For example, </p>
<p class="calibre1">we can add the following method to the Vector class from Listing 9-8 to get </p>
<p class="calibre1">information about any Vector object:</p>
<p class="calibre1">class Vector():</p>
<p class="calibre1">--- snipped all previous methods ---</p>
<p class="calibre1">def __str__(self):</p>
<p class="calibre1">return 'This vector has the value (' + str(self.x) + ', ' + str(self.y) + ')' </p>
<p class="calibre1">If you instantiate a Vector, you can then call the print() function and </p>
<p class="calibre1">pass in a  Vector object: </p>
<p class="calibre1">oVector = Vector(10, 7)</p>
<p class="calibre1">print(oVector)</p>
<p class="calibre1">Rather than just printing the memory address of the Vector object, you </p>
<p class="calibre1">will get a nicely formatted report of the values of the two instance variables </p>
<p class="calibre1">contained in the object:</p>
<p class="calibre1">This vector has the value (10, 7)</p>
<p class="calibre1">The main code in Listing 9-9 creates a few Vector objects, does some </p>
<p class="calibre1">vector math, and prints out the results of some Vector calculations. </p>
<p class="calibre1"><b class="calibre3">File: Vectors/Main_Vectors.py</b></p>
<p class="calibre1"># Vector test code</p>
<p class="calibre1">from Vector import *</p>
<p class="calibre1">v1 = Vector(3, 4)</p>
<p class="calibre1">v2 = Vector(2, 2)</p>
<p class="calibre1">v3 = Vector(3, 4)</p>
<p class="calibre1"><b class="calibre3">204</b>   Chapter 9</p>
<p class="calibre1"><a id="p234"/># These lines print Boolean or numeric values</p>
<p class="calibre1">print(v1 == v2) </p>
<p class="calibre1">print(v1 == v3) </p>
<p class="calibre1">print(v1 &lt; v2)  </p>
<p class="calibre1">print(v1 &gt; v2) </p>
<p class="calibre1">print(abs(v1))  </p>
<p class="calibre1">print(abs(v2))  </p>
<p class="calibre1">print() </p>
<p class="calibre1"># These lines print Vectors (calls the __str__() method)</p>
<p class="calibre1">print('Vector 1:', v1) </p>
<p class="calibre1">print('Vector 2:', v2) </p>
<p class="calibre1">print('Vector 1 + Vector 2:', v1 + v2)  </p>
<p class="calibre1">print('Vector 1 - Vector 2:', v1 - v2)  </p>
<p class="calibre1">print('Vector 1 times Vector 2:', v1 * v2)  </p>
<p class="calibre1">print('Vector 2 times 5:', v1 * 5)  </p>
<p class="calibre1"> <i class="calibre4">Listing 9-9: Sample main code that creates and compares Vectors, does math, and prints</i> <i class="calibre4">Vectors</i></p>
<p class="calibre1">This generates the following output:</p>
<p class="calibre1">False</p>
<p class="calibre1">True</p>
<p class="calibre1">False</p>
<p class="calibre1">True</p>
<p class="calibre1">5.0</p>
<p class="calibre1">2.8284271247461903</p>
<p class="calibre1">Vector 1: This vector has the value (3, 4)</p>
<p class="calibre1">Vector 2: This vector has the value (2, 2)</p>
<p class="calibre1">Vector 1 + Vector 2: This vector has the value (5, 6)</p>
<p class="calibre1">Vector 1 - Vector 2: This vector has the value (1, 2)</p>
<p class="calibre1">Vector 1 times Vector 2: This vector has the value (6, 8)</p>
<p class="calibre1">Vector 2 times 5: This vector has the value (15, 20)</p>
<p class="calibre1">The first set of calls to print() output Boolean and numeric values, </p>
<p class="calibre1">which result from calling math and comparison operator magic methods. </p>
<p class="calibre1">In the second set, we print two Vector objects, then compute and print </p>
<p class="calibre1">some new Vectors. Internally, the print() function first calls Python’s str() </p>
<p class="calibre1">function for each item to be printed; that results in a call to the Vector’s </p>
<p class="calibre1">__str__() magic method, which creates a formatted string with the relevant </p>
<p class="calibre1">information. </p>
<p class="calibre1"><b class="calibre3">A Fraction Class with Magic Methods</b></p>
<p class="calibre1">Let’s put some of these magic methods together in a more complex exam-</p>
<p class="calibre1">ple. Listing 9-10 shows the code of a Fraction class. Each Fraction object is </p>
<p class="calibre1">made up of a numerator (top part) and a denominator (bottom part). The </p>
<p class="calibre1">class keeps track of a fraction by storing the separate parts in instance vari-</p>
<p class="calibre1">ables, along with the fraction’s approximate decimal value. The methods </p>
<p class="calibre1">Polymorphism   <b class="calibre3">205</b></p>
<p class="calibre1"><a id="p235"/>allow the caller to get the reduced value of the fraction, print the fraction along with its floating-point value, compare two fractions for equality, and </p>
<p class="calibre1">add two Fraction objects. </p>
<p class="calibre1"><b class="calibre3">File: MagicMethods/Fraction.py</b></p>
<p class="calibre1"># Fraction class</p>
<p class="calibre1">import math</p>
<p class="calibre1">class Fraction():</p>
<p class="calibre1">def __init__(self, numerator, denominator): 1</p>
<p class="calibre1">if not isinstance(numerator, int):</p>
<p class="calibre1">raise TypeError('Numerator', numerator, 'must be an integer')</p>
<p class="calibre1">if not isinstance(denominator, int):</p>
<p class="calibre1">raise TypeError('Denominator', denominator, 'must be an integer')</p>
<p class="calibre1">self.numerator = numerator</p>
<p class="calibre1">self.denominator = denominator</p>
<p class="calibre1"/>
<p class="calibre1"># Use the math package to find the greatest common divisor</p>
<p class="calibre1">greatestCommonDivisor = math.gcd(self.numerator, self.denominator)</p>
<p class="calibre1">if greatestCommonDivisor &gt; 1:</p>
<p class="calibre1">self.numerator = self.numerator // greatestCommonDivisor</p>
<p class="calibre1">self.denominator = self.denominator // greatestCommonDivisor</p>
<p class="calibre1">self.value = self.numerator / self.denominator</p>
<p class="calibre1"># Normalize the sign of the numerator and denominator</p>
<p class="calibre1">self.numerator = int(math.copysign(1.0, self.value)) * abs(self.numerator)</p>
<p class="calibre1">self.denominator = abs(self.denominator)</p>
<p class="calibre1">def getValue(self): 2</p>
<p class="calibre1">return self.value</p>
<p class="calibre1">def __str__(self): 3</p>
<p class="calibre1">'''Create a string representation of the fraction''' </p>
<p class="calibre1">output = '  Fraction: ' + str(self.numerator) + '/' + \</p>
<p class="calibre1">str(self.denominator) + '\n' + \</p>
<p class="calibre1">'  Value: ' + str(self.value) + '\n' </p>
<p class="calibre1">return output     </p>
<p class="calibre1"/>
<p class="calibre1">def __add__(self, oOtherFraction): 4</p>
<p class="calibre1">''' Add two Fraction objects''' </p>
<p class="calibre1">if not isinstance(oOtherFraction, Fraction):</p>
<p class="calibre1">raise TypeError('Second value in attempt to add is not a Fraction')</p>
<p class="calibre1"># Use the math package to find the least common multiple</p>
<p class="calibre1">newDenominator = math.lcm(self.denominator, oOtherFraction.denominator)</p>
<p class="calibre1"/>
<p class="calibre1">multiplicationFactor = newDenominator // self.denominator</p>
<p class="calibre1">equivalentNumerator = self.numerator * multiplicationFactor</p>
<p class="calibre1"/>
<p class="calibre1">otherMultiplicationFactor = newDenominator // oOtherFraction.denominator</p>
<p class="calibre1">oOtherFractionEquivalentNumerator = </p>
<p class="calibre1">oOtherFraction.numerator * otherMultiplicationFactor</p>
<p class="calibre1"><b class="calibre3">206</b>   Chapter 9</p>
<p class="calibre1"><a id="p236"/>        newNumerator = equivalentNumerator + oOtherFractionEquivalentNumerator oAddedFraction = Fraction(newNumerator, newDenominator)</p>
<p class="calibre1">return oAddedFraction</p>
<p class="calibre1">def __eq__(self, oOtherFraction): 5</p>
<p class="calibre1">'''Test for equality ''' </p>
<p class="calibre1">if not isinstance(oOtherFraction, Fraction):</p>
<p class="calibre1">return False  # not comparing to a fraction</p>
<p class="calibre1">if (self.numerator == oOtherFraction.numerator) and \</p>
<p class="calibre1">(self.denominator == oOtherFraction.denominator):</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1"> <i class="calibre4">Listing 9-10: The Fraction class that implements a number of magic methods</i></p>
<p class="calibre1">When you create a Fraction object, you pass in a numerator and a </p>
<p class="calibre1">denominator 1, and the __init__() method immediately calculates the </p>
<p class="calibre1">reduced fraction and its floating-point value. At any time, client code can </p>
<p class="calibre1">call the getValue() method to retrieve that value 2. Client code can also call </p>
<p class="calibre1">print() to print out the object, and Python will call the __str__() method to </p>
<p class="calibre1">format a string to be printed 3. </p>
<p class="calibre1">The client can add two different Fraction objects together with the </p>
<p class="calibre1">+ operator. When this happens, the __add__() method is called 4. That </p>
<p class="calibre1">method uses the  math.lcd() (least common denominator) method to ensure </p>
<p class="calibre1">that the resulting Fraction object has the smallest common denominator. </p>
<p class="calibre1">Finally, client code can use the == operator to check if two Fraction </p>
<p class="calibre1">objects are equal. When you use this operator, the __eq__() method is </p>
<p class="calibre1">called 5, which checks the values of the two Fractions and returns True or </p>
<p class="calibre1">False. </p>
<p class="calibre1">Here is some code that instantiates Fraction objects and tests the various </p>
<p class="calibre1">magic methods:</p>
<p class="calibre1"># Test code</p>
<p class="calibre1">oFraction1 = Fraction(1, 3)  # create a Fraction object</p>
<p class="calibre1">oFraction2 = Fraction(2, 5)</p>
<p class="calibre1">print('Fraction1\n', oFraction1)  # print the object ... calls  __str__</p>
<p class="calibre1">print('Fraction2\n', oFraction2)</p>
<p class="calibre1">oSumFraction = oFraction1 + oFraction2  # calls __add__</p>
<p class="calibre1">print('Sum is\n', oSumFraction)</p>
<p class="calibre1">print('Are fractions 1 and 2 equal?', (oFraction1 == oFraction2)) # expect False</p>
<p class="calibre1">print()</p>
<p class="calibre1">oFraction3 = Fraction(-20, 80)</p>
<p class="calibre1">oFraction4 = Fraction(4, -16)</p>
<p class="calibre1">print('Fraction3\n', oFraction3)  </p>
<p class="calibre1">print('Fraction4\n', oFraction4)</p>
<p class="calibre1">print('Are fractions 3 and 4 equal?', (oFraction3 == oFraction4)) # expect True</p>
<p class="calibre1">print()</p>
<p class="calibre1">Polymorphism   <b class="calibre3">207</b></p>
<p class="calibre1"><a id="p237"/>oFraction5 = Fraction(5, 2)</p>
<p class="calibre1">oFraction6 = Fraction(500, 200)</p>
<p class="calibre1">print('Sum of 5/2 and 500/2\n', oFraction5 + oFraction6)</p>
<p class="calibre1">When run, this code produces:</p>
<p class="calibre1">Fraction1</p>
<p class="calibre1">Fraction: 1/3</p>
<p class="calibre1">Value: 0.3333333333333333</p>
<p class="calibre1">Fraction2</p>
<p class="calibre1">Fraction: 2/5</p>
<p class="calibre1">Value: 0.4</p>
<p class="calibre1">Sum is</p>
<p class="calibre1">Fraction: 11/15</p>
<p class="calibre1">Value: 0.7333333333333333</p>
<p class="calibre1">Are fractions 1 and 2 equal? False </p>
<p class="calibre1">Fraction3</p>
<p class="calibre1">Fraction: -1/4</p>
<p class="calibre1">Value: -0.25</p>
<p class="calibre1">Fraction4</p>
<p class="calibre1">Fraction: -1/4</p>
<p class="calibre1">Value: -0.25</p>
<p class="calibre1">Are fractions 3 and 4 equal? True </p>
<p class="calibre1">Sum of 5/2 and 500/2</p>
<p class="calibre1">Fraction: 5/1</p>
<p class="calibre1">Value: 5.0</p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">This chapter was about the key OOP concept of polymorphism. Stated </p>
<p class="calibre1">simply, polymorphism is the ability for multiple classes to implement meth-</p>
<p class="calibre1">ods with the same names. Each class contains specific code to do whatever </p>
<p class="calibre1">needs to be done for objects instantiated from that class. As a demonstra-</p>
<p class="calibre1">tion program, I showed how you could create a number of different shape </p>
<p class="calibre1">classes, each of which had an __init__(), getArea(), clickedInside(), and </p>
<p class="calibre1">draw() method. The code of each version of these methods was specific to </p>
<p class="calibre1">the type of the shape. </p>
<p class="calibre1">As you saw, there are two key advantages to using polymorphism. First, </p>
<p class="calibre1">it extends the concept of abstraction to a collection of classes, allowing the </p>
<p class="calibre1">client programmer to ignore the implementation. Second, it allows for a </p>
<p class="calibre1">system of classes that work in similar ways, making a system predictable to </p>
<p class="calibre1">client programmers. </p>
<p class="calibre1"><b class="calibre3">208</b>   Chapter 9</p>
<p class="calibre1"><a id="p238"/>I also discussed the idea of polymorphism in operators, explaining how the same operator could do different operations with different types </p>
<p class="calibre1">of data. I showed how Python’s magic methods are used to make this hap-</p>
<p class="calibre1">pen and how you can build methods to implement these operators in your </p>
<p class="calibre1">own classes. To demonstrate the use of arithmetic and comparison operator </p>
<p class="calibre1">magic methods, I showed a Vector class and a Fraction class. I also showed </p>
<p class="calibre1">how you can use the __str__()  method to help in debugging the content of </p>
<p class="calibre1">an object. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">209</b></p>
<p class="calibre1"><a id="p239"/>
<a id="p240"/><b class="calibre3">10</b></p>
<p class="calibre1"><b class="calibre3">I N H E R I T A N C E</b></p>
<p class="calibre1">The third tenet of OOP is  <i class="calibre4">inheritance</i>, which </p>
<p class="calibre1">is a mechanism for deriving a new class </p>
<p class="calibre1">from an existing class. Rather than starting </p>
<p class="calibre1">from scratch and potentially duplicating code, </p>
<p class="calibre1">inheritance allows a programmer to write code for </p>
<p class="calibre1">a new class that extends or differentiates it from an </p>
<p class="calibre1">existing class. </p>
<p class="calibre1">Let’s begin with a real-world example that demonstrates what inheri-</p>
<p class="calibre1">tance is basically about. You’re attending culinary school. One of your les-</p>
<p class="calibre1">sons involves an exhaustive demonstration of making hamburgers. You learn </p>
<p class="calibre1">everything that there is to know about the different cuts of meat, the grind-</p>
<p class="calibre1">ing of the meat, the best types of buns, the best lettuce, tomato, and condi-</p>
<p class="calibre1">ments—just about everything you could imagine. You also learn about the </p>
<p class="calibre1">best way to cook the hamburger, how long to cook it, when and how often to </p>
<p class="calibre1">flip it over, and so on. </p>
<p class="calibre1">The next lesson in the curriculum is about cheeseburgers. The instructor </p>
<p class="calibre1"> <i class="calibre4">could</i> start from scratch and go through all the material about hamburgers </p>
<p class="calibre1"><a id="p241"/>again. But instead, they assume that you’ve retained the knowledge from the previous lesson and so already know everything there is to know about creating a great hamburger. This lesson therefore focuses on what types of cheese </p>
<p class="calibre1">to use, when to add it, how much to use, and so on. </p>
<p class="calibre1">The point of the story is that there is no need to “reinvent the wheel”; </p>
<p class="calibre1">instead, you can simply add on to what you already know. </p>
<p class="calibre1"><b class="calibre3">Inheritance in Object-Oriented Programming</b></p>
<p class="calibre1">Inheritance in OOP is the ability to create a class that builds on ( <i class="calibre4">extends</i>) an existing class. When creating large programs, you will often use classes that </p>
<p class="calibre1">provide very useful general capabilities. You’ll sometimes want to build a </p>
<p class="calibre1">class that’s similar to a class that already exists, but does some things slightly </p>
<p class="calibre1">differently. Inheritance allows you to do just that, creating a new class that </p>
<p class="calibre1">includes all the methods and instance variables of an existing class, but adds </p>
<p class="calibre1">new and different functionality. </p>
<p class="calibre1">Inheritance is an extremely powerful concept. When classes are set up </p>
<p class="calibre1">correctly, using inheritance can  <i class="calibre4">seem</i> simple. However, being able to design classes to use it in a clear manner is a skill that’s difficult to master. As an </p>
<p class="calibre1">implementer, inheritance takes a great deal of practice to use properly and </p>
<p class="calibre1">efficiently. </p>
<p class="calibre1">With inheritance, we talk about the relationship between two classes, </p>
<p class="calibre1">typically referred to as the  <i class="calibre4">base class </i> and  <i class="calibre4">subclass</i>. </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">Base class</b> </p>
<p class="calibre1">The class that is inherited from; it serves as a starting point for the subclass . </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">Subclass</b> </p>
<p class="calibre1">The class that is doing the inheriting; it enhances the base class . </p>
<p class="calibre1">While these are the most common terms used to describe the two </p>
<p class="calibre1">classes in Python, you may also hear them referred to in other ways, such as:</p>
<p class="calibre1">•   <i class="calibre4">Superclass</i> and  <i class="calibre4">subclass</i></p>
<p class="calibre1">•   <i class="calibre4">Base class</i> and  <i class="calibre4">derived</i>  <i class="calibre4">class</i></p>
<p class="calibre1">•   <i class="calibre4">Parent</i>  <i class="calibre4">class</i> and  <i class="calibre4">child</i>  <i class="calibre4">class</i></p>
<p class="calibre1">Figure 10-1 is a standard diagram that shows this relationship. </p>
<p class="calibre1">Base class</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">Subclass</p>
<p class="calibre1"> <i class="calibre4">Figure 10-1: A subclass inherits  </i></p>
<p class="calibre1"> <i class="calibre4">from a base class. </i></p>
<p class="calibre1"><b class="calibre3">212</b>   Chapter 10</p>
<p class="calibre1"><a id="p242"/>A subclass inherits all of the methods and instance variables defined in a base class. </p>
<p class="calibre1">Figure 10-2 provides a different, perhaps more accurate, way to think of </p>
<p class="calibre1">the relationship between the two classes. </p>
<p class="calibre1">Base class</p>
<p class="calibre1">Subclass</p>
<p class="calibre1"> <i class="calibre4">Figure 10-2: A base class is  </i></p>
<p class="calibre1"> <i class="calibre4">incorporated into a subclass. </i></p>
<p class="calibre1">As the implementer, you can think of the base class as being incorpo-</p>
<p class="calibre1">rated into the subclass. That is, the base class actually becomes part of the </p>
<p class="calibre1">larger subclass. As a client of a subclass, you think about the subclass as a </p>
<p class="calibre1">single unit and do not need to know that the base class is there at all. </p>
<p class="calibre1">When discussing inheritance, we often say there is an  <i class="calibre4">is a</i> relationship </p>
<p class="calibre1">between a subclass and a base class. For example, a student is a person, an </p>
<p class="calibre1">orange is a fruit, a car is a vehicle, and so on. The subclass is a specialized </p>
<p class="calibre1">version of the base class that inherits all the properties and behavior of the </p>
<p class="calibre1">base class, but also provides additional details and functionality. </p>
<p class="calibre1">Most importantly, a subclass extends a base class in either or both of </p>
<p class="calibre1">the following ways (which will be explained soon):</p>
<p class="calibre1">•  A subclass can  <i class="calibre4">redefine</i> a method that’s defined in the base class. That </p>
<p class="calibre1">is, a subclass can provide a method with same name as one in the base </p>
<p class="calibre1">class but with different functionality. This is called  <i class="calibre4">overriding</i> a method. </p>
<p class="calibre1">When client code makes a call to an overridden method, the method in </p>
<p class="calibre1">the subclass is called. (However, the code of the method in the subclass </p>
<p class="calibre1">can still call the method of the same name in the base class.)</p>
<p class="calibre1">•  A subclass can add new methods and instance variables that do not </p>
<p class="calibre1">appear in the base class. </p>
<p class="calibre1">One way to think of a subclass is with the phrase  <i class="calibre4">coding by difference</i>. </p>
<p class="calibre1">Since the subclass inherits all the instance variables and methods of the </p>
<p class="calibre1">base class, it does not need to repeat all of that code; the subclass only </p>
<p class="calibre1">needs to contain code that differentiates it from the base class. The code </p>
<p class="calibre1">of the subclass therefore only contains new instance variables (and their </p>
<p class="calibre1">initialization), overriding methods, and/or new methods not found in the </p>
<p class="calibre1">base class. </p>
<p class="calibre1"><b class="calibre3">Implementing Inheritance </b></p>
<p class="calibre1">The syntax of inheritance in Python is simple and elegant. The base class </p>
<p class="calibre1">does not need to  <i class="calibre4">know</i> that it is being used as a base class. Only the subclass Inheritance   <b class="calibre3">213</b></p>
<p class="calibre1"><a id="p243"/>needs to indicate that it wants to inherit from a base class. Here is the general syntax:</p>
<p class="calibre1">class  <i class="calibre4">&lt;BaseClassName&gt; </i>():</p>
<p class="calibre1"># BaseClass methods</p>
<p class="calibre1">class  <i class="calibre4">&lt;SubClassName&gt; </i>( <i class="calibre4">&lt;BaseClassName&gt; </i>):</p>
<p class="calibre1"># SubClass methods</p>
<p class="calibre1">In the class statement of the subclass, within the parentheses you spec-</p>
<p class="calibre1">ify the name of the base class it should inherit from. In this case, we want </p>
<p class="calibre1">the subclass  <i class="calibre4">&lt;SubClassName&gt; </i> to inherit from the base class  <i class="calibre4">&lt;BaseClassName&gt; </i>. </p>
<p class="calibre1">(Programmers will often use the word  <i class="calibre4">subclass</i> as a verb, as in “Let’s subclass ClassA to build ClassB.”) Here’s an example with real class names:</p>
<p class="calibre1">class Widget():</p>
<p class="calibre1"># Widget's methods</p>
<p class="calibre1">class WidgetWithFrills(Widget):</p>
<p class="calibre1"># WidgetWithFrills's methods</p>
<p class="calibre1">The Widget class will provide general functionality. The WidgetWithFrills </p>
<p class="calibre1">class will include everything from the Widget class and define any additional </p>
<p class="calibre1">methods and instance variables it wants with more specific capabilities. </p>
<p class="calibre1"><b class="calibre3">Employee and Manager Example</b></p>
<p class="calibre1">I’ll start with an extremely simple example to make the key concepts clear, </p>
<p class="calibre1">then move on to some more practical examples. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Base Class: Employee</b></i></p>
<p class="calibre1">Listing 10-1 defines a base class called Employee. </p>
<p class="calibre1"><b class="calibre3">File: EmployeeManagerInheritance/EmployeeManagerInheritance.py</b></p>
<p class="calibre1">#  Employee Manager inheritance</p>
<p class="calibre1">#</p>
<p class="calibre1"># Define the Employee class, which we will use as a base class</p>
<p class="calibre1">class Employee():</p>
<p class="calibre1">def __init__(self, name, title, ratePerHour=None):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">self.title = title</p>
<p class="calibre1">if ratePerHour is not None:</p>
<p class="calibre1">ratePerHour = float(ratePerHour)</p>
<p class="calibre1">self.ratePerHour = ratePerHour</p>
<p class="calibre1">def getName(self):</p>
<p class="calibre1">return self.name</p>
<p class="calibre1">def getTitle(self):</p>
<p class="calibre1"><b class="calibre3">214</b>   Chapter 10</p>
<p class="calibre1"><a id="p244"/>        return self.title</p>
<p class="calibre1">def payPerYear(self):</p>
<p class="calibre1"># 52 weeks * 5 days a week * 8 hours per day</p>
<p class="calibre1">pay = 52 * 5 * 8 * self.ratePerHour</p>
<p class="calibre1">return pay</p>
<p class="calibre1"> <i class="calibre4">Listing 10-1: The Employee class, which will be used as a base class</i></p>
<p class="calibre1">The Employee class has the methods __init__(), getName(), getTitle(), and </p>
<p class="calibre1">payPerYear(). It also has three instance variables, self.name, self.title, and </p>
<p class="calibre1">self.ratePerHour, which are set in the __init__() method. We retrieve the  </p>
<p class="calibre1">name and title using getter methods. These employees are paid per hour, so  </p>
<p class="calibre1">self.payPerYear() does a calculation to determine the annual pay based on the </p>
<p class="calibre1">hourly rate. Everything in this class should be familiar to you; there is noth-</p>
<p class="calibre1">ing new here. You can instantiate an Employee object by itself, and it will work </p>
<p class="calibre1">fine. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Subclass: Manager</b></i></p>
<p class="calibre1">For the Manager class, we consider the differences between a manager and an </p>
<p class="calibre1">employee: the manager is a salaried employee who has a number of direct </p>
<p class="calibre1">reports. If this manager does a good job, they get a 10 percent bonus for the </p>
<p class="calibre1">year. The Manager class can extend the Employee class, since the manager is an </p>
<p class="calibre1">employee but has additional capabilities and responsibilities. </p>
<p class="calibre1">Listing 10-2 shows the code of our Manager class. It only needs to contain </p>
<p class="calibre1">code that is different from the Employee class, so you’ll see that it doesn’t </p>
<p class="calibre1">have a getName() or getTitle() method. Any calls to those methods with a </p>
<p class="calibre1">Manager object will be handled by the methods in the Employee class. </p>
<p class="calibre1"><b class="calibre3">File: EmployeeManagerInheritance/EmployeeManagerInheritance.py</b></p>
<p class="calibre1"># Define a Manager subclass that inherits from Employee</p>
<p class="calibre1">1 class Manager(Employee):</p>
<p class="calibre1">def __init__(self, name, title, salary, reportsList=None):</p>
<p class="calibre1">2 self.salary = float(salary)</p>
<p class="calibre1">if reportsList is None:</p>
<p class="calibre1">reportsList = []</p>
<p class="calibre1">self.reportsList = reportsList</p>
<p class="calibre1">3 super().__init__(name, title)</p>
<p class="calibre1">4 def getReports(self):</p>
<p class="calibre1">return self.reportsList</p>
<p class="calibre1">5 def payPerYear(self, giveBonus=False):</p>
<p class="calibre1">pay = self.salary</p>
<p class="calibre1">if giveBonus:</p>
<p class="calibre1">pay = pay + (.10 * self.salary)  # add a bonus of 10%</p>
<p class="calibre1">6 print(self.name, 'gets a bonus for good work')</p>
<p class="calibre1">return pay       </p>
<p class="calibre1"> <i class="calibre4">Listing 10-2: The Manager class, implemented as a subclass of the Employee class</i> Inheritance   <b class="calibre3">215</b></p>
<p class="calibre1"><a id="p245"/>In the class statement 1, you can see that this class inherits from the Employee class because Employee is inside the parentheses after the name </p>
<p class="calibre1">Manager. </p>
<p class="calibre1">The __init__() method of the Employee class expects a name, a title, and </p>
<p class="calibre1">an optional rate per hour. A manager is a salaried employee and manages a </p>
<p class="calibre1">number of employees, so the __init__() method of the Manager class expects </p>
<p class="calibre1">a name, a title, a salary, and a list of employees. Adhering to the principle </p>
<p class="calibre1">of coding by difference, the __init__() method starts by initializing any-</p>
<p class="calibre1">thing the __init__() method of the Employee class doesn’t do. Therefore, we </p>
<p class="calibre1">save the salary and reportsList in similarly named instance variables 2. </p>
<p class="calibre1">Next we want to call the __init__() method of the Employee base class 3. </p>
<p class="calibre1">Here, I am calling the built-in function super(), which asks Python to figure </p>
<p class="calibre1">out which class is the base class (often referred to as the  <i class="calibre4">superclass</i>) and call that class’s __init__() method. It also adjusts the arguments to include self </p>
<p class="calibre1">as the first argument in this call. Therefore, you can think of this line as </p>
<p class="calibre1">translating to:</p>
<p class="calibre1">Employee.__init__(self, name, title)</p>
<p class="calibre1">In fact, coding that line this way would work perfectly well; using the </p>
<p class="calibre1">call to super() is simply a much cleaner way to write the call without having </p>
<p class="calibre1">to specify the name of the base class. </p>
<p class="calibre1">The effect is that the new Manager class’s __init__() method initializes </p>
<p class="calibre1">the two instance variables (self.salary and self.reportsList) that are dif-</p>
<p class="calibre1">ferent from those in the Employee class, and the Employee class’s __init__() </p>
<p class="calibre1">method initializes the self.name and self.title instance variables that are </p>
<p class="calibre1">common to any Employee or Manager object that is created. For a Manager who </p>
<p class="calibre1">has a salary, self.ratePerHour is set to None. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">Older versions of Python required you to write this code in yet a third way, so you may</i> <i class="calibre4">see this in older programs and documentation:</i></p>
<p class="calibre1">super(Employee, self).__init__(name, salary)</p>
<p class="calibre1"> <i class="calibre4">This also does the exact same thing. However, the newer syntax with the simple </i></p>
<p class="calibre1"> <i class="calibre4">call to super() is much easier to remember. Using super() also makes it less error-prone if you decide that you want to change the name of your base class. </i></p>
<p class="calibre1">The Manager class has an added getter method, getReports() 4, that </p>
<p class="calibre1">allows client code to retrieve a list of Employees who report to the Manager. </p>
<p class="calibre1">The payPerYear() method 5 calculates and returns the Manager’s pay. </p>
<p class="calibre1">Notice that both the Employee and the Manager classes have a method </p>
<p class="calibre1">named payPerYear(). If you call the payPerYear() method using an instance </p>
<p class="calibre1">of Employee, the Employee class’s method will run and calculate the pay based </p>
<p class="calibre1">on the hourly rate. If you call the payPerYear() method with an instance of </p>
<p class="calibre1">Manager, the Manager class’s method will run and do a different calculation. </p>
<p class="calibre1">The payPerYear() method in the Manager class  <i class="calibre4">overrides</i> the method by the </p>
<p class="calibre1">same name in the base class. Overriding a method in a subclass specializes </p>
<p class="calibre1"><b class="calibre3">216</b>   Chapter 10</p>
<p class="calibre1"><a id="p246"/>the subclass to differentiate it from the base class. The overriding method must have the exact same name as the method that it overrides (although it </p>
<p class="calibre1">may have a different list of parameters). In the overriding method, you can:</p>
<p class="calibre1">•  Completely replace the overridden method in the base class. We see </p>
<p class="calibre1">this in the payPerYear() method of the Manager class. </p>
<p class="calibre1">•  Do some work on its own and call the inherited or overridden method </p>
<p class="calibre1">of the same name in the base class. We see this in the __init__() </p>
<p class="calibre1">method of the Manager class. </p>
<p class="calibre1">The actual content of the overriding method depends on the situation. </p>
<p class="calibre1">If the client makes a call to a method that does not exist in a subclass, the </p>
<p class="calibre1">method call will be sent on to the base class. For example, notice that there </p>
<p class="calibre1">is no method named getName() in the Manager class, but it does exist in the </p>
<p class="calibre1">Employee base class. If a client calls getName() on an instance of Manager, that </p>
<p class="calibre1">call is handled by the base class, Employee. </p>
<p class="calibre1">The payPerYear() method of the Manager class contains this code:</p>
<p class="calibre1">if giveBonus:</p>
<p class="calibre1">pay = pay + (.10 * self.salary)  # add a bonus of 10%</p>
<p class="calibre1">6 print(self.name, 'gets a bonus for good work')</p>
<p class="calibre1">The instance variable self.name was defined in the Employee class, but the </p>
<p class="calibre1">Manager class has no previous mention of it. This demonstrates that instance </p>
<p class="calibre1">variables defined in a base class are available for use in methods of a sub-</p>
<p class="calibre1">class. Here we are calculating the pay for a manager, which works correctly </p>
<p class="calibre1">because payPerYear() has access to instance variables defined inside its own </p>
<p class="calibre1">class (self.salary)  <i class="calibre4">and</i> instance variables defined in the base class (printing using self.name 6). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Test Code</b></i></p>
<p class="calibre1">Let’s test our Employee and Manager objects and call methods of each. </p>
<p class="calibre1"><b class="calibre3">File: EmployeeManagerInheritance/EmployeeManagerInheritance.py</b></p>
<p class="calibre1"># Create objects</p>
<p class="calibre1">oEmployee1 = Employee('Joe Schmoe', 'Pizza Maker', 16)</p>
<p class="calibre1">oEmployee2 = Employee('Chris Smith', 'Cashier', 14)</p>
<p class="calibre1">oManager = Manager('Sue Jones', 'Pizza Restaurant Manager', </p>
<p class="calibre1">55000, [oEmployee1, oEmployee2])</p>
<p class="calibre1"># Call methods of the Employee objects</p>
<p class="calibre1">print('Employee name:', oEmployee1.getName())</p>
<p class="calibre1">print('Employee salary:', '{:,.2f}'.format(oEmployee1.payPerYear()))</p>
<p class="calibre1">print('Employee name:', oEmployee2.getName())</p>
<p class="calibre1">print('Employee salary:', '{:,.2f}'.format(oEmployee2.payPerYear()))</p>
<p class="calibre1">print()</p>
<p class="calibre1"># Call methods of the Manager object</p>
<p class="calibre1">managerName = oManager.getName()</p>
<p class="calibre1">Inheritance   <b class="calibre3">217</b></p>
<p class="calibre1"><a id="p247"/>print('Manager name:', managerName)</p>
<p class="calibre1"># Give the manager a bonus</p>
<p class="calibre1">print('Manager salary:', '{:,.2f}'.format(oManager.payPerYear(True)))</p>
<p class="calibre1">print(managerName, '(' + oManager.getTitle() + ')', 'direct reports:')</p>
<p class="calibre1">reportsList = oManager.getReports() </p>
<p class="calibre1">for oEmployee in reportsList:</p>
<p class="calibre1">print('   ', oEmployee.getName(), </p>
<p class="calibre1">'(' + oEmployee.getTitle() + ')')</p>
<p class="calibre1">When we run this code, we see the following output, as we would </p>
<p class="calibre1">expect:</p>
<p class="calibre1">Employee name: Joe Schmoe</p>
<p class="calibre1">Employee salary: 33,280.00</p>
<p class="calibre1">Employee name: Chris Smith</p>
<p class="calibre1">Employee salary: 29,120.00</p>
<p class="calibre1">Manager name: Sue Jones</p>
<p class="calibre1">Sue Jones gets a bonus for good work</p>
<p class="calibre1">Manager salary: 60,500.00</p>
<p class="calibre1">Sue Jones (Pizza Restaurant Manager) direct reports:</p>
<p class="calibre1">Joe Schmoe (Pizza Maker)</p>
<p class="calibre1">Chris Smith (Cashier)</p>
<p class="calibre1"><b class="calibre3">The Client’s View of a Subclass</b></p>
<p class="calibre1">The discussion so far has been focused on the details of implementation. </p>
<p class="calibre1">But classes can look different depending on whether you are the developer </p>
<p class="calibre1">of a class or are writing code to use a class. Let’s change focus and take a </p>
<p class="calibre1">look at inheritance from the client’s point of view. As far as client code is </p>
<p class="calibre1">concerned, a subclass has all the functionality of the base class, plus any-</p>
<p class="calibre1">thing defined in the subclass itself. It may help to think about the result-</p>
<p class="calibre1">ing collection of methods as layers of paint on a wall. When a client looks </p>
<p class="calibre1">at the Employee class, the client sees all the methods defined in that class </p>
<p class="calibre1">(Figure 10-3). </p>
<p class="calibre1">Employee</p>
<p class="calibre1">_init_()</p>
<p class="calibre1">Client</p>
<p class="calibre1">getName()</p>
<p class="calibre1">getTitle()</p>
<p class="calibre1">payPerYear()</p>
<p class="calibre1"> <i class="calibre4">Figure 10-3: What a client would see looking at the  </i></p>
<p class="calibre1"> <i class="calibre4">interface of the Employee class</i></p>
<p class="calibre1"><b class="calibre3">218</b>   Chapter 10</p>
<p class="calibre1"><a id="p248"/>When we introduce the Manager class that inherits from the Employee class, it’s like adding paint to touch up the places where we want to add or </p>
<p class="calibre1">change methods. For methods that we don’t want to change, we just leave </p>
<p class="calibre1">the old layer of paint (Figure 10-4). </p>
<p class="calibre1">Manager</p>
<p class="calibre1">Employee</p>
<p class="calibre1">_init_()</p>
<p class="calibre1">_init_()</p>
<p class="calibre1">Client</p>
<p class="calibre1">getName()</p>
<p class="calibre1">getTitle()</p>
<p class="calibre1">payPerYear()</p>
<p class="calibre1">payPerYear()</p>
<p class="calibre1">getReports()</p>
<p class="calibre1"> <i class="calibre4">Figure 10-4: What a client would see looking at the interface of  </i></p>
<p class="calibre1"> <i class="calibre4">the Manager class</i></p>
<p class="calibre1">As the developer, we know that the Manager class inherits from the </p>
<p class="calibre1">Employee class and overrides some methods. As the client, we just see five </p>
<p class="calibre1">methods. The client doesn’t need to know that some methods are imple-</p>
<p class="calibre1">mented in the Manager class and others come from the inherited Employee </p>
<p class="calibre1">class. </p>
<p class="calibre1"><b class="calibre3">Real-World Examples of Inheritance</b></p>
<p class="calibre1">Let’s take a look at two real-world examples of inheritance. First, I’ll show </p>
<p class="calibre1">you how to build an input field that only allows you to enter numbers. I’ll </p>
<p class="calibre1">then build an output field that formats monetary values. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">InputNumber</b></i></p>
<p class="calibre1">In this first example, we’ll create an input field that allows the user to input </p>
<p class="calibre1">only numerical data. As a general user interface design principle, it’s much </p>
<p class="calibre1">better to restrict the input to allow only for correctly formatted data while </p>
<p class="calibre1">the user is entering the data, rather than allowing any input and checking </p>
<p class="calibre1">its correctness later. Entering letters or other symbols in this input field, or </p>
<p class="calibre1">attempting to enter multiple decimal points or multiple minus signs, should </p>
<p class="calibre1">not be allowed. </p>
<p class="calibre1">The pygwidgets package contains an InputText class that allows the user </p>
<p class="calibre1">to input any characters. We’ll write an InputNumber class to allow only valid </p>
<p class="calibre1">numbers as input. The new InputNumber class will inherit much of its code </p>
<p class="calibre1">from InputText. We’ll only need to override three methods of InputText: </p>
<p class="calibre1">__init__(), handleEvent(), and getValue(). Listing 10-3 shows the InputNumber </p>
<p class="calibre1">class that overrides these methods. </p>
<p class="calibre1">Inheritance   <b class="calibre3">219</b></p>
<p class="calibre1"><a id="p249"/><b class="calibre3">File: MoneyExamples/InputNumber.py</b></p>
<p class="calibre1"># InputNumber class - allows the user to enter only numbers</p>
<p class="calibre1">#</p>
<p class="calibre1"># Demo of inheritance</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WHITE = (255, 255, 255)</p>
<p class="calibre1"># Tuple of legal editing keys</p>
<p class="calibre1">LEGAL_KEYS_TUPLE = (pygame.K_RIGHT, pygame.K_LEFT, pygame.K_HOME, </p>
<p class="calibre1">pygame.K_END, pygame.K_DELETE, pygame.K_BACKSPACE, </p>
<p class="calibre1">pygame.K_RETURN, pygame.K_KP_ENTER)</p>
<p class="calibre1"># Legal keys to be typed</p>
<p class="calibre1">LEGAL_UNICODE_CHARS = ('0123456789.-')</p>
<p class="calibre1">#</p>
<p class="calibre1">#  InputNumber inherits from InputText</p>
<p class="calibre1">#</p>
<p class="calibre1">class InputNumber(pygwidgets.InputText):</p>
<p class="calibre1">def __init__(self, window, loc, value='', fontName=None, 1</p>
<p class="calibre1">fontSize=24, width=200, textColor=BLACK, </p>
<p class="calibre1">backgroundColor=WHITE, focusColor=BLACK, </p>
<p class="calibre1">initialFocus=False, nickName=None, callback=None, </p>
<p class="calibre1">mask=None, keepFocusOnSubmit=False, </p>
<p class="calibre1">allowFloatingNumber=True, allowNegativeNumber=True):</p>
<p class="calibre1">self.allowFloatingNumber = allowFloatingNumber</p>
<p class="calibre1">self.allowNegativeNumber = allowNegativeNumber</p>
<p class="calibre1"># Call the __init__ method of our base class</p>
<p class="calibre1">super().__init__(window, loc, value, fontName, fontSize, 2</p>
<p class="calibre1">width, textColor, backgroundColor, </p>
<p class="calibre1">focusColor, initialFocus, nickName, callback, </p>
<p class="calibre1">mask, keepFocusOnSubmit)</p>
<p class="calibre1"># Override handleEvent so we can filter for proper keys</p>
<p class="calibre1"> <i class="calibre4">    </i> def handleEvent(self, event): 3</p>
<p class="calibre1">if (event.type == pygame.KEYDOWN):  </p>
<p class="calibre1"> <i class="calibre4">            </i># If it's not an editing or numeric key, ignore it</p>
<p class="calibre1"># Unicode value is only present on key down</p>
<p class="calibre1">allowableKey = (event.key in LEGAL_KEYS_TUPLE) or</p>
<p class="calibre1">(event.unicode in LEGAL_UNICODE_CHARS))</p>
<p class="calibre1">if not allowableKey:</p>
<p class="calibre1">return False</p>
<p class="calibre1">if event.unicode == '-':  # user typed a minus sign</p>
<p class="calibre1"> <i class="calibre4">                </i> if not self.allowNegativeNumber:</p>
<p class="calibre1"># If no negatives, don't pass it through</p>
<p class="calibre1">return False</p>
<p class="calibre1"> <i class="calibre4">                </i> if self.cursorPosition &gt; 0:</p>
<p class="calibre1"><b class="calibre3">220</b>   Chapter 10</p>
<p class="calibre1"><a id="p250"/>                    return False # can't put minus sign after 1st char</p>
<p class="calibre1"> <i class="calibre4">                </i> if '-' in self.text:</p>
<p class="calibre1">return False  # can't enter a second minus sign</p>
<p class="calibre1"> <i class="calibre4">            </i> if event.unicode == '.':</p>
<p class="calibre1">if not self.allowFloatingNumber:</p>
<p class="calibre1"># If no floats, don't pass the period through</p>
<p class="calibre1">return False  </p>
<p class="calibre1"> <i class="calibre4">                </i> if '.' in self.text:</p>
<p class="calibre1">return False  # can't enter a second period</p>
<p class="calibre1"> <i class="calibre4">        </i># Allow the key to go through to the base class</p>
<p class="calibre1">result = super().handleEvent(event)  </p>
<p class="calibre1"> <i class="calibre4">        </i> return result</p>
<p class="calibre1">def getValue(self): 4</p>
<p class="calibre1">userString = super().getValue()</p>
<p class="calibre1">try:</p>
<p class="calibre1">if self.allowFloatingNumber:</p>
<p class="calibre1">returnValue = float(userString)</p>
<p class="calibre1">else:</p>
<p class="calibre1">returnValue = int(userString)</p>
<p class="calibre1">except ValueError:</p>
<p class="calibre1">raise ValueError('Entry is not a number, needs to have at least one digit.')</p>
<p class="calibre1">return returnValue</p>
<p class="calibre1"> <i class="calibre4">Listing 10-3: InputNumber only al ows the user to enter numeric data. </i></p>
<p class="calibre1">The __init__() method allows for the same parameters as the InputText </p>
<p class="calibre1">base class, plus a few more 1. It adds two Booleans: allowFloatingNumber to </p>
<p class="calibre1">determine if the user should be allowed to enter floating-point numbers </p>
<p class="calibre1">and allowNegativeNumber to determine if the user can enter a number starting </p>
<p class="calibre1">with a minus sign. Both default to True, so the default case allows the user to </p>
<p class="calibre1">enter a floating-point number and both positive and negative numbers. You </p>
<p class="calibre1">could use these to restrict the user to, for example, only entering a positive </p>
<p class="calibre1">integer value by setting both to False. The __init__() method saves the val-</p>
<p class="calibre1">ues of these two additional parameters in instance variables, then calls the </p>
<p class="calibre1">__init__() method of the base class using the call to super() 2. </p>
<p class="calibre1">The significant code is in the handleEvent() method 3, which restricts </p>
<p class="calibre1">the allowed keys to a small subset: the numbers zero through nine, the </p>
<p class="calibre1">minus sign, a period (decimal point), ENTER, and a few editing keys. When </p>
<p class="calibre1">the user presses a key, this method is called and a KEYDOWN or KEYUP event is </p>
<p class="calibre1">passed in. The code first ensures that the key pressed is in the restricted set. </p>
<p class="calibre1">If the user enters a key not in that set (for example, any letter), we return </p>
<p class="calibre1">False to indicate that nothing important has happened in this widget, and </p>
<p class="calibre1">that key is ignored. </p>
<p class="calibre1">The handleEvent() method then does a few more checks to ensure that </p>
<p class="calibre1">the number being entered is legal (for example, doesn’t have two periods, </p>
<p class="calibre1">only has one minus sign and, so on). Whenever a valid key press is detected, </p>
<p class="calibre1">the code calls the handleEvent() method of the InputText base class to do </p>
<p class="calibre1">whatever it needs to do with that key (display or edit the field). </p>
<p class="calibre1">Inheritance   <b class="calibre3">221</b></p>
<p class="calibre1"><a id="p251"/>When the user presses RETURN or ENTER, client code calls the get-</p>
<p class="calibre1">Value() method 4 to get the user’s entry. The getValue() method in this class </p>
<p class="calibre1">calls getValue() in the InputText class to get the string from the field, then </p>
<p class="calibre1">attempts to convert that string to a number. If that conversion fails, it raises an exception. </p>
<p class="calibre1">By overriding methods, we have built a very powerful new reusable class </p>
<p class="calibre1">that extends the functionality of the InputText class, without changing a </p>
<p class="calibre1">single line in the base class. InputText will continue to function as a class by </p>
<p class="calibre1">itself, without any changes to its functionality whatsoever. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">DisplayMoney</b></i></p>
<p class="calibre1">As a second real-world example, we’ll create a field to display an amount of </p>
<p class="calibre1">money. To make this general, we’ll display the amount with a chosen cur-</p>
<p class="calibre1">rency symbol, place that currency symbol to the left or the right of the text </p>
<p class="calibre1">(as appropriate), and format the number by adding commas between every </p>
<p class="calibre1">three digits, followed by a period and then two decimal digits. For example, </p>
<p class="calibre1">we would like to be able to display 1234.56 US dollars as $1,234.56. </p>
<p class="calibre1">The pygwidgets package already has a DisplayText class. We can instanti-</p>
<p class="calibre1">ate an object from that class using the following interface:</p>
<p class="calibre1">def __init__(self, window, loc=(0, 0), value='', </p>
<p class="calibre1">fontName=None, fontSize=18, width=None, height=None, </p>
<p class="calibre1">textColor=PYGWIDGETS_BLACK, backgroundColor=None, </p>
<p class="calibre1">justified='left', nickname=None):</p>
<p class="calibre1">Let’s assume that we have some code that creates a DisplayText object </p>
<p class="calibre1">named oSomeDisplayText using the appropriate arguments. Any time that we </p>
<p class="calibre1">want to update the text in a DisplayText object, we must call its setValue() </p>
<p class="calibre1">method, like this: </p>
<p class="calibre1">oSomeDisplayText.setValue('1234.56')</p>
<p class="calibre1">The functionality of displaying a number (as a string) with a DisplayText </p>
<p class="calibre1">object already exists. We want to create a new class named DisplayMoney that is </p>
<p class="calibre1">similar to DisplayText but adds functionality, so we’ll inherit from DisplayText. </p>
<p class="calibre1">Our DisplayMoney class will have an enhanced version of the setValue() </p>
<p class="calibre1">method that overrides the base class’s setValue() method. The DisplayMoney </p>
<p class="calibre1">version will add the desired formatting, by adding a currency symbol, add-</p>
<p class="calibre1">ing commas, optionally truncating to two decimal digits, and so on. At the </p>
<p class="calibre1">end, the method will call the inherited setValue() method of the DisplayText </p>
<p class="calibre1">base class and pass in a string version of the formatted text to display in the </p>
<p class="calibre1">window. </p>
<p class="calibre1">We’ll also add some additional setup parameters in the __init__() </p>
<p class="calibre1">method to allow client code to:</p>
<p class="calibre1">•  Choose the currency symbol (defaults to $)</p>
<p class="calibre1">•  Place the currency symbol on the left or right (defaults to left)</p>
<p class="calibre1">•  Show or hide two decimal places (defaults to show)</p>
<p class="calibre1"><b class="calibre3">222</b>   Chapter 10</p>
<p class="calibre1"><a id="p252"/>Listing 10-4 shows the code of our new DisplayMoney class. </p>
<p class="calibre1"><b class="calibre3">File: MoneyExamples/DisplayMoney.py</b></p>
<p class="calibre1"># DisplayMoney class - displays a number as an amount of money</p>
<p class="calibre1">#</p>
<p class="calibre1">#  Demo of inheritance</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">#</p>
<p class="calibre1">#  DisplayMoney class inherits from DisplayText class</p>
<p class="calibre1">#</p>
<p class="calibre1">1 class DisplayMoney(pygwidgets.DisplayText):</p>
<p class="calibre1">2 def __init__(self, window, loc, value=None, </p>
<p class="calibre1">fontName=None, fontSize=24, width=150, height=None, </p>
<p class="calibre1">textColor=BLACK, backgroundColor=None, </p>
<p class="calibre1">justified='left', value=None, currencySymbol='$', </p>
<p class="calibre1">currencySymbolOnLeft=True, showCents=True):</p>
<p class="calibre1">3 self.currencySymbol = currencySymbol</p>
<p class="calibre1">self.currencySymbolOnLeft = currencySymbolOnLeft</p>
<p class="calibre1">self.showCents = showCents</p>
<p class="calibre1">if value is None:</p>
<p class="calibre1">value = 0.00</p>
<p class="calibre1"># Call the __init__ method of our base class</p>
<p class="calibre1">4 super().__init__(window, loc, value, </p>
<p class="calibre1">fontName, fontSize, width, height, </p>
<p class="calibre1">textColor, backgroundColor, justified)</p>
<p class="calibre1">5 def setValue(self, money):</p>
<p class="calibre1">if money == '':</p>
<p class="calibre1">money = 0.00</p>
<p class="calibre1">money = float(money)</p>
<p class="calibre1">if self.showCents:  </p>
<p class="calibre1">money = '{:,.2f}'.format(money)</p>
<p class="calibre1">else:  </p>
<p class="calibre1">money = '{:,.0f}'.format(money)</p>
<p class="calibre1">if self.currencySymbolOnLeft:</p>
<p class="calibre1">theText = self.currencySymbol + money</p>
<p class="calibre1">else:</p>
<p class="calibre1">theText = money + self.currencySymbol</p>
<p class="calibre1"># Call the setValue method of our base class</p>
<p class="calibre1">6 super().setValue(theText)</p>
<p class="calibre1"> <i class="calibre4">Listing 10-4: DisplayMoney displays a number format ed as a monetary value. </i></p>
<p class="calibre1">Inheritance   <b class="calibre3">223</b></p>
<p class="calibre1"><a id="p253"/>In the class definition, we explicitly inherit from pygwidgets.DisplayText 1. </p>
<p class="calibre1">The DisplayMoney class only contains two methods: __init__() and setValue(). </p>
<p class="calibre1">These two methods override the methods with the same names in the base </p>
<p class="calibre1">class. </p>
<p class="calibre1">A client instantiates a DisplayMoney object like this:</p>
<p class="calibre1">oDisplayMoney = DisplayMoney(widow, (100, 100), 1234.56)</p>
<p class="calibre1">With this line, the __init__() method in DisplayMoney 2 will run and </p>
<p class="calibre1">override the __init__() method in the base class. This method does some </p>
<p class="calibre1">initialization, including saving any client preferences for the currency </p>
<p class="calibre1">symbol, the side on which to show the symbol, and whether or not we </p>
<p class="calibre1">should show cents, all in instance variables 3. The method ends with a </p>
<p class="calibre1">call to the __init__() method of the base class, DisplayText 4 (which it </p>
<p class="calibre1">finds by calling super()), and passes on the data required by that  </p>
<p class="calibre1">method. </p>
<p class="calibre1">Later, the client makes a call like this to show a value:</p>
<p class="calibre1">oDisplayMoney.setValue(12233.44)</p>
<p class="calibre1">The setValue() method 5 in the DisplayMoney class runs to create a ver-</p>
<p class="calibre1">sion of the amount of money formatted as a currency value. The method </p>
<p class="calibre1">ends by calling the inherited setValue() method in the DisplayText class 6 to </p>
<p class="calibre1">set the new text to display. </p>
<p class="calibre1">When a call is made to any other method with an instance of DisplayMoney, </p>
<p class="calibre1">the version residing in DisplayText will run. Most importantly, every time </p>
<p class="calibre1">through the loop, the client code should call oDisplayMoney.draw(), which </p>
<p class="calibre1">draws the field in the window. Since DisplayMoney does  <i class="calibre4">not</i> have a draw() </p>
<p class="calibre1">method, that call will go to the DisplayText base class, which does have a </p>
<p class="calibre1">draw() method. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Example Usage</b></i></p>
<p class="calibre1">Figure 10-5 shows the output of an example program that takes advantage </p>
<p class="calibre1">of both the InputNumber and DisplayMoney classes. The user enters a number </p>
<p class="calibre1">into an InputNumber field. When the user presses OK or ENTER, that value will </p>
<p class="calibre1">be displayed in the two DisplayMoney fields. The first field shows the number </p>
<p class="calibre1">with decimal places, and the second rounds to the closest dollar using dif-</p>
<p class="calibre1">ferent initial settings. </p>
<p class="calibre1">Listing 10-5 contains the full code of the main program. Notice </p>
<p class="calibre1">that the code creates a single InputNumber object and two DisplayMoney  </p>
<p class="calibre1">objects. </p>
<p class="calibre1"><b class="calibre3">224</b>   Chapter 10</p>
<p class="calibre1"><a id="p254"/><img src="index-254_1.png" alt="Image 28" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 10-5: A client program where the user enters an amount into an InputNumber</i> <i class="calibre4">field and the amount is displayed in two DisplayMoney fields</i></p>
<p class="calibre1"><b class="calibre3">File: MoneyExamples/Main_MoneyExample.py</b></p>
<p class="calibre1">#  Money example</p>
<p class="calibre1">#</p>
<p class="calibre1">#  Demonstrates overriding inherited DisplayText and InputText methods</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">from DisplayMoney import *</p>
<p class="calibre1">from InputNumber import *</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">BLACKISH = (10, 10, 10)</p>
<p class="calibre1">GRAY = (128, 128, 128)</p>
<p class="calibre1">WHITE = (255, 255, 255)</p>
<p class="calibre1">BACKGROUND_COLOR = (0, 180, 180)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode([WINDOW_WIDTH, WINDOW_HEIGHT])</p>
<p class="calibre1">clock = pygame.time.Clock()  </p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s),  etc. </p>
<p class="calibre1">Inheritance   <b class="calibre3">225</b></p>
<p class="calibre1"><a id="p255"/># 5 - Initialize variables</p>
<p class="calibre1">title = pygwidgets.DisplayText(window, (0, 40), </p>
<p class="calibre1">'Demo of InputNumber and DisplayMoney fields', </p>
<p class="calibre1">fontSize=36, width=WINDOW_WIDTH, justified='center')</p>
<p class="calibre1">inputCaption = pygwidgets.DisplayText(window, (20, 150), </p>
<p class="calibre1">'Input money amount:', fontSize=24, </p>
<p class="calibre1">width=190, justified='right')</p>
<p class="calibre1">inputField = InputNumber(window, (230, 150), '', width=150)</p>
<p class="calibre1">okButton = pygwidgets.TextButton(window, (430, 150), 'OK')</p>
<p class="calibre1">outputCaption1 = pygwidgets.DisplayText(window, (20, 300), </p>
<p class="calibre1">'Output dollars &amp; cents: ', fontSize=24, </p>
<p class="calibre1">width=190, justified='right')</p>
<p class="calibre1">moneyField1 = DisplayMoney(window, (230, 300), '', textColor=BLACK, </p>
<p class="calibre1">backgroundColor=WHITE, width=150)</p>
<p class="calibre1">outputCaption2 = pygwidgets.DisplayText(window, (20, 400), </p>
<p class="calibre1">'Output dollars only: ', fontSize=24, </p>
<p class="calibre1">width=190, justified='right')</p>
<p class="calibre1">moneyField2 = DisplayMoney(window, (230, 400), '', textColor=BLACK, </p>
<p class="calibre1">backgroundColor=WHITE, width=150, </p>
<p class="calibre1">showCents=False)</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"># If the event was a click on the close box, quit pygame and the program</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># Pressing Return/Enter or clicking OK triggers action</p>
<p class="calibre1">if inputField.handleEvent(event) or okButton.handleEvent(event): 1</p>
<p class="calibre1">try:</p>
<p class="calibre1">theValue = inputField.getValue()</p>
<p class="calibre1">except ValueError:  # any remaining error</p>
<p class="calibre1">inputField.setValue('(not a number)')</p>
<p class="calibre1">else:  # input was OK</p>
<p class="calibre1">theText = str(theValue)</p>
<p class="calibre1">moneyField1.setValue(theText)</p>
<p class="calibre1">moneyField2.setValue(theText)</p>
<p class="calibre1"># 8  Do any "per frame" actions</p>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(BACKGROUND_COLOR)</p>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">title.draw()</p>
<p class="calibre1">inputCaption.draw()</p>
<p class="calibre1">inputField.draw()</p>
<p class="calibre1">okButton.draw()</p>
<p class="calibre1"><b class="calibre3">226</b>   Chapter 10</p>
<p class="calibre1"><a id="p256"/>    outputCaption1.draw()</p>
<p class="calibre1">moneyField1.draw()</p>
<p class="calibre1">outputCaption2.draw()</p>
<p class="calibre1">moneyField2.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 10-5: The main program to demonstrate the InputNumber and DisplayMoney classes</i> The user enters the number into an InputNumber field. As the user types, </p>
<p class="calibre1">any inappropriate characters are filtered out and ignored by the handleEvent() </p>
<p class="calibre1">method. When the user clicks OK 1, the code reads the input and passes it to </p>
<p class="calibre1">the two DisplayMoney fields. The first shows the dollar and cents amount (with </p>
<p class="calibre1">two decimal digits), while the second shows the value in dollars only. Both </p>
<p class="calibre1">add a $ as the currency symbol and add commas every three digits. </p>
<p class="calibre1"><b class="calibre3">Multiple Classes Inheriting from the Same Base Class</b></p>
<p class="calibre1">Multiple different classes can inherit from the same base class. You can </p>
<p class="calibre1">build a very general base class, then construct any number of subclasses </p>
<p class="calibre1">that inherit from it. Figure 10-6 is a representation of this relationship. </p>
<p class="calibre1">Base class</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">Subclass</p>
<p class="calibre1">Subclass</p>
<p class="calibre1">Subclass</p>
<p class="calibre1">…</p>
<p class="calibre1"> <i class="calibre4">Figure 10-6: Three or more different subclasses inheriting from a common base class</i> Each of the different subclasses can then be a variant (a more specific </p>
<p class="calibre1">version) of the generic base class. Each subclass can override any methods </p>
<p class="calibre1">of the base class that it wants to or needs to, independent of any other </p>
<p class="calibre1">subclass. </p>
<p class="calibre1">Let’s walk through an example using the Shapes program from </p>
<p class="calibre1"><a href="index_split_003.html#p212">Chapter 9 t</a>hat created and drew circles, squares, and triangles. The code also allowed the user to click on any shape in the window to see the area of </p>
<p class="calibre1">that shape. </p>
<p class="calibre1">The program was implemented with three different shape classes: </p>
<p class="calibre1">Circle, Square, and Triangle. If we look back at those three classes, we find </p>
<p class="calibre1">that each one has this exact same method:</p>
<p class="calibre1">def getType(self):</p>
<p class="calibre1">return self.shapeType</p>
<p class="calibre1">Inheritance   <b class="calibre3">227</b></p>
<p class="calibre1"><a id="p257"/>Further, looking at the __init__() methods of the three classes, we find that there is some common code that remembers the window, chooses a </p>
<p class="calibre1">random color, and chooses a random location:</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(1, maxWidth - 100)</p>
<p class="calibre1">self.y = random.randrange(1, maxHeight - 100)</p>
<p class="calibre1">Finally, each class sets the instance variable self.shapeType to an appro-</p>
<p class="calibre1">priate string. </p>
<p class="calibre1">Whenever we find a set of classes that implement the exact same method </p>
<p class="calibre1">and/or share some code in a commonly named method, we should recog-</p>
<p class="calibre1">nize that this is a good candidate for inheritance. </p>
<p class="calibre1">Let’s extract the common code from the three classes and build a com-</p>
<p class="calibre1">mon base class named Shape, shown in Listing 10-6. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/ShapeBasic.py</b></p>
<p class="calibre1"># Shape class - basic </p>
<p class="calibre1">import random</p>
<p class="calibre1"># Set up the colors</p>
<p class="calibre1">RED = (255, 0, 0)</p>
<p class="calibre1">GREEN = (0, 255, 0)</p>
<p class="calibre1">BLUE = (0, 0, 255)</p>
<p class="calibre1"/>
<p class="calibre1">class Shape():</p>
<p class="calibre1">1 def __init__(self, window, shapeType, maxWidth, maxHeight):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.shapeType = shapeType</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(1, maxWidth - 100)</p>
<p class="calibre1">self.y = random.randrange(25, maxHeight - 100)</p>
<p class="calibre1">2 def getType(self):</p>
<p class="calibre1">return self.shapeType</p>
<p class="calibre1"> <i class="calibre4">Listing 10-6: The Shape class, to be used as a base class</i></p>
<p class="calibre1">The class consists of only two methods: __init__() and getType(). The </p>
<p class="calibre1">__init__() method 1 remembers the data passed in in instance vari-</p>
<p class="calibre1">ables, then randomly chooses a color and a starting location (self.x and </p>
<p class="calibre1">self.y). The getType() method 2 just returns the type of the shape given </p>
<p class="calibre1">at initialization. </p>
<p class="calibre1">We can now write any number of subclasses that inherit from Shape. </p>
<p class="calibre1">We’ll create three subclasses that will call the __init__() method of the Shape </p>
<p class="calibre1">class, passing in a string that identifies its type and the size of the window. </p>
<p class="calibre1">The getType() method will only appear in the Shape class, so any client calls </p>
<p class="calibre1"><b class="calibre3">228</b>   Chapter 10</p>
<p class="calibre1"><a id="p258"/>to getType() will be handled by that method in the inherited Shape class. </p>
<p class="calibre1">We’ll start with the code for the Square class, shown in Listing 10-7. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/Square.py</b></p>
<p class="calibre1"># Square class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from Shape import *</p>
<p class="calibre1">class Square(Shape): 1</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">super().__init__(window, 'Square', maxWidth, maxHeight) 2</p>
<p class="calibre1">self.widthAndHeight = random.randrange(10, 100)</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, </p>
<p class="calibre1">self.widthAndHeight, self.widthAndHeight)</p>
<p class="calibre1">def clickedInside(self, mousePoint): 3</p>
<p class="calibre1">clicked = self.rect.collidepoint(mousePoint)</p>
<p class="calibre1">return clicked</p>
<p class="calibre1"/>
<p class="calibre1">def getArea(self): 4</p>
<p class="calibre1">theArea = self.widthAndHeight * self.widthAndHeight</p>
<p class="calibre1">return theArea</p>
<p class="calibre1">def draw(self): 5</p>
<p class="calibre1">pygame.draw.rect(self.window, self.color, </p>
<p class="calibre1">(self.x, self.y, self.widthAndHeight, self.widthAndHeight))</p>
<p class="calibre1"> <i class="calibre4">Listing 10-7: The Square class that inherits from the Shape class</i></p>
<p class="calibre1">The Square class starts by inheriting from the Shape class 1. The  </p>
<p class="calibre1">__init__() method calls the __init__() method of its base class (or super-</p>
<p class="calibre1">class) 2, identifying this shape as a square and randomly choosing its size. </p>
<p class="calibre1">Next we have three methods whose implementation is specific  </p>
<p class="calibre1">to a square. The clickedInside() method only needs to make a call to  </p>
<p class="calibre1">rect.collidepoint() to determine if a click happened inside its rectan-</p>
<p class="calibre1">gle 3. The getArea() method simply multiplies the widthAndHeight by the </p>
<p class="calibre1">widthAndHeight 4. Finally, the draw() method draws a rectangle using the </p>
<p class="calibre1">value of widthAndHeight 5. </p>
<p class="calibre1">Listing 10-8 shows the Circle class, which has also been modified to </p>
<p class="calibre1">inherit from the Shape class. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/Circle.py</b></p>
<p class="calibre1"># Circle class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from Shape import *</p>
<p class="calibre1">import math</p>
<p class="calibre1">Inheritance   <b class="calibre3">229</b></p>
<p class="calibre1"><a id="p259"/>class Circle(Shape):</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">super().__init__(window, 'Circle', maxWidth, maxHeight)</p>
<p class="calibre1">self.radius = random.randrange(10, 50)</p>
<p class="calibre1">self.centerX = self.x + self.radius</p>
<p class="calibre1">self.centerY = self.y + self.radius</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, self.radius * 2, self.radius * 2)</p>
<p class="calibre1"/>
<p class="calibre1">def clickedInside(self, mousePoint):</p>
<p class="calibre1">theDistance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) + </p>
<p class="calibre1">((mousePoint[1] - self.centerY) ** 2))</p>
<p class="calibre1">if theDistance &lt;= self.radius:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1">def getArea(self):</p>
<p class="calibre1">theArea = math.pi * (self.radius ** 2)</p>
<p class="calibre1">return theArea</p>
<p class="calibre1">def draw(self):</p>
<p class="calibre1">pygame.draw.circle(self.window, self.color, (self.centerX, self.centerY), </p>
<p class="calibre1">self.radius, 0)</p>
<p class="calibre1"> <i class="calibre4">Listing 10-8: The Circle class that inherits from the Shape class</i></p>
<p class="calibre1">The Circle class also contains the clickedInside(), getArea(), and draw() </p>
<p class="calibre1">methods, whose implementation is specific to a circle. </p>
<p class="calibre1">Finally, Listing 10-9 shows the code of the Triangle class. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/Triangle.py</b></p>
<p class="calibre1"># Triangle class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from Shape import *</p>
<p class="calibre1">class Triangle(Shape):</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">super().__init__(window, 'Triangle', maxWidth, maxHeight)</p>
<p class="calibre1">self.width = random.randrange(10, 100)</p>
<p class="calibre1">self.height = random.randrange(10, 100)</p>
<p class="calibre1">self.triangleSlope = -1 * (self.height / self.width)</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, self.width, self.height)</p>
<p class="calibre1">def clickedInside(self, mousePoint):</p>
<p class="calibre1">inRect = self.rect.collidepoint(mousePoint)</p>
<p class="calibre1">if not inRect:</p>
<p class="calibre1">return False</p>
<p class="calibre1"># Do some math to see if the point is inside the triangle</p>
<p class="calibre1">xOffset = mousePoint[0] - self.x</p>
<p class="calibre1"><b class="calibre3">230</b>   Chapter 10</p>
<p class="calibre1"><a id="p260"/>        yOffset = mousePoint[1] – self.y</p>
<p class="calibre1">if xOffset == 0:</p>
<p class="calibre1">return True</p>
<p class="calibre1">pointSlopeFromYIntercept = (yOffset – self.height) / xOffset  # rise over run</p>
<p class="calibre1">if pointSlopeFromYIntercept &lt; 1:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1">def getArea(self):</p>
<p class="calibre1">theArea = .5 * self.width * self.height</p>
<p class="calibre1">return theArea</p>
<p class="calibre1">def draw(self):</p>
<p class="calibre1">pygame.draw.polygon(self.window, self.color, (</p>
<p class="calibre1">(self.x, self.y + self.height), </p>
<p class="calibre1">(self.x, self.y), </p>
<p class="calibre1">(self.x + self.width, self.y)))</p>
<p class="calibre1"> <i class="calibre4">Listing 10-9: The Triangle class that inherits from the Shape class</i></p>
<p class="calibre1">The main code we used for testing i<a href="index_split_003.html#p212">n Chapter 9 d</a>oesn’t have to change at all. As a client of these new classes, it instantiates Square, Circle, and Triangle objects without having to worry about the implementation of those classes. It </p>
<p class="calibre1">doesn’t need to know that each is subclassed from a common Shape class. </p>
<p class="calibre1"><b class="calibre3">Abstract Classes and Methods</b></p>
<p class="calibre1">Unfortunately, our Shape base class has a potential bug. At the moment, a </p>
<p class="calibre1">client could instantiate a generic Shape object, which is too generic to have </p>
<p class="calibre1">its own getArea() method. Further, all classes that inherit from the Shape </p>
<p class="calibre1">class (like Square, Circle, and Triangle)  <i class="calibre4">must</i> implement clickedInside(), </p>
<p class="calibre1">getArea(), and draw(). To solve both of these problems, I’ll introduce the </p>
<p class="calibre1">concepts of an  <i class="calibre4">abstract class</i> and an  <i class="calibre4">abstract method</i>. </p>
<p class="calibre1"><b class="calibre3">abstract class</b> </p>
<p class="calibre1">A class that is  <i class="calibre4">not</i> intended to be instantiated directly, but only to be used as a base class by one or more subclasses . (In some other languages, an abstract class is </p>
<p class="calibre1">referred to as a  <i class="calibre4">virtual class</i> .)</p>
<p class="calibre1"><b class="calibre3">abstract method</b>  A method that  <i class="calibre4">must</i> be overridden in every subclass . </p>
<p class="calibre1">Often, a base class cannot correctly implement an abstract method </p>
<p class="calibre1">because it cannot know the detailed data it should operate on, or it may not </p>
<p class="calibre1">be possible to implement a general algorithm. Instead, all subclasses need </p>
<p class="calibre1">to implement their own version of the abstract method. </p>
<p class="calibre1">In our shapes example, we want the Shape class to be an abstract class </p>
<p class="calibre1">so no client code can instantiate a Shape object. Further, our Shape class </p>
<p class="calibre1">Inheritance   <b class="calibre3">231</b></p>
<p class="calibre1"><a id="p261"/>should indicate that all its subclasses need to implement the clickedInside(), getArea(), and draw() methods. </p>
<p class="calibre1">Python does not have a keyword to designate a class or method as </p>
<p class="calibre1">abstract. However, the Python Standard Library contains the abc mod-</p>
<p class="calibre1">ule, short for  <i class="calibre4">abstract base class</i>, which is designed to help developers build abstract base classes and methods. </p>
<p class="calibre1">Let’s take a look at what we need to do to build an abstract class with </p>
<p class="calibre1">abstract methods. To begin, we need to import two things from the abc </p>
<p class="calibre1">module:</p>
<p class="calibre1">from abc import ABC, abstractmethod</p>
<p class="calibre1">Next, we need to indicate that the class we want to act as an abstract </p>
<p class="calibre1">base class should inherit from the ABC class, which we do by putting ABC </p>
<p class="calibre1">inside parentheses after the class name:</p>
<p class="calibre1">class  <i class="calibre4">&lt;classWeWantToDesignateAsAbstract&gt; </i>(ABC):</p>
<p class="calibre1">We then must use the special decorator @abstractmethod before any meth-</p>
<p class="calibre1">ods that must be overwritten by all subclasses:</p>
<p class="calibre1">@abstractmethod</p>
<p class="calibre1">def  <i class="calibre4">&lt;someMethodThatMustBeOverwritten&gt; </i>(self, ...):</p>
<p class="calibre1">Listing 10-10 shows how we can mark our Shape class as an abstract base </p>
<p class="calibre1">class and indicate its abstract methods. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/Shape.py</b></p>
<p class="calibre1"># Shape class</p>
<p class="calibre1">#</p>
<p class="calibre1"># To be used as a base class for other classes</p>
<p class="calibre1">import random</p>
<p class="calibre1">from abc import ABC, abstractmethod</p>
<p class="calibre1"># Set up the colors</p>
<p class="calibre1">RED = (255, 0, 0)</p>
<p class="calibre1">GREEN = (0, 255, 0)</p>
<p class="calibre1">BLUE = (0, 0, 255)</p>
<p class="calibre1">1 class Shape(ABC):  # identifies this as an abstract base class</p>
<p class="calibre1">2 def __init__(self, window, shapeType, maxWidth, maxHeight):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.shapeType = shapeType</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(1, maxWidth - 100)</p>
<p class="calibre1">self.y = random.randrange(25, maxHeight - 100)</p>
<p class="calibre1">3 def getType(self):</p>
<p class="calibre1">return self.shapeType</p>
<p class="calibre1"><b class="calibre3">232</b>   Chapter 10</p>
<p class="calibre1"><a id="p262"/>  4 @abstractmethod</p>
<p class="calibre1">def clickedInside(self, mousePoint):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">5 @abstractmethod</p>
<p class="calibre1">def getArea(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">6 @abstractmethod</p>
<p class="calibre1">def draw(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1"> <i class="calibre4">Listing 10-10: The Shape base class that inherits from ABC with abstract methods</i> The Shape class inherits from the ABC class 1, telling Python to prevent </p>
<p class="calibre1">client code from instantiating a Shape object directly. Any attempt to do so </p>
<p class="calibre1">results in the following error message:</p>
<p class="calibre1">TypeError: Can't instantiate abstract class Shape with abstract methods </p>
<p class="calibre1">clickedInside, draw, getArea</p>
<p class="calibre1">The __init__() 2 and getType() 3 methods contain code that will be </p>
<p class="calibre1">shared by all subclasses of Shape. </p>
<p class="calibre1">The clickedInside() 4, getArea() 5, and draw() 6 methods are all pre-</p>
<p class="calibre1">ceded by the @abstractmethod decorator. This decorator indicates that these </p>
<p class="calibre1">methods  <i class="calibre4">must</i> be overwritten by all subclasses of Shape. Since these methods in this abstract class will never run, the implementation here consists only </p>
<p class="calibre1">of raise NotImplementedError to further emphasize that the method doesn’t </p>
<p class="calibre1">do anything. </p>
<p class="calibre1">Let’s extend the shape demonstration program to add a new Rectangle </p>
<p class="calibre1">class, as shown in Listing 10-11. The Rectangle class inherits from the </p>
<p class="calibre1">abstract Shape class and therefore must implement the clickedInside(), </p>
<p class="calibre1">getArea(), and draw() methods. I’ll make an intentional error in this subclass </p>
<p class="calibre1">to show what happens. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/Rectangle.py</b></p>
<p class="calibre1"># Rectangle class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from Shape import *</p>
<p class="calibre1">class Rectangle(Shape):</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">super().__init__(window, 'Rectangle', maxWidth, maxHeight)</p>
<p class="calibre1">self.width = random.randrange(10, 100)</p>
<p class="calibre1">self.height = random.randrange(10, 100)</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, self.width, self.height)</p>
<p class="calibre1">def clickedInside(self, mousePoint):</p>
<p class="calibre1">Inheritance   <b class="calibre3">233</b></p>
<p class="calibre1"><a id="p263"/>        clicked = self.rect.collidepoint(mousePoint)</p>
<p class="calibre1">return clicked</p>
<p class="calibre1">def getArea(self):</p>
<p class="calibre1">theArea = self.width * self.height</p>
<p class="calibre1">return theArea</p>
<p class="calibre1"> <i class="calibre4">Listing 10-11: The Rectangle class that implements clickedInside() and getArea(), but not draw()</i> As a demonstration, this class mistakenly does not contain a draw() </p>
<p class="calibre1">method. Listing 10-12 shows a modified version of the main code that </p>
<p class="calibre1">includes the creation of Rectangle objects. </p>
<p class="calibre1"><b class="calibre3">File: InheritedShapes/Main_ShapesWithRectangle.py</b></p>
<p class="calibre1">shapesList = []</p>
<p class="calibre1">shapeClassesTuple = ('Square', 'Circle', 'Triangle', 'Rectangle')</p>
<p class="calibre1">for i in range(0, N_SHAPES):</p>
<p class="calibre1">randomlyChosenClass = random.choice(shapeClassesTuple)</p>
<p class="calibre1">oShape = randomlyChosenClass(window, WINDOW_WIDTH, WINDOW_HEIGHT)</p>
<p class="calibre1">shapesList.append(oShape)</p>
<p class="calibre1"> <i class="calibre4">Listing 10-12: The main code that randomly creates Squares, Circles, Triangles, and</i> <i class="calibre4">Rectangles</i></p>
<p class="calibre1">When this code attempts to create a Rectangle object, Python generates </p>
<p class="calibre1">this error message:</p>
<p class="calibre1">TypeError: Can't instantiate abstract class Rectangle with abstract method </p>
<p class="calibre1">draw</p>
<p class="calibre1">This tells us that we cannot instantiate a Rectangle object because we did </p>
<p class="calibre1">not write a draw() method in our Rectangle class. Adding a draw() method to </p>
<p class="calibre1">the Rectangle class (with appropriate code to draw the rectangle) fixes the </p>
<p class="calibre1">error. </p>
<p class="calibre1"><b class="calibre3">How pygwidgets Uses Inheritance</b></p>
<p class="calibre1">The pygwidgets module uses inheritance to share common code. For exam-</p>
<p class="calibre1">ple, consider the two button classes we discussed in <a href="index_split_003.html#p172">Chapter 7: </a>TextButton and CustomButton. The TextButton class requires a string to be used as a label </p>
<p class="calibre1">on the button, while the CustomButton class requires you to supply your own </p>
<p class="calibre1">art. The way that you create an instance of each of these classes is dif-</p>
<p class="calibre1">ferent—you need to specify a different set of arguments. However, once </p>
<p class="calibre1">created, all the remaining methods of both objects are exactly the same. </p>
<p class="calibre1">That’s because the two classes inherit from a common base class, named </p>
<p class="calibre1">PygWidgetsButton (Figure 10-7). </p>
<p class="calibre1">PygWidgetsButton is an abstract class. Client code is not supposed to </p>
<p class="calibre1">create an instance of it, and attempting to do so will generate an error </p>
<p class="calibre1">message. </p>
<p class="calibre1"><b class="calibre3">234</b>   Chapter 10</p>
<p class="calibre1"><a id="p264"/><img src="index-264_1.png" alt="Image 29" class="calibre2"/></p>
<p class="calibre1">(Abstract base class)</p>
<p class="calibre1">PygWidgetsButton</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">TextButton</p>
<p class="calibre1">CustomButton</p>
<p class="calibre1"> <i class="calibre4">Figure 10-7: The pygwidgets TextButton and CustomButton  </i></p>
<p class="calibre1"> <i class="calibre4">classes both inherit from PygWidgetsButton. </i></p>
<p class="calibre1">Instead, PygWidgetsButton is subclassed by the TextButton and CustomButton </p>
<p class="calibre1">classes. Those classes each provide the single method, __init__(), which </p>
<p class="calibre1">will do whatever is needed to initialize their type of button. Each will then </p>
<p class="calibre1">pass on identical arguments to the __init__() method of the base class, </p>
<p class="calibre1">PygWidgetsButton. </p>
<p class="calibre1">The TextButton class is used to build a text-based button with minimal </p>
<p class="calibre1">art. This is helpful when trying to get programs up and running quickly. </p>
<p class="calibre1">Here is the interface for creating a TextButton object:</p>
<p class="calibre1">def __init__(self, window, loc, text, width=None, height=40, </p>
<p class="calibre1">textColor=PYGWIDGETS_BLACK, </p>
<p class="calibre1">upColor= PYGWIDGETS_NORMAL_GRAY, </p>
<p class="calibre1">overColor= PYGWIDGETS_OVER_GRAY, </p>
<p class="calibre1">downColor=PYGWIDGETS_DOWN_GRAY, </p>
<p class="calibre1">fontName=None, fontSize=20, soundOnClick=None, </p>
<p class="calibre1">enterToActivate=False, callBack=None, nickname=None)</p>
<p class="calibre1">While many of the parameters default to reasonable values, the caller </p>
<p class="calibre1">must provide a value for text, which will appear on the button. The __init__() </p>
<p class="calibre1">method itself creates “surfaces” (images) for the button that are used in dis-</p>
<p class="calibre1">playing a standard button. The code to create a typical TextButton object looks </p>
<p class="calibre1">like this:</p>
<p class="calibre1">oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')</p>
<p class="calibre1">When drawn, the user sees a button that looks like Figure 10-8. </p>
<p class="calibre1"> <i class="calibre4">Figure 10-8: An example of a  </i></p>
<p class="calibre1"> <i class="calibre4">typical TextButton</i></p>
<p class="calibre1">The CustomButton class is used to build a button using artwork the client </p>
<p class="calibre1">supplies. Here is the interface for creating a CustomButton: </p>
<p class="calibre1">def __init__(self, window, loc, up, down=None, over=None, </p>
<p class="calibre1">disabled=None, soundOnClick=None, </p>
<p class="calibre1">nickname=None, enterToActivate=False):</p>
<p class="calibre1">Inheritance   <b class="calibre3">235</b></p>
<p class="calibre1"><a id="p265"/>The key difference is that this version of the __init__() method requires the caller to supply a value for the up parameter (remember, a button has </p>
<p class="calibre1">four images: up, down, disabled, and over). You can optionally also sup-</p>
<p class="calibre1">ply down, over, and disabled images. For any image that is not supplied, </p>
<p class="calibre1">CustomButton makes a copy of the up image of the button and uses that. </p>
<p class="calibre1">The last line of the __init__() methods for  <i class="calibre4">both</i> the TextButton and </p>
<p class="calibre1">CustomButton classes is a call to the __init__() method of the common base </p>
<p class="calibre1">class, PygWidgetsButton. Both calls pass in four images for the button, along </p>
<p class="calibre1">with other arguments:</p>
<p class="calibre1">super().__init__(window, loc, surfaceUp, surfaceOver, </p>
<p class="calibre1">surfaceDown, surfaceDisabled, buttonRect, </p>
<p class="calibre1">soundOnClick, nickname, enterToActivate, callBack)</p>
<p class="calibre1">From the client’s point of view, you see two completely different classes </p>
<p class="calibre1">with many methods (most of which are identical). But from the implement-</p>
<p class="calibre1">er’s point of view, you can now see how inheritance allowed us to override </p>
<p class="calibre1">the single __init__() method in the base class to provide client program-</p>
<p class="calibre1">mers with two similar, but very useful, ways of creating buttons. The two </p>
<p class="calibre1">classes share everything other than the __init__() method. Therefore, </p>
<p class="calibre1">the way that the buttons function, and the method calls that are available </p>
<p class="calibre1">( handleEvent(), draw(), disable(), enable(), and so on), must be identical. </p>
<p class="calibre1">There are a number of benefits to this kind of inheritance. First, it pro-</p>
<p class="calibre1">vides consistency for both the client code and the end user: TextButton and </p>
<p class="calibre1">CustomButton objects work the same way. It also makes bugs easier to fix— </p>
<p class="calibre1">fixing a bug in a base class means you have then fixed the bug in all sub-</p>
<p class="calibre1">classes that inherit from it. Finally, if you add functionality in the base class, </p>
<p class="calibre1">it is available immediately in all classes that inherit from the base class. </p>
<p class="calibre1"><b class="calibre3">Class Hierarchy</b></p>
<p class="calibre1">Any class can be used as a base class, even a subclass that already inherits </p>
<p class="calibre1">from another base class. This kind of relationship, known as a  <i class="calibre4">class hierarchy</i>, is depicted in Figure 10-9. </p>
<p class="calibre1">Class A</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">Class B</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">Class C</p>
<p class="calibre1"> <i class="calibre4">Figure 10-9: A class hierarchy</i></p>
<p class="calibre1"><b class="calibre3">236</b>   Chapter 10</p>
<p class="calibre1"><a id="p266"/>In this figure, class C inherits from class B, which inherits from class A. </p>
<p class="calibre1">Therefore, class C is a subclass and class B is a base class, but class B is also a subclass of class A. So, class B serves in both roles. In cases like this, class C </p>
<p class="calibre1">inherits not only all the methods and instance variables in class B, but also </p>
<p class="calibre1">all the methods and instance variables in class A. This type of hierarchy can </p>
<p class="calibre1">be very useful when building more and more specific classes. Class A can be </p>
<p class="calibre1">very general, class B more detailed, and class C even more specific. </p>
<p class="calibre1">Figure 10-10 provides a different way to think about the relationships in </p>
<p class="calibre1">a class hierarchy. </p>
<p class="calibre1">Class A</p>
<p class="calibre1">Class B</p>
<p class="calibre1">Class C</p>
<p class="calibre1"> <i class="calibre4">Figure 10-10: A different way of  </i></p>
<p class="calibre1"> <i class="calibre4">portraying a class hierarchy</i></p>
<p class="calibre1">Here, the client sees only class C, but this class is made up of all the </p>
<p class="calibre1">methods and instance variables defined collectively in classes C, B, and A. </p>
<p class="calibre1">The pygwidgets package uses a class hierarchy for all widgets. The first </p>
<p class="calibre1">class in pygwidgets is the abstract class PygWidget, which supplies basic func-</p>
<p class="calibre1">tionality to all widgets in the package. Its code consists of methods that </p>
<p class="calibre1">allow for showing and hiding, enabling and disabling, getting and setting </p>
<p class="calibre1">the location, and getting the nickname (internal name) of any widget. </p>
<p class="calibre1">There are other classes in pygwidgets that are used as abstract classes, </p>
<p class="calibre1">including the aforementioned PygWidgetsButton, which is the base class of </p>
<p class="calibre1">both TextButton and CustomButton. Figure 10-11 should help make this rela-</p>
<p class="calibre1">tionship clear. </p>
<p class="calibre1">PygWidget</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">PygWidgetsButton</p>
<p class="calibre1">Inherits from</p>
<p class="calibre1">TextButton</p>
<p class="calibre1">CustomButton</p>
<p class="calibre1"> <i class="calibre4">Figure 10-11: Class hierarchy in pygwidgets</i></p>
<p class="calibre1">Inheritance   <b class="calibre3">237</b></p>
<p class="calibre1"><a id="p267"/>As you can see, the PygWidgetsButton class is both a subclass of PygWidget and a base class for TextButton and CustomButton. </p>
<p class="calibre1"><b class="calibre3">The Difficulty of Programming with Inheritance</b></p>
<p class="calibre1">When developing using inheritance, it can be difficult to understand what </p>
<p class="calibre1">to put where. You’re constantly asking yourself questions like: Should this </p>
<p class="calibre1">instance variable be in the base class? Is there enough common code in sub-</p>
<p class="calibre1">classes to create a method in the base class? What are appropriate param-</p>
<p class="calibre1">eters for a method in a subclass? What are appropriate parameters and </p>
<p class="calibre1">defaults to be used in a base class that expects to be overridden or called </p>
<p class="calibre1">from a subclass? </p>
<p class="calibre1">Attempting to understand the interactions among all the variables and </p>
<p class="calibre1">methods in a hierarchy of classes can be an extremely difficult, tricky, and </p>
<p class="calibre1">frustrating task. This is especially true when reading the code of a class </p>
<p class="calibre1">hierarchy developed by another programmer. To fully understand what’s </p>
<p class="calibre1">going on, you often have to become familiar with the code in the base </p>
<p class="calibre1">classes all the way up the hierarchy. </p>
<p class="calibre1">For example, imagine a hierarchy in which class D is a subclass of C, </p>
<p class="calibre1">which is a subclass of B, which is a subclass of the base class A. In class D, you </p>
<p class="calibre1">may encounter code that branches based on the value of an instance vari-</p>
<p class="calibre1">able, but that variable might never be set in the code of class D. In cases like </p>
<p class="calibre1">this, you must look for the instance variable in the code of class C. If it is not </p>
<p class="calibre1">found there, then you must look in the code of class B, and so on. </p>
<p class="calibre1">When designing a class hierarchy, perhaps the best way to avoid this </p>
<p class="calibre1">problem is to only call methods and use instance variables inherited from </p>
<p class="calibre1">one layer up in the hierarchy. In our example, code in class D should only </p>
<p class="calibre1">make calls to methods in class C, while class C should only make calls to </p>
<p class="calibre1">methods in class B, and so on. This is a simplistic version of the  <i class="calibre4">Law of </i></p>
<p class="calibre1"> <i class="calibre4">Demeter</i>. Stated simply, you (meaning objects) should only talk to your </p>
<p class="calibre1">immediate friends (nearby objects) and never talk to strangers (distant </p>
<p class="calibre1">objects). A detailed discussion is beyond the scope of this book, but there </p>
<p class="calibre1">are many references available on the internet. </p>
<p class="calibre1">Another approach, which we first talked about i<a href="index_split_001.html#p86">n Chapter 4, i</a>s to take advantage of  <i class="calibre4">composition</i>, where an object instantiates one or more other </p>
<p class="calibre1">objects. The key difference is that inheritance is used to model an “is a” </p>
<p class="calibre1">relationship, whereas composition uses a “has a” relationship. For example, </p>
<p class="calibre1">if we wanted to have a spinbox widget (an editable text number field with </p>
<p class="calibre1">an up and a down arrow), we could build a SpinBox class that instantiates </p>
<p class="calibre1">a DisplayNumber object and two CustomButton objects for the arrows. Each of </p>
<p class="calibre1">these objects already knows how to handle its user interactions. </p>
<p class="calibre1"><b class="calibre3">238</b>   Chapter 10</p>
<p class="calibre1"><a id="p268"/><b class="calibre3">MULTIPLE INHERITANCE</b></p>
<p class="calibre1">You’ve seen how a class can inherit from another class . In fact, Python (like </p>
<p class="calibre1">some other programming languages) al ows a class to inherit from more than </p>
<p class="calibre1">just one class . This is known as  <i class="calibre4">multiple inheritance</i> . The Python syntax is for inheriting from more than one class is quite straightforward:</p>
<p class="calibre1">class  <i class="calibre4">SomeClass</i>( <i class="calibre4">&lt;BaseClass1&gt; </i>,  <i class="calibre4">&lt;BaseClass2&gt; </i>, ...): However, it’s important to be aware that multiple inheritance can potential y introduce conflicts when the base classes you inherit from contain iden-</p>
<p class="calibre1">tical y named methods and/or instance variables . Python does have rules </p>
<p class="calibre1">(known as the  <i class="calibre4">method resolution order</i>, or  <i class="calibre4">MRO</i>) to resolve these potential problems . I consider this an advanced topic and will not cover it here, but if </p>
<p class="calibre1">you want to look into it, a detailed discussion can be found a<a href="https://www.python.org/download/releases/2.3/mro">t  <i class="calibre4">ht ps://www </i></a></p>
<p class="calibre1"><a href="https://www.python.org/download/releases/2.3/mro"> <i class="calibre4">.python.org/download/releases/2.3/mro. </i></a></p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">This was a very ambitious chapter on the topic of inheritance: the art of </p>
<p class="calibre1">“programming by difference.” The basic idea of inheritance is to build a </p>
<p class="calibre1">class (a subclass) that incorporates all the methods and instance variables </p>
<p class="calibre1">of another class (a base class), thereby allowing you to reuse existing code. </p>
<p class="calibre1">Your new subclass can choose to use or override the methods of the base </p>
<p class="calibre1">class, as well as define its own methods. A method in a subclass can find the </p>
<p class="calibre1">base class by using a call to super(). </p>
<p class="calibre1">We built two classes, InputNumber and DisplayMoney that provide highly </p>
<p class="calibre1">reusable functionality. These classes are implemented as subclasses that use </p>
<p class="calibre1">classes in the pygwidgets package as base classes. </p>
<p class="calibre1">Any client code that uses your subclass will see an interface that incor-</p>
<p class="calibre1">porates methods defined in both the subclass and the base class. Any num-</p>
<p class="calibre1">ber of subclasses can be built using the same base class. An abstract class </p>
<p class="calibre1">is one that is not intended to be instantiated by client code, but rather is </p>
<p class="calibre1">intended only to be inherited from by subclasses. An abstract method in a </p>
<p class="calibre1">base class is one that  <i class="calibre4">must</i> be overridden in each subclass. </p>
<p class="calibre1">We worked through a number of examples to demonstrate inheritance </p>
<p class="calibre1">in the pygwidgets package, including how the TextButton and CustomButton </p>
<p class="calibre1">classes both inherit from a common base class, PygWidgetsButton. </p>
<p class="calibre1">I showed how you can build a class hierarchy, where a class inherits </p>
<p class="calibre1">from another class, which in turn inherits from a third class, and so on. </p>
<p class="calibre1">Inheritance can be complex—reading someone else’s code can be </p>
<p class="calibre1">confusing—but as we’ve seen, inheritance can be extremely powerful. </p>
<p class="calibre1">Inheritance   <b class="calibre3">239</b></p>
<p class="calibre1"><a id="p269"/>
<a id="p270"/><b class="calibre3">11</b></p>
<p class="calibre1"><b class="calibre3">M A N A G I N G   M E M O R Y </b></p>
<p class="calibre1"><b class="calibre3">U S E D   B Y   O B J E C T S</b></p>
<p class="calibre1">This chapter will explain a few important </p>
</body></html>