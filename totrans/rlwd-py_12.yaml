- en: '12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARE WE LIVING IN A COMPUTER SIMULATION?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In 2003, the philosopher Nick Bostrom postulated that we live in a computer
    simulation run by our advanced, possibly post-human, descendants. Today, many
    scientists and big thinkers, including Neil DeGrasse Tyson and Elon Musk, believe
    there’s a good chance this *simulation hypothesis* is true. It certainly explains
    why mathematics so elegantly describes nature, why observers seem to influence
    quantum events, and why we appear to be alone in the universe.
  prefs: []
  type: TYPE_NORMAL
- en: Even stranger, *you* could be the only real thing in this simulation. Perhaps
    you’re a brain in a vat, immersing yourself in a historical simulation. For computational
    efficiency, the simulation might render only those things with which you currently
    interact. When you go inside and close your door, the world outside might turn
    off like a refrigerator light. How would you really know one way or the other?
  prefs: []
  type: TYPE_NORMAL
- en: 'Scientists take this hypothesis seriously, holding debates and publishing papers
    on how we might devise some test to prove it. In this chapter, you’ll attempt
    to answer the question using an approach proposed by physicists: you’ll build
    a simple simulated world and then analyze it for clues that might give the simulation
    away. In doing so, you’ll work through this project backward, writing the code
    before coming up with the problem-solving strategy. You’ll find that even the
    simplest model can provide profound insights on the nature of our existence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #16: Life, the Universe, and Yertle’s Pond**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability to simulate reality isn’t just a far-off dream. Physicists have
    used the world’s most powerful supercomputers to accomplish this feat, simulating
    subatomic particle behavior at a scale of a few femtometers (10^(-15) m). Although
    the simulation represents only a tiny piece of the cosmos, it’s indistinguishable
    from what we understand to be reality.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry, you won’t need a supercomputer or a degree in physics to solve
    this problem. All you need is the turtle module, a drawing program designed for
    kids. You used turtle to simulate the Apollo 8 mission in [Chapter 6](ch06.xhtml).
    Here, you’ll use it to understand one of the foundational features of computer
    models. You’ll then apply that knowledge to devise the same basic strategy that
    physicists plan to apply to the simulation hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  prefs: []
  type: TYPE_NORMAL
- en: Identify a feature of a computer simulation that might be detectable by those
    being simulated.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Pond Simulation Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *pond_sim.py* code creates a turtle-based simulation of a pond that includes
    a mud island, a floating log, and a snapping turtle named Yertle. Yertle will
    swim out to the log, swim back, and then swim out again. You can download the
    code from the book’s website at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module ships with Python, so you don’t have to install anything.
    For an overview of the module, see “Using the turtle Module” on [page 127](ch06.xhtml#page_127).
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing turtle, Setting Up the Screen, and Drawing the Island**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 12-1](ch12.xhtml#ch012list1) imports turtle, sets up a screen object
    to use as a pond, and draws a mud island for Yertle to survey his domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Importing the turtle module and drawing a pond and mud island'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the turtle module, assign a screen object to a variable named
    pond. Use the turtle setup() method to set the screen size, in pixels, and then
    color the background light blue. You can find tables of turtle colors and their
    names on multiple sites, such as *[https://trinket.io/docs/colors](https://trinket.io/docs/colors)*.
    Finish the pond by providing a title for the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, make a circular mud island for Yertle to sunbathe on. Use the Turtle()
    class to instantiate a turtle object named mud. Although turtle comes with a method
    for drawing circles, it’s easier here to just pass the constructor the 'circle'
    argument, which produces a circular turtle object. This circle shape is too small
    to make much of an island, however, so use the shapesize() method to stretch it
    out. Finish the island by setting its outline and fill colors to tan.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Log, a Knothole, and Yertle**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 12-2](ch12.xhtml#ch012list2) completes the program by drawing the
    log, complete with knothole and Yertle the turtle. It then moves Yertle so that
    he can leave his island to check out the log.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Drawing a log and a turtle and then moving the turtle around'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll draw a rectangle to represent the log, so start by assigning two constants,
    SIDE and ANGLE. The first represents the length of the log, in pixels; the second
    is the angle, in degrees, by which you’ll turn the turtle at each corner of the
    rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all turtles initially appear at the center of the screen, at coordinates
    (0, 0). Since you’ll place your log off to the side, after you instantiate the
    log object, use the hideturtle() method to make it invisible. This way, you don’t
    have to watch it fly across the screen to get to its final position.
  prefs: []
  type: TYPE_NORMAL
- en: Color the log brown, using peru for the log color. Then set the object’s speed
    to the fastest setting (oddly, 0). This way, you won’t have to watch it slowly
    draw on the screen. And so you don’t see the path it takes from the screen’s center
    to its edge, pick up the drawing pen using the penup() method ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Use the setpos() method—for *set position*—to place the log near the right edge
    of the screen. Then turn the object left by 45 degrees and call the begin_fill()
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You can save a few lines of code by drawing the rectangle using a for loop ➋.
    You’ll loop twice, drawing two sides of the rectangle with each loop. Make the
    log’s width 20 pixels by dividing SIDE by 4. After the loop, call end_fill() to
    color the log brown.
  prefs: []
  type: TYPE_NORMAL
- en: Give the log some character by adding a knothole, represented by a knot turtle.
    To draw the knothole, call the circle() method and pass it 5, for a radius of
    five pixels. Note that you don’t need to specify a fill color as black is the
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, end the program by drawing Yertle, the king of all he surveys. Yertle
    is an old turtle, so set his drawing speed to the slowest setting of 1. Have him
    swim out and inspect the log and then turn around and swim back. Yertle is a touch
    senile, and he forgets what he just did. So, have him swim back out—only this
    time, angle his course so that he’s no longer swimming due east ➌. Run the program,
    and you should get the results shown in [Figure 12-1](ch12.xhtml#ch012fig1).
  prefs: []
  type: TYPE_NORMAL
- en: Look carefully at this figure. Despite the simplicity of the simulation, it
    contains powerful insights into whether we, like Yertle, dwell in a computer simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: Screenshot of completed simulation'
  prefs: []
  type: TYPE_NORMAL
- en: '***Implications of the Pond Simulation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of finite computational resources, all computer simulations require
    a framework of some type on which to “hang” their model of reality. Whether it’s
    called a grid, a lattice, a mesh, a matrix, or whatever, it provides a way to
    both distribute objects in 2D or 3D space and assign them a property, such as
    mass, temperature, color, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module uses the pixels in your monitor as its coordinate system,
    as well as to store properties. The pixel locations define the shapes, such as
    the log’s outline, and the pixel color property helps differentiate one shape
    from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pixels form an *orthogonal* pattern, which means the rows and columns of pixels
    intersect at right angles. Although individual pixels are square and too small
    to easily see, you can use the turtle module’s dot() method to generate a facsimile,
    as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This produces the pattern in [Figure 12-2](ch12.xhtml#ch012fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: Orthogonal grid of black dots representing the centers of square
    pixels'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the turtle world, pixels are true atoms: indivisible. A line can’t be shorter
    than one pixel. Movement can occur only as integers of pixels (though you can
    input float values without raising an error). The smallest object possible is
    one pixel in size.'
  prefs: []
  type: TYPE_NORMAL
- en: An implication of this is that the simulation’s grid determines the smallest
    feature you can observe. Since we can observe incredibly small subatomic particles,
    our grid, assuming we’re a simulation, must be incredibly fine. This leads many
    scientists to seriously doubt the simulation conjecture, since it would require
    a staggering amount of computer memory. Still, who knows what our distant descendants,
    or aliens, are capable of?
  prefs: []
  type: TYPE_NORMAL
- en: Besides setting a limit on the size of objects, a simulation grid might force
    a preferred orientation, or *anisotropy*, on the fabric of the cosmos. Anisotropy
    is the directional dependence of a material, such as the way wood splits more
    easily along its grain rather than across it. If you look closely at Yertle’s
    paths in the turtle simulation ([Figure 12-3](ch12.xhtml#ch012fig3)), you can
    see evidence of anisotropy. His upper, slightly angled path zigzags, while the
    lower, east-west path is perfectly straight.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: The angled versus straight path'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a nonorthogonal line on an orthogonal grid isn’t pretty. But there’s
    more involved than just aesthetics. Moving along the *x* or *y* direction requires
    only integer addition or subtraction ([Figure 12-4](ch12.xhtml#ch012fig4), left).
    Moving at an angle requires trigonometry to calculate the partial movement in
    the *x* and *y* directions ([Figure 12-4](ch12.xhtml#ch012fig4), right).
  prefs: []
  type: TYPE_NORMAL
- en: For a computer, mathematical calculations equal work, so we can surmise that
    moving at an angle takes more energy. By timing the two calculations in [Figure
    12-4](ch12.xhtml#ch012fig4), we can get a relative measure of this difference
    in energy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: Movement along rows or columns (left) requires simpler arithmetic
    than moving across them (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Measuring the Cost of Crossing the Lattice***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To time the difference between drawing a line diagonally across a pixel grid
    and drawing the line along it, you need to draw two lines of equal length. But
    remember, turtle works only with integers. You need to find an angle for which
    all sides of a triangle—the opposite, adjacent, and hypotenuse in [Figure 12-4](ch12.xhtml#ch012fig4)—are
    integers. This way, you’ll know that your angled line is the same length as your
    straight line.
  prefs: []
  type: TYPE_NORMAL
- en: To find these angles, you can use a *Pythagorean triple*, a set of positive
    integers *a*, *b*, and *c* that fit the right triangle rule *a*² + *b*² = *c*².
    The best-known triple is 3-4-5, but you’ll want a longer line, to ensure that
    the runtime of the drawing function isn’t less than the measurement precision
    of your computer’s clock. Fortunately, you can find other, larger triples online.
    The triplet 62-960-962 is a good choice, as it’s long but will still fit in a
    turtle screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Line Comparison Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To compare the cost of drawing a diagonal line to the cost of drawing a straight
    one, [Listing 12-3](ch12.xhtml#ch012list3) uses turtle to draw the two lines.
    The first line is parallel to the *x*-axis (that is, east-west), and the second
    line is at a shallow angle to the *x*-axis. You can figure out the correct degree
    of the angle using trigonometry; in this case, it’s 3.695220532 degrees. The listing
    draws these lines many times using a for loop and records the time it takes to
    draw each one using the built-in time module. The final comparison uses the averages
    of these runs.
  prefs: []
  type: TYPE_NORMAL
- en: You need to use averages because your central processing unit (CPU) is constantly
    running multiple processes. The operating system schedules these processes behind
    the scenes, executing one while delaying another until a resource, such as input/output,
    becomes available. Consequently, it’s difficult to record the *absolute* runtime
    of a given function. Calculating the average time of many runs compensates for
    this.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the code, *line_compare.py*, from the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Drawing a straight line and an angled line and recording the
    runtimes for each'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing perf_counter—short for *performance counter*—from the time
    module. This function returns the float value of time in seconds. It gives you
    a more precise answer than time.clock(), which it replaces as of Python 3.8.
  prefs: []
  type: TYPE_NORMAL
- en: Next, import the statistics module to help you calculate the average of many
    simulation runs. Then import turtle and set up the turtle screen. You can customize
    the screen for your monitor, but remember, you need to be able to see a line 962
    pixels long.
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign some key values for the simulation. Put the angles for a straight
    line and a diagonal line in a tuple named ANGLES and then assign a variable to
    hold the number of times to run the for loop and the speed at which to draw the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Start looping through the angles in the ANGLES tuple. Create an empty list to
    hold the time measurements ➊ before setting up a turtle object, as you’ve done
    before. Rotate the turtle object left by the angle amount and then use setpos()
    to move it to the far-left side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Move the turtle forward by 962 pixels, sandwiching this command between calls
    to perf_counter() to time the movement ➋. Subtract the end time from the start
    time and append the result to the times list.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by using the statistics.mean() function to find the average runtime for
    each line. Print the results to five decimal places. After the program runs, the
    turtle screen should look like [Figure 12-5](ch12.xhtml#ch012fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: Completed turtle screen for line_compare.py'
  prefs: []
  type: TYPE_NORMAL
- en: Because you used a Pythagorean triple, the angled line truly ends on a pixel.
    It doesn’t just snap to the nearest pixel. Consequently, you can be confident
    that the straight and angled lines have the same length and that you’re comparing
    apples to apples when it comes to the timing measurements.
  prefs: []
  type: TYPE_NORMAL
- en: '***Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you draw each line 500 times and then compare the results, you should see
    that it takes roughly 2.4 times as long to draw the angled line as the straight
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your times will likely differ slightly, as they’re affected by other programs
    you may have running concurrently on your computer. As noted previously, CPU scheduling
    will manage all these processes so that your system is fast, efficient, and fair.
  prefs: []
  type: TYPE_NORMAL
- en: If you repeat the exercise for 1,000 runs, you should get similar results. (If
    you decide to do so, you’ll want to get yourself a cup of coffee and some of that
    good pie.) The angled line will take about 2.7 times as long to draw.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ve been running a short function at a high drawing speed. If you’re worried
    that turtle performs optimizations to achieve speed at the expense of accuracy,
    you can slow it down and rerun the program. With the drawing speed set to normal
    (speed = 6), the angled line takes about 2.6 times as long to draw, close to the
    outcome with the fastest speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, moving across the pixel grid requires more work than moving along it.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The goal of this project was to identify a way for simulated beings, perhaps
    us, to find evidence of the simulation. At this point, we know at least two things.
    First, if we’re living in a simulation, the grid is extremely small, as we can
    observe subatomic particles. Second, if these small particles cross the simulation’s
    grid at an angle, we should expect to find computational resistance that translates
    into something measurable. This resistance might look like a loss of energy, a
    scattering of particles, a reduction in velocity, or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, physicists Silas R. Beane, from the University of Bonn, and Zohreh
    Davoudi and Martin J. Savage, from the University of Washington, published a paper
    arguing exactly this point. According to the authors, if the laws of physics,
    which appear continuous, are superimposed on a discrete grid, the grid spacing
    might impose a limitation on physical processes.
  prefs: []
  type: TYPE_NORMAL
- en: They proposed investigating this by observing *ultra-high energy cosmic rays
    (UHECRs)*. UHECRs are the fastest particles in the universe, and they are affected
    by increasingly smaller features as they get more energetic. But there’s a limit
    to how much energy these particles can have. Known as the GZK cutoff and confirmed
    by experiments in 2007, this limit is consistent with the kind of boundary a simulation
    grid might cause. Such a boundary should also cause UHECRs to travel preferentially
    along the grid’s axes and scatter particles that try to cross it.
  prefs: []
  type: TYPE_NORMAL
- en: Not surprisingly, there are many potential obstacles to this approach. UHECRs
    are rare, and anomalous behavior might not be obvious. If the spacing of the grid
    is significantly smaller than 10^(-12) femtometers, we probably can’t detect it.
    There may not even *be* a grid, at least as we understand it, as the technology
    in use may far exceed our own. And, as the philosopher Preston Greene pointed
    out in 2019, there may be a moral obstacle to the entire project. If we live in
    a simulation, our discovery of it may trigger its end!
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a coding standpoint, building Yertle’s simulated world was simple. But
    a big part of coding is solving problems, and the small amount of work you did
    had major implications. No, we didn’t make the leap to cosmic rays, but we started
    the right conversation. The basic premise that a computer simulation requires
    a grid that could imprint observable signatures on the universe is an idea that
    transcends nitty-gritty details.
  prefs: []
  type: TYPE_NORMAL
- en: In the book *Harry Potter and the Deathly Hallows*, Harry asks the wizard Dumbledore,
    “Tell me one last thing. Is this real? Or has this been happening inside my head?”
    Dumbledore replies, “Of course it is happening inside your head, Harry, but why
    on Earth should that mean that it is not real?”
  prefs: []
  type: TYPE_NORMAL
- en: Even if our world isn’t located at the “fundamental level of reality,” as Nick
    Bostrom postulates, you can still take pleasure in your ability to solve problems
    such as this. As Descartes might’ve said, had he lived today, “I code, therefore
    I am.” Onward!
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “Are We Living in a Simulated Universe? Here’s What Scientists Say” (NBC News,
    2019), by Dan Falk, provides an overview of the simulation hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: “Neil deGrasse Tyson Says ‘It’s Very Likely’ the Universe Is a Simulation” (ExtremeTech,
    2016), by Graham Templeton, is an article with an embedded video of the Isaac
    Asimov Memorial Debate, hosted by astrophysicist Neil deGrasse Tyson, that addresses
    the possibility that we’re living in a simulation.
  prefs: []
  type: TYPE_NORMAL
- en: “Are We Living in a Computer Simulation? Let’s Not Find Out” (*New York Times*,
    2019), by Preston Greene, presents a philosophical argument against investigating
    the simulation hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: “We Are Not Living in a Simulation. Probably.” (Fast Company, 2018), by Glenn
    McDonald, argues that the universe is too big and too detailed to be simulated
    computationally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moving On**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s never enough time in life to do all the things we want, and that goes
    double for writing a book. The challenge projects that follow represent the ghosts
    of chapters not yet written. There was no time to finish these (or in some cases,
    even start them), but you might have better luck. As always, the book provides
    no solutions for challenge projects—not that you’ll need them.
  prefs: []
  type: TYPE_NORMAL
- en: This is the real world, baby, and you’re ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Finding a Safe Space**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The award-winning 1970 novel *Ringworld* introduced the world to the Pierson’s
    puppeteer, a sentient and highly advanced alien herbivore. Being herd animals,
    puppeteers were extremely cowardly and cautious. When they realized that the core
    of the Milky Way had exploded and the radiation would reach them in 20,000 years,
    they started fleeing the galaxy immediately!
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’re part of a 29th-century diplomatic team assigned to the
    puppeteer ambassador. Your job is to select a state, within the conterminous United
    States, that they’ll find suitably safe for the puppeteer embassy. You’ll need
    to screen each state for natural hazards, such as earthquakes, volcanoes, tornadoes,
    and hurricanes, and present the ambassador with a map summarizing the results.
    Don’t worry that the data you’ll use is hundreds of years out-of-date; just pretend
    it’s current to the year 2850 CE.
  prefs: []
  type: TYPE_NORMAL
- en: You can find earthquake data at *[https://earthquake.usgs.gov/earthquakes/feed/v1.0/csv.php/](https://earthquake.usgs.gov/earthquakes/feed/v1.0/csv.php/)*.
    Use dots to plot the epicenters of those quakes that are 6.0 or greater in magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: You can post the tornado data as the average number per year per state (see
    *[https://www.ncdc.noaa.gov/climate-information/extreme-events/us-tornado-climatology](https://www.ncdc.noaa.gov/climate-information/extreme-events/us-tornado-climatology)*).
    Use a choropleth format like you did in [Chapter 11](ch11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: You can find a listing of dangerous volcanoes in Table 2 of the 2018 Update
    to the U.S. Geological Survey National Volcanic Threat Assessment (*[https://pubs.usgs.gov/sir/2018/5140/sir20185140.pdf](https://pubs.usgs.gov/sir/2018/5140/sir20185140.pdf)*).
    Represent these as dots on the map, but assign them a different color or shape
    than the earthquake data. Also, ignore the ashfall from Yellowstone. Assume the
    experts monitoring this supervolcano can predict an eruption soon enough for the
    ambassador to safely flee the planet.
  prefs: []
  type: TYPE_NORMAL
- en: To find hurricane tracks, visit the National Oceanic and Atmospheric Administration
    site (*[https://coast.noaa.gov/digitalcoast/data/](https://coast.noaa.gov/digitalcoast/data/)*)
    and search for “Historical Hurricane Tracks.” Download and post the Category 4
    and higher storm segments on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Try to think like a puppeteer and use the final composite map to choose a candidate
    state for the embassy. You might have to ignore a tornado or two. America is a
    dangerous place!
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Here Comes the Sun**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2018, 13-year-old Georgia Hutchinson from Woodside, California, won $25,000
    at the Broadcom Masters nationwide science, technology, engineering, and mathematics
    (STEM) competition for middle-school students. Her entry, “Designing a Data-Driven
    Dual-Axis Solar Tracker,” will make solar panels cheaper and more efficient by
    eliminating the need for costly light sensors.
  prefs: []
  type: TYPE_NORMAL
- en: This new sun tracker is based on the premise that we already know the location
    of the sun at any moment from any given point on Earth. It uses public data from
    the National Oceanic and Atmospheric Administration to continuously determine
    the sun’s position and tilt the solar panels for maximum power production.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that calculates the sun’s position based on a location
    of your choosing. To get started, check out the Wikipedia page “Position of the
    Sun” (*[https://en.wikipedia.org/wiki/Position_of_the_Sun](https://en.wikipedia.org/wiki/Position_of_the_Sun)*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Seeing Through a Dog’s Eyes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use your knowledge of computer vision to write a Python program that takes an
    image and simulates what a dog would see. To get started, check out *[https://www.akc.org/expert-advice/health/are-dogs-color-blind/](https://www.akc.org/expert-advice/health/are-dogs-color-blind/)*
    and *[https://dog-vision.andraspeter.com/](https://dog-vision.andraspeter.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Customized Word Search**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boy, does your Granny love doing word searches! For her birthday, use Python
    to design and print her customized word searches using family names, vintage TV
    shows like *Matlock* and *Columbo*, or the common names of her prescription drugs.
    Allow the words to print horizontally, vertically, and diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Simplifying a Celebration Slideshow**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your spouse, sibling, parent, best friend, or whoever is having a celebration
    dinner, and you’re in charge of the slideshow. You have tons of pictures in the
    cloud, many featuring the honoree, but the filenames just list the date and time
    at which they were taken, providing no clue as to the contents. It looks like
    you’ll spend your Saturday sifting through them all.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, didn’t you learn about face recognition in that book *Real-WorldPython*?
    All you really need to do is find a few training images and do a bit of coding.
  prefs: []
  type: TYPE_NORMAL
- en: First, pick someone in your personal digital photo collection to represent the
    guest of honor. Next, write a Python program that searches through your folders,
    finds photos containing this person, and copies the photos into a special folder
    for your review. When training, be sure to include face profiles as well as frontal
    views, and include a profile Haar cascade when detecting faces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: What a Tangled Web We Weave**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use Python and the turtle module to simulate a spider building a web. For some
    guidance on web construction, see *[https://www.brisbaneinsects.com/brisbane_weavers/index.htm](https://www.brisbaneinsects.com/brisbane_weavers/index.htm)*
    and *[http://recursiveprocess.com/mathprojects/index.php/2015/06/09/spider-webs-creepy-or-cool/](http://recursiveprocess.com/mathprojects/index.php/2015/06/09/spider-webs-creepy-or-cool/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Go Tell It on the Mountain**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “What’s the closest mountain to Houston, Texas?” This seemingly straightforward
    question, asked on Quora, isn’t easy to answer. For one thing, you need to consider
    mountains in Mexico, as well as those in the United States. For another, there’s
    no universally accepted definition of a mountain.
  prefs: []
  type: TYPE_NORMAL
- en: To make this somewhat easier, use one of the UN Environmental Program’s definitions
    of *mountainous terrain*. Find prominences with an elevation of at least 2,500
    m (8,200 feet) and consider them mountains. Calculate their distance from the
    center of Houston to find the closest.
  prefs: []
  type: TYPE_NORMAL
