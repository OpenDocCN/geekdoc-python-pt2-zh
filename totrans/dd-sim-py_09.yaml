- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Objects and Classes
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和类
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Objects are the bread and butter of many a programmer. Python makes full use
    of objects, even to the point of inspiring the mantra, “Everything is an object.”
    However, if you’ve worked with classes and objects in any other language, Python’s
    take may surprise you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是许多程序员的基本工具。Python充分利用了对象，甚至激发了“所有事物都是对象”的口号。然而，如果你曾在其他语言中使用过类和对象，Python 的实现可能会让你感到惊讶。
- en: '*Object-oriented programming* (or *OOP*) is a paradigm in which data and its
    corresponding logic is organized into objects. If you’re familiar with such languages
    as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程*（或 *OOP*）是一种将数据及其相应逻辑组织为对象的范式。如果你熟悉 Java、C++、Ruby 和 C# 等语言，那么你一定对这些概念非常熟悉。'
- en: Yet, object-oriented programming in Python is not mutually exclusive with functional
    programming; in fact, the two paradigms work very well together.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 中的面向对象编程与函数式编程并不是互相排斥的；事实上，这两种范式可以很好地结合在一起。
- en: 'In this chapter, I’ll cover the essentials of object-oriented programming in
    Python: creating classes with attributes, modules, and properties. I’ll demonstrate
    adding various behaviors via special methods, and I’ll wrap up with a summary
    of the situations in which classes are the most useful.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍 Python 中面向对象编程的基本要素：创建带有属性、模块和属性的类。我将展示如何通过特殊方法添加各种行为，最后总结类最有用的应用场景。
- en: Declaring a Class
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个类
- en: 'Creating a new class is simple. I’ll create a class named `SecretAgent`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类很简单。我将创建一个名为 `SecretAgent` 的类：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Initializing a class'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：初始化一个类
- en: Below this, in the accompanying suite of the class declaration, I’d add any
    methods I want to include in the object. An object is known as an *instance* of
    a class in Python. I’ll cover this in detail shortly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此下方，在类声明的附带部分中，我会添加任何我想在对象中包含的方法。在 Python 中，对象被称为类的*实例*。稍后我会详细讲解这一点。
- en: In Python, everything is an object, in that everything inherits from the `object`
    class. In Python 3, this inheritance from `object` is implicit, as seen in [Listing
    7-1](#listing7-1). In Python 2, you had to explicitly inherit from `object`, or
    from another class that inherits from `object`. (I cover inheritance in Chapter
    13. You can take it for granted here.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，所有事物都是对象，因为所有事物都继承自`object`类。在 Python 3 中，这种继承是隐式的，如在[列表 7-1](#listing7-1)中所示。在
    Python 2 中，你必须显式地继承自`object`，或继承自其他从`object`继承的类。（继承的内容在第13章中讲解，这里可以忽略不计。）
- en: 'Here’s the `SecretAgent` class declaration again, this time explicitly inheriting
    from `object`, as Python 2 would have required:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `SecretAgent` 类的声明，这次显式地继承自 `object`，如同 Python 2 所要求的那样：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Initializing a class with explicit inheritance'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：显式继承初始化类
- en: Listings 7-1 and 7-2 are functionally identical. Python developers really hate
    *boilerplate code*, which is code that is widely reused, with little or no modification.
    That is why Python 3 added the shorter technique seen in [Listing 7-1](#listing7-1).
    Unless you need to support Python 2, the shorter technique is preferred. You’ll
    encounter both ways often enough, so it’s important to know that they do the exact
    same thing in Python 3.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1 和 7-2 在功能上是完全相同的。Python 开发者非常讨厌*模板代码*，即那些被广泛重复使用、几乎没有修改的代码。这就是为什么 Python
    3 引入了[列表 7-1](#listing7-1)中看到的简短技巧。除非你需要支持 Python 2，否则推荐使用这种简短技巧。你会经常遇到这两种方法，所以了解它们在
    Python 3 中执行的是完全相同的操作非常重要。
- en: The Initializer
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化器
- en: A class often has an *initializer* method for defining the initial values of
    *instance attributes*, which are the member variables that exist in each instance.
    If your instance will have no instance attributes, you don’t need to define `__init__()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常有一个*初始化器*方法，用于定义*实例属性*的初始值，实例属性是每个实例中存在的成员变量。如果你的实例没有实例属性，则不需要定义`__init__()`方法。
- en: 'I want each instance of `SecretAgent` to have a code name and a list of secrets.
    Here’s the initializer for my `SecretAgent` class, which has two instance attributes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望每个 `SecretAgent` 的实例都有一个代号和一个秘密列表。这里是我的 `SecretAgent` 类的初始化器，它有两个实例属性：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: *secret_agent.py:1a*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：*secret_agent.py:1a*
- en: The initializer must have the name `__init__` to be recognized as an initializer,
    and it must accept at least one argument, conventionally called `self`. This `self`
    argument references the instance the method is acting on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化函数必须命名为 `__init__`，以便被识别为初始化函数，并且必须接受至少一个参数，通常称为 `self`。这个 `self` 参数引用了方法所作用的实例。
- en: In this case, I also accept a second argument, `codename`, which I use as the
    initial value of one of my instance attributes. This `self.codename` attribute
    will be the code name of the secret agent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我还接受了第二个参数 `codename`，并将其用作我其中一个实例属性的初始值。这个 `self.codename` 属性将会是特工的代号。
- en: Instance attributes are part of the class instance itself, so I must access
    them through the dot (`.`) operator on `self`. All instance attributes should
    be declared in the initializer method, rather than on the fly in other instance
    methods. Therefore, I’m also defining `self._secrets` as an empty list. This will
    be a list of secrets the particular secret agent (instance) is keeping.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性是类实例的一部分，因此我必须通过 `self` 上的点（`.`）运算符来访问它们。所有实例属性应该在初始化函数中声明，而不是在其他实例方法中临时创建。因此，我还定义了
    `self._secrets` 作为一个空列表。这个列表将保存特定特工（实例）所保留的秘密。
- en: Lastly, an initializer must never return a value via the `return` keyword; if
    it does, calling the initializer will raise a `TypeError`. However, you may use
    `return` by itself to explicitly exit the method, if you ever need to.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，初始化函数绝不能通过 `return` 关键字返回任何值；如果它这样做，调用初始化函数会引发 `TypeError` 错误。不过，如果你需要的话，你可以单独使用
    `return` 来明确退出方法。
- en: 'Whenever I create a new class instance, the initializer is automatically called.
    Here, I create three `SecretAgent` instances and provide arguments for the `codename`
    parameter of the initializer:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我创建一个新的类实例时，初始化函数会自动被调用。在这里，我创建了三个 `SecretAgent` 实例，并为初始化函数的 `codename` 参数提供了参数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: *secret_agent_usage.py:1*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-4: *secret_agent_usage.py:1*'
- en: In this module, I import my `SecretAgent` class and create three new instances.
    You’ll notice that I didn’t need to pass anything to the first parameter, `self`.
    That’s taken care of behind the scenes. Instead, my first argument, `"Mouse"`,
    is passed to the second parameter of the initializer, `codename`. Each instance
    also has its own empty `_secrets` list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我导入了 `SecretAgent` 类并创建了三个新实例。你会注意到，我不需要向第一个参数 `self` 传递任何东西。这部分是在幕后处理的。相反，我的第一个参数
    `"Mouse"` 被传递给初始化函数的第二个参数 `codename`。每个实例也有自己的空 `_secrets` 列表。
- en: The Constructor
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: If you’re coming from C++, Java, or some similar language, you may expect to
    write a *constructor*—a function that constructs an instance of a class—or you
    may think that the initializer does the same thing as a constructor. In fact,
    Python 3 splits the duties of a typical constructor between the initializer `__init__()`
    and the constructor `__new__()`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从 C++、Java 或类似语言过来的，你可能会期待写一个 *构造函数* —— 一个构造类实例的函数 —— 或者你可能认为初始化函数和构造函数做的是同样的事情。事实上，Python
    3 将典型构造函数的职责分配给了初始化函数 `__init__()` 和构造函数 `__new__()`。
- en: In Python, the constructor `__new__()` takes care of actually creating the instance
    in memory. When you create a new instance, the constructor is automatically called
    first, followed by a call to the initializer. The constructor is the only method
    in the class to be called automatically before the object is created!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，构造函数 `__new__()` 负责在内存中实际创建实例。当你创建一个新实例时，构造函数会自动首先被调用，然后才是初始化函数。构造函数是类中唯一在对象创建之前会自动调用的方法！
- en: 'You don’t normally need to define a constructor; one is provided automatically.
    The only time you would create a constructor would be if you needed additional
    control over the process. However, to familiarize you with the syntax, I’ll write
    a very basic (and effectively pointless) constructor, which could go in a class
    definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要定义一个构造函数；一个默认的构造函数会自动提供。只有当你需要额外控制这个过程时，你才会创建构造函数。然而，为了让你熟悉语法，我会写一个非常基础（实际上没有太大意义）的构造函数，它可以放在类定义中：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The constructor always has the name `__new__`, and it implicitly accepts a class
    as its first parameter, `cls` (in contrast to the initializer, which accepts a
    class instance on `self`). Since the initializer accepts parameters, I also need
    to prepare the constructor to accept these on the constructor, so I use variadic
    arguments to capture these arguments and pass them on to the initializer parameters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数始终具有名称`__new__`，并隐式接受类作为其第一个参数`cls`（与初始化器接受类实例`self`不同）。由于初始化器接受参数，我还需要准备构造函数来接受这些参数，所以我使用可变参数来捕获这些参数并将它们传递给初始化器参数。
- en: The constructor must return the class instance that gets created. Technically,
    I could return whatever I wanted here, but the expected behavior would almost
    certainly be to return an instance that has been instantiated from the `SecretAgent`
    class. To do that, I call the `__new__` function on the parent class, which you
    may recall (from [Listing 7-2](#listing7-2)) is `object`. (I’ll return to `super()`
    in Chapter 13. Don’t worry about understanding it now.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数必须返回创建的类实例。从技术上讲，我可以在这里返回任何我想要的东西，但预期的行为几乎可以肯定是返回一个已从`SecretAgent`类实例化的实例。为此，我调用父类的`__new__`函数，正如你从[列表
    7-2](#listing7-2)中回忆的那样，它是`object`。（我将在第13章中回到`super()`。现在不需要担心理解它。）
- en: In practice, if this is all your constructor needs to do, just omit it! Python
    automatically handles the constructor behavior if you don’t write any code for
    it. Only write a constructor when you need to control the behavior around instantiating
    the class instance itself. In any event, that scenario is rare; it is perfectly
    plausible that you will never write a constructor in your entire Python programming
    career.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果这就是你的构造函数所需要做的所有工作，那就直接省略它吧！如果你不为其编写任何代码，Python 会自动处理构造函数行为。只有在你需要控制类实例化本身的行为时，才编写构造函数。无论如何，这种情况很少见；完全可能你一生中的
    Python 编程生涯都不会编写构造函数。
- en: The Finalizer
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终结器
- en: 'The *finalizer* is called when a class instance finally reaches the end of
    its lifespan and is cleaned up by the garbage collector. It exists solely to handle
    any technically complex cleanup that your particular class may require. As with
    the constructor, you will seldom, if ever, need to write this function yourself.
    If you do, it’s important to understand: the finalizer is only called if the class
    instance (value) itself is cleaned up by the garbage collector!'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*终结器*在一个类实例的生命周期最终结束并被垃圾回收器清理时被调用。它仅用于处理你特定类可能需要的任何技术复杂的清理工作。与构造函数一样，你很少（如果有的话）需要自己编写这个函数。如果你确实编写了它，理解这一点很重要：只有当类实例（值）本身被垃圾回收器清理时，终结器才会被调用！'
- en: If any references to the class instance still exist, the finalizer won’t be
    called; furthermore, depending on the implementation of Python you’re using, the
    garbage collector might not always clean up the class instance when you’d expect,
    if at all.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类实例的任何引用仍然存在，终结器将不会被调用；此外，根据你使用的 Python 实现，垃圾回收器可能并不会总是按照预期清理类实例，甚至可能根本不清理。
- en: Therefore, only use the finalizer for code directly relating to garbage-collecting
    the class instance. It should never contain code that needs to be run as part
    of any other circumstance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，终结器只应用于与垃圾回收类实例直接相关的代码。它不应包含任何需要在其他任何情况下运行的代码。
- en: 'Here’s a rather useless finalizer that prints a message when the garbage collector
    cleans up a `SecretAgent` class instance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当无用的终结器，当垃圾回收器清理一个`SecretAgent`类实例时，它会打印一条消息：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-5: *secret_agent.py:2*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-5: *secret_agent.py:2*'
- en: A finalizer always has the name `__del__` and accepts a single parameter, `self`.
    It must not return anything.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器始终具有名称`__del__`并接受一个参数`self`。它不应该返回任何东西。
- en: 'To demonstrate this finalizer, I’ll create and manually delete an instance.
    It is possible to delete a name, thereby unbinding it from its value, by using
    the `del` keyword. Given the `SecretAgent` class with that finalizer method, I
    can create and then delete a name referring to a class instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个终结器，我将创建并手动删除一个实例。可以使用`del`关键字删除一个名称，从而将其与值解绑。给定具有该终结器方法的`SecretAgent`类，我可以创建并删除一个引用类实例的名称：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-6: *secret_agent_disavow.py*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-6: *secret_agent_disavow.py*'
- en: I create a new instance from the `SecretAgent` class and bind it to the name
    `weasel`. Then, I immediately delete the name by using the `del` operator. The
    name `weasel` is now undefined again. Coincidentally, because no references remain
    to the `SecretAgent` instance the name was bound to, that instance is cleaned
    up by the garbage collector, which first calls the finalizer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我从`SecretAgent`类创建了一个新实例，并将其绑定到名称`weasel`。然后，我立即使用`del`操作符删除该名称。现在，名称`weasel`又变成了未定义的。巧合的是，由于不再有对绑定到该名称的`SecretAgent`实例的引用，该实例被垃圾回收器清理，而垃圾回收器首先调用终结器。
- en: 'Thus, running that code displays this output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行这段代码会显示以下输出：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that `del` only deletes the name, not the value! If you have multiple names
    bound to the same value, and if you `del` one of those names, then the other names
    and their values will be unaffected. In other words, `del` will not force the
    garbage collector to delete the objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`del`只会删除名称，而不会删除值！如果有多个名称绑定到相同的值，而你使用`del`删除其中一个名称，那么其他名称及其值将不会受到影响。换句话说，`del`不会强制垃圾回收器删除对象。
- en: Attributes
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: All variables belonging to a class or instance are called *attributes*. Attributes
    belonging to the instance itself are called *instance attributes*, which are also
    sometimes referred to as *member variables*. Attributes belonging to the class
    itself are *class attributes*, which are also sometimes called *class variables*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于类或实例的变量都称为*属性*。属于实例本身的属性称为*实例属性*，有时也被称为*成员变量*。属于类本身的属性称为*类属性*，也有时被称为*类变量*。
- en: Many intermediate-level Python programmers don’t realize there is a significant
    difference between the two. I must admit, I spent the first few years of my Python
    development career using them utterly incorrectly!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多中级 Python 程序员并没有意识到两者之间有显著的区别。我必须承认，我在 Python 开发生涯的最初几年完全错误地使用了它们！
- en: Instance Attributes
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例属性
- en: An *instance attribute* exists on the instance itself; its value is unique to
    the instance and is not available to other instances. All instance attributes
    should be declared in the class’s initializer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例属性*存在于实例本身上；它的值是该实例独有的，其他实例无法访问。所有实例属性应在类的初始化器中声明。'
- en: 'Revisiting the `__init__()` method from [Listing 7-3](#listing7-3), you’ll
    see I have two instance attributes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看[列表 7-3](#listing7-3)中的`__init__()`方法，你会看到我有两个实例属性：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Class Attributes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类属性
- en: A *class attribute* exists on the class, instead of on an individual instance.
    In practice, this means that all related class instances effectively “share” a
    class attribute, although it would exist even without any instances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*类属性*存在于类上，而不是单个实例上。实际上，这意味着所有相关的类实例实际上“共享”一个类属性，尽管即使没有任何实例，它也会存在。'
- en: 'Class attributes are declared at the top of the class, outside of any methods.
    Here, I add one class attribute directly into the suite of the class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性声明在类的顶部，任何方法外面。在这里，我直接将一个类属性添加到类的代码块中：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-7: *secret_agent.py:1b*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-7: *secret_agent.py:1b*'
- en: The attribute `_codeword` belongs to the `SecretAgent` class. Typically, all
    class attributes are declared before any methods to make them easier to find,
    although this is just convention. The important part is that they are defined
    outside of any methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`_codeword`属于`SecretAgent`类。通常，所有类属性都会在任何方法之前声明，以便更容易查找，尽管这只是一个约定。重要的部分是，它们是在任何方法外定义的。
- en: 'The class attribute can be accessed like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性可以通过以下方式访问：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-8: *secret_agent_usage.py:2a*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-8: *secret_agent_usage.py:2a*'
- en: I can access the class attribute `_codeword` directly through the class, or
    through any instances instantiated from the class. If the class attribute is rebound
    or mutated on the class itself ❶, the changes will appear in all cases. However,
    if a value is assigned to the name on an instance, it will create an instance
    attribute with the same name ❷, which shadows the class attribute on that instance,
    without affecting other instances.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以直接通过类访问类属性`_codeword`，或者通过任何从该类实例化的实例访问。如果类属性在类本身上被重新绑定或变更 ❶，这些变化会在所有实例中显示出来。然而，如果在某个实例上为该名称赋值，它会在该实例上创建一个同名的实例属性
    ❷，从而遮蔽该实例的类属性，而不影响其他实例。
- en: Class attributes are particularly useful for constant values that the class’s
    methods use. I also find them more practical and maintainable than global variables
    in many cases, especially in GUI programming. For example, I often employ class
    attributes when I need to maintain a shared instance of a widget, like a window.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性特别适用于类的方法使用的常量值。我还发现它们比在许多情况下使用全局变量更实用和可维护，特别是在 GUI 编程中。例如，当我需要维护一个共享的小部件实例（比如窗口）时，我常常使用类属性。
- en: Scope-Naming Conventions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围命名约定
- en: If you’re coming from a language that has class scope, you may wonder why I
    haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation?
    In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines
    a naming convention that indicates whether an attribute is safe to modify externally
    (public) or not (nonpublic).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自于具有类作用域的语言，你可能会想知道为什么我到现在还没有提到它。数据隐藏不应该是封装的重要部分吗？事实上，Python 没有正式的数据隐藏概念。相反，PEP
    8 概述了一种命名约定，表明一个属性是否可以从外部修改（公共）或不可以（非公共）。
- en: While I talk a lot about attributes in this section, these naming conventions
    apply to methods as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这一节中我讨论了很多关于属性的内容，但这些命名约定同样适用于方法。
- en: Nonpublic
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共
- en: By preceding a name with an underscore, I declare that the attribute `_secrets`
    is intended to be *nonpublic*, meaning it shouldn’t be modified (or, ideally,
    accessed) outside of the class. This is more of a social contract via style convention;
    I’m not actually hiding anything.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在名称前加下划线，我声明属性 `_secrets` 是*非公共*的，这意味着它不应在类外部修改（或理想情况下，访问）。这更多的是通过风格约定的一种社会契约；我并没有真正隐藏任何东西。
- en: This may seem dangerous to many developers coming from languages with explicit
    scope, like Java, but it works out pretty well. As my pal “grym” likes to put
    it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore
    qualified to stick a fork in a toaster.” In other words, if the client is going
    to disregard the underscore warning label, they probably know what they’re doing.
    (On the off-chance they don’t, they’re fully responsible for the consequences.)
    That little underscore hanging out after the dot operator is advertising “You
    really shouldn’t mess with me!”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于许多来自具有显式作用域语言（如 Java）的开发者来说，可能看起来有些危险，但实际上效果不错。正如我的朋友“grym”喜欢说的，“如果你知道为什么不应该把叉子插进烤面包机，那么你就有资格把叉子插进烤面包机。”换句话说，如果客户端决定忽视下划线警告标签，他们大概知道自己在做什么。（如果万一他们不知道，他们需要对后果负责。）那个悬挂在点操作符后面的下划线是在提醒：“你真的不应该弄乱我！”
- en: Public
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共
- en: The attribute `codename`, which does not start with an underscore, is intended
    to be *public*. It is okay for this attribute to be accessed or modified externally,
    as it won’t really affect the behavior of the class. Public attributes are preferable
    to writing a plain getter/setter pair of methods; the behavior is the same, but
    the result is cleaner, with less boilerplate.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `codename` 没有以下划线开头，意味着它是*公共*的。可以从外部访问或修改此属性，因为它不会真正影响类的行为。公共属性比编写简单的 getter/setter
    方法对更优；行为是一样的，但结果更简洁，减少了样板代码。
- en: If an attribute needs a custom getter or setter, one approach is to define the
    attribute as nonpublic and create a public *property*, which I’ll come back to
    shortly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个属性需要自定义的 getter 或 setter，一种方法是将该属性定义为非公共的，并创建一个公共的*属性*，稍后我会回来详细讲解。
- en: Name Mangling
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称修改
- en: 'Python does offer *name mangling*, which rewrites an attribute or method name
    to prevent it from being shadowed by derived (inheriting) classes. This provides
    a sort of weak form of data hiding. It can also be useful for an added level of
    forewarning: “No, *really*, if you mess with this attribute, terrible things will
    happen!”'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python 确实提供了*名称修改*，它会重写属性或方法的名称，以防止它被派生（继承）类覆盖。这提供了一种弱形式的数据隐藏。它也可以作为一种额外的警告：“不，*真的*，如果你弄乱了这个属性，会发生可怕的事情！”
- en: 'To mark an attribute (or method) for name mangling, precede the name with two
    underscores (`__`), like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要标记一个属性（或方法）进行名称修改，请在名称前加两个下划线（`__`），如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-9: *message.py:1*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-9: *message.py:1*'
- en: 'The `__format` attribute will be name mangled, so accessing it externally in
    the ordinary manner will not work:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format` 属性将被名称修改，因此以普通方式从外部访问它将不起作用：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-10: *message.py:2*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-10: *message.py:2*'
- en: 'This will raise an `AttributeError` because the `msg` instance does not have
    an attribute named `__format`; the name of that attribute was mangled. Be aware
    that name mangling is *not* a true form of data hiding! It is still perfectly
    possible to access a name-mangled attribute:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发一个`AttributeError`，因为`msg`实例没有名为`__format`的属性；该属性的名称被更改了。要注意，名称更改*并不是*一种真正的数据隐藏方式！仍然可以访问名称更改后的属性：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-11: *message.py:3*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-11: *message.py:3*'
- en: 'The name-mangling pattern is predictable: an underscore, the name of the class,
    and then the name of the attribute, with its two leading underscores.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 名称更改的模式是可预测的：一个下划线，类名，然后是属性的名称，前面加上两个下划线。
- en: Public, Nonpublic, or Name Mangled?
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共、非公共，还是名称改动？
- en: 'When deciding whether to make an attribute public or nonpublic, I ask myself
    one question: could changing this attribute externally cause unexpected or negative
    behavior in the class? If the answer is yes, I make the attribute nonpublic by
    preceding it with an underscore. If the answer is no, I leave the attribute public.
    It is up to the coder using the class to respect the rules or suffer the consequences.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否将一个属性设置为公共还是非公共时，我会问自己一个问题：改变这个属性是否会在外部导致类出现意外或负面的行为？如果答案是“是”，我会通过在属性名前加下划线将其设置为非公共。如果答案是否定的，我会保持属性为公共。是否遵循这些规则由使用类的程序员决定，若不遵守，则自负后果。
- en: As to name mangling, in practice, I very rarely employ this pattern. I reserve
    it only for those cases where (a) I need to avoid a naming conflict in the context
    of inheritance or (b) external access of the attribute will have exceptionally
    horrific effects on the behavior of the class, and thus, an extra degree of warning
    is justified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 至于名称更改，实际上，我很少使用这种模式。我仅在以下情况下使用它：(a) 当我需要避免继承上下文中的命名冲突，或者(b) 外部访问该属性会对类的行为产生异常严重的影响，因此，需要额外的警告。
- en: Always remember that Python does not have private class scope. Truly secret
    data should be properly encrypted, not just concealed from your API. There are
    also no optimization benefits to private class scope, unlike in languages like
    Java, since all attribute lookups occur at runtime.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住，Python没有私有类作用域。真正的机密数据应该进行适当加密，而不仅仅是从API中隐藏。与Java等语言不同，Python中没有私有类作用域的优化好处，因为所有属性查找都会在运行时发生。
- en: Methods
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'A class is nothing without its methods, which make encapsulation possible.
    There are three distinct types of methods: instance methods, class methods, and
    static methods.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类如果没有方法，就什么都不是，正是方法使得封装成为可能。方法有三种不同的类型：实例方法、类方法和静态方法。
- en: Instance Methods
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例方法
- en: '*Instance methods* are your run-of-the-mill methods, which exist on the instance
    itself. The first parameter, conventionally named `self`, provides access to the
    instance attributes of the instance.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例方法*是普通的、常见的方法，它们存在于实例本身上。第一个参数，通常命名为`self`，提供对实例属性的访问。'
- en: 'Here, I add an instance method to my `SecretAgent` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我向`SecretAgent`类添加了一个实例方法：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-12: *secret_agent.py:3*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-12: *secret_agent.py:3*'
- en: Besides the required first parameter, the instance method accepts a second parameter,
    `secret`, which is appended to the list bound to the instance attribute `_secrets`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必需的第一个参数外，实例方法还接受第二个参数`secret`，它会被追加到绑定到实例属性`_secrets`的列表中。
- en: 'I call this method on the instance, using the dot operator:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我在实例上调用这个方法，使用点操作符：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-13: *secret_agent_usage.py:2b*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-13: *secret_agent_usage.py:2b*'
- en: The dot operator implicitly passes `mouse` to the `self` parameter, so my first
    argument, the tuple of coordinates (notice the extra set of parentheses), is passed
    to the second parameter, `secret`, on the `remember()` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点操作符隐式地将`mouse`传递给`self`参数，因此我的第一个参数，即坐标元组（注意额外的括号），会被传递给`remember()`方法中的第二个参数`secret`。
- en: Class Methods
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: Like class attributes, *class methods* belong to the class, instead of to the
    instances instantiated from the class. These are useful for working with class
    attributes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 像类属性一样，*类方法*属于类，而不是属于从类实例化的实例。这些方法对处理类属性很有用。
- en: 'Back in [Listing 7-7](#listing7-7), I defined `_codeword` as a class attribute
    so all `SecretAgent` instances would be aware of the code word; it’s something
    all agents should have in common. I need a way to inform all the agents at once
    of the new code word, so I’ll add a class method, `inform()`, which will modify
    the `_codeword` class attribute:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[示例 7-7](#listing7-7)，我将`_codeword`定义为类属性，这样所有`SecretAgent`实例都能知道这个代码词；这是所有特工应该共有的内容。我需要一种方式一次性通知所有特工新的代码词，因此我将添加一个类方法`inform()`，它将修改`_codeword`类属性：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7-14: *secret_agent.py:4*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-14: *secret_agent.py:4*'
- en: I precede a class method with the built-in `@classmethod` decorator. A class
    method receives the class as its first argument, so the first parameter is named
    `cls`. Class attributes like `_codeword` are accessed on the class passed to `cls`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我在类方法前加上了内置的`@classmethod`装饰器。类方法接收类作为第一个参数，因此第一个参数命名为`cls`。像`_codeword`这样的类属性可以通过传递给`cls`的类来访问。
- en: One of the benefits of this approach is that I don’t have to worry about whether
    I’m calling `inform()` on the class or on an instance. Because the method is a
    class instance, it will always access the class attribute on the class (`cls`),
    instead of the instance (`self`), and thus avoid accidentally shadowing `_codeword`
    on a single instance (see [Listing 7-8](#listing7-8)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，我不必担心是在类上还是实例上调用`inform()`。因为该方法是类方法，它始终会访问类上的类属性（`cls`），而不是实例上的属性（`self`），从而避免了意外地在单个实例上覆盖`_codeword`（请参见[示例
    7-8](#listing7-8)）。
- en: I don’t plan to include a getter for this attribute. After all, secret agents
    have to keep secrets!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算为这个属性提供一个getter。毕竟，特工们得保持秘密！
- en: 'To use this method, I would call something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个方法，我会像这样调用：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-15: *secret_agent_usage.py:3*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-15: *secret_agent_usage.py:3*'
- en: I can call the `inform()` class method directly on the `SecretAgent` class,
    or on any `SecretAgent` instance, such as `fox`. The changes that `inform()` makes
    to the class attribute `_codeword` appear on the class itself and all its instances.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以直接在`SecretAgent`类上调用`inform()`类方法，也可以在任何`SecretAgent`实例上调用，如`fox`。`inform()`对类属性`_codeword`所做的更改会反映在类本身及其所有实例上。
- en: When calling the class method with the dot operator, the class is implicitly
    passed to the `cls` parameter. That parameter name is still just a convention;
    the `@classmethod` decorator is what ensures that the first argument is always
    the class, never the instance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用点操作符调用类方法时，类会隐式地传递给`cls`参数。这个参数名称仅仅是一个约定，`@classmethod`装饰器确保了第一个参数始终是类，而不是实例。
- en: One awesome use of class methods is to provide alternative means of initializing
    instances. For example, the built-in integer class offers `int.from_bytes()`,
    which initializes a new `int` class instance, using a `bytes` value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法的一个妙用是提供初始化实例的替代方式。例如，内置的整数类提供了`int.from_bytes()`，它使用`bytes`值来初始化一个新的`int`类实例。
- en: Static Methods
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: A *static method* is a regular function defined within a class, which accesses
    neither the instance attributes nor the class attributes. The only difference
    between a static method and a function is that a static method belongs to the
    class for namespace reasons.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法*是定义在类中的常规函数，它既不访问实例属性，也不访问类属性。静态方法与普通函数的唯一区别在于，它属于类，仅仅是因为命名空间的原因。'
- en: The main reason to write a static method comes up when your class offers some
    functionality that doesn’t need to access any of the class or instance attributes
    or methods. For example, you may write a static method for handling some particularly
    complicated algorithm that is critical to your class’s implementation. By including
    the static method in the class, you are indicating that the algorithm is part
    of the class’s self-contained implementation logic, even though it does not access
    any attributes or methods.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写静态方法的主要原因出现在你的类提供一些不需要访问任何类或实例属性或方法的功能时。例如，你可能会为处理一些特别复杂的算法编写一个静态方法，而这个算法对你的类的实现至关重要。通过将静态方法包括在类中，你表示这个算法是类自包含实现逻辑的一部分，即使它不访问任何属性或方法。
- en: 'I’ll add a static method to the `SecretAgent` class, which handles one thing
    all the agents would do the same, regardless of their data—answer questions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为`SecretAgent`类添加一个静态方法，用于处理所有特工都需要执行的相同任务——回答问题：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 7-16: *secret_agent.py:5*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-16: *secret_agent.py:5*'
- en: I precede the static method with the `@staticmethod` decorator. You’ll notice
    that I don’t need to worry about a special first parameter, since the method doesn’t
    need access to any attributes. When this method is called on a class or on an
    instance, it only prints out the message, “I know nothing.”
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我在静态方法前面加上`@staticmethod`装饰器。你会注意到，我不需要担心特殊的第一个参数，因为该方法不需要访问任何属性。当此方法在类或实例上调用时，它仅打印出消息：“我什么都不知道。”
- en: Properties
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: '*Properties* constitute a special variety of instance method that allows you
    to write getters and setters that behave so it appears that you were directly
    accessing an instance attribute. Properties allow you to write a consistent interface,
    where you use the object directly through what appear to be its attributes.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*是一种特殊的实例方法，允许你编写getter和setter，使其看起来像是直接访问一个实例属性。属性使你能够编写一个一致的接口，直接通过看起来像是其属性的对象来使用该对象。'
- en: It is preferable to use properties, instead of making the user remember whether
    to call a method or use an attribute. Using properties is also much more Pythonic
    than cluttering your class with bare getters and setters that don’t augment attribute
    access or modification.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更推荐使用属性，而不是让用户记得是调用方法还是使用属性。使用属性比用一堆没有增强属性访问或修改的getter和setter来让你的类变得杂乱更加符合Python的风格。
- en: Setting Up the Scenario
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'To demonstrate properties in action, I’ll expand on my `SecretAgent` class.
    Here’s the class so far. First, to set up, I’ll move it to a new file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示属性的实际应用，我将扩展我的`SecretAgent`类。到目前为止，类如下所示。首先，为了设置，我将它移动到一个新的文件中：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 7-17: *secret_agent_property.py:1*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-17：*secret_agent_property.py:1*
- en: 'Next, I will add one more class method to encrypt whatever message is passed
    to it, using an encryption system of my own devising. This method has nothing
    to do with properties per se, but I include it to make the example complete:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将添加一个类方法，用我自己设计的加密系统来加密传递给它的任何消息。这个方法与属性本身没有关系，但我加入它是为了让示例完整：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 7-18: *Using a property with no getter*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-18：*使用没有getter的属性*
- en: The `_encrypt()` class method uses the `_codeword` class attribute to perform
    a basic substitution cipher encoding on a string `message`. I use `sum()` to find
    the sum of the Unicode code points (as integers) for each character in `_codeword`.
    I pass a character (string) to the `ord()` function, which returns the Unicode
    code point as an integer. This sum of code points is bound to `code`. (The odd-looking
    loop here is actually a generator expression, which I’ll cover in Chapter 10.
    You can take it for granted here that it calls `ord()` on each character in the
    string bound to `cls._codeword`.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`_encrypt()`类方法使用`_codeword`类属性对字符串`message`执行基本的替换密码编码。我使用`sum()`来求出`_codeword`中每个字符的Unicode码点（作为整数）的和。我将一个字符（字符串）传递给`ord()`函数，返回该字符的Unicode码点作为整数。这个码点的总和绑定到`code`。
    （这里看起来很奇怪的循环实际上是一个生成器表达式，我将在第10章介绍。在这里，你可以认为它对绑定到`cls._codeword`的字符串中的每个字符都调用了`ord()`。）'
- en: I use `code` to offset the Unicode code point of each character in the message.
    The `chr()` function returns the character associated with the given code point.
    I pass to it the sum of the current code point and `code`, for each character
    in the message. (Once again, I’m employing a generator expression here.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`code`来偏移消息中每个字符的Unicode码点。`chr()`函数返回与给定码点关联的字符。我将当前码点和`code`的和传递给它，处理消息中的每个字符。（再次强调，我这里使用的是生成器表达式。）
- en: Defining a Property
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义属性
- en: 'A *property* behaves like an attribute, but it is made up of three instance
    methods: a *getter*, a *setter*, and a *deleter*. Remember that a property appears
    to be an ordinary attribute to the user of the class. Accessing the property calls
    the getter, assigning a value to it calls the setter, and deleting the property
    with the `del` keyword calls the deleter.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*属性*表现得像一个普通的属性，但它由三个实例方法组成：一个*getter*、一个*setter*和一个*deleter*。请记住，属性对类的用户来说看起来就像一个普通的属性。访问属性时会调用getter，赋值时会调用setter，使用`del`关键字删除属性时会调用deleter。
- en: Like an ordinary getter or setter method, a property might access or modify
    a nonpublic attribute, multiple attributes, or even no attributes at all. It all
    depends on what behavior you want.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 像普通的getter或setter方法一样，属性可以访问或修改非公开属性、多个属性，甚至没有任何属性。它完全取决于你希望实现的行为。
- en: Here, I’ll define a property called `secret` for my `SecretAgent` class, which
    will serve as the getter, setter, and deleter for my `_secrets` instance attribute.
    This approach will allow me to add logic, such as having the setter encrypt the
    assigned data before storing it in the `_secrets` attribute.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将为`SecretAgent`类定义一个名为`secret`的属性，作为我的`_secrets`实例属性的getter、setter和deleter。这个方法允许我添加逻辑，比如让setter在将数据存储到`_secrets`属性之前进行加密处理。
- en: Before defining the property itself, I need to define the three functions that
    will make up the property. Technically, I can call them whatever I like, but the
    convention is to name them `getx`, `setx`, or `delx`, where `x` is the name of
    the property. I’m also making these nonpublic methods, since I want the client
    to use the property directly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义属性本身之前，我需要先定义构成属性的三个函数。从技术上讲，我可以随便命名它们，但约定俗成的是将它们命名为`getx`、`setx`或`delx`，其中`x`是属性的名称。我还将这些方法定义为非公开方法，因为我希望客户端直接使用这个属性。
- en: 'First, the getter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是getter：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 7-19: *secret_agent_property.py:3*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-19: *secret_agent_property.py:3*'
- en: The getter, `_getsecret()`, accepts no parameters and should return the value
    of the property. In this example, I want the getter to return the last item stored
    in the list bound to the instance attribute `self._secrets`, or if the list is
    empty, to return `None`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: getter，`_getsecret()`，不接受任何参数，应该返回属性的值。在这个例子中，我希望getter返回存储在实例属性`self._secrets`绑定的列表中的最后一个项，如果列表为空，则返回`None`。
- en: 'Next, the setter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是setter：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 7-20: *secret_agent_property.py:4*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-20: *secret_agent_property.py:4*'
- en: The setter, `_setsecret()`, accepts a single parameter, which receives the value
    being assigned to the property in the call (see [Listing 7-23](#listing7-23)).
    In this case, I assume this is some sort of string, which I run through the static
    method `_encode()` I defined earlier and then store in the list `self._secrets`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: setter，`_setsecret()`，接受一个参数，该参数接收在调用中分配给属性的值（参见[示例 7-23](#listing7-23)）。在这个例子中，我假设这是某种字符串，我会将它通过我之前定义的静态方法`_encode()`进行处理，然后将其存储在`self._secrets`列表中。
- en: 'Finally, here’s the deleter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是deleter：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 7-21: *secret_agent_property.py:5*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-21: *secret_agent_property.py:5*'
- en: The *deleter*, `_delsecret()`, accepts no parameters and returns no value. This
    method is called when the property is deleted, either in the background, by the
    garbage collector, or explicitly, with `del secret`. In this example, when the
    property is deleted, I want the entire list of secrets to be cleared.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*deleter*，`_delsecret()`，不接受任何参数，也不返回任何值。这个方法在属性被删除时会被调用，可能是后台的垃圾回收器调用，或者通过`del
    secret`显式调用。在这个例子中，当属性被删除时，我希望清空所有的机密列表。'
- en: You actually don’t need to define a deleter if you have no need for special
    behavior when the decorator is deleted. Consider what you want to happen if `del`
    is called on your decorator, such as when you are deleting an associated attribute
    that the property controls; if you can’t think of anything, skip writing the deleter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要在装饰器被删除时有特殊行为，实际上不需要定义deleter。考虑当`del`被调用时，你希望发生什么，比如当删除属性控制的关联属性时；如果你想不出什么特别的行为，就可以跳过定义deleter。
- en: 'Finally, I define the property itself:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我定义了属性本身：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 7-22: *secret_agent_property.py:6a*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-22: *secret_agent_property.py:6a*'
- en: This is defined on the class itself, outside of the `__init__()` method and
    after the functions that make it up. I pass the three methods to the `fget`, `fset`,
    and `fdel` keyword arguments, respectively (although you can also pass them as
    positional arguments, in that same order). I bind the property to the name `secret`,
    which becomes the property name.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性在类本身上定义，位于`__init__()`方法之外，并在构成它的函数之后。我分别将三个方法传递给`fget`、`fset`和`fdel`关键字参数（虽然你也可以按位置传递这些方法，顺序保持一致）。我将这个属性绑定到名称`secret`，它成为了属性的名称。
- en: 'The property can now be used as if it were an instance attribute:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以像使用实例属性一样使用这个属性：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 7-23: *secret_agent_property.py:7a*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-23: *secret_agent_property.py:7a*'
- en: Every time I try to retrieve the value of the property, the getter is called.
    Meanwhile, assigning a value to the property calls the setter. There’s no need
    to remember and explicitly call dedicated getter or setter methods; I treat the
    property like an attribute.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我尝试获取属性值时，getter会被调用。同时，给属性赋值时会调用setter。无需记住并显式调用专用的getter或setter方法；我把这个属性当作一个普通的属性来使用。
- en: You’ll recall that the deleter for `secrets` clears the contents of the `_secrets`
    list. Just before deleting the property, the list contains two secrets. After
    deleting, the list is empty.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，`secrets` 的 deleter 清空了 `_secrets` 列表的内容。在删除属性之前，列表包含两个秘密。删除后，列表为空。
- en: It is not necessary to define all three parts of the property. For example,
    I don’t want the `secret` property to even have a getter, so I can remove `_getsecret()`
    from my class code. Secret agents shouldn’t share their secrets, after all.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 并不需要定义属性的所有三个部分。例如，我不希望 `secret` 属性有 getter，因此我可以从类代码中删除 `_getsecret()`。毕竟，特工不应该分享他们的秘密。
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 7-24: A secret property with no getter'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-24：一个没有 getter 的秘密属性
- en: Because I don’t pass an argument to `fget`, the default value of `None` is used
    instead ❶. This property has a setter and a deleter, but no getter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我没有给 `fget` 传递参数，默认值 `None` 被使用❶。这个属性有 setter 和 deleter，但没有 getter。
- en: 'As a result, I can assign to `secret`, but I can’t access the value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我可以为 `secret` 赋值，但不能访问其值：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 7-25: *Using a property with no getter*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-25：*使用没有 getter 的属性*
- en: Assigning values to `mouse.secret` works as before, since that calls the setter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `mouse.secret` 赋值仍然像以前一样有效，因为它会调用 setter。
- en: 'However, attempting to access the value throws an `AttributeError`. I could
    instead have written a getter for secrets that always returned `None`, but the
    client would have to remember that it returned this useless value. Recall The
    Zen of Python:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试访问该值会抛出 `AttributeError`。我本可以为 secrets 编写一个 getter，它总是返回 `None`，但客户端必须记住它返回的是这个无用的值。请回想一下
    Python 的 Zen：
- en: Errors should never pass silently.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误绝不应悄无声息地通过。
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非显式地抑制。
- en: If a particular usage is not desired, especially when it comes to designing
    a class or interface, the usage should *explicitly fail*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某种特定用法不被期望，特别是在设计类或接口时，这种用法应该*显式地失败*。
- en: Property with Decorators
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用装饰器的属性
- en: Creating a property is easy enough, but the approach to implementing it that
    I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely
    on my method names to remind me that they’re part of a property. Thankfully, there’s
    another way.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建属性是足够简单的，但到目前为止我展示的实现方法并不真正符合 Pythonic 风格，因为我必须依赖方法名称来提醒自己它们是属性的一部分。幸运的是，还有另一种方式。
- en: 'Python offers a cleaner approach to defining properties: with decorators. There
    are two approaches to this technique.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一种更简洁的定义属性的方法：使用装饰器。这种技术有两种方法。
- en: 'Approach 1: property() and Decorators'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 1：property() 和装饰器
- en: The first approach is to still employ the `property()` function but use decorators
    to denote the associated methods. The chief benefit of this approach is the added
    readability, and it is mainly used when the getter will be omitted. I can use
    the name of the property as the method name and rely on the decorator to clarify
    its role.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法仍然是使用 `property()` 函数，但通过装饰器来标记关联的方法。这种方法的主要优点是可读性提高，通常在省略 getter 时使用。我可以使用属性的名称作为方法名称，并依赖装饰器来澄清其角色。
- en: 'Here’s my rewritten code for the `secret` property, using this approach:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我重新编写的 `secret` 属性代码，使用这种方法：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 7-26: *secret_agent_property.py:3b*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-26：*secret_agent_property.py:3b*
- en: 'In this approach, I define `secret` as a property before writing its methods.
    I pass no arguments to `property()`, so all three functions default to `None`.
    Next, I add the getter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我先将 `secret` 定义为属性，再编写它的方法。我没有给 `property()` 传递参数，因此所有三个函数默认值为 `None`。接下来，我添加
    getter：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 7-27: *secret_agent_property.py:4b*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-27：*secret_agent_property.py:4b*
- en: My getter method now must have the same name as the property, `secret`. If it
    doesn’t, it will fail with an `AttributeError` when the getter is first called,
    rather than when the class is created. The method is preceded by the decorator
    `@secret.getter`. This designates it as the getter for the property, just as if
    I had passed it to `property(fget=)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 getter 方法现在必须与属性同名，即 `secret`。如果不同名，在第一次调用 getter 时会抛出 `AttributeError`，而不是在类创建时抛出。该方法前面需要加上装饰器
    `@secret.getter`，这将其指定为属性的 getter，就像我将它传递给 `property(fget=)` 一样。
- en: 'Here’s the setter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 setter：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 7-28: *secret_agent_property.py:5b*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-28：*secret_agent_property.py:5b*
- en: Similarly, the setter method must share its name with the property it relates
    to, and it is preceded by the decorator `@secret.setter`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，setter 方法必须与它所关联的属性同名，并且它前面需要加上装饰器 `@secret.setter`。
- en: 'Finally, the deleter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是 deleter：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 7-29: *secret_agent_property.py:6b*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-29：*secret_agent_property.py:6b*
- en: Similar to the getter and setter, the deleter is preceded by the decorator `@secret.deleter`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于getter和setter，deleter方法前需要加上装饰器`@secret.deleter`。
- en: This version works as is, but there is an even better technique.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本可以正常工作，但还有一个更好的技术。
- en: 'Approach 2: Decorators Without property()'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：没有`property()`的装饰器
- en: The second approach to declaring a property with decorators is even shorter,
    and it is the most commonly used. This approach is preferred when defining a property
    that has a getter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器声明属性的第二种方法更简洁，也是最常用的。当定义一个具有getter方法的属性时，推荐使用这种方法。
- en: 'If you have defined a getter, you don’t have to explicitly create and assign
    a `property()`. Instead, the decorator `@property` can be applied to the getter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经定义了getter方法，就不必显式地创建并赋值给`property()`。相反，装饰器`@property`可以直接应用于getter方法：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: I precede the getter function with the decorator `@property`, instead of `@secret.getter`,
    which creates a property with the same name as the method. Since this defines
    the property `secret`, I don’t need `secret = property()` anywhere in my code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我将getter函数前加上装饰器`@property`，而不是`@secret.getter`，这样就创建了一个与方法同名的属性。因为这个方法定义了属性`secret`，所以在代码中不需要再写`secret
    = property()`。
- en: Bear in mind, this shortcut only works with the getter method. The setter and
    deleter must be defined in the same manner as before.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种快捷方式仅适用于getter方法。setter和deleter方法仍需像之前一样定义。
- en: 'As before, I can omit any of the three methods if their behavior is not desired.
    For example, if I don’t want `secret` to be readable, I omit the getter, so my
    full property code looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果某个方法的行为不需要，可以省略这三种方法中的任何一种。例如，如果我不希望`secret`是可读的，我就省略getter方法，那么我的完整属性代码如下：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because I don’t have a getter, I must explicitly declare my property up front
    ❶. In this version, assignment and deletion of `secret` works as before, but accessing
    the value raises an `AttributeError`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有getter方法，所以必须明确声明我的属性❶。在这个版本中，`secret`的赋值和删除与以前一样，但访问其值会引发`AttributeError`。
- en: When Not to Use Properties
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时不使用属性
- en: There’s some debate about when to use properties, versus traditional getter
    and setter methods. One of the chief drawbacks of properties is that they conceal
    that some calculation or processing is being performed upon assignment, which
    the client might not expect. This especially becomes a problem if this processing
    is particularly long or complicated, such that a client may need to run it concurrently
    with `async` or threads (see Chapters 16 and 17); you cannot run an assignment
    concurrently with the same ease as running a method concurrently.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时使用属性，何时使用传统的getter和setter方法，仍存在一些争议。属性的一个主要缺点是，它隐藏了在赋值时执行某些计算或处理的事实，而客户端可能没有预料到这一点。如果这个处理过程特别耗时或复杂，客户端可能需要与`async`或线程并发运行（参见第16章和第17章）；你不能像运行方法那样轻松地并发执行赋值操作。
- en: You must also consider the expected behavior of an assignment. When a value
    is directly assigned to an attribute, you would typically expect the same value
    to be retrievable *from* that attribute. In reality, depending on how you wrote
    your properties, the value might be transformed when assigned or accessed. You’ll
    need to take this client expectation into consideration when designing your class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须考虑赋值时的预期行为。当一个值直接赋给一个属性时，通常期望能够从该属性中获取到相同的值。实际上，根据你定义属性的方式，赋值或访问时，值可能会被转换。设计类时需要考虑到这一点，以满足客户端的预期。
- en: Some camps believe properties should only be used as a way of deprecating attributes
    that used to be public or that have been removed entirely. Others, like myself,
    find properties useful as replacements for otherwise relatively simplistic getters
    and setters that still involve more logic than plain assignment and access.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一些观点认为，属性应该仅作为淘汰以前是公开的或已经完全移除的属性的手段。还有一些人，比如我自己，认为属性作为相对简单的getter和setter的替代品非常有用，这些getter和setter通常涉及比简单赋值和访问更多的逻辑。
- en: In any case, properties are some of those cool features of Python that are all
    too easy to misuse or misapply. Carefully consider the implications of properties,
    public attributes, or methods in your specific case. Take the occasion to consult
    the advice of other experienced Python developers, such as in the Libera.Chat
    IRC `#python` channel. (If you want to debate the most Pythonic general position
    on properties, though, bring a helmet.)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，属性是 Python 中一些非常酷的特性，但它们也很容易被误用或滥用。请仔细考虑在特定情况下属性、公共属性或方法的含义。趁机咨询其他有经验的
    Python 开发者的建议，例如在 Libera.Chat IRC `#python` 频道中。（不过，如果你想讨论关于属性的最 Pythonic 的普遍立场，记得戴上头盔。）
- en: Special Methods
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊方法
- en: Special methods are my favorite part of Python object-oriented programming.
    I’m trembling a little with excitement right now (or maybe I had too much coffee).
    *Special methods*, sometimes called *magic methods*, allow you to add support
    to your classes for virtually any Python operator or built-in command!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法是我最喜欢的 Python 面向对象编程部分。我现在有点激动（或者我可能喝了太多咖啡）。*特殊方法*，有时也叫做*魔法方法*，让你可以为你的类添加几乎任何
    Python 运算符或内置命令的支持！
- en: 'Special methods are also colloquially known as *dunder methods*—which is short
    for “***d***ouble ***under***score”—because they begin and end with two underscore
    characters (`__`). You’ve already seen three examples of special methods: `__init__()`,
    `__new__()`, and `__del__()`. The Python language defines about a hundred special
    methods, most of which are documented at [https://docs.python.org/3/reference/datamodel.xhtml](https://docs.python.org/3/reference/datamodel.xhtml).
    I’ll cover a number of the most common ones here. In future chapters, I’ll discuss
    other special methods as they become relevant. I also list all the special methods
    in Python in Appendix A.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法在口语中也被称为 *dunder 方法*——这是“***d***ouble ***under***score”的缩写——因为它们以两个下划线字符（`__`）开始和结束。你已经看到了三个特殊方法的例子：`__init__()`、`__new__()`
    和 `__del__()`。Python 语言定义了大约一百个特殊方法，其中大部分有文档说明，可以在 [https://docs.python.org/3/reference/datamodel.xhtml](https://docs.python.org/3/reference/datamodel.xhtml)
    找到。我将在这里介绍一些最常见的特殊方法。在未来的章节中，我会讨论其他在相关时出现的特殊方法。附录 A 中列出了 Python 中的所有特殊方法。
- en: Scenario Setup
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'For the examples in this section, I’ll use a new class, `GlobalCoordinates`,
    which will store a global coordinate as latitude and longitude. This class is
    defined as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，我将使用一个新类 `GlobalCoordinates`，它将存储一个全球坐标，包含纬度和经度。这个类的定义如下：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 7-30: *global_coordinates.py:1*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-30：*global_coordinates.py:1*
- en: You can probably work out what’s going on here, based on the knowledge you have
    so far. The class `GlobalCoordinates` converts and stores a latitude and longitude
    as tuples of degrees, minutes, seconds, and a string literal representing a cardinal
    direction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前掌握的知识，你应该能猜到这里发生了什么。类 `GlobalCoordinates` 将纬度和经度转换并存储为包含度、分、秒的元组以及表示方向的字符串字面量。
- en: I chose to create this particular class because its data lends itself well to
    a healthy subset of the special methods I’ll cover.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择创建这个特定类，因为它的数据非常适合我将介绍的特殊方法的健康子集。
- en: Conversion Methods
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法
- en: There are many ways to represent the same data, and most clients will expect
    to be able to convert an object containing data to any Python primitive type that
    makes sense. For example, global coordinates could be expressed as strings or
    hashes. You should carefully consider what data types your class should support
    conversion to. Here, I cover some special methods for data conversions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以表示相同的数据，大多数客户端都期望能够将包含数据的对象转换为任何有意义的 Python 原生类型。例如，全局坐标可以表示为字符串或哈希值。你应该仔细考虑你的类应支持哪些数据类型的转换。在这里，我将介绍一些用于数据转换的特殊方法。
- en: 'Canonical String Representation: __repr__()'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规范字符串表示：__repr__()
- en: When writing a class, it is considered good practice to define, at minimum,
    the `__repr__()` instance method, which returns the *canonical string representation*
    of the object. This string representation should ideally contain all the data
    necessary to create another class instance with the same contents.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写类时，通常被认为是良好的实践至少定义 `__repr__()` 实例方法，该方法返回对象的*规范字符串表示*。这个字符串表示应该理想地包含所有必要的数据，以便使用相同的内容创建另一个类实例。
- en: 'If I don’t define a `__repr__()` instance method for `GlobalCoordinates`, Python
    falls back on its default version for objects, which is pretty uselessly underwhelming.
    I’ll create an instance of `GlobalCoordinates` and print this default representation
    via `repr()`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有为 `GlobalCoordinates` 定义 `__repr__()` 实例方法，Python 会使用其对象的默认版本，这通常是比较无用且不够吸引人的。我将创建一个
    `GlobalCoordinates` 实例，并通过 `repr()` 打印这个默认表示：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 7-31: *global_coordinates_usage.py:1*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-31: *global_coordinates_usage.py:1*'
- en: 'Running that prints out the following canonical string representation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时会打印出以下标准字符串表示：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Not good for much, is it? Instead, I’ll define my own `__repr__()` instance
    method for the class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么用，是吧？相反，我会为这个类定义我自己的 `__repr__()` 实例方法：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 7-32: *global_coordinates.py:2*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-32: *global_coordinates.py:2*'
- en: 'I return a string containing all the information needed to recreate the instance:
    the class name, the latitude, and the longitude.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我返回一个包含所有重建实例所需信息的字符串：类名、纬度和经度。
- en: 'Rerunning the code in [Listing 7-31](#listing7-31) now produces more useful
    information:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行 [列表 7-31](#listing7-31) 现在会输出更有用的信息：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Human-Readable String Representation: __str__()'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 人类可读字符串表示： __str__()
- en: The `__str__()` special method has a similar purpose to `__repr__()`, except
    that it’s meant to be human-readable, as opposed to the more technically inclined
    canonical representation, which is more useful for debugging.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__()` 特殊方法的作用类似于 `__repr__()`，只是它是为了人类可读，而 `__repr__()` 更多的是为了技术性的标准表示，更有利于调试。'
- en: If you don’t define `__str__()`, the `__repr__()` function will be used instead,
    but that wouldn’t be desirable in this example. The user should only see the pretty
    coordinates!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有定义 `__str__()`，那么 `__repr__()` 函数将被使用，但在这个例子中那并不是理想的。用户应该只看到漂亮的坐标！
- en: 'Here’s my `__str__()` instance method for `GlobalCoordinates`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为 `GlobalCoordinates` 定义的 `__str__()` 实例方法：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 7-33: *global_coordinates.py:3*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-33: *global_coordinates.py:3*'
- en: Unlike with `__repr__()`, I omit all that boring technical information and focus
    on composing and returning a string representation a user might want to see.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `__repr__()` 不同，我省略了所有枯燥的技术信息，专注于编写并返回用户可能想要看到的字符串表示。
- en: 'This method is called when an instance of the class is passed to `str()`, although
    passing the instance directly to `print()` or as an expression in a formatted
    string will also invoke `__str__()`. For example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当类的实例传递给 `str()` 时，将调用此方法，尽管直接将实例传递给 `print()` 或作为格式化字符串中的表达式也会调用 `__str__()`。例如：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 7-34: *global_coordinates_usage.py:2*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-34: *global_coordinates_usage.py:2*'
- en: 'That outputs the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Lovely and readable!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮且易读！
- en: 'Unique Identifier (Hash): __hash__()'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 唯一标识符（哈希）： __hash__()
- en: The `__hash__()` method typically returns a *hash value*, which is an integer
    that is unique to the data within the class instance. This allows you to use instances
    of the class in certain collections, such as keys in a dictionary or values in
    a set (see Chapter 9). It’s often helpful to write this method yourself, as the
    default behavior results in every class instance having a unique hash value, even
    if two instances contain the exact same data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`__hash__()` 方法通常返回一个*哈希值*，这是一个唯一的整数，代表类实例中的数据。这使得你可以在某些集合中使用类的实例，比如字典的键或集合中的值（参见第
    9 章）。通常最好自己编写这个方法，因为默认行为会导致每个类实例拥有唯一的哈希值，即使两个实例包含相同的数据。'
- en: The `__hash__()` method should only depend on values that won’t change for the
    life of the instance! Several collections rely on these hash values *never changing*,
    but the value of a mutable object might change.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`__hash__()` 方法应该只依赖于实例生命周期内不会改变的值！几个集合依赖于这些哈希值*永不改变*，但是可变对象的值可能会变化。'
- en: 'Here’s my `__hash__()` function for `GlobalCoordinates`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为 `GlobalCoordinates` 定义的 `__hash__()` 函数：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 7-35: *global_coordinates.py:4*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-35: *global_coordinates.py:4*'
- en: I’ve taken the most common approach, which is to create a tuple containing all
    the important instance attributes and then to call `hash()` on the tuple, which
    returns the hash value of whatever is passed to it. I then return that hash value.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我采取了最常见的方法，即创建一个包含所有重要实例属性的元组，然后对该元组调用 `hash()`，返回它的哈希值。然后，我返回这个哈希值。
- en: Additional Conversion Special Methods
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他转换特殊方法
- en: 'Python has special methods for converting the data in the instance to other
    forms. It is up to you to decide which of these you will define on your class:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一些特殊方法，用于将实例中的数据转换成其他形式。你可以决定在你的类中定义哪些方法：
- en: '`__bool__()` should return `True` or `False`. If this isn’t defined, the automatic
    conversion to a boolean value will check whether `__len__()` returns a nonzero
    value (see Chapter 9); otherwise, `True` will always be used.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__bool__()` 应该返回 `True` 或 `False`。如果没有定义这个方法，自动转换为布尔值时会检查 `__len__()` 是否返回非零值（参见第9章）；否则，默认使用
    `True`。'
- en: '`__bytes__()` should return a `bytes` object (see Chapter 12).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__bytes__()` 应该返回一个 `bytes` 对象（参见第12章）。'
- en: '`__ceil__()` should return an `int` numeric value, usually resulting from rounding
    up a `float` value to the nearest integer.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ceil__()` 应该返回一个 `int` 数值，通常是通过将 `float` 值向上舍入到最接近的整数得到的。'
- en: '`__complex__()` should return a `complex` numeric value.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__complex__()` 应该返回一个 `complex` 数值。'
- en: '`__float__()` should return a `float` numeric value.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__float__()` 应该返回一个 `float` 数值。'
- en: '`__floor__()` should return an `int` numeric value, usually resulting from
    rounding down a `float` numeric value to the nearest integer.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__floor__()` 应该返回一个 `int` 数值，通常是通过将 `float` 数值向下舍入到最接近的整数得到的。'
- en: '`__format__()` should accept a string representing the format specification
    (see Chapter 3) and return a string representation of the instance, with the specification
    applied. How exactly you apply the specification is up to you.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__format__()` 应该接受一个表示格式规范的字符串（参见第3章），并返回实例的字符串表示形式，并应用该格式规范。如何具体应用该规范由你决定。'
- en: '`__index__()` should return the same value as `__int__()`, which must also
    be defined if you write this method. The presence of this method indicates that
    the class should be considered a type of integer; you don’t have to throw away
    any data to get the integer value (lossless conversion).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__index__()` 应该返回与 `__int__()` 相同的值，如果你编写了这个方法，`__int__()` 也必须定义。这个方法的存在表示该类应被视为一种整数类型；你无需丢弃任何数据就能得到整数值（无损转换）。'
- en: '`__int__()` should return an `int` numeric value. You may simply have this
    function call `__ceil__()`, `__floor__()`, `__round__()`, or `__trunc__()`.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__int__()` 应该返回一个 `int` 数值。你可以简单地让这个函数调用 `__ceil__()`、`__floor__()`、`__round__()`
    或 `__trunc__()`。'
- en: '`__round__()` should return an `int` numeric value, usually resulting from
    rounding a `float` numeric value up or down.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__round__()` 应该返回一个 `int` 数值，通常是通过将 `float` 数值四舍五入得到的。'
- en: '`__trunc__()` should return an `int` numeric value, usually resulting from
    dropping the non-whole (decimal) part of a `float` numeric value.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__trunc__()` 应该返回一个 `int` 数值，通常是通过去掉 `float` 数值的小数部分得到的。'
- en: You only need to define the special methods that make sense for your class.
    In my case, *none* of these additional conversion methods are particularly suitable
    for a pair of global coordinates.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要为你的类定义合适的特殊方法。在我的案例中，*这些额外的转换方法* 并不适合一对全局坐标。
- en: Comparison Methods
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较方法
- en: 'Python has six comparison special methods that correspond to the six comparison
    operators in Python: `==`, `!=`, `<`, `>`, `<=`, and `>=`. Each one conventionally
    returns a boolean value.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有六个比较特殊方法，分别对应 Python 中的六个比较运算符：`==`、`!=`、`<`、`>`、`<=` 和 `>=`。每个方法通常返回一个布尔值。
- en: If one of these special methods is called, but the method isn’t defined, the
    class instance will return the special value `NotImplemented` to alert Python
    that the comparison didn’t happen. This allows the language to decide the best
    response. In the case of comparisons with built-in types, `NotImplemented` will
    be coerced to the boolean value `False`, so as to not break algorithms that rely
    on those functions. In most other situations, a `TypeError` will be raised.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用了这些特殊方法中的某个方法，但该方法未定义，类实例将返回特殊值 `NotImplemented`，以提醒 Python 该比较未发生。这允许语言决定最佳响应。在与内建类型的比较中，`NotImplemented`
    将被强制转换为布尔值 `False`，以避免破坏依赖这些函数的算法。在大多数其他情况下，将引发 `TypeError` 错误。
- en: 'Equals: __eq__()'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等于：__eq__()
- en: 'The `__eq__()` special method is called by the equals (`==`) operator. I’ll
    define this method for my `GlobalCoordinates` class:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`__eq__()` 特殊方法由等于（`==`）运算符调用。我将在我的 `GlobalCoordinates` 类中定义这个方法：'
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 7-36: *global_coordinates.py:5*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-36: *global_coordinates.py:5*'
- en: 'All comparison special methods accept two parameters: `self` and `other`. These
    represent the operands on the left and right of the operator, so `a == b` would
    call `a.__eq__(b)`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有比较特殊方法都接受两个参数：`self` 和 `other`。这表示运算符左右两边的操作数，因此 `a == b` 将调用 `a.__eq__(b)`。
- en: In the ongoing example, it would only make sense to compare two `GlobalCoordinates`
    class instances to one another. Comparing a `GlobalCoordinates` instance directly
    to an integer or a float wouldn’t be logical. Thus, this is one of those rare
    scenarios where type matters. I use `isinstance()` to ensure `other` is an instance
    of the `GlobalCoordinates` class (or a subclass thereof) ❶. If it is, I compare
    the instance attributes that constitute the latitude and longitude of one `GlobalCoordinates`
    instance to the same attributes of the other instance. I return `True` if they
    all match.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '在持续进行的示例中，将两个 `GlobalCoordinates` 类实例互相比较才是有意义的。将一个 `GlobalCoordinates` 实例直接与一个整数或浮点数比较是没有逻辑的。因此，这是一个类型非常重要的罕见场景。我使用
    `isinstance()` 来确保 `other` 是 `GlobalCoordinates` 类的实例（或其子类的实例） ❶。如果是，我将比较构成一个
    `GlobalCoordinates` 实例的纬度和经度属性与另一个实例的相同属性。如果它们都匹配，我返回 `True`。  '
- en: However, if `other` is of a different type, the comparison doesn’t happen, so
    I return the special value `NotImplemented` ❶.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，如果 `other` 是不同类型，比较就不会发生，因此我返回特殊值 `NotImplemented` ❶。  '
- en: 'Not Equals: __ne__()'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不等于：__ne__()
- en: The `__ne__()` special method corresponds to the not-equals (`!=`) operator.
    If undefined, a call to `__ne__()` *delegates* to `__eq__()`, just returning the
    opposite value that `__eq__()` does. If this is what you’re expecting, there’s
    no need to define `__ne__()`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`__ne__()` 特殊方法对应不等于（`!=`）操作符。如果未定义，调用 `__ne__()` 会*委托*给 `__eq__()`，仅返回与 `__eq__()`
    相反的值。如果这是你期望的结果，则无需定义 `__ne__()`。  '
- en: However, if there’s more complex logic to your not-equals comparison, it might
    make sense to define it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，如果你的不等式比较包含更复杂的逻辑，可能需要定义它。  '
- en: 'Less Than and Greater Than: __lt__() and __gt__()'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '小于和大于：__lt__() 和 __gt__()  '
- en: 'The special methods `__lt__()` and `__gt__()` correspond to the less-than (`<`)
    and greater-than (`>`) operators, respectively. These two special methods are
    *reflections* of one another, meaning one operator in the pair can be substituted
    for the other. The expression `a < b` calls `a.__lt__(b)`, but if that returns
    ``NotImplemented, Python automatically flips the logic and calls `b.__gt__(a)`.
    Thus, if you’re only comparing instances of the same class, you can often get
    away with defining just one of the two special methods: usually, `__lt__()`. The
    same is true of `__le__()` and `__ge__()`, which correspond to less-than-or-equal-to
    (`<=`) and greater-than-or-equal-to (`>=`).``'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '特殊方法 `__lt__()` 和 `__gt__()` 分别对应小于（`<`）和大于（`>`）操作符。这两个特殊方法是*相互映射*的，意味着这对操作符中的一个可以替代另一个。表达式
    `a < b` 调用 `a.__lt__(b)`，但是如果返回 `NotImplemented`，Python 会自动反转逻辑并调用 `b.__gt__(a)`。因此，如果你只比较相同类的实例，通常只需定义两个特殊方法中的一个：通常是
    `__lt__()`。`__le__()` 和 `__ge__()` 也是一样，它们分别对应小于或等于（`<=`）和大于或等于（`>=`）。  '
- en: '[PRE44]  def __sub__(self, other):         if not isinstance(other, GlobalCoordinates):             return
    NotImplemented          lat_diff = self.latitude - other.latitude         lon_diff
    = self.longitude - other.longitude         return (lat_diff, lon_diff) [PRE45]  def
    __invert__(self):         return GlobalCoordinates(             latitude=self.degrees_from_decimal(-self.latitude,
    lat=True),             longitude=self.degrees_from_decimal(-self.longitude, lat=False)         )
    [PRE46]  def __call__(self, ❶ other):         EARTH_RADIUS_KM = 6371          distance_lat
    = math.radians(other.latitude - self.latitude)         distance_lon = math.radians(other.longitude
    - self.longitude)         lat = math.radians(self.latitude)         lon = math.radians(self.longitude)         a
    = (             math.sin(distance_lat / 2)             * math.sin(distance_lat
    / 2)             + math.sin(distance_lon)             * math.sin(distance_lon
    / 2)             * math.cos(lat)             * math.cos(lon)         )         c
    = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))        ❷ return c * EARTH_RADIUS_KM
    [PRE47] nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),                              longitude=(122,
    24, 39.4, "W"))  psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),                         longitude=(122,
    47, 30.2 "W"))  distance = nostarch(psf) print(distance)  # 852.6857266443297
    [PRE48] class CoffeeOrder:      def __init__(self, recipe, to_go=False):         self.recipe
    = recipe         self.to_go = to_go      def brew(self):         vessel = "in
    a paper cup" if self.to_go else "in a mug"         print("Brewing", *self.recipe.parts,
    vessel)   class CoffeeRecipe:      def __init__(self, parts):         self.parts
    = parts   special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
    order = CoffeeOrder(special, to_go=False) order.brew()  # prints "Brewing double-shot
    grande no-whip mocha in a mug" [PRE49] import functools ❶ def auto_order(to_go):     def
    decorator(cls):         @functools.wraps(cls)         def wrapper(*args, **kwargs):          ❷
    recipe = cls(*args, **kwargs)          ❸ return (CoffeeOrder(recipe, to_go), recipe)         return
    wrapper   ❹ return decorator [PRE50] @auto_order(to_go=True) class CoffeeShackRecipe(CoffeeRecipe):     pass   order,
    recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"]) order.brew()  # prints
    "Brewing tall decaf cappuccino in a paper cup" [PRE51] class Pizza:      def __init__(self,
    topping, second_topping=None):         self.first = topping         self.second
    = second_topping  order = Pizza("pepperoni", "mushrooms")  match order:     case
    Pizza(first=''pepperoni'', second=''mushroom''):         print("ANSI standard
    pizza")     case Pizza(first=''pineapple''):         print("Is this even pizza?")
    [PRE52] # `--snip--`  match order:   # `--snip--`     case Pizza(first=''pineapple''):         print("Is
    this even pizza?")  **case Pizza(first=first, second=''cheese''):**  **print(f"Very
    cheesy pizza with {first}.")** [PRE53] # `--snip--`  match order:   # `--snip--`  `case
    Pizza(first=first, second=''cheese''):`  `print(f"Very cheesy pizza with {first}.")`  **case
    Pizza(first=first, second=second):**  **print(f"Pizza with {first} and {second}.")**
    [PRE54] class Point:     def __init__(self, x, y, z):         self.x_pos = x         self.y_pos
    = y         self.z_pos = z   point = Point(0, 100, 0)  match point:     case Point(x_pos=0,
    y_pos=0, z_pos=0):         print("You are here.")     case Point(x_pos=0, y_pos=_,
    z_pos=0):         print("Look up!") [PRE55] class Point:  **__match_args__ = (''x_pos'',
    ''y_pos'', ''z_pos'')**      def __init__(self, x, y, z):         self.x_pos =
    x         self.y_pos = y         self.z_pos = z   point = Point(0, 123, 0)  match
    point:     case Point(**0, 0, 0**):         print("You are here.")     case Point(**0,
    _, 0**):         print("Look up!") [PRE56] thing.action()  # this can mutate attributes
    in thing [PRE57] action(thing)  # should not modify thing; returns new value or
    object [PRE58]`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
