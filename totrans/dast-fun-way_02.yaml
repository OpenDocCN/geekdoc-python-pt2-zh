- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary Search
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Binary search* is an algorithm for efficiently searching a sorted list. It
    checks the sorted list for a target value by repeatedly dividing the list in half,
    determining which of the two halves could contain the target value, and discarding
    the other half. This algorithm’s simplicity of logic and implementation make it
    a perfect introductory topic for computer science, so binary search algorithms
    are nearly universal throughout computer science courses and textbooks.'
  prefs: []
  type: TYPE_NORMAL
- en: The skeptical reader might wonder, “How often will I really need to search a
    sorted list?” or, more accurately, “How often will I need to implement a function
    to search my sorted list? Haven’t a few million people done this? Isn’t it in
    a library somewhere?” While you shouldn’t reject the possibility of one day needing
    to implement your own binary search, its true importance goes well beyond its
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search illustrates how clever algorithms can use the structure in which
    data is stored to achieve significant computational savings, even when this structure
    is as simple as sorted data. Binary search is easily analyzed for correctness
    and efficiency, provides guarantees of both speed and correctness, and demonstrates
    the fundamental interaction between data and algorithms. It’s an excellent lens
    with which to examine difference in data storage techniques, such as the difference
    between linked lists and arrays, or the motivation behind many tree-based algorithms.
    It can even be used to create a better cup of coffee.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before defining any new algorithm, we must define the problem the algorithm
    will try to solve. In this chapter, our aim is to find a single item in a list
    that matches the given target value; we need an algorithm that can efficiently
    perform such a search. Formally we can define this search as:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a set of *N* data points *X* = {*x*[*1*]*, x*[*2*]*,* . . . *, x*[*N*]}
    and a target value *x*', find a point *x*[*i*]∈ *X* such that *x*'= *x*[*i*],
    or indicate that no such point exists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our everyday lives, we would likely describe the task as “Find me this particular
    thing.” This search problem is one that we all face numerous times a day. We might
    be hunting for a word in a dictionary, a name in our contacts list, a specific
    date in a list of historical of events, or our preferred brand of coffee in a
    densely packed supermarket shelf. All we need is a list of candidates and a way
    to check whether we’ve found a match.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To appreciate the advantages of binary search, we start with a simpler algorithm,
    *linear scan*, to provide a baseline for comparison. Linear scan searches for
    a target value by testing each value in our list, one after the other, against
    the target value, until the target is found or we reach the end of our list. This
    is how the author normally searches supermarket shelves—running his finger along
    the brightly colored packages of coffee, one by one, while mumbling to himself
    about the need for better indexing schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we are looking to find the target value in an array `A` of numbers.
    In this case, let’s use `target = 21`. We iterate through each bin in the array
    and check whether that value equals 21, as illustrated in [Figure 2-1](#figure2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-1](#listing2-1) shows the code for linear scan. The code returns
    the index of the matching element if one is found and returns an index of `-1`
    if the search fails and the item is not in our array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: The code for linear scan'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing how to perform a linear scan on an array of 11 unsorted
    bins containing numbers. We check whether the value of the first bin is 21; it
    isn’t, so we check the next bin and so on until we find a match.](image_fi/502604c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: A linear scan over an array of integers'
  prefs: []
  type: TYPE_NORMAL
- en: A single `WHILE` loop iterates over each element of the array, and the internal
    `IF` statement compares that element to the target. As soon as we come across
    an element matching the target, we return the corresponding index. If we make
    it to the end of the array, we return `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Linear scan isn’t fancy or clever. It’s a *brute-force* test guaranteed to find
    the item of interest (if the item is in the data) because it checks every possible
    item until it finds a match or confirms the item is missing. This is thorough
    but inefficient, especially for large lists. If we know nothing about the structure
    of the data in `A`, there is nothing we can do to streamline the process. The
    target value could be in any bin, so we may need to check them all.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate linear scan’s limitations, imagine performing such a scan on a
    physical row of items, like a line of introductory computer science students standing
    outside a classroom. The teacher, looking to return a specific student’s assignment,
    walks down the line asking each student “Is your name Jeremy?” before potentially
    moving onto the next. The search stops when the teacher finds the correct student
    or makes it to the end of the line. The students (correctly) roll their eyes and
    mutter about their inefficient instructor.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes there are ways to make linear search faster *per comparison*. For
    example, we might optimize the comparison time for more complex data by stopping
    at the first mismatched letter when comparing strings, as described in Chapter
    1. Likewise, in the supermarket case, we could consume massive amounts of coffee
    ahead of time, so our shaky finger zips faster along the shelf. However, this
    only helps to a point. We are still limited to checking every item, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll see how a small amount of structure in the data changes
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Binary search is an algorithm to find a target value *v* in a *sorted* list
    and only works on sorted data. The algorithm can be written to work with data
    sorted in either increasing or decreasing order, but, for now, let’s consider
    the case of data sorted in increasing order—lowest to highest. The algorithm operates
    by partitioning the list in half and determining in which half *v* must reside.
    It then discards the half that *v* is not in and repeats the process with only
    the half that can possibly still contain *v* until only one value remains. For
    example, if we were searching the sorted list in [Figure 2-2](#figure2-2) for
    the value 7, we would find 5 at the midpoint and could rule out the first half
    of the list. Anything before the middle element cannot be greater than 5, and,
    since 5 is less than 7, everything before 5 is also less than 7.
  prefs: []
  type: TYPE_NORMAL
- en: '![A sorted list of integers from 1 to 9\. An arrow points to the midpoint with
    value 5.](image_fi/502604c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: A sorted list of integers from 1 to 9, where 5 is the midpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to efficient algorithms is using information or structure within the
    data. In the case of binary search, we use the fact that the array is sorted in
    increasing order. More formally, consider a sorted array `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*[*i*] ≤ *A*[*j*] for any pair of indexes *i* and *j* such that *i* < *j*'
  prefs: []
  type: TYPE_NORMAL
- en: While this might not seem like a lot of information, it’s enough to allow us
    to rule out entire sections of the array. It’s similar to the logic we use to
    avoid the ice cream aisle when searching for coffee. Once we know an item won’t
    be in a given area, we can rule out that entire set of items in that area without
    individually checking them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary search tracks the current search space with two bounds: the upper bound
    `IndexHigh` marks the highest index of the array that is part of the active search
    space, and the lower bound `IndexLow` marks the lowest. Throughout the algorithm,
    if the target value is in the array, we guarantee the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Binary search starts each iteration by choosing the midpoint of the current
    search space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'where `Floor` is a mathematical function that rounds a number down to an integer.
    We then compare the value at the middle location, `A[IndexMid]`, with the target
    value `v`. If the middle point is less than the target value, `A[IndexMid] < v`,
    we know the target value must lie after the middle index. This allows us to chop
    the search space in half by making `IndexLow = IndexMid + 1`. Alternately, if
    the middle point is greater than the target value, `A[IndexMid] > v`, we know
    the target value must lie before the middle index, which allows us to chop the
    search space in half by making `IndexHigh = IndexMid – 1`. Of course, if we find
    `A[IndexMid] == v`, we immediately conclude the search: we’ve found the target.
    Boisterous celebration is optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row in [Figure 2-3](#figure2-3) represents a step in the binary search
    process on a sorted array. We’re searching the array at row (a) for the value
    `15`. At the start, our search bounds include the entire array: `IndexLow = 0`
    and `IndexHigh = 11`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In row (b), we compute the midpoint (rounding down) to be `IndexMid = 5`. Comparing
    the midpoint’s value to the target value, we see that `A[5] = 11`, which is less
    than our target value of 15\. Therefore, in row (c), we rule out every element
    in the array up to and including index `5`—that is, all the shaded elements—by
    adjusting the lower bounds: `IndexLow = 6`. We’ve eliminated almost half our search
    space with a single comparison! The algorithm repeats this process on the remaining
    range, computing the new midpoint as `IndexMid = 8`, comparing to the target value
    (`A[8] = 30`, which is greater than `v = 15`), and refining our bounds to `IndexHigh
    = 7`. In row (d), we once again eliminate half of the remaining search in the
    same way. In row (e), we again compute the midpoint as `IndexMid = 6` and compare
    it to the target value (`A[6] == v`). We’ve found the target!'
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though the lower bound’s index pointed to the target value (`v
    = 15`) for several iterations, we continued the search until the *midpoint* pointed
    to the target value. This is because our search checks only the value at the midpoint
    against the target and not the values at the lower or upper indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our line of introductory computer science students, we can imagine
    that by the end of the semester, the teacher asks the students to line up in alphabetical
    order. The teacher then starts a binary search by asking the middle student “What
    is your name?” and uses the responses to prune out half the line. The professor
    then mentally revises the bounds, moves to the new midpoint, and repeats the process.
    Thus, the professor can turn the exercise of returning an assignment into a demonstration
    of binary search—while also covering up the fact that they never managed to learn
    the students’ names.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram that represents performing a binary search for value 15 in a sorted
    array, where the lowest value is negative 5 and highest value is 54\. Each of
    five rows, (a) through (e), shows the same array in different stages of the search.
    Portions of the array that have been eliminated are shaded gray; the rest are
    shaded white. ](image_fi/502604c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A binary search for the value 15 over a sorted array'
  prefs: []
  type: TYPE_NORMAL
- en: Absent Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we need to consider what happens if the target value is not in the list
    and how the binary search confirms the value’s absence. In the linear scan case,
    we know that an element is not in the list as soon as we hit the end of the list.
    For binary search, we can conclude that our target item does not exist by testing
    the bounds themselves. As the search progresses, the upper and lower bounds move
    closer and closer until there are no unexplored values between them. Since we
    are always moving one of the bounds *past* the midpoint index, we can stop the
    search when `IndexHigh < IndexLow`. At that point, we can guarantee the target
    value is not in the list. [Figure 2-4](#figure2-4) shows an example search for
    `v = 10` on a sorted array, where `10` does not appear in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram that represents performing a binary search for absent value 10
    in a sorted array where the lowest value is negative 5 and highest value is 54\.
    Each of six rows, (a) through (f), shows the same array in different stages of
    the search.](image_fi/502604c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: A binary search for a value (10) that isn’t in the array'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could theoretically have stopped the search earlier than row (f): once the
    value at our high bound is less than the target value (`IndexHigh = 4`) we know
    that the target can’t be in the array. However, as with our search in [Figure
    2-3](#figure2-3), the algorithm only checks the value at the midpoint against
    the target. It tracks the indices of the high and low bounds, but does not check
    the values at these locations explicitly. While we could add logic to capture
    this case, as well as the corresponding case of the lower bound being greater
    than the target value, we will keep the logic simple for now.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Binary Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can implement a binary search in code with a single `WHILE` loop, as shown
    in [Listing 2-2](#listing2-2). Like the code for linear search in [Listing 2-1](#listing2-1),
    the binary search algorithm returns the index of the target element if it is in
    the array. If there is no matching element in the array, the algorithm returns
    `−1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Implementing binary search with a single loop'
  prefs: []
  type: TYPE_NORMAL
- en: While the high and low indices have not crossed, we continue the search ❶. During
    each iteration, we compute a new midpoint ❷ and check the midpoint value against
    the target. If it’s an exact match, we’ve found our target and can directly return
    the corresponding index. If the value at the midpoint is too small, we adjust
    the lower bounds ❸. If the value is too high, we adjust the upper bounds ❹. If
    `IndexHigh < IndexLow`, the element is not in the array, so we return `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the programming language, we could use approaches other than returning
    `-1` to indicate failure, such as throwing an exception. Regardless of the actual
    mechanism, your code and documentation should always be absolutely clear about
    what happens if the element is not in the array so that callers of the function
    can use it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting Binary Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have considered binary search in the context of lists and arrays—fixed
    sets of discrete items. It is easy to see how we could bring this algorithm into
    the real world by applying it to a shelf of sorted books, names in a telephone
    book, or a clothing rack ordered by size. But we can adapt this same approach
    to continuous data, where we don’t start with a set of individual items or indices,
    as well. Instead, we use high and low bounds on the values themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you aim to craft the perfect cup of coffee. After months of laborious
    research, you’ve confirmed the optimal temperature and quantity of water. Yet
    one mystery remains: What quantity of coffee grounds should you use? Here the
    sources diverge. The Strong Coffee camp recommends a tremendous 5 tablespoons
    of coffee grounds, while the Watery Coffee camp recommends a paltry 0.5 tablespoons.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem of determining your own optimal scoop of coffee grounds lends itself
    perfectly to a binary search, as shown in [Figure 2-5](#figure2-5). We start with
    reasonable upper and lower bounds as illustrated in [Figure 2-5](#figure2-5)(a).
  prefs: []
  type: TYPE_NORMAL
- en: LowerBound = 0 tablespoons The “coffee” was a cup of warm water.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UpperBound = 5 tablespoons The coffee was too strong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The true value must be somewhere in between. Note that our bounds are now the
    values themselves instead of item indices.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing a binary search of between 0 and 5 tablespoons of coffee.
    At each step (a) through (d), we define a new midpoint between a new upper and
    lower bound until we’ve found the optimal midpoint value, 2.](image_fi/502604c02/f02005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: An adapted binary search can be used to search a range of real
    numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: As with a binary search on an array of values, we can define the midpoint at
    2.5 tablespoons and test that ([Figure 2-5](#figure2-5)(b)). Again, 2.5 tablespoons
    is just a value. It doesn’t correspond to an element in an array or item on the
    shelf. We do not have an array of predetermined values, but rather the infinite
    range of all real numbers between 0.0 and 5.0, and any individual measurement
    effectively corresponds to an index into that range.
  prefs: []
  type: TYPE_NORMAL
- en: We find the coffee made from 2.5 tablespoons is a little too strong for our
    taste, allowing us to refine the bounds. Our optimal amount of coffee is now constrained
    to lie between 0 tablespoons and 2.5 tablespoons (c). Our search continues with
    a new midpoint of 1.25 tablespoons, an amount that produces a weak brew. We need
    to refine our lower bound (d).
  prefs: []
  type: TYPE_NORMAL
- en: 'The search for morning bliss continues this way until we’ve sufficiently narrowed
    down our range. Unlike with a discrete array of values, we may never find the
    exact point that satisfies our search. After all, there is an infinite number
    of real values. If our optimal amount of coffee is 2.0 tablespoons, we might try
    values of 2.50, 1.25, 1.875, 2.1875, and 2.03125 before concluding that we are
    close enough. Therefore, we terminate the search when our range is sufficiently
    small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Contrast this search with a linear scan through the options. In the name of
    science, we may resolve to try every possible increment of 0.05 tablespoons until
    we find the optimal brew. After all, this is coffee, and we must be thorough.
    Starting at our low index (0.0 tablespoons—alternately known as a cup of warm
    water), we continually increment the amount by 0.05 and retest. We run through
    0.05, 0.10, 0.15, . . . , 1.00 before we start to get to a reasonable strength.
    We would need many trials to get to the correct point, at least 20 of which would
    be too weak to even to count as coffee. That’s a lot of wasted effort and coffee
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: The use of binary search also allows for better precision. By sampling only
    0.05 increments during our linear scan, we are limited to how close to the target
    value we can get. Binary search keeps homing in on a smaller range until we stop.
    We choose what value of `UpperBound – LowerBound` is sufficient to halt the search,
    allowing us to narrow it down to within 0.0001 tablespoons or closer.
  prefs: []
  type: TYPE_NORMAL
- en: This adaptation of the binary search approach forms the basis of important mathematical
    techniques, such as bisection search. *Bisection search* uses it to find the zero
    of a function, or the value of *x* such that *f*(*x*) = 0\. Instead of evaluating
    whether coffee is too strong or too weak, bisection search tracks bounds where
    the function is above zero and below zero. By repeatedly dividing the interval
    in half at the midpoint, the algorithm zooms in on the value of *x* where the
    function is exactly zero.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intuitively, we can see that binary search is often faster than a linear scan
    of the data. Let’s find out how much faster binary search can be to determine
    whether it’s worth the additional code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the relative speed of the two algorithms depends on the data itself.
    If we are searching for values that always occur at the start of the list, linear
    scan will win. Similarly, binary search might be unnecessary for tiny lists. We
    don’t need to partition a list in half if it has only two elements. We can just
    look at those elements directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We often analyze the runtime of an algorithm in terms of its average and worst-case
    performance as the size of the data *N* grows. Computer scientists often use measures
    such as Big-O notation to more formally capture those concepts. We won’t formally
    analyze algorithms in this book or use Big-O notation, but we will consider the
    same two aspects throughout for each algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: The average-case runtime of an algorithm as the size of the data grows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The worst-case runtime of an algorithm as the size of the data grows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, let’s compare worst-case performance for linear scan and binary search.
    For linear scan, the worst case occurs when the target value is at the end of
    the list or not in the list at all. In these cases, the algorithm has to check
    every single value. If the array has *N* values, it will require *N* comparisons.
    Its worst-case running time is *linear* with the size of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, even the worst-case binary search will discard half the data at
    each step, so the number of comparisons is *logarithmic* with the size of the
    data set. It scales proportional to log[2]*N*, which is the base-2 logarithm of
    *N*. Admittedly there is more work per step: instead of checking a single value,
    we have to move our bounds and compute a new midpoint. However, for large enough
    lists, the benefit of needing only a logarithmic number of comparisons will far
    outweigh additional per-step costs.'
  prefs: []
  type: TYPE_NORMAL
- en: Why This Matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This fixation on binary search in introductory computer science classes isn’t
    the result of binary-search advocacy campaigns, fan clubs, or secret societies
    (although those would all be understandable). Rather, it’s binary search’s simplicity
    that makes it a perfect introductory topic. It is a clean and effective example
    of one of the most fundamental concepts of computational thinking: that designing
    algorithms by using the structure in the problems themselves helps us construct
    efficient solutions. By taking advantage of the sorted nature of the data, we
    are able to cut the worst-case runtime from linear with the number of values to
    logarithmic—a difference that becomes more significant as the data grows.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the book, we will continue to look at the tight relationship
    between problem structure (including within the data) and how we can create efficient
    solutions.
  prefs: []
  type: TYPE_NORMAL
