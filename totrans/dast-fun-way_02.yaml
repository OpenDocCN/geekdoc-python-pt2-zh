- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Binary Search
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Binary search* is an algorithm for efficiently searching a sorted list. It
    checks the sorted list for a target value by repeatedly dividing the list in half,
    determining which of the two halves could contain the target value, and discarding
    the other half. This algorithm’s simplicity of logic and implementation make it
    a perfect introductory topic for computer science, so binary search algorithms
    are nearly universal throughout computer science courses and textbooks.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分查找* 是一种高效查找已排序列表的算法。它通过不断将列表一分为二，确定哪一半可能包含目标值，并丢弃另一半，从而在已排序的列表中查找目标值。这个算法逻辑简单且易于实现，是计算机科学的完美入门主题，因此二分查找算法几乎在所有计算机科学课程和教材中都有介绍。'
- en: The skeptical reader might wonder, “How often will I really need to search a
    sorted list?” or, more accurately, “How often will I need to implement a function
    to search my sorted list? Haven’t a few million people done this? Isn’t it in
    a library somewhere?” While you shouldn’t reject the possibility of one day needing
    to implement your own binary search, its true importance goes well beyond its
    implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 怀疑的读者可能会想，“我到底有多大概率需要查找一个已排序的列表？”或者更准确地说，“我有多大可能需要实现一个查找已排序列表的函数？难道几百万个人没做过这个吗？不是已经有现成的库了吗？”虽然你不应该排除某天需要自己实现二分查找的可能性，但它真正的重要性远超其实现。
- en: Binary search illustrates how clever algorithms can use the structure in which
    data is stored to achieve significant computational savings, even when this structure
    is as simple as sorted data. Binary search is easily analyzed for correctness
    and efficiency, provides guarantees of both speed and correctness, and demonstrates
    the fundamental interaction between data and algorithms. It’s an excellent lens
    with which to examine difference in data storage techniques, such as the difference
    between linked lists and arrays, or the motivation behind many tree-based algorithms.
    It can even be used to create a better cup of coffee.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找展示了聪明的算法如何利用数据存储的结构来实现显著的计算节省，即使这种结构简单到只有已排序的数据。二分查找的正确性和效率都容易分析，提供了速度和正确性的保证，并展示了数据和算法之间的基本交互。它是检视数据存储技术差异的一个极好视角，比如链表和数组的区别，或许多基于树的算法背后的动机。它甚至可以用来制作一杯更好的咖啡。
- en: The Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Before defining any new algorithm, we must define the problem the algorithm
    will try to solve. In this chapter, our aim is to find a single item in a list
    that matches the given target value; we need an algorithm that can efficiently
    perform such a search. Formally we can define this search as:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义任何新算法之前，我们必须定义算法要解决的问题。在本章中，我们的目标是找到一个列表中的单个项，匹配给定的目标值；我们需要一个可以高效执行这种搜索的算法。我们可以正式地将这个搜索定义为：
- en: Given a set of *N* data points *X* = {*x*[*1*]*, x*[*2*]*,* . . . *, x*[*N*]}
    and a target value *x*', find a point *x*[*i*]∈ *X* such that *x*'= *x*[*i*],
    or indicate that no such point exists.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一组数据点 *N*，*X* = {*x*[*1*]*, x*[*2*]*, ... , x*[*N*]} 和一个目标值 *x*'，找到一个点 *x*[*i*]∈
    *X* 使得 *x*' = *x*[*i*]，或者指出不存在这样的点。
- en: In our everyday lives, we would likely describe the task as “Find me this particular
    thing.” This search problem is one that we all face numerous times a day. We might
    be hunting for a word in a dictionary, a name in our contacts list, a specific
    date in a list of historical of events, or our preferred brand of coffee in a
    densely packed supermarket shelf. All we need is a list of candidates and a way
    to check whether we’ve found a match.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们日常生活中，我们可能会将这个任务描述为“找到这个特定的东西”。这个搜索问题是我们每天都会遇到的。我们可能在字典中找一个词，在联系人列表中找一个名字，在历史事件列表中找一个特定的日期，或者在拥挤的超市货架上找我们喜欢的咖啡品牌。我们所需要的只是候选列表和一种检查我们是否找到匹配项的方法。
- en: Linear Scan
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性扫描
- en: To appreciate the advantages of binary search, we start with a simpler algorithm,
    *linear scan*, to provide a baseline for comparison. Linear scan searches for
    a target value by testing each value in our list, one after the other, against
    the target value, until the target is found or we reach the end of our list. This
    is how the author normally searches supermarket shelves—running his finger along
    the brightly colored packages of coffee, one by one, while mumbling to himself
    about the need for better indexing schemes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解二分查找的优势，我们首先从一个更简单的算法——*线性扫描*开始，以提供一个比较基准。线性扫描通过逐个检查列表中的每个值是否与目标值匹配，直到找到目标值或遍历完整个列表为止。这就像作者在超市货架上寻找商品的方式——一边沿着五光十色的咖啡包装逐个用手指滑过，一边自言自语地抱怨需要更好的索引方案。
- en: Imagine that we are looking to find the target value in an array `A` of numbers.
    In this case, let’s use `target = 21`. We iterate through each bin in the array
    and check whether that value equals 21, as illustrated in [Figure 2-1](#figure2-1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在查找数组`A`中的目标值。这里我们设定`target = 21`。我们依次遍历数组中的每个元素，并检查它是否等于21，如[图 2-1](#figure2-1)所示。
- en: '[Listing 2-1](#listing2-1) shows the code for linear scan. The code returns
    the index of the matching element if one is found and returns an index of `-1`
    if the search fails and the item is not in our array.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](#listing2-1)显示了线性扫描的代码。如果找到了匹配的元素，代码会返回该元素的索引；如果搜索失败，说明该元素不在数组中，代码将返回索引`-1`。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: The code for linear scan'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-1：线性扫描的代码
- en: '![A diagram showing how to perform a linear scan on an array of 11 unsorted
    bins containing numbers. We check whether the value of the first bin is 21; it
    isn’t, so we check the next bin and so on until we find a match.](image_fi/502604c02/f02001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个图示，展示如何对包含11个无序数字的数组进行线性扫描。我们检查第一个元素是否等于21；如果不是，就检查下一个元素，依此类推，直到找到匹配项。](image_fi/502604c02/f02001.png)'
- en: 'Figure 2-1: A linear scan over an array of integers'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：对整数数组进行线性扫描
- en: A single `WHILE` loop iterates over each element of the array, and the internal
    `IF` statement compares that element to the target. As soon as we come across
    an element matching the target, we return the corresponding index. If we make
    it to the end of the array, we return `-1`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的`WHILE`循环遍历数组中的每个元素，内部的`IF`语句将该元素与目标值进行比较。只要找到与目标匹配的元素，就返回相应的索引。如果遍历到数组末尾还没有找到匹配项，则返回`-1`。
- en: Linear scan isn’t fancy or clever. It’s a *brute-force* test guaranteed to find
    the item of interest (if the item is in the data) because it checks every possible
    item until it finds a match or confirms the item is missing. This is thorough
    but inefficient, especially for large lists. If we know nothing about the structure
    of the data in `A`, there is nothing we can do to streamline the process. The
    target value could be in any bin, so we may need to check them all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 线性扫描既不华丽也不聪明。它是一个*蛮力*测试，能够确保找到感兴趣的项目（如果该项目在数据中存在），因为它会检查每个可能的元素，直到找到匹配项或确认该项不存在。这种方法虽彻底，但效率低，尤其对于大型列表而言。如果我们对`A`中的数据结构一无所知，就无法通过任何方式优化该过程。目标值可能在任何一个位置，所以我们可能需要检查所有的元素。
- en: To illustrate linear scan’s limitations, imagine performing such a scan on a
    physical row of items, like a line of introductory computer science students standing
    outside a classroom. The teacher, looking to return a specific student’s assignment,
    walks down the line asking each student “Is your name Jeremy?” before potentially
    moving onto the next. The search stops when the teacher finds the correct student
    or makes it to the end of the line. The students (correctly) roll their eyes and
    mutter about their inefficient instructor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明线性扫描的局限性，假设我们正在对一排物理排列的物品进行扫描，比如一排站在教室外面的计算机科学入门学生。老师想要将某个学生的作业还给他，于是走到每个学生面前，询问“你的名字是Jeremy吗？”，然后可能会继续询问下一个学生。搜索在老师找到正确的学生或走到队伍末尾时结束。学生们（正确地）翻了翻白眼，低声抱怨他们低效的老师。
- en: Sometimes there are ways to make linear search faster *per comparison*. For
    example, we might optimize the comparison time for more complex data by stopping
    at the first mismatched letter when comparing strings, as described in Chapter
    1. Likewise, in the supermarket case, we could consume massive amounts of coffee
    ahead of time, so our shaky finger zips faster along the shelf. However, this
    only helps to a point. We are still limited to checking every item, one by one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可以通过*每次比较*使线性搜索更快。例如，我们可以通过在比较字符串时在第一个不匹配的字母处停止来优化比较时间，如第1章所述。同样，在超市的情况中，我们可以提前消耗大量咖啡，这样我们的指尖在货架上滑动得更快。然而，这种方法只有在某些程度上才有效。我们仍然限制于逐一检查每个物品。
- en: In the next section, we’ll see how a small amount of structure in the data changes
    everything.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看到数据中少量结构如何改变一切。
- en: Binary Search Algorithm
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找算法
- en: Binary search is an algorithm to find a target value *v* in a *sorted* list
    and only works on sorted data. The algorithm can be written to work with data
    sorted in either increasing or decreasing order, but, for now, let’s consider
    the case of data sorted in increasing order—lowest to highest. The algorithm operates
    by partitioning the list in half and determining in which half *v* must reside.
    It then discards the half that *v* is not in and repeats the process with only
    the half that can possibly still contain *v* until only one value remains. For
    example, if we were searching the sorted list in [Figure 2-2](#figure2-2) for
    the value 7, we would find 5 at the midpoint and could rule out the first half
    of the list. Anything before the middle element cannot be greater than 5, and,
    since 5 is less than 7, everything before 5 is also less than 7.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找是一种在*已排序*列表中查找目标值*v*的算法，仅适用于已排序的数据。该算法可以写成适用于按递增或递减顺序排序的数据，但现在我们假设数据是按递增顺序排序的——从最低到最高。该算法通过将列表分成两半，并确定*v*必须位于哪一半来进行操作。然后它会丢弃*v*不在的那一半，并仅对可能仍包含*v*的那一半重复此过程，直到只剩下一个值。例如，如果我们在[图2-2](#figure2-2)所示的排序列表中查找值7，我们会在中点找到5，并排除列表的前半部分。中点前的任何元素不可能大于5，而由于5小于7，5之前的所有元素也都小于7。
- en: '![A sorted list of integers from 1 to 9\. An arrow points to the midpoint with
    value 5.](image_fi/502604c02/f02002.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![一份从1到9的整数的排序列表。箭头指向值为5的中点。](image_fi/502604c02/f02002.png)'
- en: 'Figure 2-2: A sorted list of integers from 1 to 9, where 5 is the midpoint'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2：从1到9的排序整数列表，其中5是中点
- en: 'The key to efficient algorithms is using information or structure within the
    data. In the case of binary search, we use the fact that the array is sorted in
    increasing order. More formally, consider a sorted array `A`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 高效算法的关键在于利用数据中的信息或结构。对于二分查找，我们利用数组按递增顺序排序这一事实。更正式地说，考虑一个已排序的数组`A`：
- en: '*A*[*i*] ≤ *A*[*j*] for any pair of indexes *i* and *j* such that *i* < *j*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*[*i*] ≤ *A*[*j*] 对于任何索引对*i* 和 *j*，其中 *i* < *j*'
- en: While this might not seem like a lot of information, it’s enough to allow us
    to rule out entire sections of the array. It’s similar to the logic we use to
    avoid the ice cream aisle when searching for coffee. Once we know an item won’t
    be in a given area, we can rule out that entire set of items in that area without
    individually checking them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来似乎信息不多，但足以让我们排除数组的整个部分。这类似于我们在寻找咖啡时避免走冰激凌通道的逻辑。一旦我们知道某个物品不在某个区域，我们就可以排除该区域内的所有物品，而不需要逐一检查它们。
- en: 'Binary search tracks the current search space with two bounds: the upper bound
    `IndexHigh` marks the highest index of the array that is part of the active search
    space, and the lower bound `IndexLow` marks the lowest. Throughout the algorithm,
    if the target value is in the array, we guarantee the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找通过两个边界跟踪当前的查找空间：上边界`IndexHigh`标记数组中活跃查找空间的最高索引，下边界`IndexLow`标记最低索引。在整个算法过程中，如果目标值在数组中，我们可以保证以下几点：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Binary search starts each iteration by choosing the midpoint of the current
    search space:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找在每次迭代时，首先选择当前查找空间的中点：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'where `Floor` is a mathematical function that rounds a number down to an integer.
    We then compare the value at the middle location, `A[IndexMid]`, with the target
    value `v`. If the middle point is less than the target value, `A[IndexMid] < v`,
    we know the target value must lie after the middle index. This allows us to chop
    the search space in half by making `IndexLow = IndexMid + 1`. Alternately, if
    the middle point is greater than the target value, `A[IndexMid] > v`, we know
    the target value must lie before the middle index, which allows us to chop the
    search space in half by making `IndexHigh = IndexMid – 1`. Of course, if we find
    `A[IndexMid] == v`, we immediately conclude the search: we’ve found the target.
    Boisterous celebration is optional.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`Floor` 是一个数学函数，用来将数字向下舍入到整数。然后，我们将中间位置的值 `A[IndexMid]` 与目标值 `v` 进行比较。如果中点小于目标值，即
    `A[IndexMid] < v`，我们知道目标值一定在中间索引之后。这样，我们可以通过设置 `IndexLow = IndexMid + 1` 来将搜索空间缩小一半。或者，如果中点大于目标值，即
    `A[IndexMid] > v`，我们知道目标值一定在中间索引之前，这样我们可以通过设置 `IndexHigh = IndexMid - 1` 来将搜索空间缩小一半。当然，如果我们发现
    `A[IndexMid] == v`，我们就立刻结束搜索：我们找到了目标。热烈的庆祝活动可以自行决定。
- en: 'Each row in [Figure 2-3](#figure2-3) represents a step in the binary search
    process on a sorted array. We’re searching the array at row (a) for the value
    `15`. At the start, our search bounds include the entire array: `IndexLow = 0`
    and `IndexHigh = 11`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#figure2-3) 中的每一行都代表了在一个已排序数组上执行二分查找过程的一步。我们正在查找行 (a) 中的数组，目标值是 `15`。在开始时，我们的搜索范围包括整个数组：`IndexLow
    = 0` 和 `IndexHigh = 11`。'
- en: 'In row (b), we compute the midpoint (rounding down) to be `IndexMid = 5`. Comparing
    the midpoint’s value to the target value, we see that `A[5] = 11`, which is less
    than our target value of 15\. Therefore, in row (c), we rule out every element
    in the array up to and including index `5`—that is, all the shaded elements—by
    adjusting the lower bounds: `IndexLow = 6`. We’ve eliminated almost half our search
    space with a single comparison! The algorithm repeats this process on the remaining
    range, computing the new midpoint as `IndexMid = 8`, comparing to the target value
    (`A[8] = 30`, which is greater than `v = 15`), and refining our bounds to `IndexHigh
    = 7`. In row (d), we once again eliminate half of the remaining search in the
    same way. In row (e), we again compute the midpoint as `IndexMid = 6` and compare
    it to the target value (`A[6] == v`). We’ve found the target!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 (b) 中，我们计算中点（向下舍入）为 `IndexMid = 5`。将中点的值与目标值进行比较，我们看到 `A[5] = 11`，小于目标值 `15`。因此，在行
    (c) 中，我们通过调整下限 `IndexLow = 6`，排除了数组中所有索引为 5 及之前的元素——即所有阴影部分——从而消除了几乎一半的搜索空间！该算法在剩余范围内重复此过程，计算新的中点为
    `IndexMid = 8`，并与目标值进行比较（`A[8] = 30`，大于 `v = 15`），将范围调整为 `IndexHigh = 7`。在行 (d)
    中，我们再次以相同的方式排除剩余搜索空间的一半。在行 (e) 中，我们再次计算中点为 `IndexMid = 6` 并与目标值进行比较（`A[6] == v`）。我们找到了目标！
- en: Note that even though the lower bound’s index pointed to the target value (`v
    = 15`) for several iterations, we continued the search until the *midpoint* pointed
    to the target value. This is because our search checks only the value at the midpoint
    against the target and not the values at the lower or upper indexes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管下限的索引在几次迭代中指向了目标值 (`v = 15`)，我们仍然继续搜索，直到*中点*指向目标值。这是因为我们的搜索只检查中点的值与目标的匹配情况，而不是检查下限或上限索引的值。
- en: Returning to our line of introductory computer science students, we can imagine
    that by the end of the semester, the teacher asks the students to line up in alphabetical
    order. The teacher then starts a binary search by asking the middle student “What
    is your name?” and uses the responses to prune out half the line. The professor
    then mentally revises the bounds, moves to the new midpoint, and repeats the process.
    Thus, the professor can turn the exercise of returning an assignment into a demonstration
    of binary search—while also covering up the fact that they never managed to learn
    the students’ names.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们刚才提到的计算机科学入门课程的学生，我们可以想象，在学期结束时，老师要求学生按字母顺序排队。然后，老师通过询问中间的学生“你的名字是什么？”来进行二分查找，并利用学生的回答将队列的一半剔除。教授随后在脑海中修正范围，移动到新的中点，并重复这个过程。这样，教授就能将布置作业的过程转变为二分查找的演示——同时掩盖了他从未真正记住学生名字的事实。
- en: '![A diagram that represents performing a binary search for value 15 in a sorted
    array, where the lowest value is negative 5 and highest value is 54\. Each of
    five rows, (a) through (e), shows the same array in different stages of the search.
    Portions of the array that have been eliminated are shaded gray; the rest are
    shaded white. ](image_fi/502604c02/f02003.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![这张图展示了在一个排序数组中执行二分查找寻找值15的过程，其中数组的最小值为-5，最大值为54。每一行（从a到e）展示了搜索过程中的不同阶段。已被排除的数组部分被阴影标记，剩余的部分则标记为白色。](image_fi/502604c02/f02003.png)'
- en: 'Figure 2-3: A binary search for the value 15 over a sorted array'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：在排序数组中执行值15的二分查找
- en: Absent Values
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺失值
- en: Next, we need to consider what happens if the target value is not in the list
    and how the binary search confirms the value’s absence. In the linear scan case,
    we know that an element is not in the list as soon as we hit the end of the list.
    For binary search, we can conclude that our target item does not exist by testing
    the bounds themselves. As the search progresses, the upper and lower bounds move
    closer and closer until there are no unexplored values between them. Since we
    are always moving one of the bounds *past* the midpoint index, we can stop the
    search when `IndexHigh < IndexLow`. At that point, we can guarantee the target
    value is not in the list. [Figure 2-4](#figure2-4) shows an example search for
    `v = 10` on a sorted array, where `10` does not appear in the array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要考虑如果目标值不在列表中会发生什么，并且二分查找如何确认值的缺失。在线性扫描的情况下，一旦到达列表的末尾，我们就知道某个元素不在列表中。对于二分查找，我们可以通过测试边界来得出目标元素不存在的结论。随着搜索的进行，左右边界会越来越接近，直到它们之间没有未探索的值为止。由于我们总是将其中一个边界*超越*中点索引，当`IndexHigh
    < IndexLow`时，我们可以停止搜索。此时，我们可以确保目标值不在列表中。[图2-4](#figure2-4)展示了在排序数组中查找`v = 10`的示例搜索，其中`10`在数组中不存在。
- en: '![A diagram that represents performing a binary search for absent value 10
    in a sorted array where the lowest value is negative 5 and highest value is 54\.
    Each of six rows, (a) through (f), shows the same array in different stages of
    the search.](image_fi/502604c02/f02004.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![这张图展示了在一个排序数组中执行二分查找寻找缺失的值10的过程，其中数组的最小值为-5，最大值为54。每一行（从a到f）展示了搜索过程中的不同阶段。](image_fi/502604c02/f02004.png)'
- en: 'Figure 2-4: A binary search for a value (10) that isn’t in the array'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：在数组中进行二分查找以查找值（10），但该值不存在
- en: 'We could theoretically have stopped the search earlier than row (f): once the
    value at our high bound is less than the target value (`IndexHigh = 4`) we know
    that the target can’t be in the array. However, as with our search in [Figure
    2-3](#figure2-3), the algorithm only checks the value at the midpoint against
    the target. It tracks the indices of the high and low bounds, but does not check
    the values at these locations explicitly. While we could add logic to capture
    this case, as well as the corresponding case of the lower bound being greater
    than the target value, we will keep the logic simple for now.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以比第(f)行更早地停止搜索：一旦我们的高边界的值小于目标值（`IndexHigh = 4`），我们就知道目标值不可能在数组中。然而，正如我们在[图2-3](#figure2-3)中的搜索一样，算法只会检查中点位置的值与目标值是否匹配。它跟踪高低边界的索引，但并没有显式地检查这些位置的值。尽管我们可以添加逻辑来捕获这种情况，以及下边界大于目标值的情况，但目前我们会保持逻辑的简洁。
- en: Implementing Binary Search
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现二分查找
- en: We can implement a binary search in code with a single `WHILE` loop, as shown
    in [Listing 2-2](#listing2-2). Like the code for linear search in [Listing 2-1](#listing2-1),
    the binary search algorithm returns the index of the target element if it is in
    the array. If there is no matching element in the array, the algorithm returns
    `−1`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个简单的`WHILE`循环来实现二分查找，如[清单2-2](#listing2-2)所示。与[清单2-1](#listing2-1)中的线性查找代码类似，二分查找算法如果目标元素存在于数组中，则返回该元素的索引。如果数组中没有匹配的元素，算法返回`−1`。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-2: Implementing binary search with a single loop'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-2：通过单个循环实现二分查找
- en: While the high and low indices have not crossed, we continue the search ❶. During
    each iteration, we compute a new midpoint ❷ and check the midpoint value against
    the target. If it’s an exact match, we’ve found our target and can directly return
    the corresponding index. If the value at the midpoint is too small, we adjust
    the lower bounds ❸. If the value is too high, we adjust the upper bounds ❹. If
    `IndexHigh < IndexLow`, the element is not in the array, so we return `-1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在高低索引尚未交叉时，我们继续搜索❶。在每次迭代中，我们计算一个新的中点❷，并将中点值与目标值进行比较。如果完全匹配，我们就找到了目标，可以直接返回对应的索引。如果中点的值太小，我们会调整下界❸。如果值太大，我们会调整上界❹。如果`IndexHigh
    < IndexLow`，说明元素不在数组中，因此返回`-1`。
- en: Depending on the programming language, we could use approaches other than returning
    `-1` to indicate failure, such as throwing an exception. Regardless of the actual
    mechanism, your code and documentation should always be absolutely clear about
    what happens if the element is not in the array so that callers of the function
    can use it correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编程语言的不同，我们可以使用除返回`-1`以外的其他方式来表示失败，例如抛出异常。无论实际机制如何，你的代码和文档应该始终清楚地说明如果元素不在数组中会发生什么，以便函数的调用者能够正确使用它。
- en: Adapting Binary Search
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找的应用
- en: So far, we have considered binary search in the context of lists and arrays—fixed
    sets of discrete items. It is easy to see how we could bring this algorithm into
    the real world by applying it to a shelf of sorted books, names in a telephone
    book, or a clothing rack ordered by size. But we can adapt this same approach
    to continuous data, where we don’t start with a set of individual items or indices,
    as well. Instead, we use high and low bounds on the values themselves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在列表和数组的背景下考虑了二分查找——即一组固定的离散项。很容易看出，我们可以通过将这个算法应用于排序的书架、电话簿中的名字或按尺码排序的衣架，将其引入到现实世界中。但我们也可以将这一方法应用于连续数据，在这种情况下，我们不再从一组独立的项或索引开始，而是直接使用值本身的上下界。
- en: 'Imagine you aim to craft the perfect cup of coffee. After months of laborious
    research, you’ve confirmed the optimal temperature and quantity of water. Yet
    one mystery remains: What quantity of coffee grounds should you use? Here the
    sources diverge. The Strong Coffee camp recommends a tremendous 5 tablespoons
    of coffee grounds, while the Watery Coffee camp recommends a paltry 0.5 tablespoons.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你打算调制一杯完美的咖啡。在经过数月艰苦的研究后，你已经确认了最佳的温度和水量。然而，还有一个谜团未解：应该使用多少咖啡粉？此时，各方意见不一。强咖啡派建议使用大量的5汤匙咖啡粉，而清淡咖啡派则建议使用仅0.5汤匙的咖啡粉。
- en: The problem of determining your own optimal scoop of coffee grounds lends itself
    perfectly to a binary search, as shown in [Figure 2-5](#figure2-5). We start with
    reasonable upper and lower bounds as illustrated in [Figure 2-5](#figure2-5)(a).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确定自己理想的咖啡粉量问题非常适合使用二分查找，如[图2-5](#figure2-5)所示。我们从合理的上下界开始，如[图2-5](#figure2-5)(a)所示。
- en: LowerBound = 0 tablespoons The “coffee” was a cup of warm water.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LowerBound = 0汤匙 咖啡是杯温水。
- en: UpperBound = 5 tablespoons The coffee was too strong.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UpperBound = 5汤匙 咖啡太浓了。
- en: The true value must be somewhere in between. Note that our bounds are now the
    values themselves instead of item indices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的理想值必定介于两者之间。注意，现在我们的界限是这些值本身，而不是物品的索引。
- en: '![A diagram showing a binary search of between 0 and 5 tablespoons of coffee.
    At each step (a) through (d), we define a new midpoint between a new upper and
    lower bound until we’ve found the optimal midpoint value, 2.](image_fi/502604c02/f02005.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![一个显示在0到5汤匙咖啡之间进行二分查找的示意图。在每一步（a）到（d）中，我们定义新的中点，直到找到理想的中点值，2。](image_fi/502604c02/f02005.png)'
- en: 'Figure 2-5: An adapted binary search can be used to search a range of real
    numbers.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：一种改进的二分查找方法可以用来搜索实数范围。
- en: As with a binary search on an array of values, we can define the midpoint at
    2.5 tablespoons and test that ([Figure 2-5](#figure2-5)(b)). Again, 2.5 tablespoons
    is just a value. It doesn’t correspond to an element in an array or item on the
    shelf. We do not have an array of predetermined values, but rather the infinite
    range of all real numbers between 0.0 and 5.0, and any individual measurement
    effectively corresponds to an index into that range.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与在数组中进行二分查找类似，我们可以定义中点为2.5汤匙，并进行测试（[图2-5](#figure2-5)(b)）。同样，2.5汤匙只是一个值，它并不对应数组中的一个元素或架子上的一件物品。我们没有一个预设的值数组，而是一个从0.0到5.0的所有实数的无限范围，每个独立的测量实际上对应着该范围中的一个索引。
- en: We find the coffee made from 2.5 tablespoons is a little too strong for our
    taste, allowing us to refine the bounds. Our optimal amount of coffee is now constrained
    to lie between 0 tablespoons and 2.5 tablespoons (c). Our search continues with
    a new midpoint of 1.25 tablespoons, an amount that produces a weak brew. We need
    to refine our lower bound (d).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现用2.5汤匙做的咖啡对我们的口味来说稍微有点太浓，这让我们能够进一步精确边界。我们的最佳咖啡量现在被限定在0汤匙和2.5汤匙之间（c）。我们的搜索继续，新的中点是1.25汤匙，这个量的咖啡口感较淡。我们需要进一步缩小下限（d）。
- en: 'The search for morning bliss continues this way until we’ve sufficiently narrowed
    down our range. Unlike with a discrete array of values, we may never find the
    exact point that satisfies our search. After all, there is an infinite number
    of real values. If our optimal amount of coffee is 2.0 tablespoons, we might try
    values of 2.50, 1.25, 1.875, 2.1875, and 2.03125 before concluding that we are
    close enough. Therefore, we terminate the search when our range is sufficiently
    small:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 早晨的快乐就这样在不断的搜索中继续，直到我们足够精确地缩小了范围。与离散的数值数组不同，我们可能永远找不到完全满足条件的精确点。毕竟，实数值是无限的。如果我们的最佳咖啡量是2.0汤匙，我们可能会尝试2.50、1.25、1.875、2.1875和2.03125等值，然后才会得出我们已经足够接近的结论。因此，当我们的范围足够小的时候，我们就停止搜索：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Contrast this search with a linear scan through the options. In the name of
    science, we may resolve to try every possible increment of 0.05 tablespoons until
    we find the optimal brew. After all, this is coffee, and we must be thorough.
    Starting at our low index (0.0 tablespoons—alternately known as a cup of warm
    water), we continually increment the amount by 0.05 and retest. We run through
    0.05, 0.10, 0.15, . . . , 1.00 before we start to get to a reasonable strength.
    We would need many trials to get to the correct point, at least 20 of which would
    be too weak to even to count as coffee. That’s a lot of wasted effort and coffee
    beans.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种搜索与选项的线性扫描进行对比。为了科学，我们可能决定尝试每一个可能的0.05汤匙增量，直到找到最优的冲泡量。毕竟，这可是咖啡，我们必须彻底检查。从低索引（0.0汤匙——也叫一杯温水）开始，我们不断增加0.05并重新测试。我们依次测试0.05、0.10、0.15，...，1.00，才开始接近合理的浓度。为了找到正确的量，我们需要做很多次尝试，其中至少20次的量太淡，甚至不能算作咖啡。这将浪费大量精力和咖啡豆。
- en: The use of binary search also allows for better precision. By sampling only
    0.05 increments during our linear scan, we are limited to how close to the target
    value we can get. Binary search keeps homing in on a smaller range until we stop.
    We choose what value of `UpperBound – LowerBound` is sufficient to halt the search,
    allowing us to narrow it down to within 0.0001 tablespoons or closer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二分查找还可以提高精度。通过在我们的线性扫描过程中仅采样0.05的增量，我们只能限制在目标值附近的精度。二分查找会不断缩小范围，直到停止。我们选择`UpperBound
    – LowerBound`的值足以停止搜索，从而将结果缩小到0.0001汤匙或更小的范围。
- en: This adaptation of the binary search approach forms the basis of important mathematical
    techniques, such as bisection search. *Bisection search* uses it to find the zero
    of a function, or the value of *x* such that *f*(*x*) = 0\. Instead of evaluating
    whether coffee is too strong or too weak, bisection search tracks bounds where
    the function is above zero and below zero. By repeatedly dividing the interval
    in half at the midpoint, the algorithm zooms in on the value of *x* where the
    function is exactly zero.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种二分查找方法的变体构成了重要数学技术的基础，例如二分搜索。*二分搜索*用于找到一个函数的零点，或者找到* x *使得 *f*（*x*）= 0。二分搜索不是评估咖啡是否过强或过弱，而是追踪函数在零值以上和零值以下的区间。通过不断地将区间在中点处分割，算法能够精确地找到使得函数值为零的*
    x *。
- en: Runtime
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时
- en: Intuitively, we can see that binary search is often faster than a linear scan
    of the data. Let’s find out how much faster binary search can be to determine
    whether it’s worth the additional code complexity.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地看，我们可以发现二分查找通常比线性扫描数据要快。让我们来看看二分查找到底快多少，看看它是否值得增加额外的代码复杂度。
- en: Of course, the relative speed of the two algorithms depends on the data itself.
    If we are searching for values that always occur at the start of the list, linear
    scan will win. Similarly, binary search might be unnecessary for tiny lists. We
    don’t need to partition a list in half if it has only two elements. We can just
    look at those elements directly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这两种算法的相对速度取决于数据本身。如果我们正在查找的值总是出现在列表的开头，线性扫描会更快。同样，对于小列表来说，二分查找可能没有必要。如果列表只有两个元素，我们不需要把它分成两半，只需直接查看这两个元素即可。
- en: 'We often analyze the runtime of an algorithm in terms of its average and worst-case
    performance as the size of the data *N* grows. Computer scientists often use measures
    such as Big-O notation to more formally capture those concepts. We won’t formally
    analyze algorithms in this book or use Big-O notation, but we will consider the
    same two aspects throughout for each algorithm:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常根据数据大小*N*的增长，分析算法的平均性能和最坏情况性能。计算机科学家通常使用像大O表示法这样的度量方法来更正式地捕捉这些概念。尽管我们在本书中不会正式分析算法或使用大O表示法，但我们会在每个算法中考虑以下两个方面：
- en: The average-case runtime of an algorithm as the size of the data grows
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着数据规模增长，算法的平均运行时间
- en: The worst-case runtime of an algorithm as the size of the data grows
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着数据规模增长，算法的最坏情况运行时间
- en: For now, let’s compare worst-case performance for linear scan and binary search.
    For linear scan, the worst case occurs when the target value is at the end of
    the list or not in the list at all. In these cases, the algorithm has to check
    every single value. If the array has *N* values, it will require *N* comparisons.
    Its worst-case running time is *linear* with the size of the data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较线性扫描和二分查找的最坏情况性能。对于线性扫描，最坏情况发生在目标值位于列表末尾或根本不在列表中。在这些情况下，算法必须检查每一个值。如果数组有*N*个值，它将需要*N*次比较。它的最坏情况运行时间与数据大小呈*线性*关系。
- en: 'In contrast, even the worst-case binary search will discard half the data at
    each step, so the number of comparisons is *logarithmic* with the size of the
    data set. It scales proportional to log[2]*N*, which is the base-2 logarithm of
    *N*. Admittedly there is more work per step: instead of checking a single value,
    we have to move our bounds and compute a new midpoint. However, for large enough
    lists, the benefit of needing only a logarithmic number of comparisons will far
    outweigh additional per-step costs.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，即使是最坏情况的二分查找也会在每一步丢弃一半的数据，因此比较次数与数据集的大小呈*对数*关系。它的规模与log[2]*N*成正比，其中*N*是以2为底的对数。诚然，每一步的工作量更多：我们不仅要检查一个值，还必须移动边界并计算新的中点。然而，对于足够大的列表，仅需对数级别的比较次数的优势将远远超过每步的额外开销。
- en: Why This Matters
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: 'This fixation on binary search in introductory computer science classes isn’t
    the result of binary-search advocacy campaigns, fan clubs, or secret societies
    (although those would all be understandable). Rather, it’s binary search’s simplicity
    that makes it a perfect introductory topic. It is a clean and effective example
    of one of the most fundamental concepts of computational thinking: that designing
    algorithms by using the structure in the problems themselves helps us construct
    efficient solutions. By taking advantage of the sorted nature of the data, we
    are able to cut the worst-case runtime from linear with the number of values to
    logarithmic—a difference that becomes more significant as the data grows.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学入门课程中对二分查找的过度关注，并不是二分查找倡导运动、粉丝俱乐部或秘密社团的结果（虽然这些也都能理解）。相反，正是二分查找的简单性使其成为一个完美的入门话题。它是计算思维最基本概念之一的清晰且有效的示例：通过利用问题本身中的结构设计算法，帮助我们构建高效的解决方案。通过利用数据的排序特性，我们能够将最坏情况的运行时间从与值的数量成线性关系减少到对数级别——随着数据增长，这一差异变得更加显著。
- en: Throughout the rest of the book, we will continue to look at the tight relationship
    between problem structure (including within the data) and how we can create efficient
    solutions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将继续关注问题结构（包括数据中的结构）与如何创建高效解决方案之间的紧密关系。
