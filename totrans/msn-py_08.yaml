- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: REPAIRING THE SPACE STATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**修复太空站**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'While wandering around the space station, you must have noticed that some things
    don’t look quite right. To get the program up and running quickly, we used the
    EXPLORER section to display the rooms. However, it has a few drawbacks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在太空站四处游荡时，你一定注意到一些东西看起来不太对劲。为了让程序快速运行，我们使用了EXPLORER部分来显示房间。然而，它也有一些缺点：
- en: Sometimes a blank space is shown beneath the scenery because there’s no floor
    there.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时景物下方会显示一个空白空间，因为那里没有地板。
- en: When you walk to the front of the room, the front wall hides the astronaut.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你走到房间前面时，前墙会遮挡住宇航员。
- en: The astronaut’s legs disappear when walking to the back of the screen.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你走到屏幕背面时，宇航员的腿会消失。
- en: The rooms are all drawn in the top left of the game window. This makes it look
    uneven and inconsistent, because there’s much more space on the right of the rooms
    than on the left, and wider rooms leave less space on the right than narrow rooms
    do.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有房间都绘制在游戏窗口的左上角。这使得它看起来不均匀且不一致，因为房间的右侧空间远大于左侧，而且较宽的房间在右侧留下的空间比狭窄房间少。
- en: There are no shadows, making it harder to understand the position of objects
    in the room.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有阴影，这使得很难理解房间内物体的位置。
- en: In this chapter, we’ll fix these glitches and also add a function for displaying
    messages at the top of the window. These messages will give players information
    about the space station and their progress in the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将修复这些故障，并且还会添加一个用于显示窗口顶部信息的函数。这些信息将向玩家提供有关太空站及其在游戏中的进展情况。
- en: As you read through the chapter, you’ll learn how to send information to a Python
    function and discover how to draw rectangles using Pygame Zero. By the end of
    the chapter, the space station will look great!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这一章时，你将学习如何将信息传递给Python函数，并了解如何使用Pygame Zero绘制矩形。到本章结束时，太空站将看起来很棒！
- en: '**SENDING INFORMATION TO A FUNCTION**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将信息发送到函数**'
- en: 'For the first time, we’ll need to send information to a function. You’ve already
    seen how to send information to the print() function by putting it between the
    parentheses. For example, you can output a message like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首次，我们需要将信息发送到一个函数。你已经看到过如何将信息放在括号中传递给print()函数。例如，你可以像这样输出一条消息：
- en: print("Learn your emergency evacuation drill")
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: print("学习你的紧急疏散演习")
- en: When that instruction runs, the print() function receives information you put
    in the brackets, and displays it in the command line window or the Python shell.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当该指令运行时，print()函数会接收你放在括号中的信息，并在命令行窗口或Python shell中显示出来。
- en: We can also send information to functions we’ve made.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将信息传递给我们创建的函数。
- en: '**CREATING A FUNCTION THAT RECEIVES INFORMATION**'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**创建一个接收信息的函数**'
- en: To experiment with functions, we’ll build a function that adds two numbers that
    we send it. Click **File** ▸ **New** to open a new window, and enter the program
    in [Listing 8-1](ch08.xhtml#ch08list1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验函数，我们将构建一个可以将两个数字相加的函数。点击**文件** ▸ **新建**以打开一个新窗口，并在[清单8-1](ch08.xhtml#ch08list1)中输入程序。
- en: '*listing8-1.py*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-1.py*'
- en: '➊ def add(first_number, second_number):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def add(first_number, second_number):'
- en: ➋     total = first_number + second_number
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     total = first_number + second_number
- en: ➌     print(first_number, "+", second_number, "=", total)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     print(first_number, "+", second_number, "=", total)
- en: ➍ add(5, 7)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ add(5, 7)
- en: add(2012, 137)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: add(2012, 137)
- en: add(1234, 4321)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: add(1234, 4321)
- en: '*Listing 8-1: Sending information to a function*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：将信息发送到函数*'
- en: Save the program as *listing8-1.py*. Because it doesn’t use any Pygame Zero
    features, you can run it by clicking **Run** ▸ **Run Module** or by pressing F5\.
    (If you do run it using Pygame Zero, the results will appear in the command line
    window, and the game window will be empty.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序保存为*listing8-1.py*。因为它没有使用任何Pygame Zero功能，所以你可以通过点击**运行** ▸ **运行模块**或按F5键来运行它。（如果你使用Pygame
    Zero运行它，结果将出现在命令行窗口中，游戏窗口将为空。）
- en: 'When you run the program, you should see the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该看到以下输出：
- en: 5 + 7 = 12
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 5 + 7 = 12
- en: 2012 + 137 = 2149
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2012 + 137 = 2149
- en: 1234 + 4321 = 5555
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 1234 + 4321 = 5555
- en: We create a new function called add() ➊. After we’ve defined add(), we can run
    it by using its name ➍ and send it numbers by putting them in the parentheses,
    using commas between them ➍. The function will then add those two numbers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为add()的新函数➊。定义完add()之后，我们可以通过使用它的名称➍来运行它，并通过将数字放入括号中、数字之间用逗号分隔➍来向它传递数字。然后，函数会将这两个数字相加。
- en: '**HOW IT WORKS**'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**工作原理**'
- en: 'To enable the function to receive the numbers, we give it two variables to
    store the numbers in when we define it. I’ve called them first_number and second_number
    ➊ to make the program easier to understand, but the variable names could be anything.
    These are local variables: they only work inside this function.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使函数能够接收数字，我们在定义函数时为其提供了两个变量，用来存储这些数字。我将它们命名为first_number和second_number ➊，以便让程序更易于理解，但这些变量名可以是任何名称。这些是局部变量：它们仅在该函数内部有效。
- en: When you use the function, it takes the first item it receives and puts it into
    the variable first_number. The second item goes into second_number.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数时，它会将接收到的第一个项目放入变量first_number中。第二个项目放入second_number中。
- en: Of course, it doesn’t matter which order you add two numbers in, so it doesn’t
    matter what order you send the numbers in. The instructions add(5, 7) and add(7,
    5) give the same result. But some functions will need you to send the information
    in the same order the function expects to receive it. For example, if the function
    were subtracting numbers, you’d get a different result if you sent the numbers
    in the wrong order. The only way to know what information a function expects to
    receive is to take a look at its code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，两个数字相加的顺序并不重要，所以传入数字的顺序也无关紧要。指令add(5, 7)和add(7, 5)会给出相同的结果。但有些函数需要你按照函数期望接收的顺序来传递信息。例如，如果函数是在进行减法运算，传入数字的顺序错误就会得到不同的结果。了解函数期望接收什么信息的唯一方法是查看它的代码。
- en: The body of the function is quite simple. It creates a new variable called total,
    which stores the result of adding the two numbers ➋. The program then prints a
    line that contains the first number, a plus sign, the second number, an equal
    sign, and the total ➌.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的主体非常简单。它创建了一个名为total的新变量，用于存储两个数字相加的结果➋。然后，程序打印一行，包含第一个数字、加号、第二个数字、等号以及结果total➌。
- en: In the last three instructions, we send the function three pairs of numbers
    to add ➍.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后三条指令中，我们传递给函数三对数字进行相加 ➍。
- en: This simple demonstration shows you how information (or *arguments*) can be
    sent to a function. You can make functions that take more arguments than just
    two, and even take lists, dictionaries, or images. Functions make it easy to reuse
    sets of instructions, and sending arguments means we can reuse those instructions
    with different information. For example, [Listing 8-1](ch08.xhtml#ch08list1) uses
    the same print() instruction three times, to display the sum of three different
    number pairs. In this case, we’ve avoided repeating the print() instruction and
    the one that sets up the total variable. More sophisticated functions can avoid
    repeating a lot of code, and this can make the program much easier to write and
    understand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示范展示了如何将信息（或*参数*）传递给函数。你可以创建接受多个参数的函数，甚至可以接受列表、字典或图像。函数使得我们可以轻松重用一组指令，而传递参数意味着我们可以用不同的信息重用这些指令。例如，[示例
    8-1](ch08.xhtml#ch08list1)三次使用相同的print()指令，显示三个不同数字对的和。在这种情况下，我们避免了重复使用print()指令以及设置total变量的指令。更复杂的函数可以避免重复大量代码，这使得程序更加容易编写和理解。
- en: '**TRAINING MISSION #1**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**训练任务 #1**'
- en: Try modifying the program to subtract one number from another rather than adding.
    What happens when you change the order of the numbers you send to the new function?
    You might want to change more than just the calculation to make sure the function
    is easy to use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改程序，将两个数字相减，而不是相加。当你改变传递给新函数的数字顺序时，会发生什么？你可能需要改变的不仅仅是计算部分，以确保函数的使用更加简便。
- en: Now we’re ready to add some new functions to *Escape* to draw objects on the
    space station.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备为*Escape*添加一些新函数，用来在太空站上绘制物体。
- en: '**ADDING VARIABLES FOR SHADOWS, WALL TRANSPARENCY, AND COLORS**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加用于阴影、墙面透明度和颜色的变量**'
- en: To fix our space station, we’ll create new display functions for the *Escape*
    game, using our newfound knowledge of functions. Before we make these new functions,
    we need to set up new variables for the functions to use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复我们的太空站，我们将为*Escape*游戏创建新的显示函数，利用我们新学到的函数知识。在创建这些新函数之前，我们需要为函数设置新的变量。
- en: Open *listing7-6.py*, the last listing you saved in [Chapter 7](ch07.xhtml#ch07).
    Find the VARIABLES section near the start of the program, and add the new lines
    shown in [Listing 8-2](ch08.xhtml#ch08list2). Save the program as *listing8-2.py*.
    As always, it’s a good idea to run the program (using pgzrun listing8-2.py) to
    check for any new errors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*listing7-6.py*，这是你在[第7章](ch07.xhtml#ch07)保存的最后一个列表。找到程序开始时的VARIABLES部分，并添加在[Listing
    8-2](ch08.xhtml#ch08list2)中显示的新行。将程序保存为*listing8-2.py*。像往常一样，运行程序（使用pgzrun listing8-2.py）检查是否有新的错误。
- en: '*listing8-2.py*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-2.py*'
- en: --snip--
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '###############'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '## VARIABLES ##'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '## 变量 ##'
- en: '###############'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: --snip--
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: player_image = PLAYER[player_direction][player_frame]
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: player_image = PLAYER[player_direction][player_frame]
- en: player_offset_x, player_offset_y = 0, 0
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: player_offset_x, player_offset_y = 0, 0
- en: ➊ PLAYER_SHADOW = {
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ PLAYER_SHADOW = {
- en: '"left": [images.spacesuit_left_shadow, images.spacesuit_left_1_shadow,'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '"left": [images.spacesuit_left_shadow, images.spacesuit_left_1_shadow,'
- en: images.spacesuit_left_2_shadow, images.spacesuit_left_3_shadow,
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_left_2_shadow, images.spacesuit_left_3_shadow,
- en: images.spacesuit_left_3_shadow
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_left_3_shadow
- en: '],'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"right": [images.spacesuit_right_shadow, images.spacesuit_right_1_shadow,'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '"right": [images.spacesuit_right_shadow, images.spacesuit_right_1_shadow,'
- en: images.spacesuit_right_2_shadow,
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_right_2_shadow,
- en: images.spacesuit_right_3_shadow, images.spacesuit_right_3_shadow
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_right_3_shadow, images.spacesuit_right_3_shadow
- en: '],'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"up": [images.spacesuit_back_shadow, images.spacesuit_back_1_shadow,'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '"up": [images.spacesuit_back_shadow, images.spacesuit_back_1_shadow,'
- en: images.spacesuit_back_2_shadow, images.spacesuit_back_3_shadow,
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_back_2_shadow, images.spacesuit_back_3_shadow,
- en: images.spacesuit_back_3_shadow
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_back_3_shadow
- en: '],'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"down": [images.spacesuit_front_shadow, images.spacesuit_front_1_shadow,'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"down": [images.spacesuit_front_shadow, images.spacesuit_front_1_shadow,'
- en: images.spacesuit_front_2_shadow, images.spacesuit_front_3_shadow,
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_front_2_shadow, images.spacesuit_front_3_shadow,
- en: images.spacesuit_front_3_shadow
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: images.spacesuit_front_3_shadow
- en: ']'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➋ player_image_shadow = PLAYER_SHADOW["down"][0]
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ player_image_shadow = PLAYER_SHADOW["down"][0]
- en: ➌ PILLARS = [
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ PILLARS = [
- en: images.pillar, images.pillar_95, images.pillar_80,
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: images.pillar, images.pillar_95, images.pillar_80,
- en: images.pillar_60, images.pillar_50
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: images.pillar_60, images.pillar_50
- en: ']'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: ➍ wall_transparency_frame = 0
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ wall_transparency_frame = 0
- en: ➎ BLACK = (0, 0, 0)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ BLACK = (0, 0, 0)
- en: BLUE = (0, 155, 255)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: BLUE = (0, 155, 255)
- en: YELLOW = (255, 255, 0)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: YELLOW = (255, 255, 0)
- en: WHITE = (255, 255, 255)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: GREEN = (0, 255, 0)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = (0, 255, 0)
- en: RED = (128, 0, 0)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: RED = (128, 0, 0)
- en: '###############'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##    MAP    ##'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '##    地图    ##'
- en: '###############'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: --snip--
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '*Listing 8-2: Adding the variables needed for the new display functions*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-2: 添加新显示功能所需的变量*'
- en: We add a PLAYER_SHADOW dictionary ➊ that’s similar to the PLAYER dictionary.
    It contains animation frames for the astronaut’s shadow on the floor. As the astronaut
    moves, the shadow also changes shape. The player_image_shadow ➋ stores the astronaut’s
    current shadow, like the player_image variable that stores the astronaut’s current
    animation frame (or the standing image).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个类似于PLAYER字典的PLAYER_SHADOW字典➊。它包含了宇航员影像在地板上的动画帧。随着宇航员的移动，影像的形状也会变化。player_image_shadow
    ➋存储了宇航员当前的影像，类似于存储宇航员当前动画帧（或站立图像）的player_image变量。
- en: Later in this chapter, we’ll add animation that fades out the front wall when
    you walk behind it so you can still see the astronaut. Here, we set up a list
    of the animation frames ➌ and a wall_transparency_frame variable to remember the
    one that’s being shown now ➍. You’ll learn more about how these work later on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后，我们将添加一个动画效果，当你走到前墙后面时，前墙会逐渐消失，以便你仍然能看到宇航员。在这里，我们设置了一个动画帧列表➌和一个wall_transparency_frame变量，用于记录当前显示的帧➍。你将在后面了解这些是如何工作的。
- en: 'We’ve also set up some names that we can use to refer to color numbers ➎. Colors
    in Pygame Zero are stored as tuples. A tuple is like a list whose content you
    can’t change, and it uses parentheses instead of square brackets. You’ve seen
    tuples used for coordinates when drawing on the screen (see [Chapter 1](ch01.xhtml#ch01)).
    Colors are stored as three numbers that specify the amount of red, green, and
    blue in the color, in that order. The scale for each color ranges from 0 to 255\.
    This color is bright red:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一些名称，方便我们引用颜色编号➎。Pygame Zero中的颜色是以元组的形式存储的。元组就像是一个你不能更改内容的列表，它使用圆括号而非方括号。你在绘制屏幕坐标时就见过元组（见[第1章](ch01.xhtml#ch01)）。颜色是以三个数字存储的，分别指定颜色中的红、绿、蓝成分，按这个顺序排列。每种颜色的范围从0到255。这个颜色是亮红色：
- en: (255, 0, 0)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (255, 0, 0)
- en: The red is at its maximum (255), and there’s no green (0) or blue (0) in the
    color.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 红色的值达到了最大值（255），而没有绿色（0）或蓝色（0）。
- en: Because we’ve set up these color variables, we can now use the name BLACK instead
    of using the tuple (0, 0, 0) to represent black. Using color names will make the
    program easier to read.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经设置了这些颜色变量，现在可以使用BLACK代替元组(0, 0, 0)来表示黑色。使用颜色名称将使程序更易于阅读。
- en: '[Table 8-1](ch08.xhtml#ch08tab1) shows you some of the color combinations that
    you might want to use in your programs. You can also try different numbers to
    invent your own colors.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](ch08.xhtml#ch08tab1)显示了你可能在程序中使用的一些颜色组合。你还可以尝试不同的数字来发明你自己的颜色。'
- en: '**Table 8-1:** Some Example RGB Color Numbers'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 一些示例 RGB 颜色值'
- en: '| **Red** | **Green** | **Blue** | **Description** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **红色** | **绿色** | **蓝色** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 255 | 0 | 0 | Bright red |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 0 | 0 | 明亮的红色 |'
- en: '| 0 | 255 | 0 | Bright green |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 255 | 0 | 明亮的绿色 |'
- en: '| 0 | 0 | 255 | Bright blue |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 255 | 明亮的蓝色 |'
- en: '| 0 | 0 | 50 | Very dark blue (nearly black!) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 50 | 非常深的蓝色（几乎是黑色！） |'
- en: '| 255 | 255 | 255 | White (all the colors at maximum strength) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 255 | 255 | 白色（所有颜色的最大强度） |'
- en: '| 255 | 255 | 150 | Creamy yellow (slightly less blue than white) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 255 | 150 | 奶油黄色（比白色少一点蓝色） |'
- en: '| 230 | 230 | 230 | Silver (a slightly toned-down white) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 230 | 230 | 230 | 银色（稍微调淡的白色） |'
- en: '| 200 | 150 | 200 | Lilac |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 200 | 150 | 200 | 淡紫色 |'
- en: '| 255 | 100 | 0 | Orange (maximum red with a dash of green) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 100 | 0 | 橙色（最大红色，略带绿色） |'
- en: '| 255 | 105 | 180 | Pink |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 105 | 180 | 粉色 |'
- en: '**DELETING THE EXPLORER SECTION**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**删除EXPLORER部分**'
- en: We need to add a new DISPLAY section with some new functions that will improve
    the game’s appearance onscreen. The EXPLORER section has enabled us to get up
    and running quickly, but we’re going to build a new and better draw() function
    in this chapter that replaces the one we’ve used so far. To avoid any problems
    caused by EXPLORER code still being in the program, we’re going to remove it.
    Your EXPLORER section might have more or fewer lines than mine does in [Figure
    8-1](ch08.xhtml#ch08fig1), depending on whether you deleted some of it in earlier
    chapters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个新的DISPLAY部分，并引入一些新的函数，改善游戏的屏幕显示效果。EXPLORER部分帮助我们快速启动，但在这一章中我们将编写一个新的、更好的draw()函数来替代迄今为止使用的那个。为了避免EXPLORER代码仍然存在于程序中可能引发的问题，我们将删除它。你的EXPLORER部分可能比我在[图
    8-1](ch08.xhtml#ch08fig1)中展示的更多或更少，具体取决于你是否在之前的章节中删除了其中的一部分。
- en: 'To delete the entire EXPLORER section, follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除整个EXPLORER部分，请按照以下步骤操作：
- en: Find the EXPLORER part of the program near the end of the code.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码的末尾找到EXPLORER部分。
- en: Click the start of the EXPLORER comment box, hold down the mouse button, and
    drag the mouse to the bottom of the section (see [Figure 8-1](ch08.xhtml#ch08fig1)).
    The section ends just above where the START section begins.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击EXPLORER注释框的起始位置，按住鼠标按钮，拖动鼠标到底部（见[图 8-1](ch08.xhtml#ch08fig1)）。该部分结束位置位于START部分开始的上方。
- en: Press DELETE or BACKSPACE on the keyboard.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下DELETE或BACKSPACE键。
- en: 'There’s one instruction in the EXPLORER section that we still need: it runs
    the generate_map() function to set up the room map for the first room. You’ll
    need to add that instruction to the end of the program as a single line, as shown
    in [Listing 8-3](ch08.xhtml#ch08list3).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在EXPLORER部分有一条我们仍然需要的指令：它运行generate_map()函数，用于为第一个房间设置房间地图。你需要将该指令添加到程序末尾，作为一行代码，如[列表
    8-3](ch08.xhtml#ch08list3)所示。
- en: '*listing8-3.py*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-3.py*'
- en: --snip--
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '###############'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##   START   ##'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '##   START   ##'
- en: '###############'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: clock.schedule_interval(game_loop, 0.03)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: clock.schedule_interval(game_loop, 0.03)
- en: generate_map()
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: generate_map()
- en: '*Listing 8-3: Generating the map for the first room*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：为第一个房间生成地图*'
- en: The generate_map() line will run after the variables have been set up and will
    make the map for the current room.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: generate_map()行会在变量设置完成后运行，并为当前房间制作地图。
- en: '![image](../images/fig8-1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig8-1.jpg)'
- en: '*Figure 8-1: Deleting the* EXPLORER *section*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：删除* EXPLORER *部分*'
- en: Save your new listing as *listing8-3.py* and run it using pgzrun listing8-3.py.
    If all is going to plan, you should see no error messages in the command line
    window. The game window shows the inky blackness of space because we haven’t added
    the new code to draw anything yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的新列表为*listing8-3.py*并使用pgzrun listing8-3.py运行它。如果一切顺利，你应该不会在命令行窗口看到错误信息。游戏窗口显示的是黑暗的太空，因为我们还没有添加绘制任何内容的新代码。
- en: '**ADDING THE DISPLAY SECTION**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加显示部分**'
- en: Now we’ll add the new DISPLAY section to replace the deleted EXPLORER section.
    This section contains most of the code for updating the screen display. It includes
    code for drawing the room, showing messages, and changing the transparency of
    the front wall.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加新的显示部分，替代已删除的探索者部分。这个部分包含了更新屏幕显示的大部分代码。它包括绘制房间、显示消息以及改变前墙透明度的代码。
- en: '**ADDING THE FUNCTIONS FOR DRAWING OBJECTS**'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加绘制对象的函数**'
- en: First, we’ll make some functions to draw an object, a shadow, or the player
    at a particular tile position. Between the GAME LOOP and START sections, add the
    new DISPLAY section shown in [Listing 8-4](ch08.xhtml#ch08list4) to your program.
    Save this program as *listing8-4.py* and run it using pgzrun listing8-4.py. Again,
    you won’t see anything in the game window yet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些函数来绘制某个对象、阴影或玩家在特定瓦片位置。将新的显示部分（如[清单 8-4](ch08.xhtml#ch08list4)所示）添加到你的程序中，放在游戏循环和开始部分之间。将此程序保存为*listing8-4.py*，然后使用pgzrun
    listing8-4.py运行它。再次提醒，在游戏窗口中你还看不到任何内容。
- en: If there are any errors in the command line window, you can use them to help
    you fix the program. It’s better to test as you add code to the program than to
    add a lot of code and not know where the mistakes might be.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行窗口中有任何错误，你可以利用它们来帮助修复程序。最好在添加代码时进行测试，而不是先添加大量代码后再去找错误在哪里。
- en: '*listing8-4.py*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-4.py*'
- en: --snip--
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: 'if player_direction == "down" and player_frame > 0:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'if player_direction == "down" and player_frame > 0:'
- en: player_offset_y = -1 + (0.25 * player_frame)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: player_offset_y = -1 + (0.25 * player_frame)
- en: '###############'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##  DISPLAY  ##'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '##  显示  ##'
- en: '###############'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '➊ def draw_image(image, y, x):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def draw_image(image, y, x):'
- en: ➋     screen.blit(
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     screen.blit(
- en: image,
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: image,
- en: (top_left_x + (x * TILE_SIZE),
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (top_left_x + (x * TILE_SIZE),
- en: top_left_y + (y * TILE_SIZE) - image.get_height())
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: top_left_y + (y * TILE_SIZE) - image.get_height())
- en: )
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '➌ def draw_shadow(image, y, x):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ def draw_shadow(image, y, x):'
- en: screen.blit(
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: screen.blit(
- en: image,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: image,
- en: (top_left_x + (x * TILE_SIZE),
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (top_left_x + (x * TILE_SIZE),
- en: top_left_y + (y * TILE_SIZE))
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: top_left_y + (y * TILE_SIZE))
- en: )
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'def draw_player():'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_player():'
- en: ➍     player_image = PLAYER[player_direction][player_frame]
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     player_image = PLAYER[player_direction][player_frame]
- en: ➎     draw_image(player_image, player_y + player_offset_y,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ➎     draw_image(player_image, player_y + player_offset_y,
- en: player_x + player_offset_x)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: player_x + player_offset_x)
- en: ➏     player_image_shadow = PLAYER_SHADOW[player_direction][player_frame]
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➏     player_image_shadow = PLAYER_SHADOW[player_direction][player_frame]
- en: ➐     draw_shadow(player_image_shadow, player_y + player_offset_y,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ➐     draw_shadow(player_image_shadow, player_y + player_offset_y,
- en: player_x + player_offset_x)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: player_x + player_offset_x)
- en: '###############'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##   START   ##'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '##   开始   ##'
- en: '###############'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: clock.schedule_interval(game_loop, 0.03)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: clock.schedule_interval(game_loop, 0.03)
- en: generate_map()
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: generate_map()
- en: '*Listing 8-4: Adding the first functions in the* DISPLAY *section*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-4: 在显示部分中添加第一个函数*'
- en: 'The first new function, draw_image() ➊, draws a given image on the screen.
    When we use it, we give it the image we want to draw and the *y* and *x* tile
    positions of the object in the room. The function will work out where on the screen
    to draw the image (the pixel position), based on the tile position in the room.
    For example, we might use the function like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新函数，draw_image() ➊，在屏幕上绘制给定的图像。当我们使用它时，我们传入我们想要绘制的图像和物体在房间内的* y *和* x *瓦片位置。该函数将根据房间内的瓦片位置计算出在屏幕上的绘制位置（像素位置）。例如，我们可能会这样使用这个函数：
- en: draw_image(player_image, 5, 2)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(player_image, 5, 2)
- en: This line draws the player image at position *y* = 5 and *x* = 2 in the room.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在房间内的* y * = 5和* x * = 2的位置绘制玩家图像。
- en: When we define the draw_image() function, we set it up to give the image the
    name image, put the *y* position into the y variable, and put the *x* position
    into the x variable ➊. Although the draw_image() function is several lines long,
    its only instruction is screen.blit(), which draws the image at the position we
    specify ➋. This instruction is virtually the same as the one we used in the old
    EXPLORER section, so take a look at [Chapter 3](ch03.xhtml#ch03) for a refresher
    on how it works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义draw_image()函数时，我们设置它为给图像命名为image，将* y *位置放入y变量中，并将* x *位置放入x变量中➊。虽然draw_image()函数有几行代码，但它唯一的指令是screen.blit()，它会根据我们指定的位置绘制图像➋。这个指令几乎和我们在旧的探索者部分使用的指令一样，因此可以参考[第3章](ch03.xhtml#ch03)复习它的工作原理。
- en: '**TIP**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Make sure all the parentheses are in the correct places. You need a pair around
    all the screen.blit() arguments and another pair around the *y* and *x* positions
    because they make up a single tuple. You also need a pair around the multiplication
    parts of the position calculations. If the program doesn’t work, start checking
    for errors by counting the opening and closing parentheses to make sure you have
    the same number of each of them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有的括号位置正确。你需要为所有的 screen.blit() 参数加上一对括号，并且为 *y* 和 *x* 位置加上一对括号，因为它们构成一个元组。还需要为位置计算中的乘法部分加一对括号。如果程序没有正常运行，首先检查错误时可以通过计算括号的数量，确保开括号和闭括号的数量一致。
- en: We then add a new draw_shadow() function ➌. This is similar to the function
    for drawing an image, except that the image’s height is not subtracted when calculating
    its onscreen position. This is what places the shadow *below* the main image.
    [Figure 8-2](ch08.xhtml#ch08fig2) shows the astronaut and their shadow based on
    the same tile position. Remember that the *y* position given to screen.blit()
    is for the top edge of the image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加一个新的 draw_shadow() 函数 ➌。这个函数与绘制图像的函数类似，不同之处在于计算图像在屏幕上的位置时，不会减去图像的高度。正是这一点将阴影放置在主图像的*下方*。[图
    8-2](ch08.xhtml#ch08fig2) 显示了宇航员及其阴影，二者基于相同的瓦片位置。记住，传递给 screen.blit() 的 *y* 位置是图像的上边缘。
- en: '![image](../images/fig8-2.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig8-2.jpg)'
- en: '*Figure 8-2: Working out the position of the image and the shadow*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：计算图像和阴影的位置*'
- en: 'The third new function, draw_player(), draws the astronaut. First, it puts
    the correct astronaut animation frame into player_image ➍. It then uses the new
    draw_image() function to draw it ➎. The draw_image() function requires the following
    arguments:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个新函数，draw_player()，绘制了宇航员。首先，它将正确的宇航员动画帧放入 player_image ➍。然后使用新的 draw_image()
    函数来绘制它 ➎。draw_image() 函数需要以下参数：
- en: The variable player_image, which contains the image to draw.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含绘制图像的变量 player_image。
- en: The result after adding the global variables for player_y and player_offset_y.
    This is the *y* position in tiles, which might include a decimal part (such as
    5.25).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 player_y 和 player_offset_y 的全局变量后的结果。这是瓦片中的 *y* 位置，可能包括小数部分（例如 5.25）。
- en: The result after adding player_x and player_offset_x for the *x* position in
    tiles. (See “[Understanding the Movement Code](ch07.xhtml#lev96)” on [page 119](ch07.xhtml#page_119)
    for more information on how the offset variables are used for animation.)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 player_x 和 player_offset_x 后的结果，得到了瓦片中的 *x* 位置。（有关如何使用偏移变量进行动画的更多信息，请参阅 “[理解移动代码](ch07.xhtml#lev96)”
    第 119 页）
- en: 'We use similar code to draw the player’s shadow: the correct animation frame
    from the PLAYER_SHADOW dictionary is put into player_image_shadow ➏. Then the
    draw_shadow() function is used to draw it ➐. The draw_shadow() function uses the
    same tile positions as the draw_image() function.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似的代码来绘制玩家的阴影：从 PLAYER_SHADOW 字典中获取正确的动画帧并放入 player_image_shadow ➏。然后使用
    draw_shadow() 函数绘制它 ➐。draw_shadow() 函数使用与 draw_image() 函数相同的瓦片位置。
- en: '**DRAWING THE ROOM**'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**绘制房间**'
- en: Now that we’ve created the functions for drawing objects and the player, we
    can add the code to draw the room. The new draw() function in [Listing 8-5](ch08.xhtml#ch08list5)
    adds shadows for scenery and the player, and fixes the visual glitches we saw
    previously.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了绘制物体和玩家的函数，可以添加代码来绘制房间。[Listing 8-5](ch08.xhtml#ch08list5) 中的新的 draw()
    函数为场景和玩家添加了阴影，并修复了之前看到的视觉故障。
- en: Add the new code at the end of the DISPLAY section, save your program as *listing8-5.py*,
    and run it using pgzrun listing8-5.py. As if you’ve flicked the lights on, the
    shadows appear in front of the objects. The game won’t look quite right yet because
    all the rooms will be drawn in the top left of the window, and sometimes a room
    won’t be cleared properly when you leave it. We’ll fix this in a moment. At this
    point, you shouldn’t see any error messages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将新代码添加到 DISPLAY 部分的末尾，保存程序为 *listing8-5.py*，并使用 pgzrun listing8-5.py 运行它。就像你打开了灯一样，阴影出现在物体前面。游戏看起来可能还不太对，因为所有房间都会绘制在窗口的左上角，而且有时离开房间时房间没有正确清除。我们稍后会修复这个问题。此时，你应该不会看到任何错误信息。
- en: '*listing8-5.py*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-5.py*'
- en: --snip--
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'def draw_player():'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_player():'
- en: player_image = PLAYER[player_direction][player_frame]
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: player_image = PLAYER[player_direction][player_frame]
- en: draw_image(player_image, player_y + player_offset_y,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(player_image, player_y + player_offset_y,
- en: player_x + player_offset_x)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: player_x + player_offset_x)
- en: player_image_shadow = PLAYER_SHADOW[player_direction][player_frame]
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: player_image_shadow = PLAYER_SHADOW[player_direction][player_frame]
- en: draw_shadow(player_image_shadow, player_y + player_offset_y,
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: draw_shadow(player_image_shadow, player_y + player_offset_y,
- en: player_x + player_offset_x)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: player_x + player_offset_x)
- en: 'def draw():'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'if game_over:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'if game_over:'
- en: return
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: ➊     # Clear the game arena area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     # 清空游戏区域
- en: box = Rect((0, 150), (800, 600))
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: box = Rect((0, 150), (800, 600))
- en: screen.draw.filled_rect(box, RED)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: screen.draw.filled_rect(box, RED)
- en: box = Rect ((0, 0), (800, top_left_y + (room_height - 1)*30))
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: box = Rect ((0, 0), (800, top_left_y + (room_height - 1)*30))
- en: ➋     screen.surface.set_clip(box)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     screen.surface.set_clip(box)
- en: floor_type = get_floor_type()
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: floor_type = get_floor_type()
- en: '➌     for y in range(room_height): # Lay down floor tiles, then items on floor.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '➌     for y in range(room_height): # 放置地板瓦片，然后是地上的物品。'
- en: 'for x in range(room_width):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(room_width):'
- en: draw_image(objects[floor_type][0], y, x)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(objects[floor_type][0], y, x)
- en: '# Next line enables shadows to fall on top of objects on floor'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '# 下一行使得阴影可以投射到地面上的物体上'
- en: 'if room_map[y][x] in items_player_may_stand_on:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'if room_map[y][x] in items_player_may_stand_on:'
- en: draw_image(objects[room_map[y][x]][0], y, x)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(objects[room_map[y][x]][0], y, x)
- en: ➍     # Pressure pad in room 26 is added here, so props can go on top of it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     # 26号房间的压力垫在这里添加，因此物品可以放在它上面。
- en: 'if current_room == 26:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'if current_room == 26:'
- en: draw_image(objects[39][0], 8, 2)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(objects[39][0], 8, 2)
- en: image_on_pad = room_map[8][2]
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: image_on_pad = room_map[8][2]
- en: 'if image_on_pad > 0:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'if image_on_pad > 0:'
- en: draw_image(objects[image_on_pad][0], 8, 2)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(objects[image_on_pad][0], 8, 2)
- en: '➎     for y in range(room_height):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '➎     for y in range(room_height):'
- en: 'for x in range(room_width):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(room_width):'
- en: item_here = room_map[y][x]
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: item_here = room_map[y][x]
- en: '# Player cannot walk on 255: it marks spaces used by wide objects.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '# 玩家无法走到255：它标记了被宽物体占用的空间。'
- en: 'if item_here not in items_player_may_stand_on + [255]:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'if item_here not in items_player_may_stand_on + [255]:'
- en: image = objects[item_here][0]
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: image = objects[item_here][0]
- en: ➏                 if (current_room in outdoor_rooms
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ➏                 if (current_room in outdoor_rooms
- en: and y == room_height - 1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: and y == room_height - 1
- en: and room_map[y][x] == 1) or \
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: and room_map[y][x] == 1) or \
- en: (current_room not in outdoor_rooms
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (current_room not in outdoor_rooms
- en: and y == room_height - 1
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: and y == room_height - 1
- en: and room_map[y][x] == 1
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: and room_map[y][x] == 1
- en: and x > 0
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: and x > 0
- en: 'and x < room_width - 1):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'and x < room_width - 1):'
- en: '# Add transparent wall image in the front row.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在前排添加透明墙壁图像。'
- en: image = PILLARS[wall_transparency_frame]
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: image = PILLARS[wall_transparency_frame]
- en: draw_image(image, y, x)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: draw_image(image, y, x)
- en: '➐                 if objects[item_here][1] is not None: # If object has a shadow'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '➐                 if objects[item_here][1] is not None: # 如果物体有阴影'
- en: shadow_image = objects[item_here][1]
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: shadow_image = objects[item_here][1]
- en: '# if shadow might need horizontal tiling'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果阴影可能需要水平平铺'
- en: ➑                     if shadow_image in [images.half_shadow,
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ➑                     if shadow_image in [images.half_shadow,
- en: 'images.full_shadow]:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'images.full_shadow]:'
- en: shadow_width = int(image.get_width() / TILE_SIZE)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: shadow_width = int(image.get_width() / TILE_SIZE)
- en: '# Use shadow across width of object.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在物体的宽度上使用阴影。'
- en: 'for z in range(0, shadow_width):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'for z in range(0, shadow_width):'
- en: draw_shadow(shadow_image, y, x+z)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: draw_shadow(shadow_image, y, x+z)
- en: 'else:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: draw_shadow(shadow_image, y, x)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: draw_shadow(shadow_image, y, x)
- en: '➒         if (player_y == y):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '➒         if (player_y == y):'
- en: draw_player()
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: draw_player()
- en: ➓     screen.surface.set_clip(None)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ➓     screen.surface.set_clip(None)
- en: '###############'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##   START   ##'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '##   开始   ##'
- en: '###############'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: clock.schedule_interval(game_loop, 0.03)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: clock.schedule_interval(game_loop, 0.03)
- en: generate_map()
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: generate_map()
- en: '*Listing 8-5: The new* draw() *function*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*第8-5段：新的* draw() *函数*'
- en: As with the movement code in [Chapter 7](ch07.xhtml#ch07), you don’t need to
    know how the draw() function works, even if you want to customize the program.
    I will explain the draw() function in the next section, so if you don’t want to
    know how it works just yet, skip to “[Positioning the Room on Your Screen](ch08.xhtml#lev112)”
    on [page 141](ch08.xhtml#page_141).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第7章](ch07.xhtml#ch07)中的移动代码一样，即使你想自定义程序，也不需要知道 draw() 函数的工作原理。我将在下一节解释 draw()
    函数，所以如果你现在不想知道它是如何工作的，可以跳到[“在屏幕上定位房间”](ch08.xhtml#lev112)的[第141页](ch08.xhtml#page_141)。
- en: '**UNDERSTANDING THE NEW DRAW() FUNCTION**'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**理解新的 draw() 函数**'
- en: You can think of the new draw() function as a more elaborate version of the
    code used for the EXPLORER section previously. I’ll give you an overview of how
    each bit works.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将新的 draw() 函数视为先前 EXPLORER 部分使用的代码的更复杂版本。我将概述每一部分的工作原理。
- en: '**Clearing the Game Arena**'
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**清理游戏区域**'
- en: The program starts by clearing the game arena ➊ where the space station will
    be drawn. It does this by drawing a big red rectangle, wiping out the previous
    screen display. The areas at the top and the bottom that give the player information
    are separate, so they’re not changed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先通过清除游戏场景 ➊ 来启动，其中将绘制空间站。它通过绘制一个大红色矩形来实现这一点，擦除之前的屏幕显示。位于顶部和底部、提供玩家信息的区域是独立的，因此不会被更改。
- en: 'There are two steps for putting a rectangle on the screen. First, you create
    the shape using a Pygame object called a *Rect*, which works like this (don’t
    type this in):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制矩形有两个步骤。首先，你使用一个叫做 *Rect* 的 Pygame 对象创建形状，过程如下（不要输入此代码）：
- en: box = Rect((left position, top position), (width, height))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: box = Rect((left position, top position), (width, height))
- en: The name can be almost anything you like, but I use the name box in my programs.
    The position and size are tuples, so they have parentheses around them.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 名称几乎可以是你喜欢的任何东西，但我在我的程序中使用 box 这个名字。位置和大小是元组，因此它们被括号包围。
- en: 'Second, you draw the Rect you created on the screen by using an instruction
    like this (again, don’t type this in):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用类似这样的指令将你创建的矩形绘制到屏幕上（再次强调，不要输入此代码）：
- en: screen.draw.filled_rect(box, color)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: screen.draw.filled_rect(box, color)
- en: The first item in parentheses is the box Rect you previously created. The second
    item is the color of the rectangle you want to draw. This can be a tuple of the
    red, green, and blue numbers that make up the number. In [Listing 8-5](ch08.xhtml#ch08list5),
    I’ve used the name RED, which we set up in the VARIABLES section earlier.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的第一个项是你之前创建的矩形（Rect）框。第二项是你想要绘制的矩形颜色。这个颜色可以是由红色、绿色和蓝色数值组成的元组。在[示例 8-5](ch08.xhtml#ch08list5)中，我使用了我们在前面
    VARIABLES 部分设置的名字 RED。
- en: You can also use a Rect shape to create a *clipping area* ➋. This is like an
    invisible window through which you view the screen. If the program draws something
    outside the window, it can’t be seen. I’ve set up a clipping area that’s the height
    of the room to stop the player’s shadow from spilling out of the bottom of the
    game when they’re in the front doorway.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用矩形（Rect）形状来创建一个*裁剪区域* ➋。它就像是一个隐形的窗口，通过这个窗口你可以查看屏幕。如果程序在窗口外绘制了什么东西，它是看不见的。我设置了一个裁剪区域，它的高度与房间相同，防止玩家的影子在他们站在前门口时溢出到游戏底部。
- en: '**Drawing the Room**'
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制房间**'
- en: The room is drawn in two stages. First, the program draws the floor tiles and
    anything that the player can walk on ➌. Drawing them first enables scenery, the
    player, and shadows to be drawn on top of them. This solves the problem of black
    holes appearing under scenery, because there will be floor tiles in those spaces
    before the scenery is drawn on top.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 房间的绘制分为两个阶段。首先，程序绘制地板瓦片以及玩家可以行走的任何东西 ➌。先绘制它们可以确保景物、玩家和阴影被绘制在其上方。这解决了景物下出现黑洞的问题，因为在景物被绘制之前，地板瓦片已经存在于这些空间里。
- en: Second, the program adds the scenery in the room, including its shadows ➎, using
    new loops. Because this is drawn after the floor for the whole room has been drawn,
    the shadows will be drawn on top of floor tiles and items on the floor. The shadows
    are transparent, so you can still see the object underneath the shadow. The scenery
    drawing loops also add transparent walls ➏ and draw the player on top of the floor
    ➒.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序使用新的循环添加房间中的景物，包括它的阴影 ➎。因为这些是在整个房间的地板绘制完成后绘制的，所以阴影会覆盖在地板瓦片和地面上的物品上。阴影是透明的，因此你仍然可以看到阴影下方的物体。景物绘制的循环还添加了透明的墙壁
    ➏，并将玩家绘制在地板上方 ➒。
- en: As always, the room is drawn from back to front to ensure that objects near
    the front of the room appear to be in front of objects near the back.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，房间是从后向前绘制的，以确保靠近房间前方的物体看起来在靠近后方的物体前面。
- en: We’ve also added a small chunk of code for a special object that’s only used
    in one place in the game. Room 26 has a pressure pad on the floor that you might
    want to drop things on when you’re playing the game (maybe heavy things or things
    you can make heavy . . .). The special code here ensures that both the floor pad
    and the object on it are visible.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一段特殊代码，用于一个只在游戏中一个地方使用的特殊物品。第26号房间的地板上有一个压力垫，你可能想在游戏中放置物品（可能是重物或者是你可以让它变重的物品...）。这里的特殊代码确保地板垫和其上的物体都能可见。
- en: 'After the floor tiles have been drawn, the draw() function checks whether the
    current room is room 26: if it is, it draws the floor pad and then any object
    that is on top of it ➍.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制完地板瓦片后，draw() 函数会检查当前房间是否是房间 26：如果是，它会绘制地板垫，然后是任何放置在其上的物体 ➍。
- en: '**RED ALERT**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**红色警报**'
- en: '*If you’re customizing the game with your own map, delete this piece of code
    to remove the floor pad from the game. Start with the comment line* ➍*, and remove
    the instructions down to (and including) the* draw_image(objects[image_on_pad][0],
    8, 2) *instruction.*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在自定义游戏并使用自己的地图，删除这段代码以从游戏中移除地板垫。从注释行* ➍*开始，并删除指令，直到（并包括）*draw_image(objects[image_on_pad][0],
    8, 2)*指令。*'
- en: '**Making the Front Wall Transparent**'
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使前墙透明**'
- en: When the program is drawing the front row of the room (when the y loop equals
    room_height - 1), it checks whether it needs to draw a semitransparent wall instead
    of the solid wall object taken from the room map ➏. The semitransparent wall is
    used if the player is standing behind it (see [Figure 8-3](ch08.xhtml#ch08fig3)).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序绘制房间的前排（当y循环等于room_height - 1时），它会检查是否需要绘制半透明的墙壁，而不是从房间地图中获取的实心墙对象 ➏。如果玩家站在墙后面，则使用半透明墙壁（参见[图8-3](ch08.xhtml#ch08fig3)）。
- en: On the planet surface, the program makes the whole wall transparent. Inside
    the space station, a transparent wall panel is used only if it’s *not* in one
    of the bottom corner positions (see [Figure 8-3](ch08.xhtml#ch08fig3)). The corners
    always use a solid wall panel. The reason is that it looks odd if you see the
    solid edge wall start in the second row from the bottom.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在行星表面，程序使整个墙壁透明。在太空站内部，只有当透明墙面板不在底部角落位置时，才会使用透明墙面板（参见[图8-3](ch08.xhtml#ch08fig3)）。角落总是使用实心墙面板。原因是，如果你看到实心墙壁从倒数第二行开始，看起来会很奇怪。
- en: Later on, we’ll add the code to animate the transparency on the wall, by changing
    the number in wall_transparency_frame. You won’t see the semitransparent wall
    yet in the game.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们会添加代码，通过改变wall_transparency_frame中的数字来实现墙壁透明度的动画效果。你暂时在游戏中看不到半透明墙壁。
- en: '![image](../images/fig8-3.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig8-3.jpg)'
- en: '*Figure 8-3: The transparent wall at the front of the room, as seen in the
    final game*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：游戏最终版本中房间前面的透明墙壁*'
- en: '**Adding Shadows**'
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加阴影**'
- en: If an object has a shadow, the shadow is taken from the objects dictionary and
    put into shadow_image ➐. Then the program checks whether it should use half_shadow
    or full_shadow, which fill half a tile or a whole tile respectively. These two
    standard shadows are used with blocky items (such as electrical units and walls)
    that don’t need a distinctive shadow outline. The program checks whether the shadow_image
    is in a list that contains those two standard images ➑.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象有阴影，则阴影从对象字典中取出，并放入shadow_image ➐。然后程序检查是否应该使用half_shadow或full_shadow，它们分别填充半个瓦片或一个完整的瓦片。这两种标准阴影用于方块形物品（如电气设备和墙壁），这些物品不需要特别的阴影轮廓。程序检查shadow_image是否在一个包含这两种标准图像的列表中
    ➑。
- en: That’s a simple, and easy-to-read, way to check whether shadow_image is one
    of two things. If you’re checking for three or more things, this technique can
    make the program much easier to read than having lots of if comparisons using
    == and combining them with or.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单且易于阅读的方法，用来检查shadow_image是否是两种东西之一。如果你检查的是三个或更多的东西，这种方法会让程序比使用多个if比较（结合or）更加容易阅读。
- en: If the shadow is one of the standard images, the program then works out how
    wide the shadow should be in tiles. That is calculated by taking the width of
    the object casting the shadow and dividing it by the width of a tile (30 pixels).
    For example, an image that is 90 pixels wide will be 3 tiles wide.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果阴影是标准图像之一，程序会计算阴影应该占用的瓦片宽度。这个宽度是通过将投射阴影的对象的宽度除以一个瓦片的宽度（30像素）来计算的。例如，一个宽度为90像素的图像将占用3个瓦片宽。
- en: 'The program then creates a loop to draw the standard shadow images, using the
    variable z. It starts at 0 and runs until the width of the shadow minus 1\. That’s
    because a range leaves out the last item: range(0, 3) would give us the numbers
    0, 1, and 2\. The z values are added to the *x* position from the main loop and
    are used to draw the shadow tiles. [Figure 8-4](ch08.xhtml#ch08fig4) shows an
    object with a width of 3 tiles. The z loop takes the values 0, 1, and 2 to add
    the shadow in the correct place.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序创建一个循环来绘制标准的阴影图像，使用变量z。它从0开始，一直到阴影的宽度减去1。因为范围会排除最后一个项目：range(0, 3) 会给我们数字0、1和2。z值会加到主循环的*x*位置，用于绘制阴影瓦片。[图8-4](ch08.xhtml#ch08fig4)展示了一个宽度为3个瓦片的对象。z循环取值为0、1和2，以便将阴影放置到正确的位置。
- en: By drawing the player in position after the floor has been laid, we make sure
    the astronaut’s legs don’t disappear when walking up the screen ➒.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在铺设地板之后绘制玩家的位置，我们确保宇航员走动时不会让他的腿消失 ➒。
- en: '![image](../images/fig8-4.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig8-4.jpg)'
- en: '*Figure 8-4: An object that is 3 tiles wide could have a standard shadow below
    it that is used three times.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：一个宽度为 3 个瓦片的物体，其下方可能有一个标准的阴影，该阴影被使用三次。*'
- en: The draw() function ends by turning off the clipping area that stopped shadows
    from spilling out of the bottom of the game area ➓.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 函数的最后关闭了之前用于阻止阴影从游戏区域底部溢出的裁剪区域 ➓。
- en: '**POSITIONING THE ROOM ON YOUR SCREEN**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将房间定位到屏幕上**'
- en: 'Now let’s fix the problem of the room appearing in the top left of your screen.
    The program uses two variables to position the room: top_left_x and top_left_y.
    At the moment, these are set to 100 and 150, which means the room is always drawn
    in the top left of the window. We’ll add some code that will change these variables
    depending on the size of the room so the room is drawn in the middle of the window
    (see [Figure 8-5](ch08.xhtml#ch08fig5)). The screen layout will look better, and
    it will make the game easier to play too.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解决房间出现在屏幕左上角的问题。程序使用两个变量来定位房间：top_left_x 和 top_left_y。目前，它们被设置为 100 和 150，这意味着房间总是绘制在窗口的左上角。我们将添加一些代码，根据房间的大小来更改这些变量，这样房间就会被绘制在窗口的中央（见
    [图 8-5](ch08.xhtml#ch08fig5)）。屏幕布局看起来会更好，而且游戏也更容易操作。
- en: '![image](../images/fig8-5.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig8-5.jpg)'
- en: '*Figure 8-5: A room centered in the window*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：居中显示的房间*'
- en: Add the new lines shown in [Listing 8-6](ch08.xhtml#ch08list6) to the end of
    the generate_map() function, which is in the MAKE MAP section of the program.
    Because they’re inside a function, you need to indent each line by four spaces.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [Listing 8-6](ch08.xhtml#ch08list6) 中显示的新行添加到 generate_map() 函数的末尾，该函数位于程序的
    MAKE MAP 部分。由于这些代码在一个函数内部，因此每行需要缩进四个空格。
- en: Save the program as *listing8-6.py* and run it using pgzrun listing8-6.py. As
    [Figure 8-5](ch08.xhtml#ch08fig5) shows, each room should be centered on the screen
    now.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序保存为 *listing8-6.py*，并使用 pgzrun listing8-6.py 运行它。如 [图 8-5](ch08.xhtml#ch08fig5)
    所示，现在每个房间应该都居中显示在屏幕上。
- en: '*listing8-6.py*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-6.py*'
- en: --snip--
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'def generate_map():'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generate_map():'
- en: --snip--
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'for tile_number in range(1, image_width_in_tiles):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'for tile_number in range(1, image_width_in_tiles):'
- en: room_map[scenery_y][scenery_x + tile_number] = 255
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: room_map[scenery_y][scenery_x + tile_number] = 255
- en: '➊     center_y = int(HEIGHT / 2) # Center of game window'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     center_y = int(HEIGHT / 2) # 游戏窗口的中心'
- en: ➋     center_x = int(WIDTH / 2)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     center_x = int(WIDTH / 2)
- en: '➌     room_pixel_width = room_width * TILE_SIZE # Size of room in pixels'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '➌     room_pixel_width = room_width * TILE_SIZE # 房间的像素大小'
- en: ➍     room_pixel_height = room_height * TILE_SIZE
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     room_pixel_height = room_height * TILE_SIZE
- en: ➎     top_left_x = center_x - 0.5 * room_pixel_width
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ➎     top_left_x = center_x - 0.5 * room_pixel_width
- en: ➏     top_left_y = (center_y - 0.5 * room_pixel_height) + 110
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ➏     top_left_y = (center_y - 0.5 * room_pixel_height) + 110
- en: '*Listing 8-6: Creating variables to put the room in the middle of the game
    window*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-6：创建变量将房间置于游戏窗口的中央*'
- en: These instructions are inside the generate_map() function, which sets up the
    room_map list for each room when the player enters it. The generate_map() function
    now also sets up the top_left_x and top_left_y variables that remember where the
    room should be drawn in the window.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令位于 generate_map() 函数内，该函数在玩家进入房间时设置每个房间的 room_map 列表。generate_map() 函数现在还设置了
    top_left_x 和 top_left_y 变量，这些变量记录了房间在窗口中应绘制的位置。
- en: The new code in [Listing 8-6](ch08.xhtml#ch08list6) starts by working out where
    the middle of the window is. The HEIGHT and WIDTH variables store the window’s
    size in pixels. Dividing them by 2 gives us the coordinates of the center of the
    window. We store these in the center_y ➊ and center_x ➋ variables.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-6](ch08.xhtml#ch08list6) 中的新代码首先计算出窗口的中心位置。HEIGHT 和 WIDTH 变量存储了窗口的像素大小，将它们除以
    2 就能得到窗口中心的坐标。我们将这些值存储在 center_y ➊ 和 center_x ➋ 变量中。'
- en: The program then works out how wide the image of the room is in pixels ➌. That
    will be the width of the room in tiles multiplied by the size of a tile. The result
    is stored in room_pixel_width. A similar calculation is done for the room height
    ➍.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接着计算房间图像的宽度（以像素为单位） ➌。这个值等于房间宽度（以瓦片为单位）乘以单个瓦片的大小。结果存储在 room_pixel_width 中。房间的高度也通过类似的计算得出
    ➍。
- en: To put the room image in the middle of the room, we want half the room to be
    to the left of the center line and half to the right. So we subtract half the
    room width in pixels from the center line ➎ and start drawing the room there.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将房间图像放在房间的中央，我们希望房间的一半位于中心线的左侧，另一半位于右侧。因此，我们从中心线 ➎ 开始，减去房间宽度的一半（以像素为单位），并从那里开始绘制房间。
- en: A similar calculation is used for top_left_y except we add 110 to the result
    ➏. We need to add 110 because our final screen layout will use an area at the
    top of the screen as an information panel. We nudge the room image down a bit
    to make room for the panel.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对 top_left_y 也使用了类似的计算，唯一不同的是我们在结果中加了 110 ➏。我们需要加上 110，因为我们的最终屏幕布局将使用屏幕顶部的一个区域作为信息面板。因此我们稍微将房间图像向下移动一点，为面板腾出空间。
- en: '**MAKING THE FRONT WALL FADE IN AND OUT**'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让前墙逐渐显现和消失**'
- en: At this point, there are some dead spots in the game where the player can’t
    be seen. In the middle of the room, we can avoid that by making sure objects are
    not so tall that they obstruct the player. We need a tall wall at the front of
    the room, though.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，游戏中存在一些死角，玩家无法被看到。在房间的中间，我们可以避免这种情况，通过确保物体的高度不会遮挡玩家。然而，我们仍然需要在房间前面设置一面高墙。
- en: 'Blocking the player with a wall at the front of the room can cause all sorts
    of problems: if you drop something, you won’t be able to find it, or if something
    is hurting you, you won’t be able to see it! The solution is to make the wall
    fade away when the player approaches it.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 用墙壁阻挡玩家在房间前面可能会导致各种问题：如果你丢下东西，就找不到它，或者如果有什么东西正在伤害你，你将无法看到它！解决方法是，当玩家接近墙壁时，使墙壁逐渐消失。
- en: The draw() function already draws the front wall pillars using animation frames.
    The wall animation has five frames (numbered from 0 to 4) in the PILLARS list.
    The first frame is the solid wall, and the last frame shows the wall at its most
    translucent (see [Table 8-2](ch08.xhtml#ch08tab2)). As the animation frame number
    increases, the wall becomes more transparent. The current frame is stored in the
    variable wall_transparency_frame.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 函数已经使用动画帧绘制了前墙柱子。墙壁动画有五帧（编号从 0 到 4）在 PILLARS 列表中。第一帧是实心墙，最后一帧显示的是墙壁最透明的状态（见[表
    8-2](ch08.xhtml#ch08tab2)）。随着动画帧数的增加，墙壁变得越来越透明。当前帧存储在变量 wall_transparency_frame
    中。
- en: Because of the way the transparency works in the images, when the transparent
    wall is drawn on top of the player, the player can be seen through it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像中的透明度工作方式，当透明墙壁绘制在玩家上方时，玩家可以透过它被看到。
- en: '**Table 8-2:** The Animation Frames for the Front Wall'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2：** 前墙动画帧'
- en: '| **Frame number** | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **帧编号** | **0** | **1** | **2** | **3** | **4** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Image | ![image](../images/f0143-01.jpg) | ![image](../images/f0143-02.jpg)
    | ![image](../images/f0143-03.jpg) | ![image](../images/f0143-04.jpg) | ![image](../images/f0143-05.jpg)
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 图像 | ![image](../images/f0143-01.jpg) | ![image](../images/f0143-02.jpg)
    | ![image](../images/f0143-03.jpg) | ![image](../images/f0143-04.jpg) | ![image](../images/f0143-05.jpg)
    |'
- en: '[Listing 8-7](ch08.xhtml#ch08list7) shows the new function called adjust_wall_transparency(),
    which will fade the wall in and out. Add it at the end of the DISPLAY section,
    after the draw() function you just completed, and before the START section. You
    also need to add a line at the end of the program, outside the function, which
    will schedule it to run regularly. This line is also in [Listing 8-7](ch08.xhtml#ch08list7).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-7](ch08.xhtml#ch08list7) 显示了一个新函数叫做 adjust_wall_transparency()，它将使墙壁渐变显示。将它添加到
    DISPLAY 部分的末尾，紧接在你刚完成的 draw() 函数之后，并在 START 部分之前。你还需要在程序的末尾（函数外）添加一行代码，定期调度该函数的运行。这行代码也在[Listing
    8-7](ch08.xhtml#ch08list7)中。'
- en: Save your updated program as *listing8-7.py* and run it using pgzrun listing8-7.py.
    If you walk behind the front wall, it now fades to transparent so you can be seen
    through it (see [Figure 8-3](ch08.xhtml#ch08fig3) earlier in this chapter). When
    you walk away again, the wall changes back to being solid again.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将更新后的程序保存为 *listing8-7.py* 并使用 pgzrun listing8-7.py 运行它。如果你走到前墙后面，它现在会逐渐变为透明，这样你就可以透过它看到自己（见本章前面的[图
    8-3](ch08.xhtml#ch08fig3)）。当你再次走开时，墙壁会恢复为实心。
- en: '*listing8-7.py*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-7.py*'
- en: --snip--
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '###############'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##  DISPLAY  ##'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '##  显示  ##'
- en: '###############'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: --snip--
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: screen.surface.set_clip(None)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: screen.surface.set_clip(None)
- en: 'def adjust_wall_transparency():'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'def adjust_wall_transparency():'
- en: global wall_transparency_frame
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: global wall_transparency_frame
- en: ➊     if (player_y == room_height - 2
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     if (player_y == room_height - 2
- en: ➋         and room_map[room_height - 1][player_x] == 1
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ➋         and room_map[room_height - 1][player_x] == 1
- en: '➌         and wall_transparency_frame < 4):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '➌         和 wall_transparency_frame < 4):'
- en: '➍         wall_transparency_frame += 1 # Fade wall out.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '➍         wall_transparency_frame += 1 # 墙壁渐隐。'
- en: ➎     if ((player_y < room_height - 2
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ➎     如果 ((player_y < room_height - 2
- en: ➏             or room_map[room_height - 1][player_x] != 1)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ➏             或 room_map[room_height - 1][player_x] != 1)
- en: '➐             and wall_transparency_frame > 0):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '➐             和 wall_transparency_frame > 0):'
- en: '➑         wall_transparency_frame -= 1 # Fade wall in.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '➑         wall_transparency_frame -= 1 # 墙壁渐显。'
- en: '###############'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##   START   ##'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '##   开始   ##'
- en: '###############'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: clock.schedule_interval(game_loop, 0.03)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: clock.schedule_interval(game_loop, 0.03)
- en: generate_map()
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: generate_map()
- en: ➒ clock.schedule_interval(adjust_wall_transparency, 0.05)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ clock.schedule_interval(adjust_wall_transparency, 0.05)
- en: '*Listing 8-7: Making the front wall see-through when you approach it*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 8-7：当你接近墙时让前墙变得透明*'
- en: The final line we added in [Listing 8-7](ch08.xhtml#ch08list7) makes the function
    adjust_wall_transparency() run once every 0.05 seconds ➒. This makes the wall
    fade in or out as necessary as the player walks around the room.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [代码清单 8-7](ch08.xhtml#ch08list7) 中添加的最后一行，使得 adjust_wall_transparency()
    函数每 0.05 秒运行一次 ➒。这使得墙壁会随着玩家在房间内的移动逐渐淡入或淡出。
- en: 'Let’s see how this new function works. If the player is standing behind the
    wall, the following two statements are true:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个新函数是如何工作的。如果玩家站在墙后面，以下两个语句为真：
- en: Their *y* position will be equal to room_height - 2 ➊. As [Figure 8-6](ch08.xhtml#ch08fig6)
    shows, the bottom row of the map is room_height - 1. So we check whether the player
    is in the row above that.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的 *y* 位置将等于 room_height - 2 ➊。如 [图 8-6](ch08.xhtml#ch08fig6) 所示，地图的底部行是 room_height
    - 1。因此，我们检查玩家是否在这一行的上方。
- en: There is a piece of wall in the bottom row of the room that is in line with
    the player’s *x* position ➋. In [Figure 8-6](ch08.xhtml#ch08fig6), the red square
    marks a position where we can’t see the player. The bottom row in front of them
    contains a 1 for the wall. The green square shows where we can see the player,
    because they’re in the doorway. Here, the bottom row of the room map contains
    a 0.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在房间的底部行，有一块墙与玩家的 *x* 位置对齐 ➋。在 [图 8-6](ch08.xhtml#ch08fig6) 中，红色方块标记了我们看不见玩家的位置。它们前方的底部行包含一个墙的
    1。绿色方块则标出我们能看到玩家的位置，因为他们站在门口。此时，房间地图的底部行包含 0。
- en: '![image](../images/fig8-6.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig8-6.jpg)'
- en: '*Figure 8-6: Working out whether the player is behind the wall*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：判断玩家是否站在墙后*'
- en: If the player is behind the wall ➊ ➋ and the wall transparency is not set to
    maximum ➌, the wall transparency is increased by 1 ➍.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家站在墙后面 ➊ ➋ 且墙壁透明度没有设置为最大值 ➌，墙壁透明度会增加 1 ➍。
- en: 'If either of the following is true, it means the player *isn’t* hidden by the
    wall:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下任一条件成立，就意味着玩家 *没有* 被墙壁遮挡：
- en: Their *y* position is less than room_height - 2 ➎. The player can be seen, at
    least in part, if they’re farther back in the room.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的 *y* 位置小于 room_height - 2 ➎。玩家至少部分是可见的，如果他们站得更远些。
- en: There is not a piece of wall in the bottom row of the room in line with their
    *x* position ➏.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在房间的底部行，没有与玩家的 *x* 位置对齐的墙块 ➏。
- en: In these cases, if the wall transparency is set to more than the minimum ➐,
    it’s reduced by one ➑.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，如果墙壁透明度设置大于最小值 ➐，它会减少 1 ➑。
- en: The draw() function uses the value of wall_transparency_frame to work out which
    image from the animation frames in the PILLARS list to use in the front row.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 函数使用 wall_transparency_frame 的值来确定在 PILLARS 动画帧列表中，哪个图像应该用于前排。
- en: The effect is that the wall gradually fades in and out, depending on whether
    the player is behind it or not. This fading happens fast enough that players won’t
    be delayed by it but not so fast that it vanishes instantly, which would be distracting.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 效果是，墙壁会逐渐淡入或淡出，具体取决于玩家是否站在墙后面。这个渐变速度足够快，以至于玩家不会因为它而受到延迟，但也不会太快，以至于墙壁瞬间消失，这样会分散注意力。
- en: '**DISPLAYING HINTS, TIPS, AND WARNINGS**'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**显示提示、技巧和警告**'
- en: There are times when the *Escape* game uses text to tell you what’s going on.
    For example, it might use text to tell you what happens when you do something
    with an object, or provide a description of it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，《逃脱》游戏会使用文本来告诉你发生了什么。例如，它可能会使用文本告诉你当你与一个物体互动时会发生什么，或者提供物体的描述。
- en: 'The final function in the DISPLAY section of the program writes messages at
    the top of the game window. There are two lines of text:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中 DISPLAY 部分的最后一个函数将在游戏窗口顶部写入消息。有两行文本：
- en: The first line, positioned at 15 pixels from the top of the window, tells players
    about what they’re doing. For example, it displays object descriptions and tells
    them what happens when they use the objects.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行，距离窗口顶部 15 像素，告诉玩家他们正在做什么。例如，它显示物品描述，并告诉玩家使用这些物品后会发生什么。
- en: The second line, positioned at 50 pixels from the top of the window, is for
    important messages.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行，距离窗口顶部 50 像素，用于显示重要信息。
- en: The lines of text are separated like this so important messages don’t get covered
    up by less important messages. If the game needs to tell you about a life-threatening
    situation, you don’t want that message to be replaced with one that tells you
    about the new room you’ve entered!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文本行被分开，是为了避免重要信息被不太重要的信息覆盖。如果游戏需要告诉你一个危及生命的情况，你可不希望那个信息被一个告诉你进入新房间的信息所替代！
- en: Add the new code in [Listing 8-8](ch08.xhtml#ch08list8) to the end of the DISPLAY
    section, after where you added the wall transparency code in [Listing 8-7](ch08.xhtml#ch08list7).
    Save the listing as *listing8-8.py*. You can test it by running it with pgzrun
    listing8-8.py, but you won’t see any difference yet. In a moment, we’ll add some
    instructions to use this new show_text() function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [Listing 8-8](ch08.xhtml#ch08list8) 中的新代码添加到 DISPLAY 部分的末尾，放在你在 [Listing 8-7](ch08.xhtml#ch08list7)
    中添加墙壁透明度代码之后。将代码保存为 *listing8-8.py*。你可以通过运行 `pgzrun listing8-8.py` 来测试它，但你暂时不会看到任何区别。稍后，我们会添加一些使用此新
    show_text() 函数的指令。
- en: '*listing8-8.py*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-8.py*'
- en: --snip--
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: if ((player_y < room_height - 2
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: if ((player_y < room_height - 2
- en: or room_map[room_height - 1][player_x] != 1)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 room_map[room_height - 1][player_x] != 1)
- en: 'and wall_transparency_frame > 0):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'and wall_transparency_frame > 0):'
- en: 'wall_transparency_frame -= 1 # Fade wall in.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'wall_transparency_frame -= 1 # 墙壁渐显。'
- en: '➊ def show_text(text_to_show, line_number):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def show_text(text_to_show, line_number):'
- en: 'if game_over:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'if game_over:'
- en: return
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: ➋     text_lines = [15, 50]
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     text_lines = [15, 50]
- en: ➌     box = Rect((0, text_lines[line_number]), (800, 35))
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     box = Rect((0, text_lines[line_number]), (800, 35))
- en: ➍     screen.draw.filled_rect(box, BLACK)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     screen.draw.filled_rect(box, BLACK)
- en: ➎     screen.draw.text(text_to_show,
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ➎     screen.draw.text(text_to_show,
- en: (20, text_lines[line_number]), color=GREEN)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: (20, text_lines[line_number]), color=GREEN)
- en: '###############'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: '##   START   ##'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '##   START   ##'
- en: '###############'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: --snip--
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '*Listing 8-8: Adding the text display function*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-8: 添加文本显示功能*'
- en: 'We’ll use the show_text() ➊ function like this (don’t type this in):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用 show_text() ➊ 函数（不要键入此内容）：
- en: show_text("message", line number)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: show_text("message", line number)
- en: The line number will be either 0 for the top row or 1 for the second row, which
    is reserved for important messages. At the start of the function, the message
    is put into the variable text_to_show and the row number goes into line_number
    ➊.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 行号将是 0，表示第一行，或者 1，表示第二行，第二行是用于显示重要信息的。在函数开始时，信息被放入变量 text_to_show 中，行号被存储到 line_number
    ➊ 中。
- en: We use a list called text_lines to remember the vertical positions (in pixels)
    of the two lines of text ➋. We also define a box ➌ and fill it with black ➍, to
    clear the row of text before the new message is drawn.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为 text_lines 的列表来记录两行文本的垂直位置（单位：像素） ➋。我们还定义了一个框 ➌，并将其填充为黑色 ➍，以便在绘制新消息之前清除当前文本行。
- en: Finally, we use the screen.draw.text() function in Pygame Zero to put the text
    on the screen ➎. This function takes the text, the text’s *x* and *y* position,
    and the text color. The position numbers go inside parentheses (they make up a
    tuple).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 Pygame Zero 中的 screen.draw.text() 函数将文本显示在屏幕上 ➎。这个函数接受文本、文本的 *x* 和 *y*
    位置，以及文本颜色。位置数字放在括号内（它们组成一个元组）。
- en: In [Listing 8-8](ch08.xhtml#ch08list8) ➎, the *x* position is 20 pixels from
    the left, and the vertical position is taken from the text_lines list, using the
    number in line_number as the list index.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 8-8](ch08.xhtml#ch08list8) ➎ 中，*x* 位置是从左边 20 像素，垂直位置则来自 text_lines
    列表，使用 line_number 中的数字作为列表索引。
- en: '**SHOWING THE ROOM NAME WHEN YOU ENTER THE ROOM**'
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进入房间时显示房间名称**'
- en: To test the show_text() function, let’s add the start_room() function, which
    displays the name of the room when you walk into it. Put this function in the
    GAME LOOP section before the game_loop() function, as shown in [Listing 8-9](ch08.xhtml#ch08list9).
    Save your program as *listing8-9.py*. When you run it, you won’t see anything
    new yet.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 show_text() 函数，我们可以添加 start_room() 函数，当你走进一个房间时，它会显示房间的名称。将此函数放入 GAME LOOP
    部分，在 game_loop() 函数之前，如 [Listing 8-9](ch08.xhtml#ch08list9) 所示。将程序保存为 *listing8-9.py*，当你运行它时，暂时不会看到任何新变化。
- en: '*listing8-9.py*'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-9.py*'
- en: --snip--
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '###############'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: 'GAME LOOP ##'
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'GAME LOOP ##'
- en: '###############'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '###############'
- en: 'def start_room():'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 'def start_room():'
- en: 'show_text("You are here: " + room_name, 0)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'show_text("You are here: " + room_name, 0)'
- en: 'def game_loop():'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'def game_loop():'
- en: --snip--
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '*Listing 8-9: Adding the* start_room() *function*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-9: 添加* start_room() *函数*'
- en: 'This function uses the room_name variable, which we set up in the generate_map()
    function. It contains the name of the current room, taken from the GAME_MAP list.
    The room name is combined with the text "You are here: " and is sent to the show_text()
    function.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '这个函数使用了room_name变量，我们在generate_map()函数中设置了它。它包含当前房间的名称，来自GAME_MAP列表。房间名称与文本"You
    are here: "组合后，发送到show_text()函数。'
- en: 'Now we need to set our new start_room() function to run whenever the player
    enters a new room. We included the code to do this in [Listing 7-6](ch07.xhtml#ch07list6)
    in [Chapter 7](ch07.xhtml#ch07), but we commented it out. Now we’re ready for
    it! Anywhere we have the code #start_room() we want to replace it with start_room().
    That # is working as an “off switch,” telling Python to ignore the instruction.
    To turn the instruction on, we remove the # sign.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置新的start_room()函数，以便每次玩家进入新房间时都能运行。我们在[第7章](ch07.xhtml#ch07)的[Listing
    7-6](ch07.xhtml#ch07list6)中包含了执行此操作的代码，但我们注释掉了它。现在，我们准备好了！在我们代码中每次出现#start_room()时，我们希望将其替换为start_room()。那个#符号起到了“关闭开关”的作用，告诉Python忽略该指令。为了启用该指令，我们需要去掉#符号。
- en: 'Rather than manually finding all the lines that need to change, we’ll get IDLE
    to do it for us. Follow these steps, and refer to [Figure 8-7](ch08.xhtml#ch08fig7):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会手动查找所有需要更改的行，而是让IDLE为我们完成这项工作。按照以下步骤操作，并参考[图8-7](ch08.xhtml#ch08fig7)：
- en: Click **Edit** ▸ **Replace** (or press CTRL-H) in IDLE to show the replace text
    dialog box.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑** ▸ **替换**（或按CTRL-H）在IDLE中显示替换文本对话框。
- en: 'Enter #start_room() into the Find box.'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“查找”框中输入#start_room()。
- en: Enter start_room() into the Replace With box.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“替换为”框中输入start_room()。
- en: Click **Replace All**.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全部替换**。
- en: '![image](../images/fig8-7.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig8-7.jpg)'
- en: '*Figure 8-7: Enabling the* start_room() *function when the player enters a
    new room*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 8-7: 当玩家进入新房间时启用* start_room() *函数*'
- en: IDLE should replace the instruction in four places and will jump to the last
    one in the listing, as shown in [Listing 8-10](ch08.xhtml#ch08list10) (there’s
    no need to type this listing in).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE应该会在四个地方替换该指令，并跳转到列表中的最后一个位置，如[Listing 8-10](ch08.xhtml#ch08list10)所示（无需手动输入此列表）。
- en: Save the listing as *listing8-10.py* and run the program using pgzrun listing8-10.py.
    A message should appear announcing each new room as you enter it. It’s triggered
    by walking through the door, so it doesn’t work in the first room.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表保存为*listing8-10.py*，并使用pgzrun listing8-10.py运行程序。进入每个新房间时，应该会出现一条消息进行公告。它是通过走过门触发的，因此在第一个房间内不起作用。
- en: '*listing8-10.py*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '*listing8-10.py*'
- en: --snip--
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'if player_y == -1: # through door at TOP'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 'if player_y == -1: # 通过顶部的门'
- en: '#clock.unschedule(hazard_move)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '#clock.unschedule(hazard_move)'
- en: current_room -= MAP_WIDTH
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: current_room -= MAP_WIDTH
- en: generate_map()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: generate_map()
- en: 'player_y = room_height - 1 # enter at bottom'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 'player_y = room_height - 1 # 从底部进入'
- en: 'player_x = int(room_width / 2) # enter at door'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'player_x = int(room_width / 2) # 通过门进入'
- en: player_frame = 0
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: player_frame = 0
- en: start_room()
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: start_room()
- en: return
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: --snip--
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '*Listing 8-10: Enabling the* start_room() *function when the player leaves
    the room*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-10: 当玩家离开房间时启用* start_room() *函数*'
- en: This completes the DISPLAY section of the *Escape* game! We’ll make a few small
    changes later to show enemies, but otherwise we’ve laid the foundation for the
    rest of the game.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了*Escape*游戏的DISPLAY部分！稍后我们会做一些小的修改，展示敌人，但除此之外，我们已经为游戏的其余部分奠定了基础。
- en: In the next chapter, we’ll start unpacking your personal effects as we add props
    to the game.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始整理个人物品，并为游戏添加道具。
- en: '**ARE YOU FIT TO FLY?**'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你适合飞行吗？**'
- en: Check the following boxes to confirm that you’ve learned the key lessons in
    this chapter.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选以下复选框，确认你已经学会了本章的关键内容。
- en: '![Images](../images/box.jpg)  A piece of information sent to a function is
    called an *argument*.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg) 一段发送到函数的信息叫做*参数*。'
- en: '![Images](../images/box.jpg)  To send information to a function, you put it
    between the parentheses after the function name. You can send several arguments
    if you separate them with commas. For example: add(5, 7).'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg) 要向函数发送信息，你需要将其放在函数名后面的括号中。如果你想传送多个参数，可以用逗号分隔它们。例如：add(5,
    7)。'
- en: '![Images](../images/box.jpg)  To enable a function to accept information, you
    set up local variables to receive the arguments when you define the function.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg) 要使函数接受信息，你需要在定义函数时设置本地变量来接收参数。'
- en: '![Images](../images/box.jpg)  The DISPLAY section of the program draws the
    room, animates the transparent wall, and displays text messages.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg)  程序的 DISPLAY 部分绘制房间，动画透明墙，并显示文本消息。'
- en: '![Images](../images/box.jpg)  The show_text() function takes two arguments:
    the string you want to display and the row number (0 or 1). Row 1 is reserved
    for important messages.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg)  show_text() 函数接受两个参数：要显示的字符串和行号（0 或 1）。第 1 行保留用于重要消息。'
- en: '![Images](../images/box.jpg)  You define a Rect by giving Python tuples for
    its position and size.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg)  你通过为位置和大小提供 Python 元组来定义一个矩形（Rect）。'
- en: '![Images](../images/box.jpg)  The screen.draw.filled_rect() function draws
    a filled rectangle.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg)  screen.draw.filled_rect() 函数绘制一个填充的矩形。'
- en: '![Images](../images/box.jpg)  The colors in Pygame Zero use the RGB (red, green,
    blue) format. For example (255, 100, 0) is orange: maximum red, a dash of green,
    and no blue.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg)  Pygame Zero 中的颜色使用 RGB（红、绿、蓝）格式。例如 (255, 100, 0)
    是橙色：最大红色，一点绿色，没有蓝色。'
- en: '![Images](../images/box.jpg)  If you want to replace some code throughout the
    whole program, you can use the Replace All option in IDLE.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/box.jpg)  如果你想替换整个程序中的某些代码，可以在 IDLE 中使用“全部替换”选项。'
- en: '![image](../images/f0149-01.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0149-01.jpg)'
