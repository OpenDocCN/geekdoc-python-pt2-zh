- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REPAIRING THE SPACE STATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While wandering around the space station, you must have noticed that some things
    don’t look quite right. To get the program up and running quickly, we used the
    `EXPLORER` section to display the rooms. However, it has a few drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a blank space is shown beneath the scenery because there’s no floor
    there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you walk to the front of the room, the front wall hides the astronaut.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The astronaut’s legs disappear when walking to the back of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rooms are all drawn in the top left of the game window. This makes it look
    uneven and inconsistent, because there’s much more space on the right of the rooms
    than on the left, and wider rooms leave less space on the right than narrow rooms
    do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no shadows, making it harder to understand the position of objects
    in the room.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll fix these glitches and also add a function for displaying
    messages at the top of the window. These messages will give players information
    about the space station and their progress in the game.
  prefs: []
  type: TYPE_NORMAL
- en: As you read through the chapter, you’ll learn how to send information to a Python
    function and discover how to draw rectangles using Pygame Zero. By the end of
    the chapter, the space station will look great!
  prefs: []
  type: TYPE_NORMAL
- en: '**SENDING INFORMATION TO A FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the first time, we’ll need to send information to a function. You’ve already
    seen how to send information to the `print()` function by putting it between the
    parentheses. For example, you can output a message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When that instruction runs, the `print()` function receives information you
    put in the brackets, and displays it in the command line window or the Python
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: We can also send information to functions we’ve made.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A FUNCTION THAT RECEIVES INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To experiment with functions, we’ll build a function that adds two numbers that
    we send it. Click **File** ▸ **New** to open a new window, and enter the program
    in [Listing 8-1](ch08.xhtml#ch08list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-1.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Sending information to a function*'
  prefs: []
  type: TYPE_NORMAL
- en: Save the program as *listing8-1.py*. Because it doesn’t use any Pygame Zero
    features, you can run it by clicking **Run** ▸ **Run Module** or by pressing F5\.
    (If you do run it using Pygame Zero, the results will appear in the command line
    window, and the game window will be empty.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create a new function called `add()` ➊. After we’ve defined `add()`, we can
    run it by using its name ➍ and send it numbers by putting them in the parentheses,
    using commas between them ➍. The function will then add those two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To enable the function to receive the numbers, we give it two variables to
    store the numbers in when we define it. I’ve called them `first_number` and `second_number`
    ➊ to make the program easier to understand, but the variable names could be anything.
    These are local variables: they only work inside this function.'
  prefs: []
  type: TYPE_NORMAL
- en: When you use the function, it takes the first item it receives and puts it into
    the variable `first_number`. The second item goes into `second_number`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it doesn’t matter which order you add two numbers in, so it doesn’t
    matter what order you send the numbers in. The instructions `add(5, 7)` and `add(7,
    5)` give the same result. But some functions will need you to send the information
    in the same order the function expects to receive it. For example, if the function
    were subtracting numbers, you’d get a different result if you sent the numbers
    in the wrong order. The only way to know what information a function expects to
    receive is to take a look at its code.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the function is quite simple. It creates a new variable called `total`,
    which stores the result of adding the two numbers ➋. The program then prints a
    line that contains the first number, a plus sign, the second number, an equal
    sign, and the total ➌.
  prefs: []
  type: TYPE_NORMAL
- en: In the last three instructions, we send the function three pairs of numbers
    to add ➍.
  prefs: []
  type: TYPE_NORMAL
- en: This simple demonstration shows you how information (or *arguments*) can be
    sent to a function. You can make functions that take more arguments than just
    two, and even take lists, dictionaries, or images. Functions make it easy to reuse
    sets of instructions, and sending arguments means we can reuse those instructions
    with different information. For example, [Listing 8-1](ch08.xhtml#ch08list1) uses
    the same `print()` instruction three times, to display the sum of three different
    number pairs. In this case, we’ve avoided repeating the `print()` instruction
    and the one that sets up the `total` variable. More sophisticated functions can
    avoid repeating a lot of code, and this can make the program much easier to write
    and understand.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRAINING MISSION #1**'
  prefs: []
  type: TYPE_NORMAL
- en: Try modifying the program to subtract one number from another rather than adding.
    What happens when you change the order of the numbers you send to the new function?
    You might want to change more than just the calculation to make sure the function
    is easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to add some new functions to *Escape* to draw objects on the
    space station.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING VARIABLES FOR SHADOWS, WALL TRANSPARENCY, AND COLORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To fix our space station, we’ll create new display functions for the *Escape*
    game, using our newfound knowledge of functions. Before we make these new functions,
    we need to set up new variables for the functions to use.
  prefs: []
  type: TYPE_NORMAL
- en: Open *listing7-6.py*, the last listing you saved in [Chapter 7](ch07.xhtml#ch07).
    Find the `VARIABLES` section near the start of the program, and add the new lines
    shown in [Listing 8-2](ch08.xhtml#ch08list2). Save the program as *listing8-2.py*.
    As always, it’s a good idea to run the program (using pgzrun listing8-2.py) to
    check for any new errors.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-2.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Adding the variables needed for the new display functions*'
  prefs: []
  type: TYPE_NORMAL
- en: We add a `PLAYER_SHADOW` dictionary ➊ that’s similar to the `PLAYER` dictionary.
    It contains animation frames for the astronaut’s shadow on the floor. As the astronaut
    moves, the shadow also changes shape. The `player_image_shadow` ➋ stores the astronaut’s
    current shadow, like the `player_image` variable that stores the astronaut’s current
    animation frame (or the standing image).
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we’ll add animation that fades out the front wall when
    you walk behind it so you can still see the astronaut. Here, we set up a list
    of the animation frames ➌ and a `wall_transparency_frame` variable to remember
    the one that’s being shown now ➍. You’ll learn more about how these work later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve also set up some names that we can use to refer to color numbers ➎. Colors
    in Pygame Zero are stored as tuples. A tuple is like a list whose content you
    can’t change, and it uses parentheses instead of square brackets. You’ve seen
    tuples used for coordinates when drawing on the screen (see [Chapter 1](ch01.xhtml#ch01)).
    Colors are stored as three numbers that specify the amount of red, green, and
    blue in the color, in that order. The scale for each color ranges from 0 to 255\.
    This color is bright red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The red is at its maximum (255), and there’s no green (0) or blue (0) in the
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Because we’ve set up these color variables, we can now use the name `BLACK`
    instead of using the tuple `(0, 0, 0)` to represent black. Using color names will
    make the program easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](ch08.xhtml#ch08tab1) shows you some of the color combinations that
    you might want to use in your programs. You can also try different numbers to
    invent your own colors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Some Example RGB Color Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Red** | **Green** | **Blue** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | 0 | 0 | Bright red |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 255 | 0 | Bright green |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 255 | Bright blue |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 50 | Very dark blue (nearly black!) |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | 255 | 255 | White (all the colors at maximum strength) |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | 255 | 150 | Creamy yellow (slightly less blue than white) |'
  prefs: []
  type: TYPE_TB
- en: '| 230 | 230 | 230 | Silver (a slightly toned-down white) |'
  prefs: []
  type: TYPE_TB
- en: '| 200 | 150 | 200 | Lilac |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | 100 | 0 | Orange (maximum red with a dash of green) |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | 105 | 180 | Pink |'
  prefs: []
  type: TYPE_TB
- en: '**DELETING THE EXPLORER SECTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to add a new `DISPLAY` section with some new functions that will improve
    the game’s appearance onscreen. The `EXPLORER` section has enabled us to get up
    and running quickly, but we’re going to build a new and better `draw()` function
    in this chapter that replaces the one we’ve used so far. To avoid any problems
    caused by `EXPLORER` code still being in the program, we’re going to remove it.
    Your `EXPLORER` section might have more or fewer lines than mine does in [Figure
    8-1](ch08.xhtml#ch08fig1), depending on whether you deleted some of it in earlier
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the entire `EXPLORER` section, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `EXPLORER` part of the program near the end of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the start of the `EXPLORER` comment box, hold down the mouse button, and
    drag the mouse to the bottom of the section (see [Figure 8-1](ch08.xhtml#ch08fig1)).
    The section ends just above where the `START` section begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press DELETE or BACKSPACE on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There’s one instruction in the `EXPLORER` section that we still need: it runs
    the `generate_map()` function to set up the room map for the first room. You’ll
    need to add that instruction to the end of the program as a single line, as shown
    in [Listing 8-3](ch08.xhtml#ch08list3).'
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-3.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Generating the map for the first room*'
  prefs: []
  type: TYPE_NORMAL
- en: The `generate_map()` line will run after the variables have been set up and
    will make the map for the current room.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Deleting the* EXPLORER *section*'
  prefs: []
  type: TYPE_NORMAL
- en: Save your new listing as *listing8-3.py* and run it using pgzrun listing8-3.py.
    If all is going to plan, you should see no error messages in the command line
    window. The game window shows the inky blackness of space because we haven’t added
    the new code to draw anything yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE DISPLAY SECTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll add the new `DISPLAY` section to replace the deleted `EXPLORER` section.
    This section contains most of the code for updating the screen display. It includes
    code for drawing the room, showing messages, and changing the transparency of
    the front wall.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE FUNCTIONS FOR DRAWING OBJECTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we’ll make some functions to draw an object, a shadow, or the player
    at a particular tile position. Between the `GAME LOOP` and `START` sections, add
    the new `DISPLAY` section shown in [Listing 8-4](ch08.xhtml#ch08list4) to your
    program. Save this program as *listing8-4.py* and run it using pgzrun listing8-4.py.
    Again, you won’t see anything in the game window yet.
  prefs: []
  type: TYPE_NORMAL
- en: If there are any errors in the command line window, you can use them to help
    you fix the program. It’s better to test as you add code to the program than to
    add a lot of code and not know where the mistakes might be.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-4.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Adding the first functions in the* DISPLAY *section*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first new function, `draw_image()` ➊, draws a given image on the screen.
    When we use it, we give it the image we want to draw and the *y* and *x* tile
    positions of the object in the room. The function will work out where on the screen
    to draw the image (the pixel position), based on the tile position in the room.
    For example, we might use the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line draws the player image at position *y* = 5 and *x* = 2 in the room.
  prefs: []
  type: TYPE_NORMAL
- en: When we define the `draw_image()` function, we set it up to give the image the
    name `image`, put the *y* position into the `y` variable, and put the *x* position
    into the `x` variable ➊. Although the `draw_image()` function is several lines
    long, its only instruction is `screen.blit()`, which draws the image at the position
    we specify ➋. This instruction is virtually the same as the one we used in the
    old `EXPLORER` section, so take a look at [Chapter 3](ch03.xhtml#ch03) for a refresher
    on how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all the parentheses are in the correct places. You need a pair around
    all the `screen.blit()` arguments and another pair around the *y* and *x* positions
    because they make up a single tuple. You also need a pair around the multiplication
    parts of the position calculations. If the program doesn’t work, start checking
    for errors by counting the opening and closing parentheses to make sure you have
    the same number of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: We then add a new `draw_shadow()` function ➌. This is similar to the function
    for drawing an image, except that the image’s height is not subtracted when calculating
    its onscreen position. This is what places the shadow *below* the main image.
    [Figure 8-2](ch08.xhtml#ch08fig2) shows the astronaut and their shadow based on
    the same tile position. Remember that the *y* position given to `screen.blit()`
    is for the top edge of the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: Working out the position of the image and the shadow*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third new function, `draw_player()`, draws the astronaut. First, it puts
    the correct astronaut animation frame into `player_image` ➍. It then uses the
    new `draw_image()` function to draw it ➎. The `draw_image()` function requires
    the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `player_image`, which contains the image to draw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result after adding the global variables for `player_y` and `player_offset_y`.
    This is the *y* position in tiles, which might include a decimal part (such as
    5.25).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result after adding `player_x` and `player_offset_x` for the *x* position
    in tiles. (See “[Understanding the Movement Code](ch07.xhtml#lev96)” on [page
    119](ch07.xhtml#page_119) for more information on how the offset variables are
    used for animation.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use similar code to draw the player’s shadow: the correct animation frame
    from the `PLAYER_SHADOW` dictionary is put into `player_image_shadow` ➏. Then
    the `draw_shadow()` function is used to draw it ➐. The `draw_shadow()` function
    uses the same tile positions as the `draw_image()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DRAWING THE ROOM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve created the functions for drawing objects and the player, we
    can add the code to draw the room. The new `draw()` function in [Listing 8-5](ch08.xhtml#ch08list5)
    adds shadows for scenery and the player, and fixes the visual glitches we saw
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Add the new code at the end of the `DISPLAY` section, save your program as *listing8-5.py*,
    and run it using pgzrun listing8-5.py. As if you’ve flicked the lights on, the
    shadows appear in front of the objects. The game won’t look quite right yet because
    all the rooms will be drawn in the top left of the window, and sometimes a room
    won’t be cleared properly when you leave it. We’ll fix this in a moment. At this
    point, you shouldn’t see any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-5.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: The new* draw() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: As with the movement code in [Chapter 7](ch07.xhtml#ch07), you don’t need to
    know how the `draw()` function works, even if you want to customize the program.
    I will explain the `draw()` function in the next section, so if you don’t want
    to know how it works just yet, skip to “[Positioning the Room on Your Screen](ch08.xhtml#lev112)”
    on [page 141](ch08.xhtml#page_141).
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING THE NEW DRAW() FUNCTION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can think of the new `draw()` function as a more elaborate version of the
    code used for the `EXPLORER` section previously. I’ll give you an overview of
    how each bit works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clearing the Game Arena**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The program starts by clearing the game arena ➊ where the space station will
    be drawn. It does this by drawing a big red rectangle, wiping out the previous
    screen display. The areas at the top and the bottom that give the player information
    are separate, so they’re not changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps for putting a rectangle on the screen. First, you create
    the shape using a Pygame object called a *Rect*, which works like this (don’t
    type this in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The name can be almost anything you like, but I use the name `box` in my programs.
    The position and size are tuples, so they have parentheses around them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you draw the Rect you created on the screen by using an instruction
    like this (again, don’t type this in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first item in parentheses is the `box` Rect you previously created. The
    second item is the color of the rectangle you want to draw. This can be a tuple
    of the red, green, and blue numbers that make up the number. In [Listing 8-5](ch08.xhtml#ch08list5),
    I’ve used the name `RED`, which we set up in the `VARIABLES` section earlier.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use a Rect shape to create a *clipping area* ➋. This is like an
    invisible window through which you view the screen. If the program draws something
    outside the window, it can’t be seen. I’ve set up a clipping area that’s the height
    of the room to stop the player’s shadow from spilling out of the bottom of the
    game when they’re in the front doorway.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Room**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The room is drawn in two stages. First, the program draws the floor tiles and
    anything that the player can walk on ➌. Drawing them first enables scenery, the
    player, and shadows to be drawn on top of them. This solves the problem of black
    holes appearing under scenery, because there will be floor tiles in those spaces
    before the scenery is drawn on top.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the program adds the scenery in the room, including its shadows ➎, using
    new loops. Because this is drawn after the floor for the whole room has been drawn,
    the shadows will be drawn on top of floor tiles and items on the floor. The shadows
    are transparent, so you can still see the object underneath the shadow. The scenery
    drawing loops also add transparent walls ➏ and draw the player on top of the floor
    ➒.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the room is drawn from back to front to ensure that objects near
    the front of the room appear to be in front of objects near the back.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also added a small chunk of code for a special object that’s only used
    in one place in the game. Room 26 has a pressure pad on the floor that you might
    want to drop things on when you’re playing the game (maybe heavy things or things
    you can make heavy . . .). The special code here ensures that both the floor pad
    and the object on it are visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the floor tiles have been drawn, the `draw()` function checks whether
    the current room is room 26: if it is, it draws the floor pad and then any object
    that is on top of it ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RED ALERT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re customizing the game with your own map, delete this piece of code
    to remove the floor pad from the game. Start with the comment line* ➍*, and remove
    the instructions down to (and including) the* draw_image(objects[image_on_pad][0],
    8, 2) *instruction.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Front Wall Transparent**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When the program is drawing the front row of the room (when the `y` loop equals
    `room_height - 1)`, it checks whether it needs to draw a semitransparent wall
    instead of the solid wall object taken from the room map ➏. The semitransparent
    wall is used if the player is standing behind it (see [Figure 8-3](ch08.xhtml#ch08fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: On the planet surface, the program makes the whole wall transparent. Inside
    the space station, a transparent wall panel is used only if it’s *not* in one
    of the bottom corner positions (see [Figure 8-3](ch08.xhtml#ch08fig3)). The corners
    always use a solid wall panel. The reason is that it looks odd if you see the
    solid edge wall start in the second row from the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we’ll add the code to animate the transparency on the wall, by changing
    the number in `wall_transparency_frame`. You won’t see the semitransparent wall
    yet in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: The transparent wall at the front of the room, as seen in the
    final game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Shadows**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If an object has a shadow, the shadow is taken from the `objects` dictionary
    and put into `shadow_image` ➐. Then the program checks whether it should use `half_shadow`
    or `full_shadow`, which fill half a tile or a whole tile respectively. These two
    standard shadows are used with blocky items (such as electrical units and walls)
    that don’t need a distinctive shadow outline. The program checks whether the `shadow_image`
    is in a list that contains those two standard images ➑.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a simple, and easy-to-read, way to check whether `shadow_image` is one
    of two things. If you’re checking for three or more things, this technique can
    make the program much easier to read than having lots of `if` comparisons using
    `==` and combining them with `or`.
  prefs: []
  type: TYPE_NORMAL
- en: If the shadow is one of the standard images, the program then works out how
    wide the shadow should be in tiles. That is calculated by taking the width of
    the object casting the shadow and dividing it by the width of a tile (30 pixels).
    For example, an image that is 90 pixels wide will be 3 tiles wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program then creates a loop to draw the standard shadow images, using the
    variable `z`. It starts at 0 and runs until the width of the shadow minus 1\.
    That’s because a `range` leaves out the last item: `range(0, 3)` would give us
    the numbers 0, 1, and 2\. The `z` values are added to the *x* position from the
    main loop and are used to draw the shadow tiles. [Figure 8-4](ch08.xhtml#ch08fig4)
    shows an object with a width of 3 tiles. The `z` loop takes the values 0, 1, and
    2 to add the shadow in the correct place.'
  prefs: []
  type: TYPE_NORMAL
- en: By drawing the player in position after the floor has been laid, we make sure
    the astronaut’s legs don’t disappear when walking up the screen ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: An object that is 3 tiles wide could have a standard shadow below
    it that is used three times.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function ends by turning off the clipping area that stopped shadows
    from spilling out of the bottom of the game area ➓.
  prefs: []
  type: TYPE_NORMAL
- en: '**POSITIONING THE ROOM ON YOUR SCREEN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s fix the problem of the room appearing in the top left of your screen.
    The program uses two variables to position the room: `top_left_x` and `top_left_y`.
    At the moment, these are set to 100 and 150, which means the room is always drawn
    in the top left of the window. We’ll add some code that will change these variables
    depending on the size of the room so the room is drawn in the middle of the window
    (see [Figure 8-5](ch08.xhtml#ch08fig5)). The screen layout will look better, and
    it will make the game easier to play too.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig8-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: A room centered in the window*'
  prefs: []
  type: TYPE_NORMAL
- en: Add the new lines shown in [Listing 8-6](ch08.xhtml#ch08list6) to the end of
    the `generate_map()` function, which is in the `MAKE MAP` section of the program.
    Because they’re inside a function, you need to indent each line by four spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Save the program as *listing8-6.py* and run it using pgzrun listing8-6.py. As
    [Figure 8-5](ch08.xhtml#ch08fig5) shows, each room should be centered on the screen
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-6.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Creating variables to put the room in the middle of the game
    window*'
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are inside the `generate_map()` function, which sets up the
    `room_map` list for each room when the player enters it. The `generate_map()`
    function now also sets up the `top_left_x` and `top_left_y` variables that remember
    where the room should be drawn in the window.
  prefs: []
  type: TYPE_NORMAL
- en: The new code in [Listing 8-6](ch08.xhtml#ch08list6) starts by working out where
    the middle of the window is. The `HEIGHT` and `WIDTH` variables store the window’s
    size in pixels. Dividing them by 2 gives us the coordinates of the center of the
    window. We store these in the `center_y` ➊ and `center_x` ➋ variables.
  prefs: []
  type: TYPE_NORMAL
- en: The program then works out how wide the image of the room is in pixels ➌. That
    will be the width of the room in tiles multiplied by the size of a tile. The result
    is stored in `room_pixel_width`. A similar calculation is done for the room height
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: To put the room image in the middle of the room, we want half the room to be
    to the left of the center line and half to the right. So we subtract half the
    room width in pixels from the center line ➎ and start drawing the room there.
  prefs: []
  type: TYPE_NORMAL
- en: A similar calculation is used for `top_left_y` except we add 110 to the result
    ➏. We need to add 110 because our final screen layout will use an area at the
    top of the screen as an information panel. We nudge the room image down a bit
    to make room for the panel.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE FRONT WALL FADE IN AND OUT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, there are some dead spots in the game where the player can’t
    be seen. In the middle of the room, we can avoid that by making sure objects are
    not so tall that they obstruct the player. We need a tall wall at the front of
    the room, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocking the player with a wall at the front of the room can cause all sorts
    of problems: if you drop something, you won’t be able to find it, or if something
    is hurting you, you won’t be able to see it! The solution is to make the wall
    fade away when the player approaches it.'
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function already draws the front wall pillars using animation frames.
    The wall animation has five frames (numbered from 0 to 4) in the `PILLARS` list.
    The first frame is the solid wall, and the last frame shows the wall at its most
    translucent (see [Table 8-2](ch08.xhtml#ch08tab2)). As the animation frame number
    increases, the wall becomes more transparent. The current frame is stored in the
    variable `wall_transparency_frame`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way the transparency works in the images, when the transparent
    wall is drawn on top of the player, the player can be seen through it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2:** The Animation Frames for the Front Wall'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Frame number** | **0** | **1** | **2** | **3** | **4** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Image | ![image](../images/f0143-01.jpg) | ![image](../images/f0143-02.jpg)
    | ![image](../images/f0143-03.jpg) | ![image](../images/f0143-04.jpg) | ![image](../images/f0143-05.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '[Listing 8-7](ch08.xhtml#ch08list7) shows the new function called `adjust_wall_transparency()`,
    which will fade the wall in and out. Add it at the end of the `DISPLAY` section,
    after the `draw()` function you just completed, and before the `START` section.
    You also need to add a line at the end of the program, outside the function, which
    will schedule it to run regularly. This line is also in [Listing 8-7](ch08.xhtml#ch08list7).'
  prefs: []
  type: TYPE_NORMAL
- en: Save your updated program as *listing8-7.py* and run it using pgzrun listing8-7.py.
    If you walk behind the front wall, it now fades to transparent so you can be seen
    through it (see [Figure 8-3](ch08.xhtml#ch08fig3) earlier in this chapter). When
    you walk away again, the wall changes back to being solid again.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-7.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: Making the front wall see-through when you approach it*'
  prefs: []
  type: TYPE_NORMAL
- en: The final line we added in [Listing 8-7](ch08.xhtml#ch08list7) makes the function
    `adjust_wall_``transparency()` run once every 0.05 seconds ➒. This makes the wall
    fade in or out as necessary as the player walks around the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this new function works. If the player is standing behind the
    wall, the following two statements are true:'
  prefs: []
  type: TYPE_NORMAL
- en: Their *y* position will be equal to `room_height - 2` ➊. As [Figure 8-6](ch08.xhtml#ch08fig6)
    shows, the bottom row of the map is `room_height - 1`. So we check whether the
    player is in the row above that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a piece of wall in the bottom row of the room that is in line with
    the player’s *x* position ➋. In [Figure 8-6](ch08.xhtml#ch08fig6), the red square
    marks a position where we can’t see the player. The bottom row in front of them
    contains a 1 for the wall. The green square shows where we can see the player,
    because they’re in the doorway. Here, the bottom row of the room map contains
    a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](../images/fig8-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: Working out whether the player is behind the wall*'
  prefs: []
  type: TYPE_NORMAL
- en: If the player is behind the wall ➊ ➋ and the wall transparency is not set to
    maximum ➌, the wall transparency is increased by 1 ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either of the following is true, it means the player *isn’t* hidden by the
    wall:'
  prefs: []
  type: TYPE_NORMAL
- en: Their *y* position is less than `room_height - 2` ➎. The player can be seen,
    at least in part, if they’re farther back in the room.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is not a piece of wall in the bottom row of the room in line with their
    *x* position ➏.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these cases, if the wall transparency is set to more than the minimum ➐,
    it’s reduced by one ➑.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function uses the value of `wall_transparency_frame` to work out
    which image from the animation frames in the `PILLARS` list to use in the front
    row.
  prefs: []
  type: TYPE_NORMAL
- en: The effect is that the wall gradually fades in and out, depending on whether
    the player is behind it or not. This fading happens fast enough that players won’t
    be delayed by it but not so fast that it vanishes instantly, which would be distracting.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING HINTS, TIPS, AND WARNINGS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times when the *Escape* game uses text to tell you what’s going on.
    For example, it might use text to tell you what happens when you do something
    with an object, or provide a description of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final function in the `DISPLAY` section of the program writes messages
    at the top of the game window. There are two lines of text:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line, positioned at 15 pixels from the top of the window, tells players
    about what they’re doing. For example, it displays object descriptions and tells
    them what happens when they use the objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line, positioned at 50 pixels from the top of the window, is for
    important messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lines of text are separated like this so important messages don’t get covered
    up by less important messages. If the game needs to tell you about a life-threatening
    situation, you don’t want that message to be replaced with one that tells you
    about the new room you’ve entered!
  prefs: []
  type: TYPE_NORMAL
- en: Add the new code in [Listing 8-8](ch08.xhtml#ch08list8) to the end of the `DISPLAY`
    section, after where you added the wall transparency code in [Listing 8-7](ch08.xhtml#ch08list7).
    Save the listing as *listing8-8.py*. You can test it by running it with pgzrun
    listing8-8.py, but you won’t see any difference yet. In a moment, we’ll add some
    instructions to use this new `show_text()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-8.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: Adding the text display function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the `show_text()` ➊ function like this (don’t type this in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The line number will be either 0 for the top row or 1 for the second row, which
    is reserved for important messages. At the start of the function, the message
    is put into the variable `text_to_show` and the row number goes into `line_number`
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: We use a list called `text_lines` to remember the vertical positions (in pixels)
    of the two lines of text ➋. We also define a box ➌ and fill it with black ➍, to
    clear the row of text before the new message is drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `screen.draw.text()` function in Pygame Zero to put the
    text on the screen ➎. This function takes the text, the text’s *x* and *y* position,
    and the text color. The position numbers go inside parentheses (they make up a
    tuple).
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 8-8](ch08.xhtml#ch08list8) ➎, the *x* position is 20 pixels from
    the left, and the vertical position is taken from the `text_lines` list, using
    the number in `line_number` as the list index.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOWING THE ROOM NAME WHEN YOU ENTER THE ROOM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the `show_text()` function, let’s add the `start_room()` function, which
    displays the name of the room when you walk into it. Put this function in the
    `GAME LOOP` section before the `game_loop()` function, as shown in [Listing 8-9](ch08.xhtml#ch08list9).
    Save your program as *listing8-9.py*. When you run it, you won’t see anything
    new yet.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-9.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: Adding the* start_room() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function uses the `room_name` variable, which we set up in the `generate_map``()`
    function. It contains the name of the current room, taken from the `GAME_MAP`
    list. The room name is combined with the text `"You are here: "` and is sent to
    the `show_text()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to set our new `start_room()` function to run whenever the player
    enters a new room. We included the code to do this in [Listing 7-6](ch07.xhtml#ch07list6)
    in [Chapter 7](ch07.xhtml#ch07), but we commented it out. Now we’re ready for
    it! Anywhere we have the code `#start_room()` we want to replace it with `start_room()`.
    That `#` is working as an “off switch,” telling Python to ignore the instruction.
    To turn the instruction on, we remove the `#` sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than manually finding all the lines that need to change, we’ll get IDLE
    to do it for us. Follow these steps, and refer to [Figure 8-7](ch08.xhtml#ch08fig7):'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Edit** ▸ **Replace** (or press CTRL-H) in IDLE to show the replace text
    dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter #start_room() into the Find box.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter start_room() into the Replace With box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Replace All**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/fig8-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Enabling the* start_room() *function when the player enters a
    new room*'
  prefs: []
  type: TYPE_NORMAL
- en: IDLE should replace the instruction in four places and will jump to the last
    one in the listing, as shown in [Listing 8-10](ch08.xhtml#ch08list10) (there’s
    no need to type this listing in).
  prefs: []
  type: TYPE_NORMAL
- en: Save the listing as *listing8-10.py* and run the program using pgzrun listing8-10.py.
    A message should appear announcing each new room as you enter it. It’s triggered
    by walking through the door, so it doesn’t work in the first room.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing8-10.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: Enabling the* start_room() *function when the player leaves
    the room*'
  prefs: []
  type: TYPE_NORMAL
- en: This completes the `DISPLAY` section of the *Escape* game! We’ll make a few
    small changes later to show enemies, but otherwise we’ve laid the foundation for
    the rest of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start unpacking your personal effects as we add props
    to the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARE YOU FIT TO FLY?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check the following boxes to confirm that you’ve learned the key lessons in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  A piece of information sent to a function is
    called an *argument*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  To send information to a function, you put it
    between the parentheses after the function name. You can send several arguments
    if you separate them with commas. For example: `add(5, 7)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  To enable a function to accept information, you
    set up local variables to receive the arguments when you define the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `DISPLAY` section of the program draws the
    room, animates the transparent wall, and displays text messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `show_text()` function takes two arguments:
    the string you want to display and the row number (0 or 1). Row 1 is reserved
    for important messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  You define a Rect by giving Python tuples for
    its position and size.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `screen.draw.filled_rect()` function draws
    a filled rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The colors in Pygame Zero use the RGB (red, green,
    blue) format. For example `(255, 100, 0)` is orange: maximum red, a dash of green,
    and no blue.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  If you want to replace some code throughout the
    whole program, you can use the Replace All option in IDLE.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0149-01.jpg)'
  prefs: []
  type: TYPE_IMG
