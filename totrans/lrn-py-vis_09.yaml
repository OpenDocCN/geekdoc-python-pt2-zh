- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Functions and Periodic Motion
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和周期性运动
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: As your programs grow more complex, your line counts will increase, and you’ll
    begin repeating the same or similar code. By using *functions*, you can divide
    your programs into named blocks of reusable code. This makes your code more modular,
    allowing you to reuse lines without needing to rewrite them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的程序变得越来越复杂，代码行数会增加，你也会开始重复相同或相似的代码。通过使用*函数*，你可以将程序分成具有名称的可重用代码块。这使得代码更加模块化，允许你在不需要重写代码的情况下重用某些代码行。
- en: You’ve already used many Processing functions, like `size()`, `print()`, and
    `rect()`, and in this chapter, you’ll learn how to define your own functions.
    As an example, Processing has no function for drawing diamonds, but you can create
    one. You decide what to name this function and what arguments it will accept.
    Perhaps your `diamond()` function accepts an x, y, width, height, and optional
    rotation argument.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用过许多Processing函数，例如`size()`、`print()`和`rect()`，在本章中，你将学习如何定义自己的函数。作为一个例子，Processing没有绘制菱形的函数，但你可以创建一个。你可以决定这个函数的名称以及它接受的参数。也许你的`diamond()`函数接受x、y、宽度、高度和可选的旋转角度参数。
- en: You’ll also create functions for generating elliptical and wave-type motion,
    which will involve delving into some trigonometry. You’ll incorporate the mathematical
    functions sine and cosine by using Processing’s built-in functions for performing
    these calculations. If the mention of trigonometry triggers disturbing flashbacks
    from math class, take a deep breath and relax. This will be a practical and visual
    reintroduction to these concepts, with Processing crunching all the numbers for
    you.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将创建生成椭圆形和波动类型运动的函数，这将涉及一些三角学内容。你将使用Processing的内置函数来执行这些数学计算，从而结合正弦和余弦函数。如果三角学的提法让你想起了数学课上那些让人不快的回忆，不妨深呼吸放松一下。这将是一个实用且可视化的重新介绍，Processing将为你计算所有的数字。
- en: Defining Functions
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数
- en: Sensibly named functions make your code easier to understand and work with.
    A 1,000-line program can be tricky to comprehend, especially for somebody who
    didn’t write it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 合理命名的函数使得代码更容易理解和使用。一个1000行的程序可能会让人难以理解，尤其是对于那些没有编写它的人来说。
- en: Imagine programming a music player. You might create a function named `play()`
    that executes 20 or so lines of code necessary to load and play an MP3 file. When
    you need to play a track, you simply call your `play()` function by using a file
    argument, like `play('track_1.mp3')`. You don’t need to concern yourself with
    the details of how the `play()` function operates after you’ve defined it, and
    neither does anybody else working with your code. Additionally, you could define
    functions for `stop()`, `pause()`, `skipBack()`, and `skipForward()`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下编写一个音乐播放器。你可能会创建一个名为`play()`的函数，执行加载和播放MP3文件所需的20行左右的代码。当你需要播放一首歌曲时，只需使用文件参数调用`play()`函数，例如`play('track_1.mp3')`。在定义了`play()`函数之后，你无需关心它是如何操作的，其他与代码一起工作的人也不需要。除此之外，你还可以为`stop()`、`pause()`、`skipBack()`和`skipForward()`定义函数。
- en: In this section, you’ll learn to define functions with the `def` keyword and
    then how to handle arguments. You might call these *user-defined functions* to
    distinguish them from those that come built-in with Python and Processing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用`def`关键字定义函数，以及如何处理函数参数。你可以将这些称为*用户定义的函数*，以便将它们与Python和Processing中内置的函数区分开来。
- en: Creating a Simple Speech Bubble Function
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的对话框函数
- en: Let’s begin with a simple function that takes no arguments and draws speech
    bubbles, like the ones you find in comic strips, in the console. You’ve already
    used functions that work without arguments, like Processing’s `noFill()` that
    relies on just a function name and parentheses. Conversely, a function like `fill()`
    requires at least one argument, such as a hexadecimal color value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的函数开始，这个函数不接受任何参数，并在控制台中绘制像漫画条形图那样的对话框。你已经使用过不需要参数的函数，比如Processing中的`noFill()`，它仅依赖函数名和括号。相反，一个像`fill()`的函数则需要至少一个参数，比如十六进制的颜色值。
- en: Your speech bubble function will form an outline, using plaintext characters,
    that surrounds a caption. Once you have this working, you’ll move on to defining
    a more dynamic function that accepts a range of arguments to draw speech bubbles
    in the display window.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的对话框函数将形成一个轮廓，使用纯文本字符，围绕一个标题。一旦这个功能实现，你就可以定义一个更动态的函数，接受一系列参数，在显示窗口中绘制对话框。
- en: 'Create a new sketch and save it as *speech_bubbles*. Add the following code
    that prints a question in the console, followed by the answer in a speech bubble
    five seconds later:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的草图，并将其保存为*speech_bubbles*。添加以下代码，首先在控制台打印一个问题，然后在五秒钟后通过对话框显示答案：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you run the sketch, you should see the question appear in your console
    immediately 1. The Processing `delay()` function halts the program for 5,000 milliseconds
    (five seconds) 2, then reveals the answer in a speech bubble using the four print
    lines that follow it. Run the sketch to confirm this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，你应该立即看到问题出现在控制台中。Processing的`delay()`函数会暂停程序5,000毫秒（五秒），然后使用接下来的四行打印语句在对话框中揭示答案。运行草图以确认这一点：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This might not look like the most convincing speech bubble, but it’ll do for
    now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是最令人信服的对话框，但目前勉强可以使用。
- en: 'Make the following changes to your code to define a function for printing the
    answer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的代码做以下更改，以定义一个打印答案的函数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `def` keyword defines a new function. You can name this function whatever
    you like, but make the name descriptive. Like variable names, function names should
    contain only alphanumeric and underscore characters, and they must start with
    a letter or an underscore; in this case, I’ve chosen `printAnswer`. Always include
    the parentheses and a colon at the end of the `def` line. The four `print()` lines
    are in the *body* of the function definition, which is the indented section of
    code beneath the `def` line. The function won’t execute the print lines until
    you *call* it. On the last line, where the program must reveal the answer, is
    the `printAnswer()` function call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`def`关键字定义了一个新函数。你可以给这个函数起任何名字，但要确保名字具有描述性。像变量名一样，函数名应只包含字母数字和下划线字符，并且必须以字母或下划线开头；在这种情况下，我选择了`printAnswer`。在`def`行末尾始终包括括号和冒号。四行`print()`语句位于函数定义的*主体*部分，这是`def`行下面的缩进代码。函数不会执行打印语句，直到你*调用*它。在最后一行，程序必须揭示答案时，调用了`printAnswer()`函数。'
- en: When you run the sketch, the program should work as before, printing the question
    followed by the answer in a speech bubble five seconds later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，程序应该和以前一样工作，首先打印问题，然后在五秒钟后通过对话框显示答案。
- en: The PEP 8 style guide recommends that “function names should be lowercase, with
    words separated by underscores as necessary to improve readability.” In other
    words, the `printAnswer()` function instead should be named `print_answer()`.
    However, when an existing style is established, internal consistency is usually
    preferred.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8风格指南建议“函数名应为小写，必要时使用下划线分隔单词以提高可读性。”换句话说，`printAnswer()`函数应该命名为`print_answer()`。然而，当已有的命名风格已经建立时，通常更倾向于保持内部一致性。
- en: I’ve opted for a camelCase function name to match the convention used for Processing’s
    built-in functions, like `noFill()` or `pushMatrix()`. As noted in Chapter 1,
    camelCase combines multiple words into one and uses a capital letter to start
    the second and subsequent words. The style is also referred to as *mixedCase*,
    or sometimes *lowerCamelCase* (to contrast it with *UpperCamelCase*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了驼峰命名法的函数名，以符合Processing内置函数的命名惯例，如`noFill()`或`pushMatrix()`。正如第一章所提到的，驼峰命名法将多个单词合并成一个单词，并使用大写字母开始第二个及之后的单词。这种风格也称为*混合大小写*，有时也叫*小驼峰命名法*（与*大驼峰命名法*相对）。
- en: 'Add a second question to the end of your sketch:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图的末尾添加第二个问题：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After displaying the answer to question 1, the program waits two and a half
    seconds and prints question 2\. The answer to question 2 is revealed five seconds
    after this. Once again, the answer is 42, but there’s no need to retype the four
    lines of code for displaying the speech bubble. Instead, you can call the `printAnswer()`
    function a second time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示问题1的答案之后，程序等待两秒半，然后打印问题2。问题2的答案将在五秒后揭示。答案再次是42，但不需要重新输入显示对话框的四行代码。相反，你可以第二次调用`printAnswer()`函数。
- en: You can add as many questions as you like. If the answer to each question is
    42, you can call the `printAnswer()` function to display the answer. If you want
    to restyle *all* of your speech bubbles—for example, using different characters
    for the outline—edit the body of the `printAnswer()` definition. You need to change
    the code in only one place to affect every speech bubble.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加任意数量的问题。如果每个问题的答案都是42，你可以调用`printAnswer()`函数来显示答案。如果你想更改*所有*对话框的样式——例如，使用不同的字符来表示边框——编辑`printAnswer()`定义中的代码。你只需要在一个地方修改代码，就能影响每个对话框。
- en: For each answer, you have a neat, one-line function call with a name that indicates
    what it does. Other programmers won’t need to understand the inner workings of
    the `printAnswer()` function to use it, but if necessary, they can read through
    the definition code to find out how it works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个答案，您有一个整洁的单行函数调用，函数名称表明它的作用。其他程序员无需了解`printAnswer()`函数的内部工作原理即可使用它，但如果需要，他们可以通过查看定义代码了解它是如何工作的。
- en: 'Before proceeding to the next section, set the `wait` value (at the top of
    your code) to `0`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行下一部分之前，将代码顶部的`wait`值设置为`0`：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This change cancels the effects of the `delay()` functions, because a delay
    time of zero means there is no delay. As a result, your sketch doesn’t pause,
    and the next section of code you add can run immediately.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改取消了`delay()`函数的效果，因为零延迟时间意味着没有延迟。因此，草图不会暂停，您添加的下一部分代码可以立即运行。
- en: The `printAnswer()` function is limited to drawing speech bubbles in the console,
    and it always prints the same answer of 42, so next, you’ll define a function
    that can accept arguments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`printAnswer()`函数仅限于在控制台中绘制气泡，并且它总是打印相同的答案42，因此接下来，您将定义一个可以接受参数的函数。'
- en: Drawing Compound Shapes Using a Function
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数绘制复合形状
- en: To define a function that draws speech bubbles with shapes and text in the display
    window, continue working in your *speech_bubbles* sketch. First, you’ll need an
    image over which to place your speech bubbles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个在显示窗口中绘制带有形状和文本的气泡函数，请继续在您的*speech_bubbles*草图中工作。首先，您需要一张图片来放置气泡。
- en: 'I’ve chosen Jan van Eyck’s *Arnolfini Portrait* for this example because the
    painting has three speech bubble candidates: a man, a woman, and a dog. It’s also
    public domain. [Figure 9-1](#figure9-1) presents the original painting on the
    left, and the result you’re working toward on the right.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了扬·范·艾克的*阿尔诺芬尼肖像*作为本示例，因为这幅画有三个气泡候选人：一名男子、一名女子和一只狗。而且它是公有领域的。[图9-1](#figure9-1)展示了左侧的原始画作，以及右侧您将要完成的效果。
- en: '![f09001](image_fi/500969c09/f09001.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/500969c09/f09001.png)'
- en: 'Figure 9-1: The original *Arnolfini Portrait*, 1434 (left); a version with
    speech bubbles (right)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：原始*阿尔诺芬尼肖像*，1434年（左）；带有气泡的版本（右）
- en: You can download the *Arnolfini Portrait* image from Wikipedia ([https://en.wikipedia.org/wiki/File:Van_Eyck_-_Arnolfini_Portrait.jpg](https://en.wikipedia.org/wiki/File:Van_Eyck_-_Arnolfini_Portrait.jpg));
    the 561 × 768 pixel resolution will suffice. If you want to use a different image,
    that’s fine too; just choose one with at least three subjects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从维基百科下载*阿尔诺芬尼肖像*图片（[https://en.wikipedia.org/wiki/File:Van_Eyck_-_Arnolfini_Portrait.jpg](https://en.wikipedia.org/wiki/File:Van_Eyck_-_Arnolfini_Portrait.jpg)）；561
    × 768像素的分辨率就足够了。如果您想使用不同的图片也可以；只需选择至少有三个人物的图片。
- en: 'Create a new *data* subfolder and add your image to this; then add the following
    code to load and display it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的*data*子文件夹，并将您的图片添加到其中；然后添加以下代码以加载并显示它：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’re not using the *Arnolfini Portrait*, adjust the `size()` and `loadImage()`
    arguments accordingly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用*阿尔诺芬尼肖像*，请相应调整`size()`和`loadImage()`的参数。
- en: Run the sketch to confirm that the image spans your display window.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图以确认图片跨越了您的显示窗口。
- en: 'Define and then call a new speech bubble function by adding this code to the
    end of your sketch:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义并调用一个新的气泡函数，将以下代码添加到草图的末尾：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re using a different image, adjust the `x`, `y`, and `txt` variables.
    The `x` and `y` variables control the position of the speech bubble—specifically,
    the x-y coordinate for the tip of the “tail” that’s attached to the bubble. Before
    drawing anything, a `translate()` function repositions the drawing space so that
    the vertex coordinates for this tip are (0, 0); the other tail vertices and the
    bubble are positioned relative to this point.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不同的图片，请调整`x`、`y`和`txt`变量。`x`和`y`变量控制气泡的位置——具体来说，是指附着在气泡上的“尾巴”尖端的x-y坐标。在绘制任何内容之前，`translate()`函数会重新定位绘图空间，使得这个尖端的顶点坐标为（0，0）；其他尾巴顶点和气泡则相对于这个点进行定位。
- en: The `txt` variable defines the text that appears within the bubble. You can
    use any `txt` string you like, but keep it short. The speech bubbles will not
    accommodate multiline captions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`txt`变量定义了气泡内显示的文本。您可以使用任何喜欢的`txt`字符串，但请保持简短。气泡不支持多行标题。'
- en: The code beneath the `bubble` comment draws a rounded rectangular bubble above
    the tail. The `rect()` function includes a fifth argument (`10`) that controls
    the corner radius. The larger you make this value, the rounder the corners become.
    The result is a rounded rectangular speech bubble with a tail at its bottom left
    ([Figure 9-2](#figure9-2)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`bubble` 注释下方的代码绘制了一个位于尾部上方的圆角矩形气泡。`rect()` 函数包含第五个参数（`10`），该参数控制角的半径。这个值越大，角就会变得越圆。结果是一个带有左下角尾巴的圆角矩形语音气泡（[图
    9-2](#figure9-2)）。'
- en: '![f09002](image_fi/500969c09/f09002.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/500969c09/f09002.png)'
- en: 'Figure 9-2: The tip of the speech bubble tail has an x-y coordinate of (190,
    150).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：语音气泡尾部的尖端坐标为 (190, 150)。
- en: You can call the `speechBubble()` function 100 times, but the visual result
    always appears the same because every speech bubble draws over the one before
    it, at the same size, with the same text, in the same position. But, if you modify
    the `x`, `y`, and `txt` variables each time you call the `speechBubble()` function,
    you can customize the x-coordinate, y-coordinate, and caption. You can accomplish
    this by adding parameters to your function definition that allow you to pass values
    to the function using different arguments in your function call.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用 `speechBubble()` 函数 100 次，但视觉效果始终相同，因为每个语音气泡都覆盖在前一个上，大小相同，文本相同，位置也相同。但是，如果你每次调用
    `speechBubble()` 函数时都修改 `x`、`y` 和 `txt` 变量，你就可以自定义 x 坐标、y 坐标和标题。你可以通过向函数定义中添加参数来实现这一点，这样你就可以在函数调用中通过不同的参数传递值给函数。
- en: Adding Arguments and Parameters
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加参数和占位符
- en: Now you’ll edit your `speechBubble()` definition so that the function can accept
    three arguments, allowing you to pass your coordinate and caption values to the
    function to manipulate the appearance of each speech bubble you draw. Arguments
    are assigned to corresponding *parameters*, but more on those shortly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将编辑 `speechBubble()` 的定义，使得函数可以接受三个参数，这样你就可以将坐标和标题值传递给函数，进而操作每个语音气泡的外观。参数被赋值给相应的*占位符*，但稍后会详细讲解这些内容。
- en: 'Currently, three variables control the speech bubble’s appearance: `x`, `y`,
    and `txt`. To control those variable values via arguments, adapt your function
    definition as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，有三个变量控制语音气泡的外观：`x`、`y` 和 `txt`。要通过参数控制这些变量值，可以按如下方式调整你的函数定义：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The definition parentheses now include three parameters: `x`, `y`, and `txt`
    1. A parameter is a placeholder for a value that’s provided by way of an argument.
    These parameters are made available within the local scope of the function; in
    other words, Python can access `x`, `y`, and `txt` only within the `speechBubble()`
    function block. You need to comment out (or delete) the old `x`, `y`, and `txt`
    lines to avoid overwriting the values that you pass in with the function call
    2.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义括号现在包含三个参数：`x`、`y` 和 `txt` 1。参数是一个占位符，代表通过参数传入的值。这些参数在函数的局部作用域内可用；换句话说，Python
    只能在 `speechBubble()` 函数块内访问 `x`、`y` 和 `txt`。你需要注释掉（或删除）旧的 `x`、`y` 和 `txt` 行，以避免覆盖你通过函数调用传递的值
    2。
- en: Because you have three parameters, you must provide three arguments when you
    call the `speechBubble()` function. The first argument of `190` is assigned to
    parameter `x`, the second argument of `150` is assigned to parameter `y`, and
    so on, in the same order the parameters appear in the `def` line. These are called
    *positional arguments* because the order of the arguments determines which values
    are assigned to each parameter ([Figure 9-3](#figure9-3)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你有三个参数，所以在调用 `speechBubble()` 函数时必须提供三个参数。第一个参数 `190` 被赋值给参数 `x`，第二个参数 `150`
    被赋值给参数 `y`，依此类推，按照参数在 `def` 行中出现的顺序。这些被称为*位置参数*，因为参数的顺序决定了每个参数所分配的值（[图 9-3](#figure9-3)）。
- en: '![f09003](image_fi/500969c09/f09003.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/500969c09/f09003.png)'
- en: 'Figure 9-3: Positional arguments'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：位置参数
- en: Run the sketch to confirm that the visual result is unchanged. Try testing different
    arguments to change the appearance of the speech bubble.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图以确认视觉效果没有变化。尝试测试不同的参数来改变语音气泡的外观。
- en: 'Call a second `speechBubble()` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调用第二个 `speechBubble()` 函数：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first and second (x and y) arguments position the speech bubble above the
    dog. The third argument specifies that the caption must read, “Woof” ([Figure
    9-4](#figure9-4)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个（x 和 y）参数将语音气泡定位在狗的上方。第三个参数指定标题必须为“汪汪”（[图 9-4](#figure9-4)）。
- en: '![f09004](image_fi/500969c09/f09004.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](image_fi/500969c09/f09004.png)'
- en: 'Figure 9-4: A second speech bubble'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：第二个语音气泡
- en: You now have a working `speechBubble()` function that accepts positional arguments.
    However, you can also call this function by using arguments in an arbitrary order
    if you use keyword arguments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个可以接受位置参数的 `speechBubble()` 函数。然而，如果你使用关键字参数，你也可以按任意顺序调用此函数。
- en: Using Keyword Arguments
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用关键字参数
- en: 'When you call a function, you can state explicitly which value belongs to which
    parameter by using *keyword arguments*. These arguments include both a keyword
    and value. Each keyword takes its name from a parameter in the function definition.
    Consider this example, where both lines produce the same result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，可以通过使用*关键字参数*明确指定每个值对应的参数。这些参数包括一个关键字和一个值。每个关键字的名称来自函数定义中的参数。考虑以下示例，其中两行代码产生相同的结果：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first `speechBubble()` call employs a positional argument approach. The
    second call uses keyword arguments; notice that each value has a keyword in front
    of it. Python uses the keywords in your function call to match values and parameters
    ([Figure 9-5](#figure9-5)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `speechBubble()` 调用使用了位置参数方法。第二个调用使用了关键字参数；注意每个值前面都有一个关键字。Python 使用你在函数调用中的关键字来匹配值和参数（[图
    9-5](#figure9-5)）。
- en: '![f09005](image_fi/500969c09/f09005.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](image_fi/500969c09/f09005.png)'
- en: 'Figure 9-5: Keyword arguments'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：关键字参数
- en: This means you can order the arguments in your function call however you please.
    Just be sure to name your keywords exactly the same as the parameters in the function
    definition.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以随意排列函数调用中的参数顺序。只要确保你的关键字与函数定义中的参数名称完全一致。
- en: Setting Default Values
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认值
- en: When you define a function, you can specify a *default value* for each parameter,
    which is like a backup Python can use if you leave out an argument in your function
    call. This behavior is useful for defining optional arguments. For example, the
    `rect()` function can accept an optional fifth argument for the corner radius.
    If you call the `rect()` function with four arguments, you get a rectangle with
    90-degree corners, which is what users seem to want more often than not. But,
    if you provide the fifth argument (of something other than zero), you get a rectangle
    with rounded corners.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个函数时，可以为每个参数指定一个*默认值*，如果你在函数调用时省略了某个参数，Python 就会使用这个备份值。这种行为对于定义可选参数很有用。例如，`rect()`
    函数可以接受一个可选的第五个参数，用于设置圆角半径。如果你调用 `rect()` 函数时只传入四个参数，默认会得到一个具有 90 度角的矩形，这是用户通常更常见的需求。但是，如果你提供第五个参数（值为非零的其他数值），你将得到一个带圆角的矩形。
- en: 'Use an equal sign to assign a default value to a parameter. For example, the
    following adds a default value of `''Hello''` to your `txt` parameter:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等号为参数指定默认值。例如，下面的代码为 `txt` 参数添加了默认值 `'Hello'`：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The default `txt` parameter is a string, but you can use any data type you like,
    including numbers and lists.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `txt` 参数是一个字符串，但你可以使用任何你喜欢的数据类型，包括数字和列表。
- en: 'You can now call the `speechBubble()` function using two positional arguments,
    leaving `txt` (the third argument) to rely on its default value:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用两个位置参数来调用 `speechBubble()` 函数，让 `txt`（第三个参数）使用默认值：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `445` and `125` are positional arguments for `x` and `y`. As there’s no
    third argument, `txt` defaults to `'Hello'`, as per the function definition. The
    result ([Figure 9-6](#figure9-6)) is a speech bubble positioned above the woman’s
    head that reads, “Hello.”
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`445` 和 `125` 是 `x` 和 `y` 的位置参数。由于没有第三个参数，`txt` 默认为 `''Hello''`，如函数定义所示。结果（[图
    9-6](#figure9-6)）是一个位于女性头顶上的对话框，内容为“Hello”。'
- en: '![f09006](image_fi/500969c09/f09006.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](image_fi/500969c09/f09006.png)'
- en: 'Figure 9-6: Drawing a speech bubble using the default `txt` parameter, `Hello`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：使用默认的 `txt` 参数（即 `Hello`）绘制一个对话框
- en: 'To replace *Hello* with *Meh*, call the `speechBubble()` function using three
    arguments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 *Hello* 替换为 *Meh*，请使用三个参数调用 `speechBubble()` 函数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because you provided the positional argument for the `txt` parameter, the woman’s
    speech bubble will now read, “Meh.”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你为 `txt` 参数提供了位置参数，所以该女性的对话框现在会显示“Meh”。
- en: The lady clearly isn’t overly impressed with her partner’s hat, so she might
    choose not to risk offending him. A *thought bubble* could be more appropriate
    ([Figure 9-7](#figure9-7)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那位女士显然对她伴侣的帽子并不十分印象深刻，所以她可能不想冒犯他。此时使用*思考气泡*可能更为合适（[图 9-7](#figure9-7)）。
- en: '![f09007](image_fi/500969c09/f09007.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](image_fi/500969c09/f09007.png)'
- en: 'Figure 9-7: A speech bubble (left) and a thought bubble (right)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：一个对话框（左）和一个思考气泡（右）
- en: To draw a thought bubble, modify the `speechBubble()` function to draw a chain
    of small circles instead of a triangular tail. However, you want the `speechBubble()`
    function to depict speech bubbles by default, as they are more common than thought
    bubbles.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制思维气泡，请修改 `speechBubble()` 函数，以绘制一串小圆圈，而不是三角形尾巴。然而，你希望 `speechBubble()` 函数默认绘制语音气泡，因为语音气泡比思维气泡更常见。
- en: 'Add an additional `type` parameter to the function definition:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 向函数定义中添加一个额外的 `type` 参数：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you have two parameters with default values. Notice that these come after
    the parameters with no default values. If you’re defining any function with default
    values, place those parameters at the end of the list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个带默认值的参数。注意，这些参数位于没有默认值的参数之后。如果你定义任何带默认值的函数，应该将这些参数放在列表的末尾。
- en: 'The next step is to modify the function body, specifically the section beneath
    the `tail` comment. The `type` parameter must determine whether Processing should
    draw a triangular tail or a chain of circles. Modify the code as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改函数体，特别是 `tail` 注释下方的部分。`type` 参数必须决定 Processing 是否绘制三角形尾巴或一串圆圈。修改代码如下：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `if` statement code will draw a triangular tail if the `type` parameter
    is equal to `''speech''`, the default value assigned in the function definition.
    The `elif` statement will draw a chain of two circles whenever the function call
    includes a `type` argument of `''thought''`. Edit your function call to see this
    in action:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `type` 参数等于 `'speech'`（函数定义中分配的默认值），`if` 语句代码将绘制一个三角形尾巴。每当函数调用中包含 `type`
    参数为 `'thought'` 时，`elif` 语句将绘制一串两个圆圈。编辑你的函数调用，看看效果：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `thought` argument switches the `speechBubble()` function to “thought bubble
    mode.” If you omit this argument, the function defaults to drawing the speech
    bubble with the tail. Run the sketch to confirm that the result matches [Figure
    9-7](#figure9-7).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`thought` 参数将 `speechBubble()` 函数切换到“思维气泡模式”。如果省略此参数，函数将默认绘制带尾巴的语音气泡。运行草图以确认结果与[图
    9-7](#figure9-7)一致。'
- en: Mixing Positional and Keyword Arguments
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合位置参数和关键字参数
- en: 'You can use positional arguments for your `x` and `y` coordinates, leave out
    the `txt` argument, and include a keyword argument for `type`. This way, Python
    can utilize the default value for `txt` (`''Hello''`), but render it in a thought
    bubble. As an example, you might want to replace the dog’s speech bubble with
    a thought bubble that reads, “Hello.” One option is to include a third argument
    of `''Hello''` explicitly in the function call—a fully positional approach. For
    example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用位置参数来传递 `x` 和 `y` 坐标，省略 `txt` 参数，并为 `type` 添加一个关键字参数。这样，Python 可以使用 `txt`
    的默认值（`'Hello'`），但将其渲染为思维气泡。例如，你可能想将狗的语音气泡替换为一个写着“Hello”的思维气泡。一个选项是明确地在函数调用中包含
    `'Hello'` 作为第三个参数——完全的定位方式。例如：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each argument here corresponds to a parameter. This seems redundant, though,
    given that `''Hello''` is the default value for parameter 3\. If you just omit
    the `''Hello''` argument in your function call, Processing will draw a *speech*
    bubble with the word *thought* in it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的每个参数都对应一个参数。尽管如此，这看起来有些多余，因为 `'Hello'` 已经是第三个参数的默认值。如果你在函数调用中省略 `'Hello'`
    参数，Processing 将绘制一个带有 *thought* 字样的 *speech* 气泡：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Recall that the third positional argument is for the `txt` parameter and that
    leaving out the fourth argument means Python has to adopt the default value for
    the fourth `type` parameter (speech bubble mode). A simple solution to this problem
    exists, however; use a keyword argument instead of relying on a positional argument:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，第三个位置参数是 `txt` 参数，省略第四个参数意味着 Python 必须采用第四个 `type` 参数的默认值（语音气泡模式）。不过，这个问题有一个简单的解决方案；使用关键字参数，而不是依赖位置参数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, you’ve explicitly stated that the value `'thought'` belongs to
    the `type` parameter. You might notice that you can arrange the arguments in any
    order if you use keyword arguments for every value. This is true, so decide what
    combination of positional and keyword arguments works best in a particular situation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你明确地声明了值 `'thought'` 属于 `type` 参数。你可能会注意到，如果你对每个值都使用关键字参数，那么可以以任何顺序排列参数。这是正确的，所以根据具体情况决定最适合的混合位置参数和关键字参数组合。
- en: If you’re missing one or many required arguments in a function call, Processing
    displays an error message ([Figure 9-8](#figure9-8)). For example, if you call
    the `speechBubble()` function with no arguments, the error message indicates that
    you require at least two.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数调用中缺少一个或多个必需的参数，Processing 会显示错误信息（[图 9-8](#figure9-8)）。例如，如果你调用`speechBubble()`函数时没有任何参数，错误信息会显示你至少需要两个参数。
- en: '![f09008](image_fi/500969c09/f09008.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f09008](image_fi/500969c09/f09008.png)'
- en: 'Figure 9-8: An error message for missing arguments'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8：缺少参数的错误信息
- en: If you provide too many arguments, the error message indicates that `speechBubble()`
    takes at most four arguments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供了太多参数，错误信息会显示`speechBubble()`函数最多只接受四个参数。
- en: Returning Values
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: You can use a function to operate on data and then have it *return* the result
    to the main program. This is different from the functions you’ve created so far,
    which execute a predefined section of code before resuming the regular flow of
    the main program.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个函数来处理数据，然后让它*返回*结果给主程序。这与到目前为止你创建的函数不同，后者执行预定义的代码块后，才会恢复主程序的正常流程。
- en: 'To help explain this difference, here’s some code to contrast a function that
    returns a value with one that does not:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解释这个区别，这里有一些代码，用来对比一个返回值的函数和一个不返回值的函数：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Two Processing functions are in use here: `random()` and `square()`. The first
    one returns a value; the second does not. The `random()` function generates a
    floating-point value ranging from 0 up to but not including 100\. The random function
    *returns* the value, which is assigned to a variable named `x`. The `square()`
    function draws a square in the display window; it does not return a value.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了两个 Processing 函数：`random()` 和 `square()`。第一个函数返回一个值；第二个函数则不返回值。`random()`函数生成一个从
    0 到但不包括 100 的浮动值。`random()`函数*返回*该值，并将其分配给一个名为`x`的变量。`square()`函数在显示窗口中绘制一个正方形；它不返回值。
- en: 'To define your own function that returns a value, use the `return` keyword.
    As an example, create a new function named `shout()`. This function accepts a
    single string argument, and then converts this string to uppercase and adds three
    exclamation marks to the end. Enter the following code above your `speechBubble()`
    calls to ensure that the `shout()` definition precedes any `shout()` function
    call:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个返回值的函数，使用`return`关键字。举个例子，创建一个新的名为`shout()`的函数。这个函数接受一个字符串参数，然后将该字符串转换为大写并在结尾加上三个感叹号。将以下代码输入到`speechBubble()`调用之前，以确保`shout()`定义位于任何`shout()`函数调用之前：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `return` line, the `upper()` method converts the string assigned to `txt`
    to uppercase; the final result is a concatenation of this and three exclamation
    marks. Once Python processes the `return` statement, it exits the function immediately.
    In other words, if you add any further code to the `shout()` definition below
    the `return` line, Python ignores it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句中，`upper()`方法将分配给`txt`的字符串转换为大写；最终结果是该字符串与三个感叹号的拼接。一旦 Python 处理了`return`语句，它会立即退出函数。换句话说，如果你在`return`语句下面的`shout()`定义中添加任何其他代码，Python
    会忽略它。
- en: 'You could use this function to add emphasis to the text in any speech bubble.
    Here’s an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个函数在任意对话框中的文本上添加强调。以下是一个示例：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `shout()` function converts the string to “CHECK OUT MY HAT!!!” before it’s
    passed to the `speechBubble()` function. This wraps the argument with `shout()`
    to avoid having to create an intermediate variable, which you would then pass
    to the `speechBubble()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`shout()`函数将字符串转换为“CHECK OUT MY HAT!!!”之后，才会传递给`speechBubble()`函数。这将`shout()`函数包装在参数中，避免了创建中间变量的需要，之后你可以将其传递给`speechBubble()`函数。'
- en: This was a simple example to introduce how the `return` keyword works. Many
    functions that return values perform more complex tasks, like Processing’s `sqrt()`
    function that calculates the square root of any number.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，用来介绍`return`关键字的作用。许多返回值的函数执行更复杂的任务，例如 Processing 的`sqrt()`函数，它计算任意数字的平方根。
- en: Defining Functions for Periodic Motion
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义周期运动的函数
- en: In this section, you’ll learn how to simulate periodic motion in Processing
    by defining functions that employ trigonometry to draw circular patterns and waves.
    In physics, *periodic motion* is motion that repeats itself at regular intervals,
    such as a swinging pendulum, waves moving through water, or the moon orbiting
    the Earth. A *cycle* is one complete repetition of the motion. The *period* is
    the time it takes to complete a cycle. The period for the moon’s orbit of the
    Earth is roughly 27.3 days; the second hand of a clock has a period of 60 seconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何通过定义使用三角函数的函数来模拟Processing中的周期性运动，以绘制圆形图案和波动。在物理学中，*周期性运动*是指以规律间隔重复的运动，例如摆动的钟摆、水中传播的波浪，或者围绕地球运动的月亮。*周期*是完成一个运动循环所需的时间。月球绕地球的轨道周期大约为27.3天；时钟的秒针周期为60秒。
- en: '*Trigonometry*, or *trig*, is a branch of mathematics that studies triangles
    and uses various mathematical functions, such as sine and cosine, to calculate
    angles and distances. It also has applications in many fields of programming.
    For instance, games that incorporate physics must continuously calculate the position
    and speed of objects in motion, and those calculations involve triangles.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*三角学*，或称*三角函数*，是数学的一个分支，研究三角形，并使用各种数学函数，如正弦和余弦，来计算角度和距离。它在许多编程领域也有应用。例如，包含物理的游戏必须不断计算运动中物体的位置和速度，这些计算涉及三角形。'
- en: Trig is also useful for controlling steering and aiming behavior. For example,
    if you know the x-y coordinates of the player and enemy turret in [Figure 9-9](#figure9-9),
    you can calculate how to rotate the enemy gun to aim it at the player.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数在控制方向和瞄准行为方面也非常有用。例如，如果你知道[图9-9](#figure9-9)中玩家和敌人炮塔的x-y坐标，你可以计算出如何旋转敌人炮塔以瞄准玩家。
- en: You’ll use right triangles to calculate points along the circumference of a
    circle, using sine and cosine functions. The coordinates for those points are
    what you use to simulate smooth, periodic motion.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用直角三角形，通过正弦和余弦函数来计算圆周上的点。这些点的坐标就是你用来模拟平滑周期性运动的基础。
- en: '![f09009](image_fi/500969c09/f09009.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![f09009](image_fi/500969c09/f09009.png)'
- en: 'Figure 9-9: If only the enemy turret had listened in math class.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9：如果敌人炮塔在数学课上听讲就好了。
- en: 'Create a new sketch and save it as *periodic_motion*. Add the following code
    to set up the drawing space:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的草图并将其保存为*periodic_motion*。添加以下代码来设置绘图空间：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code structures an animated sketch by using `setup()` and `draw()`
    functions with two (pale blue) lines that intersect at the center of the display
    window. The y-axis is flipped, so y-coordinates decrease as you move downward;
    I’ll elaborate on why I did that soon. The final `translate()` function shifts
    the coordinate system so that the origin (0, 0) sits in the center of the display
    window. This means that the x-coordinate for the left edge of the display window
    is –400, and the x-coordinate for the right edge is 400\. The y-coordinate for
    the top edge is 300; for the bottom edge, it’s –300 ([Figure 9-10](#figure9-10)).
    The modified coordinate space, with its flipped y-axis, now behaves like a regular
    *Cartesian plane*, with four quadrants that allow you to plot any x-y coordinates
    ranging between (–400, –300) and (400, 300).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过使用`setup()`和`draw()`函数，结构化了一个动画草图，其中有两条（淡蓝色的）线条在显示窗口的中心交汇。y轴被翻转，所以y坐标随着向下移动而减少；我稍后会详细解释为什么这样做。最后的`translate()`函数将坐标系统移位，使原点（0,
    0）位于显示窗口的中心。这意味着显示窗口左边缘的x坐标是–400，右边缘的x坐标是400，顶部边缘的y坐标是300，底部边缘的y坐标是–300（见[图9-10](#figure9-10)）。修改后的坐标空间，带有翻转的y轴，现在像一个常规的*笛卡尔平面*，拥有四个象限，允许你绘制任何范围在（–400,
    –300）和（400, 300）之间的x-y坐标。
- en: You’ve likely encountered this system in math classes before, which is why I’ve
    set up the coordinate space this way. You’ll use it as a platform to experiment
    with elliptical and wave motion, but first, you may require a brief refresher
    on trigonometric functions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在数学课上遇到过这种系统，这也是我以这种方式设置坐标空间的原因。你将把它作为一个平台，来实验椭圆运动和波动运动，但首先，你可能需要简要复习一下三角函数。
- en: '![f09010](image_fi/500969c09/f09010.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![f09010](image_fi/500969c09/f09010.png)'
- en: 'Figure 9-10: The Cartesian plane with four quadrants'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10：带有四个象限的笛卡尔平面
- en: An Introduction to Trigonometric Functions
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三角函数介绍
- en: '*Sine*, *cosine*, and *tangent* are three common *trigonometric functions*.
    These are mathematical (as opposed to programming) functions, but you can use
    them in Python thanks to Processing’s built-in trig functions. Sin, cos, and tan—as
    they are often abbreviated—are based on ratios obtained from a right triangle
    ([Figure 9-11](#figure9-11)). A *right triangle* (or *right-angled triangle*)
    has one angle that measures exactly 90 degrees, usually denoted by a small square.
    The θ symbol, *theta*, is commonly used to represent an unknown angle.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*正弦*、*余弦*和*正切*是三种常见的*三角函数*。这些是数学（而非编程）函数，但你可以通过Processing的内置三角函数在Python中使用它们。sin、cos和tan—它们通常的缩写—是基于从直角三角形中得到的比值（见[图9-11](#figure9-11)）。*直角三角形*（或*直角三角形*）有一个角度恰好为90度，通常用一个小方块表示。θ符号，*theta*，通常用来表示未知角度。'
- en: '![f09011](image_fi/500969c09/f09011.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![f09011](image_fi/500969c09/f09011.png)'
- en: 'Figure 9-11: A right triangle'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-11：一个直角三角形
- en: 'You can calculate the size of theta if you know the lengths of any two sides
    of this triangle. Depending on the lengths you have, you’ll use either sin, cos,
    or tan for the calculation. *SOHCAHTOA*, pronounced phonetically as *so-ka-toe-uh*,
    is a handy mnemonic device to help you remember the following trigonometric ratios:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道这个三角形的任意两条边的长度，你可以计算出θ的大小。根据你掌握的边长，你将使用sin、cos或tan来进行计算。*SOHCAHTOA*，按发音规则为*so-ka-toe-uh*，是一个方便的助记法，帮助你记住以下三角比率：
- en: SOH sin(θ) = opposite / hypotenuse
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOH sin(θ) = 对边 / 斜边
- en: CAH cos(θ) = adjacent / hypotenuse
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAH cos(θ) = 邻边 / 斜边
- en: TOA tan(θ) = opposite / adjacent
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TOA tan(θ) = 对边 / 邻边
- en: As an example, if you know the length of the opposite and hypotenuse in [Figure
    9-11](#figure9-11), you can find angle theta by using sin(θ). If you know the
    length of the adjacent and hypotenuse, use cos(θ). You can also rearrange these
    equations to find the length of an unknown side in cases when you know theta and
    one length. I’ll return to this point shortly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，如果你知道[图9-11](#figure9-11)中对边和斜边的长度，你可以通过使用sin(θ)来求得角度θ。如果你知道邻边和斜边的长度，使用cos(θ)。你也可以重新排列这些方程式，在已知θ和某个边长的情况下，求出未知边的长度。我稍后会再提到这一点。
- en: 'You’ll apply sin and cos to a simple example to determine an x-y coordinate
    along the perimeter of a circle. To begin, draw a circle with its center positioned
    at (0, 0) with a radius of 200\. Add a line starting at (0, 0) that’s the same
    length as the circle radius and rotated 1 radian:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你将应用sin和cos来解决一个简单的例子，计算沿着圆周的x-y坐标。首先，画一个圆，圆心位于(0, 0)，半径为200。添加一条从(0, 0)开始的线段，长度与圆的半径相同，并旋转1弧度：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code renders the circle in a pale blue outline. A white line the length
    of the radius extends from the center of the circle to its perimeter; this forms
    an angle of 1 radian (equal to roughly 57.3 degrees), as labeled in [Figure 9-12](#figure9-12).
    Notice that the `rotate()` function applies counterclockwise to the line because
    the y-axis is inverted. The task is to work out the x-y coordinate for the point
    where the white line connects to the circle perimeter, labeled A. The other yellow
    markings reveal the right triangle upon which you’ll base your calculations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将圆形呈现为淡蓝色的轮廓。一个白色的线段从圆心延伸到圆周，长度为半径；这形成了一个1弧度（大约等于57.3度）的角度，如[图9-12](#figure9-12)所示。注意，`rotate()`函数应用于线条时是逆时针方向，因为y轴是反向的。任务是计算白线与圆周相接的点A的x-y坐标。其他黄色标记揭示了你将基于其进行计算的直角三角形。
- en: '![f09012](image_fi/500969c09/f09012.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![f09012](image_fi/500969c09/f09012.png)'
- en: 'Figure 9-12: You’ll find the x-y coordinate for the point labeled A.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12：你将找到标记为A的点的x-y坐标。
- en: Observe that the y-coordinate for point A is equal to the length (or height)
    of the opposite side. You know the angle (`theta` variable) and the length of
    the hypotenuse (`radius`), which you can use to calculate the length of the opposite.
    Recall that the *SOH* in *SOHCAHTOA* stands for *sin(*θ*) = opposite / hypotenuse*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到A点的y坐标等于对边的长度（或高度）。你知道角度（`theta`变量）和斜边的长度（`radius`），你可以用它们来计算对边的长度。记住，*SOH*在*SOHCAHTOA*中表示*sin(*θ*)
    = 对边 / 斜边*。
- en: 'You have the values for θ and hypotenuse, so rearrange the equation to isolate
    opposite: *opposite = sin(*θ*) × hypotenuse.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道θ和斜边的值，所以重新排列方程以求出对边：*对边 = sin(*θ*) × 斜边*。
- en: If you substitute the placeholders with the variable names in your program,
    this is `y = sin(theta) * radius`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用程序中的变量名替换占位符，这是`y = sin(theta) * radius`。
- en: To calculate the x-coordinate for point A, you need to find the length (or width)
    of the adjacent side. Recall that the *CAH* in *SOHCAHTOA* stands for *cos(*θ*)
    = adjacent / hypotenuse*, which you can rearrange as `x = cos(theta) * radius`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算 A 点的 x 坐标，你需要找出相邻边的长度（或宽度）。回想一下，*SOHCAHTOA* 中的 *CAH* 表示 *cos(*θ*) = adjacent
    / hypotenuse*，你可以将其重新排列为 `x = cos(theta) * radius`。
- en: 'Add the following code to the end of your `draw()` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `draw()` 函数的末尾：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `cos()` and `sin()` functions return floating-point values ranging from
    –1 to 1 for various values of `theta`. Processing’s trig functions work with radians,
    so there’s no need to convert the `theta` argument to degrees. In this case, theta
    is equal to 1 radian, and the `cos()` and `sin()` functions return values of 0.54
    and 0.84, respectively (rounded to two decimal places). When you multiply 0.54
    and 0.84 by the `radius` value of 200, you get an x-y coordinate of (108, 168).
    The `circle(x, y, 15)` function renders a white dot by using this x-y coordinate
    pair. Run the sketch to confirm the position of the white dot at point A, where
    the white line connects to the circle boundary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`cos()` 和 `sin()` 函数返回浮动值，范围从 –1 到 1，适用于不同的 `theta` 值。Processing 的三角函数使用弧度制，因此不需要将
    `theta` 参数转换为度数。在这个例子中，`theta` 等于 1 弧度，`cos()` 和 `sin()` 函数分别返回 0.54 和 0.84 的值（四舍五入到小数点后两位）。当你将
    0.54 和 0.84 乘以半径值 200 时，你会得到一个 x-y 坐标（108, 168）。`circle(x, y, 15)` 函数通过这个 x-y
    坐标对渲染一个白色点。运行草图，确认白色点位于 A 点位置，即白色线条连接到圆周边界的地方。'
- en: You can adjust the theta value to move the white dot to different points along
    the perimeter of the pale blue circle. To position the dot at 90 degrees, directly
    above the origin, use `theta = HALF_PI`; for 180 degrees, use `theta = PI`; and
    so forth. A `theta` value of `TAU` brings you back around to the starting point,
    visually indistinguishable from a dot at `theta = 0`. If `theta` is greater than
    `TAU`, there’s a wraparound effect. In other words, `cos(TAU+1)` is equivalent
    to `cos(1)`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整 `theta` 值，将白色点移动到淡蓝色圆周上的不同点。要将点定位在原点正上方的 90 度位置，使用 `theta = HALF_PI`；要定位在
    180 度位置，使用 `theta = PI`；以此类推。`theta` 值为 `TAU` 会让你回到起始点，在视觉上与 `theta = 0` 的点无区别。如果
    `theta` 大于 `TAU`，则会发生环绕效果。换句话说，`cos(TAU+1)` 等同于 `cos(1)`。
- en: The next task is to get the dot moving. You don’t need the white line anymore;
    remove it by deleting the lines starting from `pushMatrix()` up to and including
    `popMatrix()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是让点开始移动。你不再需要白色线条；通过删除从 `pushMatrix()` 开始直到包括 `popMatrix()` 的代码来去除它。
- en: Circular and Elliptical Motion
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 圆形与椭圆形运动
- en: You’ll begin by moving the dot along a circle perimeter (a circular motion),
    and you’ll create a user-defined function for handling the necessary math. You’ll
    then use this same function to create a spiral variant of the circular motion.
    Once you have the circular and spiral motions working, you’ll define a new function
    for elliptical motion. [Figure 9-13](#figure9-13) depicts examples of each motion.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从沿着圆周移动点开始（即圆周运动），并创建一个用户定义的函数来处理必要的数学运算。然后，你将使用这个相同的函数来创建圆形运动的螺旋变体。完成圆形和螺旋运动后，你将定义一个新的函数来实现椭圆运动。[图
    9-13](#figure9-13) 展示了每种运动的示例。
- en: '![f09013](image_fi/500969c09/f09013.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![f09013](image_fi/500969c09/f09013.png)'
- en: 'Figure 9-13: Circular (left), spiral (middle), and elliptical (right) motion'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-13：圆形（左）、螺旋形（中）和椭圆形（右）运动
- en: Circles
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 圆形
- en: 'Recall that the size of angle theta, stored in a variable named `theta`, governs
    the position of the white dot. To make the dot move along the perimeter of the
    circle in a counterclockwise direction, add code to increment theta each time
    the draw function executes. Include a `period` variable to control the increment
    size:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，存储在名为 `theta` 的变量中的角度大小决定了白色点的位置。为了让点沿圆周逆时针方向移动，添加代码每次执行 `draw` 函数时递增 `theta`。包括一个
    `period` 变量来控制增量大小：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the default `frameRate` of 60 fps, with a `period` of 2.1 seconds, the `theta`
    increment is equal to approximately 0.05 1. This means your angle extends 0.05
    of a radian with each new frame. Run the sketch to test this out. The white dot
    should take about 2.1 seconds to complete a lap of the circle perimeter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的 `frameRate` 为 60 fps，`period` 为 2.1 秒的情况下，`theta` 的增量大约是 0.05 1。这意味着每一帧，角度会延伸
    0.05 弧度。运行草图来测试这一点。白色点应该在大约 2.1 秒内完成一圈圆周。
- en: The larger the value you add to theta, the faster the dot will move. Subtracting
    from theta moves the dot in the opposite direction (clockwise).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你增加theta的值时，点移动得越快。减小theta值会使点向相反方向（顺时针）移动。
- en: 'Define a new function named `circlePoint()` for calculating points along the
    perimeter of a circle. In your `draw()` function, substitute the `x` and `y` lines
    with a `circlePoint()` function call:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`circlePoint()`的新函数，用于计算圆周上的点。在你的`draw()`函数中，将`x`和`y`的代码行替换为`circlePoint()`函数调用：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `circlePoint()` definition includes two parameters: `t` for theta (the
    angle) and `r` for the radius. Because the function must calculate the x- and
    y-coordinates for some point along a circle perimeter, it needs to return two
    values. Use a list to return more than one value 1; you could also use a dictionary
    (or a tuple).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`circlePoint()`的定义包括两个参数：`t`表示theta（角度），`r`表示半径。由于该函数需要计算圆周上一些点的x和y坐标，因此它需要返回两个值。使用列表来返回多个值；你也可以使用字典（或元组）。'
- en: When you call the function, Python can *unpack* the list values and assign them
    to multiple variables. To invoke this unpacking behavior, provide a corresponding
    variable for each list item, separating each variable with a comma. In this case,
    the function returns a list of two values, which are assigned to variables `x`
    and `y` 2. Alternatively, you could assign the list to a single variable using
    something like `a = circlePoint(theta, radius)`, but then you’d have to refer
    to `x` and `y` by using `a[0]` and `a[1]`, respectively, which isn’t as neat or
    descriptive.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用该函数时，Python可以*解包*列表中的值并将其赋值给多个变量。为了触发这种解包行为，需要为每个列表项提供相应的变量，并用逗号分隔每个变量。在这种情况下，函数返回一个包含两个值的列表，这些值分别赋给变量`x`和`y`。另外，你也可以将列表赋给一个变量，如`a
    = circlePoint(theta, radius)`，但这时你必须通过`a[0]`和`a[1]`来引用`x`和`y`，这种方式不如前者简洁或直观。
- en: Spirals
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 螺旋
- en: 'For an outward spiral motion (the center image in [Figure 9-13](#figure9-13)),
    you can use a radius value that increases over time. Here’s an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向外螺旋的运动（见[图9-13](#figure9-13)中的中心图像），你可以使用随时间增加的半径值。以下是一个例子：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Recall that `frameCount` is a system variable containing the number of frames
    displayed since starting the sketch. The radius argument (the `frameCount`) begins
    at 0 and grows larger as the animation progresses, causing the dot to move outward
    in a spiral motion. The dot gains speed as it moves away from the center of the
    display window because each full rotation maintains the same period, regardless
    of the `circlePoint()` radius. In other words, the dot must cover a larger distance
    in the same time, so it moves faster.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`frameCount`是一个系统变量，包含自开始绘制以来显示的帧数。半径参数（`frameCount`）从0开始，随着动画的进展逐渐增大，导致点在螺旋轨迹上向外移动。由于每一次完整的旋转保持相同的周期，无论`circlePoint()`的半径如何，点在远离显示窗口中心时会加速。换句话说，点必须在相同的时间内覆盖更大的距离，因此它移动得更快。
- en: Ellipses
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 椭圆
- en: 'For an elliptical motion, you need two radii: one for the horizontal axis and
    one for the vertical axis. These radii control the width and height of the ellipse
    shape that guides the white dot’s trajectory (see the right image in [Figure 9-13](#figure9-13)).
    Define a new `ellipsePoint()` function with parameters for an angle, horizontal
    radius, and vertical radius:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于椭圆轨迹，你需要两个半径：一个用于水平轴，另一个用于垂直轴。这些半径控制椭圆形状的宽度和高度，从而指导白点的运动轨迹（见[图9-13](#figure9-13)右图）。定义一个新的`ellipsePoint()`函数，参数包括角度、水平半径和垂直半径：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function body is similar to that of the `circlePoint()` function. The difference
    is that you multiply the `x` and `y` values by the `hr` (horizontal-radius) and
    `vr` (vertical-radius) parameters, respectively.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体与`circlePoint()`函数类似。不同之处在于，你需要分别将`x`和`y`值乘以`hr`（水平半径）和`vr`（垂直半径）参数。
- en: 'The following `ellipsePoint()` function call makes the dot move in an elliptical
    motion:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`ellipsePoint()`函数调用使得点在椭圆轨迹上移动：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ellipsePoint()` function’s second argument (horizontal radius) is larger
    than the third argument (vertical radius), so the resulting ellipse is wider than
    it is tall.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ellipsePoint()`函数的第二个参数（水平半径）大于第三个参数（垂直半径），因此得到的椭圆在水平方向上比垂直方向更宽。'
- en: Sine Waves
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正弦波
- en: A *sine wave* is a geometric waveform that repeats itself periodically, like
    a continuous chain of S-shaped curves connected end to end. This waveform features
    in many mathematical and physical applications. For example, you can use sine
    waves to model musical tones, radio waves, tides, and electrical currents.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*正弦波* 是一种几何波形，周期性地重复自身，就像一连串相连的S形曲线。该波形在许多数学和物理应用中都有出现。例如，你可以使用正弦波来模拟音乐音调、电波、潮汐和电流。'
- en: The shape of a sine wave is formed using a `sin()` function. [Figure 9-14](#figure9-14)
    depicts a yellow sine wave.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波的形状是使用 `sin()` 函数形成的。[图 9-14](#figure9-14) 描绘了一个黄色的正弦波。
- en: '![f09014](image_fi/500969c09/f09014.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![f09014](image_fi/500969c09/f09014.png)'
- en: 'Figure 9-14: A sine wave'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-14：正弦波
- en: The *wavelength* is the length of one complete cycle, measured as the distance
    from crest to crest (or trough to trough). Wavelength is related to period, but
    period is a reference to time (taken to complete a cycle), and wavelength is a
    reference to distance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*波长* 是一个完整周期的长度，测量的是从波峰到波峰（或从波谷到波谷）的距离。波长与周期有关，但周期是指时间（完成一个周期所需的时间），而波长是指距离。'
- en: The *amplitude* is the distance from the resting position (y = 0) to the crest.
    A wave with an amplitude of 0 would lie flat along the x-axis. You can determine
    that the yellow wave in [Figure 9-14](#figure9-14) has an amplitude of 200 by
    comparing it to the radius of the pale blue circle.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*振幅* 是从静止位置（y = 0）到波峰的距离。一个振幅为0的波将平铺在x轴上。你可以通过与淡蓝色圆形的半径进行比较，确定[图 9-14](#figure9-14)中的黄色波具有200的振幅。'
- en: 'To simulate sine wave motion, add the following code to your *periodic_motion*
    sketch. This is the same as drawing a circle, but using a fixed x-coordinate:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟正弦波运动，请将以下代码添加到你的 *periodic_motion* 草图中。这与绘制圆形相同，但使用固定的x坐标：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The wave’s `amplitude` is equal to the `radius` of the pale blue circle, although
    you can test any value you like. The y-coordinate for the white dot is calculated
    using `sin(theta)` multiplied by the amplitude; the x-coordinate is always 0\.
    The result is a white dot that moves directly up and down from the origin.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 波的 `振幅` 等于淡蓝色圆形的 `半径`，尽管你可以测试任何你喜欢的数值。白点的y坐标是通过 `sin(theta)` 乘以振幅计算得出的；x坐标始终为0。结果是一个从原点上下移动的白点。
- en: Run the sketch and pay careful attention to how the dot is accelerating and
    decelerating, as if the wave shown in [Figure 9-14](#figure9-14) were passing
    through water with the dot floating on its surface. As the dot approaches a crest
    or trough, it begins to slow down, and then it accelerates after it makes a turn;
    it’s moving fastest as it crosses the y-axis.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图并仔细观察点的加速和减速情况，就像[图 9-14](#figure9-14)中的波形穿过水面，点漂浮在其表面一样。当点接近波峰或波谷时，它开始减速，然后在转弯后加速；它在穿越y轴时移动得最快。
- en: You can use this motion to draw a whole wave of moving dots or to simulate a
    weight hanging from a spring ([Figure 9-15](#figure9-15)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此运动来绘制一整个移动的点波，或者模拟一个挂在弹簧上的重物（[图 9-15](#figure9-15)）。
- en: '![f09015](image_fi/500969c09/f09015.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![f09015](image_fi/500969c09/f09015.png)'
- en: 'Figure 9-15: A wave of dots (left) and a weight hanging from a spring (right)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-15：点阵波（左）和挂在弹簧上的重物（右）
- en: The code for each of these examples follows. You’ll need to add it to the end
    of the `draw()` block of your *periodic_motion* sketch. You can add both code
    listings if you want to draw the spring and weight over the wave of dots, or instead
    replace one listing with the other.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例的代码如下。你需要将其添加到 *periodic_motion* 草图的 `draw()` 块的末尾。如果你想在点阵波形上绘制弹簧和重物，可以添加两个代码列表，或者将其中一个列表替换为另一个。
- en: Drawing a Sine Wave of Dots
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制点状正弦波
- en: 'Use a loop to draw a whole wave of dots. There are 51 dots in all, equally
    spread along the x-axis. Each dot has a different y-coordinate based on a `theta`
    value that’s incrementally larger than the dot preceding it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环绘制一整波点阵。总共有51个点，均匀分布在x轴上。每个点的y坐标基于一个比前一个点更大的 `theta` 值。
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The loop draws 51 dots, beginning at an `x`-coordinate of –400, at x intervals
    of 16 pixels 2. The `y` value for each dot is calculated using a `theta` value
    that’s `0.125 * 2` of a radian (or 0.25) 1 larger than the neighbor to its left.
    You can change this multiplier to `1` for a single wave that spans the width of
    the display window, leave it as `2` for two waves (as in [Figure 9-15](#figure9-15)),
    make it `3` for three waves, and so forth. I’ve named the variable `f`, for *frequency*,
    which refers to the number of times an event repeats itself in a fixed time period.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 循环绘制 51 个点，从 `x` 坐标 -400 开始，x 坐标间隔为 16 像素 2。每个点的 `y` 值通过一个 `theta` 值计算，`theta`
    值是比其左侧邻点大 `0.125 * 2` 弧度（即 0.25）。你可以将该乘数改为 `1`，表示一个波，占据显示窗口的宽度；将其保留为 `2` 表示两个波（如[图
    9-15](#figure9-15)所示），将其改为 `3` 表示三个波，以此类推。我将变量命名为 `f`，表示*频率*，指的是事件在固定时间内重复的次数。
- en: Wavelength is inversely proportional to frequency, so as you increase the frequency,
    you decrease the wavelength (and the waves begin to look spikier). The wave motion
    travels from right to left, but the horizontal positions of the dots don’t change.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 波长与频率成反比，因此随着频率的增加，波长会减小（波形开始变得更加尖锐）。波动从右向左传播，但点的水平位置不会改变。
- en: Simulating a Weight Hanging from a Spring
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟悬挂在弹簧上的重物
- en: 'Use a loop to draw the spring, which is a shape composed of vertices. The weight
    dangling on the end of the spring is a rectangle. Adjust the fill and stroke to
    draw outlines instead of filled shapes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环来绘制弹簧，弹簧是由顶点组成的形状。悬挂在弹簧末端的重物是一个矩形。调整填充和描边以绘制轮廓线，而不是填充形状：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The tight corners of the spring’s bends will produce sharp joints, which result
    in elongated “elbows.” Processing clips these when they get too long and sharp,
    but jumping between *mitered* (sharp) and *beveled* (clipped) joints makes the
    animation look bad. To prevent this, I’ve set the `strokeJoin` to `ROUND`. A loop
    is nested within the `beginShape()` and `endShape()` functions for plotting the
    zigzagging spring vertices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧弯曲的紧角会产生锐利的接头，导致拉长的“肘部”。处理程序会在这些接头过长和过尖时将其裁剪，但在*斜接*（尖锐）和*倒角*（裁剪）接头之间跳跃会使动画看起来很差。为了防止这种情况，我将
    `strokeJoin` 设置为 `ROUND`。在 `beginShape()` 和 `endShape()` 函数内嵌套了一个循环，用于绘制锯齿形弹簧的顶点。
- en: Ordinarily, some energy is dissipated or lost in such a system, and the amplitude
    should decay over time. You could simulate this by reducing the (global) `radius`
    value every frame until it reaches 0, when the weight will come to a rest.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在这样的系统中，一些能量会被耗散或丧失，振幅应该随着时间的推移衰减。你可以通过每一帧减少（全局）`radius` 值来模拟这一点，直到它降到
    0，这时重物将停下来。
- en: Now that you’ve learned how to return values from functions and incorporate
    trigonometry for elliptical and wave animation, let’s look at a special curve
    created by combining waves.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何从函数返回值，并将三角学应用于椭圆和波浪动画，接下来让我们看看通过组合波浪产生的特殊曲线。
- en: Lissajous Curves
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利萨如曲线
- en: In this section, you’ll create a function for drawing Lissajous curves controlled
    by arguments. A *Lissajous curve*—named after French physicist Jules Antoine Lissajous—is
    formed by combining x- and y-coordinates from two waves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，你将创建一个用于绘制由参数控制的利萨如曲线的函数。*利萨如曲线*——以法国物理学家朱尔·安托万·利萨如命名——是通过组合来自两个波的 x
    和 y 坐标形成的。
- en: You can create these curves mechanically by setting up a Y-shaped pendulum with
    a sand-filled cup hanging at the end of it. As the cup swings about, sand drains
    through a hole at the bottom, drawing a curve. [Figure 9-16](#figure9-16) shows
    an example of this device (left) and an image of a curve drawn with sand (right).
    The point labeled *r* indicates where the pendulum merges into a single string.
    The ratio of the upper to lower section of the pendulum, and the angle and power
    of your initial swing, determine the shape of the resulting curve.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过机械方法创建这些曲线，方法是设置一个 Y 形的摆钟，摆钟的末端挂着一个充满沙子的杯子。当杯子摆动时，沙子通过底部的孔流出，绘制出一条曲线。[图
    9-16](#figure9-16)显示了这个装置的一个示例（左）和用沙子绘制的曲线（右）。标有 *r* 的点表示摆钟合并为一根弦的位置。摆钟上部和下部的比例、初始摆动的角度和力量决定了最终曲线的形状。
- en: '![f09016](image_fi/500969c09/f09016.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![f09016](image_fi/500969c09/f09016.png)'
- en: 'Figure 9-16: Blackburn’s Y-shaped pendulum, from *Sound* by John Tyndall, 1879
    (left), and a Lissajous curve drawn with sand (right)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-16：Blackburn 的 Y 形摆钟，出自 John Tyndall 的《声音》，1879 年（左），以及用沙子绘制的利萨如曲线（右）
- en: To begin, suppose that you have two circles of different sizes ([Figure 9-17](#figure9-17)).
    Circle A has a radius labeled A that is 200 units, and Circle B has a radius labeled
    B that is 100 units.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设你有两个大小不同的圆（[图 9-17](#figure9-17)）。圆形 A 的半径为 A，大小为 200 单位，圆形 B 的半径为 B，大小为
    100 单位。
- en: '![f09017](image_fi/500969c09/f09017.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![f09017](image_fi/500969c09/f09017.png)'
- en: 'Figure 9-17: Combining x and y values from different circles to form an ellipse'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-17：将来自不同圆的 x 和 y 值组合形成椭圆
- en: The Result ellipse (lower left) is formed by using x-coordinates from Circle
    A and y-coordinates from Circle B. The ellipse turns out as wide as Circle A and
    as tall as Circle B. The math for this is relatively simple and uses what you
    already know about drawing ellipses with trigonometric functions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结果椭圆（左下角）是通过使用圆形 A 的 x 坐标和圆形 B 的 y 坐标形成的。椭圆的宽度与圆形 A 一样，且高度与圆形 B 一样。这些数学计算相对简单，使用了你已经掌握的三角函数绘制椭圆的知识。
- en: 'To find the x-y coordinate for any point along the perimeter of the Result
    ellipse, you use the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到结果椭圆周长上任何点的 x-y 坐标，你可以使用以下公式：
- en: '*x* = *cos(*θ*)* × *A*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *cos(*θ*)* × *A*'
- en: '*y* = *sin(*θ) × *B*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *sin(*θ) × *B*'
- en: 'Create a new sketch, save it as *lissajous_curves*, and add the following code
    to recreate the ellipse from [Figure 9-17](#figure9-17):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的草图，将其保存为 *lissajous_curves*，并添加以下代码以重现 [图 9-17](#figure9-17) 中的椭圆：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The drawing space is set up like your preceding sketch. You have an inverted
    y-axis, and the origin is shifted to the center of the display window. The `theta`
    value increments by approximately 0.01 each frame, which serves as the first argument
    in the `lissajousPoint()` function call. Right now, this function performs exactly
    the same operation as the `ellipsePoint()` function in your *period_motion* sketch—the
    only difference is the naming of the function and its variables.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图空间的设置与之前的草图相同。你有一个倒置的 y 轴，原点已移至显示窗口的中心。`theta` 值每帧增量大约为 0.01，作为 `lissajousPoint()`
    函数调用中的第一个参数。目前，这个函数执行的操作与你在 *period_motion* 草图中的 `ellipsePoint()` 函数完全相同——唯一的区别是函数名和变量名不同。
- en: Notice that there’s no `background()` call within the `draw()` section of the
    code, so Processing won’t clear each frame. Because of this, the moving white
    dot forms a continuous line. Run the sketch; it should draw a complete ellipse
    in a counterclockwise motion ([Figure 9-18](#figure9-18)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码的 `draw()` 部分没有 `background()` 调用，因此 Processing 不会在每一帧清除画面。因为这个原因，移动的白点形成了一条连续的线条。运行草图，它应该以逆时针方向画出一个完整的椭圆（[图
    9-18](#figure9-18)）。
- en: '![f09018](image_fi/500969c09/f09018.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![f09018](image_fi/500969c09/f09018.png)'
- en: 'Figure 9-18: Drawing an ellipse by using the `ellipsePoint()` function'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-18：使用 `ellipsePoint()` 函数绘制椭圆
- en: When theta reaches τ radians (~6.28), the oval is complete, and Processing continues
    to draw over the existing line. Even though the animation might appear complete,
    the dot is still moving along the perimeter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当 theta 达到 τ 弧度（大约为 6.28）时，椭圆已经完成，而 Processing 继续在现有线条上绘制。即使动画看起来已经完成，点仍在沿着周长移动。
- en: The next step is to modify the `lissajousPoint()` function so that it can draw
    Lissajous curves (as opposed to ellipses). But first, consider what’s happening
    here in terms of waves. Study [Figure 9-19](#figure9-19), which represents each
    circle as a wave, and take note of how the dots on each wave control the position
    of the dot along the ellipse’s perimeter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改 `lissajousPoint()` 函数，以便它能够绘制 Lissajous 曲线（而不是椭圆）。但首先，请考虑在波形方面发生了什么。研究
    [图 9-19](#figure9-19)，它将每个圆表示为一个波形，并注意每个波形上的点如何控制椭圆周长上的点位置。
- en: '![f09019](image_fi/500969c09/f09019.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![f09019](image_fi/500969c09/f09019.png)'
- en: 'Figure 9-19: Circle A and Circle B represented in wave form'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-19：以波形表示的圆形 A 和圆形 B
- en: '[Figure 9-19](#figure9-19) presents the x-coordinates of Circle A as a cosine
    wave that oscillates between –1 and 1, which is scaled by the circle radius (the
    wave amplitude) of A. Similarly, the y-coordinates of Circle B are presented as
    a sine wave with an amplitude of B.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-19](#figure9-19) 展示了圆形 A 的 x 坐标，作为一个余弦波，在 -1 和 1 之间振荡，且由 A 的圆半径（波幅）进行缩放。同样，圆形
    B 的 y 坐标以正弦波的形式呈现，波幅为 B。'
- en: In [Figure 9-20](#figure9-20), you can see how dots move along the waves to
    form the ellipse shape.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-20](#figure9-20) 中，你可以看到点如何沿着波动形成椭圆的形状。
- en: '![f09020](image_fi/500969c09/f09020.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![f09020](image_fi/500969c09/f09020.png)'
- en: 'Figure 9-20: Theta = 2 (left), theta = 3 (middle), theta = 4 (right)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-20：theta = 2（左），theta = 3（中），theta = 4（右）
- en: Currently, the frequencies of both waves match. In other words, it takes the
    same amount of time for each wave to complete a single cycle. The result is an
    ellipse.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，两个波的频率相匹配。换句话说，每个波完成一个周期的时间是相同的。结果是一个椭圆。
- en: Lissajous curves occur when the wave frequencies differ. In [Figure 9-21](#figure9-21),
    the frequency of the Circle B wave is twice that of the Circle A wave. The dot
    following the Circle B wave must complete two cycles in the same amount of time
    that the Circle A dot will complete one. The *a* and *b* values (lowercase) represent
    a frequency of 1 and 2, respectively.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当波的频率不同时，就会出现Lissajous曲线。在[图9-21](#figure9-21)中，Circle B波的频率是Circle A波的两倍。跟随Circle
    B波的点必须在Circle A点完成一个周期的同样时间内完成两个周期。*a*和*b*值（小写）分别表示频率1和2。
- en: '![f09021](image_fi/500969c09/f09021.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![f09021](image_fi/500969c09/f09021.png)'
- en: 'Figure 9-21: The Circle B wave has a frequency twice that of Circle A.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-21：Circle B波的频率是Circle A波的两倍。
- en: 'Frequencies *a* and *b* could be 3 and 6, 40 and 80, or 620 and 1,240\. Any
    pair of numbers with a ratio of 1:2 will produce a ∞ shape. This will be important
    when you return to writing the code. You can think of this in another way as well:
    in [Figure 9-17](#figure9-17), the Circle B dot must always complete two journeys
    around the perimeter in the same amount of time that the Circle A dot completes
    one.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 频率*a*和*b*可以是3和6，40和80，或者620和1240。任何一对1:2的比例数字都会产生一个∞形状。这一点在你返回编写代码时将非常重要。你也可以用另一种方式理解这一点：在[图9-17](#figure9-17)中，Circle
    B点必须总是在Circle A点完成一个周长的同样时间内，完成两个周长的循环。
- en: '[Figure 9-22](#figure9-22) shows how the dots move along the waves to form
    the Lissajous curve.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-22](#figure9-22)展示了点如何沿着波形移动，形成Lissajous曲线。'
- en: 'Adapt your `lissajousPoint()` definition, adding a parameter for frequency
    *a* and frequency *b*. Use these two parameters as multipliers for theta (`t`)
    in your `x` and `y` lines, respectively:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的`lissajousPoint()`定义，添加一个参数表示频率*a*和频率*b*。将这两个参数作为乘数分别作用于`x`和`y`线中的theta（`t`）：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![f09022](image_fi/500969c09/f09022.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![f09022](image_fi/500969c09/f09022.png)'
- en: 'Figure 9-22: From left to right: theta = 2; theta = 3; theta = 4'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-22：从左到右：theta = 2；theta = 3；theta = 4
- en: 'Now, add arguments for parameters `a` and `b` to your function call:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为你的函数调用添加参数`a`和`b`：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the sketch and watch Processing draw a Lissajous curve ([Figure 9-23](#figure9-23)).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图，观察Processing绘制Lissajous曲线（[图9-23](#figure9-23)）。
- en: '![f09023](image_fi/500969c09/f09023.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![f09023](image_fi/500969c09/f09023.png)'
- en: 'Figure 9-23: Drawing a Lissajous curve by using the `lissajousPoint()` function'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-23：通过使用`lissajousPoint()`函数绘制Lissajous曲线
- en: The `a` and `b` arguments determine the number of horizontal and vertical “lobes”
    in the Lissajous curve. Recall that it’s the ratio that matters, so `1`, `2` will
    produce the same curve as `5`, `10`. However, the latter pair will complete drawing
    the curve in less time, and even larger numbers will create discernible spacing
    between the dots (that would otherwise form a solid line). [Figure 9-24](#figure9-24)
    shows the results of a few `a`, `b` arguments. Try experimenting with other numbers.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`和`b`参数决定了Lissajous曲线中的水平和垂直“叶片”的数量。记住，关键在于比例，因此`1`、`2`将产生与`5`、`10`相同的曲线。然而，后者将在更短的时间内完成曲线的绘制，甚至更大的数字会在点之间产生可识别的间距（否则它们会形成一条实线）。[图9-24](#figure9-24)展示了几个`a`、`b`参数的结果。尝试使用其他数字进行实验。'
- en: '![f09024](image_fi/500969c09/f09024.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![f09024](image_fi/500969c09/f09024.png)'
- en: 'Figure 9-24: Drawing Lissajous curves using different `a`, `b` arguments'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-24：使用不同的`a`、`b`参数绘制Lissajous曲线
- en: You can create intriguing visual patterns by moving shapes, points, and lines
    around with trigonometric functions. Simply experimenting, with no predefined
    idea of what you want to accomplish, can lead to impressive visual results. Think
    of this approach to coding like a musical jam session, where instrumentalists
    improvise until they stumble upon something that sounds good.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用三角函数移动形状、点和线，创造出有趣的视觉图案。单纯地实验，没有预设的目标，可能会带来令人印象深刻的视觉效果。可以把这种编程方式看作是一场音乐即兴演奏会，演奏者即兴创作，直到他们偶然发现某种听起来不错的旋律。
- en: The next task uses Lissajous curves and a `line()` function for animated patterns,
    which should provide some interesting ideas for you to riff off.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步任务使用Lissajous曲线和`line()`函数来创建动画图案，这应该会给你提供一些有趣的创意。
- en: Creating Screensaver-Like Patterns with Lissajous Curves
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Lissajous曲线创建类似屏幕保护程序的图案
- en: 'In Chapter 6, you programmed a simple DVD screensaver; now let’s create a more
    elaborate one using Lissajous curves. The original purpose of a screensaver was
    to “save” your screen. Older cathode-ray tube (CRT) monitors were susceptible
    to *burn-in*: if you displayed the same graphic in the same position for too long,
    it would leave a permanent “ghost” image. Modern displays aren’t susceptible to
    burn-in, but many people still use screensavers because they look cool.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，你编写了一个简单的DVD屏幕保护程序；现在让我们使用Lissajous曲线创建一个更复杂的屏幕保护程序。屏幕保护程序的最初目的是“保护”屏幕。老式的阴极射线管（CRT）显示器容易发生*烧屏*现象：如果在同一个位置长时间显示相同的图形，它会留下永久的“鬼影”图像。现代显示器不容易发生烧屏现象，但许多人仍然使用屏幕保护程序，因为它们看起来很酷。
- en: You’ll use your `lissajousPoint()` function to create a pattern inspired by
    popular screensaver designs. [Figure 9-25](#figure9-25) shows the final result
    with lines and colors morphing smoothly as the pattern twists about the screen.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`lissajousPoint()`函数创建一个受流行屏幕保护程序设计启发的图案。[图9-25](#figure9-25)展示了最终结果，随着图案在屏幕上扭动，线条和颜色平滑地变化。
- en: '![f09025](image_fi/500969c09/f09025.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![f09025](image_fi/500969c09/f09025.png)'
- en: 'Figure 9-25: An animated pattern based on Lissajous curves'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-25：基于Lissajous曲线的动画图案
- en: This movement relies on two Lissajous curves, using a `line()` function to draw
    a straight line between the leading tip of each curve. [Figure 9-26](#figure9-26)
    illustrates how this works.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该运动依赖于两条Lissajous曲线，使用`line()`函数在每条曲线的前端之间绘制一条直线。[图9-26](#figure9-26)展示了这一过程是如何工作的。
- en: '![f09026](image_fi/500969c09/f09026.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![f09026](image_fi/500969c09/f09026.png)'
- en: 'Figure 9-26: Drawing a straight line between two Lissajous curves'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-26：在两条Lissajous曲线之间绘制直线
- en: Of course, you don’t see the curves, just the straight line, but it’s two `lissajousPoint()`
    calls that are calculating the x-y coordinate for your `line()` function. When
    theta reaches τ radians, the Lissajous curves are complete and the motion repeats
    itself.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你看不到曲线，只看到直线，但实际上是通过两次`lissajousPoint()`调用计算出你的`line()`函数的x-y坐标。当theta达到τ弧度时，Lissajous曲线完成，运动开始重复。
- en: 'Add the following code to the end of the `draw()` function in your *lissajous_curves*
    sketch:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`draw()`函数的末尾，在你的*lissajous_curves*草图中：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The loop will draw 10 lines 1 in all—one solid line leading a trail of nine
    lines that gradually fade behind it. You use two `lissajousPoint()` functions,
    one for each curve (that together define the x-y coordinate for each end of the
    line). With each iteration, Processing draws a semiopaque black square that spans
    the entire display window, dimming the lines of previous iterations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将绘制10条线——一条实线在前，后面跟着9条逐渐消失的线。你使用了两个`lissajousPoint()`函数，分别对应每条曲线（它们共同定义了每条线的两端的x-y坐标）。每次迭代时，Processing都会绘制一个半透明的黑色方块，覆盖整个显示窗口，逐渐暗化之前迭代中的线条。
- en: To define a semiopaque color, you use Processing’s `0x` notation 2. The hexadecimal
    value is expressed with a leading `0x`, without quotes, using eight hexadecimal
    digits. The first two digits define the *alpha* (transparency) component; for
    example, `11` is highly transparent, and `EE` highly opaque. This example uses
    `55`, somewhere in between, but nearer the transparent side. The remaining six
    characters are your standard RGB hexadecimal mixture, in this case black (`000000`).
    For the stroke color, set the `colorMode()` to `HSB` (see “Color Modes” on page
    14). For the first 360 frames, you can use `frameCount` to shift the hue value
    a single degree per frame. However, `frameCount` will soon exceed 360, so you
    use a modulo operation to “wrap around” back to 0 3.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义半透明颜色，你使用Processing的`0x`表示法2。十六进制值以`0x`开头，不带引号，后跟八个十六进制数字。前两位定义了*alpha*（透明度）成分；例如，`11`是高度透明的，而`EE`是高度不透明的。这个示例使用`55`，介于两者之间，但更接近透明端。其余六位是标准的RGB十六进制混合，在此为黑色（`000000`）。对于笔触颜色，设置`colorMode()`为`HSB`（参见第14页的“颜色模式”）。在前360帧内，你可以使用`frameCount`每帧调整色相值1度。然而，`frameCount`很快会超过360，所以你需要使用取模运算将其“环绕”回到0
    3。
- en: Run the sketch to observe the output.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图以观察输出结果。
- en: Try different `lissajousPoint()` arguments, or add new curves and lines; maybe
    even try to connect three lines between three curves for morphing triangles. Keep
    experimenting to see what you come up with.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的`lissajousPoint()`参数，或者添加新的曲线和线条；甚至可以尝试在三条曲线之间连接三条线，形成变形三角形。继续实验，看看你能创造出什么。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you’ve learned how to define your own functions, which reduce
    repetition and help you structure more modular programs. Remember that well-named
    functions will make your code easier to read and understand, for yourself and
    anybody else dealing with it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何定义自己的函数，这样可以减少重复并帮助你构建更加模块化的程序。记住，命名清晰的函数会使你的代码更易于阅读和理解，不仅对你自己，也对其他任何处理代码的人。
- en: You can add parameters to any function to make it more versatile, and the function
    call will include different arguments that correspond to those parameters to control
    how it works. You can call a function by using positional and/or keyword arguments.
    For optional arguments, you can define parameters that include default values
    for Python to fall back on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向任何函数添加参数，使其更具通用性，且函数调用会包含与这些参数对应的不同参数，以控制其工作方式。你可以使用位置参数和/或关键字参数来调用函数。对于可选参数，你可以定义包含默认值的参数，以便
    Python 在必要时使用这些默认值。
- en: You can also define functions that return values, which means you can use a
    function to process data and hand back a result to the function caller. If a function
    returns a value, you can assign it to a variable. Additionally, you can wrap a
    function around an argument to process and return a value for another function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以定义返回值的函数，这意味着你可以使用一个函数来处理数据，并将结果返回给函数调用者。如果一个函数返回一个值，你可以将其赋值给一个变量。此外，你还可以将函数封装在一个参数中，以便处理并返回另一个函数所需的值。
- en: This chapter also introduced trigonometry concepts and how to use them to simulate
    periodic motion. You learned about built-in Processing trig functions, like `sin()`
    and `cos()`, which you used to draw circles, spirals, ellipses, sine waves, and
    Lissajous curves. Experiment with trigonometry to generate compelling patterns
    and movements like those you see in some screensavers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了三角函数的概念以及如何使用它们来模拟周期性运动。你学习了内建的 Processing 三角函数，如 `sin()` 和 `cos()`，并用它们绘制了圆形、螺旋、椭圆、正弦波和李萨如曲线。可以通过三角函数实验生成引人入胜的图案和运动，就像你在某些屏幕保护程序中看到的那样。
- en: In the next chapter, you’ll write *classes*, which you will use to create *objects*.
    These techniques enable you to structure your code more efficiently, especially
    for larger, more complex programs, by modeling your programs around real-world
    objects. You’ll also learn about *vectors* for programming motion.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将编写*类*，通过它们来创建*对象*。这些技巧使你能够更高效地构建代码，尤其是在面对更大、更复杂的程序时，通过围绕现实世界中的对象来建模你的程序。你还将学习用于编程运动的*向量*。
