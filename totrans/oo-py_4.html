<html><head></head><body>
<p class="calibre1">concepts of Python and OOP, such as the </p>
<p class="calibre1">lifetime of an object (including deleting an </p>
<p class="calibre1">object) and class variables, that didn’t fit well </p>
<p class="calibre1">in the earlier chapters in this section. To tie all of this </p>
<p class="calibre1">together, we’ll build a small game. I’ll also introduce </p>
<p class="calibre1">slots, a memory management technique for objects. </p>
<p class="calibre1">This chapter should give you a better understanding </p>
<p class="calibre1">of how your code can affect the way that memory is </p>
<p class="calibre1">used by objects. </p>
<p class="calibre1"><a id="p271"/><b class="calibre3">Object Lifetime</b></p>
<p class="calibre1">I<a href="index_split_000.html#p50">n Chapter 2, I d</a>efined an object as “Data, plus code that acts on that data, over time.” I’ve talked quite a bit about data (instance variables) and the </p>
<p class="calibre1">code that acts on that data (methods), but I haven’t explained much about </p>
<p class="calibre1">the time aspect. That will be my focus here. </p>
<p class="calibre1">You already know that a program can create an object at any time. </p>
<p class="calibre1">Often, a program will create one or more objects at startup and use those </p>
<p class="calibre1">objects throughout its operation. However, in many cases a program will </p>
<p class="calibre1">want to create an object when it needs it, but release or remove the object </p>
<p class="calibre1">when it’s done using it to free up the resources that the object uses (mem-</p>
<p class="calibre1">ory, files, network connections, and so on). Here are a few examples:</p>
<p class="calibre1">•  A “transaction” object that’s used while a customer is making an </p>
<p class="calibre1">electronic purchase. When the purchase is completed, the object is </p>
<p class="calibre1">destroyed. </p>
<p class="calibre1">•  An object to handle communication over the internet that’s released </p>
<p class="calibre1">when the communication is completed. </p>
<p class="calibre1">•  Transient objects in a game. The program could instantiate many cop-</p>
<p class="calibre1">ies of bad guys, aliens, spaceships, and so on; as the player destroys each </p>
<p class="calibre1">one, the program can eliminate the underlying object. </p>
<p class="calibre1">The period of time from the instantiation of an object until it is destroyed </p>
<p class="calibre1">is known as the object’s  <i class="calibre4">lifetime</i>. To understand the lifetime of an object, you first need to know about a related underlying concept having to do with the </p>
<p class="calibre1">implementation of objects in Python (and some other OOP languages): the </p>
<p class="calibre1">reference count. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Reference Count</b></i></p>
<p class="calibre1">There are a number of different implementations of Python. The following </p>
<p class="calibre1">discussion of reference counts applies to the official version released by the </p>
<p class="calibre1">Python Software Foundation—the version downloaded from <a href="python.org"> <i class="calibre4">python.org</i>—</a></p>
<p class="calibre1">that’s commonly known as  <i class="calibre4">CPython</i>. Other implementations of Python may </p>
<p class="calibre1">use a different approach. </p>
<p class="calibre1">Part of the philosophy of Python is that programmers should never </p>
<p class="calibre1">have to worry about the details of managing memory. Python takes care of </p>
<p class="calibre1">that for you. However, having a basic idea of how Python manages memory </p>
<p class="calibre1">will be helpful in understanding how and when objects are released back to </p>
<p class="calibre1">the system. </p>
<p class="calibre1">Whenever a program instantiates an object from a class, Python allo-</p>
<p class="calibre1">cates memory for the storage of the instance variables defined in the class. </p>
<p class="calibre1">Each object also contains an extra internal field called a  <i class="calibre4">reference count</i>, which keeps track of how many different variables refer to that object. I </p>
<p class="calibre1">show how this works in Listing 11-1. </p>
<p class="calibre1"><b class="calibre3">242</b>   Chapter 11</p>
<p class="calibre1"><a id="p272"/><img src="index-272_1.png" alt="Image 30" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">File: ReferenceCount.py</b></p>
<p class="calibre1"># Reference count example</p>
<p class="calibre1">1 class Square():</p>
<p class="calibre1">def __init__(self, width, color):</p>
<p class="calibre1">self.width = width</p>
<p class="calibre1">self.color = color</p>
<p class="calibre1"># Instantiate an object</p>
<p class="calibre1">2 oSquare1 = Square(5, 'red')</p>
<p class="calibre1">print(oSquare1)</p>
<p class="calibre1"># Reference count of the Square object is 1</p>
<p class="calibre1"># Now set another variable to the same object</p>
<p class="calibre1">3 oSquare2 = oSquare1</p>
<p class="calibre1">print(oSquare2)</p>
<p class="calibre1"># Reference count of the Square object is 2</p>
<p class="calibre1"> <i class="calibre4">Listing 11-1: A simple Square class for demonstrating reference counting</i></p>
<p class="calibre1">We can use Python Tuto<a href="http://pythontutor.com/">r ( <i class="calibre4">http://pythontutor.com/</i>) t</a>o step through our code. We start with a simple Square class 1 containing a few instance variables. We then instantiate an object and assign it to the variable oSquare1 2. </p>
<p class="calibre1">Figure 11-1 shows what we see after instantiating the first object: as you can </p>
<p class="calibre1">see, the variable oSquare1 refers to an instance of the Square class. </p>
<p class="calibre1"> <i class="calibre4">Figure 11-1: A single variable (oSquare1) referring to an object </i></p>
<p class="calibre1">Next, we set a second variable to refer to the same Square object 3 </p>
<p class="calibre1">and print the value of the new variable. Note that the statement oSquare2 = </p>
<p class="calibre1">oSquare1 does not make a new copy of the Square object! Figure 11-2 shows </p>
<p class="calibre1">what we see after executing these two lines. </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">243</b></p>
<p class="calibre1"><a id="p273"/><img src="index-273_1.png" alt="Image 31" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 11-2: Two variables referring to the same object </i></p>
<p class="calibre1">The variables oSquare1 and oSquare2 both refer to the same Square object. </p>
<p class="calibre1">You can also see in the top box that the two calls to print() show the same </p>
<p class="calibre1">memory address. Therefore, the reference count of the object is now 2. If </p>
<p class="calibre1">we were to assign another variable:</p>
<p class="calibre1">oSquare3 = oSquare2  # or oSquare1</p>
<p class="calibre1">the reference count would be incremented to 3 (because all three variables </p>
<p class="calibre1">would refer to the same object), and so on. </p>
<p class="calibre1">The reference count of an object is important because when it reaches </p>
<p class="calibre1">zero, Python marks the relevant memory as no longer in use by the pro-</p>
<p class="calibre1">gram. This is known as being  <i class="calibre4">marked as garbage</i>. Python has a garbage col-</p>
<p class="calibre1">lector that runs to reclaim any blocks of memory that have been marked as </p>
<p class="calibre1">garbage; I’ll discuss that later in this chapter. </p>
<p class="calibre1">The Python Standard Library contains the getrefcount() function, </p>
<p class="calibre1">which returns the number of variables that refer to an object. Here, we use </p>
<p class="calibre1">it to see the reference count after the first instantiation of a Square object </p>
<p class="calibre1">from the Square class: </p>
<p class="calibre1">oSquare1 = Square(5, 'red')</p>
<p class="calibre1">print('Reference count is', sys.getrefcount(oSquare1))</p>
<p class="calibre1">This prints a count of 2. This may be surprising—you likely expected </p>
<p class="calibre1">that the count would be 1. However, as the documentation of this func-</p>
<p class="calibre1">tion explains, “The count returned is generally one higher than you might </p>
<p class="calibre1">expect, because it includes the (temporary) reference as an argument to </p>
<p class="calibre1">getrefcount().” </p>
<p class="calibre1"><b class="calibre3">244</b>   Chapter 11</p>
<p class="calibre1"><a id="p274"/><b class="calibre3">Incrementing the Reference Count</b></p>
<p class="calibre1">There are a few ways that an object’s reference count is incremented:</p>
<p class="calibre1">1.  When an additional variable is assigned to refer to the same object:</p>
<p class="calibre1">oSquare2 = oSquare1</p>
<p class="calibre1">2.  When an object is passed into a function and therefore a local param-</p>
<p class="calibre1">eter variable is set to refer to the object:</p>
<p class="calibre1">def myFunctionOrMethod(oLocalSquareParam):</p>
<p class="calibre1"># oLocalSquareParam now refers to wherever the argument refers to</p>
<p class="calibre1"> <i class="calibre4">&lt;body of myFunctionOrMethod&gt; </i></p>
<p class="calibre1">myFunctionOrMethod(oSquare1)  # call the function and pass in the object</p>
<p class="calibre1">3.  When an object is put into a container such as a list or a dictionary:</p>
<p class="calibre1">myList = [oSquare1, someValue, someOtherValue]</p>
<p class="calibre1">If oSquare1 already refers to an object, after executing this line, the list </p>
<p class="calibre1">contains an additional reference to the same Square object. </p>
<p class="calibre1"><b class="calibre3">Decrementing the Reference Count</b></p>
<p class="calibre1">Decrementing the reference count also happens in a few ways. To demon-</p>
<p class="calibre1">strate this, let’s create an object and increment its reference count:</p>
<p class="calibre1">oSquare1 = Square(20, BLACK)</p>
<p class="calibre1">oSquare2 = oSquare1</p>
<p class="calibre1">myList = [oSquare1]</p>
<p class="calibre1">myFunctionOrMethod(oSquare1)  # call the function and pass in the object</p>
<p class="calibre1">When myFunctionOrMethod() starts, the reference to the object is copied </p>
<p class="calibre1">into a local parameter variable for use inside the function. The reference </p>
<p class="calibre1">count of this Square object is currently 4: two object variables, one copy </p>
<p class="calibre1">inside a list, plus a local parameter variable inside the function. This refer-</p>
<p class="calibre1">ence count can be decremented:</p>
<p class="calibre1">1.  When any variable that refers to an object is reassigned. For example:</p>
<p class="calibre1">oSquare2 = 5</p>
<p class="calibre1">2.  Whenever a local variable that refers to an object goes out of scope. </p>
<p class="calibre1">When a variable is created inside of a function or method, the scope of </p>
<p class="calibre1">that variable is limited to that function or method. When the execution </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">245</b></p>
<p class="calibre1"><a id="p275"/>of the current function or method ends, that variable literally goes away. In this example, when myFunctionOrMethod() ends, the local variable </p>
<p class="calibre1">that refers to the object is eliminated. </p>
<p class="calibre1">3.  When an object is removed from a container like a list, tuple, or diction-</p>
<p class="calibre1">ary, for example with: </p>
<p class="calibre1">myList.pop()    </p>
<p class="calibre1">Calling the remove() method of a list would also decrement the refer-</p>
<p class="calibre1">ence count. </p>
<p class="calibre1">4.  When you use the del statement to explicitly delete a variable that refers </p>
<p class="calibre1">to an object. This eliminates the variable and reduces the reference </p>
<p class="calibre1">count of the object:</p>
<p class="calibre1">del oSquare3  # delete the variable</p>
<p class="calibre1">5.  If the reference count of the object’s container (in this case, myList) </p>
<p class="calibre1">goes to zero:</p>
<p class="calibre1">del myList  # where myList has an element that refers to an object</p>
<p class="calibre1">If you have a variable that refers to an object, and you want to keep the </p>
<p class="calibre1">variable but lose the reference to the object, you can execute a statement </p>
<p class="calibre1">like the following:</p>
<p class="calibre1">oSquare1 = None</p>
<p class="calibre1">That keeps the variable name, but lowers the reference count of the </p>
<p class="calibre1">object. </p>
<p class="calibre1"><b class="calibre3">Death Notice</b></p>
<p class="calibre1">When the reference count of an object goes to zero, Python knows that the </p>
<p class="calibre1">object can be safely deleted. Right before destroying an object, Python calls </p>
<p class="calibre1">a magic method of that object named __del__() to inform the object of its </p>
<p class="calibre1">impending demise. </p>
<p class="calibre1">In any class, you can write your own version of the __del__() method. </p>
<p class="calibre1">In your version, you can include any code you want your object to execute </p>
<p class="calibre1">(ha! interesting word choice here) before the object disappears forever. For </p>
<p class="calibre1">example, your object may want to close a file, close a network connection, </p>
<p class="calibre1">and so on. </p>
<p class="calibre1">When an object is deleted, Python checks to see if any of its instance </p>
<p class="calibre1">variables refer to other objects. If so, the reference counts of those objects </p>
<p class="calibre1">are also decremented. If this results in another object’s reference count </p>
<p class="calibre1">going to zero, then that object is deleted as well. This type of chained or </p>
<p class="calibre1"> <i class="calibre4">cascading</i> deletion can go on as many layers deep as is necessary. Listing 11-2 </p>
<p class="calibre1">provides an example. </p>
<p class="calibre1"><b class="calibre3">246</b>   Chapter 11</p>
<p class="calibre1"><a id="p276"/><b class="calibre3">File: DeleteExample_Teacher_Student.py</b></p>
<p class="calibre1"># Student class</p>
<p class="calibre1">class Student():</p>
<p class="calibre1">def __init__(self, name):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">print('Creating Student object', self.name)</p>
<p class="calibre1">1 def __del__(self):</p>
<p class="calibre1">print('In the __del__ method for student:', self.name)</p>
<p class="calibre1"># Teacher class</p>
<p class="calibre1">class Teacher():</p>
<p class="calibre1">def __init__(self):</p>
<p class="calibre1">print('Creating the Teacher object')</p>
<p class="calibre1">2 self.oStudent1 = Student('Joe')</p>
<p class="calibre1">self.oStudent2 = Student('Sue')</p>
<p class="calibre1">self.oStudent3 = Student('Chris')</p>
<p class="calibre1">3 def __del__(self):</p>
<p class="calibre1">print('In the __del__ method for Teacher')</p>
<p class="calibre1"># Instantiate the Teacher object (that creates Student objects)</p>
<p class="calibre1">4 oTeacher = Teacher()</p>
<p class="calibre1"># Delete the Teacher object</p>
<p class="calibre1">5 del oTeacher</p>
<p class="calibre1"> <i class="calibre4">Listing 11-2: Classes demonstrating __del__() methods </i></p>
<p class="calibre1">Here we have two classes, Student and Teacher. The main code instanti-</p>
<p class="calibre1">ates one Teacher object 4, and its __init__() method creates three instances </p>
<p class="calibre1">of the Student class 2, one each for Joe, Sue, and Chris. Therefore, after </p>
<p class="calibre1">starting up, the Teacher object has three instance variables that are Student </p>
<p class="calibre1">objects. The output from the first part is: </p>
<p class="calibre1">Creating the Teacher object</p>
<p class="calibre1">Creating Student object Joe</p>
<p class="calibre1">Creating Student object Sue</p>
<p class="calibre1">Creating Student object Chris</p>
<p class="calibre1">Next, the main code uses the del statement to delete the Teacher </p>
<p class="calibre1">object 5. Since we wrote a __del__() method in the Teacher class 3, that </p>
<p class="calibre1">method of the Teacher  <i class="calibre4">object</i> is called—which, for demonstration purposes, </p>
<p class="calibre1">only prints a message. </p>
<p class="calibre1">When the Teacher object is deleted, Python sees that it contains three </p>
<p class="calibre1">other objects (the three Student objects). So, Python lowers the reference </p>
<p class="calibre1">count of each of those objects from 1 to 0. </p>
<p class="calibre1">Once this happens, the __del__() method of the Student objects is </p>
<p class="calibre1">called 1, and each outputs a message. The memory used by all three of </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">247</b></p>
<p class="calibre1"><a id="p277"/>the Student objects is then marked as garbage. The output from the end of the program is:</p>
<p class="calibre1">In the __del__ method for Teacher</p>
<p class="calibre1">In the __del__ method for student: Joe</p>
<p class="calibre1">In the __del__ method for student: Sue</p>
<p class="calibre1">In the __del__ method for student: Chris</p>
<p class="calibre1">Because Python keeps track of reference counts for all objects, you </p>
<p class="calibre1">rarely, if ever, have to worry about memory management in Python and </p>
<p class="calibre1">rarely need to include a __del__() method. However, you might consider </p>
<p class="calibre1">using a del statement to explicitly tell Python to delete objects that use </p>
<p class="calibre1">a very large amount of memory when you are no longer using them. For </p>
<p class="calibre1">example, you might want to delete an object that loads a large number of </p>
<p class="calibre1">records from a database, or loads many images, when you are done using it. </p>
<p class="calibre1">Also, it is not guaranteed that Python will call the __del__() method when </p>
<p class="calibre1">a program exits, so you should avoid putting any program-ending critical </p>
<p class="calibre1">code in this method. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Garbage Collection</b></i></p>
<p class="calibre1">When an object is deleted, either through the reference count going to zero </p>
<p class="calibre1">or though the explicit use of a del statement, as the programmer you should </p>
<p class="calibre1">consider the object inaccessible. </p>
<p class="calibre1">However, the specific implementation of the garbage collector is com-</p>
<p class="calibre1">pletely up to Python. The details of the algorithm that decides when the </p>
<p class="calibre1">actual garbage collection code runs are not important to you as the pro-</p>
<p class="calibre1">grammer. It may run when your program instantiates an object and Python </p>
<p class="calibre1">needs to allocate memory, or at random times, or at certain scheduled </p>
<p class="calibre1">times. The algorithm may change from one release of Python to another. </p>
<p class="calibre1">Whichever it is, Python will take care of garbage collection, and you needn’t </p>
<p class="calibre1">worry about the specifics. </p>
<p class="calibre1"><b class="calibre3">Class Variables</b></p>
<p class="calibre1">I have talked extensively about how instance variables are defined in a class </p>
<p class="calibre1">and how each object instantiated from a class gets its own set of all the </p>
<p class="calibre1">instance variables. The prefix self. is used to identify each instance vari-</p>
<p class="calibre1">able. However, you can also create  <i class="calibre4">class variables</i> at the class level. </p>
<p class="calibre1"><b class="calibre3">class variable</b> </p>
<p class="calibre1">A variable that is defined in and owned by a class . Only one of each class variable exists, independent of how many instances of that class are created . </p>
<p class="calibre1">You create a class variable with an assignment statement, which by conven-</p>
<p class="calibre1">tion is placed between the class statement and the first def statement, like so: </p>
<p class="calibre1">class MyDemoClass():</p>
<p class="calibre1">myClassVariable = 0  # create a class variable and assign 0 to it</p>
<p class="calibre1"><b class="calibre3">248</b>   Chapter 11</p>
<p class="calibre1"><a id="p278"/>    def __init__(self,  <i class="calibre4">&lt;otherParameters&gt; </i>):</p>
<p class="calibre1"># More code here</p>
<p class="calibre1">Because this class variable is owned by the class, in methods of the class </p>
<p class="calibre1">you would refer to it as MyDemoClass.myClassVariable. Every object instantiated </p>
<p class="calibre1">from a class has access to all class variables defined in the class. </p>
<p class="calibre1">There are two typical uses for class variables: defining a constant and </p>
<p class="calibre1">creating a counter. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Class Variable Constants</b></i></p>
<p class="calibre1">You can create a class variable to be used as a constant, like so:  </p>
<p class="calibre1">class MyClass():</p>
<p class="calibre1">DEGREES_IN_CIRCLE = 360  # creating a class variable constant</p>
<p class="calibre1">To access this constant in methods of the class, you would write  </p>
<p class="calibre1">MyClass.DEGREES_IN_CIRCLE. </p>
<p class="calibre1">As a reminder, Python does not actually have constants. Instead, there </p>
<p class="calibre1">is a convention among Python programmers that any variable whose name </p>
<p class="calibre1">consists of all uppercase letters, with words separated by underscores, is </p>
<p class="calibre1">meant to be treated as a constant. That is, this type of variable should </p>
<p class="calibre1">never be reassigned. </p>
<p class="calibre1">We can also use class variable constants to save on resources (memory </p>
<p class="calibre1">and time). Imagine we’re writing a game where we create many instances </p>
<p class="calibre1">of a SpaceShip class. We create a picture of a spaceship and place the file in </p>
<p class="calibre1">a folder named  <i class="calibre4">images</i>. Before considering class variables, the __init__() </p>
<p class="calibre1">method of our SpaceShip class would start by instantiating an Image object </p>
<p class="calibre1">like this:</p>
<p class="calibre1">class SpaceShip():</p>
<p class="calibre1">def __init__(self, window, ...):</p>
<p class="calibre1">self.image = pygwidgets.Image(window, (0, 0), </p>
<p class="calibre1">'images/ship.png')</p>
<p class="calibre1">This technique works fine. However, coding it this way means that not </p>
<p class="calibre1">only does every object instantiated from the SpaceShip class have to take the </p>
<p class="calibre1">time to load the image, but each object takes up all the memory needed to </p>
<p class="calibre1">represent a copy of the same image. Instead, we can have the class load the </p>
<p class="calibre1">image once, and each SpaceShip object then uses the single image kept in </p>
<p class="calibre1">the class, like this:</p>
<p class="calibre1">class SpaceShip():</p>
<p class="calibre1">SPACE_SHIP_IMAGE = pygame.image.load('images/ship.png')</p>
<p class="calibre1">def __init__(self, window, ...):</p>
<p class="calibre1">self.image = pygwidgets.Image(window, (0, 0), </p>
<p class="calibre1">SpaceShip.SPACE_SHIP_IMAGE)</p>
<p class="calibre1">An Image object (in pygwidgets, as used here) can use either a path </p>
<p class="calibre1">to an image or an already loaded image. Allowing the class to load </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">249</b></p>
<p class="calibre1"><a id="p279"/>the image only  <i class="calibre4">once</i> makes startup faster and results in lower memory usage. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Class Variables for Counting</b></i></p>
<p class="calibre1">A second way to use a class variable is to keep track of how many objects </p>
<p class="calibre1">have been instantiated from a class. Listing 11-3 shows an example. </p>
<p class="calibre1"><b class="calibre3">File: ClassVariable.py</b></p>
<p class="calibre1"># Sample class</p>
<p class="calibre1">class Sample():</p>
<p class="calibre1">1 nObjects = 0  # this is a class variable of the Sample class</p>
<p class="calibre1">def __init__(self, name):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">2 Sample.nObjects = Sample.nObjects + 1</p>
<p class="calibre1">def howManyObjects(self):</p>
<p class="calibre1">3 print('There are', Sample.nObjects, 'Sample objects')</p>
<p class="calibre1">def __del__(self):</p>
<p class="calibre1">4 Sample.nObjects = Sample.nObjects - 1</p>
<p class="calibre1"># Instantiate 4 objects</p>
<p class="calibre1">oSample1 = Sample('A')</p>
<p class="calibre1">oSample2 = Sample('B')</p>
<p class="calibre1">oSample3 = Sample('C')</p>
<p class="calibre1">oSample4 = Sample('D')</p>
<p class="calibre1"># Delete 1 object</p>
<p class="calibre1">del oSample3</p>
<p class="calibre1"># See how many we have</p>
<p class="calibre1">oSample1.howManyObjects()</p>
<p class="calibre1"> <i class="calibre4">Listing 11-3: Using a class variable for counting objects instantiated from a class</i> In the Sample class, nObjects is a class variable because it is defined </p>
<p class="calibre1">in the class scope, typically between the class statement and the first def </p>
<p class="calibre1">statement 1. It is used to count the number of Sample objects that exist </p>
<p class="calibre1">and is initialized to zero. All methods refer to this variable using the </p>
<p class="calibre1">name Sample.nObjects. Whenever a Sample object is instantiated, the count </p>
<p class="calibre1">is incremented 2. When one is deleted, the count is decremented 4. </p>
<p class="calibre1">The  howManyObjects() method reports the current count 3. </p>
<p class="calibre1">The main code creates four objects, then deletes one. When run, this </p>
<p class="calibre1">program outputs:</p>
<p class="calibre1">There are 3 Sample objects</p>
<p class="calibre1"><b class="calibre3">250</b>   Chapter 11</p>
<p class="calibre1"><a id="p280"/><img src="index-280_1.png" alt="Image 32" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Putting It All Together: Balloon Sample Program</b></p>
<p class="calibre1">In this section, we’ll take a number of different concepts we’ve covered and </p>
<p class="calibre1">put them all together in a relatively simple game—at least, simple from the </p>
<p class="calibre1">user’s point of view. The game will present some number of balloons in </p>
<p class="calibre1">three sizes that move upward in the window. The goal for the user is to pop </p>
<p class="calibre1">as many balloons as possible before they float off the top of the window. </p>
<p class="calibre1">Small balloons are worth 30 points, medium balloons are worth 20 points, </p>
<p class="calibre1">and large balloons are worth 10 points. </p>
<p class="calibre1">The game could be extended to include many levels with faster-moving </p>
<p class="calibre1">balloons, but for now, there is only a single level. The size and location </p>
<p class="calibre1">of each balloon is chosen at random. Before each round, a Start button </p>
<p class="calibre1">becomes available that allows the user to play again. Figure 11-3 is a screen-</p>
<p class="calibre1">shot of the game in action. </p>
<p class="calibre1"> <i class="calibre4">Figure 11-3: A screenshot of the Bal oon game</i></p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">251</b></p>
<p class="calibre1"><a id="p281"/><img src="index-281_1.png" alt="Image 33" class="calibre2"/></p>
<p class="calibre1">Figure 11-4 shows the project folder for the game. </p>
<p class="calibre1"> <i class="calibre4">Figure 11-4: The Bal oon game project folder </i></p>
<p class="calibre1">The game is implemented with four Python source files:</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main_BalloonGame.py</b></i><b class="calibre3">     </b>Main code, runs the main loop</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">BalloonMgr.py</b></i><b class="calibre3">     </b>Contains the BalloonMgr class that handles all Balloon objects</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Balloon.py</b></i><b class="calibre3">     </b>Contains the Balloon class and BalloonSmall, BalloonMedium, and BalloonLarge subclasses</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">BalloonConstants.py</b></i><b class="calibre3">     </b>Contains constants used by more than one file Figure 11-5 shows an object diagram of the implementation. </p>
<p class="calibre1">Main code</p>
<p class="calibre1">BalloonMgr</p>
<p class="calibre1">Balloon</p>
<p class="calibre1">Balloon</p>
<p class="calibre1">Balloon</p>
<p class="calibre1">…</p>
<p class="calibre1">Balloon</p>
<p class="calibre1"> <i class="calibre4">Figure 11-5: An object diagram of the Bal oon game </i></p>
<p class="calibre1">The main code (found in  <i class="calibre4">Main_BalloonGame.py</i>) instantiates a single </p>
<p class="calibre1">balloon manager (oBalloonMgr) object from the BalloonMgr class. The balloon </p>
<p class="calibre1"><b class="calibre3">252</b>   Chapter 11</p>
<p class="calibre1"><a id="p282"/>manager then instantiates a number of balloons, each chosen randomly from the BalloonSmall, BalloonMedium, and BalloonLarge classes, and keeps this </p>
<p class="calibre1">list of objects in an instance variable. Each Balloon object sets its own speed, </p>
<p class="calibre1">point value, and random starting position off the bottom of the window. </p>
<p class="calibre1">Given this structure, the main code is responsible for presenting the over-</p>
<p class="calibre1">all user interface. It only communicates with the oBalloonMgr. The  oBalloonMgr </p>
<p class="calibre1">talks to all the Balloon objects. Therefore, the main code doesn’t even know </p>
<p class="calibre1">that the Balloon objects exist. It relies on the balloon manager to take care </p>
<p class="calibre1">of them. Let’s walk through the different parts of the program and see how </p>
<p class="calibre1">each piece works. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Module of Constants</b></i></p>
<p class="calibre1">This organization introduces a new technique for working with multiple </p>
<p class="calibre1">Python files, each of which is commonly referred to as a  <i class="calibre4">module</i>. If you find yourself in a situation where multiple Python modules require access to </p>
<p class="calibre1">the same constants, a good solution is to create a module of constants and </p>
<p class="calibre1">import that module into all modules that use the constants. Listing 11-4 </p>
<p class="calibre1">shows some constants defined in  <i class="calibre4">BalloonConstants.py</i>. </p>
<p class="calibre1"><b class="calibre3">File: BalloonGame/BalloonConstants.py</b></p>
<p class="calibre1"># Constants used by more than one Python module</p>
<p class="calibre1">N_BALLOONS = 15  # number of balloons in a round of the game</p>
<p class="calibre1">BALLOON_MISSED = 'Missed'  # balloon went off the top</p>
<p class="calibre1">BALLOON_MOVING = 'Balloon Moving'  # balloon is moving</p>
<p class="calibre1"> <i class="calibre4">Listing 11-4: A module of constants that’s imported by other modules</i></p>
<p class="calibre1">This is just a simple Python file that contains constants shared by more </p>
<p class="calibre1">than one module. The main code needs to know how many balloons there </p>
<p class="calibre1">are in order to display that number. The balloon manager needs to know </p>
<p class="calibre1">the number so it can instantiate the correct number of Balloon objects. </p>
<p class="calibre1">This approach makes it extremely simple to modify the number of Balloon </p>
<p class="calibre1">objects. If we added levels with different numbers of balloons, we could </p>
<p class="calibre1">build a list or a dictionary in this file alone, and all other files would have </p>
<p class="calibre1">access to that information. </p>
<p class="calibre1">The other two constants are used in each Balloon object as status indica-</p>
<p class="calibre1">tors as the balloon moves up the window. When I get to the discussion of </p>
<p class="calibre1">the game play, you’ll see that the balloon manager (oBalloonMgr) asks each </p>
<p class="calibre1">Balloon object for its status, and each responds with one of these two con-</p>
<p class="calibre1">stants. Placing shared constants in a module and importing that module </p>
<p class="calibre1">in modules that use the constants is a simple and effective technique for </p>
<p class="calibre1">ensuring that different parts of a program use consistent values. This is a </p>
<p class="calibre1">good example of applying the Don’t Repeat Yourself (DRY) principle by </p>
<p class="calibre1">only defining values in a single place. </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">253</b></p>
<p class="calibre1"><a id="p283"/> <i class="calibre4"><b class="calibre3">Main Program Code</b></i></p>
<p class="calibre1">The main code of our sample program, shown in Listing 11-5, follows the </p>
<p class="calibre1">12-step template I’ve used throughout this book. It shows the user’s score, </p>
<p class="calibre1">the game status, and a Start button at the bottom of the window, and it </p>
<p class="calibre1">reacts to the user clicking the Start button. </p>
<p class="calibre1"><b class="calibre3">File: BalloonGame/Main_BalloonGame.py</b></p>
<p class="calibre1">#  Balloon game main code</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from BalloonMgr import *</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">GRAY = (200, 200, 200)</p>
<p class="calibre1">BACKGROUND_COLOR = (0, 180, 180)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 640</p>
<p class="calibre1">PANEL_HEIGHT = 60</p>
<p class="calibre1">USABLE_WINDOW_HEIGHT = WINDOW_HEIGHT - PANEL_HEIGHT</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">oScoreDisplay = pygwidgets.DisplayText(window, (10, USABLE_WINDOW_HEIGHT + 25), </p>
<p class="calibre1">'Score: 0', textColor=BLACK, </p>
<p class="calibre1">backgroundColor=None, width=140, fontSize=24)</p>
<p class="calibre1">oStatusDisplay = pygwidgets.DisplayText(window, (180, USABLE_WINDOW_HEIGHT + 25), </p>
<p class="calibre1">'', textColor=BLACK, backgroundColor=None, </p>
<p class="calibre1">width=300, fontSize=24)</p>
<p class="calibre1">oStartButton = pygwidgets.TextButton(window, </p>
<p class="calibre1">(WINDOW_WIDTH - 110, USABLE_WINDOW_HEIGHT + 10), </p>
<p class="calibre1">'Start')</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">oBalloonMgr = BalloonMgr(window, WINDOW_WIDTH, USABLE_WINDOW_HEIGHT)</p>
<p class="calibre1">playing = False 1  # wait until user clicks Start </p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">nPointsEarned = 0</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">254</b>   Chapter 11</p>
<p class="calibre1"><a id="p284"/>        if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if playing: 2 </p>
<p class="calibre1">oBalloonMgr.handleEvent(event)</p>
<p class="calibre1">theScore = oBalloonMgr.getScore()</p>
<p class="calibre1">oScoreDisplay.setValue('Score: ' + str(theScore))</p>
<p class="calibre1">elif oStartButton.handleEvent(event): 3 </p>
<p class="calibre1">oBalloonMgr.start()</p>
<p class="calibre1">oScoreDisplay.setValue('Score: 0')</p>
<p class="calibre1">playing = True</p>
<p class="calibre1">oStartButton.disable()</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">if playing: 4 </p>
<p class="calibre1">oBalloonMgr.update()</p>
<p class="calibre1">nPopped = oBalloonMgr.getCountPopped()</p>
<p class="calibre1">nMissed = oBalloonMgr.getCountMissed()</p>
<p class="calibre1">oStatusDisplay.setValue('Popped: ' + str(nPopped) +</p>
<p class="calibre1">'   Missed: ' + str(nMissed) +</p>
<p class="calibre1">'   Out of: ' + str(N_BALLOONS))</p>
<p class="calibre1">if (nPopped + nMissed) == N_BALLOONS: 5 </p>
<p class="calibre1">playing = False</p>
<p class="calibre1">oStartButton.enable()</p>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(BACKGROUND_COLOR)</p>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">if playing: 6 </p>
<p class="calibre1">oBalloonMgr.draw()</p>
<p class="calibre1">pygame.draw.rect(window, GRAY, pygame.Rect(0, </p>
<p class="calibre1">USABLE_WINDOW_HEIGHT, WINDOW_WIDTH, PANEL_HEIGHT))</p>
<p class="calibre1">oScoreDisplay.draw()</p>
<p class="calibre1">oStatusDisplay.draw()</p>
<p class="calibre1">oStartButton.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 11-5: The Bal oon game’s main code</i></p>
<p class="calibre1">The code is based on a single Boolean variable, playing, set to False by </p>
<p class="calibre1">default to let the user begin the game by pressing Start 1. </p>
<p class="calibre1">When playing is True, the main code calls the handleEvent() method 2 </p>
<p class="calibre1">of the balloon manager, oBalloonMgr, to handle all events. We call the bal-</p>
<p class="calibre1">loon manager’s getScore() method to get the score, and we update the score </p>
<p class="calibre1">field’s text. </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">255</b></p>
<p class="calibre1"><a id="p285"/>When the game is over, the program waits for the user to press the Start button 3. When the button is clicked, the balloon manager is told to start </p>
<p class="calibre1">the game, and the user interface is updated. </p>
<p class="calibre1">In every frame, if the game is running, we send the update() message </p>
<p class="calibre1">to the balloon manager 4, triggering it to pass on the update() message to </p>
<p class="calibre1">all balloons. Then we ask the balloon manager for the numbers of balloons </p>
<p class="calibre1">remaining and balloons popped. We use that information to update the </p>
<p class="calibre1">user interface. </p>
<p class="calibre1">When the user pops all balloons or the last balloon floats off the top </p>
<p class="calibre1">of the window, we set the playing variable to False and enable the Start </p>
<p class="calibre1">button 5. </p>
<p class="calibre1">The drawing code is very straightforward 6. We tell the balloon man-</p>
<p class="calibre1">ager to draw, which triggers all the balloons to draw themselves. Then we </p>
<p class="calibre1">draw the bottom bar with its status data and the Start button. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Bal oon Manager</b></i></p>
<p class="calibre1">The balloon manager is responsible for keeping track of all balloons, </p>
<p class="calibre1">including creating the Balloon objects, telling each one to draw itself, tell-</p>
<p class="calibre1">ing each to move, and keeping track of how many were popped and missed. </p>
<p class="calibre1">Listing 11-6 contains the code of the BalloonMgr class. </p>
<p class="calibre1"><b class="calibre3">File: BalloonGame/BalloonMgr.py</b></p>
<p class="calibre1"># BalloonMgr class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import random</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">from BalloonConstants import *</p>
<p class="calibre1">from Balloon import *</p>
<p class="calibre1"># BalloonMgr manages a list of Balloon objects</p>
<p class="calibre1">class BalloonMgr():</p>
<p class="calibre1">1 def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.maxWidth = maxWidth</p>
<p class="calibre1">self.maxHeight = maxHeight</p>
<p class="calibre1">2 def start(self):</p>
<p class="calibre1">self.balloonList = []</p>
<p class="calibre1">self.nPopped = 0</p>
<p class="calibre1">self.nMissed = 0</p>
<p class="calibre1">3 for balloonNum in range(0, N_BALLOONS):</p>
<p class="calibre1">randomBalloonClass = random.choice((BalloonSmall, </p>
<p class="calibre1">BalloonMedium, </p>
<p class="calibre1">BalloonLarge))</p>
<p class="calibre1">oBalloon = randomBalloonClass(self.window, self.maxWidth, </p>
<p class="calibre1">self.maxHeight, balloonNum)</p>
<p class="calibre1"><b class="calibre3">256</b>   Chapter 11</p>
<p class="calibre1"><a id="p286"/>            self.balloonList.append(oBalloon)</p>
<p class="calibre1">def handleEvent(self, event):</p>
<p class="calibre1">4 if event.type == MOUSEBUTTONDOWN:</p>
<p class="calibre1"># Go 'reversed' so topmost balloon gets popped</p>
<p class="calibre1">for oBalloon in reversed(self.balloonList):</p>
<p class="calibre1">wasHit, nPoints = oBalloon.clickedInside(event.pos)</p>
<p class="calibre1">if wasHit:</p>
<p class="calibre1">if nPoints &gt; 0:  # remove this balloon</p>
<p class="calibre1">self.balloonList.remove(oBalloon)  </p>
<p class="calibre1">self.nPopped = self.nPopped + 1</p>
<p class="calibre1">self.score = self.score + nPoints</p>
<p class="calibre1">return  # no need to check others</p>
<p class="calibre1">5 def update(self):</p>
<p class="calibre1">for oBalloon in self.balloonList:</p>
<p class="calibre1">status = oBalloon.update()</p>
<p class="calibre1">if status == BALLOON_MISSED:</p>
<p class="calibre1"># Balloon went off the top, remove it</p>
<p class="calibre1">self.balloonList.remove(oBalloon)  </p>
<p class="calibre1">self.nMissed = self.nMissed + 1</p>
<p class="calibre1">6 def getScore(self):</p>
<p class="calibre1">return self.score</p>
<p class="calibre1">7 def getCountPopped(self):</p>
<p class="calibre1">return self.nPopped</p>
<p class="calibre1">8 def getCountMissed(self):</p>
<p class="calibre1">return self.nMissed</p>
<p class="calibre1">9 def draw(self):</p>
<p class="calibre1">for oBalloon in self.balloonList:</p>
<p class="calibre1">oBalloon.draw()</p>
<p class="calibre1"> <i class="calibre4">Listing 11-6: The BalloonMgr class</i></p>
<p class="calibre1">When instantiated, the balloon manager is told the width and height of </p>
<p class="calibre1">the window 1, and it saves this information in instance variables. </p>
<p class="calibre1">The concept behind the start() method 2 is important. Its purpose </p>
<p class="calibre1">is to initialize any instance variables needed for one round of the game, </p>
<p class="calibre1">so it’s called whenever the user starts a round of the game. In this game, </p>
<p class="calibre1">start() resets the count of popped balloons and the count of missed bal-</p>
<p class="calibre1">loons. It then goes through a loop that creates all the Balloon objects (ran-</p>
<p class="calibre1">domly chosen among three different sizes using three different classes) </p>
<p class="calibre1">and stores them in a list 3. Whenever the method creates a Balloon object, </p>
<p class="calibre1">it passes the window and the width and height of the window. (For future </p>
<p class="calibre1">expansion, each Balloon object is given a unique number.)</p>
<p class="calibre1">Each time through the main loop, the main code calls the handleEvent() </p>
<p class="calibre1">method of the balloon manager 4. Here, we check if the user has clicked </p>
<p class="calibre1">on any Balloon. If the event detected was a MOUSEDOWNEVENT, the code loops </p>
<p class="calibre1">through all the Balloon objects, asking each one if the click occurred inside </p>
<p class="calibre1">that balloon. Each Balloon returns a Boolean indicating if it was hit and, if </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">257</b></p>
<p class="calibre1"><a id="p287"/>so, the number of points the user should get for popping it. (The code is set up this way for future expansion, as discussed in the note at the end of this </p>
<p class="calibre1">section.) The balloon manager then uses the remove() method to eliminate </p>
<p class="calibre1">that Balloon from its list, increments the number of popped balloons, and </p>
<p class="calibre1">updates the score. </p>
<p class="calibre1">In each iteration of the main loop, the main code also calls the update() </p>
<p class="calibre1">method of the balloon manager 5, which passes this call on to all of the </p>
<p class="calibre1">balloons, telling them to update themselves. Each balloon moves up the </p>
<p class="calibre1">screen based on its own speed setting and returns its status: either that it is </p>
<p class="calibre1">still moving (BALLOON_MOVING) or that it has moved beyond the top of the win-</p>
<p class="calibre1">dow (BALLOON_MISSED). If a balloon was missed, the balloon manager removes </p>
<p class="calibre1">that balloon from its list and increments its count of missed balloons. </p>
<p class="calibre1">The balloon manager provides three getter methods that allow the </p>
<p class="calibre1">main code to get the score 6, the number of popped balloons 7, and the </p>
<p class="calibre1">number of missed balloons 8. </p>
<p class="calibre1">Each time through the main loop, the main code calls the balloon </p>
<p class="calibre1">manager’s draw() method 9. The balloon manager doesn’t have anything </p>
<p class="calibre1">to draw by itself, but loops though all the Balloon objects and calls the draw() </p>
<p class="calibre1">method of each. (Notice the polymorphism here. The balloon manager has </p>
<p class="calibre1">a draw() method, and each Balloon object has a draw() method.)</p>
<p class="calibre1"><b class="calibre3">N O T E   </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">As a challenge, try to expand this game to include a new type (subclass) of Balloon, a</i> <i class="calibre4">MegaBalloon. The difference is that a MegaBalloon will take three clicks to pop. Artwork</i> <i class="calibre4">is included in the download for this game. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Bal oon Class and Objects</b></i></p>
<p class="calibre1">Finally, we have the balloon classes. To reinforce the concept of inheri-</p>
<p class="calibre1">tance fro<a href="index_split_004.html#p240">m Chapter 10, t</a>he  <i class="calibre4">Balloon.py</i> module includes an abstract base class named Balloon and three subclasses: BalloonSmall, BalloonMedium, and </p>
<p class="calibre1">BalloonLarge. The balloon manager instantiates Balloon objects from these </p>
<p class="calibre1">subclasses. The subclasses each only include an __init__() method, which </p>
<p class="calibre1">overrides and then calls the abstract method __init__() in the Balloon </p>
<p class="calibre1">class. Each balloon image will start at some randomized location (below </p>
<p class="calibre1">the bottom of the window) and will move up a few pixels in every frame. </p>
<p class="calibre1">Listing 11-7 shows the code of the Balloon class and its subclasses. </p>
<p class="calibre1"><b class="calibre3">File: BalloonGame/Balloon.py</b></p>
<p class="calibre1"># Balloon base class and 3 subclasses</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import random</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">from BalloonConstants import *</p>
<p class="calibre1">from abc import ABC, abstractmethod</p>
<p class="calibre1"><b class="calibre3">258</b>   Chapter 11</p>
<p class="calibre1"><a id="p288"/>1 class Balloon(ABC):</p>
<p class="calibre1">popSoundLoaded = False</p>
<p class="calibre1">popSound = None  # load when first balloon is created</p>
<p class="calibre1">@abstractmethod</p>
<p class="calibre1">2 def __init__(self, window, maxWidth, maxHeight, ID, </p>
<p class="calibre1">oImage, size, nPoints, speedY):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.ID = ID</p>
<p class="calibre1">self.balloonImage = oImage</p>
<p class="calibre1">self.size = size</p>
<p class="calibre1">self.nPoints = nPoints</p>
<p class="calibre1">self.speedY = speedY</p>
<p class="calibre1">if not Balloon.popSoundLoaded:  # load first time only</p>
<p class="calibre1">Balloon.popSoundLoaded = True</p>
<p class="calibre1">Balloon.popSound = pygame.mixer.Sound('sounds/balloonPop.wav')</p>
<p class="calibre1">balloonRect = self.balloonImage.getRect()</p>
<p class="calibre1">self.width = balloonRect.width</p>
<p class="calibre1">self.height = balloonRect.height</p>
<p class="calibre1"># Position so balloon is within the width of the window, </p>
<p class="calibre1"># but below the bottom</p>
<p class="calibre1">self.x = random.randrange(maxWidth - self.width)</p>
<p class="calibre1">self.y = maxHeight + random.randrange(75)</p>
<p class="calibre1">self.balloonImage.setLoc((self.x, self.y))</p>
<p class="calibre1">3 def clickedInside(self, mousePoint):</p>
<p class="calibre1">myRect = pygame.Rect(self.x, self.y, self.width, self.height)</p>
<p class="calibre1">if myRect.collidepoint(mousePoint):</p>
<p class="calibre1">Balloon.popSound.play()</p>
<p class="calibre1">return True, self.nPoints  # True here means it was hit</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False, 0  # not hit, no points</p>
<p class="calibre1">4 def update(self):</p>
<p class="calibre1">self.y = self.y - self.speedY   # update y position by speed</p>
<p class="calibre1">self.balloonImage.setLoc((self.x, self.y))</p>
<p class="calibre1">if self.y &lt; -self.height:  # off the top of the window</p>
<p class="calibre1">return BALLOON_MISSED</p>
<p class="calibre1">else:</p>
<p class="calibre1">return BALLOON_MOVING</p>
<p class="calibre1">5 def draw(self):</p>
<p class="calibre1">self.balloonImage.draw()</p>
<p class="calibre1">6 def __del__(self):</p>
<p class="calibre1">print(self.size, 'Balloon', self.ID, 'is going away')</p>
<p class="calibre1">7 class BalloonSmall(Balloon):</p>
<p class="calibre1">balloonImage = pygame.image.load('images/redBalloonSmall.png')</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight, ID):</p>
<p class="calibre1">oImage = pygwidgets.Image(window, (0, 0), </p>
<p class="calibre1">BalloonSmall.balloonImage)</p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">259</b></p>
<p class="calibre1"><a id="p289"/>        super().__init__(window, maxWidth, maxHeight, ID, </p>
<p class="calibre1">oImage, 'Small', 30, 3.1)</p>
<p class="calibre1">8 class BalloonMedium(Balloon):</p>
<p class="calibre1">balloonImage = pygame.image.load('images/redBalloonMedium.png')</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight, ID):</p>
<p class="calibre1">oImage = pygwidgets.Image(window, (0, 0), </p>
<p class="calibre1">BalloonMedium.balloonImage)</p>
<p class="calibre1">super().__init__(window, maxWidth, maxHeight, ID, </p>
<p class="calibre1">oImage, 'Medium', 20, 2.2)</p>
<p class="calibre1">9 class BalloonLarge(Balloon):</p>
<p class="calibre1">balloonImage = pygame.image.load('images/redBalloonLarge.png')</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight, ID):</p>
<p class="calibre1">oImage = pygwidgets.Image(window, (0, 0), </p>
<p class="calibre1">BalloonLarge.balloonImage)</p>
<p class="calibre1">super().__init__(window, maxWidth, maxHeight, ID, </p>
<p class="calibre1">oImage, 'Large', 10, 1.5)</p>
<p class="calibre1"> <i class="calibre4">Listing 11-7: The Balloon classes</i></p>
<p class="calibre1">The Balloon class is an abstract class 1, so the BalloonMgr instanti-</p>
<p class="calibre1">ates objects (randomly) from the BalloonSmall 7, BalloonMedium 8, and </p>
<p class="calibre1">BalloonLarge 9 classes. Each of those classes creates a pygwidgets Image object, </p>
<p class="calibre1">then calls the __init__() method in the Balloon base class. We differentiate </p>
<p class="calibre1">the balloons with the arguments representing the image, size, number of </p>
<p class="calibre1">points, and speed. </p>
<p class="calibre1">The __init__() method in the Balloon class 2 stores the information </p>
<p class="calibre1">about each balloon in instance variables. We get the rectangle of the bal-</p>
<p class="calibre1">loon image and remember its width and height. We set a randomized </p>
<p class="calibre1">horizontal position that will ensure that the balloon image will fully show </p>
<p class="calibre1">within the window. </p>
<p class="calibre1">Every time a MOUSEDOWNEVENT happens, the balloon manager loops </p>
<p class="calibre1">through the Balloon objects and calls the clickedInside() method of each 3. </p>
<p class="calibre1">The code here checks to see if the MOUSEDOWNEVENT that was detected hap-</p>
<p class="calibre1">pened inside the current balloon. If it did, the Balloon plays the pop sound </p>
<p class="calibre1">and returns a Boolean to say that it was clicked on, as well as the number of </p>
<p class="calibre1">points that balloon was worth. If it was not hit, it returns False and zero. </p>
<p class="calibre1">In each frame, the balloon manager calls the update() method of each </p>
<p class="calibre1">Balloon 4, which updates that Balloon’s y position by subtracting its own </p>
<p class="calibre1">speed in order to move higher in the window. After changing the position, </p>
<p class="calibre1">the update() method returns either BALLOON_MISSED (if it has moved completely </p>
<p class="calibre1">off the top of the window) or BALLOON_MOVING (to indicate that it is still in play). </p>
<p class="calibre1">The draw() method simply draws the image of the balloon at the appro-</p>
<p class="calibre1">priate (x, y) location 5. Although the y position is kept as a floating-point </p>
<p class="calibre1">value, pygame automatically converts it to an integer for pixel placement in </p>
<p class="calibre1">the window. </p>
<p class="calibre1">The last method, __del__() 6, has been added for debugging and for </p>
<p class="calibre1">future development. Whenever the balloon manager deletes a balloon, </p>
<p class="calibre1">the __del__() method of that Balloon object is called. For demonstration </p>
<p class="calibre1"><b class="calibre3">260</b>   Chapter 11</p>
<p class="calibre1"><a id="p290"/>purposes, for now it simply prints a message that displays the balloon’s size and ID number. </p>
<p class="calibre1">When the program is run and the user starts clicking on the balloons, </p>
<p class="calibre1">we see output like this in the shell or console window:</p>
<p class="calibre1">Small Balloon 2 is going away</p>
<p class="calibre1">Small Balloon 8 is going away</p>
<p class="calibre1">Small Balloon 3 is going away</p>
<p class="calibre1">Small Balloon 7 is going away</p>
<p class="calibre1">Small Balloon 9 is going away</p>
<p class="calibre1">Small Balloon 12 is going away</p>
<p class="calibre1">Small Balloon 11 is going away</p>
<p class="calibre1">Small Balloon 6 is going away</p>
<p class="calibre1">Medium Balloon 14 is going away</p>
<p class="calibre1">Large Balloon 1 is going away</p>
<p class="calibre1">Medium Balloon 10 is going away</p>
<p class="calibre1">Medium Balloon 13 is going away</p>
<p class="calibre1">Medium Balloon 0 is going away</p>
<p class="calibre1">Medium Balloon 4 is going away</p>
<p class="calibre1">Large Balloon 5 is going away</p>
<p class="calibre1">When the game is over, the program waits for the user to click on the </p>
<p class="calibre1">Start button. When that button is clicked, the balloon manager re-creates </p>
<p class="calibre1">the list of Balloon objects and resets its instance variables, and the game </p>
<p class="calibre1">begins again. </p>
<p class="calibre1"><b class="calibre3">Managing Memory: Slots</b></p>
<p class="calibre1">As we have discussed, when you instantiate an object, Python must allocate </p>
<p class="calibre1">space for the instance variables defined in the class. By default, Python does </p>
<p class="calibre1">this using a dictionary with a special name: __dict__. To see this in action, </p>
<p class="calibre1">you can add this line to the end of the __init__() method of any class:</p>
<p class="calibre1">print(self.__dict__)</p>
<p class="calibre1">A dictionary is an excellent way to represent all the instance vari-</p>
<p class="calibre1">ables because it is dynamic—it can grow whenever Python encounters an </p>
<p class="calibre1">instance variable that it has not seen before in a class. While I recommend </p>
<p class="calibre1">that you initialize all your instance variables in your __init__() method, you </p>
<p class="calibre1">can in fact define instance variables in any method, and those instance vari-</p>
<p class="calibre1">ables will be added when the method is executed for the first time. While </p>
<p class="calibre1">I personally think the following is a bad idea, it demonstrates the ability to </p>
<p class="calibre1">add an instance variable to an object dynamically:</p>
<p class="calibre1">myObject = MyClass()</p>
<p class="calibre1">myObject.someInstanceVariable = 5</p>
<p class="calibre1">In order to allow for this dynamic capability, dictionaries are typically </p>
<p class="calibre1">implemented starting with enough empty space to represent some number </p>
<p class="calibre1">of instance variables (the exact number is an internal detail of Python). </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">261</b></p>
<p class="calibre1"><a id="p291"/>Whenever a new instance variable is encountered, it’s added to the dictionary. If the dictionary runs out of space, Python adds more. This generally </p>
<p class="calibre1">works well, and programmers do not experience any problems with this </p>
<p class="calibre1">implementation. </p>
<p class="calibre1">However, imagine you have a class like the following with two instance </p>
<p class="calibre1">variables created in the __init__() method, and you know that you will not </p>
<p class="calibre1">need to add any more instance variables:</p>
<p class="calibre1">class Point():</p>
<p class="calibre1">def __init__(self, x, y):</p>
<p class="calibre1">self.x = x</p>
<p class="calibre1">self.y = y</p>
<p class="calibre1"># More methods</p>
<p class="calibre1">Now, let’s assume that you need to instantiate a very large number </p>
<p class="calibre1">(hundreds of thousands, or even millions) of objects from this class. A case </p>
<p class="calibre1">like this could cumulatively account for a large amount of wasted memory </p>
<p class="calibre1">space (RAM). </p>
<p class="calibre1">To combat this potential waste, Python gives us a different approach, </p>
<p class="calibre1">known as  <i class="calibre4">slots</i>, to represent the instance variables. The idea is that you can tell Python the names of all the instance variables up front, and Python </p>
<p class="calibre1">will use a data structure that allocates exactly enough space for just those </p>
<p class="calibre1">instance variables. To use slots, you need to include the special class vari-</p>
<p class="calibre1">able __slots__ to define a list of variables:</p>
<p class="calibre1">__slots__ = [ <i class="calibre4">&lt;instanceVar1&gt; </i>,  <i class="calibre4">&lt;instanceVar2&gt; </i>, ...  <i class="calibre4">&lt;instanceVarN&gt; </i>]</p>
<p class="calibre1">Here is what a modified version of our example class would look like:</p>
<p class="calibre1">class PointWithSlots():</p>
<p class="calibre1"># Define slots for only two instance variables</p>
<p class="calibre1">__slots__ = ['x', 'y']</p>
<p class="calibre1">def __init__(self, x, y):</p>
<p class="calibre1">self.x = x</p>
<p class="calibre1">self.y = y</p>
<p class="calibre1">print(x, y)</p>
<p class="calibre1">These two classes will work identically, but objects instantiated from </p>
<p class="calibre1">PointWithSlots will take up considerably less memory. To demonstrate the </p>
<p class="calibre1">difference, we’ll add this line to the end of the __init__() method of both </p>
<p class="calibre1">classes:</p>
<p class="calibre1"># Try to create an additional instance variable</p>
<p class="calibre1">self.color = 'black' </p>
<p class="calibre1">Now when we try to instantiate an object from both classes, the </p>
<p class="calibre1">Point class has no problem adding another instance variable, but the </p>
<p class="calibre1">PointWithSlots class fails with the following error:</p>
<p class="calibre1">AttributeError: 'PointWithSlots' object has no attribute 'color' </p>
<p class="calibre1"><b class="calibre3">262</b>   Chapter 11</p>
<p class="calibre1"><a id="p292"/>Using slots is highly memory-efficient at the expense of a loss of dynamic instance variables. If you’re dealing with a very large number of </p>
<p class="calibre1">objects from a class, this trade-off may very well be worthwhile. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">This chapter focused on a few concepts that didn’t readily fit in the previ-</p>
<p class="calibre1">ous chapters. First, I discussed the circumstances under which you might </p>
<p class="calibre1">want to delete an object. We looked at reference counts and how they track </p>
<p class="calibre1">how many variables refer to the same object, which led to a discussion of </p>
<p class="calibre1">object lifetimes and garbage collection. When the reference count goes to </p>
<p class="calibre1">zero, the object is available for garbage collection. If a class has a __del__() </p>
<p class="calibre1">method, then any objects created from the class can use the __del__() </p>
<p class="calibre1">method for any cleanup that they might want to do. </p>
<p class="calibre1">Next, I discussed how class variables are different from instance </p>
<p class="calibre1">variables. Every object instantiated from a class gets its own set of all the </p>
<p class="calibre1">instance variables in the class. However, there is only one of each class </p>
<p class="calibre1">variable, and that is accessible by all objects created from the class. Class </p>
<p class="calibre1">variables are often used as constants or counters, or for loading something </p>
<p class="calibre1">large and making it available to all objects instantiated from the class. </p>
<p class="calibre1">To put a number of techniques and concepts together, we built a </p>
<p class="calibre1">balloon-popping game and organized it very efficiently. We had one file </p>
<p class="calibre1">that contained only constants used by other files. The main code con-</p>
<p class="calibre1">sisted of the main loop and a status display, and the balloon manager </p>
<p class="calibre1">did the work of managing the objects. Such a division of labor allows for </p>
<p class="calibre1">splitting up the game into smaller, logical pieces. The role of each part is </p>
<p class="calibre1">well defined, making the overall program more manageable. </p>
<p class="calibre1">Finally, I explained how a technique called slots allows for a memory-</p>
<p class="calibre1">efficient representation of instance variables. </p>
<p class="calibre1">Managing Memory Used by Objects   <b class="calibre3">263</b></p>
<p class="calibre1"><a id="p293"/>
<a id="p294"/><b class="calibre3">PART IV</b></p>
<p class="calibre1"><b class="calibre3">U S I N G   O O P   I N   G A M E </b></p>
<p class="calibre1"><b class="calibre3">D E V E L O P M E N T</b></p>
<p class="calibre1">In this part of the book, we’ll build some sample </p>
<p class="calibre1">games using pygwidgets. I’ll also introduce the pyghelpers </p>
<p class="calibre1">module, which includes a number of classes and func-</p>
<p class="calibre1">tions that can be useful in building game programs. </p>
<p class="calibre1"><a href="#p296">Chapter 12 re</a>visits the Higher or Lower game fro<a href="index_split_000.html#p32">m Chapter 1. W</a>e’ll build a version of the game with a graphical user interface, and I’ll introduce Deck and Card classes that can be reused in any card game program. </p>
<p class="calibre1"><a href="#p310">Chapter 13 f</a>ocuses on timers. We’ll build a number of different timer classes that allow your program to keep running while concurrently checking for a certain time limit. </p>
<p class="calibre1"><a href="#p324">Chapter 14 d</a>iscusses different animation classes you can use to show sequences of images. This will allow you to easily build more artistic games </p>
<p class="calibre1">and programs. </p>
<p class="calibre1"><a href="index_split_006.html#p340">Chapter 15 i</a>ntroduces an approach to building a program that can contain many scenes, like a start scene, a play scene, and a game over scene. I’ll </p>
<p class="calibre1">show a SceneMgr class that is designed to manage any number of program-</p>
<p class="calibre1">mer-built scenes, and we’ll use it to build a Rock, Paper, Scissors game. </p>
<p class="calibre1"><a href="index_split_006.html#p370">Chapter 16 d</a>emonstrates how to show and react to different types of dialog boxes. You’ll then use everything you’ve learned to build a fully functioning animated game. </p>
<p class="calibre1"><a href="index_split_007.html#p396">Chapter 17 i</a>ntroduces the concept of design patterns, using the model, view, controller pattern as an example. It then provides a short wrap-up for </p>
<p class="calibre1">the book. </p>
<p class="calibre1"><a id="p295"/>
<a id="p296"/><b class="calibre3">12</b></p>
<p class="calibre1"><b class="calibre3">C A R D   G A M E S </b></p>
<p class="calibre1">In the remaining chapters of this book, </p>
<p class="calibre1">we’ll build a few demo programs using </p>
<p class="calibre1">pygame  and  pygwidgets. Each program will </p>
<p class="calibre1">present one or more reusable classes and show </p>
<p class="calibre1">how they can be used in a sample project. </p>
<p class="calibre1">I<a href="index_split_000.html#p32">n Chapter 1, I p</a>resented a text-based Higher or Lower card game. In this chapter we’ll create a GUI version of the game, as shown in Figure 12-1. </p>
<p class="calibre1">To quickly recap the game rules: we start with seven cards face down </p>
<p class="calibre1">and one card face up. The player guesses whether the next card to be </p>
<p class="calibre1">turned over will be higher or lower than the last visible card by pressing </p>
<p class="calibre1">Lower or Higher. When the game is over, the user can click New Game to </p>
<p class="calibre1">start a new round of the game. The player starts with 100 points, gains 15 </p>
<p class="calibre1">points for a correct answer, and loses 10 points for an incorrect answer. </p>
<p class="calibre1"><a id="p297"/><img src="index-297_1.png" alt="Image 34" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 12-1: The user interface of the Higher or Lower game</i></p>
<p class="calibre1"><b class="calibre3">The Card Class</b></p>
<p class="calibre1">In the original text-based version of the game, the code dealing with the </p>
<p class="calibre1">deck of cards was not easily reusable in other projects. To solve this prob-</p>
<p class="calibre1">lem, here we’ll create a highly reusable Deck class that manages cards from a </p>
<p class="calibre1">Card class. </p>
<p class="calibre1">To represent a card in pygame, we need to store the following data in </p>
<p class="calibre1">instance variables for each Card object:</p>
<p class="calibre1">•  Rank (ace, 2, 3, … 10, jack, queen, king)</p>
<p class="calibre1">•  Suit (clubs, hearts, diamonds, spades)</p>
<p class="calibre1">•  Value (1, 2, 3, … 12, 13)</p>
<p class="calibre1">•  Name (built using the rank and suit: for example, 7 of clubs)</p>
<p class="calibre1">•  Image of the back of the card (a single image shared by all Card objects)</p>
<p class="calibre1">•  Image of the front of the card (a unique image for each Card object)</p>
<p class="calibre1">Each card must be able to perform the following behaviors, for which </p>
<p class="calibre1">we will create methods:</p>
<p class="calibre1">•  Mark itself as concealed (face down)</p>
<p class="calibre1">•  Mark itself as revealed (face up)</p>
<p class="calibre1">•  Return its name</p>
<p class="calibre1">•  Return its value</p>
<p class="calibre1">•  Set and get its location in the window</p>
<p class="calibre1">•  Draw itself (either the revealed image or the concealed image)</p>
<p class="calibre1"><b class="calibre3">268</b>   Chapter 12</p>
<p class="calibre1"><a id="p298"/>While the following card behaviors are not used in the Higher or Lower game, we’ll add these too in case they are needed in some other game:</p>
<p class="calibre1">•  Return its rank </p>
<p class="calibre1">•  Return its suit </p>
<p class="calibre1">Listing 12-1 shows the code of the Card class. </p>
<p class="calibre1"><b class="calibre3">File: HigherOrLower/Card.py</b></p>
<p class="calibre1"># Card class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">class Card():</p>
<p class="calibre1">1 BACK_OF_CARD_IMAGE = pygame.image.load('images/BackOfCard.png')</p>
<p class="calibre1">2 def __init__(self, window, rank, suit, value):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.rank = rank</p>
<p class="calibre1">self.suit = suit</p>
<p class="calibre1">self.cardName = rank + ' of ' + suit</p>
<p class="calibre1">self.value = value</p>
<p class="calibre1">3 fileName = 'images/' + self.cardName + '.png' </p>
<p class="calibre1"># Set some starting location; use setLoc below to change</p>
<p class="calibre1">4 self.images = pygwidgets.ImageCollection(window, (0, 0), </p>
<p class="calibre1">{'front': fileName, </p>
<p class="calibre1">'back': Card.BACK_OF_CARD_IMAGE}, 'back')</p>
<p class="calibre1">5 def conceal(self):</p>
<p class="calibre1">self.images.replace('back')</p>
<p class="calibre1">6 def reveal(self):</p>
<p class="calibre1">self.images.replace('front')</p>
<p class="calibre1">7 def getName(self):</p>
<p class="calibre1">return self.cardName</p>
<p class="calibre1">def getValue(self):</p>
<p class="calibre1">return self.value</p>
<p class="calibre1">def getSuit(self):</p>
<p class="calibre1">return self.suit</p>
<p class="calibre1">def getRank(self):</p>
<p class="calibre1">return self.rank</p>
<p class="calibre1">8 def setLoc(self, loc):  # call the setLoc method of the ImageCollection</p>
<p class="calibre1">self.images.setLoc(loc)</p>
<p class="calibre1">Card Games    <b class="calibre3">269</b></p>
<p class="calibre1"><a id="p299"/>  9 def getLoc(self):  # get the location from the ImageCollection loc = self.images.getLoc()</p>
<p class="calibre1">return loc </p>
<p class="calibre1">a def draw(self):</p>
<p class="calibre1">self.images.draw()</p>
<p class="calibre1"> <i class="calibre4">Listing 12-1: The Card class</i></p>
<p class="calibre1">The Card class assumes that image files for all 52 cards, plus an image </p>
<p class="calibre1">for the back of all the cards, are available in a folder named  <i class="calibre4">images</i> inside the project folder. If you download the files associated with this chapter, </p>
<p class="calibre1">you will see that the  <i class="calibre4">images</i> folder contains the full set of .  <i class="calibre4">png</i> files. The files are available via my GitHub repository at <a href="https://github.com/IrvKalb/Object-Oriented-Python-Code/"> <i class="calibre4">https://github.com/IrvKalb/</i></a></p>
<p class="calibre1"><a href="https://github.com/IrvKalb/Object-Oriented-Python-Code/"> <i class="calibre4">Object-Oriented-Python-Code</i></a> <i class="calibre4">/</i>. </p>
<p class="calibre1">The class loads the image of the back of the cards once and saves it in a </p>
<p class="calibre1">class variable 1. That image is available to all Card objects. </p>
<p class="calibre1">When called for each card, the __init__() method 2 starts by storing </p>
<p class="calibre1">the window; building and storing the name of the card; and storing its </p>
<p class="calibre1">rank, value, and suit in instance variables. It then builds the path to the file </p>
<p class="calibre1">in the  <i class="calibre4">images</i> folder that contains the image for that specific card 3. For </p>
<p class="calibre1">example, if the rank is ace and the suit is spades, we build a path of  <i class="calibre4">images/</i></p>
<p class="calibre1"> <i class="calibre4">Ace of Spades.png</i>. We use an ImageCollection object to remember the paths </p>
<p class="calibre1">to both the front and back images 4; we’ll use 'back' to say that we want to </p>
<p class="calibre1">show the back of the card as the starting image. </p>
<p class="calibre1">The conceal() method 5 tells ImageCollection to set the back of the card </p>
<p class="calibre1">as the current image. The reveal() method 6 tells ImageCollection to set the </p>
<p class="calibre1">front of the card as the current image. </p>
<p class="calibre1">The getName(), getValue(), getSuit(), and getRank() methods 7 are getter </p>
<p class="calibre1">methods that allow the caller to retrieve the name, value, suit, and rank of </p>
<p class="calibre1">the given card. </p>
<p class="calibre1">The setLoc() method sets a new location for the card 8, and getLoc() </p>
<p class="calibre1">retrieves the current location 9. The location is kept in the ImageCollection. </p>
<p class="calibre1">Finally, draw() a draws the image of the card in the window. More spe-</p>
<p class="calibre1">cifically, it tells the ImageCollection to draw the currently indicated image at </p>
<p class="calibre1">the remembered location. </p>
<p class="calibre1"><b class="calibre3">The Deck Class</b></p>
<p class="calibre1">A Deck object is a classic example of an object manager object. Its job is to </p>
<p class="calibre1">create and manage 52 Card objects. Listing 12-2 contains the code of our </p>
<p class="calibre1">Deck class. </p>
<p class="calibre1"><b class="calibre3">File: HigerOrLower/Deck.py</b></p>
<p class="calibre1"># Deck class</p>
<p class="calibre1">import random</p>
<p class="calibre1">from Card import *</p>
<p class="calibre1"><b class="calibre3">270</b>   Chapter 12</p>
<p class="calibre1"><a id="p300"/>class Deck():</p>
<p class="calibre1">1 SUIT_TUPLE = ('Diamonds', 'Clubs', 'Hearts', 'Spades')</p>
<p class="calibre1"># This dict maps each card rank to a value for a standard deck</p>
<p class="calibre1">STANDARD_DICT = {'Ace':1, '2':2, '3':3, '4':4, '5':5, </p>
<p class="calibre1">'6':6, '7':7, '8': 8, '9':9, '10':10, </p>
<p class="calibre1">'Jack':11, 'Queen':12, 'King':13}</p>
<p class="calibre1">2 def __init__(self, window, rankValueDict=STANDARD_DICT):</p>
<p class="calibre1"># rankValueDict defaults to STANDARD_DICT, but you can call it </p>
<p class="calibre1"># with a different dict, e.g., a special dict for Blackjack</p>
<p class="calibre1">self.startingDeckList = []</p>
<p class="calibre1">self.playingDeckList = []</p>
<p class="calibre1">for suit in Deck.SUIT_TUPLE:</p>
<p class="calibre1">3 for rank, value in rankValueDict.items():</p>
<p class="calibre1">oCard = Card(window, rank, suit, value)</p>
<p class="calibre1">self.startingDeckList.append(oCard)</p>
<p class="calibre1">self.shuffle()</p>
<p class="calibre1">4 def shuffle(self):</p>
<p class="calibre1"># Copy the starting deck and save it in the playing deck list</p>
<p class="calibre1">self.playingDeckList = self.startingDeckList.copy()</p>
<p class="calibre1">for oCard in self.playingDeckList:</p>
<p class="calibre1">oCard.conceal()</p>
<p class="calibre1">random.shuffle(self.playingDeckList)</p>
<p class="calibre1">5 def getCard(self):</p>
<p class="calibre1">if len(self.playingDeckList) == 0:</p>
<p class="calibre1">raise IndexError('No more cards')</p>
<p class="calibre1"># Pop one card off the deck and return it</p>
<p class="calibre1">oCard = self.playingDeckList.pop()  </p>
<p class="calibre1">return oCard</p>
<p class="calibre1">6 def returnCardToDeck(self, oCard):</p>
<p class="calibre1"># Put a card back into the deck</p>
<p class="calibre1">self.deckList.insert(0, oCard)</p>
<p class="calibre1"> <i class="calibre4">Listing 12-2: A Deck class that manages 52 Card objects</i></p>
<p class="calibre1">We begin the Deck class by creating a few class variables 1 that we’ll </p>
<p class="calibre1">use to create 52 cards with the proper suits and values. There are only four </p>
<p class="calibre1">methods. </p>
<p class="calibre1">To the __init__() method 2, we pass a reference to the window and an </p>
<p class="calibre1">optional dictionary that maps card ranks to their values. If none is passed </p>
<p class="calibre1">in, we use the dictionary for a standard deck of values. We build a deck </p>
<p class="calibre1">of 52 cards, saved in self.startingDeckList, by iterating through all suits, </p>
<p class="calibre1">then iterating through all card ranks and values. In the inner for loop 3, </p>
<p class="calibre1">we use a call to the items() method of a dictionary that allows us to eas-</p>
<p class="calibre1">ily get the key and value (here, the rank and value) in a single statement. </p>
<p class="calibre1">Each time through the inner loop we instantiate a Card object, passing the </p>
<p class="calibre1">rank, suit, and value of the new card. We append each Card object to the </p>
<p class="calibre1">list self.startingDeckList to create a full deck of cards. </p>
<p class="calibre1">Card Games    <b class="calibre3">271</b></p>
<p class="calibre1"><a id="p301"/>The final step is to call the shuffle() method 4 to randomize the </p>
<p class="calibre1">deck. The purpose of this method may seem obvious: to shuffle the deck. </p>
<p class="calibre1">However, it does an extra little trick. The __init__() method built the  </p>
<p class="calibre1">self.startingDeckList, and that work should only be done once. So, when-</p>
<p class="calibre1">ever we shuffle the deck, rather than re-creating all the Card objects, we </p>
<p class="calibre1">make a copy of the starting deck list, save it in self.playingDeckList, and </p>
<p class="calibre1">shuffle that. The copy is what will be used and manipulated as the game </p>
<p class="calibre1">runs. With this approach, we can remove cards from self.playingDeckList </p>
<p class="calibre1">and not have to worry about adding them back into the deck later or reload-</p>
<p class="calibre1">ing cards. The two lists, self.startingDeckList and self.playingDeckList, share </p>
<p class="calibre1">references to the same 52 Card objects. </p>
<p class="calibre1">Note that when we call shuffle() for subsequent runs of the game, some </p>
<p class="calibre1">of the Card objects may be in the “revealed” state. So, before proceeding, we </p>
<p class="calibre1">iterate through the entire deck and call the conceal() method on each card, </p>
<p class="calibre1">so that all cards will initially appear face down. The shuffle() method fin-</p>
<p class="calibre1">ishes by randomizing the cards in the playing deck using random.shuffle(). </p>
<p class="calibre1">The getCard() method 5 retrieves a card from the deck. It first checks </p>
<p class="calibre1">to see if the deck is empty and, if so, raises an exception. Otherwise, since </p>
<p class="calibre1">the deck is already shuffled, it pops a card off the deck and returns that </p>
<p class="calibre1">card to the caller. </p>
<p class="calibre1">Together, Deck and Card provide a highly reusable combination of classes </p>
<p class="calibre1">that can be used in most card games. The Higher or Lower game only uses </p>
<p class="calibre1">eight cards for each round and shuffles the entire deck at the start of each </p>
<p class="calibre1">game. Therefore, in this game it is not possible for the Deck object to run out </p>
<p class="calibre1">of cards. For a card game where you need to know if the deck runs out of </p>
<p class="calibre1">cards, you can build a try block around the call to getCard() and use an except </p>
<p class="calibre1">clause to catch an exception. The choice of what to do there is up to you. </p>
<p class="calibre1">While not used in this game, the returnCardToDeck() method 6 allows </p>
<p class="calibre1">you to put a card back into the deck. </p>
<p class="calibre1"><b class="calibre3">The Higher or Lower Game</b></p>
<p class="calibre1">The code of the actual game is fairly simple: the main code implements the </p>
<p class="calibre1">main loop, and a Game object contains the logic for the game itself. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main Program </b></i></p>
<p class="calibre1">Listing 12-3 is the main program that sets up the world and contains the </p>
<p class="calibre1">main loop. It also creates the Game object that runs the game. </p>
<p class="calibre1"><b class="calibre3">File: HigherOrLower/Main_HigherOrLower.py</b></p>
<p class="calibre1"># Higher or Lower - pygame version</p>
<p class="calibre1"># Main program </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">1 background = pygwidgets.Image(window, (0, 0), </p>
<p class="calibre1"><b class="calibre3">272</b>   Chapter 12</p>
<p class="calibre1"><a id="p302"/>                              'images/background.png')</p>
<p class="calibre1">newGameButton = pygwidgets.TextButton(window, (20, 530), </p>
<p class="calibre1">'New Game', width=100, height=45)</p>
<p class="calibre1">higherButton = pygwidgets.TextButton(window, (540, 520), </p>
<p class="calibre1">'Higher', width=120, height=55)</p>
<p class="calibre1">lowerButton = pygwidgets.TextButton(window, (340, 520), </p>
<p class="calibre1">'Lower', width=120, height=55)</p>
<p class="calibre1">quitButton = pygwidgets.TextButton(window, (880, 530), </p>
<p class="calibre1">'Quit', width=100, height=45)</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">2 oGame = Game(window)</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if ((event.type == QUIT) or </p>
<p class="calibre1">((event.type == KEYDOWN) and (event.key == K_ESCAPE)) or </p>
<p class="calibre1">(quitButton.handleEvent(event))):</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">3 if newGameButton.handleEvent(event):</p>
<p class="calibre1">oGame.reset()</p>
<p class="calibre1">lowerButton.enable()</p>
<p class="calibre1">higherButton.enable()</p>
<p class="calibre1">if higherButton.handleEvent(event):</p>
<p class="calibre1">gameOver = oGame.hitHigherOrLower(HIGHER)</p>
<p class="calibre1">if gameOver:</p>
<p class="calibre1">higherButton.disable()</p>
<p class="calibre1">lowerButton.disable()</p>
<p class="calibre1">if lowerButton.handleEvent(event):</p>
<p class="calibre1">gameOver = oGame.hitHigherOrLower(LOWER)</p>
<p class="calibre1">if gameOver: </p>
<p class="calibre1">higherButton.disable()</p>
<p class="calibre1">lowerButton.disable()</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1"># 9 - Clear the window before drawing it again</p>
<p class="calibre1">4 background.draw()</p>
<p class="calibre1"># 10 - Draw the window elements</p>
<p class="calibre1"># Tell the game to draw itself</p>
<p class="calibre1">5 oGame.draw()</p>
<p class="calibre1"># Draw remaining user interface components</p>
<p class="calibre1">newGameButton.draw()</p>
<p class="calibre1">higherButton.draw()</p>
<p class="calibre1">lowerButton.draw()</p>
<p class="calibre1">quitButton.draw()</p>
<p class="calibre1">Card Games    <b class="calibre3">273</b></p>
<p class="calibre1"><a id="p303"/>    # 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)</p>
<p class="calibre1"> <i class="calibre4">Listing 12-3: The main code of the Higher or Lower game</i></p>
<p class="calibre1">The main program loads the background image and builds four but-</p>
<p class="calibre1">tons 1, then instantiates the Game object 2. </p>
<p class="calibre1">In the main loop, we listen for any of the buttons being pressed 3, and </p>
<p class="calibre1">when one is, we call the appropriate method in the Game object. </p>
<p class="calibre1">At the bottom of the loop, we draw the window elements 4, starting </p>
<p class="calibre1">with the background. Most significantly, we call the draw() method of the </p>
<p class="calibre1">Game object 5. As you will see, the Game object passes this message on to each </p>
<p class="calibre1">of the Card objects. Finally, we draw all four buttons. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Game Object</b></i></p>
<p class="calibre1">The Game object handles the actual game logic. Listing 12-4 contains the </p>
<p class="calibre1">code of the Game class. </p>
<p class="calibre1"><b class="calibre3">File: HigherOrLower/Game.py</b></p>
<p class="calibre1">#  Game class</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">from Constants import *</p>
<p class="calibre1">from Deck import *</p>
<p class="calibre1">from Card import *</p>
<p class="calibre1">class Game():</p>
<p class="calibre1">CARD_OFFSET = 110</p>
<p class="calibre1">CARDS_TOP = 300</p>
<p class="calibre1">CARDS_LEFT = 75</p>
<p class="calibre1">NCARDS = 8</p>
<p class="calibre1">POINTS_CORRECT = 15</p>
<p class="calibre1">POINTS_INCORRECT = 10</p>
<p class="calibre1">def __init__(self, window): 1</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.oDeck = Deck(self.window)</p>
<p class="calibre1">self.score = 100</p>
<p class="calibre1">self.scoreText = pygwidgets.DisplayText(window, (450, 164), </p>
<p class="calibre1">'Score: ' + str(self.score), </p>
<p class="calibre1">fontSize=36, textColor=WHITE, </p>
<p class="calibre1">justified='right')</p>
<p class="calibre1">self.messageText = pygwidgets.DisplayText(window, (50, 460), </p>
<p class="calibre1">'', width=900, justified='center', </p>
<p class="calibre1">fontSize=36, textColor=WHITE)</p>
<p class="calibre1">self.loserSound = pygame.mixer.Sound("sounds/loser.wav")</p>
<p class="calibre1"><b class="calibre3">274</b>   Chapter 12</p>
<p class="calibre1"><a id="p304"/>        self.winnerSound = pygame.mixer.Sound("sounds/ding.wav") self.cardShuffleSound = pygame.mixer.Sound("sounds/cardShuffle.wav")</p>
<p class="calibre1">self.cardXPositionsList = []</p>
<p class="calibre1">thisLeft = Game.CARDS_LEFT</p>
<p class="calibre1"># Calculate the x positions of all cards, once</p>
<p class="calibre1">for cardNum in range(Game.NCARDS):</p>
<p class="calibre1">self.cardXPositionsList.append(thisLeft)</p>
<p class="calibre1">thisLeft = thisLeft + Game.CARD_OFFSET</p>
<p class="calibre1">self.reset()  # start a round of the game</p>
<p class="calibre1">def reset(self): 2  # this method is called when a new round starts</p>
<p class="calibre1">self.cardShuffleSound.play()</p>
<p class="calibre1">self.cardList = []</p>
<p class="calibre1">self.oDeck.shuffle()</p>
<p class="calibre1">for cardIndex in range(0, Game.NCARDS):  # deal out cards</p>
<p class="calibre1">oCard = self.oDeck.getCard()</p>
<p class="calibre1">self.cardList.append(oCard)</p>
<p class="calibre1">thisXPosition = self.cardXPositionsList[cardIndex]</p>
<p class="calibre1">oCard.setLoc((thisXPosition, Game.CARDS_TOP))</p>
<p class="calibre1">self.showCard(0)</p>
<p class="calibre1">self.cardNumber = 0</p>
<p class="calibre1">self.currentCardName, self.currentCardValue = \</p>
<p class="calibre1">self.getCardNameAndValue(self.cardNumber)</p>
<p class="calibre1">self.messageText.setValue('Starting card is ' + self.currentCardName + </p>
<p class="calibre1">'. Will the next card be higher or lower?')</p>
<p class="calibre1">def getCardNameAndValue(self, index):</p>
<p class="calibre1">oCard = self.cardList[index]</p>
<p class="calibre1">theName = oCard.getName()</p>
<p class="calibre1">theValue = oCard.getValue()</p>
<p class="calibre1">return theName, theValue</p>
<p class="calibre1">def showCard(self, index):</p>
<p class="calibre1">oCard = self.cardList[index]</p>
<p class="calibre1">oCard.reveal()</p>
<p class="calibre1">def hitHigherOrLower(self, higherOrLower): 3</p>
<p class="calibre1">self.cardNumber = self.cardNumber + 1</p>
<p class="calibre1">self.showCard(self.cardNumber)</p>
<p class="calibre1">nextCardName, nextCardValue = self.getCardNameAndValue(self.cardNumber)</p>
<p class="calibre1">if higherOrLower == HIGHER:</p>
<p class="calibre1">if nextCardValue &gt; self.currentCardValue:</p>
<p class="calibre1">self.score = self.score + Game.POINTS_CORRECT</p>
<p class="calibre1">self.messageText.setValue('Yes, the ' + nextCardName + ' was higher')</p>
<p class="calibre1">self.winnerSound.play()</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.score = self.score – Game.POINTS_INCORRECT</p>
<p class="calibre1">self.messageText.setValue('No, the ' + nextCardName + ' was not higher')</p>
<p class="calibre1">self.loserSound.play()</p>
<p class="calibre1">Card Games    <b class="calibre3">275</b></p>
<p class="calibre1"><a id="p305"/>        else:  # user hit the Lower button</p>
<p class="calibre1">if nextCardValue &lt; self.currentCardValue:</p>
<p class="calibre1">self.score = self.score + Game.POINTS_CORRECT</p>
<p class="calibre1">self.messageText.setValue('Yes, the ' + nextCardName + ' was lower')</p>
<p class="calibre1">self.winnerSound.play()</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.score = self.score – Game.POINTS_INCORRECT</p>
<p class="calibre1">self.messageText.setValue('No, the ' + nextCardName + ' was not lower')</p>
<p class="calibre1">self.loserSound.play()</p>
<p class="calibre1">self.scoreText.setValue('Score: ' + str(self.score))</p>
<p class="calibre1">self.currentCardValue = nextCardValue  # set up for the next card</p>
<p class="calibre1">done = (self.cardNumber == (Game.NCARDS - 1))  # did we reach the last card? </p>
<p class="calibre1">return done</p>
<p class="calibre1">def draw(self): 4</p>
<p class="calibre1"># Tell each card to draw itself</p>
<p class="calibre1">for oCard in self.cardList:</p>
<p class="calibre1">oCard.draw()</p>
<p class="calibre1">self.scoreText.draw()</p>
<p class="calibre1">self.messageText.draw()</p>
<p class="calibre1"> <i class="calibre4">Listing 12-4: The Game object that runs the game</i></p>
<p class="calibre1">In the __init__() method 1, we initialize a number of instance variables </p>
<p class="calibre1">that only need to be set up once. We create the Deck object, set the starting </p>
<p class="calibre1">score, and create a DisplayText object for displaying the score and the result </p>
<p class="calibre1">of each move. We also load a number of sound files for use during play. </p>
<p class="calibre1">Lastly, we call the reset() method 2, which contains any code needed for </p>
<p class="calibre1">one play of the game: that is, to shuffle the deck, play the shuffling sound, </p>
<p class="calibre1">deal out eight cards, display them in previously computed positions, and </p>
<p class="calibre1">show the face of the first card. </p>
<p class="calibre1">When the user presses the Higher or Lower button, the main code calls </p>
<p class="calibre1">hitHigherOrLower() 3, which turns over the next card, compares the value </p>
<p class="calibre1">with the previous face-up card, and awards or subtracts points. </p>
<p class="calibre1">The draw() method 4 iterates through all the cards in the current game, </p>
<p class="calibre1">telling each to draw itself (by calling each Card object’s draw() method). It </p>
<p class="calibre1">then draws the text of the score and the feedback for the current move. </p>
<p class="calibre1"><b class="calibre3">Testing with __name__ </b></p>
<p class="calibre1">When you write a class, it’s always a good idea to write some test code </p>
<p class="calibre1">to ensure that an object created from that class will work correctly. As a </p>
<p class="calibre1">reminder, any file containing Python code is called a  <i class="calibre4">module</i>. A standard </p>
<p class="calibre1">practice is to write one or more classes in a module, then use an import </p>
<p class="calibre1">statement to bring that module into some other module. When you write a </p>
<p class="calibre1">module that contains a class (or classes), you can add some test code that’s </p>
<p class="calibre1"><b class="calibre3">276</b>   Chapter 12</p>
<p class="calibre1"><a id="p306"/>intended to run  <i class="calibre4">only</i> when the module is run as the main program, and doesn’t run in the typical case when the module is imported by another </p>
<p class="calibre1">Python file. </p>
<p class="calibre1">In a project with multiple Python modules, you typically have one main </p>
<p class="calibre1">module and several other modules. When your program runs, Python cre-</p>
<p class="calibre1">ates the special variable __name__ in every module. In whichever module is </p>
<p class="calibre1">given control first, Python sets the value of __name__ to the string '__main__'. </p>
<p class="calibre1">Therefore, you can write code to check the value of __name__ and execute </p>
<p class="calibre1">some test code only if a module is running as the main program. </p>
<p class="calibre1">I’ll use the Deck class as an example. At the end of  <i class="calibre4">Deck.py</i>, after the </p>
<p class="calibre1">code of the class, I’ve added this code to create an instance of the Deck class </p>
<p class="calibre1">and print out the cards that it creates:</p>
<p class="calibre1">--- snip code of the Deck class ---</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1"># Main code to test the Deck class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1"># Constants</p>
<p class="calibre1">WINDOW_WIDTH = 100</p>
<p class="calibre1">WINDOW_HEIGHT = 100</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">oDeck = Deck(window)</p>
<p class="calibre1">for i in range(1, 53):</p>
<p class="calibre1">oCard = oDeck.getCard()</p>
<p class="calibre1">print('Name: ', oCard.getName(), '  Value:', oCard.getValue())</p>
<p class="calibre1">This checks if the  <i class="calibre4">Deck.py</i> file is running as the main program. In the </p>
<p class="calibre1">typical case where the Deck class is imported by some other module, the </p>
<p class="calibre1">value of __name__ will be 'Deck', so this code does nothing. But if we run </p>
<p class="calibre1"> <i class="calibre4">Deck.py</i> as the main program, for testing purposes only, Python sets the </p>
<p class="calibre1">value of __name__ to '__main__' and this test code runs. </p>
<p class="calibre1">In the test code, we build a minimal pygame program that creates </p>
<p class="calibre1">an instance of the Deck class, then prints out the name and value of all 52 </p>
<p class="calibre1">cards. The output of running  <i class="calibre4">Deck.py</i> as the main program looks like this in the shell or console window:</p>
<p class="calibre1">Name:  4 of Spades   Value: 4</p>
<p class="calibre1">Name:  4 of Diamonds   Value: 4</p>
<p class="calibre1">Name:  Jack of Hearts   Value: 11</p>
<p class="calibre1">Name:  8 of Spades   Value: 8</p>
<p class="calibre1">Name:  10 of Diamonds   Value: 10</p>
<p class="calibre1">Name:  3 of Clubs   Value: 3</p>
<p class="calibre1">Name:  Jack of Diamonds   Value: 11</p>
<p class="calibre1">Name:  9 of Spades   Value: 9</p>
<p class="calibre1">Name:  Ace of Diamonds   Value: 1</p>
<p class="calibre1">Name:  2 of Clubs   Value: 2</p>
<p class="calibre1">Name:  7 of Clubs   Value: 7</p>
<p class="calibre1">Card Games    <b class="calibre3">277</b></p>
<p class="calibre1"><a id="p307"/>Name:  4 of Clubs   Value: 4</p>
<p class="calibre1">Name:  8 of Hearts   Value: 8</p>
<p class="calibre1">Name:  3 of Diamonds   Value: 3</p>
<p class="calibre1">Name:  7 of Spades   Value: 7</p>
<p class="calibre1">Name:  7 of Diamonds   Value: 7</p>
<p class="calibre1">Name:  King of Diamonds   Value: 13</p>
<p class="calibre1">Name:  10 of Spades   Value: 10</p>
<p class="calibre1">Name:  Ace of Hearts   Value: 1</p>
<p class="calibre1">Name:  8 of Diamonds   Value: 8</p>
<p class="calibre1">Name:  Queen of Diamonds   Value: 12</p>
<p class="calibre1">... </p>
<p class="calibre1">Code like this is useful for testing that the class is generally working as </p>
<p class="calibre1">we expect, without having to deal with a larger main program to instanti-</p>
<p class="calibre1">ate it. It gives us a quick way to make sure the class isn’t broken. Depending </p>
<p class="calibre1">on our needs, we could go further and add some example code to illustrate </p>
<p class="calibre1">typical calls to the methods of the class. </p>
<p class="calibre1"><b class="calibre3">Other Card Games</b></p>
<p class="calibre1">There are many card games that use a standard 52-card deck. We could </p>
<p class="calibre1">use the Deck and Card classes as is to build games like Bridge, Hearts, Gin </p>
<p class="calibre1">Rummy, and most Solitaire games. However, there are some card games </p>
<p class="calibre1">that use different card values or different numbers of cards. Let’s look at a </p>
<p class="calibre1">few examples and see how our classes could be adapted for these cases. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Blackjack Deck</b></i></p>
<p class="calibre1">While a deck for Blackjack, also known as 21, uses the same cards as a stan-</p>
<p class="calibre1">dard deck, the  <i class="calibre4">values</i> of the cards are different: the card values for 10, jack, queen, and king are all 10. The __init__() method of the Deck class starts </p>
<p class="calibre1">like this: </p>
<p class="calibre1">def __init__(self, window, rankValueDict=STANDARD_DICT):</p>
<p class="calibre1">To create a Blackjack deck, you would only need to supply a different </p>
<p class="calibre1">dictionary for rankValueDict, like this:</p>
<p class="calibre1">blackJackDict = {'Ace':1, '2':2, '3':3, '4':4, '5':5, </p>
<p class="calibre1">'6':6, '7':7, '8': 8, '9':9, '10':10, </p>
<p class="calibre1">'Jack':10, 'Queen':10, 'King':10}</p>
<p class="calibre1">oBlackjackDeck = Deck(window, rankValueDict=blackJackDict)</p>
<p class="calibre1">Once you create the oBlackjackDeck this way, you can then call the exist-</p>
<p class="calibre1">ing shuffle() and getCard() methods with no change. In the implementation </p>
<p class="calibre1">of Blackjack, you would also have to deal with the fact that an ace can have </p>
<p class="calibre1">a value of 1 or 11. But that, as we say, is an exercise left to the reader! </p>
<p class="calibre1"><b class="calibre3">278</b>   Chapter 12</p>
<p class="calibre1"><a id="p308"/> <i class="calibre4"><b class="calibre3">Games with Unusual Card Decks</b></i></p>
<p class="calibre1">There are a number of card games that do not use a standard deck of 52 </p>
<p class="calibre1">cards. The game of canasta requires at least two decks with jokers, for a </p>
<p class="calibre1">total of 108 cards. A pinochle deck consists of two copies of 9, 10, jack, </p>
<p class="calibre1">queen, king, and ace for each suit, for a total of 48 cards. </p>
<p class="calibre1">For games like these, you could still use the Deck class, but you would </p>
<p class="calibre1">need to create a subclass with Deck as the base class. The new CanastaDeck </p>
<p class="calibre1">or PinochleDeck class would need to have its own __init__() method that </p>
<p class="calibre1">builds a deck as a list consisting of the appropriate Card objects. However, </p>
<p class="calibre1">the shuffle() and getCard() methods could be inherited from the Deck class. </p>
<p class="calibre1">Therefore, a CanastaDeck or PinochleDeck class would subclass the Deck class </p>
<p class="calibre1">and consist of only an __init__() method. </p>
<p class="calibre1"><b class="calibre3">Summary </b></p>
<p class="calibre1">In this chapter, we built a GUI version of the Higher or Lower card game </p>
<p class="calibre1">fro<a href="index_split_000.html#p32">m Chapter 1 u</a>sing highly reusable Deck and Card classes. The main code instantiates a Game object, which creates a Deck object that instantiates 52 Card </p>
<p class="calibre1">objects, one for each card in the resulting deck. Each Card object is respon-</p>
<p class="calibre1">sible for drawing its appropriate image in the window and can respond to </p>
<p class="calibre1">queries about its name, rank, suit, and value. The Game class, which contains </p>
<p class="calibre1">the logic of the game, is separate from the main code, which runs the </p>
<p class="calibre1">main loop. </p>
<p class="calibre1">I demonstrated how Python creates a special variable called __name__ </p>
<p class="calibre1">and gives it different values depending on whether a file is being run as </p>
<p class="calibre1">the main program or not. You can use this feature to add some test code </p>
<p class="calibre1">that runs when you run the file as a main program (to test the code in the </p>
<p class="calibre1">module), but will not run in the typical case when the file is imported by </p>
<p class="calibre1">another module. </p>
<p class="calibre1">Finally, I showed how you can build different types of card decks, </p>
<p class="calibre1">depending on how different they are from the Deck class. </p>
<p class="calibre1">Card Games    <b class="calibre3">279</b></p>
<p class="calibre1"><a id="p309"/>
<a id="p310"/><b class="calibre3">13</b></p>
<p class="calibre1"><b class="calibre3">T I M E R S</b></p>
<p class="calibre1">This chapter is about timers. A  <i class="calibre4">timer</i> </p>
<p class="calibre1">allows your program to count or wait for </p>
<p class="calibre1">a given amount of time before moving on </p>
<p class="calibre1">to perform some other action. In the world of </p>
<p class="calibre1">text-based Python programs, this is easily achieved </p>
<p class="calibre1">with time.sleep() by specifying a number of seconds </p>
<p class="calibre1">to sleep. To pause for two and a half seconds, you </p>
<p class="calibre1">could write:</p>
<p class="calibre1">import time</p>
<p class="calibre1">time.sleep(2.5)</p>
<p class="calibre1">However, in the world of pygame, and event-driven programming in </p>
<p class="calibre1">general, the user should always be able to interact with the program, so </p>
<p class="calibre1">pausing in this way is inappropriate. A call to time.sleep() would make the </p>
<p class="calibre1">program nonreactive during the sleeping period. </p>
<p class="calibre1"><a id="p311"/><img src="index-311_1.png" alt="Image 35" class="calibre2"/></p>
<p class="calibre1"><img src="index-311_2.png" alt="Image 36" class="calibre2"/></p>
<p class="calibre1">Instead, the main loop needs to continue to run at whatever frame </p>
<p class="calibre1">rate you have chosen. You need a way for the program to continue to loop, </p>
<p class="calibre1">but also count time from a given starting point to some time in the future. </p>
<p class="calibre1">There are three different ways this can be accomplished:</p>
<p class="calibre1">•  Measure time by counting frames. </p>
<p class="calibre1">•  Use pygame to create an event that is issued in the future. </p>
<p class="calibre1">•  Remember a start time and continuously check for the elapsed time. </p>
<p class="calibre1">I will quickly discuss the first two, but I’ll focus on the third, as it pro-</p>
<p class="calibre1">vides the cleanest and most accurate approach. </p>
<p class="calibre1"><b class="calibre3">Timer Demonstration Program</b></p>
<p class="calibre1">To illustrate the different approaches, I’ll use different implementations of </p>
<p class="calibre1">the test program shown in Figure 13-1. </p>
<p class="calibre1"> <i class="calibre4">Figure 13-1: The timer demonstration program</i></p>
<p class="calibre1">When the user clicks Start, a 2.5-second timer starts and the window </p>
<p class="calibre1">changes to look like Figure 13-2. </p>
<p class="calibre1"> <i class="calibre4">Figure 13-2: The message displayed while the timer is running</i></p>
<p class="calibre1">For two and a half seconds, the Start button becomes disabled and a </p>
<p class="calibre1">message is displayed below the buttons. When the time expires, the mes-</p>
<p class="calibre1">sage goes away and the Start button is re-enabled. Independent of the timer </p>
<p class="calibre1">running, anything else that the user wants to do in the program still needs </p>
<p class="calibre1">to be responsive. In this example, clicking Click Me prints a message to the </p>
<p class="calibre1">shell window, whether the timer is running or not. </p>
<p class="calibre1"><b class="calibre3">282</b>   Chapter 13</p>
<p class="calibre1"><a id="p312"/><b class="calibre3">Three Approaches for Implementing Timers</b></p>
<p class="calibre1">In this section, I’ll discuss three different approaches to implementing tim-</p>
<p class="calibre1">ers: counting frames, generating a pygame event, and checking for elapsed </p>
<p class="calibre1">time. To make these concepts clear, the following code examples are built </p>
<p class="calibre1">directly in the main loop. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Counting Frames</b></i></p>
<p class="calibre1">A straightforward approach to creating a timer is to count the number of </p>
<p class="calibre1">frames that go by. One frame is the same as one loop iteration. If you know </p>
<p class="calibre1">the frame rate of a program, you can calculate how long to wait by multiply-</p>
<p class="calibre1">ing the time to wait by the frame rate. The following code shows the key </p>
<p class="calibre1">parts of the implementation:</p>
<p class="calibre1"><b class="calibre3">File: InLineTimerExamples/CountingFrames.py</b></p>
<p class="calibre1">FRAMES_PER_SECOND = 30  # takes 1/30th of a second for each frame</p>
<p class="calibre1">TIMER_LENGTH = 2.5</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">timerRunning = False</p>
<p class="calibre1">This code shows what happens when the user clicks the Start button:</p>
<p class="calibre1">if startButton.handleEvent(event):</p>
<p class="calibre1">timerRunning = True</p>
<p class="calibre1">nFramesElapsed = 0  # initialize a counter</p>
<p class="calibre1">nFramesToWait = int(FRAMES_PER_SECOND * TIMER_LENGTH)</p>
<p class="calibre1">startButton.disable()</p>
<p class="calibre1">timerMessage.show()</p>
<p class="calibre1">The program calculates that it should wait for 75 frames (2.5 seconds </p>
<p class="calibre1">× 30 frames per second), and we set timerRunning to True to indicate that the </p>
<p class="calibre1">timer has started. Inside the main loop, we use this code to check for when </p>
<p class="calibre1">the timer ends:</p>
<p class="calibre1">if timerRunning:</p>
<p class="calibre1">nFramesElapsed = nFramesElapsed + 1  # increment the counter</p>
<p class="calibre1">if nFramesElapsed &gt;= nFramesToWait:</p>
<p class="calibre1">startButton.enable()</p>
<p class="calibre1">timerMessage.hide()</p>
<p class="calibre1">print('Timer ended by counting frames')</p>
<p class="calibre1">timerRunning = False</p>
<p class="calibre1">When the timer ends, we re-enable the Start button, hide the message, </p>
<p class="calibre1">and reset the timerRunning variable. (If you prefer, you could set the count </p>
<p class="calibre1">to the number of frames to wait and count down to zero instead.) This </p>
<p class="calibre1">approach works fine, but it is tied to the program’s frame rate. </p>
<p class="calibre1">Timers   <b class="calibre3">283</b></p>
<p class="calibre1"><a id="p313"/> <i class="calibre4"><b class="calibre3">Timer Event</b></i></p>
<p class="calibre1">As a second approach, we’ll take advantage of pygame’s built-in timer. </p>
<p class="calibre1">Pygame allows you to add a new event to the event queue—this is known </p>
<p class="calibre1">as  <i class="calibre4">posting</i> an event. Specifically, we’ll ask pygame to create and post a timer event. We only need to specify how far into the future we want the event to </p>
<p class="calibre1">happen. After the given amount of time, pygame will issue a timer event in </p>
<p class="calibre1">the main loop, in the same way that it issues other standard events such as </p>
<p class="calibre1">KEYUP, KEYDOWN, MOUSEBUTTONUP, MOUSEBUTTONDOWN, and so on. Your code will need </p>
<p class="calibre1">to look for and react to this type of event. </p>
<p class="calibre1">The following documentation is fro<a href="https://www.pygame.org/docs/ref/time.html">m  <i class="calibre4">https://www.pygame.org/docs/ref/</i></a></p>
<p class="calibre1"><a href="https://www.pygame.org/docs/ref/time.html"> <i class="calibre4">time.html</i>:</a></p>
<p class="calibre1">pygame.time.set_timer()</p>
<p class="calibre1"> <i class="calibre4">Repeatedly create an event on the event queue</i></p>
<p class="calibre1">set_timer(eventid, milliseconds) -&gt; None</p>
<p class="calibre1">set_timer(eventid, milliseconds, once) -&gt; None</p>
<p class="calibre1">Set an event type to appear on the event queue every given number of </p>
<p class="calibre1">milliseconds. The first event will not appear until the amount of time </p>
<p class="calibre1">has passed. </p>
<p class="calibre1">Every event type can have a separate timer attached to it. It is best to </p>
<p class="calibre1">use the value between pygame.USEREVENT and pygame.NUMEVENTS. </p>
<p class="calibre1">To disable the timer for an event, set the milliseconds argument to 0. </p>
<p class="calibre1">If the once argument is True, then only send the timer once. </p>
<p class="calibre1">Every event type in pygame is represented by unique identifier. As of </p>
<p class="calibre1">pygame 2.0, you can now make a call to pygame.event.custom_type() to get an </p>
<p class="calibre1">identifier for a custom event. </p>
<p class="calibre1"><b class="calibre3">File: InLineTimerExamples /TimerEvent.py</b></p>
<p class="calibre1">TIMER_EVENT_ID = pygame.event.custom_type()  # new in pygame 2.0</p>
<p class="calibre1">TIMER_LENGTH = 2.5  # seconds</p>
<p class="calibre1">When the user clicks Start, the code creates and posts the timer event:</p>
<p class="calibre1">if startButton.handleEvent(event):</p>
<p class="calibre1">pygame.time.set_timer(TIMER_EVENT_ID, </p>
<p class="calibre1">int(TIMER_LENGTH * 1000), True)</p>
<p class="calibre1">--- snip disable button, show message ---</p>
<p class="calibre1">The value calculated is 2,500 milliseconds. True means that the timer </p>
<p class="calibre1">should only run once (generate only one event). We now need code in the </p>
<p class="calibre1">event loop that checks for the event happening:</p>
<p class="calibre1">if event.type == TIMER_EVENT_ID:</p>
<p class="calibre1">--- snip enable button, hide message ---</p>
<p class="calibre1"><b class="calibre3">284</b>   Chapter 13</p>
<p class="calibre1"><a id="p314"/>Since we specified True in the call to set the timer, this event is issued only once. If we want to repeat events every 2,500 milliseconds, we could set </p>
<p class="calibre1">the last argument in the original call to False (or just let it default to False). </p>
<p class="calibre1">To end repeated timer events, we would make a call to set_timer() and pass </p>
<p class="calibre1">0 (zero) as the second argument. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Building a Timer by Calculating Elapsed Time</b></i></p>
<p class="calibre1">The third approach for implementing a timer uses the current time as a </p>
<p class="calibre1">starting point. We can then continuously query the current time and per-</p>
<p class="calibre1">form a simple subtraction to calculate the elapsed time. The code shown </p>
<p class="calibre1">for this example runs in the main loop; later, we’ll extract the timer-related </p>
<p class="calibre1">code and build a reusable Timer class. </p>
<p class="calibre1">The time module of the Python Standard Library has this function:</p>
<p class="calibre1">time.time()</p>
<p class="calibre1">Calling this function returns the current time in seconds as a floating-</p>
<p class="calibre1">point number. The value returned is the number of seconds that have passed </p>
<p class="calibre1">since “epoch time,” which is defined as 00:00:00 UTC on January 1, 1970. </p>
<p class="calibre1">The code in Listing 13-1 creates a timer by remembering the time when </p>
<p class="calibre1">the user clicks Start. While the timer is running, we check in every frame to </p>
<p class="calibre1">see if the desired amount of time has elapsed. You’ve already seen the user </p>
<p class="calibre1">interface, so I’ll omit those details and some of the setup code for brevity. </p>
<p class="calibre1"><b class="calibre3">File: InLineTimerExamples/ElapsedTime.py</b></p>
<p class="calibre1"># Timer in the main loop</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">TIMER_LENGTH = 2.5  # seconds</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">timerRunning = False</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">1 if startButton.handleEvent(event):</p>
<p class="calibre1">timeStarted = time.time()  # remember the start time</p>
<p class="calibre1">startButton.disable()</p>
<p class="calibre1">timerMessage.show()</p>
<p class="calibre1">print('Starting timer')</p>
<p class="calibre1">timerRunning = True</p>
<p class="calibre1">Timers   <b class="calibre3">285</b></p>
<p class="calibre1"><a id="p315"/>        if clickMeButton.handleEvent(event):</p>
<p class="calibre1">print('Other button was clicked')</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">2 if timerRunning:  # if the timer is running</p>
<p class="calibre1">elapsed = time.time() - timeStarted</p>
<p class="calibre1">3 if elapsed &gt;= TIMER_LENGTH:  # True here means timer has ended</p>
<p class="calibre1">startButton.enable()</p>
<p class="calibre1">timerMessage.hide()</p>
<p class="calibre1">print('Timer ended')</p>
<p class="calibre1">timerRunning = False</p>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(WHITE)</p>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">headerMessage.draw()</p>
<p class="calibre1">startButton.draw()</p>
<p class="calibre1">clickMeButton.draw()</p>
<p class="calibre1">timerMessage.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 13-1: A timer built into the main loop</i></p>
<p class="calibre1">The important variables to notice in this program are:</p>
<p class="calibre1"><b class="calibre3">TIMER_LENGTH     </b>A constant that says how long we want our timer to run</p>
<p class="calibre1"><b class="calibre3">timerRunning     </b>A Boolean that tells us whether the timer is running</p>
<p class="calibre1"><b class="calibre3">timeStarted     </b>The time at which the user pressed the Start button</p>
<p class="calibre1">When the user clicks Start, timerRunning is set to True 1. We initialize the </p>
<p class="calibre1">variable startTime to the current time. We then disable the Start button and </p>
<p class="calibre1">show the message below the buttons. </p>
<p class="calibre1">Each time through the loop, if the timer is running 2, we subtract </p>
<p class="calibre1">the starting time from the current time to see how much time has elapsed </p>
<p class="calibre1">since the timer started. When the amount of time elapsed becomes greater </p>
<p class="calibre1">than or equal to TIMER_LENGTH, whatever action we want to happen when the </p>
<p class="calibre1">time is up can happen. In this sample program, we enable the Start but-</p>
<p class="calibre1">ton, remove the bottom message, print a short text output, and reset the </p>
<p class="calibre1">timerRunning variable to False 3. </p>
<p class="calibre1">The code in Listing 13-1 works fine . . . for a single timer. However, this </p>
<p class="calibre1">is a book on object-oriented programming, so we want this to be scalable. </p>
<p class="calibre1">To generalize the functionality, we’ll turn the timing code into a class. </p>
<p class="calibre1">We’ll take the important variables, turn them into instance variables, and </p>
<p class="calibre1">split the code into methods. That way, we can define and use any number </p>
<p class="calibre1"><b class="calibre3">286</b>   Chapter 13</p>
<p class="calibre1"><a id="p316"/>of timers in a program. The Timer class, along with other classes used to display timing in pygame programs, are available in a module named </p>
<p class="calibre1">pyghelpers. </p>
<p class="calibre1"><b class="calibre3">Installing pyghelpers </b></p>
<p class="calibre1">To install pyghelpers, open the command line and enter the following two </p>
<p class="calibre1">commands:</p>
<p class="calibre1"><b class="calibre3">python3 -m pip install -U pip --user</b></p>
<p class="calibre1"><b class="calibre3">python3 -m pip install -U pyghelpers --user</b></p>
<p class="calibre1">These commands download and install pyghelpers from PyPI into a </p>
<p class="calibre1">folder that is available to all your Python programs. Once installed, you can </p>
<p class="calibre1">use pyghelpers by including the following statement at the beginning of your </p>
<p class="calibre1">programs:</p>
<p class="calibre1">import pyghelpers </p>
<p class="calibre1">You can then instantiate objects from the classes in the module and call </p>
<p class="calibre1">the methods of those objects. The most current documentation of pyghelpers </p>
<p class="calibre1">is at <a href="https://pyghelpers.readthedocs.io/en/latest/"> <i class="calibre4">https://pyghelpers.readthedocs.io/en/latest/</i></a>, and the source code is available via my GitHub repository at <a href="https://github.com/IrvKalb/pyghelpers"> <i class="calibre4">https://github.com/IrvKalb/pyghelpers/</i></a>. </p>
<p class="calibre1"><b class="calibre3">The Timer Class</b></p>
<p class="calibre1">Listing 13-2 contains the code of a very simple timer as a class. This code is </p>
<p class="calibre1">built into the pyghelpers package as the Timer class (I’ve omitted some of the </p>
<p class="calibre1">documentation here for brevity). </p>
<p class="calibre1"><b class="calibre3">File: (Available as part of the pyghelpers module)</b></p>
<p class="calibre1"># Timer class</p>
<p class="calibre1">class Timer():</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">1 def __init__(self, timeInSeconds, nickname=None, callBack=None):</p>
<p class="calibre1">self.timeInSeconds = timeInSeconds</p>
<p class="calibre1">self.nickname = nickname</p>
<p class="calibre1">self.callBack = callBack</p>
<p class="calibre1">self.savedSecondsElapsed = 0.0</p>
<p class="calibre1">self.running = False</p>
<p class="calibre1">2 def start(self, newTimeInSeconds=None):</p>
<p class="calibre1">Timers   <b class="calibre3">287</b></p>
<p class="calibre1"><a id="p317"/>        --- snip ---</p>
<p class="calibre1">if newTimeInSeconds != None:</p>
<p class="calibre1">self.timeInSeconds = newTimeInSeconds</p>
<p class="calibre1">self.running = True</p>
<p class="calibre1">self.startTime = time.time()</p>
<p class="calibre1">3 def update(self):</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">if not self.running:</p>
<p class="calibre1">return False</p>
<p class="calibre1">self.savedSecondsElapsed = time.time() - self.startTime</p>
<p class="calibre1">if self.savedSecondsElapsed &lt; self.timeInSeconds:</p>
<p class="calibre1">return False  # running but hasn't reached limit</p>
<p class="calibre1">else:  # timer has finished</p>
<p class="calibre1">self.running = False</p>
<p class="calibre1">if self.callBack is not None:</p>
<p class="calibre1">self.callBack(self.nickname)</p>
<p class="calibre1">return True  # True here means that the timer has ended</p>
<p class="calibre1">4 def getTime(self):</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">if self.running:</p>
<p class="calibre1">self.savedSecondsElapsed = time.time() - self.startTime</p>
<p class="calibre1"/>
<p class="calibre1">return self.savedSecondsElapsed</p>
<p class="calibre1">5 def stop(self):</p>
<p class="calibre1">"""Stops the timer""" </p>
<p class="calibre1">self.getTime()  # remembers final self.savedSecondsElapsed</p>
<p class="calibre1">self.running = False</p>
<p class="calibre1"> <i class="calibre4">Listing 13-2: A simple Timer class</i></p>
<p class="calibre1">When you create a Timer object, the only required argument is the num-</p>
<p class="calibre1">ber of seconds you want the timer to run 1. You can optionally supply a </p>
<p class="calibre1">nickname for the timer and a function or method to be called back when </p>
<p class="calibre1">the time has elapsed. If you specify a callback, the nickname will be passed </p>
<p class="calibre1">in when the callback happens. </p>
<p class="calibre1">You call the start() method 2 to start the timer running. The Timer </p>
<p class="calibre1">object remembers the start time in the instance variable self.startTime. </p>
<p class="calibre1">The update() method 3 must be called every time through the main </p>
<p class="calibre1">loop. If the timer is running and the appropriate amount of time has </p>
<p class="calibre1">elapsed, this method returns True. In any other call, this method returns </p>
<p class="calibre1">False. </p>
<p class="calibre1">If a Timer is running, calling getTime() 4 returns how much time has </p>
<p class="calibre1">elapsed for that Timer. You can call the stop() method 5 to immediately </p>
<p class="calibre1">stop the Timer. </p>
<p class="calibre1">We can now rewrite the timer demonstration program shown in </p>
<p class="calibre1">Figure 13-1 to use this Timer class from the pyghelpers package. Listing 13-3 </p>
<p class="calibre1">shows how we use a Timer object in the code. </p>
<p class="calibre1"><b class="calibre3">288</b>   Chapter 13</p>
<p class="calibre1"><a id="p318"/><b class="calibre3">File: TimerObjectExamples/SimpleTimerExample.py</b></p>
<p class="calibre1"># Simple timer example</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">1 oTimer = pyghelpers.Timer(TIMER_LENGTH)  # create a Timer object</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if startButton.handleEvent(event):</p>
<p class="calibre1">2 oTimer.start()  # start the timer</p>
<p class="calibre1">startButton.disable()</p>
<p class="calibre1">timerMessage.show()</p>
<p class="calibre1">print('Starting timer')</p>
<p class="calibre1">if clickMeButton.handleEvent(event):</p>
<p class="calibre1">print('Other button was clicked')</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">3 if oTimer.update():  # True here means timer has ended</p>
<p class="calibre1">startButton.enable()</p>
<p class="calibre1">timerMessage.hide()</p>
<p class="calibre1">print('Timer ended')</p>
<p class="calibre1"># 9 - Clear the screen</p>
<p class="calibre1">window.fill(WHITE)</p>
<p class="calibre1"># 10 - Draw all screen elements</p>
<p class="calibre1">headerMessage.draw()</p>
<p class="calibre1">startButton.draw()</p>
<p class="calibre1">clickMeButton.draw()</p>
<p class="calibre1">timerMessage.draw()</p>
<p class="calibre1"># 11 - Update the screen</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 13-3: A main program that uses an instance of the Timer class</i></p>
<p class="calibre1">Again, I’ve cut the setup code. Before the main loop starts, we create a </p>
<p class="calibre1">Timer object 1. When the user clicks Start, we call oTimer.start() 2 to start </p>
<p class="calibre1">the timer running. </p>
<p class="calibre1">Timers   <b class="calibre3">289</b></p>
<p class="calibre1"><a id="p319"/><img src="index-319_1.png" alt="Image 37" class="calibre2"/></p>
<p class="calibre1">Each time through the loop, we call the update() method of the Timer </p>
<p class="calibre1">object 3. There are two ways to know when the timer ends. The simple </p>
<p class="calibre1">way is to check for this call returning True. The sample code in Listing 13-3 </p>
<p class="calibre1">uses this approach. Alternatively, if we specified a value for callBack in the </p>
<p class="calibre1">__init__() call, when the timer finished, whatever was specified as the </p>
<p class="calibre1">callBack value would be called back. In most cases, I would suggest using </p>
<p class="calibre1">the first approach. </p>
<p class="calibre1">There are two advantages to using a Timer class. First, it hides the details </p>
<p class="calibre1">of the timing code; you only create a Timer object when you want to, and </p>
<p class="calibre1">you call the methods of that object. Second, you can create as many Timer </p>
<p class="calibre1">objects as you wish, and each will run independently. </p>
<p class="calibre1"><b class="calibre3">Displaying Time</b></p>
<p class="calibre1">Many programs will need to count and display time to the user. For exam-</p>
<p class="calibre1">ple, in a game, the elapsed time might be constantly displayed and updated, </p>
<p class="calibre1">or the user might have a set amount of time to complete a task, requiring a </p>
<p class="calibre1">countdown timer. I’ll demonstrate how to do both of these using the Slider </p>
<p class="calibre1">Puzzle game pictured in Figure 13-3. </p>
<p class="calibre1"> <i class="calibre4">Figure 13-3: The Slider Puzzle user interface</i></p>
<p class="calibre1">When you start this game, the tiles are randomly rearranged, and there </p>
<p class="calibre1">is one empty black space. The goal of the game is to move tiles one at a time </p>
<p class="calibre1">to put them in order from 1 to 15. You are only allowed to click a tile that is </p>
<p class="calibre1">horizontally or vertically adjacent to the empty square. Clicking a valid tile </p>
<p class="calibre1">swaps it with the space. I won’t get into the details of the full implementa-</p>
<p class="calibre1">tion of the game (although the source code is available online, with the rest </p>
<p class="calibre1">of the book’s resources). Instead, I will focus on how to integrate a timer. </p>
<p class="calibre1">The pyghelpers package contains two classes that allow programmers to </p>
<p class="calibre1">track time. The first is CountUpTimer, which starts at zero and counts up indef-</p>
<p class="calibre1">initely, or until you tell it to stop. The second is CountDownTimer, which starts </p>
<p class="calibre1">at a given amount of time and counts down to zero. I’ve built a version of </p>
<p class="calibre1"><b class="calibre3">290</b>   Chapter 13</p>
<p class="calibre1"><a id="p320"/>the game for each. The first version lets the user see how long it takes them to solve the puzzle. In the second one, the user is given a certain amount of </p>
<p class="calibre1">time when they start the game, and if they have not completed it when the </p>
<p class="calibre1">timer reaches zero, they lose the game. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">CountUpTimer</b></i></p>
<p class="calibre1">With the CountUpTimer class, you create a timer object and tell it when to </p>
<p class="calibre1">start. Then, in every frame, you can call one of three different methods to </p>
<p class="calibre1">get the time elapsed in different formats. </p>
<p class="calibre1">Listing 13-4 contains the implementation of the CountUpTimer class from </p>
<p class="calibre1">pyghelpers. The code is a good example of how the different methods of a </p>
<p class="calibre1">class share instance variables. </p>
<p class="calibre1"><b class="calibre3">File: (Available as part of the pyghelpers module)</b></p>
<p class="calibre1"># CountUpTimer class</p>
<p class="calibre1">class CountUpTimer():</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">def __init__(self): 1 </p>
<p class="calibre1">self.running = False</p>
<p class="calibre1">self.savedSecondsElapsed = 0.0</p>
<p class="calibre1">self.secondsStart = 0  # safeguard</p>
<p class="calibre1">def start(self): 2 </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">self.secondsStart = time.time()  # get the current seconds and save the value</p>
<p class="calibre1">self.running = True</p>
<p class="calibre1">self.savedSecondsElapsed = 0.0</p>
<p class="calibre1">def getTime(self): 3 </p>
<p class="calibre1">"""Returns the time elapsed as a float""" </p>
<p class="calibre1">if not self.running:</p>
<p class="calibre1">return self.savedSecondsElapsed  # do nothing</p>
<p class="calibre1"/>
<p class="calibre1">self.savedSecondsElapsed = time.time() - self.secondsStart</p>
<p class="calibre1">return self.savedSecondsElapsed  # returns a float</p>
<p class="calibre1">def getTimeInSeconds(self): 4 </p>
<p class="calibre1">"""Returns the time elapsed as an integer number of seconds""" </p>
<p class="calibre1">nSeconds = int(self.getTime())</p>
<p class="calibre1">return nSeconds</p>
<p class="calibre1"># Updated version using fStrings</p>
<p class="calibre1">def getTimeInHHMMSS(self, nMillisecondsDigits=0): 5 </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">nSeconds = self.getTime()</p>
<p class="calibre1">mins, secs = divmod(nSeconds, 60)</p>
<p class="calibre1">hours, mins = divmod(int(mins), 60)</p>
<p class="calibre1">if nMillisecondsDigits &gt; 0:</p>
<p class="calibre1">Timers   <b class="calibre3">291</b></p>
<p class="calibre1"><a id="p321"/>            secondsWidth = nMillisecondsDigits + 3</p>
<p class="calibre1">else:</p>
<p class="calibre1">secondsWidth = 2</p>
<p class="calibre1">if hours &gt; 0:</p>
<p class="calibre1">output = </p>
<p class="calibre1">f'{hours:d}:{mins:02d}:{secs:0{secondsWidth}.{nMillisecondsDigits}f}' </p>
<p class="calibre1">elif mins &gt; 0:</p>
<p class="calibre1">output = f'{mins:d}:{secs:0{secondsWidth}.{nMillisecondsDigits}f}' </p>
<p class="calibre1">else:</p>
<p class="calibre1">output = f'{secs:.{nMillisecondsDigits}f}' </p>
<p class="calibre1">return output</p>
<p class="calibre1"/>
<p class="calibre1">def stop(self): 6 </p>
<p class="calibre1">"""Stops the timer""" </p>
<p class="calibre1">self.getTime()  # remembers final self.savedSecondsElapsed</p>
<p class="calibre1">self.running = False</p>
<p class="calibre1"> <i class="calibre4">Listing 13-4: The CountUpTimer class</i></p>
<p class="calibre1">The implementation depends on three key instance variables 1: </p>
<p class="calibre1">•  self.running is a Boolean that indicates whether the timer is running or </p>
<p class="calibre1">not. </p>
<p class="calibre1">•  self.savedSecondsElapsed is a float that represents the elapsed time of a </p>
<p class="calibre1">timer. </p>
<p class="calibre1">•  self.secondsStart is the time that the timer started running. </p>
<p class="calibre1">The client calls the start() method 2 to start a timer. In response, the </p>
<p class="calibre1">method calls time.time(), stores the start time in self.secondsStart, and sets </p>
<p class="calibre1">self.running to True to indicate that the timer is running. </p>
<p class="calibre1">The client can call any of these three methods to get the elapsed time </p>
<p class="calibre1">associated with the timer, in different formats:</p>
<p class="calibre1">•  getTime() 3 returns the elapsed time as a floating-point number. </p>
<p class="calibre1">•  getTimeInSeconds() 4 returns the elapsed time as an integer number of </p>
<p class="calibre1">seconds. </p>
<p class="calibre1">•  getTimeInHHMMSS() 5 returns the elapsed time as a formatted string. </p>
<p class="calibre1">The getTime() method calls time.time() to get the current time and </p>
<p class="calibre1">subtracts the starting time to get the elapsed time. The other two meth-</p>
<p class="calibre1">ods each make a call to the getTime() method of this class to calculate the </p>
<p class="calibre1">elapsed time, then do different processing on the output: getTimeInSeconds() </p>
<p class="calibre1">converts the time into an integer number of seconds, and getTimeInHHMMSS() </p>
<p class="calibre1">formats the time into a string in  <i class="calibre4">hours:minutes:seconds</i> format. The output of each of these methods is intended to be sent to a DisplayText object (defined </p>
<p class="calibre1">in the pygwidgets package) to be shown in the window. </p>
<p class="calibre1">The stop() method 6 can be called to stop the timer (for example, </p>
<p class="calibre1">when the user completes the puzzle). </p>
<p class="calibre1"><b class="calibre3">292</b>   Chapter 13</p>
<p class="calibre1"><a id="p322"/>The main file for this version of the Slider Puzzle game is available with the rest of the book’s resources, at  <i class="calibre4">SliderPuzzles/Main_SliderPuzzleCountUp.py</i>. </p>
<p class="calibre1">It instantiates a CountUpTimer object before the main loop begins and saves </p>
<p class="calibre1">it in the variable oCountUpTimer. It then calls the start() method right away. </p>
<p class="calibre1">It also creates a DisplayText field to display the time. Each time through the </p>
<p class="calibre1">main loop, the main code calls the getTimeInHHMMSS() method and shows the </p>
<p class="calibre1">result in the field: </p>
<p class="calibre1">timeToShow = oCountUpTimer.getTimeInHHMMSS()  # ask the Timer object for the elapsed time oTimerDisplay.setValue('Time: ' + timeToShow)  # put that into a text field</p>
<p class="calibre1">The variable oTimerDisplay is an instance of the pygwidgets.DisplayText </p>
<p class="calibre1">class. The setValue() method of the DisplayText class is optimized to check </p>
<p class="calibre1">whether the new text to be displayed is the same as the previous text. </p>
<p class="calibre1">Therefore, even though we are telling the field to display the amount of </p>
<p class="calibre1">time 30 times every second, there is not much work done until the time </p>
<p class="calibre1">changes, once per second. </p>
<p class="calibre1">The game code checks for a solved puzzle and, when the puzzle is </p>
<p class="calibre1">solved, calls the stop() method to freeze the time. If the user clicks the </p>
<p class="calibre1">Restart button to start a new game, the game calls start() to restart the </p>
<p class="calibre1">timer object. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">CountDownTimer</b></i></p>
<p class="calibre1">The CountDownTimer class has some subtle differences. Instead of counting up </p>
<p class="calibre1">from zero, you initialize a CountDownTimer by providing a starting number of </p>
<p class="calibre1">seconds, and it counts down from that value. The interface for creating a </p>
<p class="calibre1">CountDownTimer looks like this:</p>
<p class="calibre1">CountDownTimer(nStartingSeconds, stopAtZero=True, nickname=None, </p>
<p class="calibre1">callBack=None):</p>
<p class="calibre1">There is a second optional parameter, stopAtZero, that defaults to True—</p>
<p class="calibre1">which assumes that you want the timer to stop when it reaches zero. You can </p>
<p class="calibre1">also optionally specify a function or method as a callback when the timer </p>
<p class="calibre1">reaches zero. Lastly, you can supply a nickname to be used if and when a </p>
<p class="calibre1">callback is made. </p>
<p class="calibre1">The client calls the start() method to begin counting down. </p>
<p class="calibre1">From the client’s point of view, the getTime(), getTimeInSeconds(), </p>
<p class="calibre1">getTimeInHHMMSS(), and stop() methods appear identical to their counter-</p>
<p class="calibre1">parts in the CountUpTimer class. </p>
<p class="calibre1">CountDownTimer has an additional method named ended(). The applica-</p>
<p class="calibre1">tion needs to call the ended() method every time through its main loop. It </p>
<p class="calibre1">returns False while the timer is active, but returns True when the timer ends </p>
<p class="calibre1">(that is, reaches zero). </p>
<p class="calibre1">The countdown version of the Slider Puzzle game’s main file is available </p>
<p class="calibre1">with the book’s resources, at  <i class="calibre4">SliderPuzzles/Main_SliderPuzzleCountDown.py</i>. </p>
<p class="calibre1">The code is very similar to the previous version that counts up, but </p>
<p class="calibre1">this version creates an instance of CountDownTimer instead and supplies a set </p>
<p class="calibre1">Timers   <b class="calibre3">293</b></p>
<p class="calibre1"><a id="p323"/>number of seconds it allows to solve the puzzle. It also calls getTimeInHHMMSS(2) every frame and updates the time with two decimal digits. Finally, it includes </p>
<p class="calibre1">a call to the ended() method in every frame to see if the time has run out. If </p>
<p class="calibre1">the timer ends before the user has solved the puzzle, it plays a sound and </p>
<p class="calibre1">displays a message telling the user that they ran out of time. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">This chapter gave you a number of ways to handle timing in programs. I </p>
<p class="calibre1">discussed three different approaches: first by counting frames, second by </p>
<p class="calibre1">creating a custom event, and finally by remembering a start time and sub-</p>
<p class="calibre1">tracting it from the current time to get the time elapsed. </p>
<p class="calibre1">Using the third approach, we built a generic reusable Timer class (which </p>
<p class="calibre1">you can find in the pyghelpers package). I also showed two additional classes </p>
<p class="calibre1">from this package, CountUpTimer and CountDownTimer, that can be used to han-</p>
<p class="calibre1">dle timing in programs where you want to show a timer to the user. </p>
<p class="calibre1"><b class="calibre3">294</b>   Chapter 13</p>
<p class="calibre1"><a id="p324"/><b class="calibre3">14</b></p>
<p class="calibre1"><b class="calibre3">A N I M A T I O N</b></p>
<p class="calibre1">This chapter is about animation—</p>
<p class="calibre1">s pecifically, traditional image animation. </p>
<p class="calibre1">On a very simple level, you can think of </p>
<p class="calibre1">this like a flip-book: a series of images, each </p>
<p class="calibre1">slightly different from the previous one, that are </p>
<p class="calibre1">shown in succession. The user sees each image for a </p>
<p class="calibre1">short amount of time and experiences the illusion of </p>
<p class="calibre1">movement. Animation provides a good opportunity </p>
<p class="calibre1">for building a class because the mechanics of display-</p>
<p class="calibre1">ing the images over time are well understood and </p>
<p class="calibre1">easily  coded. </p>
<p class="calibre1">To show the general principles, we’ll begin by implementing two anima-</p>
<p class="calibre1">tion classes: a SimpleAnimation class based on a series of individual image files, </p>
<p class="calibre1">and a SimpleSpriteSheetAnimation class built using a single file that contains </p>
<p class="calibre1"><a id="p325"/>a sequence of many images. Then I’ll show you two more-robust animation classes from the pygwidgets package, Animation and SpriteSheetAnimation, and </p>
<p class="calibre1">explain how they are built using a common base class. </p>
<p class="calibre1"><b class="calibre3">Building Animation Classes</b></p>
<p class="calibre1">The basic idea behind an animation class is relatively straightforward. The </p>
<p class="calibre1">client will provide an ordered set of images and an amount of time. The cli-</p>
<p class="calibre1">ent code will tell the animation when to start playing and will periodically </p>
<p class="calibre1">tell the animation to update itself. The images in the animation will be dis-</p>
<p class="calibre1">played in order, each for the given amount of time. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">SimpleAnimation Class</b></i></p>
<p class="calibre1">The general technique is to begin by loading the complete set of images, </p>
<p class="calibre1">storing them in a list, and displaying the first image. When the client tells </p>
<p class="calibre1">the animation to start, the animation begins tracking time. Each time the </p>
<p class="calibre1">object is told to update itself, our code checks to see if the specified amount </p>
<p class="calibre1">of time has passed and, if so, displays the next image in the sequence. </p>
<p class="calibre1">When the animation is finished, we display the first image again. </p>
<p class="calibre1"><b class="calibre3">Creating the Class</b></p>
<p class="calibre1">Listing 14-1 contains the code of a SimpleAnimation class, which handles an </p>
<p class="calibre1">animation made up of separate image files. To keep things clearly orga-</p>
<p class="calibre1">nized, I strongly recommend that you place all the image files associated </p>
<p class="calibre1">with an animation in a subfolder inside an  <i class="calibre4">images</i> folder inside your project folder. The examples given here will use this structure, and the associated </p>
<p class="calibre1">art and main code are available with the rest of the book’s resources. </p>
<p class="calibre1"><b class="calibre3">File: SimpleAnimation/SimpleAnimation.py</b></p>
<p class="calibre1"># SimpleAnimation class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import time</p>
<p class="calibre1">class SimpleAnimation():</p>
<p class="calibre1">def __init__(self, window, loc, picPaths durationPerImage): 1</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.loc = loc</p>
<p class="calibre1">self.imagesList = []</p>
<p class="calibre1">for picPath in picPaths:</p>
<p class="calibre1">image = pygame.image.load(picPath)  # load an image</p>
<p class="calibre1">image = pygame.Surface.convert_alpha(image) 2  # optimize blitting</p>
<p class="calibre1">self.imagesList.append(image)</p>
<p class="calibre1">self.playing = False</p>
<p class="calibre1">self.durationPerImage = durationPerImage</p>
<p class="calibre1">self.nImages = len(self.imagesList)</p>
<p class="calibre1"><b class="calibre3">296</b>   Chapter 14</p>
<p class="calibre1"><a id="p326"/>        self.index = 0</p>
<p class="calibre1">def play(self): 3</p>
<p class="calibre1">if self.playing:</p>
<p class="calibre1">return</p>
<p class="calibre1">self.playing = True</p>
<p class="calibre1">self.imageStartTime = time.time()</p>
<p class="calibre1">self.index = 0</p>
<p class="calibre1">def update(self): 4</p>
<p class="calibre1">if not self.playing:</p>
<p class="calibre1">return</p>
<p class="calibre1"># How much time has elapsed since we started showing this image</p>
<p class="calibre1">self.elapsed = time.time() - self.imageStartTime</p>
<p class="calibre1"># If enough time has elapsed, move on to the next image</p>
<p class="calibre1">if self.elapsed &gt; self.durationPerImage:</p>
<p class="calibre1">self.index = self.index + 1</p>
<p class="calibre1">if self.index &lt; self.nImages: # move on to next image</p>
<p class="calibre1">self.imageStartTime = time.time()</p>
<p class="calibre1">else:  # animation is finished</p>
<p class="calibre1">self.playing = False</p>
<p class="calibre1">self.index = 0  # reset to the beginning</p>
<p class="calibre1">def draw(self): 5</p>
<p class="calibre1"># Assumes that self.index has been set earlier - in the update() method. </p>
<p class="calibre1"># It is used as the index into the imagesList to find the current image. </p>
<p class="calibre1">theImage = self.imagesList[self.index]  # choose the image to show</p>
<p class="calibre1">self.window.blit(theImage, self.loc)  # show it</p>
<p class="calibre1"> <i class="calibre4">Listing 14-1: The SimpleAnimation class</i></p>
<p class="calibre1">When a client instantiates a SimpleAnimation object, it must pass in the </p>
<p class="calibre1">following:</p>
<p class="calibre1"><b class="calibre3">window     </b>The window to draw into. </p>
<p class="calibre1"><b class="calibre3">loc     </b>The location in the window to draw the images. </p>
<p class="calibre1"><b class="calibre3">picPaths     </b>A list or tuple of paths to images. The images will be dis-</p>
<p class="calibre1">played in the order given here. </p>
<p class="calibre1"><b class="calibre3">durationPerImage     </b>How long (in seconds) to show each image. </p>
<p class="calibre1">In the __init__() method 1, we save these parameter variables into sim-</p>
<p class="calibre1">ilarly named instance variables. The method loops through the list of paths, </p>
<p class="calibre1">loads each image, and saves the resulting images into a list. A list is a perfect </p>
<p class="calibre1">way to represent an ordered set of images. The class will use the self.index </p>
<p class="calibre1">variable to keep track of the current image in the list. </p>
<p class="calibre1">The format of an image in a file is different from the format of an image </p>
<p class="calibre1">when displayed on the screen. The call to convert_alpha() 2 converts from the </p>
<p class="calibre1">file format to the screen format to optimize performance when showing an </p>
<p class="calibre1">image in the window. The actual drawing is done later, in the draw() method. </p>
<p class="calibre1">Animation   <b class="calibre3">297</b></p>
<p class="calibre1"><a id="p327"/>The play() method 3 starts an animation running. It first checks to see if the animation is already running, and if it is, the method just returns. </p>
</body></html>