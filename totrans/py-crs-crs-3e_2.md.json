["```py\n$ **python -m pip install --user pygame**\n```", "```py\nimport sys\n\nimport pygame\n\nclass AlienInvasion:\n    \"\"\"Overall class to manage game assets and behavior.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the game, and create game resources.\"\"\"\n❶         pygame.init()\n\n❷         self.screen = pygame.display.set_mode((1200, 800))\n        pygame.display.set_caption(\"Alien Invasion\")\n\n    def run_game(self):\n        \"\"\"Start the main loop for the game.\"\"\"\n❸         while True:\n            # Watch for keyboard and mouse events.\n❹             for event in pygame.event.get():\n❺                 if event.type == pygame.QUIT:\n                    sys.exit()\n\n            # Make the most recently drawn screen visible.\n❻             pygame.display.flip()\n\nif __name__ == '__main__':\n    # Make a game instance, and run the game.\n    ai = AlienInvasion()\n    ai.run_game()\n```", "```py\n def __init__(self):\n \"\"\"Initialize the game, and create game resources.\"\"\"\n pygame.init()\n self.clock = pygame.time.Clock()\n  *--snip--*\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n  *--snip--*\n pygame.display.flip()\n            self.clock.tick(60)\n```", "```py\n def __init__(self):\n  *--snip--*\n pygame.display.set_caption(\"Alien Invasion\")\n\n        # Set the background color.\n❶         self.bg_color = (230, 230, 230)\n\n def run_game(self):\n  *--snip--*\n for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n\n            # Redraw the screen during each pass through the loop.\n❷             self.screen.fill(self.bg_color)\n\n # Make the most recently drawn screen visible.\n pygame.display.flip()\n self.clock.tick(60)\n```", "```py\nclass Settings:\n    \"\"\"A class to store all settings for Alien Invasion.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the game's settings.\"\"\"\n        # Screen settings\n        self.screen_width = 1200\n        self.screen_height = 800\n        self.bg_color = (230, 230, 230)\n```", "```py\n*--snip--*\nimport pygame\n\nfrom settings import Settings\n\nclass AlienInvasion:\n \"\"\"Overall class to manage game assets and behavior.\"\"\"\n\n def __init__(self):\n \"\"\"Initialize the game, and create game resources.\"\"\"\n pygame.init()\n self.clock = pygame.time.Clock()\n❶  self.settings = Settings()\n\n❷         self.screen = pygame.display.set_mode(\n            (self.settings.screen_width, self.settings.screen_height))\n pygame.display.set_caption(\"Alien Invasion\")\n\n def run_game(self):\n  *--snip--*\n # Redraw the screen during each pass through the loop.\n❸             self.screen.fill(self.settings.bg_color)\n\n # Make the most recently drawn screen visible.\n pygame.display.flip()\n self.clock.tick(60)\n*--snip--*\n```", "```py\nimport pygame\n\nclass Ship:\n    \"\"\"A class to manage the ship.\"\"\"\n\n    def __init__(self, ai_game):\n        \"\"\"Initialize the ship and set its starting position.\"\"\"\n❶         self.screen = ai_game.screen\n❷         self.screen_rect = ai_game.screen.get_rect()\n\n        # Load the ship image and get its rect.\n❸         self.image = pygame.image.load('images/ship.bmp')\n        self.rect = self.image.get_rect()\n\n        # Start each new ship at the bottom center of the screen.\n❹         self.rect.midbottom = self.screen_rect.midbottom\n\n❺     def blitme(self):\n        \"\"\"Draw the ship at its current location.\"\"\"\n        self.screen.blit(self.image, self.rect)\n```", "```py\n*--snip--*\nfrom settings import Settings\nfrom ship import Ship\n\nclass AlienInvasion:\n \"\"\"Overall class to manage game assets and behavior.\"\"\"\n\n def __init__(self):\n  *--snip--*\n pygame.display.set_caption(\"Alien Invasion\")\n\n❶         self.ship = Ship(self)\n\n def run_game(self):\n  *--snip--*\n # Redraw the screen during each pass through the loop.\n self.screen.fill(self.settings.bg_color)\n❷             self.ship.blitme()\n\n # Make the most recently drawn screen visible.\n pygame.display.flip()\n self.clock.tick(60)\n*--snip--*\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n❶  self._check_events()\n\n # Redraw the screen during each pass through the loop.\n  *--snip--*\n\n❷  def _check_events(self):\n        \"\"\"Respond to keypresses and mouse events.\"\"\"\n        for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n self._check_events()\n  self._update_screen()\n self.clock.tick(60)\n\n def _check_events(self):\n  *--snip--*\n\n def _update_screen(self):\n        \"\"\"Update images on the screen, and flip to the new screen.\"\"\"\n        self.screen.fill(self.settings.bg_color)\n self.ship.blitme()\n\n pygame.display.flip()\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n❶             elif event.type == pygame.KEYDOWN:\n❷                 if event.key == pygame.K_RIGHT:\n                    # Move the ship to the right.\n❸                     self.ship.rect.x += 1\n```", "```py\nclass Ship:\n \"\"\"A class to manage the ship.\"\"\"\n\n def __init__(self, ai_game):\n  *--snip--*\n # Start each new ship at the bottom center of the screen.\n self.rect.midbottom = self.screen_rect.midbottom\n\n # Movement flag; start with a ship that's not moving.\n❶         self.moving_right = False\n\n❷     def update(self):\n        \"\"\"Update the ship's position based on the movement flag.\"\"\"\n        if self.moving_right:\n            self.rect.x += 1\n\n def blitme(self):\n  *--snip--*\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n  *--snip--*\n elif event.type == pygame.KEYDOWN:\n if event.key == pygame.K_RIGHT:\n❶                     self.ship.moving_right = True\n❷             elif event.type == pygame.KEYUP:\n                if event.key == pygame.K_RIGHT:\n                    self.ship.moving_right = False\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n self._check_events()\n  self.ship.update()\n self._update_screen()\n self.clock.tick(60)\n```", "```py\n def __init__(self, ai_game):\n  *--snip--*\n     # Movement flags; start with a ship that's not moving.\n self.moving_right = False\n     self.moving_left = False\n\n def update(self):\n     \"\"\"Update the ship's position based on movement flags.\"\"\"\n if self.moving_right:\n self.rect.x += 1\n     if self.moving_left:\n            self.rect.x -= 1\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n  *--snip--*\n elif event.type == pygame.KEYDOWN:\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = True\n                elif event.key == pygame.K_LEFT:\n                    self.ship.moving_left = True\n\n elif event.type == pygame.KEYUP:\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = False\n                elif event.key == pygame.K_LEFT:\n                    self.ship.moving_left = False\n```", "```py\nclass Settings:\n \"\"\"A class to store all settings for Alien Invasion.\"\"\"\n\n def __init__(self):\n  *--snip--*\n\n        # Ship settings\n        self.ship_speed = 1.5\n```", "```py\nclass Ship:\n \"\"\"A class to manage the ship.\"\"\"\n\n    def __init__(self, ai_game):\n \"\"\"Initialize the ship and set its starting position.\"\"\"\n self.screen = ai_game.screen\n❶         self.settings = ai_game.settings\n  *--snip--*\n\n # Start each new ship at the bottom center of the screen.\n  self.rect.midbottom = self.screen_rect.midbottom\n\n        # Store a float for the ship's exact horizontal position.\n❷         self.x = float(self.rect.x)\n\n # Movement flags; start with a ship that's not moving.\n self.moving_right = False\n self.moving_left = False\n\n def update(self):\n \"\"\"Update the ship's position based on movement flags.\"\"\"\n        # Update the ship's x value, not the rect.\n if self.moving_right:\n❸             self.x += self.settings.ship_speed\n if self.moving_left:\n            self.x -= self.settings.ship_speed\n\n        # Update rect object from self.x.\n❹         self.rect.x = self.x\n\n def blitme(self):\n  *--snip--*\n```", "```py\n def update(self):\n \"\"\"Update the ship's position based on movement flags.\"\"\"\n # Update the ship's x value, not the rect.\n❶      if self.moving_right and self.rect.right < self.screen_rect.right:\n self.x += self.settings.ship_speed\n❷      if self.moving_left and self.rect.left > 0:\n self.x -= self.settings.ship_speed\n\n # Update rect object from self.x.\n self.rect.x = self.x\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n elif event.type == pygame.KEYDOWN:\n  self._check_keydown_events(event)\n elif event.type == pygame.KEYUP:\n  self._check_keyup_events(event)\n\n    def _check_keydown_events(self, event):\n        \"\"\"Respond to keypresses.\"\"\"\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = True\n elif event.key == pygame.K_LEFT:\n self.ship.moving_left = True\n\n    def _check_keyup_events(self, event):\n        \"\"\"Respond to key releases.\"\"\"\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = False\n elif event.key == pygame.K_LEFT:\n self.ship.moving_left = False\n```", "```py\n def _check_keydown_events(self, event):\n  *--snip--*\n elif event.key == pygame.K_LEFT:\n self.ship.moving_left = True\n        elif event.key == pygame.K_q:\n            sys.exit()\n```", "```py\n def __init__(self):\n \"\"\"Initialize the game, and create game resources.\"\"\"\n pygame.init()\n self.settings = Settings()\n\n❶         self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)\n❷         self.settings.screen_width = self.screen.get_rect().width\n        self.settings.screen_height = self.screen.get_rect().height\n        pygame.display.set_caption(\"Alien Invasion\")\n```", "```py\n def __init__(self):\n  *--snip--*\n        # Bullet settings\n        self.bullet_speed = 2.0\n     self.bullet_width = 3\n     self.bullet_height = 15\n     self.bullet_color = (60, 60, 60)\n```", "```py\nimport pygame\nfrom pygame.sprite import Sprite\n\nclass Bullet(Sprite):\n    \"\"\"A class to manage bullets fired from the ship.\"\"\"\n\n    def __init__(self, ai_game):\n        \"\"\"Create a bullet object at the ship's current position.\"\"\"\n        super().__init__()\n        self.screen = ai_game.screen\n        self.settings = ai_game.settings\n        self.color = self.settings.bullet_color\n\n        # Create a bullet rect at (0, 0) and then set correct position.\n❶         self.rect = pygame.Rect(0, 0, self.settings.bullet_width,\n            self.settings.bullet_height)\n❷         self.rect.midtop = ai_game.ship.rect.midtop\n\n        # Store the bullet's position as a float.\n❸         self.y = float(self.rect.y)\n```", "```py`Next we create the bullet’s `rect` attribute ❶. The bullet isn’t based on an image, so we have to build a `rect` from scratch using the `pygame.Rect()` class. This class requires the *x*- and *y*-coordinates of the top-left corner of the `rect`, and the width and height of the `rect`. We initialize the `rect` at (0, 0), but we’ll move it to the correct location in the next line, because the bullet’s position depends on the ship’s position. We get the width and height of the bullet from the values stored in `self.settings`.    We set the bullet’s `midtop` attribute to match the ship’s `midtop` attribute ❷. This will make the bullet emerge from the top of the ship, making it look like the bullet is fired from the ship. We use a float for the bullet’s *y*-coordinate so we can make fine adjustments to the bullet’s speed ❸.    Here’s the second part of *bullet.py*, `update()` and `draw_bullet()`:    **bullet.py**    ```", "```py    The `update()` method manages the bullet’s position. When a bullet is fired, it moves up the screen, which corresponds to a decreasing *y*-coordinate value. To update the position, we subtract the amount stored in `settings.bullet_speed` from `self.y` ❶. We then use the value of `self.y` to set the value of `self.rect.y` ❷.    The `bullet_speed` setting allows us to increase the speed of the bullets as the game progresses or as needed to refine the game’s behavior. Once a bullet is fired, we never change the value of its *x*-coordinate, so it will travel vertically in a straight line even if the ship moves.    When we want to draw a bullet, we call `draw_bullet()`. The `draw.rect()` function fills the part of the screen defined by the bullet’s `rect` with the color stored in `self.color` ❸.    ### Storing Bullets in a Group    Now that we have a `Bullet` class and the necessary settings defined, we can write code to fire a bullet each time the player presses the spacebar. We’ll create a group in `AlienInvasion` to store all the active bullets so we can manage the bullets that have already been fired. This group will be an instance of the `pygame.sprite.Group` class, which behaves like a list with some extra functionality that’s helpful when building games. We’ll use this group to draw bullets to the screen on each pass through the main loop and to update each bullet’s position.    First, we’ll import the new `Bullet` class:    **alien_invasion.py**    ```", "```py    Next we’ll create the group that holds the bullets in `__init__()`:    **alien_invasion.py**    ```", "```py    Then we need to update the position of the bullets on each pass through the `while` loop:    **alien_invasion.py**    ```", "```py    When you call `update()` on a group, the group automatically calls `update()` for each sprite in the group. The line `self.bullets.update()` calls `bullet.update()` for each bullet we place in the group `bullets`.    ### Firing Bullets    In `AlienInvasion`, we need to modify `_check_keydown_events()` to fire a bullet when the player presses the spacebar. We don’t need to change `_check_keyup_events()` because nothing happens when the spacebar is released. We also need to modify `_update_screen()` to make sure each bullet is drawn to the screen before we call `flip()`.    There will be a bit of work to do when we fire a bullet, so let’s write a new method, `_fire_bullet()`, to handle this work:    **alien_invasion.py**    ```", "```py    We call `_fire_bullet()` when the spacebar is pressed ❶. In `_fire_bullet()`, we make an instance of `Bullet` and call it `new_bullet` ❷. We then add it to the group `bullets` using the `add()` method ❸. The `add()` method is similar to `append()`, but it’s written specifically for Pygame groups.    The `bullets.sprites()` method returns a list of all sprites in the group `bullets`. To draw all fired bullets to the screen, we loop through the sprites in `bullets` and call `draw_bullet()` on each one ❹. We place this loop before the line that draws the ship, so the bullets don’t start out on top of the ship.    When you run *alien_invasion.py* now, you should be able to move the ship right and left and fire as many bullets as you want. The bullets travel up the screen and disappear when they reach the top, as shown in [Figure 12-3](#figure12-3). You can alter the size, color, and speed of the bullets in *settings.py*.  ![](Images/f12003.png)    Figure 12-3: The ship after firing a series of bullets      ### Deleting Old Bullets    At the moment, the bullets disappear when they reach the top, but only because Pygame can’t draw them above the top of the screen. The bullets actually continue to exist; their *y*-coordinate values just grow increasingly negative. This is a problem because they continue to consume memory and processing power.    We need to get rid of these old bullets, or the game will slow down from doing so much unnecessary work. To do this, we need to detect when the `bottom` value of a bullet’s `rect` has a value of 0, which indicates the bullet has passed off the top of the screen:    **alien_invasion.py**    ```", "```py    When you use a `for` loop with a list (or a group in Pygame), Python expects that the list will stay the same length as long as the loop is running. That means you can’t remove items from a list or group within a `for` loop, so we have to loop over a copy of the group. We use the `copy()` method to set up the `for` loop ❶, which leaves us free to modify the original `bullets` group inside the loop. We check each bullet to see whether it has disappeared off the top of the screen ❷. If it has, we remove it from `bullets` ❸. We insert a `print()` call to show how many bullets currently exist in the game and verify they’re being deleted when they reach the top of the screen ❹.    If this code works correctly, we can watch the terminal output while firing bullets and see that the number of bullets decreases to zero after each series of bullets has cleared the top of the screen. After you run the game and verify that bullets are being deleted properly, remove the `print()` call. If you leave it in, the game will slow down significantly because it takes more time to write output to the terminal than it does to draw graphics to the game window.    ### Limiting the Number of Bullets    Many shooting games limit the number of bullets a player can have on the screen at one time; doing so encourages players to shoot accurately. We’ll do the same in *Alien Invasion*.    First, store the number of bullets allowed in *settings.py*:    **settings.py**    ```", "```py    This limits the player to three bullets at a time. We’ll use this setting in `AlienInvasion` to check how many bullets exist before creating a new bullet in `_fire_bullet()`:    **alien_invasion.py**    ```", "```py    When the player presses the spacebar, we check the length of `bullets`. If `len(self.bullets)` is less than three, we create a new bullet. But if three bullets are already active, nothing happens when the spacebar is pressed. When you run the game now, you should only be able to fire bullets in groups of three.    ### Creating the _update_bullets() Method    We want to keep the `AlienInvasion` class reasonably well organized, so now that we’ve written and checked the bullet management code, we can move it to a separate method. We’ll create a new method called `_update_bullets()` and add it just before `_update_screen()`:    **alien_invasion.py**    ```", "```py    The code for `_update_bullets()` is cut and pasted from `run_game()`; all we’ve done here is clarify the comments.    The `while` loop in `run_game()` looks simple again:    **alien_invasion.py**    ```", "```py    Now our main loop contains only minimal code, so we can quickly read the method names and understand what’s happening in the game. The main loop checks for player input, and then updates the position of the ship and any bullets that have been fired. We then use the updated positions to draw a new screen and tick the clock at the end of each pass through the loop.    Run *alien_invasion.py* one more time, and make sure you can still fire bullets without errors.    ## Summary    In this chapter, you learned to make a plan for a game and learned the basic structure of a game written in Pygame. You learned to set a background color and store settings in a separate class where you can adjust them more easily. You saw how to draw an image to the screen and give the player control over the movement of game elements. You created elements that move on their own, like bullets flying up a screen, and you deleted objects that are no longer needed. You also learned to refactor code in a project on a regular basis to facilitate ongoing development.    In Chapter 13, we’ll add aliens to *Alien Invasion*. By the end of the chapter, you’ll be able to shoot down aliens, hopefully before they reach your ship!```", "```py`# 13 Aliens!  ![](Images/chapterart.png)  In this chapter, we’ll add aliens to *Alien Invasion*. We’ll add one alien near the top of the screen and then generate a whole fleet of aliens. We’ll make the fleet advance sideways and down, and we’ll get rid of any aliens hit by a bullet. Finally, we’ll limit the number of ships a player has and end the game when the player runs out of ships.    As you work through this chapter, you’ll learn more about Pygame and about managing a large project. You’ll also learn to detect collisions between game objects, like bullets and aliens. Detecting collisions helps you define interactions between elements in your games. For example, you can confine a character inside the walls of a maze or pass a ball between two characters. We’ll continue to work from a plan that we revisit occasionally to maintain the focus of our code-writing sessions.    Before we start writing new code to add a fleet of aliens to the screen, let’s look at the project and update our plan.    ## Reviewing the Project    When you’re beginning a new phase of development on a large project, it’s always a good idea to revisit your plan and clarify what you want to accomplish with the code you’re about to write. In this chapter, we’ll do the following:    *   Add a single alien to the top-left corner of the screen, with appropriate spacing around it. *   Fill the upper portion of the screen with as many aliens as we can fit horizontally. We’ll then create additional rows of aliens until we have a full fleet. *   Make the fleet move sideways and down until the entire fleet is shot down, an alien hits the ship, or an alien reaches the ground. If the entire fleet is shot down, we’ll create a new fleet. If an alien hits the ship or the ground, we’ll destroy the ship and create a new fleet. *   Limit the number of ships the player can use, and end the game when the player has used up the allotted number of ships.    We’ll refine this plan as we implement features, but this is specific enough to start writing code.    You should also review your existing code when you begin working on a new series of features in a project. Because each new phase typically makes a project more complex, it’s best to clean up any cluttered or inefficient code. We’ve been refactoring as we go, so there isn’t any code that we need to refactor at this point.    ## Creating the First Alien    Placing one alien on the screen is like placing a ship on the screen. Each alien’s behavior is controlled by a class called `Alien`, which we’ll structure like the `Ship` class. We’ll continue using bitmap images for simplicity. You can find your own image for an alien or use the one shown in [Figure 13-1](#figure13-1), which is available in the book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e). This image has a gray background, which matches the screen’s background color. Make sure you save the image file you choose in the *images* folder.  ![](Images/f13001.png)    Figure 13-1: The alien we’ll use to build the fleet      ### Creating the Alien Class    Now we’ll write the `Alien` class and save it as *alien.py*:    **alien.py**    ```", "```py    Most of this class is like the `Ship` class, except for the alien’s placement on the screen. We initially place each alien near the top-left corner of the screen; we add a space to the left of it that’s equal to the alien’s width and a space above it equal to its height ❶, so it’s easy to see. We’re mainly concerned with the aliens’ horizontal speed, so we’ll track the horizontal position of each alien precisely ❷.    This `Alien` class doesn’t need a method for drawing it to the screen; instead, we’ll use a Pygame group method that automatically draws all the elements of a group to the screen.    ### Creating an Instance of the Alien    We want to create an instance of `Alien` so we can see the first alien on the screen. Because it’s part of our setup work, we’ll add the code for this instance at the end of the `__init__()` method in `AlienInvasion`. Eventually, we’ll create an entire fleet of aliens, which will be quite a bit of work, so we’ll make a new helper method called `_create_fleet()`.    The order of methods in a class doesn’t matter, as long as there’s some consistency to how they’re placed. I’ll place `_create_fleet()` just before the `_update_screen()` method, but anywhere in `AlienInvasion` will work. First, we’ll import the `Alien` class.    Here are the updated `import` statements for *alien_invasion.py*:    **alien_invasion.py**    ```", "```py    And here’s the updated `__init__()` method:    **alien_invasion.py**    ```", "```py    We create a group to hold the fleet of aliens, and we call `_create_fleet()`, which we’re about to write.    Here’s the new `_create_fleet()` method:    **alien_invasion.py**    ```", "```py    In this method, we’re creating one instance of `Alien` and then adding it to the group that will hold the fleet. The alien will be placed in the default upper-left area of the screen.    To make the alien appear, we need to call the group’s `draw()` method in `_update_screen()`:    **alien_invasion.py**    ```", "```py    When you call `draw()` on a group, Pygame draws each element in the group at the position defined by its `rect` attribute. The `draw()` method requires one argument: a surface on which to draw the elements from the group. [Figure 13-2](#figure13-2) shows the first alien on the screen.  ![](Images/f13002.png)    Figure 13-2: The first alien appears.      Now that the first alien appears correctly, we’ll write the code to draw an entire fleet.    ## Building the Alien Fleet    To draw a fleet, we need to figure out how to fill the upper portion of the screen with aliens, without overcrowding the game window. There are a number of ways to accomplish this goal. We’ll approach it by adding aliens across the top of the screen, until there’s no space left for a new alien. Then we’ll repeat this process, as long as we have enough vertical space to add a new row.    ### Creating a Row of Aliens    Now we’re ready to generate a full row of aliens. To make a full row, we’ll first make a single alien so we have access to the alien’s width. We’ll place an alien on the left side of the screen and then keep adding aliens until we run out of space:    **alien_invasion.py**    ```", "```py    We get the alien’s width from the first alien we created, and then define a variable called `current_x` ❶. This refers to the horizontal position of the next alien we intend to place on the screen. We initially set this to one alien width, to offset the first alien in the fleet from the left edge of the screen.    Next, we begin the `while` loop ❷; we’re going to keep adding aliens *while* there’s enough room to place one. To determine whether there’s room to place another alien, we’ll compare `current_x` to some maximum value. A first attempt at defining this loop might look like this:    ```", "```py    This seems like it might work, but it would place the final alien in the row at the far-right edge of the screen. So we add a little margin on the right side of the screen. As long as there’s at least two alien widths’ worth of space at the right edge of the screen, we enter the loop and add another alien to the fleet.    Whenever there’s enough horizontal space to continue the loop, we want to do two things: create an alien at the correct position, and define the horizontal position of the next alien in the row. We create an alien and assign it to `new_alien` ❸. Then we set the precise horizontal position to the current value of `current_x` ❹. We also position the alien’s `rect` at this same *x*-value, and add the new alien to the group `self.aliens`.    Finally, we increment the value of `current_x` ❺. We add two alien widths to the horizontal position, to move past the alien we just added and to leave some space between the aliens as well. Python will re-evaluate the condition at the start of the `while` loop and decide if there’s room for another alien. When there’s no room left, the loop will end, and we should have a full row of aliens.    When you run *Alien Invasion* now, you should see the first row of aliens appear, as in [Figure 13-3](#figure13-3).  ![](Images/f13003.png)    Figure 13-3: The first row of aliens      ### Refactoring _create_fleet()    If the code we’ve written so far was all we needed to create a fleet, we’d probably leave `_create_fleet()` as is. But we have more work to do, so let’s clean up the method a bit. We’ll add a new helper method, `_create_alien()`, and call it from `_create_fleet()`:    **alien_invasion.py**    ```", "```py    The method `_create_alien()` requires one parameter in addition to `self`: the *x*-value that specifies where the alien should be placed ❶. The code in the body of `_create_alien()` is the same code that was in `_create_fleet()`, except we use the parameter name `x_position` in place of `current_x`. This refactoring will make it easier to add new rows and create an entire fleet.    ### Adding Rows    To finish the fleet, we’ll keep adding more rows until we run out of room. We’ll use a nested loop—we’ll wrap another `while` loop around the current one. The inner loop will place aliens horizontally in a row by focusing on the aliens’ *x*-values. The outer loop will place aliens vertically by focusing on the *y*-values. We’ll stop adding rows when we get near the bottom of the screen, leaving enough space for the ship and some room to start firing at the aliens.    Here’s how to nest the two `while` loops in `_create_fleet()`:    ```", "```py    We’ll need to know the alien’s height in order to place rows, so we grab the alien’s width and height using the `size` attribute of an alien `rect` ❶. A `rect`’s `size` attribute is a tuple containing its width and height.    Next, we set the initial *x*- and *y*-values for the placement of the first alien in the fleet ❷. We place it one alien width in from the left and one alien height down from the top. Then we define the `while` loop that controls how many rows are placed onto the screen ❸. As long as the *y*-value for the next row is less than the screen height, minus three alien heights, we’ll keep adding rows. (If this doesn’t leave the right amount of space, we can adjust it later.)    We call `_create_alien()`, and pass it the *y*-value as well as its *x*-position ❹. We’ll modify `_create_alien()` in a moment.    Notice the indentation of the last two lines of code ❺. They’re inside the outer `while` loop, but outside the inner `while` loop. This block runs after the inner loop is finished; it runs once after each row is created. After each row has been added, we reset the value of `current_x` so the first alien in the next row will be placed at the same position as the first alien in the previous rows. Then we add two alien heights to the current value of `current_y`, so the next row will be placed further down the screen. Indentation is really important here; if you don’t see the correct fleet when you run *alien_invasion.py* at the end of this section, check the indentation of all the lines in these nested loops.    We need to modify `_create_alien()` to set the vertical position of the alien correctly:    ```", "```py    We modify the definition of the method to accept the *y*-value for the new alien, and we set the vertical position of the `rect` in the body of the method.    When you run the game now, you should see a full fleet of aliens, as shown in [Figure 13-4](#figure13-4).  ![](Images/f13004.png)    Figure 13-4: The full fleet appears.      In the next section, we’ll make the fleet move!    ## Making the Fleet Move    Now let’s make the fleet of aliens move to the right across the screen until it hits the edge, and then make it drop a set amount and move in the other direction. We’ll continue this movement until all aliens have been shot down, one collides with the ship, or one reaches the bottom of the screen. Let’s begin by making the fleet move to the right.    ### Moving the Aliens Right    To move the aliens, we’ll use an `update()` method in *alien.py*, which we’ll call for each alien in the group of aliens. First, add a setting to control the speed of each alien:    **settings.py**    ```", "```py    Then use this setting to implement `update()` in *alien.py*:    **alien.py**    ```", "```py    We create a `settings` parameter in `__init__()` so we can access the alien’s speed in `update()`. Each time we update an alien’s position, we move it to the right by the amount stored in `alien_speed`. We track the alien’s exact position with the `self.x` attribute, which can hold float values ❶. We then use the value of `self.x` to update the position of the alien’s `rect` ❷.    In the main `while` loop, we already have calls to update the ship and bullet positions. Now we’ll add a call to update the position of each alien as well:    **alien_invasion.py**    ```", "```py    We’re about to write some code to manage the movement of the fleet, so we create a new method called `_update_aliens()`. We update the aliens’ positions after the bullets have been updated, because we’ll soon be checking to see whether any bullets hit any aliens.    Where you place this method in the module is not critical. But to keep the code organized, I’ll place it just after `_update_bullets()` to match the order of method calls in the `while` loop. Here’s the first version of `_update_aliens()`:    **alien_invasion.py**    ```", "```py    We use the `update()` method on the `aliens` group, which calls each alien’s `update()` method. When you run *Alien Invasion* now, you should see the fleet move right and disappear off the side of the screen.    ### Creating Settings for Fleet Direction    Now we’ll create the settings that will make the fleet move down the screen and to the left when it hits the right edge of the screen. Here’s how to implement this behavior:    **settings.py**    ```", "```py    The setting `fleet_drop_speed` controls how quickly the fleet drops down the screen each time an alien reaches either edge. It’s helpful to separate this speed from the aliens’ horizontal speed so you can adjust the two speeds independently.    To implement the setting `fleet_direction`, we could use a text value such as `'left'` or `'right'`, but we’d end up with `if`-`elif` statements testing for the fleet direction. Instead, because we only have two directions to deal with, let’s use the values 1 and −1 and switch between them each time the fleet changes direction. (Using numbers also makes sense because moving right involves adding to each alien’s *x*-coordinate value, and moving left involves subtracting from each alien’s *x*-coordinate value.)    ### Checking Whether an Alien Has Hit the Edge    We need a method to check whether an alien is at either edge, and we need to modify `update()` to allow each alien to move in the appropriate direction. This code is part of the `Alien` class:    **alien.py**    ```", "```py    We can call the new method `check_edges()` on any alien to see whether it’s at the left or right edge. The alien is at the right edge if the `right` attribute of its `rect` is greater than or equal to the `right` attribute of the screen’s `rect`. It’s at the left edge if its `left` value is less than or equal to 0 ❶. Rather than put this conditional test in an `if` block, we put the test directly in the `return` statement. This method will return `True` if the alien is at the right or left edge, and `False` if it is not at either edge.    We modify the method `update()` to allow motion to the left or right by multiplying the alien’s speed by the value of `fleet_direction` ❷. If `fleet_direction` is 1, the value of `alien_speed` will be added to the alien’s current position, moving the alien to the right; if `fleet_direction` is −1, the value will be subtracted from the alien’s position, moving the alien to the left.    ### Dropping the Fleet and Changing Direction    When an alien reaches the edge, the entire fleet needs to drop down and change direction. Therefore, we need to add some code to `AlienInvasion` because that’s where we’ll check whether any aliens are at the left or right edge. We’ll make this happen by writing the methods `_check_fleet_edges()` and `_change_fleet_direction()`, and then modifying `_update_aliens()`. I’ll put these new methods after `_create_alien()`, but again, the placement of these methods in the class isn’t critical.    **alien_invasion.py**    ```", "```py    In `_check_fleet_edges()`, we loop through the fleet and call `check_edges()` on each alien ❶. If `check_edges()` returns `True`, we know an alien is at an edge and the whole fleet needs to change direction; so we call `_change_fleet_direction()` and break out of the loop ❷. In `_change_fleet_direction()`, we loop through all the aliens and drop each one using the setting `fleet_drop_speed` ❸; then we change the value of `fleet_direction` by multiplying its current value by −1\\. The line that changes the fleet’s direction isn’t part of the `for` loop. We want to change each alien’s vertical position, but we only want to change the direction of the fleet once.    Here are the changes to `_update_aliens()`:    **alien_invasion.py**    ```", "```py    We’ve modified the method by calling `_check_fleet_edges()` before updating each alien’s position.    When you run the game now, the fleet should move back and forth between the edges of the screen and drop down every time it hits an edge. Now we can start shooting down aliens and watch for any aliens that hit the ship or reach the bottom of the screen.    ## Shooting Aliens    We’ve built our ship and a fleet of aliens, but when the bullets reach the aliens, they simply pass through because we aren’t checking for collisions. In game programming, *collisions* happen when game elements overlap. To make the bullets shoot down aliens, we’ll use the function `sprite.groupcollide()` to look for collisions between members of two groups.    ### Detecting Bullet Collisions    We want to know right away when a bullet hits an alien so we can make an alien disappear as soon as it’s hit. To do this, we’ll look for collisions immediately after updating the position of all the bullets.    The `sprite.groupcollide()` function compares the `rect`s of each element in one group with the `rect`s of each element in another group. In this case, it compares each bullet’s `rect` with each alien’s `rect` and returns a dictionary containing the bullets and aliens that have collided. Each key in the dictionary will be a bullet, and the corresponding value will be the alien that was hit. (We’ll also use this dictionary when we implement a scoring system in Chapter 14.)    Add the following code to the end of `_update_bullets()` to check for collisions between bullets and aliens:    **alien_invasion.py**    ```", "```py    The new code we added compares the positions of all the bullets in `self.bullets` and all the aliens in `self.aliens`, and identifies any that overlap. Whenever the `rect`s of a bullet and alien overlap, `groupcollide()` adds a key-value pair to the dictionary it returns. The two `True` arguments tell Pygame to delete the bullets and aliens that have collided. (To make a high-powered bullet that can travel to the top of the screen, destroying every alien in its path, you could set the first Boolean argument to `False` and keep the second Boolean argument set to `True`. The aliens hit would disappear, but all bullets would stay active until they disappeared off the top of the screen.)    When you run *Alien Invasion* now, aliens you hit should disappear. [Figure 13-5](#figure13-5) shows a fleet that has been partially shot down.  ![](Images/f13005.png)    Figure 13-5: We can shoot aliens!      ### Making Larger Bullets for Testing    You can test many features of *Alien Invasion* simply by running the game, but some features are tedious to test in the normal version of the game. For example, it’s a lot of work to shoot down every alien on the screen multiple times to test whether your code responds to an empty fleet correctly.    To test particular features, you can change certain game settings to focus on a particular area. For example, you might shrink the screen so there are fewer aliens to shoot down or increase the bullet speed and give yourself lots of bullets at once.    My favorite change for testing *Alien Invasion* is to use really wide bullets that remain active even after they’ve hit an alien (see [Figure 13-6](#figure13-6)). Try setting `bullet_width` to 300, or even 3,000, to see how quickly you can shoot down the fleet!  ![](Images/f13006.png)    Figure 13-6: Extra-powerful bullets make some aspects of the game easier to test.      Changes like these will help you test the game more efficiently and possibly spark ideas for giving players bonus powers. Just remember to restore the settings to normal when you’re finished testing a feature.    ### Repopulating the Fleet    One key feature of *Alien Invasion* is that the aliens are relentless: every time the fleet is destroyed, a new fleet should appear.    To make a new fleet of aliens appear after a fleet has been destroyed, we first check whether the `aliens` group is empty. If it is, we make a call to `_create_fleet()`. We’ll perform this check at the end of `_update_bullets()`, because that’s where individual aliens are destroyed.    **alien_invasion.py**    ```", "```py    We check whether the `aliens` group is empty ❶. An empty group evaluates to `False`, so this is a simple way to check whether the group is empty. If it is, we get rid of any existing bullets by using the `empty()` method, which removes all the remaining sprites from a group ❷. We also call `_create_fleet()`, which fills the screen with aliens again.    Now a new fleet appears as soon as you destroy the current fleet.    ### Speeding Up the Bullets    If you’ve tried firing at the aliens in the game’s current state, you might find that the bullets aren’t traveling at the best speed for gameplay. They might be a little too slow or a little too fast. At this point, you can modify the settings to make the gameplay more interesting. Keep in mind that the game is going to get progressively faster, so don’t make the game too fast at the beginning.    We modify the speed of the bullets by adjusting the value of `bullet_speed` in *settings.py*. On my system, I’ll adjust the value of `bullet_speed` to 2.5, so the bullets travel a little faster:    **settings.py**    ```", "```py    The best value for this setting depends on your experience of the game, so find a value that works for you. You can adjust other settings as well.    ### Refactoring _update_bullets()    Let’s refactor `_update_bullets()` so it’s not doing so many different tasks. We’ll move the code for dealing with bullet-alien collisions to a separate method:    **alien_invasion.py**    ```", "```py    We’ve created a new method, `_check_bullet_alien_collisions()`, to look for collisions between bullets and aliens and to respond appropriately if the entire fleet has been destroyed. Doing so keeps `_update_bullets()` from growing too long and simplifies further development.    ## Ending the Game    What’s the fun and challenge in playing a game you can’t lose? If the player doesn’t shoot down the fleet quickly enough, we’ll have the aliens destroy the ship when they make contact. At the same time, we’ll limit the number of ships a player can use, and we’ll destroy the ship when an alien reaches the bottom of the screen. The game will end when the player has used up all their ships.    ### Detecting Alien-Ship Collisions    We’ll start by checking for collisions between aliens and the ship so we can respond appropriately when an alien hits it. We’ll check for alien-ship collisions immediately after updating the position of each alien in `AlienInvasion`:    **alien_invasion.py**    ```", "```py    The `spritecollideany()` function takes two arguments: a sprite and a group. The function looks for any member of the group that has collided with the sprite and stops looping through the group as soon as it finds one member that has collided with the sprite. Here, it loops through the group `aliens` and returns the first alien it finds that has collided with `ship`.    If no collisions occur, `spritecollideany()` returns `None` and the `if` block won’t execute ❶. If it finds an alien that has collided with the ship, it returns that alien and the `if` block executes: it prints `Ship hit!!!` ❷. When an alien hits the ship, we’ll need to do a number of tasks: delete all remaining aliens and bullets, recenter the ship, and create a new fleet. Before we write code to do all this, we want to know that our approach to detecting alien-ship collisions works correctly. Writing a `print()` call is a simple way to ensure we’re detecting these collisions properly.    Now when you run *Alien Invasion,* the message *Ship hit!!!* should appear in the terminal whenever an alien runs into the ship. When you’re testing this feature, set `fleet_drop_speed` to a higher value, such as 50 or 100, so the aliens reach your ship faster.    ### Responding to Alien-Ship Collisions    Now we need to figure out exactly what will happen when an alien collides with the ship. Instead of destroying the `ship` instance and creating a new one, we’ll count how many times the ship has been hit by tracking statistics for the game. Tracking statistics will also be useful for scoring.    Let’s write a new class, `GameStats`, to track game statistics, and let’s save it as *game_stats.py*:    **game_stats.py**    ```", "```py    We’ll make one `GameStats` instance for the entire time *Alien Invasion* is running, but we’ll need to reset some statistics each time the player starts a new game. To do this, we’ll initialize most of the statistics in the `reset_stats()` method, instead of directly in `__init__()`. We’ll call this method from `__init__()` so the statistics are set properly when the `GameStats` instance is first created ❶. But we’ll also be able to call `reset_stats()` anytime the player starts a new game. Right now we have only one statistic, `ships_left`, the value of which will change throughout the game.    The number of ships the player starts with should be stored in *settings.py* as `ship_limit`:    **settings.py**    ```", "```py    We also need to make a few changes in *alien_invasion.py* to create an instance of `GameStats`. First, we’ll update the `import` statements at the top of the file:    **alien_invasion.py**    ```", "```py    We import the `sleep()` function from the `time` module in the Python standard library, so we can pause the game for a moment when the ship is hit. We also import `GameStats`.    We’ll create an instance of `GameStats` in `__init__()`:    **alien_invasion.py**    ```", "```py    We make the instance after creating the game window but before defining other game elements, such as the ship.    When an alien hits the ship, we’ll subtract 1 from the number of ships left, destroy all existing aliens and bullets, create a new fleet, and reposition the ship in the middle of the screen. We’ll also pause the game for a moment so the player can notice the collision and regroup before a new fleet appears.    Let’s put most of this code in a new method called `_ship_hit()`. We’ll call this method from `_update_aliens()` when an alien hits the ship:    **alien_invasion.py**    ```", "```py    The new method `_ship_hit()` coordinates the response when an alien hits a ship. Inside `_ship_hit()`, the number of ships left is reduced by 1 ❶, after which we empty the groups `bullets` and `aliens` ❷.    Next, we create a new fleet and center the ship ❸. (We’ll add the method `center_ship()` to `Ship` in a moment.) Then we add a pause after the updates have been made to all the game elements but before any changes have been drawn to the screen, so the player can see that their ship has been hit ❹. The `sleep()` call pauses program execution for half a second, long enough for the player to see that the alien has hit the ship. When the `sleep()` function ends, code execution moves on to the `_update_screen()` method, which draws the new fleet to the screen.    In `_update_aliens()`, we replace the `print()` call with a call to `_ship_hit()` when an alien hits the ship:    **alien_invasion.py**    ```", "```py    Here’s the new method `center_ship()`, which belongs in *ship.py*:    **ship.py**    ```", "```py    We center the ship the same way we did in `__init__()`. After centering it, we reset the `self.x` attribute, which allows us to track the ship’s exact position.    Run the game, shoot a few aliens, and let an alien hit the ship. The game should pause, and a new fleet should appear with the ship centered at the bottom of the screen again.    ### Aliens That Reach the Bottom of the Screen    If an alien reaches the bottom of the screen, we’ll have the game respond the same way it does when an alien hits the ship. To check when this happens, add a new method in *alien_invasion.py*:    **alien_invasion.py**    ```", "```py    The method `_check_aliens_bottom()` checks whether any aliens have reached the bottom of the screen. An alien reaches the bottom when its `rect.bottom` value is greater than or equal to the screen’s height ❶. If an alien reaches the bottom, we call `_ship_hit()`. If one alien hits the bottom, there’s no need to check the rest, so we break out of the loop after calling `_ship_hit()`.    We’ll call this method from `_update_aliens()`:    **alien_invasion.py**    ```", "```py    We call `_check_aliens_bottom()` after updating the positions of all the aliens and after looking for alien-ship collisions. Now a new fleet will appear every time the ship is hit by an alien or an alien reaches the bottom of the screen.    ### Game Over!    *Alien Invasion* feels more complete now, but the game never ends. The value of `ships_left` just grows increasingly negative. Let’s add a `game_active` flag, so we can end the game when the player runs out of ships. We’ll set this flag at the end of the `__init__()` method in `AlienInvasion`:    **alien_invasion.py**    ```", "```py    Now we add code to `_ship_hit()` that sets `game_active` to `False` when the player has used up all their ships:    **alien_invasion.py**    ```", "```py    Most of `_ship_hit()` is unchanged. We’ve moved all the existing code into an `if` block, which tests to make sure the player has at least one ship remaining. If so, we create a new fleet, pause, and move on. If the player has no ships left, we set `game_active` to `False`.    ### Identifying When Parts of the Game Should Run    We need to identify the parts of the game that should always run and the parts that should run only when the game is active:    **alien_invasion.py**    ```", "```py    In the main loop, we always need to call `_check_events()`, even if the game is inactive. For example, we still need to know if the user presses Q to quit the game or clicks the button to close the window. We also continue updating the screen so we can make changes to the screen while waiting to see whether the player chooses to start a new game. The rest of the function calls need to happen only when the game is active, because when the game is inactive, we don’t need to update the positions of game elements.    Now when you play *Alien Invasion*, the game should freeze when you’ve used up all your ships.    ## Summary    In this chapter, you learned how to add a large number of identical elements to a game by creating a fleet of aliens. You used nested loops to create a grid of elements, and you made a large set of game elements move by calling each element’s `update()` method. You learned to control the direction of objects on the screen and to respond to specific situations, such as when the fleet reaches the edge of the screen. You detected and responded to collisions when bullets hit aliens and aliens hit the ship. You also learned how to track statistics in a game and use a `game_active` flag to determine when the game is over.    In the next and final chapter of this project, we’ll add a Play button so the player can choose when to start their first game and whether to play again when the game ends. We’ll speed up the game each time the player shoots down the entire fleet, and we’ll add a scoring system. The final result will be a fully playable game!    # 14 Scoring  ![](Images/chapterart.png)  In this chapter, we’ll finish building *Alien Invasion*. We’ll add a Play button to start the game on demand and to restart the game once it ends. We’ll also change the game so it speeds up when the player moves up a level, and we’ll implement a scoring system. By the end of the chapter, you’ll know enough to start writing games that increase in difficulty as a player progresses and that feature complete scoring systems.    ## Adding the Play Button    In this section, we’ll add a Play button that appears before a game begins and reappears when the game ends so the player can play again.    Right now, the game begins as soon as you run *alien_invasion.py*. Let’s start the game in an inactive state and then prompt the player to click a Play button to begin. To do this, modify the `__init__()` method of `AlienInvasion`:    **alien_invasion.py**    ```", "```py    Now the game should start in an inactive state, with no way for the player to start it until we make a Play button.    ### Creating a Button Class    Because Pygame doesn’t have a built-in method for making buttons, we’ll write a `Button` class to create a filled rectangle with a label. You can use this code to make any button in a game. Here’s the first part of the `Button` class; save it as *button.py*:    **button.py**    ```", "```py    First, we import the `pygame.font` module, which lets Pygame render text to the screen. The `__init__()` method takes the parameters `self`, the `ai_game` object, and `msg`, which contains the button’s text ❶. We set the button dimensions ❷, set `button_color` to color the button’s `rect` object dark green, and set `text_color` to render the text in white.    Next, we prepare a `font` attribute for rendering text ❸. The `None` argument tells Pygame to use the default font, and `48` specifies the size of the text. To center the button on the screen, we create a `rect` for the button ❹ and set its `center` attribute to match that of the screen.    Pygame works with text by rendering the string you want to display as an image. Finally, we call `_prep_msg()` to handle this rendering ❺.    Here’s the code for `_prep_msg()`:    **button.py**    ```", "```py    The `_prep_msg()` method needs a `self` parameter and the text to be rendered as an image (`msg`). The call to `font.render()` turns the text stored in `msg` into an image, which we then store in `self.msg_image` ❶. The `font.render()` method also takes a Boolean value to turn antialiasing on or off (*antialiasing* makes the edges of the text smoother). The remaining arguments are the specified font color and background color. We set antialiasing to `True` and set the text background to the same color as the button. (If you don’t include a background color, Pygame will try to render the font with a transparent background.)    We center the text image on the button by creating a `rect` from the image and setting its `center` attribute to match that of the button ❷.    Finally, we create a `draw_button()` method that we can call to display the button onscreen:    **button.py**    ```", "```py    We call `screen.fill()` to draw the rectangular portion of the button. Then we call `screen.blit()` to draw the text image to the screen, passing it an image and the `rect` object associated with the image. This completes the `Button` class.    ### Drawing the Button to the Screen    We’ll use the `Button` class to create a Play button in `AlienInvasion`. First, we’ll update the `import` statements:    **alien_invasion.py**    ```", "```py    Because we need only one Play button, we’ll create the button in the `__init__()` method of `AlienInvasion`. We can place this code at the very end of `__init__()`:    **alien_invasion.py**    ```", "```py    This code creates an instance of `Button` with the label `Play`, but it doesn’t draw the button to the screen. To do this, we’ll call the button’s `draw_button()` method in `_update_screen()`:    **alien_invasion.py**    ```", "```py    To make the Play button visible above all other elements on the screen, we draw it after all the other elements have been drawn but before flipping to a new screen. We include it in an `if` block, so the button only appears when the game is inactive.    Now when you run *Alien Invasion*, you should see a Play button in the center of the screen, as shown in [Figure 14-1](#figure14-1).  ![](Images/f14001.png)    Figure 14-1: A Play button appears when the game is inactive.      ### Starting the Game    To start a new game when the player clicks Play, add the following `elif` block to the end of `_check_events()` to monitor mouse events over the button:    **alien_invasion.py**    ```", "```py    Pygame detects a `MOUSEBUTTONDOWN` event when the player clicks anywhere on the screen ❶, but we want to restrict our game to respond to mouse clicks only on the Play button. To accomplish this, we use `pygame.mouse.get_pos()`, which returns a tuple containing the mouse cursor’s *x*- and *y*-coordinates when the mouse button is clicked ❷. We send these values to the new method `_check_play_button()` ❸.    Here’s `_check_play_button()`, which I chose to place after `_check_events()`:    **alien_invasion.py**    ```", "```py    We use the `rect` method `collidepoint()` to check whether the point of the mouse click overlaps the region defined by the Play button’s `rect` ❶. If so, we set `game_active` to `True`, and the game begins!    At this point, you should be able to start and play a full game. When the game ends, the value of `game_active` should become `False` and the Play button should reappear.    ### Resetting the Game    The Play button code we just wrote works the first time the player clicks Play. But it doesn’t work after the first game ends, because the conditions that caused the game to end haven’t been reset.    To reset the game each time the player clicks Play, we need to reset the game statistics, clear out the old aliens and bullets, build a new fleet, and center the ship, as shown here:    **alien_invasion.py**    ```", "```py    We reset the game statistics ❶, which gives the player three new ships. Then we set `game_active` to `True` so the game will begin as soon as the code in this function finishes running. We empty the `aliens` and `bullets` groups ❷, and then we create a new fleet and center the ship ❸.    Now the game will reset properly each time you click Play, allowing you to play it as many times as you want!    ### Deactivating the Play Button    One issue with our Play button is that the button region on the screen will continue to respond to clicks even when the Play button isn’t visible. If you click the Play button area by accident after a game begins, the game will restart!    To fix this, set the game to start only when `game_active` is `False`:    **alien_invasion.py**    ```", "```py    The flag `button_clicked` stores a `True` or `False` value ❶, and the game will restart only if Play is clicked *and* the game is not currently active ❷. To test this behavior, start a new game and repeatedly click where the Play button should be. If everything works as expected, clicking the Play button area should have no effect on the gameplay.    ### Hiding the Mouse Cursor    We want the mouse cursor to be visible when the game is inactive, but once play begins, it just gets in the way. To fix this, we’ll make it invisible when the game becomes active. We can do this at the end of the `if` block in `_check_play_button()`:    **alien_invasion.py**    ```", "```py    Passing `False` to `set_visible()` tells Pygame to hide the cursor when the mouse is over the game window.    We’ll make the cursor reappear once the game ends so the player can click Play again to begin a new game. Here’s the code to do that:    **alien_invasion.py**    ```", "```py    We make the cursor visible again as soon as the game becomes inactive, which happens in `_ship_hit()`. Attention to details like this makes your game more professional looking and allows the player to focus on playing, rather than figuring out the user interface.    ## Leveling Up    In our current game, once a player shoots down the entire alien fleet, the player reaches a new level, but the game difficulty doesn’t change. Let’s liven things up a bit and make the game more challenging by increasing the game’s speed each time a player clears the screen.    ### Modifying the Speed Settings    We’ll first reorganize the `Settings` class to group the game settings into static and dynamic ones. We’ll also make sure any settings that change during the game reset when we start a new game. Here’s the `__init__()` method for *settings.py*:    **settings.py**    ```", "```py    We continue to initialize settings that stay constant in the `__init__()` method. We add a `speedup_scale` setting ❶ to control how quickly the game speeds up: a value of 2 will double the game speed every time the player reaches a new level; a value of 1 will keep the speed constant. A value like `1.1` should increase the speed enough to make the game challenging but not impossible. Finally, we call the `initialize_dynamic_settings()` method to initialize the values for attributes that need to change throughout the game ❷.    Here’s the code for `initialize_dynamic_settings()`:    **settings.py**    ```", "```py    This method sets the initial values for the ship, bullet, and alien speeds. We’ll increase these speeds as the player progresses in the game and reset them each time the player starts a new game. We include `fleet_direction` in this method so the aliens always move right at the beginning of a new game. We don’t need to increase the value of `fleet_drop_speed`, because when the aliens move faster across the screen, they’ll also come down the screen faster.    To increase the speeds of the ship, bullets, and aliens each time the player reaches a new level, we’ll write a new method called `increase_speed()`:    **settings.py**    ```", "```py    To increase the speed of these game elements, we multiply each speed setting by the value of `speedup_scale`.    We increase the game’s tempo by calling `increase_speed()` in `_check_bullet_alien_collisions()` when the last alien in a fleet has been shot down:    **alien_invasion.py**    ```", "```py    Changing the values of the speed settings `ship_speed`, `alien_speed`, and `bullet_speed` is enough to speed up the entire game!    ### Resetting the Speed    Now we need to return any changed settings to their initial values each time the player starts a new game; otherwise, each new game would start with the increased speed settings of the previous game:    **alien_invasion.py**    ```", "```py    Playing *Alien Invasion* should be more fun and challenging now. Each time you clear the screen, the game should speed up and become slightly more difficult. If the game becomes too difficult too quickly, decrease the value of `settings.speedup_scale`. Or if the game isn’t challenging enough, increase the value slightly. Find a sweet spot by ramping up the difficulty in a reasonable amount of time. The first couple of screens should be easy, the next few should be challenging but doable, and subsequent screens should be almost impossibly difficult.    ## Scoring    Let’s implement a scoring system to track the game’s score in real time and display the high score, level, and number of ships remaining.    The score is a game statistic, so we’ll add a `score` attribute to `GameStats`:    **game_stats.py**    ```", "```py    To reset the score each time a new game starts, we initialize `score` in `reset_stats()` rather than `__init__()`.    ### Displaying the Score    To display the score on the screen, we first create a new class, `Scoreboard`. For now, this class will just display the current score. Eventually, we’ll use it to report the high score, level, and number of ships remaining as well. Here’s the first part of the class; save it as *scoreboard.py*:    **scoreboard.py**    ```", "```py    Because `Scoreboard` writes text to the screen, we begin by importing the `pygame.font` module. Next, we give `__init__()` the `ai_game` parameter so it can access the `settings`, `screen`, and `stats` objects, which it will need to report the values we’re tracking ❶. Then we set a text color ❷ and instantiate a font object ❸.    To turn the text to be displayed into an image, we call `prep_score()` ❹, which we define here:    **scoreboard.py**    ```", "```py    In `prep_score()`, we turn the numerical value `stats.score` into a string ❶ and then pass this string to `render()`, which creates the image ❷. To display the score clearly onscreen, we pass the screen’s background color and the text color to `render()`.    We’ll position the score in the upper-right corner of the screen and have it expand to the left as the score increases and the width of the number grows. To make sure the score always lines up with the right side of the screen, we create a `rect` called `score_rect` ❸ and set its right edge 20 pixels from the right edge of the screen ❹. We then place the top edge 20 pixels down from the top of the screen ❺.    Then we create a `show_score()` method to display the rendered score image:    **scoreboard.py**    ```", "```py    This method draws the score image onscreen at the location `score_rect` specifies.    ### Making a Scoreboard    To display the score, we’ll create a `Scoreboard` instance in `AlienInvasion`. First, let’s update the `import` statements:    **alien_invasion.py**    ```", "```py    Next, we make an instance of `Scoreboard` in `__init__()`:    **alien_invasion.py**    ```", "```py    Then we draw the scoreboard onscreen in `_update_screen()`:    **alien_invasion.py**    ```", "```py    We call `show_score()` just before we draw the Play button.    When you run *Alien Invasion* now, a 0 should appear at the top right of the screen. (At this point, we just want to make sure the score appears in the right place before developing the scoring system further.) [Figure 14-2](#figure14-2) shows the score as it appears before the game starts.    Next, we’ll assign point values to each alien!  ![](Images/f14002.png)    Figure 14-2: The score appears at the top-right corner of the screen.      ### Updating the Score as Aliens Are Shot Down    To write a live score onscreen, we update the value of `stats.score` whenever an alien is hit, and then call `prep_score()` to update the score image. But first, let’s determine how many points a player gets each time they shoot down an alien:    **settings.py**    ```", "```py    We’ll increase each alien’s point value as the game progresses. To make sure this point value is reset each time a new game starts, we set the value in `initialize_dynamic_settings()`.    Let’s update the score in `_check_bullet_alien_collisions()` each time an alien is shot down:    **alien_invasion.py**    ```", "```py    When a bullet hits an alien, Pygame returns a `collisions` dictionary. We check whether the dictionary exists, and if it does, the alien’s value is added to the score. We then call `prep_score()` to create a new image for the updated score.    Now when you play *Alien Invasion*, you should be able to rack up points!    ### Resetting the Score    Right now, we’re only prepping a new score *after* an alien has been hit, which works for most of the game. But when we start a new game, we’ll still see our score from the old game until the first alien is hit.    We can fix this by prepping the score when starting a new game:    **alien_invasion.py**    ```", "```py    We call `prep_score()` after resetting the game stats when starting a new game. This preps the scoreboard with a score of 0.    ### Making Sure to Score All Hits    As currently written, our code could miss scoring for some aliens. For example, if two bullets collide with aliens during the same pass through the loop or if we make an extra-wide bullet to hit multiple aliens, the player will only receive points for hitting one of the aliens. To fix this, let’s refine the way that bullet-alien collisions are detected.    In `_check_bullet_alien_collisions()`, any bullet that collides with an alien becomes a key in the `collisions` dictionary. The value associated with each bullet is a list of aliens it has collided with. We loop through the values in the `collisions` dictionary to make sure we award points for each alien hit:    **alien_invasion.py**    ```", "```py    If the `collisions` dictionary has been defined, we loop through all values in the dictionary. Remember that each value is a list of aliens hit by a single bullet. We multiply the value of each alien by the number of aliens in each list and add this amount to the current score. To test this, change the width of a bullet to 300 pixels and verify that you receive points for each alien you hit with your extra-wide bullets; then return the bullet width to its normal value.    ### Increasing Point Values    Because the game gets more difficult each time a player reaches a new level, aliens in later levels should be worth more points. To implement this functionality, we’ll add code to increase the point value when the game’s speed increases:    **settings.py**    ```", "```py    We define a rate at which points increase, which we call `score_scale` ❶. A small increase in speed (`1.1`) makes the game more challenging quickly. But to see a more notable difference in scoring, we need to change the alien point value by a larger amount (`1.5`). Now when we increase the game’s speed, we also increase the point value of each hit ❷. We use the `int()` function to increase the point value by whole integers.    To see the value of each alien, add a `print()` call to the `increase_speed()` method in `Settings`:    **settings.py**    ```", "```py    The new point value should appear in the terminal every time you reach a new level.    ### Rounding the Score    Most arcade-style shooting games report scores as multiples of 10, so let’s follow that lead with our scores. Also, let’s format the score to include comma separators in large numbers. We’ll make this change in `Scoreboard`:    **scoreboard.py**    ```", "```py    The `round()` function normally rounds a float to a set number of decimal places given as the second argument. However, when you pass a negative number as the second argument, `round()` will round the value to the nearest 10, 100, 1,000, and so on. This code tells Python to round the value of `stats.score` to the nearest 10 and assign it to `rounded_score`.    We then use a format specifier in the f-string for the score. A *format specifier* is a special sequence of characters that modifies the way a variable’s value is presented. In this case the sequence `:,` tells Python to insert commas at appropriate places in the numerical value that’s provided. This results in strings like `1,000,000` instead of `1000000`.    Now when you run the game, you should see a neatly formatted, rounded score even when you rack up lots of points, as shown in [Figure 14-3](#figure14-3).  ![](Images/f14003.png)    Figure 14-3: A rounded score with comma separators      ### High Scores    Every player wants to beat a game’s high score, so let’s track and report high scores to give players something to work toward. We’ll store high scores in `GameStats`:    **game_stats.py**    ```", "```py    Because the high score should never be reset, we initialize `high_score` in `__init__()` rather than in `reset_stats()`.    Next, we’ll modify `Scoreboard` to display the high score. Let’s start with the `__init__()` method:    **scoreboard.py**    ```", "```py    The high score will be displayed separately from the score, so we need a new method, `prep_high_score()`, to prepare the high-score image ❶.    Here’s the `prep_high_score()` method:    **scoreboard.py**    ```", "```py    We round the high score to the nearest 10 and format it with commas ❶. We then generate an image from the high score ❷, center the high score `rect` horizontally ❸, and set its `top` attribute to match the top of the score image ❹.    The `show_score()` method now draws the current score at the top right and the high score at the top center of the screen:    **scoreboard.py**    ```", "```py    To check for high scores, we’ll write a new method, `check_high_score()`, in `Scoreboard`:    **scoreboard.py**    ```", "```py    The method `check_high_score()` checks the current score against the high score. If the current score is greater, we update the value of `high_score` and call `prep_high_score()` to update the high score’s image.    We need to call `check_high_score()` each time an alien is hit after updating the score in `_check_bullet_alien_collisions()`:    **alien_invasion.py**    ```", "```py    We call `check_high_score()` when the `collisions` dictionary is present, and we do so after updating the score for all the aliens that have been hit.    The first time you play *Alien Invasion*, your score will be the high score, so it will be displayed as the current score and the high score. But when you start a second game, your high score should appear in the middle and your current score should appear at the right, as shown in [Figure 14-4](#figure14-4).  ![](Images/f14004.png)    Figure 14-4: The high score is shown at the top center of the screen.      ### Displaying the Level    To display the player’s level in the game, we first need an attribute in `GameStats` representing the current level. To reset the level at the start of each new game, initialize it in `reset_stats()`:    **game_stats.py**    ```", "```py    To have `Scoreboard` display the current level, we call a new method, `prep_level()`, from `__init__()`:    **scoreboard.py**    ```", "```py    Here’s `prep_level()`:    **scoreboard.py**    ```", "```py    The `prep_level()` method creates an image from the value stored in `stats.level` ❶ and sets the image’s `right` attribute to match the score’s `right` attribute ❷. It then sets the `top` attribute 10 pixels beneath the bottom of the score image to leave space between the score and the level ❸.    We also need to update `show_score()`:    **scoreboard.py**    ```", "```py    This new line draws the level image to the screen.    We’ll increment `stats.level` and update the level image in `_check_bullet_alien_collisions()`:    **alien_invasion.py**    ```", "```py    If a fleet is destroyed, we increment the value of `stats.level` and call `prep_level()` to make sure the new level displays correctly.    To ensure the level image updates properly at the start of a new game, we also call `prep_level()` when the player clicks the Play button:    **alien_invasion.py**    ```", "```py    We call `prep_level()` right after calling `prep_score()`.    Now you’ll see how many levels you’ve completed, as shown in [Figure 14-5](#figure14-5).  ![](Images/f14005.png)    Figure 14-5: The current level appears just below the current score.      ### Displaying the Number of Ships    Finally, let’s display the number of ships the player has left, but this time, let’s use a graphic. To do so, we’ll draw ships in the upper-left corner of the screen to represent how many ships are left, just as many classic arcade games do.    First, we need to make `Ship` inherit from `Sprite` so we can create a group of ships:    **ship.py**    ```", "```py    Here we import `Sprite`, make sure `Ship` inherits from `Sprite` ❶, and call `super()` at the beginning of `__init__()` ❷.    Next, we need to modify `Scoreboard` to create a group of ships we can display. Here are the `import` statements for `Scoreboard`:    **scoreboard.py**    ```", "```py    Because we’re making a group of ships, we import the `Group` and `Ship` classes.    Here’s `__init__()`:    **scoreboard.py**    ```", "```py    We assign the game instance to an attribute, because we’ll need it to create some ships. We call `prep_ships()` after the call to `prep_level()`.    Here’s `prep_ships()`:    **scoreboard.py**    ```", "```py    The `prep_ships()` method creates an empty group, `self.ships`, to hold the ship instances ❶. To fill this group, a loop runs once for every ship the player has left ❷. Inside the loop, we create a new ship and set each ship’s *x*-coordinate value so the ships appear next to each other with a 10-pixel margin on the left side of the group of ships ❸. We set the *y*-coordinate value 10 pixels down from the top of the screen so the ships appear in the upper-left corner of the screen ❹. Then we add each new ship to the group `ships` ❺.    Now we need to draw the ships to the screen:    **scoreboard.py**    ```", "```py    To display the ships on the screen, we call `draw()` on the group, and Pygame draws each ship.    To show the player how many ships they have to start with, we call `prep_ships()` when a new game starts. We do this in `_check_play_button()` in `AlienInvasion`:    **alien_invasion.py**    ```", "```py    We also call `prep_ships()` when a ship is hit, to update the display of ship images when the player loses a ship:    **alien_invasion.py**    ```", "```py    We call `prep_ships()` after decreasing the value of `ships_left`, so the correct number of remaining ships displays each time a ship is destroyed.    [Figure 14-6](#figure14-6) shows the complete scoring system, with the remaining ships displayed at the top left of the screen.  ![](Images/f14006.png)    Figure 14-6: The complete scoring system for *Alien Invasion*      ## Summary    In this chapter, you learned how to implement a Play button to start a new game. You also learned how to detect mouse events and hide the cursor in active games. You can use what you’ve learned to create other buttons, like a Help button to display instructions on how to play your games. You also learned how to modify the speed of a game as it progresses, implement a progressive scoring system, and display information in textual and nontextual ways.   # 15 Generating Data  ![](Images/chapterart.png)  *Data visualization* is the use of visual representations to explore and present patterns in datasets. It’s closely associated with *data analysis*, which uses code to explore the patterns and connections in a dataset. A dataset can be a small list of numbers that fits in a single line of code, or it can be terabytes of data that include many different kinds of information.    Creating effective data visualizations is about more than just making information look nice. When a representation of a dataset is simple and visually appealing, its meaning becomes clear to viewers. People will see patterns and significance in your datasets that they never knew existed.    Fortunately, you don’t need a supercomputer to visualize complex data. Python is so efficient that with just a laptop, you can quickly explore datasets containing millions of individual data points. These data points don’t have to be numbers; with the basics you learned in the first part of this book, you can analyze non-numerical data as well.    People use Python for data-intensive work in genetics, climate research, political and economic analysis, and much more. Data scientists have written an impressive array of visualization and analysis tools in Python, many of which are available to you as well. One of the most popular tools is Matplotlib, a mathematical plotting library. In this chapter, we’ll use Matplotlib to make simple plots, such as line graphs and scatter plots. Then we’ll create a more interesting dataset based on the concept of a random walk—a visualization generated from a series of random decisions.    We’ll also use a package called Plotly, which creates visualizations that work well on digital devices, to analyze the results of rolling dice. Plotly generates visualizations that automatically resize to fit a variety of display devices. These visualizations can also include a number of interactive features, such as emphasizing particular aspects of the dataset when users hover over different parts of the visualization. Learning to use Matplotlib and Plotly will help you get started visualizing the kinds of data you’re most interested in.    ## Installing Matplotlib    To use Matplotlib for your initial set of visualizations, you’ll need to install it using pip, just like we did with pytest in Chapter 11 (see “Installing pytest with pip” on page 210).    To install Matplotlib, enter the following command at a terminal prompt:    ```", "```py    If you use a command other than `python` to run programs or start a terminal session, such as `python3`, your command will look like this:    ```", "```py    To see the kinds of visualizations you can make with Matplotlib, visit the Matplotlib home page at [https://matplotlib.org](https://matplotlib.org) and click **Plot types**. When you click a visualization in the gallery, you’ll see the code used to generate the plot.    ## Plotting a Simple Line Graph    Let’s plot a simple line graph using Matplotlib and then customize it to create a more informative data visualization. We’ll use the square number sequence 1, 4, 9, 16, and 25 as the data for the graph.    To make a simple line graph, specify the numbers you want to work with and let Matplotlib do the rest:    **mpl_squares.py**    ```", "```py    We first import the `pyplot` module using the alias `plt` so we don’t have to type `pyplot` repeatedly. (You’ll see this convention often in online examples, so we’ll use it here.) The `pyplot` module contains a number of functions that help generate charts and plots.    We create a list called `squares` to hold the data that we’ll plot. Then we follow another common Matplotlib convention by calling the `subplots()` function ❶. This function can generate one or more plots in the same figure. The variable `fig` represents the entire *figure*, which is the collection of plots that are generated. The variable `ax` represents a single plot in the figure; this is the variable we’ll use most of the time when defining and customizing a single plot.    We then use the `plot()` method, which tries to plot the data it’s given in a meaningful way. The function `plt.show()` opens Matplotlib’s viewer and displays the plot, as shown in [Figure 15-1](#figure15-1). The viewer allows you to zoom and navigate the plot, and you can save any plot images you like by clicking the disk icon.  ![](Images/f15001.png)    Figure 15-1: One of the simplest plots you can make in Matplotlib      ### Changing the Label Type and Line Thickness    Although the plot in [Figure 15-1](#figure15-1) shows that the numbers are increasing, the label type is too small and the line is a little thin to read easily. Fortunately, Matplotlib allows you to adjust every feature of a visualization.    We’ll use a few of the available customizations to improve this plot’s readability. Let’s start by adding a title and labeling the axes:    **mpl_squares.py**    ```", "```py    The `linewidth` parameter controls the thickness of the line that `plot()` generates ❶. Once a plot has been generated, there are many methods available to modify the plot before it’s presented. The `set_title()` method sets an overall title for the chart ❷. The `fontsize` parameters, which appear repeatedly throughout the code, control the size of the text in various elements on the chart.    The `set_xlabel()` and `set_ylabel()` methods allow you to set a title for each of the axes ❸, and the method `tick_params()` styles the tick marks ❹. Here `tick_params()` sets the font size of the tick mark labels to 14 on both axes.    As you can see in [Figure 15-2](#figure15-2), the resulting chart is much easier to read. The label type is bigger, and the line graph is thicker. It’s often worth experimenting with these values to see what works best in the resulting graph.  ![](Images/f15002.png)    Figure 15-2: The chart is much easier to read now.      ### Correcting the Plot    Now that we can read the chart better, we can see that the data is not plotted correctly. Notice at the end of the graph that the square of 4.0 is shown as 25! Let’s fix that.    When you give `plot()` a single sequence of numbers, it assumes the first data point corresponds to an *x*-value of 0, but our first point corresponds to an *x*-value of 1\\. We can override the default behavior by giving `plot()` both the input and output values used to calculate the squares:    **mpl_squares.py**    ```", "```py    Now `plot()` doesn’t have to make any assumptions about how the output numbers were generated. The resulting plot, shown in [Figure 15-3](#figure15-3), is correct.  ![](Images/f15003.png)    Figure 15-3: The data is now plotted correctly.      You can specify a number of arguments when calling `plot()` and use a number of methods to customize your plots after generating them. We’ll continue to explore these approaches to customization as we work with more interesting datasets throughout this chapter.    ### Using Built-in Styles    Matplotlib has a number of predefined styles available. These styles contain a variety of default settings for background colors, gridlines, line widths, fonts, font sizes, and more. They can make your visualizations appealing without requiring much customization. To see the full list of available styles, run the following lines in a terminal session:    ```", "```py    To use any of these styles, add one line of code before calling `subplots()`:    **mpl_squares.py**    ```", "```py    This code generates the plot shown in [Figure 15-4](#figure15-4). A wide variety of styles is available; play around with these styles to find some that you like.  ![](Images/f15004.png)    Figure 15-4: The built-in seaborn style      ### Plotting and Styling Individual Points with scatter()    Sometimes, it’s useful to plot and style individual points based on certain characteristics. For example, you might plot small values in one color and larger values in a different color. You could also plot a large dataset with one set of styling options and then emphasize individual points by replotting them with different options.    To plot a single point, pass the single *x*- and *y*-values of the point to `scatter()`:    **scatter_squares.py**    ```", "```py    Let’s style the output to make it more interesting. We’ll add a title, label the axes, and make sure all the text is large enough to read:    ```", "```py    We call `scatter()` and use the `s` argument to set the size of the dots used to draw the graph ❶. When you run *scatter_squares.py* now, you should see a single point in the middle of the chart, as shown in [Figure 15-5](#figure15-5).  ![](Images/f15005.png)    Figure 15-5: Plotting a single point      ### Plotting a Series of Points with scatter()    To plot a series of points, we can pass `scatter()` separate lists of *x*- and *y*-values, like this:    **scatter_squares.py**    ```", "```py    The `x_values` list contains the numbers to be squared, and `y_values` contains the square of each number. When these lists are passed to `scatter()`, Matplotlib reads one value from each list as it plots each point. The points to be plotted are (1, 1), (2, 4), (3, 9), (4, 16), and (5, 25); [Figure 15-6](#figure15-6) shows the result.  ![](Images/f15006.png)    Figure 15-6: A scatter plot with multiple points      ### Calculating Data Automatically    Writing lists by hand can be inefficient, especially when we have many points. Rather than writing out each value, let’s use a loop to do the calculations for us.    Here’s how this would look with 1,000 points:    **scatter_squares.py**    ```", "```py    We start with a range of *x*-values containing the numbers 1 through 1,000 ❶. Next, a list comprehension generates the *y*-values by looping through the *x*-values (`for x in x_values`), squaring each number (`x**2`), and assigning the results to `y_values`. We then pass the input and output lists to `scatter()` ❷. Because this is a large dataset, we use a smaller point size.    Before showing the plot, we use the `axis()` method to specify the range of each axis ❸. The `axis()` method requires four values: the minimum and maximum values for the *x*-axis and the *y*-axis. Here, we run the *x*-axis from 0 to 1,100 and the *y*-axis from 0 to 1,100,000\\. [Figure 15-7](#figure15-7) shows the result.  ![](Images/f15007.png)    Figure 15-7: Python can plot 1,000 points as easily as it plots 5 points.      ### Customizing Tick Labels    When the numbers on an axis get large enough, Matplotlib defaults to scientific notation for tick labels. This is usually a good thing, because larger numbers in plain notation take up a lot of unnecessary space on a visualization.    Almost every element of a chart is customizable, so you can tell Matplotlib to keep using plain notation if you prefer:    ```", "```py    The `ticklabel_format()` method allows you to override the default tick label style for any plot.    ### Defining Custom Colors    To change the color of the points, pass the argument `color` to `scatter()` with the name of a color to use in quotation marks, as shown here:    ```", "```py    You can also define custom colors using the RGB color model. To define a color, pass the `color` argument a tuple with three float values (one each for red, green, and blue, in that order), using values between 0 and 1\\. For example, the following line creates a plot with light-green dots:    ```", "```py    Values closer to 0 produce darker colors, and values closer to 1 produce lighter colors.    ### Using a Colormap    A *colormap* is a sequence of colors in a gradient that moves from a starting to an ending color. In visualizations, colormaps are used to emphasize patterns in data. For example, you might make low values a light color and high values a darker color. Using a colormap ensures that all points in the visualization vary smoothly and accurately along a well-designed color scale.    The `pyplot` module includes a set of built-in colormaps. To use one of these colormaps, you need to specify how `pyplot` should assign a color to each point in the dataset. Here’s how to assign a color to each point, based on its *y*-value:    **scatter_squares.py**    ```", "```py    The `c` argument is similar to `color`, but it’s used to associate a sequence of values with a color mapping. We pass the list of *y*-values to `c`, and then tell `pyplot` which colormap to use with the `cmap` argument. This code colors the points with lower *y*-values light blue and the points with higher *y*-values dark blue. [Figure 15-8](#figure15-8) shows the resulting plot.  ![](Images/f15008.png)    Figure 15-8: A plot using the `Blues` colormap      ### Saving Your Plots Automatically    If you want to save the plot to a file instead of showing it in the Matplotlib viewer, you can use `plt.savefig()` instead of `plt.show()`:    ```", "```py    The first argument is a filename for the plot image, which will be saved in the same directory as *scatter_squares.py*. The second argument trims extra whitespace from the plot. If you want the extra whitespace around the plot, you can omit this argument. You can also call `savefig()` with a `Path` object, and write the output file anywhere you want on your system.    ## Random Walks    In this section, we’ll use Python to generate data for a random walk and then use Matplotlib to create a visually appealing representation of that data. A *random walk* is a path that’s determined by a series of simple decisions, each of which is left entirely to chance. You might imagine a random walk as the path a confused ant would take if it took every step in a random direction.    Random walks have practical applications in nature, physics, biology, chemistry, and economics. For example, a pollen grain floating on a drop of water moves across the surface of the water because it’s constantly pushed around by water molecules. Molecular motion in a water drop is random, so the path a pollen grain traces on the surface is a random walk. The code we’ll write next models many real-world situations.    ### Creating the RandomWalk Class    To create a random walk, we’ll create a `RandomWalk` class, which will make random decisions about which direction the walk should take. The class needs three attributes: one variable to track the number of points in the walk, and two lists to store the *x*- and *y*-coordinates of each point in the walk.    We’ll only need two methods for the `RandomWalk` class: the `__init__()` method and `fill_walk()`, which will calculate the points in the walk. Let’s start with the `__init__()` method:    **random_walk.py**    ```", "```py    To make random decisions, we’ll store possible moves in a list and use the `choice()` function (from the `random` module) to decide which move to make each time a step is taken ❶. We set the default number of points in a walk to `5000`, which is large enough to generate some interesting patterns but small enough to generate walks quickly ❷. Then we make two lists to hold the *x*- and *y*-values, and we start each walk at the point (0, 0) ❸.    ### Choosing Directions    We’ll use the `fill_walk()` method to determine the full sequence of points in the walk. Add this method to *random_walk.py*:    **random_walk.py**    ```", "```py    We first set up a loop that runs until the walk is filled with the correct number of points ❶. The main part of `fill_walk()` tells Python how to simulate four random decisions: Will the walk go right or left? How far will it go in that direction? Will it go up or down? How far will it go in that direction?    We use `choice([1, -1])` to choose a value for `x_direction`, which returns either 1 for movement to the right or −1 for movement to the left ❷. Next, `choice([0, 1, 2, 3, 4])` randomly selects a distance to move in that direction. We assign this value to `x_distance`. The inclusion of a 0 allows for the possibility of steps that have movement along only one axis.    We determine the length of each step in the *x-* and *y-*directions by multiplying the direction of movement by the distance chosen ❸ ❹. A positive result for `x_step` means move to the right, a negative result means move to the left, and 0 means move vertically. A positive result for `y_step` means move up, negative means move down, and 0 means move horizontally. If the values of both `x_step` and `y_step` are 0, the walk doesn’t go anywhere; when this happens, we continue the loop ❺.    To get the next *x*-value for the walk, we add the value in `x_step` to the last value stored in `x_values` ❻ and do the same for the *y*-values. When we have the new point’s coordinates, we append them to `x_values` and `y_values`.    ### Plotting the Random Walk    Here’s the code to plot all the points in the walk:    **rw_visual.py**    ```", "```py    We begin by importing `pyplot` and `RandomWalk`. We then create a random walk and assign it to `rw` ❶, making sure to call `fill_walk()`. To visualize the walk, we feed the walk’s *x*- and *y*-values to `scatter()` and choose an appropriate dot size ❷. By default, Matplotlib scales each axis independently. But that approach would stretch most walks out horizontally or vertically. Here we use the `set_aspect()` method to specify that both axes should have equal spacing between tick marks ❸.    [Figure 15-9](#figure15-9) shows the resulting plot with 5,000 points. The images in this section omit Matplotlib’s viewer, but you’ll continue to see it when you run *rw_visual.py*.  ![](Images/f15009.png)    Figure 15-9: A random walk with 5,000 points      ### Generating Multiple Random Walks    Every random walk is different, and it’s fun to explore the various patterns that can be generated. One way to use the preceding code to make multiple walks without having to run the program several times is to wrap it in a `while` loop, like this:    **rw_visual.py**    ```", "```py    This code generates a random walk, displays it in Matplotlib’s viewer, and pauses with the viewer open. When you close the viewer, you’ll be asked whether you want to generate another walk. If you generate a few walks, you should see some that stay near the starting point, some that wander off mostly in one direction, some that have thin sections connecting larger groups of points, and many other kinds of walks. When you want to end the program, press N.    ### Styling the Walk    In this section, we’ll customize our plots to emphasize the important characteristics of each walk and deemphasize distracting elements. To do so, we identify the characteristics we want to emphasize, such as where the walk began, where it ended, and the path taken. Next, we identify the characteristics to deemphasize, such as tick marks and labels. The result should be a simple visual representation that clearly communicates the path taken in each random walk.    #### Coloring the Points    We’ll use a colormap to show the order of the points in the walk, and remove the black outline from each dot so the color of the dots will be clearer. To color the points according to their position in the walk, we pass the `c` argument a list containing the position of each point. Because the points are plotted in order, this list just contains the numbers from 0 to 4,999:    **rw_visual.py**    ```", "```py    We use `range()` to generate a list of numbers equal to the number of points in the walk ❶. We assign this list to `point_numbers`, which we’ll use to set the color of each point in the walk. We pass `point_numbers` to the `c` argument, use the `Blues` colormap, and then pass `edgecolors='none'` to get rid of the black outline around each point. The result is a plot that varies from light to dark blue, showing exactly how the walk moves from its starting point to its ending point. This is shown in [Figure 15-10](#figure15-10).  ![](Images/f15010.png)    Figure 15-10: A random walk colored with the `Blues` colormap      #### Plotting the Starting and Ending Points    In addition to coloring points to show their position along the walk, it would be useful to see exactly where each walk begins and ends. To do so, we can plot the first and last points individually after the main series has been plotted. We’ll make the end points larger and color them differently to make them stand out:    **rw_visual.py**    ```", "```py    To show the starting point, we plot the point (0, 0) in green and in a larger size (`s=100`) than the rest of the points. To mark the end point, we plot the last *x*- and *y*-values in red with a size of 100 as well. Make sure you insert this code just before the call to `plt.show()` so the starting and ending points are drawn on top of all the other points.    When you run this code, you should be able to spot exactly where each walk begins and ends. If these end points don’t stand out clearly enough, adjust their color and size until they do.    #### Cleaning Up the Axes    Let’s remove the axes in this plot so they don’t distract from the path of each walk. Here’s how to hide the axes:    **rw_visual.py**    ```", "```py    To modify the axes, we use the `ax.get_xaxis()` and `ax.get_yaxis()` methods to get each axis, and then chain the `set_visible()` method to make each axis invisible. As you continue to work with visualizations, you’ll frequently see this chaining of methods to customize different aspects of a visualization.    Run *rw_visual.py* now; you should see a series of plots with no axes.    #### Adding Plot Points    Let’s increase the number of points, to give us more data to work with. To do so, we increase the value of `num_points` when we make a `RandomWalk` instance and adjust the size of each dot when drawing the plot:    **rw_visual.py**    ```", "```py    This example creates a random walk with 50,000 points and plots each point at size `s=1`. The resulting walk is wispy and cloudlike, as shown in [Figure 15-11](#figure15-11). We’ve created a piece of art from a simple scatter plot!    Experiment with this code to see how much you can increase the number of points in a walk before your system starts to slow down significantly or the plot loses its visual appeal.  ![](Images/f15011.png)    Figure 15-11: A walk with 50,000 points      #### Altering the Size to Fill the Screen    A visualization is much more effective at communicating patterns in data if it fits nicely on the screen. To make the plotting window better fit your screen, you can adjust the size of Matplotlib’s output. This is done in the `subplots()` call:    ```", "```py    When creating a plot, you can pass `subplots()` a `figsize` argument, which sets the size of the figure. The `figsize` parameter takes a tuple that tells Matplotlib the dimensions of the plotting window in inches.    Matplotlib assumes your screen resolution is 100 pixels per inch; if this code doesn’t give you an accurate plot size, adjust the numbers as necessary. Or, if you know your system’s resolution, you can pass `subplots()` the resolution using the `dpi` parameter:    ```", "```py    This should help make the most efficient use of the space available on your screen.    ## Rolling Dice with Plotly    In this section, we’ll use Plotly to produce interactive visualizations. Plotly is particularly useful when you’re creating visualizations that will be displayed in a browser, because the visualizations will scale automatically to fit the viewer’s screen. These visualizations are also interactive; when the user hovers over certain elements on the screen, information about those elements is highlighted. We’ll build our initial visualization in just a couple lines of code using *Plotly Express*, a subset of Plotly that focuses on generating plots with as little code as possible. Once we know our plot is correct, we’ll customize the output just as we did with Matplotlib.    In this project, we’ll analyze the results of rolling dice. When you roll one regular, six-sided die, you have an equal chance of rolling any of the numbers from 1 through 6\\. However, when you use two dice, you’re more likely to roll certain numbers than others. We’ll try to determine which numbers are most likely to occur by generating a dataset that represents rolling dice. Then we’ll plot the results of a large number of rolls to determine which results are more likely than others.    This work helps model games involving dice, but the core ideas also apply to games that involve chance of any kind, such as card games. It also relates to many real-world situations where randomness plays a significant factor.    ### Installing Plotly    Install Plotly using pip, just as you did for Matplotlib:    ```", "```py    Plotly Express depends on *pandas*, which is a library for working efficiently with data, so we need to install that as well. If you used `python3` or something else when installing Matplotlib, make sure you use the same command here.    To see what kind of visualizations are possible with Plotly, visit the gallery of chart types at [https://plotly.com/python](https://plotly.com/python). Each example includes source code, so you can see how Plotly generates the visualizations.    ### Creating the Die Class    We’ll create the following `Die` class to simulate the roll of one die:    **die.py**    ```", "```py    The `__init__()` method takes one optional argument ❶. With the `Die` class, when an instance of our die is created, the number of sides will be six if no argument is included. If an argument *is* included, that value will set the number of sides on the die. (Dice are named for their number of sides: a six-sided die is a D6, an eight-sided die is a D8, and so on.)    The `roll()` method uses the `randint()` function to return a random number between 1 and the number of sides ❷. This function can return the starting value (1), the ending value (`num_sides`), or any integer between the two.    ### Rolling the Die    Before creating a visualization based on the `Die` class, let’s roll a D6, print the results, and check that the results look reasonable:    **die_visual.py**    ```", "```py    We create an instance of `Die` with the default six sides ❶. Then we roll the die `100` times ❷ and store the result of each roll in the list `results`. Here’s a sample set of results:    ```", "```py    A quick scan of these results shows that the `Die` class seems to be working. We see the values 1 and 6, so we know the smallest and largest possible values are being returned, and because we don’t see 0 or 7, we know all the results are in the appropriate range. We also see each number from 1 through 6, which indicates that all possible outcomes are represented. Let’s determine exactly how many times each number appears.    ### Analyzing the Results    We’ll analyze the results of rolling one D6 by counting how many times we roll each number:    **die_visual.py**    ```", "```py    Because we’re no longer printing the results, we can increase the number of simulated rolls to `1000` ❶. To analyze the rolls, we create the empty list `frequencies` to store the number of times each value is rolled. We then generate all the possible results we could get; in this example, that’s all the numbers from `1` to however many sides `die` has ❷. We loop through the possible values, count how many times each number appears in `results` ❸, and then append this value to `frequencies` ❹. We print this list before making a visualization:    ```", "```py    These results look reasonable: we see six frequencies, one for each possible number when you roll a D6\\. We also see that no frequency is significantly higher than any other. Now let’s visualize these results.    ### Making a Histogram    Now that we have the data we want, we can generate a visualization in just a couple lines of code using Plotly Express:    **die_visual.py**    ```", "```py    We first import the `plotly.express` module, using the conventional alias `px`. We then use the `px.bar()` function to create a bar graph. In the simplest use of this function, we only need to pass a set of *x-*values and a set of *y-*values. Here the *x*-values are the possible results from rolling a single die, and the *y*-values are the frequencies for each possible result.    The final line calls `fig.show()`, which tells Plotly to render the resulting chart as an HTML file and open that file in a new browser tab. The result is shown in [Figure 15-12](#figure15-12).    This is a really simple chart, and it’s certainly not complete. But this is exactly how Plotly Express is meant to be used; you write a couple lines of code, look at the plot, and make sure it represents the data the way you want it to. If you like what you see, you can move on to customizing elements of the chart such as labels and styles. But if you want to explore other possible chart types, you can do so now, without having spent extra time on customization work. Feel free to try this now by changing `px.bar()` to something like `px.scatter()` or `px.line()`. You can find a full list of available chart types at [https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express).    This chart is dynamic and interactive. If you change the size of your browser window, the chart will resize to match the available space. If you hover over any of the bars, you’ll see a pop-up highlighting the specific data related to that bar.  ![](Images/f15012.png)    Figure 15-12: The initial plot produced by Plotly Express      ### Customizing the Plot    Now that we know we have the correct kind of plot and our data is being represented accurately, we can focus on adding the appropriate labels and styles for the chart.    The first way to customize a plot with Plotly is to use some optional parameters in the initial call that generates the plot, in this case, `px.bar()`. Here’s how to add an overall title and a label for each axis:    **die_visual.py**    ```", "```py    We first define the title that we want, here assigned to `title` ❶. To define axis labels, we write a dictionary ❷. The keys in the dictionary refer to the labels we want to customize, and the values are the custom labels we want to use. Here we give the *x*-axis the label `Result` and the *y*-axis the label `Frequency of Result`. The call to `px.bar()` now includes the optional arguments `title` and `labels`.    Now when the plot is generated it includes an appropriate title and a label for each axis, as shown in [Figure 15-13](#figure15-13).  ![](Images/f15013.png)    Figure 15-13: A simple bar chart created with Plotly      ### Rolling Two Dice    Rolling two dice results in larger numbers and a different distribution of results. Let’s modify our code to create two D6 dice to simulate the way we roll a pair of dice. Each time we roll the pair, we’ll add the two numbers (one from each die) and store the sum in `results`. Save a copy of *die_visual.py* as *dice_visual.py* and make the following changes:    **dice_visual.py**    ```", "```py    After creating two instances of `Die`, we roll the dice and calculate the sum of the two dice for each roll ❶. The smallest possible result (2) is the sum of the smallest number on each die. The largest possible result (12) is the sum of the largest number on each die, which we assign to `max_result` ❷. The variable `max_result` makes the code for generating `poss_results` much easier to read ❸. We could have written `range(2, 13)`, but this would work only for two D6 dice. When modeling real-world situations, it’s best to write code that can easily model a variety of situations. This code allows us to simulate rolling a pair of dice with any number of sides.    After running this code, you should see a chart that looks like [Figure 15-14](#figure15-14).  ![](Images/f15014.png)    Figure 15-14: Simulated results of rolling two six-sided dice 1,000 times      This graph shows the approximate distribution of results you’re likely to get when you roll a pair of D6 dice. As you can see, you’re least likely to roll a 2 or a 12 and most likely to roll a 7\\. This happens because there are six ways to roll a 7: 1 and 6, 2 and 5, 3 and 4, 4 and 3, 5 and 2, and 6 and 1.    ### Further Customizations    There’s one issue that we should address with the plot we just generated. Now that there are 11 bars, the default layout settings for the *x*-axis leave some of the bars unlabeled. While the default settings work well for most visualizations, this chart would look better with all of the bars labeled.    Plotly has an `update_layout()` method that can be used to make a wide variety of updates to a figure after it’s been created. Here’s how to tell Plotly to give each bar its own label:    **dice_visual.py**    ```", "```py    The `update_layout()` method acts on the `fig` object, which represents the overall chart. Here we use the `xaxis_dtick` argument, which specifies the distance between tick marks on the *x*-axis. We set that spacing to `1`, so that every bar is labeled. When you run *dice_visual.py* again, you should see a label on each bar.    ### Rolling Dice of Different Sizes    Let’s create a six-sided die and a ten-sided die, and see what happens when we roll them 50,000 times:    **dice_visual_d6d10.py**    ```", "```py    To make a D10, we pass the argument `10` when creating the second `Die` instance ❶ and change the first loop to simulate 50,000 rolls instead of 1,000\\. We change the title of the graph as well ❷.    [Figure 15-15](#figure15-15) shows the resulting chart. Instead of one most likely result, there are five such results. This happens because there’s still only one way to roll the smallest value (1 and 1) and the largest value (6 and 10), but the smaller die limits the number of ways you can generate the middle numbers. There are six ways to roll a 7, 8, 9, 10, or 11, these are the most common results, and you’re equally likely to roll any one of them.  ![](Images/f15015.png)    Figure 15-15: The results of rolling a six-sided die and a ten-sided die 50,000 times      Our ability to use Plotly to model the rolling of dice gives us considerable freedom in exploring this phenomenon. In just minutes, you can simulate a tremendous number of rolls using a large variety of dice.    ### Saving Figures    When you have a figure you like, you can always save the chart as an HTML file through your browser. But you can also do so programmatically. To save your chart as an HTML file, replace the call to `fig.show()` with a call to `fig.write_html()`:    ```", "```py    The `write_html()` method requires one argument: the name of the file to write to. If you only provide a filename, the file will be saved in the same directory as the *.py* file. You can also call `write_html()` with a `Path` object, and write the output file anywhere you want on your system.    ## Summary    In this chapter, you learned to generate datasets and create visualizations of that data. You created simple plots with Matplotlib and used a scatter plot to explore random walks. You also created a histogram with Plotly, and used it to explore the results of rolling dice of different sizes.    Generating your own datasets with code is an interesting and powerful way to model and explore a wide variety of real-world situations. As you continue to work through the data visualization projects that follow, keep an eye out for situations you might be able to model with code. Look at the visualizations you see in news media, and see if you can identify those that were generated using methods similar to the ones you’re learning in these projects.    In Chapter 16, you’ll download data from online sources and continue to use Matplotlib and Plotly to explore that data.   # 16 Downloading Data  ![](Images/chapterart.png)  In this chapter, you’ll download datasets from online sources and create working visualizations of that data. You can find an incredible variety of data online, much of which hasn’t been examined thoroughly. The ability to analyze this data allows you to discover patterns and connections that no one else has found.    We’ll access and visualize data stored in two common data formats: CSV and JSON. We’ll use Python’s `csv` module to process weather data stored in the CSV format and analyze high and low temperatures over time in two different locations. We’ll then use Matplotlib to generate a chart based on our downloaded data to display variations in temperature in two dissimilar environments: Sitka, Alaska, and Death Valley, California. Later in the chapter, we’ll use the `json` module to access earthquake data stored in the GeoJSON format and use Plotly to draw a world map showing the locations and magnitudes of recent earthquakes.    By the end of this chapter, you’ll be prepared to work with various types of datasets in different formats, and you’ll have a deeper understanding of how to build complex visualizations. Being able to access and visualize online data is essential to working with a wide variety of real-world datasets.    ## The CSV File Format    One simple way to store data in a text file is to write the data as a series of values separated by commas, called *comma-separated values*. The resulting files are *CSV* files. For example, here’s a chunk of weather data in CSV format:    ```", "```py    This is an excerpt of weather data from January 1, 2021, in Sitka, Alaska. It includes the day’s high and low temperatures, as well as a number of other measurements from that day. CSV files can be tedious for humans to read, but programs can process and extract information from them quickly and accurately.    We’ll begin with a small set of CSV-formatted weather data recorded in Sitka; it is available in this book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e). Make a folder called *weather_data* inside the folder where you’re saving this chapter’s programs. Copy the file *sitka_weather_07-2021_simple.csv* into this new folder. (After you download this book’s resources, you’ll have all the files you need for this project.)    ### Parsing the CSV File Headers    Python’s `csv` module in the standard library parses the lines in a CSV file and allows us to quickly extract the values we’re interested in. Let’s start by examining the first line of the file, which contains a series of headers for the data. These headers tell us what kind of information the data holds:    **sitka_highs.py**    ```", "```py    We first import `Path` and the `csv` module. We then build a `Path` object that looks in the *weather_data* folder, and points to the specific weather data file we want to work with ❶. We read the file and chain the `splitlines()` method to get a list of all lines in the file, which we assign to `lines`.    Next, we build a `reader` object ❷. This is an object that can be used to parse each line in the file. To make a reader object, call the function `csv.reader()` and pass it the list of lines from the CSV file.    When given a `reader` object, the `next()` function returns the next line in the file, starting from the beginning of the file. Here we call `next()` only once, so we get the first line of the file, which contains the file headers ❸. We assign the data that’s returned to `header_row`. As you can see, `header_row` contains meaningful, weather-related headers that tell us what information each line of data holds:    ```", "```py    The `reader` object processes the first line of comma-separated values in the file and stores each value as an item in a list. The header `STATION` represents the code for the weather station that recorded this data. The position of this header tells us that the first value in each line will be the weather station code. The `NAME` header indicates that the second value in each line is the name of the weather station that made the recording. The rest of the headers specify what kinds of information were recorded in each reading. The data we’re most interested in for now are the date (`DATE`), the high temperature (`TMAX`), and the low temperature (`TMIN`). This is a simple dataset that contains only temperature-related data. When you download your own weather data, you can choose to include a number of other measurements relating to wind speed, wind direction, and precipitation data.    ### Printing the Headers and Their Positions    To make it easier to understand the file header data, let’s print each header and its position in the list:    **sitka_highs.py**    ```", "```py    The `enumerate()` function returns both the index of each item and the value of each item as you loop through a list. (Note that we’ve removed the line `print(header_row)` in favor of this more detailed version.)    Here’s the output showing the index of each header:    ```", "```py    We can see that the dates and their high temperatures are stored in columns 2 and 4\\. To explore this data, we’ll process each row of data in *sitka_weather_07-2021_simple.csv* and extract the values with the indexes 2 and 4.    ### Extracting and Reading Data    Now that we know which columns of data we need, let’s read in some of that data. First, we’ll read in the high temperature for each day:    **sitka_highs.py**    ```", "```py    We make an empty list called `highs` ❶ and then loop through the remaining rows in the file ❷. The `reader` object continues from where it left off in the CSV file and automatically returns each line following its current position. Because we’ve already read the header row, the loop will begin at the second line where the actual data begins. On each pass through the loop we pull the data from index 4, corresponding to the header `TMAX`, and assign it to the variable `high` ❸. We use the `int()` function to convert the data, which is stored as a string, to a numerical format so we can use it. We then append this value to `highs`.    The following listing shows the data now stored in `highs`:    ```", "```py    We’ve extracted the high temperature for each date and stored each value in a list. Now let’s create a visualization of this data.    ### Plotting Data in a Temperature Chart    To visualize the temperature data we have, we’ll first create a simple plot of the daily highs using Matplotlib, as shown here:    **sitka_highs.py**    ```", "```py    We pass the list of highs to `plot()` and pass `color='red'` to plot the points in red ❶. (We’ll plot the highs in red and the lows in blue.) We then specify a few other formatting details, such as the title, font size, and labels ❷, just as we did in Chapter 15. Because we have yet to add the dates, we won’t label the *x*-axis, but `ax.set_xlabel()` does modify the font size to make the default labels more readable ❸. [Figure 16-1](#figure16-1) shows the resulting plot: a simple line graph of the high temperatures for July 2021 in Sitka, Alaska.  ![](Images/f16001.png)    Figure 16-1: A line graph showing daily high temperatures for July 2021 in Sitka, Alaska      ### The datetime Module    Let’s add dates to our graph to make it more useful. The first date from the weather data file is in the second row of the file:    ```", "```py    The data will be read in as a string, so we need a way to convert the string `\"2021-07-01\"` to an object representing this date. We can construct an object representing July 1, 2021, using the `strptime()` method from the `datetime` module. Let’s see how `strptime()` works in a terminal session:    ```", "```py    We first import the `datetime` class from the `datetime` module. Then we call the method `strptime()` with the string containing the date we want to process as its first argument. The second argument tells Python how the date is formatted. In this example, `'%Y-'` tells Python to look for a four-digit year before the first dash; `'%m-'` indicates a two-digit month before the second dash; and `'%d'` means the last part of the string is the day of the month, from 1 to 31.    The `strptime()` method can take a variety of arguments to determine how to interpret the date. [Table 16-1](#table16-1) shows some of these arguments.      Table 16-1: Date and Time Formatting Arguments from the `datetime` Module       | **Argument** | **Meaning** | | --- | --- | | `%A` | Weekday name, such as Monday | | `%B` | Month name, such as January | | `%m` | Month, as a number (01 to 12) | | `%d` | Day of the month, as a number (01 to 31) | | `%Y` | Four-digit year, such as 2019 | | `%y` | Two-digit year, such as 19 | | `%H` | Hour, in 24-hour format (00 to 23) | | `%I` | Hour, in 12-hour format (01 to 12) | | `%p` | AM or PM | | `%M` | Minutes (00 to 59) | | `%S` | Seconds (00 to 61) |    ### Plotting Dates    We can improve our plot by extracting dates for the daily high temperature readings, and using these dates on the *x*-axis:    **sitka_highs.py**    ```", "```py    We create two empty lists to store the dates and high temperatures from the file ❶. We then convert the data containing the date information (`row[2]`) to a `datetime` object ❷ and append it to `dates`. We pass the dates and the high temperature values to `plot()` ❸. The call to `fig.autofmt_xdate()` ❹ draws the date labels diagonally to prevent them from overlapping. [Figure 16-2](#figure16-2) shows the improved graph.  ![](Images/f16002.png)    Figure 16-2: The graph is more meaningful, now that it has dates on the *x*-axis.      ### Plotting a Longer Timeframe    With our graph set up, let’s include additional data to get a more complete picture of the weather in Sitka. Copy the file *sitka_weather_2021_simple.csv*, which contains a full year’s worth of weather data for Sitka, to the folder where you’re storing the data for this chapter’s programs.    Now we can generate a graph for the entire year’s weather:    **sitka_highs.py**    ```", "```py    We modify the filename to use the new data file *sitka_weather_2021_simple.csv*, and we update the title of our plot to reflect the change in its content. [Figure 16-3](#figure16-3) shows the resulting plot.  ![](Images/f16003.png)    Figure 16-3: A year’s worth of data      ### Plotting a Second Data Series    We can make our graph even more useful by including the low temperatures. We need to extract the low temperatures from the data file and then add them to our graph, as shown here:    **sitka_highs_lows.py**    ```", "```py    We add the empty list `lows` to hold low temperatures ❶, and then we extract and store the low temperature for each date from the sixth position in each row (`row[5]`) ❷. We add a call to `plot()` for the low temperatures and color these values blue ❸. Finally, we update the title ❹. [Figure 16-4](#figure16-4) shows the resulting chart.  ![](Images/f16004.png)    Figure 16-4: Two data series on the same plot      ### Shading an Area in the Chart    Having added two data series, we can now examine the range of temperatures for each day. Let’s add a finishing touch to the graph by using shading to show the range between each day’s high and low temperatures. To do so, we’ll use the `fill_between()` method, which takes a series of *x*-values and two series of *y*-values and fills the space between the two series of *y*-values:    **sitka_highs_lows.py**    ```", "```py    The `alpha` argument controls a color’s transparency ❶. An `alpha` value of 0 is completely transparent, and a value of 1 (the default) is completely opaque. By setting `alpha` to 0.5, we make the red and blue plot lines appear lighter.    We pass `fill_between()` the list `dates` for the *x*-values and then the two *y*-value series `highs` and `lows` ❷. The `facecolor` argument determines the color of the shaded region; we give it a low `alpha` value of 0.1 so the filled region connects the two data series without distracting from the information they represent. [Figure 16-5](#figure16-5) shows the plot with the shaded region between the highs and lows.  ![](Images/f16005.png)    Figure 16-5: The region between the two datasets is shaded.      The shading helps make the range between the two datasets immediately apparent.    ### Error Checking    We should be able to run the *sitka_highs_lows.py* code using data for any location. But some weather stations collect different data than others, and some occasionally malfunction and fail to collect some of the data they’re supposed to. Missing data can result in exceptions that crash our programs, unless we handle them properly.    For example, let’s see what happens when we attempt to generate a temperature plot for Death Valley, California. Copy the file *death_valley_2021_simple.csv* to the folder where you’re storing the data for this chapter’s programs.    First, let’s run the code to see the headers that are included in this data file:    **death_valley_highs_lows.py**    ```", "```py    Here’s the output:    ```", "```py    The date is in the same position, at index 2\\. But the high and low temperatures are at indexes 3 and 4, so we’ll need to change the indexes in our code to reflect these new positions. Instead of including an average temperature reading for the day, this station includes `TOBS`, a reading for a specific observation time.    Change *sitka_highs_lows.py* to generate a graph for Death Valley using the indexes we just noted, and see what happens:    **death_valley_highs_lows.py**    ```", "```py    We update the program to read from the Death Valley data file, and we change the indexes to correspond to this file’s `TMAX` and `TMIN` positions.    When we run the program, we get an error:    ```", "```py    The traceback tells us that Python can’t process the high temperature for one of the dates because it can’t turn an empty string (`''`) into an integer ❶. Rather than looking through the data to find out which reading is missing, we’ll just handle cases of missing data directly.    We’ll run error-checking code when the values are being read from the CSV file to handle exceptions that might arise. Here’s how to do this:    **death_valley_highs_lows.py**    ```", "```py    Each time we examine a row, we try to extract the date and the high and low temperature ❶. If any data is missing, Python will raise a `ValueError` and we handle it by printing an error message that includes the date of the missing data ❷. After printing the error, the loop will continue processing the next row. If all data for a date is retrieved without error, the `else` block will run and the data will be appended to the appropriate lists ❸. Because we’re plotting information for a new location, we update the title to include the location on the plot, and we use a smaller font size to accommodate the longer title ❹.    When you run *death_valley_highs_lows.py* now, you’ll see that only one date had missing data:    ```", "```py    Because the error is handled appropriately, our code is able to generate a plot, which skips over the missing data. [Figure 16-6](#figure16-6) shows the resulting plot.    Comparing this graph to the Sitka graph, we can see that Death Valley is warmer overall than southeast Alaska, as we expect. Also, the range of temperatures each day is greater in the desert. The height of the shaded region makes this clear.  ![](Images/f16006.png)    Figure 16-6: Daily high and low temperatures for Death Valley      Many datasets you work with will have missing, improperly formatted, or incorrect data. You can use the tools you learned in the first half of this book to handle these situations. Here we used a `try`-`except`-`else` block to handle missing data. Sometimes you’ll use `continue` to skip over some data, or use `remove()` or `del` to eliminate some data after it’s been extracted. Use any approach that works, as long as the result is a meaningful, accurate visualization.    ### Downloading Your Own Data    To download your own weather data, follow these steps:    1.  Visit the NOAA Climate Data Online site at [https://www.ncdc.noaa.gov/cdo-web](https://www.ncdc.noaa.gov/cdo-web). In the Discover Data By section, click **Search Tool**. In the Select a Dataset box, choose **Daily Summaries**. 2.  Select a date range, and in the Search For section, choose **ZIP Codes**. Enter the ZIP code you’re interested in and click **Search**. 3.  On the next page, you’ll see a map and some information about the area you’re focusing on. Below the location name, click **View Full Details**, or click the map and then click **Full Details**. 4.  Scroll down and click **Station List** to see the weather stations that are available in this area. Click one of the station names and then click **Add to Cart**. This data is free, even though the site uses a shopping cart icon. In the upper-right corner, click the cart. 5.  In Select the Output Format, choose **Custom GHCN-Daily CSV**. Make sure the date range is correct and click **Continue**. 6.  On the next page, you can select the kinds of data you want. You can download one kind of data (for example, focusing on air temperature) or you can download all the data available from this station. Make your choices and then click **Continue**. 7.  On the last page, you’ll see a summary of your order. Enter your email address and click **Submit Order**. You’ll receive a confirmation that your order was received, and in a few minutes, you should receive another email with a link to download your data.    The data you download should be structured just like the data we worked with in this section. It might have different headers than those you saw in this section, but if you follow the same steps we used here, you should be able to generate visualizations of the data you’re interested in.    ## Mapping Global Datasets: GeoJSON Format    In this section, you’ll download a dataset representing all the earthquakes that have occurred in the world during the previous month. Then you’ll make a map showing the location of these earthquakes and how significant each one was. Because the data is stored in the GeoJSON format, we’ll work with it using the `json` module. Using Plotly’s `scatter_geo()` plot, you’ll create visualizations that clearly show the global distribution of earthquakes.    ### Downloading Earthquake Data    Make a folder called *eq_data* inside the folder where you’re saving this chapter’s programs. Copy the file *eq_1_day_m1.geojson* into this new folder. Earthquakes are categorized by their magnitude on the Richter scale. This file includes data for all earthquakes with a magnitude M1 or greater that took place in the last 24 hours (at the time of this writing). This data comes from one of the United States Geological Survey’s earthquake data feeds, at [https://earthquake.usgs.gov/earthquakes/feed](https://earthquake.usgs.gov/earthquakes/feed).    ### Examining GeoJSON Data    When you open *eq_1_day_m1.geojson*, you’ll see that it’s very dense and hard to read:    ```", "```py    This file is formatted more for machines than humans. But we can see that the file contains some dictionaries, as well as information that we’re interested in, such as earthquake magnitudes and locations.    The `json` module provides a variety of tools for exploring and working with JSON data. Some of these tools will help us reformat the file so we can look at the raw data more easily before we work with it programmatically.    Let’s start by loading the data and displaying it in a format that’s easier to read. This is a long data file, so instead of printing it, we’ll rewrite the data to a new file. Then we can open that file and scroll back and forth through the data more easily:    **eq_explore_data.py**    ```", "```py    We read the data file as a string, and use `json.loads()` to convert the string representation of the file to a Python object ❶. This is the same approach we used in Chapter 10. In this case, the entire dataset is converted to a single dictionary, which we assign to `all_eq_data`. We then define a new `path` where we can write this same data in a more readable format ❷. The `json.dumps()` function that you saw in Chapter 10 can take an optional `indent` argument ❸, which tells it how much to indent nested elements in the data structure.    When you look in your *eq_data* directory and open the file *readable_eq_data.json*, here’s the first part of what you’ll see:    **readable_eq_data.json**    ```", "```py    The first part of the file includes a section with the key `\"metadata\"`❶. This tells us when the data file was generated and where we can find the data online. It also gives us a human-readable title and the number of earthquakes included in this file. In this 24-hour period, `160` earthquakes were recorded.    This GeoJSON file has a structure that’s helpful for location-based data. The information is stored in a list associated with the key `\"features\"` ❷. Because this file contains earthquake data, the data is in list form where every item in the list corresponds to a single earthquake. This structure might look confusing, but it’s quite powerful. It allows geologists to store as much information as they need to in a dictionary about each earthquake, and then stuff all those dictionaries into one big list.    Let’s look at a dictionary representing a single earthquake:    **readable_eq_data.json**    ```", "```py    The key `\"properties\"` contains a lot of information about each earthquake ❶. We’re mainly interested in the magnitude of each earthquake, associated with the key `\"mag\"`. We’re also interested in the `\"title\"` of each event, which provides a nice summary of its magnitude and location ❷.    The key `\"geometry\"` helps us understand where the earthquake occurred ❸. We’ll need this information to map each event. We can find the longitude ❹ and the latitude ❺ for each earthquake in a list associated with the key `\"coordinates\"`.    This file contains way more nesting than we’d use in the code we write, so if it looks confusing, don’t worry: Python will handle most of the complexity. We’ll only be working with one or two nesting levels at a time. We’ll start by pulling out a dictionary for each earthquake that was recorded in the 24-hour time period.    ### Making a List of All Earthquakes    First, we’ll make a list that contains all the information about every earthquake that occurred.    **eq_explore_data.py**    ```", "```py    We take the data associated with the key `'features'` in the `all_eq_data` dictionary, and assign it to `all_eq_dicts`. We know this file contains records of 160 earthquakes, and the output verifies that we’ve captured all the earthquakes in the file:    ```", "```py    Notice how short this code is. The neatly formatted file *readable_eq_data.json* has over 6,000 lines. But in just a few lines, we can read through all that data and store it in a Python list. Next, we’ll pull the magnitudes from each earthquake.    ### Extracting Magnitudes    We can loop through the list containing data about each earthquake, and extract any information we want. Let’s pull out the magnitude of each earthquake:    **eq_explore_data.py**    ```", "```py    We make an empty list to store the magnitudes, and then loop through the list `all_eq_dicts` ❶. Inside this loop, each earthquake is represented by the dictionary `eq_dict`. Each earthquake’s magnitude is stored in the `'properties'` section of this dictionary, under the key `'mag'` ❷. We store each magnitude in the variable `mag` and then append it to the list `mags`.    We print the first `10` magnitudes, so we can see whether we’re getting the correct data:    ```", "```py    Next, we’ll pull the location data for each earthquake, and then we can make a map of the earthquakes.    ### Extracting Location Data    The location data for each earthquake is stored under the key `\"geometry\"`. Inside the geometry dictionary is a `\"coordinates\"` key, and the first two values in this list are the longitude and latitude. Here’s how we’ll pull this data:    **eq_explore_data.py**    ```", "```py    We make empty lists for the longitudes and latitudes. The code `eq_dict['geometry']` accesses the dictionary representing the geometry element of the earthquake ❶. The second key, `'coordinates'`, pulls the list of values associated with `'coordinates'`. Finally, the `0` index asks for the first value in the list of coordinates, which corresponds to an earthquake’s longitude.    When we print the first `5` longitudes and latitudes, the output shows that we’re pulling the correct data:    ```", "```py    With this data, we can move on to mapping each earthquake.    ### Building a World Map    Using the information we’ve pulled so far, we can build a simple world map. Although it won’t look presentable yet, we want to make sure the information is displayed correctly before focusing on style and presentation issues. Here’s the initial map:    **eq_world_map.py**    ```", "```py    We import `plotly.express` with the alias `px`, just as we did in Chapter 15. The `scatter_geo()` function ❶ allows you to overlay a scatterplot of geographic data on a map. In the simplest use of this chart type, you only need to provide a list of latitudes and a list of longitudes. We pass the list `lats` to the `lat` argument, and `lons` to the `lon` argument.    When you run this file, you should see a map that looks like the one in [Figure 16-7](#figure16-7). This again shows the power of the Plotly Express library; in just three lines of code, we have a map of global earthquake activity.  ![](Images/f16007.png)    Figure 16-7: A simple map showing where all the earthquakes in the last 24 hours occurred      Now that we know the information in our dataset is being plotted correctly, we can make a few changes to make the map more meaningful and easier to read.    ### Representing Magnitudes    A map of earthquake activity should show the magnitude of each earthquake. We can also include more data, now that we know the data is being plotted correctly.    ```", "```py    We load the file *eq_data_30_day_m1.geojson*, to include a full 30 days’ worth of earthquake activity. We also use the size argument in the `px.scatter_geo()` call, which specifies how the points on the map will be sized. We pass the list `mags` to `size`, so earthquakes with a higher magnitude will show up as larger points on the map.    The resulting map is shown in [Figure 16-8](#figure16-8). Earthquakes usually occur near tectonic plate boundaries, and the longer period of earthquake activity included in this map reveals the exact locations of these boundaries.  ![](Images/f16008.png)    Figure 16-8: The map now shows the magnitude of all earthquakes in the last 30 days.      This map is better, but it’s still difficult to pick out which points represent the most significant earthquakes. We can improve this further by using color to represent magnitudes as well.    ### Customizing Marker Colors    We can use Plotly’s color scales to customize each marker’s color, according to the severity of the corresponding earthquake. We’ll also use a different projection for the base map.    **eq_world_map.py**    ```", "```py    All the significant changes here occur in the `px.scatter_geo()` function call. The `color` argument tells Plotly what values it should use to determine where each marker falls on the color scale ❶. We use the `mags` list to determine the color for each point, just as we did with the `size` argument.    The `color_continuous_scale` argument tells Plotly which color scale to use ❷. *Viridis* is a color scale that ranges from dark blue to bright yellow, and it works well for this dataset. By default, the color scale on the right of the map is labeled *color*; this is not representative of what the colors actually mean. The `labels` argument, shown in Chapter 15, takes a dictionary as a value ❸. We only need to set one custom label on this chart, making sure the color scale is labeled *Magnitude* instead of *color*.    We add one more argument, to modify the base map over which the earthquakes are plotted. The `projection` argument accepts a number of common map projections ❹. Here we use the `'natural earth'` projection, which rounds the ends of the map. Also, note the trailing comma after this last argument. When a function call has a long list of arguments spanning multiple lines like this, it’s common practice to add a trailing comma so you’re always ready to add another argument on the next line.    When you run the program now, you’ll see a much nicer-looking map. In [Figure 16-9](#figure16-9), the color scale shows the severity of individual earthquakes; the most severe earthquakes stand out as light-yellow points, in contrast to many darker points. You can also tell which regions of the world have more significant earthquake activity.  ![](Images/f16009.png)    Figure 16-9: In 30 days’ worth of earthquakes, color and size are used to represent the magnitude of each earthquake.      ### Other Color Scales    You can choose from a number of other color scales. To see the available color scales, enter the following two lines in a Python terminal session:    ```", "```py    Feel free to try out these color scales in the earthquake map, or with any dataset where continuously varying colors can help show patterns in the data.    ### Adding Hover Text    To finish this map, we’ll add some informative text that appears when you hover over the marker representing an earthquake. In addition to showing the longitude and latitude, which appear by default, we’ll show the magnitude and provide a description of the approximate location as well.    To make this change, we need to pull a little more data from the file:    **eq_world_map.py**    ```", "```py    We first make a list called `eq_titles` to store the title of each earthquake ❶. The `'title'` section of the data contains a descriptive name of the magnitude and location of each earthquake, in addition to its longitude and latitude. We pull this information and assign it to the variable `eq_title` ❷, and then append it to the list `eq_titles`.    In the `px.scatter_geo()` call, we pass `eq_titles` to the `hover_name` argument ❸. Plotly will now add the information from the title of each earthquake to the hover text on each point. When you run this program, you should be able to hover over any marker, see a description of where that earthquake took place, and read its exact magnitude. An example of this information is shown in [Figure 16-10](#figure16-10).  ![](Images/f16010.png)    Figure 16-10: The hover text now includes a summary of each earthquake.      This is impressive! In less than 30 lines of code, we’ve created a visually appealing and meaningful map of global earthquake activity that also illustrates the geological structure of the planet. Plotly offers a wide range of ways you can customize the appearance and behavior of your visualizations. Using Plotly’s many options, you can make charts and maps that show exactly what you want them to.    ## Summary    In this chapter, you learned how to work with real-world datasets. You processed CSV and GeoJSON files, and extracted the data you want to focus on. Using historical weather data, you learned more about working with Matplotlib, including how to use the `datetime` module and how to plot multiple data series on one chart. You plotted geographical data on a world map in Plotly, and learned to customize the style of the map.    As you gain experience working with CSV and JSON files, you’ll be able to process almost any data you want to analyze. You can download most online datasets in either or both of these formats. By working with these formats, you’ll be able to learn how to work with other data formats more easily as well.    In the next chapter, you’ll write programs that automatically gather their own data from online sources, and then you’ll create visualizations of that data. These are fun skills to have if you want to program as a hobby and are critical skills if you’re interested in programming professionally.   # 17 Working with APIs  ![](Images/chapterart.png)  In this chapter, you’ll learn how to write a self-contained program that generates a visualization based on data it retrieves. Your program will use an *application programming interface (**API)* to automatically request specific information from a website and then use that information to generate a visualization. Because programs written like this will always use current data to generate a visualization, even when that data might be rapidly changing, the visualization will always be up to date.    ## Using an API    An API is a part of a website designed to interact with programs. Those programs use very specific URLs to request certain information. This kind of request is called an *API call*. The requested data will be returned in an easily processed format, such as JSON or CSV. Most apps that use external data sources, such as apps that integrate with social media sites, rely on API calls.    ### Git and GitHub    We’ll base our visualization on information from GitHub ([https://github.com](https://github.com)), a site that allows programmers to collaborate on coding projects. We’ll use GitHub’s API to request information about Python projects on the site, and then generate an interactive visualization of the relative popularity of these projects using Plotly.    GitHub takes its name from Git, a distributed version control system. Git helps people manage their work on a project in a way that prevents changes made by one person from interfering with changes other people are making. When you implement a new feature in a project, Git tracks the changes you make to each file. When your new code works, you *commit* the changes you’ve made, and Git records the new state of your project. If you make a mistake and want to revert your changes, you can easily return to any previously working state. (To learn more about version control using Git, see Appendix D.) Projects on GitHub are stored in *repositories*, which contain everything associated with the project: its code, information on its collaborators, any issues or bug reports, and so on.    When users on GitHub like a project, they can “star” it to show their support and keep track of projects they might want to use. In this chapter, we’ll write a program to automatically download information about the most-starred Python projects on GitHub, and then we’ll create an informative visualization of these projects.    ### Requesting Data Using an API Call    GitHub’s API lets you request a wide range of information through API calls. To see what an API call looks like, enter the following into your browser’s address bar and press ENTER:    ```", "```py    This call returns the number of Python projects currently hosted on GitHub, as well as information about the most popular Python repositories. Let’s examine the call. The first part, `https://api.github.com/`, directs the request to the part of GitHub that responds to API calls. The next part, `search/repositories`, tells the API to conduct a search through all the repositories on GitHub.    The question mark after `repositories` signals that we’re about to pass an argument. The `q` stands for *query*, and the equal sign (`=`) lets us begin specifying a query (`q=`). By using `language:python`, we indicate that we want information only on repositories that have Python as the primary language. The final part, `+sort:stars`, sorts the projects by the number of stars they’ve been given.    The following snippet shows the first few lines of the response:    ```", "```py    You can see from the response that this URL is not primarily intended to be entered by humans, because it’s in a format that’s meant to be processed by a program. GitHub found just under nine million Python projects as of this writing ❶. The value for `\"incomplete_results\"` is `true`, which tells us that GitHub didn’t fully process the query ❷. GitHub limits how long each query can run, in order to keep the API responsive for all users. In this case it found some of the most popular Python repositories, but it didn’t have time to find all of them; we’ll fix that in a moment. The `\"items\"` returned are displayed in the list that follows, which contains details about the most popular Python projects on GitHub ❸.    ### Installing Requests    The *Requests* package allows a Python program to easily request information from a website and examine the response. Use pip to install Requests:    ```", "```py    If you use a command other than `python` to run programs or start a terminal session, such as `python3`, your command will look like this:    ```", "```py    ### Processing an API Response    Now we’ll write a program to automatically issue an API call and process the results:    **python_repos.py**    ```", "```py    We first import the `requests` module. Then we assign the URL of the API call to the `url` variable ❶. This is a long URL, so we break it into two lines. The first line is the main part of the URL, and the second line is the query string. We’ve included one more condition to the original query string: `stars:>10000`, which tells GitHub to only look for Python repositories that have more than 10,000 stars. This should allow GitHub to return a complete, consistent set of results.    GitHub is currently on the third version of its API, so we define headers for the API call that ask explicitly to use this version of the API, and return the results in the JSON format ❷. Then we use `requests` to make the call to the API ❸. We call `get()` and pass it the URL and the header that we defined, and we assign the response object to the variable `r`.    The response object has an attribute called `status_code`, which tells us whether the request was successful. (A status code of 200 indicates a successful response.) We print the value of `status_code` so we can make sure the call went through successfully ❹. We asked the API to return the information in JSON format, so we use the `json()` method to convert the information to a Python dictionary ❺. We assign the resulting dictionary to `response_dict`.    Finally, we print the keys from `response_dict` and see the following output:    ```", "```py    Because the status code is `200`, we know that the request was successful. The response dictionary contains only three keys: `'total_count'`, `'incomplete_results'`, and `'items'`. Let’s take a look inside the response dictionary.    ### Working with the Response Dictionary    With the information from the API call represented as a dictionary, we can work with the data stored there. Let’s generate some output that summarizes the information. This is a good way to make sure we received the information we expected, and to start examining the information we’re interested in:    **python_repos.py**    ```", "```py    We start exploring the response dictionary by printing the value associated with `'total_count'`, which represents the total number of Python repositories returned by this API call ❶. We also use the value associated with `'incomplete_results'`, so we'll know if GitHub was able to fully process the query. Rather than printing this value directly, we print its opposite: a value of `True` will indicate that we received a complete set of results.    The value associated with `'items'` is a list containing a number of dictionaries, each of which contains data about an individual Python repository. We assign this list of dictionaries to `repo_dicts` ❷. We then print the length of `repo_dicts` to see how many repositories we have information for.    To look closer at the information returned about each repository, we pull out the first item from `repo_dicts` and assign it to `repo_dict` ❸. We then print the number of keys in the dictionary to see how much information we have ❹. Finally, we print all the dictionary’s keys to see what kind of information is included ❺.    The results give us a clearer picture of the actual data:    ```", "```py    At the time of this writing, there are only `248` Python repositories with over 10,000 stars ❶. We can see that GitHub was able to fully process the API call ❷. In this response, GitHub returned information about the first `30` repositories that match the conditions of our query. If we want more repositories, we can request additional pages of data.    GitHub’s API returns a lot of information about each repository: there are `78` keys in `repo_dict` ❸. When you look through these keys, you’ll get a sense of the kind of information you can extract about a project. (The only way to know what information is available through an API is to read the documentation or to examine the information through code, as we’re doing here.)    Let’s pull out the values for some of the keys in `repo_dict`:    **python_repos.py**    ```", "```py    Here, we print the values for a number of keys from the first repository’s dictionary. We start with the name of the project ❶. An entire dictionary represents the project’s owner, so we use the key `owner` to access the dictionary representing the owner, and then use the key `login` to get the owner’s login name ❷. Next, we print how many stars the project has earned ❸ and the URL for the project’s GitHub repository. We then show when it was created ❹ and when it was last updated ❺. Finally, we print the repository’s description.    The output should look something like this:    ```", "```py    We can see that the most-starred Python project on GitHub as of this writing is *public-apis*. Its owner is an organization with the same name, and it has been starred by almost 200,000 GitHub users. We can see the URL for the project’s repository, its creation date of March 2016, and that it was updated recently. Additionally, the description tells us that *public-apis* contains a list of free APIs that programmers might be interested in.    ### Summarizing the Top Repositories    When we make a visualization for this data, we’ll want to include more than one repository. Let’s write a loop to print selected information about each repository the API call returns so we can include them all in the visualization:    **python_repos.py**    ```", "```py    We first print an introductory message ❶. Then we loop through all the dictionaries in `repo_dicts` ❷. Inside the loop, we print the name of each project, its owner, how many stars it has, its URL on GitHub, and the project’s description:    ```", "```py    Some interesting projects appear in these results, and it might be worth looking at a few. But don’t spend too much time here, because we’re about to create a visualization that will make the results much easier to read.    ### Monitoring API Rate Limits    Most APIs have *rate limits*, which means there’s a limit to how many requests you can make in a certain amount of time. To see if you’re approaching GitHub’s limits, enter [https://api.github.com/rate_limit](https://api.github.com/rate_limit%20) into a web browser. You should see a response that begins like this:    ```", "```py    The information we’re interested in is the rate limit for the search API ❶. We see that the limit is 10 requests per minute ❷ and that we have 9 requests remaining for the current minute ❸. The value associated with the key `\"reset\"` represents the time in *Unix* or *epoch time* (the number of seconds since midnight on January 1, 1970) when our quota will reset ❹. If you reach your quota, you’ll get a short response that lets you know you’ve reached the API limit. If you reach the limit, just wait until your quota resets.    ## Visualizing Repositories Using Plotly    Let’s make a visualization using the data we’ve gathered to show the relative popularity of Python projects on GitHub. We’ll make an interactive bar chart: the height of each bar will represent the number of stars the project has acquired, and you’ll be able to click the bar’s label to go to that project’s home on GitHub.    Save a copy of the program we’ve been working on as *python_repos_visual.py*, then modify it so it reads as follows:    **python_repos_visual.py**    ```", "```py    We import Plotly Express and then make the API call as we have been doing. We continue to print the status of the API call response so we’ll know if there is a problem ❶. When we process the overall results, we continue to print the message confirming that we got a complete set of results ❷. We remove the rest of the `print()` calls because we’re no longer in the exploratory phase; we know we have the data we want.    We then create two empty lists ❸ to store the data we’ll include in the initial chart. We’ll need the name of each project to label the bars (`repo_names`) and the number of stars to determine the height of the bars (`stars`). In the loop, we append the name of each project and the number of stars it has to these lists.    We make the initial visualization with just two lines of code ❹. This is consistent with Plotly Express’s philosophy that you should be able to see your visualization as quickly as possible before refining its appearance. Here we use the `px.bar()` function to create a bar chart. We pass the list `repo_names` as the `x` argument and `stars` as the `y` argument.    [Figure 17-1](#figure17-1) shows the resulting chart. We can see that the first few projects are significantly more popular than the rest, but all of them are important projects in the Python ecosystem.  ![](Images/f17001.png)    Figure 17-1: The most-starred Python projects on GitHub      ### Styling the Chart    Plotly supports a number of ways to style and customize the plots, once you know the information in the plot is correct. We’ll make some changes in the initial `px.bar()` call and then make some further adjustments to the `fig` object after it’s been created.    We’ll start styling the chart by adding a title and labels for each axis:    **python_repos_visual.py**    ```", "```py    We first add a title and labels for each axis, as we did in Chapters 15 and 16. We then use the `fig.update_layout()` method to modify specific elements of the chart ❶. Plotly uses a convention where aspects of a chart element are connected by underscores. As you become familiar with Plotly’s documentation, you’ll start to see consistent patterns in how different elements of a chart are named and modified. Here we set the title font size to `28` and the font size for each axis title to `20`. The result is shown in [Figure 17-2](#figure17-2).  ![](Images/f17002.png)    Figure 17-2: A title has been added to the main chart, and to each axis as well.      ### Adding Custom Tooltips    In Plotly, you can hover the cursor over an individual bar to show the information the bar represents. This is commonly called a *tooltip*, and in this case, it currently shows the number of stars a project has. Let’s create a custom tooltip to show each project’s description as well as the project’s owner.    We need to pull some additional data to generate the tooltips:    **python_repos_visual.py**    ```", "```py    We first define a new empty list, `hover_texts`, to hold the text we want to display for each project ❶. In the loop where we process the data, we pull the owner and the description for each project ❷. Plotly allows you to use HTML code within text elements, so we generate a string for the label with a line break (`<br />`) between the project owner’s username and the description ❸. We then append this label to the list `hover_texts`.    In the `px.bar()` call, we add the `hover_name` argument and pass it `hover_texts` ❹. This is the same approach we used to customize the label for each dot in the map of global earthquake activity. As Plotly creates each bar, it will pull labels from this list and only display them when the viewer hovers over a bar. [Figure 17-3](#figure17-3) shows one of these custom tooltips.  ![](Images/f17003.png)    Figure 17-3: Hovering over a bar shows the project’s owner and description.      ### Adding Clickable Links    Because Plotly allows you to use HTML on text elements, we can easily add links to a chart. Let’s use the *x*-axis labels as a way to let the viewer visit any project’s home page on GitHub. We need to pull the URLs from the data and use them when generating the *x*-axis labels:    **python_repos_visual.py**    ```", "```py    We update the name of the list we’re creating from `repo_names` to `repo_links` to more accurately communicate the kind of information we’re putting together for the chart ❶. We then pull the URL for the project from `repo_dict` and assign it to the temporary variable `repo_url` ❷. Next, we generate a link to the project ❸. We use the HTML anchor tag, which has the form `<a href='URL'>link text</a>`, to generate the link. We then append this link to `repo_links`.    When we call `px.bar()`, we use `repo_links` for the *x*-values in the chart. The result looks the same as before, but now the viewer can click any of the project names at the bottom of the chart to visit that project’s home page on GitHub. Now we have an interactive, informative visualization of data retrieved through an API!    ### Customizing Marker Colors    Once a chart has been created, almost any aspect of the chart can be customized through an update method. We’ve used the `update_layout()` method previously. Another method, `update_traces()`, can be used to customize the data that’s represented on a chart.    Let’s change the bars to a darker blue, with some transparency:    ```", "```py    In Plotly, a *trace* refers to a collection of data on a chart. The `update_traces()` method can take a number of different arguments; any argument that starts with `marker_` affects the markers on the chart. Here we set each marker’s color to `'SteelBlue'`; any named CSS color will work here. We also set the opacity of each marker to `0.6`. An opacity of 1.0 will be entirely opaque, and an opacity of 0 will be entirely invisible.    ### More About Plotly and the GitHub API    Plotly’s documentation is extensive and well organized; however, it can be hard to know where to start reading. A good place to start is with the article “Plotly Express in Python,” at [https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express). This is an overview of all the plots you can make with Plotly Express, and you can find links to longer articles about each individual chart type.    If you want to understand how to customize Plotly charts better, the article “Styling Plotly Express Figures in Python” will expand on what you’ve seen in Chapters 15–17. You can find this article at [https://plotly.com/python/styling-plotly-express](https://plotly.com/python/styling-plotly-express).    For more about the GitHub API, refer to its documentation at [https://docs.github.com/en/rest](https://docs.github.com/en/rest). Here you’ll learn how to pull a wide variety of information from GitHub. To expand on what you saw in this project, look for the Search section of the reference in the sidebar. If you have a GitHub account, you can work with your own data as well as the publicly available data from other users’ repositories.    ## The Hacker News API    To explore how to use API calls on other sites, let’s take a quick look at Hacker News ([https://news.ycombinator.com](https://news.ycombinator.com)). On Hacker News, people share articles about programming and technology and engage in lively discussions about those articles. The Hacker News API provides access to data about all submissions and comments on the site, and you can use the API without having to register for a key.    The following call returns information about the current top article as of this writing:    ```", "```py    When you enter this URL in a browser, you’ll see that the text on the page is enclosed by braces, meaning it’s a dictionary. But the response is difficult to examine without some better formatting. Let’s run this URL through the `json.dumps()` method, like we did in the earthquake project in Chapter 16, so we can explore the kind of information that’s returned about an article:    **hn_article.py**    ```", "```py    Everything in this program should look familiar, because we’ve used it all in the previous two chapters. The main difference here is that we can print the formatted response string ❶ instead of writing it to a file, because the output is not particularly long.    The output is a dictionary of information about the article with the ID `31353677`:    ```", "```py    The dictionary contains a number of keys we can work with. The key `\"descendants\"` tells us the number of comments the article has received ❶. The key `\"kids\"` provides the IDs of all comments made directly in response to this submission ❷. Each of these comments might have comments of their own as well, so the number of descendants a submission has is usually greater than its number of kids. We can see the title of the article being discussed ❸ and a URL for the article being discussed as well ❹.    The following URL returns a simple list of all the IDs of the current top articles on Hacker News:    ```", "```py    We can use this call to find out which articles are on the home page right now, and then generate a series of API calls similar to the one we just examined. With this approach, we can print a summary of all the articles on the front page of Hacker News at the moment:    **hn_submissions.py**    ```", "```py    First, we make an API call and print the status of the response ❶. This API call returns a list containing the IDs of up to 500 of the most popular articles on Hacker News at the time the call is issued. We then convert the response object to a Python list ❷, which we assign to `submission_ids`. We’ll use these IDs to build a set of dictionaries, each of which contains information about one of the current submissions.    We set up an empty list called `submission_dicts` to store these dictionaries ❸. We then loop through the IDs of the top 30 submissions. We make a new API call for each submission by generating a URL that includes the current value of `submission_id` ❹. We print the status of each request along with its ID, so we can see whether it’s successful.    Next, we create a dictionary for the submission currently being processed ❺. We store the title of the submission, a link to the discussion page for that item, and the number of comments the article has received so far. Then we append each `submission_dict` to the list `submission_dicts` ❻.    Each submission on Hacker News is ranked according to an overall score based on a number of factors, including how many times it’s been voted on, how many comments it’s received, and how recent the submission is. We want to sort the list of dictionaries by the number of comments. To do this, we use a function called `itemgetter()` ❼, which comes from the `operator` module. We pass this function the key `'comments'`, and it pulls the value associated with that key from each dictionary in the list. The `sorted()` function then uses this value as its basis for sorting the list. We sort the list in reverse order, to place the most-commented stories first.    Once the list is sorted, we loop through the list ❽ and print out three pieces of information about each of the top submissions: the title, a link to the discussion page, and the number of comments the submission currently has:    ```", "```py    You would use a similar process to access and analyze information with any API. With this data, you could make a visualization showing which submissions have inspired the most active recent discussions. This is also the basis for apps that provide a customized reading experience for sites like Hacker News. To learn more about what kind of information you can access through the Hacker News API, visit the documentation page at [https://github.com/HackerNews/API](https://github.com/HackerNews/API).    ## Summary    In this chapter, you learned how to use APIs to write self-contained programs that automatically gather the data they need and use that data to create a visualization. You used the GitHub API to explore the most-starred Python projects on GitHub, and you also looked briefly at the Hacker News API. You learned how to use the Requests package to automatically issue an API call and how to process the results of that call. We also introduced some Plotly settings that further customize the appearance of the charts you generate.    In the next chapter, you’ll use Django to build a web application as your final project.   # 18 Getting Started with Django  ![](Images/chapterart.png)  As the internet has evolved, the line between websites and mobile apps has blurred. Websites and apps both help users interact with data in a variety of ways. Fortunately, you can use Django to build a single project that serves a dynamic website as well as a set of mobile apps. *Django* is Python’s most popular *web framework*, a set of tools designed for building interactive web applications. In this chapter, you’ll learn how to use Django to build a project called Learning Log, an online journal system that lets you keep track of information you’ve learned about different topics.    We’ll write a specification for this project, and then define models for the data the app will work with. We’ll use Django’s admin system to enter some initial data, and then write views and templates so Django can build the site’s pages.    Django can respond to page requests and make it easier to read and write to a database, manage users, and much more. In Chapters 19 and 20, you’ll refine the Learning Log project, and then deploy it to a live server so you (and everyone else in the world) can use it.    ## Setting Up a Project    When starting work on something as significant as a web app, you first need to describe the project’s goals in a specification, or *spec*. Once you have a clear set of goals, you can start to identify manageable tasks to achieve those goals.    In this section, we’ll write a spec for Learning Log and start working on the first phase of the project. This will involve setting up a virtual environment and building out the initial aspects of a Django project.    ### Writing a Spec    A full spec details the project goals, describes the project’s functionality, and discusses its appearance and user interface. Like any good project or business plan, a spec should keep you focused and help keep your project on track. We won’t write a full project spec here, but we’ll lay out a few clear goals to keep the development process focused. Here’s the spec we’ll use:    > We’ll write a web app called Learning Log that allows users to log the topics they’re interested in and make journal entries as they learn about each topic. The Learning Log home page will describe the site and invite users to either register or log in. Once logged in, a user can create new topics, add new entries, and read and edit existing entries.    When you’re researching a new topic, maintaining a journal of what you’ve learned can help you keep track of new information and information you’ve already found. This is especially true when studying technical subjects. A good app, like the one we’ll be creating, can help make this process more efficient.    ### Creating a Virtual Environment    To work with Django, we’ll first set up a virtual environment. A *virtual environment* is a place on your system where you can install packages and isolate them from all other Python packages. Separating one project’s libraries from other projects is beneficial and will be necessary when we deploy Learning Log to a server in Chapter 20.    Create a new directory for your project called *learning_log*, switch to that directory in a terminal, and enter the following code to create a virtual environment:    ```", "```py    Here we’re running the `venv` virtual environment module and using it to create an environment named *ll_env* (note that this name starts with two lowercase *L*s, not two ones). If you use a command such as `python3` when running programs or installing packages, make sure to use that command here.    ### Activating the Virtual Environment    Now we need to activate the virtual environment, using the following command:    ```", "```py    This command runs the script *activate* in *ll_env/bin/*. When the environment is active, you’ll see the name of the environment in parentheses. This indicates that you can install new packages to the environment and use packages that have already been installed. Packages you install in *ll_env* will not be available when the environment is inactive.    To stop using a virtual environment, enter `deactivate`:    ```", "```py    The environment will also become inactive when you close the terminal it’s running in.    ### Installing Django    With the virtual environment activated, enter the following to update pip and install Django:    ```", "```py    Because it downloads resources from a variety of sources, pip is upgraded fairly often. It’s a good idea to upgrade pip whenever you make a new virtual environment.    We’re working in a virtual environment now, so the command to install Django is the same on all systems. There’s no need to use longer commands, such as `python -m pip install` `package_name`, or to include the `--user` flag. Keep in mind that Django will be available only when the *ll_env* environment is active.    ### Creating a Project in Django    Without leaving the active virtual environment (remember to look for *ll_env* in parentheses in the terminal prompt), enter the following commands to create a new project:    ```", "```py    The `startproject` command ❶ tells Django to set up a new project called *ll_project*. The dot (`.`) at the end of the command creates the new project with a directory structure that will make it easy to deploy the app to a server when we’re finished developing it.    Running the `ls` command (`dir` on Windows) ❷ shows that Django has created a new directory called *ll_project*. It also created a *manage.py* file, which is a short program that takes in commands and feeds them to the relevant part of Django. We’ll use these commands to manage tasks, such as working with databases and running servers.    The *ll_project* directory contains four files ❸; the most important are *settings.py*, *urls.py*, and *wsgi.py*. The *settings.py* file controls how Django interacts with your system and manages your project. We’ll modify a few of these settings and add some settings of our own as the project evolves. The *urls.py* file tells Django which pages to build in response to browser requests. The *wsgi.py* file helps Django serve the files it creates. The filename is an acronym for “web server gateway interface.”    ### Creating the Database    Django stores most of the information for a project in a database, so next we need to create a database that Django can work with. Enter the following command (still in an active environment):    ```", "```py    Anytime we modify a database, we say we’re *migrating* the database. Issuing the `migrate` command for the first time tells Django to make sure the database matches the current state of the project. The first time we run this command in a new project using SQLite (more about SQLite in a moment), Django will create a new database for us. Here, Django reports that it will prepare the database to store information it needs to handle administrative and authentication tasks ❶.    Running the `ls` command shows that Django created another file called *db.sqlite3* ❷. *SQLite* is a database that runs off a single file; it’s ideal for writing simple apps because you won’t have to pay much attention to managing the database.    ### Viewing the Project    Let’s make sure that Django has set up the project properly. Enter the `runserver` command to view the project in its current state:    ```", "```py    Django should start a server called the *development server*, so you can view the project on your system to see how well it works. When you request a page by entering a URL in a browser, the Django server responds to that request by building the appropriate page and sending it to the browser.    Django first checks to make sure the project is set up properly ❶; it then reports the version of Django in use and the name of the settings file in use ❷. Finally, it reports the URL where the project is being served ❸. The URL *http://127.0.0.1:8000/* indicates that the project is listening for requests on port 8000 on your computer, which is called a localhost. The term *localhost* refers to a server that only processes requests on your system; it doesn’t allow anyone else to see the pages you’re developing.    Open a web browser and enter the URL *http://localhost:8000/*, or *http://127.0.0.1:8000/* if the first one doesn’t work. You should see something like [Figure 18-1](#figure18-1): a page that Django creates to let you know everything is working properly so far. Keep the server running for now, but when you want to stop the server, press CTRL-C in the terminal where the `runserver` command was issued.  ![](Images/f18001.png)    Figure 18-1: Everything is working so far.      ## Starting an App    A Django *project* is organized as a group of individual *apps* that work together to make the project work as a whole. For now, we’ll create one app to do most of our project’s work. We’ll add another app in Chapter 19 to manage user accounts.    You should leave the development server running in the terminal window you opened earlier. Open a new terminal window (or tab) and navigate to the directory that contains *manage.py*. Activate the virtual environment, and then run the `startapp` command:    ```", "```py    The command `startapp` `appname` tells Django to create the infrastructure needed to build an app. When you look in the project directory now, you’ll see a new folder called *learning_logs* ❶. Use the `ls` command to see what Django has created ❷. The most important files are *models.py*, *admin.py*, and *views.py*. We’ll use *models.py* to define the data we want to manage in our app. We’ll look at *admin.py* and *views.py* a little later.    ### Defining Models    Let’s think about our data for a moment. Each user will need to create a number of topics in their learning log. Each entry they make will be tied to a topic, and these entries will be displayed as text. We’ll also need to store the timestamp of each entry so we can show users when they made each one.    Open the file *models.py* and look at its existing content:    **models.py**    ```", "```py    A module called `models` is being imported, and we’re being invited to create models of our own. A *model* tells Django how to work with the data that will be stored in the app. A model is a class; it has attributes and methods, just like every class we’ve discussed. Here’s the model for the topics users will store:    ```", "```py    We’ve created a class called `Topic`, which inherits from `Model`—a parent class included in Django that defines a model’s basic functionality. We add two attributes to the `Topic` class: `text` and `date_added`.    The `text` attribute is a `CharField`, a piece of data that’s made up of characters or text ❶. You use `CharField` when you want to store a small amount of text, such as a name, a title, or a city. When we define a `CharField` attribute, we have to tell Django how much space it should reserve in the database. Here we give it a `max_length` of `200` characters, which should be enough to hold most topic names.    The `date_added` attribute is a `DateTimeField`, a piece of data that will record a date and time ❷. We pass the argument `auto_now_add=True`, which tells Django to automatically set this attribute to the current date and time whenever the user creates a new topic.    It’s a good idea to tell Django how you want it to represent an instance of a model. If a model has a `__str__()` method, Django calls that method whenever it needs to generate output referring to an instance of that model. Here we’ve written a `__str__()` method that returns the value assigned to the `text` attribute ❸.    To see the different kinds of fields you can use in a model, see the “Model Field Reference” page at [https://docs.djangoproject.com/en/4.1/ref/models/fields](https://docs.djangoproject.com/en/4.1/ref/models/fields). You won’t need all the information right now, but it will be extremely useful when you’re developing your own Django projects.    ### Activating Models    To use our models, we have to tell Django to include our app in the overall project. Open *settings.py* (in the *ll_project* directory); you’ll see a section that tells Django which apps are installed in the project:    **settings.py**    ```", "```py    Add our app to this list by modifying `INSTALLED_APPS` so it looks like this:    ```", "```py    Grouping apps together in a project helps keep track of them as the project grows to include more apps. Here we start a section called `My apps`, which includes only `'learning_logs'` for now. It’s important to place your own apps before the default apps, in case you need to override any behavior of the default apps with your own custom behavior.    Next, we need to tell Django to modify the database so it can store information related to the model `Topic`. From the terminal, run the following command:    ```", "```py    The command `makemigrations` tells Django to figure out how to modify the database so it can store the data associated with any new models we’ve defined. The output here shows that Django has created a migration file called *0001_initial.py*. This migration will create a table for the model `Topic` in the database.    Now we’ll apply this migration and have Django modify the database for us:    ```", "```py    Most of the output from this command is identical to the output from the first time we issued the `migrate` command. We need to check the last line in this output, where Django confirms that the migration for `learning_logs` worked `OK`.    Whenever we want to modify the data that Learning Log manages, we’ll follow these three steps: modify *models.py*, call `makemigrations` on `learning_logs`, and tell Django to `migrate` the project.    ### The Django Admin Site    Django makes it easy to work with your models through its admin site. Django’s *admin site* is only meant to be used by the site’s administrators; it’s not meant for regular users. In this section, we’ll set up the admin site and use it to add some topics through the `Topic` model.    #### Setting Up a Superuser    Django allows you to create a *superuser*, a user who has all privileges available on the site. A user’s *privileges* control the actions they can take. The most restrictive privilege settings allow a user to only read public information on the site. Registered users typically have the privilege of reading their own private data and some selected information available only to members. To effectively administer a project, the site owner usually needs access to all information stored on the site. A good administrator is careful with their users’ sensitive information, because users put a lot of trust into the apps they access.    To create a superuser in Django, enter the following command and respond to the prompts:    ```", "```py    When you issue the command `createsuperuser`, Django prompts you to enter a username for the superuser ❶. Here I’m using `ll_admin`, but you can enter any username you want. You can enter an email address or just leave this field blank ❷. You’ll need to enter your password twice ❸.    #### Registering a Model with the Admin Site    Django includes some models in the admin site automatically, such as `User` and `Group`, but the models we create need to be added manually.    When we started the `learning_logs` app, Django created an *admin.py* file in the same directory as *models.py*. Open the *admin.py* file:    **admin.py**    ```", "```py    To register `Topic` with the admin site, enter the following:    ```", "```py    This code first imports the model we want to register, `Topic`. The dot in front of `models` tells Django to look for *models.py* in the same directory as *admin.py*. The code `admin.site.register()` tells Django to manage our model through the admin site.    Now use the superuser account to access the admin site. Go to *http://localhost:8000/admin/* and enter the username and password for the superuser you just created. You should see a screen similar to the one shown in [Figure 18-2](#figure18-2). This page allows you to add new users and groups, and change existing ones. You can also work with data related to the `Topic` model that we just defined.  ![](Images/f18002.png)    Figure 18-2: The admin site with `Topic` included      #### Adding Topics    Now that `Topic` has been registered with the admin site, let’s add our first topic. Click **Topics** to go to the Topics page, which is mostly empty, because we have no topics to manage yet. Click **Add Topic**, and a form for adding a new topic appears. Enter `Chess` in the first box and click **Save**. You’ll be sent back to the Topics admin page, and you’ll see the topic you just created.    Let’s create a second topic so we’ll have more data to work with. Click **Add Topic** again, and enter `Rock Climbing`. Click **Save**, and you’ll be sent back to the main Topics page again. Now you’ll see Chess and Rock Climbing listed.    ### Defining the Entry Model    For a user to record what they’ve been learning about chess and rock climbing, we need to define a model for the kinds of entries users can make in their learning logs. Each entry needs to be associated with a particular topic. This relationship is called a *many-to-one relationship*, meaning many entries can be associated with one topic.    Here’s the code for the `Entry` model. Place it in your *models.py* file:    **models.py**    ```", "```py    The `Entry` class inherits from Django’s base `Model` class, just as `Topic` did ❶. The first attribute, `topic`, is a `ForeignKey` instance ❷. A *foreign key* is a database term; it’s a reference to another record in the database. This is the code that connects each entry to a specific topic. Each topic is assigned a *key*, or ID, when it’s created. When Django needs to establish a connection between two pieces of data, it uses the keys associated with each piece of information. We’ll use these connections shortly to retrieve all the entries associated with a certain topic. The `on_delete=models.CASCADE` argument tells Django that when a topic is deleted, all the entries associated with that topic should be deleted as well. This is known as a *cascading delete*.    Next is an attribute called `text`, which is an instance of `TextField` ❸. This kind of field doesn’t need a size limit, because we don’t want to limit the size of individual entries. The `date_added` attribute allows us to present entries in the order they were created, and to place a timestamp next to each entry.    The `Meta` class is nested inside the `Entry` class ❹. The `Meta` class holds extra information for managing a model; here, it lets us set a special attribute telling Django to use `Entries` when it needs to refer to more than one entry. Without this, Django would refer to multiple entries as `Entrys`.    The `__str__()` method tells Django which information to show when it refers to individual entries. Because an entry can be a long body of text, `__str__()` returns just the first `50` characters of `text` ❺. We also add an ellipsis to clarify that we’re not always displaying the entire entry.    ### Migrating the Entry Model    Because we’ve added a new model, we need to migrate the database again. This process will become quite familiar: you modify *models.py*, run the command `python manage.py makemigrations` `app_name`, and then run the command `python manage.py migrate`.    Migrate the database and check the output by entering the following commands:    ```", "```py    A new migration called *0002_entry.py* is generated, which tells Django how to modify the database to store information related to the model `Entry` ❶. When we issue the `migrate` command, we see that Django applied this migration and everything worked properly ❷.    ### Registering Entry with the Admin Site    We also need to register the `Entry` model. Here’s what *admin.py* should look like now:    **admin.py**    ```", "```py    Go back to *http://localhost/admin/*, and you should see Entries listed under *Learning_Logs*. Click the **Add** link for Entries, or click **Entries** and then choose **Add entry**. You should see a drop-down list to select the topic you’re creating an entry for and a text box for adding an entry. Select **Chess** from the drop-down list, and add an entry. Here’s the first entry I made:    > The opening is the first part of the game, roughly the first ten moves or so. In the opening, it’s a good idea to do three things—bring out your bishops and knights, try to control the center of the board, and castle your king. >  > Of course, these are just guidelines. It will be important to learn when to follow these guidelines and when to disregard these suggestions.    When you click **Save**, you’ll be brought back to the main admin page for entries. Here, you’ll see the benefit of using `text[:50]` as the string representation for each entry; it’s much easier to work with multiple entries in the admin interface if you see only the first part of an entry, rather than the entire text of each entry.    Make a second entry for Chess and one entry for Rock Climbing so we have some initial data. Here’s a second entry for Chess:    > In the opening phase of the game, it’s important to bring out your bishops and knights. These pieces are powerful and maneuverable enough to play a significant role in the beginning moves of a game.    And here’s a first entry for Rock Climbing:    > One of the most important concepts in climbing is to keep your weight on your feet as much as possible. There’s a myth that climbers can hang all day on their arms. In reality, good climbers have practiced specific ways of keeping their weight over their feet whenever possible.    These three entries will give us something to work with as we continue to develop Learning Log.    ### The Django Shell    Now that we’ve entered some data, we can examine it programmatically through an interactive terminal session. This interactive environment is called the Django *shell*, and it’s a great environment for testing and troubleshooting your project. Here’s an example of an interactive shell session:    ```", "```py    The command `python manage.py shell`, run in an active virtual environment, launches a Python interpreter that you can use to explore the data stored in your project’s database. Here, we import the model `Topic` from the `learning_logs.models` module ❶. We then use the method `Topic.objects.all()` to get all instances of the model `Topic`; the list that’s returned is called a *queryset*.    We can loop over a queryset just as we’d loop over a list. Here’s how you can see the ID that’s been assigned to each topic object:    ```", "```py    We assign the queryset to `topics` and then print each topic’s `id` attribute and the string representation of each topic. We can see that `Chess` has an ID of `1` and `Rock Climbing` has an ID of `2`.    If you know the ID of a particular object, you can use the method `Topic.objects.get()` to retrieve that object and examine any attribute the object has. Let’s look at the `text` and `date_added` values for `Chess`:    ```", "```py    We can also look at the entries related to a certain topic. Earlier, we defined the `topic` attribute for the `Entry` model. This was a `ForeignKey`, a connection between each entry and a topic. Django can use this connection to get every entry related to a certain topic, like this:    ```", "```py    To get data through a foreign key relationship, you use the lowercase name of the related model followed by an underscore and the word `set` ❶. For example, say you have the models `Pizza` and `Topping`, and `Topping` is related to `Pizza` through a foreign key. If your object is called `my_pizza`, representing a single pizza, you can get all of the pizza’s toppings using the code `my_pizza.topping_set.all()`.    We’ll use this syntax when we begin to code the pages users can request. The shell is really useful for making sure your code retrieves the data you want it to. If your code works as you expect it to in the shell, it should also work properly in the files within your project. If your code generates errors or doesn’t retrieve the data you expect it to, it’s much easier to troubleshoot your code in the simple shell environment than within the files that generate web pages. We won’t refer to the shell much, but you should continue using it to practice working with Django’s syntax for accessing the data stored in the project.    Each time you modify your models, you’ll need to restart the shell to see the effects of those changes. To exit a shell session, press CTRL-D; on Windows, press CTRL-Z and then press ENTER.    ## Making Pages: The Learning Log Home Page    Making web pages with Django consists of three stages: defining URLs, writing views, and writing templates. You can do these in any order, but in this project we’ll always start by defining the URL pattern. A *URL pattern* describes the way the URL is laid out. It also tells Django what to look for when matching a browser request with a site URL, so it knows which page to return.    Each URL then maps to a particular view. The *view* function retrieves and processes the data needed for that page. The view function often renders the page using a *template*, which contains the overall structure of the page. To see how this works, let’s make the home page for Learning Log. We’ll define the URL for the home page, write its view function, and create a simple template.    Because we just want to ensure that Learning Log works as it’s supposed to, we’ll make a simple page for now. A functioning web app is fun to style when it’s complete; an app that looks good but doesn’t work well is pointless. For now, the home page will display only a title and a brief description.    ### Mapping a URL    Users request pages by entering URLs into a browser and clicking links, so we’ll need to decide what URLs are needed. The home page URL is first: it’s the base URL people use to access the project. At the moment, the base URL, *http://localhost:8000/*, returns the default Django site that lets us know the project was set up correctly. We’ll change this by mapping the base URL to Learning Log’s home page.    In the main *ll_project* folder, open the file *urls.py*. You should see the following code:    **ll_project/urls.py**    ```", "```py    The first two lines import the `admin` module and a function to build URL paths ❶. The body of the file defines the `urlpatterns` variable ❷. In this *urls.py* file, which defines URLs for the project as a whole, the `urlpatterns` variable includes sets of URLs from the apps in the project. The list includes the module `admin.site.urls`, which defines all the URLs that can be requested from the admin site ❸.    We need to include the URLs for `learning_logs`, so add the following:    ```", "```py    We’ve imported the `include()` function, and we’ve also added a line to include the module `learning_logs.urls`.    The default *urls.py* is in the *ll_project* folder; now we need to make a second *urls.py* file in the *learning_logs* folder. Create a new Python file, save it as *urls.py* in *learning_logs*, and enter this code into it:    **learning_logs/urls.py**    ```", "```py    To make it clear which *urls.py* we’re working in, we add a docstring at the beginning of the file ❶. We then import the `path` function, which is needed when mapping URLs to views ❷. We also import the `views` module ❸; the dot tells Python to import the *views.py* module from the same directory as the current *urls.py* module. The variable `app_name` helps Django distinguish this *urls.py* file from files of the same name in other apps within the project ❹. The variable `urlpatterns` in this module is a list of individual pages that can be requested from the `learning_logs` app ❺.    The actual URL pattern is a call to the `path()` function, which takes three arguments ❻. The first argument is a string that helps Django route the current request properly. Django receives the requested URL and tries to route the request to a view. It does this by searching all the URL patterns we’ve defined to find one that matches the current request. Django ignores the base URL for the project (*http://localhost:8000/*), so the empty string (`''`) matches the base URL. Any other URL won’t match this pattern, and Django will return an error page if the URL requested doesn’t match any existing URL patterns.    The second argument in `path()` ❻ specifies which function to call in *views.py*. When a requested URL matches the pattern we’re defining, Django calls the `index()` function from *views.py*. (We’ll write this view function in the next section.) The third argument provides the name *index* for this URL pattern so we can refer to it more easily in other files throughout the project. Whenever we want to provide a link to the home page, we’ll use this name instead of writing out a URL.    ### Writing a View    A view function takes in information from a request, prepares the data needed to generate a page, and then sends the data back to the browser. It often does this by using a template that defines what the page will look like.    The file *views.py* in *learning_logs* was generated automatically when we ran the command `python manage.py startapp`. Here’s what’s in *views.py* right now:    **views.py**    ```", "```py    Currently, this file just imports the `render()` function, which renders the response based on the data provided by views. Open *views.py* and add the following code for the home page:    ```", "```py    When a URL request matches the pattern we just defined, Django looks for a function called `index()` in the *views.py* file. Django then passes the `request` object to this view function. In this case, we don’t need to process any data for the page, so the only code in the function is a call to `render()`. The `render()` function here passes two arguments: the original `request` object and a template it can use to build the page. Let’s write this template.    ### Writing a Template    The template defines what the page should look like, and Django fills in the relevant data each time the page is requested. A template allows you to access any data provided by the view. Because our view for the home page provides no data, this template is fairly simple.    Inside the *learning_logs* folder, make a new folder called *templates*. Inside the *templates* folder, make another folder called *learning_logs*. This might seem a little redundant (we have a folder named *learning_logs* inside a folder named *templates* inside a folder named *learning_logs*), but it sets up a structure that Django can interpret unambiguously, even in the context of a large project containing many individual apps. Inside the inner *learning_logs* folder, make a new file called *index.html*. The path to the file will be *ll_project/learning_logs/templates/learning_logs/index.html*. Enter the following code into that file:    **index.html**    ```", "```py    This is a very simple file. If you’re not familiar with HTML, the `<p></p>` tags signify paragraphs. The `<p>` tag opens a paragraph, and the `</p>` tag closes a paragraph. We have two paragraphs: the first acts as a title, and the second describes what users can do with Learning Log.    Now when you request the project’s base URL, *http://localhost:8000/*, you should see the page we just built instead of the default Django page. Django will take the requested URL, and that URL will match the pattern `''`; then Django will call the function `views.index()`, which will render the page using the template contained in *index.html*. [Figure 18-3](#figure18-3) shows the resulting page.  ![](Images/f18003.png)    Figure 18-3: The home page for Learning Log      Although it might seem like a complicated process for creating one page, this separation between URLs, views, and templates works quite well. It allows you to think about each aspect of a project separately. In larger projects, it allows individuals working on the project to focus on the areas in which they’re strongest. For example, a database specialist can focus on the models, a programmer can focus on the view code, and a frontend specialist can focus on the templates.    ## Building Additional Pages    Now that we’ve established a routine for building a page, we can start to build out the Learning Log project. We’ll build two pages that display data: a page that lists all topics and a page that shows all the entries for a particular topic. For each page, we’ll specify a URL pattern, write a view function, and write a template. But before we do this, we’ll create a base template that all templates in the project can inherit from.    ### Template Inheritance    When building a website, some elements will need to be repeated on each page. Rather than writing these elements directly into each page, you can write a base template containing the repeated elements and then have each page inherit from the base. This approach lets you focus on developing the unique aspects of each page, and makes it much easier to change the overall look and feel of the project.    #### The Parent Template    We’ll create a template called *base.html* in the same directory as *index.html*. This file will contain elements common to all pages; every other template will inherit from *base.html*. The only element we want to repeat on each page right now is the title at the top. Because we’ll include this template on every page, let’s make the title a link to the home page:    **base.html**    ```", "```py    The first part of this file creates a paragraph containing the name of the project, which also acts as a home page link. To generate a link, we use a *template tag*, which is indicated by braces and percent signs (`{% %}`). A template tag generates information to be displayed on a page. The template tag `{% url 'learning_logs:index' %}` shown here generates a URL matching the URL pattern defined in *learning_logs/urls.py* with the name `'index'` ❶. In this example, `learning_logs` is the *namespace* and `index` is a uniquely named URL pattern in that namespace. The namespace comes from the value we assigned to `app_name` in the *learning_logs/urls.py* file.    In a simple HTML page, a link is surrounded by the *anchor* *tag* `<a>`:    ```", "```py    Having the template tag generate the URL for us makes it much easier to keep our links up to date. We only need to change the URL pattern in *urls.py*, and Django will automatically insert the updated URL the next time the page is requested. Every page in our project will inherit from *base.html*, so from now on, every page will have a link back to the home page.    On the last line, we insert a pair of `block` tags ❷. This block, named `content`, is a placeholder; the child template will define the kind of information that goes in the `content` block.    A child template doesn’t have to define every block from its parent, so you can reserve space in parent templates for as many blocks as you like; the child template uses only as many as it needs.    #### The Child Template    Now we need to rewrite *index.html* to inherit from *base.html*. Add the following code to *index.html*:    **index.html**    ```", "```py    If you compare this to the original *index.html*, you can see that we’ve replaced the Learning Log title with the code for inheriting from a parent template ❶. A child template must have an `{% extends %}` tag on the first line to tell Django which parent template to inherit from. The file *base.html* is part of `learning_logs`, so we include *learning_logs* in the path to the parent template. This line pulls in everything contained in the *base.html* template and allows *index.html* to define what goes in the space reserved by the `content` block.    We define the content block by inserting a `{% block %}` tag with the name `content` ❷. Everything that we aren’t inheriting from the parent template goes inside the `content` block. Here, that’s the paragraph describing the Learning Log project. We indicate that we’re finished defining the content by using an `{% endblock content %}` tag ❸. The `{% endblock %}` tag doesn’t require a name, but if a template grows to contain multiple blocks, it can be helpful to know exactly which block is ending.    You can start to see the benefit of template inheritance: in a child template, we only need to include content that’s unique to that page. This not only simplifies each template, but also makes it much easier to modify the site. To modify an element common to many pages, you only need to modify the parent template. Your changes are then carried over to every page that inherits from that template. In a project that includes tens or hundreds of pages, this structure can make it much easier and faster to improve your site.    In a large project, it’s common to have one parent template called *base.html* for the entire site and parent templates for each major section of the site. All the section templates inherit from *base.html*, and each page in the site inherits from a section template. This way you can easily modify the look and feel of the site as a whole, any section in the site, or any individual page. This configuration provides a very efficient way to work, and encourages you to steadily update your project over time.    ### The Topics Page    Now that we have an efficient approach to building pages, we can focus on our next two pages: the general topics page and the page to display entries for a single topic. The topics page will show all topics that users have created, and it’s the first page that will involve working with data.    #### The Topics URL Pattern    First, we define the URL for the topics page. It’s common to choose a simple URL fragment that reflects the kind of information presented on the page. We’ll use the word *topics*, so the URL *http://localhost:8000/topics/* will return this page. Here’s how we modify *learning_logs/urls.py*:    **learning_logs/urls.py**    ```", "```py    The new URL pattern is the word *topics*, followed by a forward slash. When Django examines a requested URL, this pattern will match any URL that has the base URL followed by *topics*. You can include or omit a forward slash at the end, but there can’t be anything else after the word *topics*, or the pattern won’t match. Any request with a URL that matches this pattern will then be passed to the function `topics()` in *views.py*.    #### The Topics View    The `topics()` function needs to retrieve some data from the database and send it to the template. Add the following to *views.py*:    **views.py**    ```", "```py    We first import the model associated with the data we need ❶. The `topics()` function needs one parameter: the `request` object Django received from the server ❷. We query the database by asking for the `Topic` objects, sorted by the `date_added` attribute ❸. We assign the resulting queryset to `topics`.    We then define a context that we’ll send to the template ❹. A *context* is a dictionary in which the keys are names we’ll use in the template to access the data we want, and the values are the data we need to send to the template. In this case, there’s one key-value pair, which contains the set of topics we’ll display on the page. When building a page that uses data, we call `render()` with the `request` object, the template we want to use, and the `context` dictionary ❺.    #### The Topics Template    The template for the topics page receives the `context` dictionary, so the template can use the data that `topics()` provides. Make a file called *topics.html* in the same directory as *index.html*. Here’s how we can display the topics in the template:    **topics.html**    ```", "```py    We use the `{% extends %}` tag to inherit from *base.html*, just as we did on the home page, and then we open a `content` block. The body of this page contains a bulleted list of the topics that have been entered. In standard HTML, a bulleted list is called an *unordered list* and is indicated by the tags `<ul></ul>`. The opening tag `<ul>` begins the bulleted list of topics ❶.    Next we use a template tag that’s equivalent to a `for` loop, which loops through the list `topics` from the `context` dictionary ❷. The code used in templates differs from Python in some important ways. Python uses indentation to indicate which lines of a `for` statement are part of a loop. In a template, every `for` loop needs an explicit `{% endfor %}` tag indicating where the end of the loop occurs. So in a template, you’ll see loops written like this:    ```", "```py    Inside the loop, we want to turn each topic into an item in the bulleted list. To print a variable in a template, wrap the variable name in double braces. The braces won’t appear on the page; they just indicate to Django that we’re using a template variable. So the code `{{ topic.text }}` ❸ will be replaced by the value of the current topic’s `text` attribute on each pass through the loop. The HTML tag `<li></li>` indicates a *list item*. Anything between these tags, inside a pair of `<ul></ul>` tags, will appear as a bulleted item in the list.    We also use the `{% empty %}` template tag ❹, which tells Django what to do if there are no items in the list. In this case, we print a message informing the user that no topics have been added yet. The last two lines close out the `for` loop ❺ and then close out the bulleted list ❻.    Now we need to modify the base template to include a link to the topics page. Add the following code to *base.html*:    **base.html**    ```", "```py    We add a dash after the link to the home page ❶, and then add a link to the topics page using the `{% url %}` template tag again ❷. This line tells Django to generate a link matching the URL pattern with the name `'topics'` in *learning_logs/urls.py*.    Now when you refresh the home page in your browser, you’ll see a Topics link. When you click the link, you’ll see a page that looks similar to [Figure 18-4](#figure18-4).  ![](Images/f18004.png)    Figure 18-4: The topics page      ### Individual Topic Pages    Next, we need to create a page that can focus on a single topic, showing the topic name and all the entries for that topic. We’ll define a new URL pattern, write a view, and create a template. We’ll also modify the topics page so each item in the bulleted list links to its corresponding topic page.    #### The Topic URL Pattern    The URL pattern for the topic page is a little different from the prior URL patterns because it will use the topic’s `id` attribute to indicate which topic was requested. For example, if the user wants to see the detail page for the Chess topic (where the `id` is 1), the URL will be *http://localhost:8000/topics/1/*. Here’s a pattern to match this URL, which you should place in *learning_logs/urls.py*:    **learning_logs/urls.py**    ```", "```py    Let’s examine the string `'topics/<int:topic_id>/'` in this URL pattern. The first part of the string tells Django to look for URLs that have the word *topics* after the base URL. The second part of the string, `/<int:topic_id>/`, matches an integer between two forward slashes and assigns the integer value to an argument called `topic_id`.    When Django finds a URL that matches this pattern, it calls the view function `topic()` with the value assigned to `topic_id` as an argument. We’ll use the value of `topic_id` to get the correct topic inside the function.    #### The Topic View    The `topic()` function needs to get the topic and all associated entries from the database, much like what we did earlier in the Django shell:    **views.py**    ```", "```py    This is the first view function that requires a parameter other than the `request` object. The function accepts the value captured by the expression `/<int:topic_id>/` and assigns it to `topic_id` ❶. Then we use `get()` to retrieve the topic, just as we did in the Django shell ❷. Next, we get all of the entries associated with this topic and order them according to `date_added` ❸. The minus sign in front of `date_added` sorts the results in reverse order, which will display the most recent entries first. We store the topic and entries in the `context` dictionary ❹ and call `render()` with the `request` object, the *topic.html* template, and the `context` dictionary ❺.    #### The Topic Template    The template needs to display the name of the topic and the entries. We also need to inform the user if no entries have been made yet for this topic.    **topic.html**    ```", "```py    We extend *base.html*, as we’ll do for all pages in the project. Next, we show the `text` attribute of the topic that’s been requested ❶. The variable `topic` is available because it’s included in the `context` dictionary. We then start a bulleted list ❷ to show each of the entries and loop through them ❸, as we did with the topics earlier.    Each bullet lists two pieces of information: the timestamp and the full text of each entry. For the timestamp ❹, we display the value of the attribute `date_added`. In Django templates, a vertical line (`|`) represents a template *filter*—a function that modifies the value in a template variable during the rendering process. The filter `date:'M d, Y H:i'` displays timestamps in the format *January 1, 2022 23:00*. The next line displays the value of the current entry’s `text` attribute. The filter `linebreaks` ❺ ensures that long text entries include line breaks in a format understood by browsers, rather than showing a block of uninterrupted text. We again use the `{% empty %}` template tag ❻ to print a message informing the user that no entries have been made.    #### Links from the Topics Page    Before we look at the topic page in a browser, we need to modify the topics template so each topic links to the appropriate page. Here’s the change you need to make to *topics.html*:    **topics.html**    ```", "```py    We use the URL template tag to generate the proper link, based on the URL pattern in `learning_logs` with the name `'topic'`. This URL pattern requires a `topic_id` argument, so we add the attribute `topic.id` to the URL template tag. Now each topic in the list of topics is a link to a topic page, such as *http://localhost:8000/topics/1/*.    When you refresh the topics page and click a topic, you should see a page that looks like [Figure 18-5](#figure18-5).  ![](Images/f18005.png)    Figure 18-5: The detail page for a single topic, showing all entries for a topic      ## Summary    In this chapter, you learned how to start building a simple web app using the Django framework. You saw a brief project specification, installed Django to a virtual environment, set up a project, and checked that the project was set up correctly. You set up an app and defined models to represent the data for your app. You learned about databases and how Django helps you migrate your database after you make a change to your models. You created a superuser for the admin site, and you used the admin site to enter some initial data.    You also explored the Django shell, which allows you to work with your project’s data in a terminal session. You learned how to define URLs, create view functions, and write templates to make pages for your site. You also used template inheritance to simplify the structure of individual templates and make it easier to modify the site as the project evolves.    In Chapter 19, you’ll make intuitive, user-friendly pages that allow users to add new topics and entries and edit existing entries without going through the admin site. You’ll also add a user registration system, allowing users to create an account and make their own learning log. This is the heart of a web app—the ability to create something that any number of users can interact with.   # 19 User Accounts  ![](Images/chapterart.png)  At the heart of a web application is the ability for any user, anywhere in the world, to register an account with your app and start using it. In this chapter, you’ll build forms so users can add their own topics and entries, and edit existing entries. You’ll also learn how Django guards against common attacks against form-based pages, so you won’t have to spend much time thinking about securing your apps.    You’ll also implement a user authentication system. You’ll build a registration page for users to create accounts, and then restrict access to certain pages to logged-in users only. Then you’ll modify some of the view functions so users can only see their own data. You’ll learn to keep your users’ data safe and secure.    ## Allowing Users to Enter Data    Before we build an authentication system for creating accounts, we’ll first add some pages that allow users to enter their own data. We’ll give users the ability to add a new topic, add a new entry, and edit their previous entries.    Currently, only a superuser can enter data through the admin site. We don’t want users to interact with the admin site, so we’ll use Django’s form-building tools to build pages that allow users to enter data.    ### Adding New Topics    Let’s start by allowing users to add a new topic. Adding a form-based page works in much the same way as adding the pages we’ve already built: we define a URL, write a view function, and write a template. The one significant difference is the addition of a new module called *forms.py*, which will contain the forms.    #### The Topic ModelForm    Any page that lets a user enter and submit information on a web page involves an HTML element called a *form*. When users enter information, we need to *validate* that the information provided is the right kind of data and is not malicious, such as code designed to interrupt our server. We then need to process and save valid information to the appropriate place in the database. Django automates much of this work.    The simplest way to build a form in Django is to use a `ModelForm`, which uses the information from the models we defined in Chapter 18 to build a form automatically. Write your first form in the file *forms.py*, which should be created in the same directory as *models.py*:    **forms.py**    ```", "```py    We first import the `forms` module and the model we’ll work with, `Topic`. We then define a class called `TopicForm`, which inherits from `forms.ModelForm` ❶.    The simplest version of a `ModelForm` consists of a nested `Meta` class telling Django which model to base the form on and which fields to include in the form. Here we specify that the form should be based on the `Topic` model ❷, and that it should only include the `text` field ❸. The empty string in the labels dictionary tells Django not to generate a label for the `text` field ❹.    #### The new_topic URL    The URL for a new page should be short and descriptive. When the user wants to add a new topic, we’ll send them to *http://localhost:8000/new_topic/*. Here’s the URL pattern for the `new_topic` page; add this to *learning_logs/urls.py*:    **learning_logs/urls.py**    ```", "```py    This URL pattern sends requests to the view function `new_topic()`, which we’ll write next.    #### The new_topic() View Function    The `new_topic()` function needs to handle two different situations: initial requests for the `new_topic` page, in which case it should show a blank form; and the processing of any data submitted in the form. After data from a submitted form is processed, it needs to redirect the user back to the `topics` page:    **views.py**    ```", "```py    We import the function `redirect`, which we’ll use to redirect the user back to the `topics` page after they submit their topic. We also import the form we just wrote, `TopicForm`.    #### GET and POST Requests    The two main types of requests you’ll use when building apps are GET and POST. You use *GET* requests for pages that only read data from the server. You usually use *POST* requests when the user needs to submit information through a form. We’ll be specifying the POST method for processing all of our forms. (A few other kinds of requests exist, but we won’t use them in this project.)    The `new_topic()` function takes in the `request` object as a parameter. When the user initially requests this page, their browser will send a GET request. Once the user has filled out and submitted the form, their browser will submit a POST request. Depending on the request, we’ll know whether the user is requesting a blank form (GET) or asking us to process a completed form (POST).    We use an `if` test to determine whether the request method is GET or POST ❶. If the request method isn’t POST, the request is probably GET, so we need to return a blank form. (If it’s another kind of request, it’s still safe to return a blank form.) We make an instance of `TopicForm` ❷, assign it to the variable `form`, and send the form to the template in the `context` dictionary ❼. Because we included no arguments when instantiating `TopicForm`, Django creates a blank form that the user can fill out.    If the request method is POST, the `else` block runs and processes the data submitted in the form. We make an instance of `TopicForm` ❸ and pass it the data entered by the user, which is assigned to `request.POST`. The `form` object that’s returned contains the information submitted by the user.    We can’t save the submitted information in the database until we’ve checked that it’s valid ❹. The `is_valid()` method checks that all required fields have been filled in (all fields in a form are required by default) and that the data entered matches the field types expected—for example, that the length of `text` is less than 200 characters, as we specified in *models.py* in Chapter 18. This automatic validation saves us a lot of work. If everything is valid, we can call `save()` ❺, which writes the data from the form to the database.    Once we’ve saved the data, we can leave this page. The `redirect()` function takes in the name of a view and redirects the user to the page associated with that view. Here we use `redirect()` to redirect the user’s browser to the `topics` page ❻, where the user should see the topic they just entered in the list of topics.    The `context` variable is defined at the end of the view function, and the page is rendered using the template *new_topic.html*, which we’ll create next. This code is placed outside of any `if` block; it will run if a blank form was created, and it will run if a submitted form is determined to be invalid. An invalid form will include some default error messages to help the user submit acceptable data.    #### The new_topic Template    Now we’ll make a new template called *new_topic.html* to display the form we just created:    **new_topic.html**    ```", "```py    This template extends *base.html*, so it has the same base structure as the rest of the pages in Learning Log. We use the `<form></form>` tags to define an HTML form ❶. The `action` argument tells the browser where to send the data submitted in the form; in this case, we send it back to the view function `new_topic()`. The `method` argument tells the browser to submit the data as a POST request.    Django uses the template tag `{% csrf_token %}` ❷ to prevent attackers from using the form to gain unauthorized access to the server. (This kind of attack is called a *cross-site request forgery*.) Next, we display the form; here you can see how simple Django can make certain tasks, such as displaying a form. We only need to include the template variable `{{ form.as_div }}` for Django to create all the fields necessary to display the form automatically ❸. The `as_div` modifier tells Django to render all the form elements as HTML `<div></div>` elements; this is a simple way to display the form neatly.    Django doesn’t create a submit button for forms, so we define one before closing the form ❹.    #### Linking to the new_topic Page    Next, we include a link to the `new_topic` page on the `topics` page:    **topics.html**    ```", "```py    Place the link after the list of existing topics. [Figure 19-1](#figure19-1) shows the resulting form; try using the form to add a few new topics of your own.  ![](Images/f19001.png)    Figure 19-1: The page for adding a new topic      ### Adding New Entries    Now that the user can add a new topic, they’ll want to add new entries too. We’ll again define a URL, write a view function and a template, and link to the page. But first, we’ll add another class to *forms.py*.    #### The Entry ModelForm    We need to create a form associated with the `Entry` model, but this time, with a bit more customization than `TopicForm`:    **forms.py**    ```", "```py    We update the `import` statement to include `Entry` as well as `Topic`. We make a new class called `EntryForm` that inherits from `forms.ModelForm`. The `EntryForm` class has a nested `Meta` class listing the model it’s based on, and the field to include in the form. We again give the field `'text'` a blank label ❶.    For `EntryForm`, we include the `widgets` attribute ❷. A *widget* is an HTML form element, such as a single-line text box, multiline text area, or drop-down list. By including the `widgets` attribute, you can override Django’s default widget choices. Here we’re telling Django to use a `forms.Textarea` element with a width of 80 columns, instead of the default 40 columns. This gives users enough room to write a meaningful entry.    #### The new_entry URL    New entries must be associated with a particular topic, so we need to include a `topic_id` argument in the URL for adding a new entry. Here’s the URL, which you add to *learning_logs/urls.py*:    **learning_logs/urls.py**    ```", "```py    This URL pattern matches any URL with the form *http://localhost:8000/new_entry/id/*, where `id` is a number matching the topic ID. The code `<int:topic_id>` captures a numerical value and assigns it to the variable `topic_id`. When a URL matching this pattern is requested, Django sends the request and the topic’s ID to the `new_entry()` view function.    #### The new_entry() View Function    The view function for `new_entry` is much like the function for adding a new topic. Add the following code to your *views.py* file:    **views.py**    ```", "```py    We update the `import` statement to include the `EntryForm` we just made. The definition of `new_entry()` has a `topic_id` parameter to store the value it receives from the URL. We’ll need the topic to render the page and process the form’s data, so we use `topic_id` to get the correct topic object ❶.    Next, we check whether the request method is POST or GET ❷. The `if` block executes if it’s a GET request, and we create a blank instance of `EntryForm` ❸.    If the request method is POST, we process the data by making an instance of `EntryForm`, populated with the POST data from the `request` object ❹. We then check whether the form is valid. If it is, we need to set the entry object’s `topic` attribute before saving it to the database. When we call `save()`, we include the argument `commit=False` ❺ to tell Django to create a new entry object and assign it to `new_entry`, without saving it to the database yet. We set the `topic` attribute of `new_entry` to the topic we pulled from the database at the beginning of the function ❻. Then we call `save()` with no arguments, saving the entry to the database with the correct associated topic.    The `redirect()` call requires two arguments: the name of the view we want to redirect to and the argument that view function requires ❼. Here, we’re redirecting to `topic()`, which needs the argument `topic_id`. This view then renders the topic page that the user made an entry for, and they should see their new entry in the list of entries.    At the end of the function, we create a `context` dictionary and render the page using the *new_entry.html* template. This code will execute for a blank form, or for a form that’s been submitted but turns out to be invalid.    #### The new_entry Template    As you can see in the following code, the template for `new_entry` is similar to the template for `new_topic`:    **new_entry.html**    ```", "```py    We show the topic at the top of the page ❶, so the user can see which topic they’re adding an entry to. The topic also acts as a link back to the main page for that topic.    The form’s `action` argument includes the `topic.id` value in the URL, so the view function can associate the new entry with the correct topic ❷. Other than that, this template looks just like *new_topic.html*.    #### Linking to the new_entry Page    Next, we need to include a link to the `new_entry` page from each topic page, in the topic template:    **topic.html**    ```", "```py    We place the link to add entries just before showing the entries, because adding a new entry will be the most common action on this page. [Figure 19-2](#figure19-2) shows the `new_entry` page. Now users can add new topics and as many entries as they want for each topic. Try out the `new_entry` page by adding a few entries to some of the topics you’ve created.  ![](Images/f19002.png)    Figure 19-2: The `new_entry` page      ### Editing Entries    Now we’ll make a page so users can edit the entries they’ve added.    #### The edit_entry URL    The URL for the page needs to pass the ID of the entry to be edited. Here’s *learning_logs/urls.py*:    **urls.py**    ```", "```py    This URL pattern matches URLs like *http://localhost:8000/edit_entry/id/*. Here the value of `id` is assigned to the parameter `entry_id`. Django sends requests that match this format to the view function `edit_entry()`.    #### The edit_entry() View Function    When the `edit_entry` page receives a GET request, the `edit_entry()` function returns a form for editing the entry. When the page receives a POST request with revised entry text, it saves the modified text into the database:    **views.py**    ```", "```py    We first import the `Entry` model. We then get the entry object that the user wants to edit ❶ and the topic associated with this entry. In the `if` block, which runs for a GET request, we make an instance of `EntryForm` with the argument `instance=entry` ❷. This argument tells Django to create the form, prefilled with information from the existing entry object. The user will see their existing data and be able to edit that data.    When processing a POST request, we pass both the `instance=entry` and the `data=request.POST` arguments ❸. These arguments tell Django to create a form instance based on the information associated with the existing entry object, updated with any relevant data from `request.POST`. We then check whether the form is valid; if it is, we call `save()` with no arguments because the entry is already associated with the correct topic ❹. We then redirect to the `topic` page, where the user should see the updated version of the entry they edited ❺.    If we’re showing an initial form for editing the entry or if the submitted form is invalid, we create the `context` dictionary and render the page using the *edit_entry.html* template.    #### The edit_entry Template    Next, we create an *edit_entry.html* template, which is similar to *new_entry.html*:    **edit_entry.html**    ```", "```py    The `action` argument sends the form back to the `edit_entry()` function for processing ❶. We include the `entry.id` as an argument in the `{% url %}` tag, so the view function can modify the correct entry object. We label the submit button as `Save changes` to remind the user they’re saving edits, not creating a new entry ❷.    #### Linking to the edit_entry Page    Now we need to include a link to the `edit_entry` page for each entry on the topic page:    **topic.html**    ```", "```py    We include the edit link after each entry’s date and text has been displayed. We use the `{% url %}` template tag to determine the URL for the named URL pattern `edit_entry`, along with the ID attribute of the current entry in the loop (`entry.id`). The link text `Edit entry` appears after each entry on the page. [Figure 19-3](#figure19-3) shows what the topic page looks like with these links.  ![](Images/f19003.png)    Figure 19-3: Each entry now has a link for editing that entry.      Learning Log now has most of the functionality it needs. Users can add topics and entries, and they can read through any set of entries they want. In the next section, we’ll implement a user registration system so anyone can make an account with Learning Log and create their own set of topics and entries.    ## Setting Up User Accounts    In this section, we’ll set up a user registration and authorization system so people can register an account, log in, and log out. We’ll create a new app to contain all the functionality related to working with users. We’ll use the default user authentication system included with Django to do as much of the work as possible. We’ll also modify the `Topic` model slightly so every topic belongs to a certain user.    ### The accounts App    We’ll start by creating a new app called `accounts`, using the `startapp` command:    ```", "```py    The default authentication system is built around the concept of user accounts, so using the name `accounts` makes integration with the default system easier. The `startapp` command shown here makes a new directory called *accounts* ❶ with a structure identical to the `learning_logs` app ❷.    #### Adding accounts to settings.py    We need to add our new app to `INSTALLED_APPS` in *settings.py*, like so:    **settings.py**    ```", "```py    Now Django will include the `accounts` app in the overall project.    #### Including the URLs from accounts    Next, we need to modify the root *urls.py* so it includes the URLs we’ll write for the `accounts` app:    **ll_project/urls.py**    ```", "```py    We add a line to include the file *urls.py* from `accounts`. This line will match any URL that starts with the word *accounts*, such as *http://localhost:8000/accounts/login/*.    ### The Login Page    We’ll first implement a login page. We’ll use the default `login` view Django provides, so the URL pattern for this app looks a little different. Make a new *urls.py* file in the directory *ll_project/accounts/* and add the following to it:    **accounts/urls.py**    ```", "```py    We import the `path` function, and then import the `include` function so we can include some default authentication URLs that Django has defined. These default URLs include named URL patterns, such as `'login'` and `'logout'`. We set the variable `app_name` to `'accounts'` so Django can distinguish these URLs from URLs belonging to other apps. Even default URLs provided by Django, when included in the `accounts` app’s *urls.py* file, will be accessible through the `accounts` namespace.    The login page’s pattern matches the URL *http://localhost:8000/accounts/login/*. When Django reads this URL, the word *accounts* tells Django to look in *accounts/urls.py*, and *login* tells it to send requests to Django’s default `login` view.    #### The login Template    When the user requests the login page, Django will use a default view function, but we still need to provide a template for the page. The default authentication views look for templates inside a folder called *registration*, so we’ll need to make that folder. Inside the *ll_project/accounts/* directory, make a directory called *templates*; inside that, make another directory called *registration*. Here’s the *login.html* template, which should be saved in *ll_project/accounts/templates/registration*:    **login.html**    ```", "```py    This template extends *base.html* to ensure that the login page will have the same look and feel as the rest of the site. Note that a template in one app can inherit from a template in another app.    If the form’s `errors` attribute is set, we display an error message ❶, reporting that the username and password combination doesn’t match anything stored in the database.    We want the login view to process the form, so we set the `action` argument as the URL of the login page ❷. The login view sends a `form` object to the template, and it’s up to us to display the form ❸ and add a submit button ❹.    #### The LOGIN_REDIRECT_URL Settting    Once a user logs in successfully, Django needs to know where to send that user. We control this in the settings file.    Add the following code to the end of *settings.py*:    **settings.py**    ```", "```py    With all the default settings in *settings.py*, it’s helpful to mark off the section where we’re adding new settings. The first new setting we’ll add is `LOGIN_REDIRECT_URL`, which tells Django which URL to redirect to after a successful login attempt.    #### Linking to the Login Page    Let’s add the login link to *base.html* so it appears on every page. We don’t want the link to display when the user is already logged in, so we nest it inside an `{% if %}` tag:    **base.html**    ```", "```py    In Django’s authentication system, every template has a `user` object available that always has an `is_authenticated` attribute set: the attribute is `True` if the user is logged in and `False` if they aren’t. This attribute allows you to display one message to authenticated users and another to unauthenticated users.    Here we display a greeting to users currently logged in ❶. Authenticated users have an additional `username` attribute set, which we use to personalize the greeting and remind the user they’re logged in ❷. For users who haven’t been authenticated, we display a link to the login page ❸.    #### Using the Login Page    We’ve already set up a user account, so let’s log in to see if the page works. Go to *http://localhost:8000/admin/*. If you’re still logged in as an admin, look for a **logout** link in the header and click it.    When you’re logged out, go to *http://localhost:8000/accounts/login/*. You should see a login page similar to the one shown in [Figure 19-4](#figure19-4). Enter the username and password you set up earlier, and you should be brought back to the home page. The header on the home page should display a greeting personalized with your username.  ![](Images/f19004.png)    Figure 19-4: The login page      ### Logging Out    Now we need to provide a way for users to log out. Logout requests should be submitted as POST requests, so we’ll add a small logout form to *base.html*. When users click the logout button, they’ll go to a page confirming that they’ve been logged out.    #### Adding a Logout Form to base.html    We’ll add the form for logging out to *base.html* so it’s available on every page. We’ll include it in another `if` block, so only users who are already logged in can see it:    **base.html**    ```", "```py    The default URL pattern for logging out is `'accounts/logout/'`. However, the request has to be sent as a POST request; otherwise, attackers can easily force logout requests. To make the logout request use POST, we define a simple form.    We place the form at the bottom of the page, below a horizontal rule element (`<hr />`) ❶. This is an easy way to always keep the logout button in a consistent position below any other content on the page. The form itself has the logout URL as its `action` argument, and `'post'` as the request method ❷. Every form in Django needs to include the `{% csrf_token %}`, even a simple form like this one. This form is empty except for the submit button.    #### The LOGOUT_REDIRECT_URL Setting    When the user clicks the logout button, Django needs to know where to send them. We control this behavior in *settings.py*:    **settings.py**    ```", "```py    The `LOGOUT_REDIRECT_URL` setting shown here tells Django to redirect logged-out users back to the home page. This is a simple way to confirm that they were logged out, because they should no longer see their username after logging out.    ### The Registration Page    Next, we’ll build a page so new users can register. We’ll use Django’s default `UserCreationForm`, but write our own view function and template.    #### The register URL    The following code provides the URL pattern for the registration page, which should be placed in *accounts/urls.py*:    **accounts/urls.py**    ```", "```py    We import the `views` module from `accounts`, which we need because we’re writing our own view for the registration page. The pattern for the registration page matches the URL *http://localhost:8000/accounts/register/* and sends requests to the `register()` function we’re about to write.    #### The register() View Function    The `register()` view function needs to display a blank registration form when the registration page is first requested, and then process completed registration forms when they’re submitted. When a registration is successful, the function also needs to log the new user in. Add the following code to *accounts/views.py*:    **accounts/views.py**    ```", "```py    We import the `render()` and `redirect()` functions, and then we import the `login()` function to log the user in if their registration information is correct. We also import the default `UserCreationForm`. In the `register()` function, we check whether we’re responding to a POST request. If we’re not, we make an instance of `UserCreationForm` with no initial data ❶.    If we’re responding to a POST request, we make an instance of `UserCreationForm` based on the submitted data ❷. We check that the data is valid ❸—in this case, that the username has the appropriate characters, the passwords match, and the user isn’t trying to do anything malicious in their submission.    If the submitted data is valid, we call the form’s `save()` method to save the username and the hash of the password to the database ❹. The `save()` method returns the newly created user object, which we assign to `new_user`. When the user’s information is saved, we log them in by calling the `login()` function with the `request` and `new_user` objects ❺, which creates a valid session for the new user. Finally, we redirect the user to the home page ❻, where a personalized greeting in the header tells them their registration was successful.    At the end of the function, we render the page, which will be either a blank form or a submitted form that’s invalid.    #### The register Template    Now create a template for the registration page, which will be similar to the login page. Be sure to save it in the same directory as *login.html*:    **register.html**    ```", "```py    This should look like the other form-based templates we’ve been writing. We use the `as_div` method again so Django will display all the fields in the form appropriately, including any error messages if the form isn’t filled out correctly.    #### Linking to the Registration Page    Next, we’ll add code to show the registration page link to any user who isn’t currently logged in:    **base.html**    ```", "```py    Now users who are logged in see a personalized greeting and a logout button. Users who aren’t logged in see a registration link and a login link. Try out the registration page by making several user accounts with different usernames.    In the next section, we’ll restrict some of the pages so they’re available only to registered users, and we’ll make sure every topic belongs to a specific user.    ## Allowing Users to Own Their Data    Users should be able to enter private data in their learning logs, so we’ll create a system to figure out which data belongs to which user. Then we’ll restrict access to certain pages so users can only work with their own data.    We’ll modify the `Topic` model so every topic belongs to a specific user. This will also take care of entries, because every entry belongs to a specific topic. We’ll start by restricting access to certain pages.    ### Restricting Access with @login_required    Django makes it easy to restrict access to certain pages through the `@login_required` decorator. Recall from Chapter 11 that a *decorator* is a directive placed just before a function definition, which modifies how the function behaves. Let’s look at an example.    #### Restricting Access to the Topics Page    Each topic will be owned by a user, so only registered users can request the topics page. Add the following code to *learning_logs/views.py*:    **learning_logs/views.py**    ```", "```py    We first import the `login_required()` function. We apply `login_required()` as a decorator to the `topics()` view function by prepending `login_required` with the `@` symbol. As a result, Python knows to run the code in `login_required()` before the code in `topics()`.    The code in `login_required()` checks whether a user is logged in, and Django runs the code in `topics()` only if they are. If the user isn’t logged in, they’re redirected to the login page.    To make this redirect work, we need to modify *settings.py* so Django knows where to find the login page. Add the following at the end of *settings.py*:    **settings.py**    ```", "```py    Now when an unauthenticated user requests a page protected by the `@login_required` decorator, Django will send the user to the URL defined by `LOGIN_URL` in *settings.py*.    You can test this setting by logging out of any user accounts and going to the home page. Click the **Topics** link, which should redirect you to the login page. Then log in to any of your accounts, and from the home page, click the **Topics** link again. You should be able to access the topics page.    #### Restricting Access Throughout Learning Log    Django makes it easy to restrict access to pages, but you have to decide which pages to protect. It’s best to think about which pages need to be unrestricted first, and then restrict all the other pages in the project. You can easily correct over-restricted access, and it’s less dangerous than leaving sensitive pages unrestricted.    In Learning Log, we’ll keep the home page and the registration page unrestricted. We’ll restrict access to every other page.    Here’s *learning_logs/views.py* with `@login_required` decorators applied to every view except `index()`:    **learning_logs/views.py**    ```", "```py    Try accessing each of these pages while logged out; you should be redirected back to the login page. You’ll also be unable to click links to pages such as `new_topic`. But if you enter the URL *http://localhost:8000/new_topic/*, you’ll be redirected to the login page. You should restrict access to any URL that’s publicly accessible and relates to private user data.    ### Connecting Data to Certain Users    Next, we need to connect the data to the user who submitted it. We only need to connect the data highest in the hierarchy to a user, and the lower-level data will follow. In Learning Log, topics are the highest level of data in the app, and all entries are connected to a topic. As long as each topic belongs to a specific user, we can trace the ownership of each entry in the database.    We’ll modify the `Topic` model by adding a foreign key relationship to a user. We’ll then have to migrate the database. Finally, we’ll modify some of the views so they only show the data associated with the currently logged-in user.    #### Modifying the Topic Model    The modification to *models.py* is just two lines:    **models.py**    ```", "```py    We import the `User` model from `django.contrib.auth`. Then we add an `owner` field to `Topic`, which establishes a foreign key relationship to the `User` model. If a user is deleted, all the topics associated with that user will be deleted as well.    #### Identifying Existing Users    When we migrate the database, Django will modify the database so it can store a connection between each topic and a user. To make the migration, Django needs to know which user to associate with each existing topic. The simplest approach is to start by assigning all existing topics to one user—for example, the superuser. But first, we need to know that user’s ID.    Let’s look at the IDs of all users created so far. Start a Django shell session and issue the following commands:    ```", "```py    We first import the `User` model into the shell session ❶. We then look at all the users that have been created so far ❷. The output shows three users for my version of the project: `ll_admin`, `eric`, and `willie`.    Next, we loop through the list of users and print each user’s username and ID ❸. When Django asks which user to associate the existing topics with, we’ll use one of these ID values.    #### Migrating the Database    Now that we know the IDs, we can migrate the database. When we do this, Python will ask us to connect the `Topic` model to a particular owner temporarily or to add a default to our *models.py* file to tell it what to do. Choose option **1**:    ```", "```py    We start by issuing the `makemigrations` command ❶. In the output, Django indicates that we’re trying to add a required (*non-nullable*) field to an existing model (`topic`) with no default value specified ❷. Django gives us two options: we can provide a default right now, or we can quit and add a default value in *models.py* ❸. Here I’ve chosen the first option ❹. Django then asks us to enter the default value ❺.    To associate all existing topics with the original admin user, `ll_admin`, I entered the user ID of `1` ❻. You can use the ID of any user you’ve created; it doesn’t have to be a superuser. Django then migrates the database using this value and generates the migration file *0003_topic_owner.py*, which adds the field `owner` to the `Topic` model.    Now we can execute the migration. Enter the following in an active virtual environment:    ```", "```py    Django applies the new migration, and the result is `OK` ❶.    We can verify that the migration worked as expected in a shell session, like this:    ```", "```py    We import `Topic` from `learning_logs.models` and then loop through all existing topics, printing each topic and the user it belongs to. You can see that each topic now belongs to the user `ll_admin`. (If you get an error when you run this code, try exiting the shell and starting a new shell.)    ### Restricting Topics Access to Appropriate Users    Currently, if you’re logged in, you’ll be able to see all the topics, no matter which user you’re logged in as. We’ll change that by showing users only the topics that belong to them.    Make the following change to the `topics()` function in *views.py*:    **learning_logs/views.py**    ```", "```py    When a user is logged in, the `request` object has a `request.user` attribute set, which contains information about the user. The query `Topic.objects.filter(owner=request.user)` tells Django to retrieve only the `Topic` objects from the database whose `owner` attribute matches the current user. Because we’re not changing how the topics are displayed, we don’t need to change the template for the topics page at all.    To see if this works, log in as the user you connected all existing topics to, and go to the topics page. You should see all the topics. Now log out and log back in as a different user. You should see the message “No topics have been added yet.”    ### Protecting a User’s Topics    We haven’t restricted access to the topic pages yet, so any registered user could try a bunch of URLs (like *http://localhost:8000/topics/1/*) and retrieve topic pages that happen to match.    Try it yourself. While logged in as the user that owns all topics, copy the URL or note the ID in the URL of a topic, and then log out and log back in as a different user. Enter that topic’s URL. You should be able to read the entries, even though you’re logged in as a different user.    We’ll fix this now by performing a check before retrieving the requested entries in the `topic()` view function:    **learning_logs/views.py**    ```", "```py    A 404 response is a standard error response that’s returned when a requested resource doesn’t exist on a server. Here we import the `Http404` exception ❶, which we’ll raise if the user requests a topic they shouldn’t have access to. After receiving a topic request, we make sure the topic’s user matches the currently logged-in user before rendering the page. If the requested topic’s owner is not the same as the current user, we raise the `Http404` exception ❷, and Django returns a 404-error page.    Now if you try to view another user’s topic entries, you’ll see a “Page Not Found” message from Django. In Chapter 20, we’ll configure the project so users will see a proper error page instead of a debugging page.    ### Protecting the edit_entry Page    The `edit_entry` pages have URLs of the form *http://localhost:8000/edit_entry/entry_id/*, where the `entry_id` is a number. Let’s protect this page so no one can use the URL to gain access to someone else’s entries:    **learning_logs/views.py**    ```", "```py    We retrieve the entry and the topic associated with this entry. We then check whether the owner of the topic matches the currently logged-in user; if they don’t match, we raise an `Http404` exception.    ### Associating New Topics with the Current User    Currently, the page for adding new topics is broken because it doesn’t associate new topics with any particular user. If you try adding a new topic, you’ll see the message `IntegrityError` along with `NOT NULL constraint failed: learning_logs_topic.owner_id`. Django is saying you can’t create a new topic without specifying a value for the topic’s `owner` field.    There’s a straightforward fix for this problem, because we have access to the current user through the `request` object. Add the following code, which associates the new topic with the current user:    **learning_logs/views.py**    ```", "```py    When we first call `form.save()`, we pass the `commit=False` argument because we need to modify the new topic before saving it to the database ❶. We then set the new topic’s `owner` attribute to the current user ❷. Finally, we call `save()` on the topic instance we just defined ❸. Now the topic has all the required data and will save successfully.    You should be able to add as many new topics as you want for as many different users as you want. Each user will only have access to their own data, whether they’re viewing data, entering new data, or modifying old data.    ## Summary    In this chapter, you learned how forms allow users to add new topics and entries, and edit existing entries. You then learned how to implement user accounts. You gave existing users the ability to log in and out, and used Django’s default `UserCreationForm` to let people create new accounts.    After building a simple user authentication and registration system, you restricted access to logged-in users for certain pages using the `@login_required` decorator. You then assigned data to specific users through a foreign key relationship. You also learned to migrate the database when the migration requires you to specify some default data.    Finally, you learned how to make sure a user can only see data that belongs to them by modifying the view functions. You retrieved appropriate data using the `filter()` method, and compared the owner of the requested data to the currently logged-in user.    It might not always be immediately obvious what data you should make available and what data you should protect, but this skill will come with practice. The decisions we’ve made in this chapter to secure our users’ data also illustrate why working with others is a good idea when building a project: having someone else look over your project makes it more likely that you’ll spot vulnerable areas.    You now have a fully functioning project running on your local machine. In the final chapter, you’ll style Learning Log to make it visually appealing, and you’ll deploy the project to a server so anyone with internet access can register and make an account.   # 20 Styling and Deploying an App  ![](Images/chapterart.png)  Learning Log is fully functional now, but it has no styling and runs only on your local machine. In this chapter, you’ll style the project in a simple but professional manner and then deploy it to a live server so anyone in the world can make an account and use it.    For the styling, we’ll use the *Bootstrap* library, a collection of tools for styling web applications so they look professional on all modern devices, from a small phone to a large desktop monitor. To do this, we’ll use the django-bootstrap5 app, which will also give you practice using apps made by other Django developers.    We’ll deploy Learning Log using *Platform.sh*, a site that lets you push your project to one of its servers, making it available to anyone with an internet connection. We’ll also start using a version control system called Git to track changes to the project.    When you’re finished with Learning Log, you’ll be able to develop simple web applications, give them a professional look and feel, and deploy them to a live server. You’ll also be able to use more advanced learning resources as you develop your skills.    ## Styling Learning Log    We’ve purposely ignored styling until now to focus on Learning Log’s functionality first. This is a good way to approach development, because an app is only useful if it works. Once an app is working, its appearance is critical so people will want to use it.    In this section, we’ll install the django-bootstrap5 app and add it to the project. We’ll then use it to style the individual pages in the project, so all the pages have a consistent look and feel.    ### The django-bootstrap5 App    We’ll use django-bootstrap5 to integrate Bootstrap into our project. This app downloads the required Bootstrap files, places them in an appropriate location in your project, and makes the styling directives available in your project’s templates.    To install django-bootstrap5, issue the following command in an active virtual environment:    ```", "```py    Next, we need to add django-bootstrap5 to `INSTALLED_APPS` in *settings.py*:    **settings.py**    ```", "```py    Start a new section called `Third party apps`, for apps created by other developers, and add `'django_bootstrap5'` to this section. Make sure you place this section after `My apps` but before the section containing Django’s default apps.    ### Using Bootstrap to Style Learning Log    Bootstrap is a large collection of styling tools. It also has a number of templates you can apply to your project to create an overall style. It’s much easier to use these templates than to use individual styling tools. To see the templates Bootstrap offers, go to [https://getbootstrap.com](https://getbootstrap.com) and click **Examples**. We’ll use the *Navbar static* template, which provides a simple top navigation bar and a container for the page’s content.    [Figure 20-1](#figure20-1) shows what the home page will look like after we apply Bootstrap’s template to *base.html* and modify *index.html* slightly.  ![](Images/f20001.png)    Figure 20-1: The Learning Log home page using Bootstrap      ### Modifying base.html    We need to rewrite *base.html* using the Bootstrap template. We’ll develop the new *base.html* in sections. This is a large file; you may want to copy this file from the online resources, available at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e). If you do copy the file, you should still read through the following section to understand the changes that were made.    #### Defining the HTML Headers    The first change we’ll make to *base.html* defines the HTML headers in the file. We’ll also add some requirements for using Bootstrap in our templates, and give the page a title. Delete everything in *base.html* and replace it with the following code:    **base.html**    ```", "```py    We first declare this file as an HTML document ❶ written in English ❷. An HTML file is divided into two main parts: the *head* and the *body*. The head of the file begins with an opening `<head>` tag ❸. The head of an HTML file doesn’t hold any of the page’s content; it just tells the browser what it needs to know to display the page correctly. We include a `<title>` element for the page, which will display in the browser’s title bar whenever Learning Log is open ❹.    Before closing the head section, we load the collection of template tags available in django-bootstrap5 ❺. The template tag `{% bootstrap_css %}` is a custom tag from django-bootstrap5; it loads all of the CSS files required to implement Bootstrap styles. The tag that follows enables all the interactive behavior you might use on a page, such as collapsible navigation bars. The closing `</head>` tag appears on the last line.    All Bootstrap styling options are now available in any template that inherits from *base.html*. If you want to use custom template tags from django-bootstrap5, each template will need to include the `{% load django_bootstrap5 %}` tag.    #### Defining the Navigation Bar    The code that defines the navigation bar at the top of the page is fairly long, because it has to work equally well on narrow phone screens and wide desktop monitors. We’ll work through the navigation bar in sections.    Here’s the first part of the navigation bar:    **base.html**    ```", "```py    The first new element is the opening `<body>` tag. The *body* of an HTML file contains the content users will see on a page. Next we have a `<nav>` element, which opens the code for the navigation bar at the top of the page ❶. Everything contained in this element is styled according to the Bootstrap style rules defined by the selectors `navbar`, `navbar-expand-md`, and the rest that you see here. A *selector* determines which elements on a page a certain style rule applies to. The `navbar-light` and `bg-light` selectors style the navigation bar with a light-themed background. The `mb` in `mb-4` is short for *margin-bottom*; this selector ensures that a little space appears between the navigation bar and the rest of the page. The `border` selector provides a thin border around the light background to set it off a little from the rest of the page.    The `<div>` tag on the next line opens a resizable container that will hold the overall navigation bar. The term *div* is short for *division*; you build a web page by dividing it into sections and defining style and behavior rules that apply to that section. Any styling or behavior rules that are defined in an opening `<div>` tag affect everything you see until its corresponding closing tag, written as `</div>`.    Next we set the project’s name, `Learning Log`, to appear as the first element on the navigation bar ❷. This will also serve as a link to the home page, just as it’s been doing in the minimally styled version of the project we built in the previous two chapters. The `navbar-brand` selector styles this link so it stands out from the rest of the links and helps add some branding to the site.    The Bootstrap template then defines a button that appears if the browser window is too narrow to display the whole navigation bar horizontally ❸. When the user clicks the button, the navigation elements appear in a drop-down list. The `collapse` reference causes the navigation bar to collapse when the user shrinks the browser window or when the site is displayed on devices with small screens.    Next, we open a new section (`<div>`) of the navigation bar ❹. This is the part of the navigation bar that can collapse depending on the size of the browser window.    Bootstrap defines navigation elements as items in an unordered list ❺, with style rules that make it look nothing like a list. Every link or element you need on the bar can be included as an item in an unordered list ❻. Here, the only item in the list is our link to the topics page ❼. Notice the closing `</li>` tag at the end of the link; every opening tag needs a corresponding closing tag.    The rest of the lines shown here close out all of the tags that have been opened. In HTML, a comment is written like this:    ```", "```py    Closing tags don’t usually have comments, but if you’re new to HTML, it can be really helpful to label some of your closing tags. A single missing tag or an extra tag can throw off the layout of an entire page. We include the `content` block ❽ and the closing `</body>` and `</html>` tags as well.    We’re not finished with the navigation bar, but we now have a complete HTML document. If `runserver` is currently active, stop the current server and restart it. Go to the project’s home page, and you should see a navigation bar that has some of the elements shown in [Figure 20-1](#figure20-1). Now let’s add the rest of the elements to the navigation bar.    #### Adding User Account Links    We still need to add the links associated with user accounts. We’ll start by adding all of the account-related links except the logout form.    Make the following changes to *base.html*:    **base.html**    ```", "```py    We begin a new set of links by using another opening `<ul>` tag ❶. You can have as many groups of links as you need on a page. The selector `ms-auto` is short for *margin-start-automatic*: this selector examines the other elements in the navigation bar and works out a left (start) margin that pushes this group of links to the right side of the browser window.    The `if` block is the same conditional block we used earlier to display appropriate messages to users, depending on whether they’re logged in ❷. The block is a little longer now because there are some styling rules inside the conditional tags. The greeting for authenticated users is wrapped in a `<span>` element ❸. A *span element* styles pieces of text or elements of a page that are part of a longer line. While div elements create their own divisions in a page, span elements are continuous within a larger section. This can be confusing at first, because many pages have deeply nested div elements. Here, we’re using the span element to style informational text on the navigation bar: in this case, the logged-in user’s name.    In the `else` block, which runs for unauthenticated users, we include the links for registering a new account and logging in ❹. These should look just like the link to the topics page.    If you wanted to add more links to the navigation bar, you’d add another `<li>` item to one of the `<ul>` groups that we’ve defined, using styling directives like the ones you’ve seen here.    Now let’s add the logout form to the navigation bar.    #### Adding the Logout Form to the Navigation Bar    When we first wrote the logout form, we added it to the bottom of *base.html*. Now let’s put it in a better place, in the navigation bar:    **base.html**    ```", "```py    The logout form should be placed after the set of account-related links, but inside the collapsible section of the navigation bar. The only change in the form is the addition of a number of Bootstrap styling classes in the `<button>` element, which apply Bootstrap styling elements to the logout button ❶.    Reload the home page, and you should be able to log in and out using any of the accounts you’ve created.    There’s still a bit more we need to add to *base.html*. We need to define two blocks that the individual pages can use to place the content specific to those pages.    #### Defining the Main Part of the Page    The rest of *base.html* contains the main part of the page:    **base.html**    ```", "```py    We first open a `<main>` tag ❶. The *main* element is used for the most significant part of the body of a page. Here we assign the bootstrap selector `container`, which is a simple way to group elements on a page. We’ll place two div elements in this container.    The first div element contains a `page_header` block ❷. We’ll use this block to title most pages. To make this section stand out from the rest of the page, we place some padding below the header. *Padding* refers to space between an element’s content and its border. The selector `pb-2` is a bootstrap directive that provides a moderate amount of padding at the bottom of the styled element. A *margin* is the space between an element’s border and other elements on the page. The selector `mb-2` provides a moderate amount of margin at the bottom of this div. We want a border on the bottom of this block, so we use the selector `border-bottom`, which provides a thin border at the bottom of the `page_header` block.    We then define one more div element that contains the block `content` ❸. We don’t apply any specific style to this block, so we can style the content of any page as we see fit for that page. The end of the *base.html* file has closing tags for the `main`, `body`, and `html` elements.    When you load Learning Log’s home page in a browser, you should see a professional-looking navigation bar that matches the one shown in [Figure 20-1](#figure20-1). Try resizing the window so it’s really narrow; a button should replace the navigation bar. Click the button, and all the links should appear in a drop-down list.    ### Styling the Home Page Using a Jumbotron    To update the home page, we’ll use a Bootstrap element called a *jumbotron*, a large box that stands out from the rest of the page. Typically, it’s used on home pages to hold a brief description of the overall project and a call to action that invites the viewer to get involved.    Here’s the revised *index.html* file:    **index.html**    ```", "```py    We first tell Django that we’re about to define what goes in the `page_header` block ❶. A jumbotron is implemented as a pair of div elements with a set of styling directives applied to them ❷. The outer div has padding and margin settings, a light background color, and rounded corners. The inner div is a container that changes along with the window size and has some padding as well. The `py-4` selector adds padding to the top and bottom of the div element. Feel free to adjust the numbers in these settings and see how the home page changes.    Inside the jumbotron are three elements. The first is a short message, `Track your learning`, that gives new visitors a sense of what Learning Log does ❸. The `<h1>` element is a first-level header, and the `display-3` selector adds a thinner and taller look to this particular header. We also include a longer message that provides more information about what the user can do with their learning log ❹. This is formatted as a `lead` paragraph, which is meant to stand out from regular paragraphs.    Rather than just using a text link, we create a button that invites users to register an account on Learning Log ❺. This is the same link as in the header, but the button stands out on the page and shows the viewer what they need to do in order to start using the project. The selectors you see here style this as a large button that represents a call to action. The code `&raquo;` is an *HTML entity* that looks like two right angle brackets combined (>>). Finally, we provide closing div tags and close the `page_header` block. With only two div elements in this file, it’s not particularly helpful to label the closing div tags. We aren’t adding anything else to this page, so we don’t need to define the `content` block in this template.    The home page now looks like [Figure 20-1](#figure20-1). This is a significant improvement over the unstyled version of the project!    ### Styling the Login Page    We’ve refined the overall appearance of the login page, but the login form itself doesn’t have any styling yet. Let’s make the form look consistent with the rest of the page by modifying *login.html*:    **login.html**    ```", "```py    We first load the `bootstrap5` template tags into this template ❶. We then define the `page_header` block, which tells the user what the page is for ❷. Notice that we’ve removed the `{% if form.errors %}` block from the template; django-bootstrap5 manages form errors automatically.    To display the form, we use the template tag `{% bootstrap_form %}` ❸; this replaces the `{{ form.as_div }}` element we were using in Chapter 19. The `{% booststrap_form %}` template tag inserts Bootstrap style rules into the form’s individual elements as the form is rendered. To generate the submit button, we use the `{% bootstrap_button %}` tag with arguments that designate it as a submit button, and give it the label `Log in` ❹.    [Figure 20-2](#figure20-2) shows the login form now. The page is much cleaner, with consistent styling and a clear purpose. Try logging in with an incorrect username or password; you’ll see that even the error messages are styled consistently and integrate well with the overall site.  ![](Images/f20002.png)    Figure 20-2: The login page styled with Bootstrap      ### Styling the Topics Page    Let’s make sure the pages for viewing information are styled appropriately as well, starting with the topics page:    **topics.html**    ```", "```py    We don’t need the `{% load bootstrap5 %}` tag, because we’re not using any custom bootstrap5 template tags in this file. We move the heading `Topics` into the `page_header` block and make it an `<h1>` element instead of a simple paragraph ❶.    The main content on this page is a list of topics, so we use Bootstrap’s *list group* component to render the page. This applies a simple set of styling directives to the overall list and to each item in the list. When we open the `<ul>` tag, we first include the `list-group` class to apply the default style directives to the list ❷. We further customize the list by putting a border at the bottom of the list, a little padding below the list (`pb-2`), and a margin below the bottom border (`mb-4`).    Each item in the list needs the `list-group-item` class, and we customize the default style by removing the border around individual items ❸. The message that’s displayed when the list is empty needs these same classes ❹.    When you visit the topics page now, you should see a page with styling that matches the home page.    ### Styling the Entries on the Topic Page    On the topic page, we’ll use Bootstrap’s card component to make each entry stand out. A *card* is a nestable set of divs with flexible, predefined styles that are perfect for displaying a topic’s entries:    **topic.html**    ```", "```py    We first place the topic in the `page_header` block ❶. Then we delete the unordered list structure previously used in this template. Instead of making each entry a list item, we open a div element with the selector `card` ❷. This card has two nested elements: one to hold the timestamp and the link to edit the entry, and another to hold the body of the entry. The `card` selector takes care of most of the styling we need for this div; we customize the card by adding a small margin to the bottom of each card (`mb-3`).    The first element in the card is a header, which is an `<h4>` element with the selector `card-header` ❸. This header contains the date the entry was made and a link to edit the entry. The `<small>` tag around the `edit_entry` link makes it appear a little smaller than the timestamp ❹. The second element is a div with the selector `card-body` ❺, which places the text of the entry in a simple box on the card. Notice that the Django code for including the information on the page hasn’t changed; only elements that affect the appearance of the page have. Since we no longer have an unordered list, we’ve replaced the list item tags around the empty list message with simple paragraph tags ❻.    [Figure 20-3](#figure20-3) shows the topic page with its new look. Learning Log’s functionality hasn’t changed, but it looks significantly more professional and inviting to users.    If you want to use a different Bootstrap template for a project, follow a process that’s similar to what we’ve done so far in this chapter. Copy the template you want to use into *base.html*, and modify the elements that contain actual content so the template displays your project’s information. Then use Bootstrap’s individual styling tools to style the content on each page.  ![](Images/f20003.png)    Figure 20-3: The topic page with Bootstrap styling      ## Deploying Learning Log    Now that we have a professional-looking project, let’s deploy it to a live server so anyone with an internet connection can use it. We’ll use Platform.sh, a web-based platform that allows you to manage the deployment of web applications. We’ll get Learning Log up and running on Platform.sh.    ### Making a Platform.sh Account    To make an account, go to [https://platform.sh](https://platform.sh) and click the **Free Trial** button. Platform.sh has a free tier that, as of this writing, does not require a credit card. The trial period allows you to deploy an app with minimal resources, which lets you test your project in a live deployment before committing to a paid hosting plan.    ### Installing the Platform.sh CLI    To deploy and manage a project on Platform.sh, you’ll need the tools available in the Command Line Interface (CLI). To install the latest version of the CLI, visit [https://docs.platform.sh/development/cli.html](https://docs.platform.sh/development/cli.html) and follow the instructions for your operating system.    On most systems, you can install the CLI by running the following command in a terminal:    ```", "```py    After this command has finished running, you will need to open a new terminal window before you can use the CLI.    ### Installing platformshconfig    You’ll also need to install one additional package, `platformshconfig`. This package helps detect whether the project is running on your local system or on a Platform.sh server. In an active virtual environment, issue the following command:    ```", "```py    We’ll use this package to modify the project’s settings when it’s running on the live server.    ### Creating a requirements.txt File    The remote server needs to know which packages Learning Log depends on, so we’ll use pip to generate a file listing them. Again, from an active virtual environment, issue the following command:    ```", "```py    The `freeze` command tells pip to write the names of all the packages currently installed in the project into the file *requirements.txt*. Open this file to see the packages and version numbers installed in your project:    **requirements.txt**    ```", "```py    Learning Log already depends on specific versions of seven different packages, so it requires a matching environment to run properly on a remote server. (We installed three of these packages manually, and four of them were installed automatically as dependencies of these packages.)    When we deploy Learning Log, Platform.sh will install all the packages listed in *requirements.txt*, creating an environment with the same packages we’re using locally. Because of this, we can be confident the deployed project will function just like it has on our local system. This approach to managing a project is critical as you start to build and maintain multiple projects on your system.    ### Additional Deployment Requirements    The live server requires two additional packages. These packages are used to serve the project in a production environment, where many users can be making requests at the same time.    In the same directory where *requirements.txt* is saved, make a new file called *requirements_remote.txt*. Add the following two packages to it:    **requirements_remote.txt**    ```", "```py    The `gunicorn` package responds to requests as they come in to the remote server; this takes the place of the development server we’ve been using locally. The `psycopg2` package is required to let Django manage the Postgres database that Platform.sh uses. *Postgres* is an open source database that’s extremely well suited to production apps.    ### Adding Configuration Files    Every hosting platform requires some configuration for a project to run correctly on its servers. In this section, we’ll add three configuration files:    *.platform.app.yaml* This is the main configuration file for the project. This tells Platform.sh what kind of project we’re trying to deploy and what kinds of resources our project needs, and it includes commands for building the project on the server.    *.platform/routes.yaml* This file defines the routes to our project. When a request is received by Platform.sh, this is the configuration that helps direct these requests to our specific project.    *.platform/services.yaml* This file defines any additional services our project needs.    These are all YAML (YAML Ain’t Markup Language) files. *YAML* is a language designed for writing configuration files; it’s made to be read easily by both humans and computers. You can write or modify a typical YAML file by hand, but a computer can also read and interpret the file unambiguously.    YAML files are great for deployment configuration, because they give you a good deal of control over what happens during the deployment process.    #### Making Hidden Files Visible    Most operating systems hide files and folders that begin with a dot, such as *.platform*. When you open a file browser, you won’t see these kinds of files and folders by default. But as a programmer, you’ll need to see them. Here’s how to view hidden files, depending on your operating system:    *   On Windows, open Windows Explorer, and then open a folder such as *Desktop*. Click the **View** tab, and make sure **File name extensions** and **Hidden items** are checked. *   On macOS, you can press ⌘-SHIFT-. (dot) in any Finder window to see hidden files and folders. *   On Linux systems such as Ubuntu, you can press CTRL-H in any file browser to display hidden files and folders. To make this setting permanent, open a file browser such as Nautilus and click the options tab (indicated by three lines). Select the **Show Hidden Files** checkbox.    #### The .platform.app.yaml Configuration File    The first configuration file is the longest, because it controls the overall deployment process. We’ll show it in parts; you can either enter it by hand in your text editor or download a copy from the online resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).    Here’s the first part of *.platform.app.yaml*, which should be saved in the same directory as *manage.py*:    **.platform.app.yaml**    ```", "```py    When you save this file, make sure you include the dot at the beginning of the filename. If you omit the dot, Platform.sh won’t find the file and your project will not be deployed.    You don’t need to understand everything in *.platform.app.yaml* at this point; I’ll highlight the most important parts of the configuration. The file starts off by specifying the `name` of the project, which we’re calling `'ll_project'` to be consistent with the name we used when starting the project ❶. We also need to specify the version of Python we’re using (3.10 at the time of this writing). You can find a list of supported versions at [https://docs.platform.sh/languages/python.html](https://docs.platform.sh/languages/python.html).    Next is a section labeled `relationships` that defines other services the project needs ❷. Here the only relationship is to a Postgres database. After that is the `web` section ❸. The `commands:start` section tells Platform.sh what process to use to serve incoming requests. Here we’re specifying that `gunicorn` will handle requests ❹. This command takes the place of the `python manage.py runserver` command we’ve been using locally.    The `locations` section tells Platform.sh where to send incoming requests ❺. Most requests should be passed through to `gunicorn`; our *urls.py* files will tell `gunicorn` exactly how to handle those requests. Requests for static files will be handled separately and will be refreshed once an hour. The last line shows that we’re requesting 512MB of disk space on one of Platform.sh’s servers ❻.    The rest of [.platform.app.yaml](http://.platform.app.yaml) is as follows:    ```", "```py    The `mounts` section ❶ lets us define directories where we can read and write data while the project is running. This section defines a *logs/* directory for the deployed project.    The `hooks` section ❷ defines actions that are taken at various points during the deployment process. In the `build` section, we install all the packages that are required to serve the project in the live environment ❸. We also run `collectstatic` ❹, which collects all the static files needed for the project into one place so they can be served efficiently.    Finally, in the `deploy` section ❺, we specify that migrations should be run each time the project is deployed. In a simple project, this will have no effect when there have been no changes.    The other two configuration files are much shorter; let’s write them now.    #### The routes.yaml Configuration File    A *route* is the path a request takes as it’s processed by the server. When a request is received by Platform.sh, it needs to know where to send the request.    Make a new folder called *.platform*, in the same directory as *manage.py*. Make sure you include the dot at the beginning of the name. Inside that folder, make a file called *routes.yaml* and enter the following:    **.platform/routes.yaml**    ```", "```py    This file makes sure requests like *https://project_url.com* and *www.project_url.com* all get routed to the same place.    #### The services.yaml Configuration File    This last configuration file specifies services that our project needs in order to run. Save this file in the *.platform/* directory, alongside *routes.yaml*:    **.platform/routes.yaml**    ```", "```py    This file defines one service, a Postgres database.    ### Modifying settings.py for Platform.sh    Now we need to add a section at the end of *settings.py* to modify some settings for the Platform.sh environment. Add this code to the very end of *settings.py*:    **settings.py**    ```", "```py    We normally place `import` statements at the beginning of a module, but in this case, it’s helpful to keep all the remote-specific settings in one section. Here we import `Config` from `platformshconfig` ❶, which helps determine settings on the remote server. We only modify settings if the method `config.is_valid_platform()` returns `True` ❷, indicating the settings are being used on a Platform.sh server.    We modify `ALLOWED_HOSTS` to allow the project to be served by hosts ending in *.platformsh.site* ❸. All projects deployed to the free tier will be served using this host. If settings are being loaded in the deployed app’s directory ❹, we set `STATIC_ROOT` so that static files are served correctly. We also set a more secure `SECRET_KEY` on the remote server ❺.    Finally, we configure the production database ❻. This is only set if the build process has finished running and the project is being served. Everything you see here is necessary to let Django talk to the Postgres server that Platform.sh set up for the project.    ### Using Git to Track the Project’s Files    As discussed in Chapter 17, Git is a version control program that allows you to take a snapshot of the code in your project each time you implement a new feature successfully. If anything goes wrong, you can easily return to the last working snapshot of your project; for example, if you accidentally introduce a bug while working on a new feature. Each snapshot is called a *commit*.    Using Git, you can try implementing new features without worrying about breaking your project. When you’re deploying to a live server, you need to make sure you’re deploying a working version of your project. To read more about Git and version control, see Appendix D.    #### Installing Git    Git may already be installed on your system. To find out, open a new terminal window and issue the command `git --version`:    ```", "```py    If you get a message indicating that Git is not installed, see the installation instructions in Appendix D.    #### Configuring Git    Git keeps track of who makes changes to a project, even when only one person is working on the project. To do this, Git needs to know your username and email. You must provide a username, but you can make up an email for your practice projects:    ```", "```py    If you forget this step, Git will prompt you for this information when you make your first commit.    #### Ignoring Files    We don’t need Git to track every file in the project, so we’ll tell it to ignore some files. Create a file called *.gitignore* in the folder that contains *manage.py*. Notice that this filename begins with a dot and has no file extension. Here’s the code that goes in *.gitignore*:    **.gitignore**    ```", "```py    We tell Git to ignore the entire *ll_env* directory, because we can re-create it automatically at any time. We also don’t track the *__pycache__* directory, which contains the *.pyc* files that are created automatically when the *.py* files are executed. We don’t track changes to the local database, because it’s a bad habit: if you’re ever using SQLite on a server, you might accidentally overwrite the live database with your local test database when you push the project to the server. The asterisk in `*.sqlite3` tells Git to ignore any file that ends with the extension *.sqlite3*.    #### Committing the Project    We need to initialize a Git repository for Learning Log, add all the necessary files to the repository, and commit the initial state of the project. Here’s how to do that:    ```", "```py    We issue the `git init` command to initialize an empty repository in the directory containing Learning Log ❶. We then use the `git add .` command, which adds all the files that aren’t being ignored to the repository ❷. (Don’t forget the dot.) Next, we issue the command `git commit -am` `\"``commit message``\"`: the `-a` flag tells Git to include all changed files in this commit, and the `-m` flag tells Git to record a log message ❸.    Issuing the `git status` command ❹ indicates that we’re on the *main* branch and that our working tree is *clean*. This is the status you’ll want to see anytime you push your project to a remote server.    ### Creating a Project on Platform.sh    At this point, the Learning Log project still runs on our local system and is also configured to run correctly on a remote server. We’ll use the Platform.sh CLI to create a new project on the server and then push our project to the remote server.    Make sure you’re in a terminal, at the *learning_log/* directory, and issue the following command:    ```", "```py    This command will open a browser tab where you can log in. Once you’re logged in, you can close the browser tab and return to the terminal. If you’re prompted about creating an SSH configuration file ❶, enter `Y` so you can connect to the remote server later.    Now we’ll create a project. There’s a lot of output, so we’ll look at the creation process in sections. Start by issuing the `create` command:    ```", "```py    The first prompt asks for a name for the project ❶, so we use the name `ll_project`. The next prompt asks which region we’d like the server to be in ❷. Choose the server closest to you; for me, that’s `us-3.platform.sh`. For the rest of the prompts, you can accept the defaults: a server on the lowest development plan ❸, three environments for the project ❹, and 5GB of storage for the overall project ❺.    There are three more prompts to respond to:    ```", "```py    A Git repository can have multiple branches; Platform.sh is asking us if the default branch for the project should be `main` ❶. It then asks if we want to connect the local project’s repository to the remote repository ❷. Finally, we’re informed that this project will cost about $10 per month if we keep it running beyond the free trial period ❸. If you haven’t entered a credit card yet, you shouldn’t have to worry about this cost. Platform.sh will simply suspend your project if you exceed the free trial’s limits without adding a credit card.    ### Pushing to Platform.sh    The last step before seeing the live version of the project is to push our code to the remote server. To do that, issue the following command:    ```", "```py    When you issue the command `platform push`, you’ll be asked for one more confirmation that you want to push the project ❶. You may also see a message about the authenticity of Platform.sh, if this is your first time connecting to the site ❷. Enter `Y` for each of these prompts, and you’ll see a bunch of output scroll by. This output will probably look confusing at first, but if anything goes wrong, it’s really useful to have during troubleshooting. If you skim through the output, you can see where Platform.sh installs necessary packages, collects static files, applies migrations, and sets up URLs for the project.    ### Viewing the Live Project    Once the push is complete, you can open the project:    ```", "```py    The `platform url` command lists the URLs associated with a deployed project; you’ll be given a choice of several URLs that are all valid for your project. Choose one, and your project should open in a new browser tab! This will look just like the project we’ve been running locally, but you can share this URL with anyone in the world, and they can access and use your project.    ### Refining the Platform.sh Deployment    Now we’ll refine the deployment by creating a superuser, just as we did locally. We’ll also make the project more secure by changing the setting `DEBUG` to `False`, so error messages won’t show users any extra information that they could use to attack the server.    #### Creating a Superuser on Platform.sh    The database for the live project has been set up, but it’s completely empty. All the users we created earlier only exist in our local version of the project.    To create a superuser on the live version of the project, we’ll start an SSH (secure socket shell) session where we can run management commands on the remote server:    ```", "```py    When you first run the `platform environment:ssh` command, you may get another prompt about the authenticity of this host. If you see this message, enter `Y` and you should be logged in to a remote terminal session.    After running the `ssh` command, your terminal acts just like a terminal on the remote server. Note that your prompt has changed to indicate that you’re in a `web` session associated with the project named `ll_project` ❶. If you issue the `ls` command, you’ll see the files that have been pushed to the Platform.sh server.    Issue the same `createsuperuser` command we used in Chapter 18 ❷. This time, I entered an admin username, `ll_admin_live`, that’s distinct from the one I used locally ❸. When you’re finished working in the remote terminal session, enter the `exit` command ❹. Your prompt will indicate that you’re working in your local system again ❺.    Now you can add */admin/* to the end of the URL for the live app and log in to the admin site. If others have already started using your project, be aware that you’ll have access to all their data! Take this responsibility seriously, and users will continue to trust you with their data.    #### Securing the Live Project    There’s one glaring security issue in the way our project is currently deployed: the setting `DEBUG = True` in *settings.py*, which provides debug messages when errors occur. Django’s error pages give you vital debugging information when you’re developing a project; however, they give way too much information to attackers if you leave them enabled on a live server.    To see how bad this is, go to the home page of your deployed project. Log in to a user’s account and add */topics/999/* to the end of the home page URL. Assuming you haven’t made thousands of topics, you should see a page with the message *DoesNotExist at /topics/999/*. If you scroll down, you should see a whole bunch of information about the project and the server. You won’t want your users to see this, and you certainly wouldn’t want this information available to anyone interested in attacking the site.    We can prevent this information from being shown on the live site by setting `DEBUG = False` in the part of *settings.py* that only applies to the deployed version of the project. This way you’ll continue to see debugging information locally, where that information is useful, but it won’t show up on the live site.    Open *settings.py* in your text editor, and add one line of code to the part that modifies settings for Platform.sh:    **settings.py**    ```", "```py    All the work to set up configuration for the deployed version of the project has paid off. When we want to adjust the live version of the project, we just change the relevant part of the configuration we set up earlier.    #### Committing and Pushing Changes    Now we need to commit the changes made to *settings.py* and push the changes to Platform.sh. Here’s a terminal session showing the first part of this process:    ```", "```py    We issue the `git commit` command with a short but descriptive commit message ❶. Remember the `-am` flag makes sure Git commits all the files that have changed and records the log message. Git recognizes that one file has changed and commits this change to the repository.    Running `git status` shows that we’re working on the `main` branch of the repository and that there are now no new changes to commit ❷. It’s important to check the status before pushing to a remote server. If you don’t see a clean status, then some changes haven’t been committed and those changes won’t be pushed to the server. You can try issuing the `commit` command again; if you’re not sure how to resolve the issue, read through Appendix D to better understand how to work with Git.    Now let’s push the updated repository to Platform.sh:    ```", "```py    Platform.sh recognizes that the repository has been updated, and it rebuilds the project to make sure all the changes have been taken into account. It doesn’t rebuild the database, so we haven’t lost any data.    To make sure this change took effect, visit the */topics/999/* URL again. You should see just the message *Server Error (500)*, with no sensitive information about the project at all.    ### Creating Custom Error Pages    In Chapter 19, we configured Learning Log to return a 404 error if the user requests a topic or entry that doesn’t belong to them. Now you’ve seen a 500 server error as well. A 404 error usually means your Django code is correct, but the object being requested doesn’t exist. A 500 error usually means there’s an error in the code you’ve written, such as an error in a function in *views.py*. Django currently returns the same generic error page in both situations, but we can write our own 404 and 500 error page templates that match Learning Log’s overall appearance. These templates belong in the root template directory.    #### Making Custom Templates    In the *learning_log* folder, make a new folder called *templates*. Then make a new file called *404.html*; the path to this file should be *learning_log/templates/404.html*. Here’s the code for this file:    **404.html**    ```", "```py    This simple template provides the generic 404 error page information but is styled to match the rest of the site.    Make another file called *500.html* using the following code:    **500.html**    ```", "```py    These new files require a slight change to *settings.py*.    **settings.py**    ```", "```py    This change tells Django to look in the root template directory for the error page templates and any other templates that aren’t associated with a particular app.    #### Pushing the Changes to Platform.sh    Now we need to commit the changes we just made and push them to Platform.sh:    ```", "```py    We issue the `git add .` command ❶ because we created some new files in the project. Then we commit the changes ❷ and push the updated project to Platform.sh ❸.    Now when an error page appears, it should have the same styling as the rest of the site, making for a smoother user experience when errors arise.    ### Ongoing Development    You might want to further develop Learning Log after your initial push to a live server, or you might want to develop your own projects to deploy. When doing so, there’s a fairly consistent process for updating your projects.    First, you’ll make the necessary changes to your local project. If your changes result in any new files, add those files to the Git repository using the command `git add .` (making sure to include the dot at the end of the command). Any change that requires a database migration will need this command, because each migration generates a new migration file.    Second, commit the changes to your repository using `git commit -am \"``commit message``\"`. Then push your changes to Platform.sh, using the command `platform push`. Visit your live project and make sure the changes you expect to see have taken effect.    It’s easy to make mistakes during this process, so don’t be surprised when something goes wrong. If the code doesn’t work, review what you’ve done and try to spot the mistake. If you can’t find the mistake or you can’t figure out how to undo it, refer to the suggestions for getting help in Appendix C. Don’t be shy about asking for help: everyone else learned to build projects by asking the same questions you’re likely to ask, so someone will be happy to help you. Solving each problem that arises helps you steadily develop your skills until you’re building meaningful, reliable projects and answering other people’s questions as well.    ### Deleting a Project on Platform.sh    It’s great practice to run through the deployment process a number of times with the same project or with a series of small projects, to get the hang of deployment. But you’ll need to know how to delete a project that’s been deployed. Platform.sh also limits the number of projects you can host for free, and you don’t want to clutter your account with practice projects.    You can delete a project using the CLI:    ```", "```py    You’ll be asked to confirm that you want to take this destructive action. Respond to the prompts, and your project will be deleted.    The command `platform create` also gave the local Git repository a reference to the remote repository on Platform.sh’s servers. You can remove this remote from the command line as well:    ```", "```py    The command `git remote` lists the names of all remote URLs associated with the current repository. The command `git remote remove``remote_name` deletes these remote URLs from the local repository.    You can also delete a project’s resources by logging in to the Platform.sh website and visiting your dashboard at [https://console.platform.sh](https://console.platform.sh). This page lists all your active projects. Click the three dots in a project’s box, and click **Edit Plan**. This is a pricing page for the project; click the **Delete Project** button at the bottom of the page, and you’ll be shown a confirmation page where you can follow through with the deletion. Even if you deleted your project using the CLI, it’s a good idea to familiarize yourself with the dashboard of any hosting provider you deploy to.    ## Summary    In this chapter, you learned to give your projects a simple but professional appearance using the Bootstrap library and the django-bootstrap5 app. With Bootstrap, the styles you choose will work consistently on almost any device people use to access your project.    You learned about Bootstrap’s templates and used the *Navbar static* template to create a simple look and feel for Learning Log. You used a jumbotron to make a home page’s message stand out, and learned to style all the pages in a site consistently.    In the final part of the project, you learned how to deploy a project to a remote server so anyone can access it. You made a Platform.sh account and installed some tools that help manage the deployment process. You used Git to commit the working project to a repository, and then pushed the repository to a remote server on Platform.sh. Finally, you learned to begin securing your app by setting `DEBUG = False` on the live server. You also made custom error pages, so the inevitable errors that come up will look well-handled.    Now that you’ve finished Learning Log, you can start building your own projects. Start simple, and make sure the project works before adding complexity. Enjoy your continued learning, and good luck with your projects!```"]