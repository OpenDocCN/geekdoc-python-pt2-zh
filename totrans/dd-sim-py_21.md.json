["```py\n**import threading**\n\nBOUND = 10**5\n\ndef collatz(n):\n    steps = 0\n    while n > 1:\n        if n % 2:\n            n = n * 3 + 1\n        else:\n            n = n // 2\n        steps += 1\n    return steps\n\ndef length_counter(target):\n    count = 0\n    for i in range(2, BOUND):\n        if collatz(i) == target:\n            count += 1\n    return count\n```", "```py\n**guess = None**\n\ndef get_input(prompt):\n    **global guess**\n    while True:\n        n = input(prompt)\n        try:\n            n = int(n)\n        except ValueError:\n            print(\"Value must be an integer.\")\n            continue\n        if n <= 0:\n            print(\"Value must be positive.\")\n        else:\n            **guess = n**\n            return n\n```", "```py\ndef main():\n    print(\"Collatz Sequence Counter\")\n\n    target = get_input(\"Collatz sequence length to search for: \")\n    print(f\"Searching in range 1-{BOUND}...\")\n\n **t_guess = threading.Thread(**\n **target=get_input,**\n **args=(\"How many times do you think it will appear? \",)**\n **)**\n **t_guess.start()**\n\n    count = length_counter(target)\n\n    **t_guess.join()**\n\n    if guess == count:\n        print(\"Exactly right! I'm amazed.\")\n    elif abs(guess - count) < 100:\n print(f\"You're close! It was {count}.\")\n    else:\n        print(f\"Nope. It was {count}.\")\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\ndef main():\n    # `--snip--`\n\n    t_guess = threading.Thread(\n        target=get_input,\n        args=(\"How many times do you think it will appear? \",),\n        **daemon=True**\n    )\n    t_guess.start()\n\n    count = length_counter(target)\n\n    t_guess.join(**timeout=1.5**)\n    **if t_guess.is_alive():**\n **print(\"\\nYou took too long to respond!\")**\n **return**\n\n    # `--snip--`\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n**import concurrent.futures**\n\nBOUND = 10**5\n\ndef collatz(n):\n    # `--snip--`\n```", "```py\ndef get_input(prompt):\n    while True:\n        n = input(prompt)\n        try:\n            n = int(n)\n        except ValueError:\n            print(\"Value must be an integer.\")\n            continue\n        if n <= 0:\n            print(\"Value must be positive.\")\n        else:\n            return n\n```", "```py\ndef main():\n    print(\"Collatz Sequence Counter\")\n\n    # `--snip--`\n\n    **executor = concurrent.futures.ThreadPoolExecutor()**\n    **future_guess = executor.submit(**\n **get_input,**\n **\"How many times do you think it will appear? \"**\n **)**\n\n    **count = length_counter(target)**\n    **guess = future_guess.result()**\n    **executor.shutdown()**\n\n    # `--snip--`\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\ndef main():\n    print(\"Collatz Sequence Counter\")\n\n    # `--snip--`\n\n    **with concurrent.futures.ThreadPoolExecutor() as executor:**\n        future_guess = executor.submit(\n            get_input,\n            \"How many times do you think it will appear? \"\n        )\n\n        count = length_counter(target)\n\n    guess = future_guess.result()\n\n    # `--snip--`\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n count = length_counter(target)\n    try:\n        guess = future_guess.result(timeout=1.5)\n    except concurrent.futures.TimeoutError:\n        print(\"\\nYou took too long to respond!\")\n      ❶ executor.shutdown(wait=False, cancel_futures=True)\n        return  # hangs forever!\n    else:\n        executor.shutdown()\n```", "```py\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n```", "```py\n**import dis**\n\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n\n**dis.dis(increment)**\n```", "```py\n 7           0 LOAD_GLOBAL              0 (count)\n              2 LOAD_CONST               1 (1)\n              4 INPLACE_ADD\n              6 STORE_GLOBAL             0 (count)\n              8 LOAD_CONST               0 (None)\n             10 RETURN_VALUE\n```", "```py\nimport concurrent.futures\nimport functools\nimport time\n\nBOUND = 10**5\n\nclass Counter:\n    count = 0\n\n    @classmethod\n    def increment(cls):\n        new = cls.count + 1\n      ❶ time.sleep(0.1)  # forces the problem\n        cls.count = new\n\n    @classmethod\n    def get(cls):\n        return cls.count\n\n    @classmethod\n    def reset(cls):\n        cls.count = 0\n```", "```py\ndef collatz(**target,** n):\n    steps = 0\n    while n > 1:\n        if n % 2:\n            n = n * 3 + 1\n        else:\n            n = n // 2\n        steps += 1\n\n **if steps == target:**\n **Counter.increment()**\n```", "```py\ndef length_counter(target):\n  ❶ Counter.reset()\n    with concurrent.futures.ThreadPoolExecutor( ❷ max_workers=5) as executor:\n        func = ❸ functools.partial(collatz, target)\n      ❹ executor.map(func, range(2, BOUND))\n    return Counter.get()\n```", "```py\nCollatz Sequence Counter\nCollatz sequence length to search for: 123\nSearching in range 1-100000...\nHow many times do you think it will appear? 210\nNope. It was 43.\n```", "```py\nimport concurrent.futures\n**import threading**\nimport functools\nimport time\n\nBOUND = 10**5\n\nclass Counter:\n    count = 0\n    **_lock =** ❶ **threading.Lock()**\n\n    @classmethod\n    def increment(cls):\n      ❷ **cls._lock.acquire()**\n        new = cls.count + 1\n        time.sleep(0.1)\n        cls.count = new\n      ❸ **cls._lock.release()**\n\n    # `--snip--`\n```", "```py\n # `--snip--`\n\n    @classmethod\n    def increment(cls):\n        **with cls._lock:**\n            new = cls.count + 1\n            time.sleep(0.1)\n            cls.count = new\n\n    # `--snip--`\n```", "```py\nimport concurrent.futures\nimport functools\n**import queue**\n\nBOUND = 10**5\n```", "```py\ndef collatz(**results**, n):\n    steps = 0\n    while n > 1:\n        if n % 2:\n            n = n * 3 + 1\n        else:\n            n = n // 2\n        steps += 1\n    **results.put(steps)**\n```", "```py\ndef length_counter(target):\n    **results = queue.Queue()**\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        func = functools.partial(collatz, ❶ **results**)\n        executor.map(func, range(2, BOUND))\n    **results = list(results.queue)**\n    return **results.count(target)**\n```", "```py\nimport concurrent.futures\n\nBOUND = 10**5\n```", "```py\ndef collatz(n):\n    steps = 0\n    while n > 1:\n        if n % 2:\n            n = n * 3 + 1\n        else:\n            n = n // 2\n        steps += 1\n    **return steps**\n```", "```py\ndef length_counter(target):\n    **count = 0**\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        **for result in** executor.map(collatz, range(2, BOUND))**:**\n            **if result == target:**\n **count += 1**\n    **return count**\n```", "```py\ndef length_counter(target):\n    count = 0\n    with concurrent.futures.**ProcessPoolExecutor()** as executor:\n        for result in executor.map(collatz, range(2, BOUND)):\n            if result == target:\n                count += 1\n    return count\n```", "```py\ndef length_counter(target):\n    count = 0\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        for result in executor.map(\n            collatz,\n            range(2, BOUND)**,**\n            **chunksize=BOUND//4**\n        ):\n            if result == target:\n                count += 1\n    return count\n```", "```py\nimport concurrent.futures\nimport multiprocessing\nimport queue\nimport itertools\nimport signal\nimport time\n\nBOUND = 10**5\n```", "```py\nin_queue = multiprocessing.Queue(100)\nexit_event = multiprocessing.Event()\n```", "```py\ndef exit_handler(signum, frame):\n  ❶ exit_event.set()\n\nsignal.signal(❷ signal.SIGINT, exit_handler)\nsignal.signal(❸ signal.SIGTERM, exit_handler)\n```", "```py\ndef collatz(n):\n    steps = 0\n    while n > 1:\n        if n % 2:\n            n = n * 3 + 1\n        else:\n            n = n // 2\n        steps += 1\n    return steps\n\ndef collatz_consumer(target):\n    count = 0\n    while True:\n        if not in_queue.empty():\n            try:\n                n = in_queue.get( ❶ timeout=1)\n            except queue.Empty:\n                return count\n\n            if collatz(n) == target:\n                count += 1\n\n        if exit_event.is_set():\n            return count\n```", "```py\ndef range_producer():\n    for n in range(2, BOUND):\n      ❶ if exit_event.is_set():\n            return\n        try:\n          ❷ in_queue.put(n, timeout=1)\n except queue.Full:\n          ❸ exit_event.set()\n            return\n\n    while True:\n        time.sleep(0.05)\n        if in_queue.empty():\n            exit_event.set()\n            return\n```", "```py\ndef length_counter(target):\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        executor.submit( ❶ range_producer)\n        results = ❷ executor.map(\n            collatz_consumer,\n          ❸ itertools.repeat(target, 4)\n        )\n\n    return ❹ sum(results)\n```", "```py\nCollatz Sequence Counter\nCollatz sequence length to search for: 128\nSearching in range 1-100000...\nHow many times do you think it will appear? 608\nExactly right! I'm amazed.\n```"]