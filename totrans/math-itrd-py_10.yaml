- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: USING MATRICES FOR COMPUTER GRAPHICS AND SYSTEMS OF EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵进行计算机图形学和方程组
- en: '*“I am large, I contain multitudes.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我很伟大，我包容万象。”*'
- en: —Walt Whitman, from “Song of Myself”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —沃尔特·惠特曼，摘自《我歌唱我自己》*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: In math class, students are taught how to add, subtract, and multiply matrices
    without ever learning how they’re really used. This is too bad because matrices
    allow us to easily group together large collections of items and simulate coordinates
    of an object from multiple perspectives, making them useful in machine learning
    and absolutely crucial to 2D and 3D graphics. In other words, without matrices,
    there would be no video games!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学课上，学生被教导如何加、减和乘矩阵，但他们从未真正学过矩阵是如何应用的。这是很遗憾的，因为矩阵使我们能够轻松地将大量项目分组，并模拟物体从多个角度的坐标，这使得它们在机器学习中非常有用，对
    2D 和 3D 图形至关重要。换句话说，如果没有矩阵，就不会有视频游戏！
- en: To understand how matrices are useful for creating graphics, you first need
    to understand how to perform arithmetic on them. In this chapter, you review how
    to add and multiply matrices so that you can create and transform 2D and 3D objects
    in Processing. Finally, you learn how to solve large systems of equations instantaneously
    using matrices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解矩阵如何用于创建图形，首先需要理解如何对它们进行算术运算。在本章中，你将回顾如何加法和乘法运算矩阵，以便你可以在 Processing 中创建和转换
    2D 和 3D 对象。最后，你将学习如何使用矩阵瞬间解决大型方程组。
- en: '### WHAT IS A MATRIX?'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### 什么是矩阵？'
- en: A *matrix* is a rectangular array of numbers that have specific rules for operating
    on them. [Figure 8-1](ch08.xhtml#ch08fig1) shows what a matrix looks like.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵* 是一个矩形的数字数组，有特定的规则用于对它们进行操作。[图 8-1](ch08.xhtml#ch08fig1) 显示了矩阵的样子。'
- en: '![image](../images/f146-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f146-01.jpg)'
- en: '*Figure 8-1: Matrices have* `m` *rows and* `n` *columns*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：矩阵有* `m` *行和* `n` *列*'
- en: 'Here, the numbers are arranged in rows and columns, where *m* and *n* represent
    the total number of rows and columns, respectively. You can have a 2 × 2 matrix,
    with two rows and two columns, like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字按行和列排列，其中 *m* 和 *n* 分别表示行数和列数。你可以有一个 2 × 2 的矩阵，包含两行两列，如下所示：
- en: '![image](../images/e146-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e146-01.jpg)'
- en: 'Or you can have a 3 × 4 matrix with three rows and four columns, like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以有一个 3 × 4 的矩阵，包含三行四列，如下所示：
- en: '![image](../images/e146-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e146-02.jpg)'
- en: Traditionally, we use the letter *i* to represent the row number and the letter
    *j* to represent the column number. Note that the numbers in a matrix aren’t being
    added to each other; they’re just arranged together. This is similar to how we
    arrange coordinates using the format (x,y), but you don’t operate on coordinates.
    For example, a point at (2,3) doesn’t mean you add or multiply 2 and 3; they just
    sit next to each other and tell you where the point is located on a graph. But
    as you’ll soon see, you *can* add, subtract, and multiply two matrices just like
    you can normal numbers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们使用字母 *i* 来表示行号，使用字母 *j* 来表示列号。注意，矩阵中的数字并不是彼此相加；它们只是排在一起。这类似于我们使用坐标格式 (x,
    y) 来排列坐标，但你并不对坐标进行运算。例如，一个位于 (2, 3) 的点并不意味着你要加或乘 2 和 3；它们只是并排在一起，告诉你该点在图表中的位置。但正如你很快会看到的那样，你
    *确实可以* 像对待普通数字一样，对两个矩阵进行加、减和乘法运算。
- en: ADDING MATRICES
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加矩阵
- en: 'You can only add and subtract matrices of the same dimensions (size and shape),
    which means that you can add or subtract only the *corresponding elements*. Here
    is an example of how to add two 2 × 2 matrices:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能对相同维度（大小和形状）的矩阵进行加法和减法运算，这意味着你只能加或减 *对应元素*。以下是如何加两个 2 × 2 矩阵的示例：
- en: '![image](../images/e146-03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e146-03.jpg)'
- en: 'For example, we add 1 and 5 because they are corresponding elements in their
    matrices, meaning they’re in the same spot: the first row, first column. Thus,
    we get 6 in the top-left corner. Adding the corresponding elements 3 and –7 gives
    us –4, as you can see in the bottom-left corner of the result.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们加 1 和 5，因为它们是矩阵中对应的元素，意味着它们处于相同的位置：第一行，第一列。因此，我们得到 6 在左上角。将对应的元素 3 和 –7
    相加，得到 –4，就像你在结果的左下角看到的那样。
- en: That’s easy enough to put into a Python function since you can save a matrix
    to a variable. Open a new file in IDLE and save it as *matrices.py*. Then write
    the code in [Listing 8-1](ch08.xhtml#ch08list1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于放入 Python 函数来说足够简单，因为你可以将一个矩阵保存到一个变量中。在 IDLE 中打开一个新文件并将其保存为 *matrices.py*。然后按照
    [Listing 8-1](ch08.xhtml#ch08list1) 编写代码。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Writing the* `matrices.py` *program to add matrices*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-1：编写* `matrices.py` *程序以添加矩阵*'
- en: Here, we declare a couple of 2 × 2 matrices, `A` and `B`, using Python’s list
    syntax. For example, `A` is a list that contains two lists, each of which has
    two elements. We then declare a function called `addMatrices()`, which takes two
    matrices as arguments. Finally, we create another matrix, `C`, which adds each
    element in the first matrix to the corresponding element in the second.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Python 的列表语法声明了两个 2 × 2 的矩阵，`A` 和 `B`。例如，`A` 是一个包含两个列表的列表，每个列表都有两个元素。然后，我们声明了一个名为
    `addMatrices()` 的函数，它接受两个矩阵作为参数。最后，我们创建了另一个矩阵 `C`，它将第一个矩阵中的每个元素与第二个矩阵中对应的元素相加。
- en: 'When you run this, the output should be something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，输出应该类似于下面这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This shows the 2 × 2 matrix that results from adding matrices A and B:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了将矩阵 A 和 B 相加得到的 2 × 2 矩阵：
- en: '![image](../images/e147-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e147-01.jpg)'
- en: Now that you know how to add matrices, let’s try multiplying them, which will
    let you transform coordinates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何加矩阵了，让我们来试试矩阵乘法，它将帮助你进行坐标转换。
- en: MULTIPLYING MATRICES
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Multiplying matrices is much more useful than adding them. For example, you
    can rotate a 2D or 3D shape by multiplying a matrix of (x,y) coordinates by a
    transformation matrix, as you’ll do later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵相乘比矩阵相加更有用。例如，你可以通过将 (x,y) 坐标矩阵与变换矩阵相乘来旋转一个二维或三维形状，正如你将在本章稍后做的那样。
- en: 'When multiplying matrices, you don’t simply multiply the corresponding elements.
    Instead, you multiply the elements in each row of the first matrix by the corresponding
    elements in each column of the second matrix. This means that the number of columns
    in the first matrix has to equal the number of rows in the second. Otherwise,
    they can’t be multiplied. For example, the following two matrices can be multiplied:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵相乘时，你不是直接相乘对应的元素。相反，你将第一个矩阵每一行的元素与第二个矩阵每一列的对应元素相乘。这意味着第一个矩阵的列数必须等于第二个矩阵的行数。否则，它们就不能相乘。例如，下面这两个矩阵可以相乘：
- en: '![image](../images/e148-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-01.jpg)'
- en: 'First, we multiply the elements in the first row of the first matrix (1 and
    2) with the elements in only the first column of the second matrix (5 and 6).
    The sum of those products would become the element in the first row and column
    of the resultant matrix. We do the same for the second row of the first matrix,
    and so on. It would look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将第一个矩阵的第一行（1和2）与第二个矩阵第一列的元素（5和6）相乘。这些乘积的和将成为结果矩阵第一行第一列的元素。对第一个矩阵的第二行执行相同的操作，依此类推。结果将如下所示：
- en: '![image](../images/e148-02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-02.jpg)'
- en: 'Here is the general formula for multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将 2 × 2 矩阵与 2 × 2 矩阵相乘的通用公式：
- en: '![image](../images/e148-03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-03.jpg)'
- en: 'We can also multiply the following two matrices, because *A* is a 1 × 4 matrix
    and *B* is a 4 × 2 matrix:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以乘以以下两个矩阵，因为 *A* 是一个 1 × 4 矩阵，*B* 是一个 4 × 2 矩阵：
- en: '![image](../images/e148-04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-04.jpg)'
- en: What will the resultant matrix look like? Well, the first row of *A* will be
    multiplied by the first column of *B* to become the number in the first row, first
    column of the result. It works the same way for the first row, second column.
    The resultant matrix will be a 1 × 2 matrix. You can see when you’re multiplying
    matrices, the elements in the rows of the first matrix are being matched up with
    the elements in the columns of the second matrix. That means the resultant matrix
    will have the number of rows of the first matrix and the number of columns of
    the second matrix.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果矩阵将是什么样子？好吧，*A*的第一行将与*B*的第一列相乘，得到结果矩阵的第一行第一列的数字。对于第一行第二列也是一样。结果矩阵将是一个 1 ×
    2 矩阵。你可以看到，当你在做矩阵乘法时，第一个矩阵的行元素会与第二个矩阵的列元素对应起来。这意味着结果矩阵的行数将等于第一个矩阵的行数，而列数将等于第二个矩阵的列数。
- en: Now we’ll directly multiply the elements in matrix *A* by their corresponding
    elements in matrix *B* and add all the products.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将直接将矩阵 *A* 中的元素与矩阵 *B* 中的对应元素相乘，并将所有的乘积相加。
- en: '![image](../images/e148-05.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-05.jpg)'
- en: This might seem like a complicated process to have to automate, but as long
    as we have the matrices as input, we can easily find out the number of columns
    and rows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一个复杂的自动化过程，但只要我们有矩阵作为输入，就能轻松找出列数和行数。
- en: Listing 8-2 shows a matrix multiplication program in Python that requires a
    bit more work than the addition code. Add this code to *matrices.py*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例8-2展示了一个矩阵乘法程序，它比加法代码稍微复杂一些。将此代码添加到*matrices.py*中。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-2: Writing a matrix multiplication function*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例8-2：编写矩阵乘法函数*'
- en: 'In this example, the `multmatrix()` function takes two matrices as parameters:
    `a` and `b`. Right at the beginning of the function we declare `m`, the number
    of rows in matrix `a`, and `n`, the number of columns in matrix `b`. We create
    an empty list called `newmatrix` as the resultant matrix. The “row times column”
    operation will occur `m` times, so the first loop is `for i in range(m)`, making
    `i` repeat `m` number of times. For every row, we add an empty row to `newmatrix`
    so we can fill the row with `n` elements. The next loop makes `j` repeat `n` times
    because there are `n` columns in `b`. The tricky part will be matching up the
    correct elements, but it just takes a little thinking.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`multmatrix()`函数接受两个矩阵作为参数：`a`和`b`。在函数一开始，我们声明了`m`，即矩阵`a`的行数，以及`n`，即矩阵`b`的列数。我们创建一个名为`newmatrix`的空列表作为结果矩阵。
    “行乘列”的操作将进行`m`次，所以第一个循环是`for i in range(m)`，使得`i`重复`m`次。对于每一行，我们向`newmatrix`中添加一个空行，以便我们可以用`n`个元素填充该行。接下来的循环使得`j`重复`n`次，因为矩阵`b`有`n`列。棘手的部分是匹配正确的元素，但这只需要一点思考。
- en: Just think of what elements will be multiplied together. When `j = 0`, we multiply
    the elements in the `i`th row of `a` by the first column (index 0) of `b`, and
    the product becomes the first column in the new row of `newmatrix`, as you saw
    in the previous example. Then, when `j = 1`, the same happens to the `i`th row
    of `a` and the second column (index 1) of `b`. That product becomes the second
    column in the new row of `newmatrix`. This process gets repeated for every row
    of `a`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只需考虑哪些元素会被相乘。当`j = 0`时，我们将矩阵`a`的第`i`行的元素与矩阵`b`的第一列（索引0）相乘，结果成为`newmatrix`新行中的第一列，正如你在之前的示例中看到的那样。然后，当`j
    = 1`时，矩阵`a`的第`i`行和矩阵`b`的第二列（索引1）发生同样的情况。该乘积成为`newmatrix`新行中的第二列。这个过程会为矩阵`a`的每一行重复进行。
- en: 'For every element in the row in matrix `a`, there’s a corresponding element
    in the column in matrix `b`. The number of columns of `a` and the number of rows
    of `b` are the same, but we can express it as `len(a[0])` or `len(b)`. I chose
    `len(b)`. So in the third loop, `k` will repeat `len(b)` times. The first element
    in the `i`th row of `a` and the first element in the `j`th column of `b` will
    be multiplied together, which can be written like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵`a`中每一行的每个元素，矩阵`b`中有一个对应的列元素。矩阵`a`的列数和矩阵`b`的行数是相同的，但我们可以将其表示为`len(a[0])`或`len(b)`。我选择了`len(b)`。因此，在第三个循环中，`k`将重复`len(b)`次。矩阵`a`的第`i`行的第一个元素与矩阵`b`的第`j`列的第一个元素将相乘，可以写成这样：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same for the second element in the `i`th row of `a` and the second element
    in the `j`th column of `b`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵`a`的第`i`行的第二个元素和矩阵`b`的第`j`列的第二个元素，同样的操作：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So for every column (in the `j` loop), we’ll start a running sum at 0 (because
    `sum` is already a Python keyword, I use `sum1`), and it will increment for every
    one of the `k` elements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每一列（在`j`循环中），我们将从0开始累加求和（因为`sum`已经是Python的关键字，所以我使用`sum1`），并且它会随着每个`k`元素的增加而增加：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It doesn’t look like much, but that’s the line that’s going to keep track of
    and multiply all the corresponding elements! After going through all `k` elements
    (after the `k` loop is finished), we’ll append the sum to the row, and once we’ve
    gone through all the columns in `b` (after the `j` loop is finished), we’ll put
    that row into `newmatrix`. After going through all the rows in `a`, we return
    the resultant matrix.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不算很多，但这行代码会跟踪并相乘所有对应的元素！在完成所有`k`元素的循环后（即`k`循环结束后），我们将把和添加到行中，并且一旦遍历完矩阵`b`中的所有列（即`j`循环结束后），我们将把该行放入`newmatrix`中。完成矩阵`a`中的所有行后，我们返回结果矩阵。
- en: 'Let’s test this program by multiplying our sample matrices, a 1 × 4 matrix
    by a 4 × 2 matrix:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将我们的样本矩阵相乘来测试这个程序，乘以一个1 × 4的矩阵和一个4 × 2的矩阵：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This checks out:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样检查是正确的：
- en: '![image](../images/e150-01a.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e150-01a.jpg)'
- en: 'Therefore, our new function for multiplying any two matrices (if they *can*
    be multiplied) works. Let’s test it by multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的新函数用于乘任何两个矩阵（如果它们*可以*相乘）工作。让我们通过将一个2 × 2的矩阵与一个2 × 2的矩阵相乘来测试它：
- en: '![image](../images/e150-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e150-01.jpg)'
- en: 'Enter the following to multiply matrix `a` by matrix `b`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容来将矩阵`a`乘以矩阵`b`：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code shows how to enter 2 × 2 matrices using Python lists. The multiplication
    also looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码展示了如何使用 Python 列表输入 2 × 2 的矩阵。矩阵乘法也像这样：
- en: '![image](../images/e150-02.jpg) Let’s check these answers. We begin by multiplying
    the first row of `a` by the first column of `b`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e150-02.jpg) 让我们检查这些答案。我们从将 `a` 的第一行与 `b` 的第一列相乘开始：'
- en: (1)(3) + (–2)(5) = 3 – 10 = –7
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (1)(3) + (–2)(5) = 3 – 10 = –7
- en: 'And –7 is the number in the first row, first column of the resultant matrix.
    We next multiply the second row of `a` by the first column of `b`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 而 –7 是结果矩阵中第一行、第一列的数字。接下来我们将 `a` 的第二行与 `b` 的第一列相乘：
- en: (2)(3) + (1)(5) = 6 + 5 = 11
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (2)(3) + (1)(5) = 6 + 5 = 11
- en: And 11 is the number in the second row, first column of the resultant matrix.
    The other numbers are correct, too. The `multmatrix()` function is going to save
    us from doing a lot of laborious arithmetic!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 11 是结果矩阵中第二行、第一列的数字。其他数字也是正确的。`multmatrix()` 函数将帮助我们避免做大量繁琐的计算！
- en: ORDER MATTERS IN MATRIX MULTIPLICATION
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵乘法中顺序很重要
- en: 'An important fact about multiplying matrices is that A × B doesn’t necessarily
    equal B × A. Let’s prove that by reversing our previous example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于矩阵乘法的一个重要事实是 A × B 不一定等于 B × A。让我们通过反转之前的示例来证明这一点：
- en: '![image](../images/e151-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e151-01.jpg)'
- en: 'Here’s how to multiply these matrices in the other direction in the Python
    shell:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在 Python shell 中反向乘法的方法：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, when you multiply the same matrices in the reverse order using
    `multmatrix(b,a)` instead of `multmatrix(a,b)`, you get a completely different
    resultant matrix. Remember that when you’re multiplying matrices, *A × B doesn’t
    necessarily equal B × A*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你用 `multmatrix(b,a)` 而不是 `multmatrix(a,b)` 反向相乘相同的矩阵时，你会得到完全不同的结果矩阵。记住，矩阵相乘时，*A
    × B 不一定等于 B × A*。
- en: DRAWING 2D SHAPES
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制二维形状
- en: Now that you know how to operate on matrices, let’s put a bunch of points into
    a list to make a 2D shape. Open a new sketch in Processing and save it as *matrices.pyde*.
    If you still have your *grid.pyde* sketch from [Listing 4-11](ch04.xhtml#ch04list11),
    you can copy and paste the essentials for drawing a grid. Otherwise, add the code
    in [Listing 8-3](ch08.xhtml#ch08list3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何进行矩阵操作了，让我们将一堆点放入列表中，形成一个二维形状。在 Processing 中打开一个新草图，并将其保存为 *matrices.pyde*。如果你仍然保留着
    [列表 4-11](ch04.xhtml#ch04list11) 中的 *grid.pyde* 草图，可以复制并粘贴绘制网格的核心代码。否则，请添加 [列表
    8-3](ch08.xhtml#ch08list3) 中的代码。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-3: The code for drawing a grid*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：绘制网格的代码*'
- en: We’re going to draw a simple figure and transform it using matrices. I’ll use
    the letter *F* because it has no rotational or reflectional symmetry (and because
    it’s my initial). We’ll sketch it out to get the points, as shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个简单的图形，并通过矩阵变换它。我将使用字母*F*，因为它没有旋转或对称反射的特性（而且因为它是我的名字首字母）。我们将先画出它的轮廓来获得点，如
    [图 8-2](ch08.xhtml#ch08fig2) 所示。
- en: '![image](../images/f152-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f152-01.jpg)'
- en: '*Figure 8-2: The points needed to draw an* `F`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：绘制 *F* 所需的点*'
- en: Add the code in [Listing 8-4](ch08.xhtml#ch08list4) after the `draw()` function
    to enter the points for all the corners of the *F* and draw lines between those
    points.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw()` 函数后添加 [列表 8-4](ch08.xhtml#ch08list4) 中的代码，以输入 *F* 的所有角点，并在这些点之间画线。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-4: Graphing the points to draw the* `F`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4：绘制 *F* 的点*'
- en: 'Here, we first create a list called `fmatrix` and enter points on each row
    corresponding to the points in the letter *F*. The `graphPoints()` function takes
    a matrix as a parameter, and each row becomes a vertex of the shape using Processing’s
    `beginShape()` and `endShape()` functions. Also, we call the `graphPoints()` function
    using `fmatrix` as an argument in the `draw()` function. Add the code in [Listing
    8-5](ch08.xhtml#ch08list5) to the end of the `draw()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个名为 `fmatrix` 的列表，并在每一行中输入与字母 *F* 中的点相对应的坐标。`graphPoints()` 函数以矩阵为参数，每一行成为形状的一个顶点，使用
    Processing 的 `beginShape()` 和 `endShape()` 函数。同时，我们在 `draw()` 函数中使用 `fmatrix`
    作为参数调用 `graphPoints()` 函数。在 `draw()` 函数的末尾添加 [列表 8-5](ch08.xhtml#ch08list5) 中的代码：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-5: Getting the program to graph the points in the* `F`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：让程序绘制 *F* 的点*'
- en: We’re creating the `fmatrix` as a list containing a bunch of coordinates, and
    we call the `graphPoints()` function to tell the program to graph all the points.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建 `fmatrix`，它是一个包含许多坐标的列表，并且调用 `graphPoints()` 函数来指示程序绘制所有的点。
- en: Processing’s built-in `strokeWeight()` function lets you control how thick you
    want the outline to be, and the `stroke()` function lets you choose the color
    of the outline. We’ll draw the first *F* in black. The output looks like [Figure
    8-3](ch08.xhtml#ch08fig3).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Processing内置的`strokeWeight()`函数允许你控制轮廓的厚度，而`stroke()`函数让你选择轮廓的颜色。我们将用黑色绘制第一个*F*。输出结果如[图8-3](ch08.xhtml#ch08fig3)所示。
- en: '![image](../images/f153-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f153-01.jpg)'
- en: '*Figure 8-3: The output of graphing the points in the matrix, called the “f-matrix”*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：绘制矩阵中点的输出，称为“f-矩阵”*'
- en: When we learn about matrices in school, we learn how to add and multiply them,
    but we never learn why. It’s only when you graph them that you realize that multiplying
    matrices is *transforming* them. Next, we’ll use matrix multiplication to transform
    our *F*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在学校学习矩阵时，我们学会了如何进行加法和乘法运算，但我们从未学过为什么。只有当你将它们绘制出来时，才会意识到矩阵乘法实际上是在*变换*它们。接下来，我们将使用矩阵乘法来变换我们的*F*。
- en: TRANSFORMING MATRICES
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换矩阵
- en: To see how multiplying matrices lets you transform them, we’ll use a 2 × 2 transformation
    matrix I found on the web (see [Figure 8-4](ch08.xhtml#ch08fig4)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何通过矩阵相乘来进行变换，我们将使用我在网上找到的一个2 × 2的变换矩阵（见[图8-4](ch08.xhtml#ch08fig4)）。
- en: '![image](../images/f154-01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f154-01.jpg)'
- en: '*Figure 8-4: A transformation matrix found online at* `mathworld.wolfram.com`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-4：一个在网上找到的变换矩阵* `mathworld.wolfram.com`'
- en: It’s going to rotate our *F* counterclockwise by an angle, given by theta (θ).
    If the angle is 90 degrees, cos(90) = 0 and sin(90) = 1\. Therefore, the rotation
    matrix for a counterclockwise rotation of 90 degrees is
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它将把我们的*F*逆时针旋转一个角度，角度由θ（θ）给出。如果角度是90度，则cos(90) = 0且sin(90) = 1。因此，逆时针旋转90度的旋转矩阵是
- en: '![image](../images/e154-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e154-01.jpg)'
- en: 'We can create a transformation matrix by adding the following code to *matrices.pyde*
    before the `setup()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`setup()`函数之前，将以下代码添加到*matrices.pyde*文件中来创建一个变换矩阵：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we multiply the f-matrix by the transformation matrix and save the result
    to a new matrix. Since the f-matrix is a 10 × 2 matrix and the transformation
    matrix is 2 × 2, the only way to multiply them is F × T, not T × F.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将f-矩阵与变换矩阵相乘，并将结果保存到一个新矩阵中。由于f-矩阵是10 × 2矩阵，而变换矩阵是2 × 2矩阵，所以它们相乘的唯一方式是F
    × T，而不是T × F。
- en: Remember, the number of columns in the first matrix has to equal the number
    of rows in the second matrix. We’ll graph the f-matrix in black and change the
    stroke color to red for the new matrix. Replace `graphPoints(fmatrix)` by adding
    the following code in [Listing 8-6](ch08.xhtml#ch08list6) to the `draw()` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，第一个矩阵的列数必须等于第二个矩阵的行数。我们将用黑色绘制f-矩阵，并将新矩阵的描边颜色更改为红色。通过将以下代码添加到`draw()`函数中的[清单8-6](ch08.xhtml#ch08list6)来替换`graphPoints(fmatrix)`。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-6: Multiplying the matrices and graphing the points*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-6：矩阵相乘并绘制点*'
- en: When you run this, it will look like [Figure 8-5](ch08.xhtml#ch08fig5).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，它将显示为[图8-5](ch08.xhtml#ch08fig5)。
- en: '![image](../images/f155-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f155-01.jpg)'
- en: '*Figure 8-5: A clockwise rotation?*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-5：顺时针旋转？*'
- en: 'That’s not a counterclockwise rotation! Looking at the math notation in [Figure
    8-4](ch08.xhtml#ch08fig4) again, we see the order of the multiplication is different
    from ours. The accepted way is to multiply by the transformation matrix first
    and then the point(s) to be transformed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是逆时针旋转！再看一下[图8-4](ch08.xhtml#ch08fig4)中的数学表示法，我们发现乘法的顺序与我们的不同。标准的方法是先乘以变换矩阵，再乘以要变换的点：
- en: '![image](../images/e155-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e155-01.jpg)'
- en: This means the transformed vector v (*v'*) is the result of the rotation vector
    R[θ] being multiplied by the initial vector v[0]. Vector notation is different
    from coordinate notation. For instance, the vector that goes 2 in the x-direction
    and 3 in the y-direction is not given as (2,3), like in standard (x,y) coordinates.
    Rather, it’s given as
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着变换后的向量v（*v'*）是通过将旋转矩阵R[θ]与初始向量v[0]相乘得到的。向量表示法不同于坐标表示法。例如，向量在x方向上为2，y方向上为3，不是像标准（x，y）坐标那样给出为（2,3）。相反，它表示为
- en: '![image](../images/e155-02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e155-02.jpg)'
- en: like a 2 × 1 matrix, instead of a 1 × 2 matrix. In our list notation, we’d write
    that as `[[2],[3]]`. That means we have to change our f-matrix to
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它像一个2 × 1矩阵，而不是1 × 2矩阵。在我们的列表表示法中，我们会将其写作`[[2],[3]]`。这意味着我们需要将我们的f-矩阵更改为
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first example at least keeps the x- and y-values of a point together, but
    that’s a lot of brackets! The second doesn’t even keep the x- and y-values next
    to each other. Let’s see if there’s another way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子至少能保持点的 x 和 y 值在一起，但这有很多括号！第二个例子甚至没有将 x 和 y 值放在一起。我们来看看是否有其他方法。
- en: '### TRANSPOSING MATRICES'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '### 转置矩阵'
- en: An important concept in matrices is *transposition*, where the columns become
    the rows, and vice versa. In our example, we want to change *F* into *F^T*, the
    notation for “the f-matrix, transposed.”
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵中，一个重要的概念是 *转置*，即将列变成行，反之亦然。在我们的例子中，我们想将 *F* 转换成 *F^T*，即“f 矩阵的转置”。
- en: '![image](../images/e156-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e156-01.jpg)'
- en: Let’s write a `transpose()` function that will transpose any matrix. Add the
    code in [Listing 8-7](ch08.xhtml#ch08list7) to *matrices.pyde* after the `draw()`
    function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 `transpose()` 函数，它将转置任何矩阵。将 [列表 8-7](ch08.xhtml#ch08list7) 中的代码添加到 *matrices.pyde*
    的 `draw()` 函数后面。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-7: The code to transpose a matrix*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：转置矩阵的代码*'
- en: First, we create an empty list called `output` that will be the transposed matrix.
    We then define `m`, the number of rows in the matrix, and `n`, the number of columns.
    We’re going to make output into an `n` × `m` matrix. For all `n` rows, we’re going
    to start an empty list, and then everything in the `i`th row of the matrix we
    add to the `j`th column of the transposed matrix.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `output` 的空列表，它将是转置后的矩阵。接着，我们定义 `m`，矩阵的行数，以及 `n`，矩阵的列数。我们将把 output
    变成一个 `n` × `m` 的矩阵。对于所有 `n` 行，我们将开始一个空列表，然后将矩阵中第 `i` 行的所有内容添加到转置矩阵的第 `j` 列。
- en: 'The following line of code in the `transpose` function switches the rows and
    columns of `a`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`transpose` 函数中的以下代码行交换了 `a` 的行和列：'
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we return the transposed matrix. Let’s test it out. Add the `transpose()`
    function to your *matrices.py* file and run it. Then we can enter the following
    code in the shell:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回转置后的矩阵。让我们测试一下。将 `transpose()` 函数添加到你的 *matrices.py* 文件中并运行它。然后我们可以在
    shell 中输入以下代码：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It works! All we’ll have to do is transpose our f-matrix before multiplying
    it by the transformation matrix. To graph it, we’ll transpose it back, as shown
    in [Listing 8-8](ch08.xhtml#ch08list8).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！我们需要做的就是在将 f 矩阵与变换矩阵相乘之前对其进行转置。为了绘制它，我们会将其转置回去，如 [列表 8-8](ch08.xhtml#ch08list8)
    中所示。
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-8: Transposing a matrix, multiplying, and then transposing again*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：转置矩阵、相乘，然后再转置*'
- en: Add the calls to the `transpose()` ➋ function to the `newmatrix` line ➊ of the
    `draw()` function. This should get you the correct counterclockwise rotation,
    as shown in [Figure 8-6](ch08.xhtml#ch08fig6).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `transpose()` ➋ 函数的调用添加到 `draw()` 函数的 `newmatrix` 行 ➊。这样应该能获得正确的逆时针旋转，如 [图
    8-6](ch08.xhtml#ch08fig6) 所示。
- en: '![image](../images/f157-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f157-01.jpg)'
- en: '*Figure 8-6: A counterclockwise rotation, by matrices*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：通过矩阵进行逆时针旋转*'
- en: The final code for *matrices.pyde* should look like [Listing 8-9](ch08.xhtml#ch08list9).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 *matrices.pyde* 代码应如下所示 [列表 8-9](ch08.xhtml#ch08list9)。
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-9: The entire code to draw and transform the letter* `F`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-9：绘制并变换字母* `F` *的完整代码*'
- en: 'EXERCISE 8-1: MORE TRANSFORMATION MATRICES'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8-1：更多的变换矩阵
- en: 'See what happens to your shape when you change your transformation matrix to
    each of these matrices:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当你将变换矩阵改为这些矩阵时，形状会发生什么变化：
- en: '![image](../images/e159-01.jpg) ### ROTATING MATRICES IN REAL TIME'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e159-01.jpg) ### 实时旋转矩阵'
- en: So you just learned how matrices can transform points. But this can happen in
    real time, and interactively too! Change the code in the `draw()` function in
    *matrices.pyde* to what’s in [Listing 8-10](ch08.xhtml#ch08list10).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你刚刚学到了矩阵如何变换点。但这个过程可以实时进行，也可以进行交互式操作！将 *matrices.pyde* 中 `draw()` 函数的代码更改为
    [列表 8-10](ch08.xhtml#ch08list10) 中的内容。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-10: Rotating in real time using matrices*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-10：使用矩阵实时旋转*'
- en: 'Recall that we used `sin()` and `cos()` in [Chapter 7](ch07.xhtml#ch07) to
    rotate and oscillate shapes. In this example, we’re transforming a matrix of points
    using a rotation matrix. Here is what a typical 2 × 2 rotation matrix looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在 [第 7 章](ch07.xhtml#ch07) 中使用了 `sin()` 和 `cos()` 来旋转和振荡形状。在这个例子中，我们正在使用旋转矩阵变换一个点的矩阵。这里是一个典型的
    2 × 2 旋转矩阵的样子：
- en: '![image](../images/e160-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e160-01.jpg)'
- en: Because I don’t have a theta (θ) key, I’ll call the rotation angle `ang`. The
    interesting thing we’re doing right now is changing the `ang` variable with the
    mouse. So, at every loop, the mouse position determines the value of `ang` and
    then plugs `ang` into each expression. It then quickly calculates the sine and
    cosine of `ang` and multiplies the rotation matrix by the f-matrix. For each loop,
    the rotation matrix will be a little different, depending on where your mouse
    is.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有 θ（θ）键，我将旋转角度称为`ang`。我们现在做的有趣的事情是通过鼠标改变`ang`变量。因此，在每次循环时，鼠标位置决定`ang`的值，然后将`ang`代入每个表达式。它快速计算`ang`的正弦和余弦，并将旋转矩阵与f矩阵相乘。每次循环时，旋转矩阵会略有不同，具体取决于鼠标的位置。
- en: '![image](../images/f160-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f160-01.jpg)'
- en: '*Figure 8-7: Transforming points in real time using matrices!*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：使用矩阵实时变换点！*'
- en: Now the red *F* should rotate around the origin as you move your mouse left
    and right over the graph, as shown in [Figure 8-7](ch08.xhtml#ch08fig7).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在图表上左右移动鼠标时，红色的*F*应该围绕原点旋转，如[图 8-7](ch08.xhtml#ch08fig7)所示。
- en: This is the kind of transformation that’s happening all the time when you see
    any kind of animation on a computer screen. Creating computer graphics is perhaps
    the most common application of matrices.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在计算机屏幕上看到任何动画时发生的变换。创建计算机图形学可能是矩阵最常见的应用。
- en: '### CREATING 3D SHAPES'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### 创建3D形状'
- en: So far we used matrices to create and manipulate two-dimensional shapes. You
    might be curious as to how we mathematicians crunch the numbers to represent a
    three-dimensional object on a two-dimensional surface like the computer screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用矩阵创建和操作二维形状。你可能会好奇，我们数学家是如何计算数字，将三维物体表示在像计算机屏幕这样的二维表面上的。
- en: 'Return to your code in [Listing 8-11](ch08.xhtml#ch08list11) and save it as
    *matrices3D.pyde*. Turn `fmatrix` into the following matrix of points:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 返回[清单 8-11](ch08.xhtml#ch08list11)中的代码，并将其保存为*matrices3D.pyde*。将`fmatrix`转换为以下点矩阵：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-11: A 3D version of our f-matrix*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：我们f矩阵的3D版本*'
- en: Adding depth to our *F* requires adding another layer to our matrix of points.
    Because our *F* only has two dimensions right now, it’s made up of only x- and
    y-values. But we can think of 2D objects as having a third dimension, represented
    by a z-axis. 2D objects have a z-value of 0\. So for each point we’ll add a zero
    as its third value, making the first 10 points three-dimensional. Then we’ll copy
    and paste these values and change the third value to a 1\. This creates the rear
    layer, which is an identical *F* drawn one unit behind the front one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的*F*添加深度需要向我们的点矩阵中添加另一个层。因为我们的*F*现在只有二维，所以它只由x和y值组成。但是我们可以将二维物体视为具有第三维度，表示为z轴。二维物体的z值为0。因此，对于每个点，我们将添加一个零作为其第三个值，使前10个点成为三维。然后，我们将这些值复制粘贴，并将第三个值更改为1。这将创建后层，这是一个与前层*F*相同的图形，且位于前层后面一个单位。
- en: Now that we’ve created the two layers for the *F*, we need to connect the points
    on the front layer with those on the rear layer. Let’s create an `edges` list
    so we can simply tell the program which points to link with line segments, as
    shown in [Listing 8-12](ch08.xhtml#ch08list12).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为*F*创建了两个层，我们需要将前层的点与后层的点连接起来。我们创建一个`edges`列表，这样就可以简单地告诉程序要用线段连接哪些点，如[清单
    8-12](ch08.xhtml#ch08list12)所示。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 8-12: Keeping track of the edges (the lines between the points on
    the* `F`)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-12：跟踪边（点与点之间的线*`F`）'
- en: This is a way to keep track of which points are going to be connected with segments,
    or *edges*. For example, the first entry `[0,1]` draws an edge from point 0 (0,0,0)
    to point 1 (1,0,0). The first 10 edges draw the front *F*, and the next 10 edges
    draw the rear *F*. Then we draw edges between a point on the front *F* and the
    corresponding point on the rear *F*. For example, edge `[0,10]` draws a segment
    between point 0 (0,0,0) and point 10 (0,0,1).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是跟踪哪些点将被线段连接的方式，或称为*边*。例如，第一个条目`[0,1]`从点0（0,0,0）到点1（1,0,0）画一条边。前10条边画出前*F*，接下来的10条边画出后*F*。然后我们画出连接前*F*上的点与后*F*上相应点之间的边。例如，边`[0,10]`画出点0（0,0,0）与点10（0,0,1）之间的线段。
- en: Now when we’re graphing the points, we’re not just drawing lines between every
    consecutive point. [Listing 8-13](ch08.xhtml#ch08list13) shows the new `graphPoints()`
    function that graphs the *edges* between the points in the list. Replace the old
    `graphPoints()` function with the following code, just before the definition of
    the `grid()` function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在绘制这些点时，我们不仅仅是在相邻的点之间绘制线条。[列表 8-13](ch08.xhtml#ch08list13) 显示了新的 `graphPoints()`
    函数，它绘制了列表中点与点之间的 *边缘*。将旧的 `graphPoints()` 函数替换为以下代码，放在 `grid()` 函数的定义之前。
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-13: Graphing points using the edges*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-13：使用边缘绘制点*'
- en: 'Remember that in Processing you draw a line between two points, (x1,y1) and
    (x2,y2), by using `line(x1,y1,x2,y2)`. Here, we call the points in the `pointList`
    (we’ll send `fmatrix` when we run this) by using their numbers in the `edges`
    list. The function loops over every item, `e`, in the `edges` list and connects
    the point represented by the first number, `e[0]`, to the point represented by
    the second number, `e[1]`. The x-coordinates are multiplied by the `xscl` variable,
    which scales the x-values:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Processing 中，你通过 `line(x1,y1,x2,y2)` 在两个点（x1, y1）和（x2, y2）之间绘制一条线。在这里，我们通过在
    `edges` 列表中的数字来调用 `pointList` 中的点（当我们运行时将传递 `fmatrix`）。该函数会遍历 `edges` 列表中的每个元素
    `e`，并将由第一个数字 `e[0]` 表示的点与由第二个数字 `e[1]` 表示的点连接起来。x 坐标会乘以 `xscl` 变量，这个变量会缩放 x 值：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We do the same for the y-coordinates:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 y 坐标做相同的操作：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can make our mouse represent the angle of rotation again by creating two
    rotation variables: `rot` and `tilt`. The first one, `rot`, maps the x-value of
    the mouse to an angle between 0 and 2π, and that value will go in a rotation matrix
    like the one we made in [Listing 8-5](ch08.xhtml#ch08list5). We do the same for
    `tilt` so it can map the y-value of the mouse. Put the code in [Listing 8-14](ch08.xhtml#ch08list14)
    in the `draw()` function before multiplying the matrices together.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建两个旋转变量：`rot` 和 `tilt`，让鼠标代表旋转角度。第一个变量 `rot` 将鼠标的 x 值映射到 0 到 2π 之间的角度，这个值将放入我们在
    [列表 8-5](ch08.xhtml#ch08list5) 中制作的旋转矩阵中。我们对 `tilt` 做同样的操作，使其能映射鼠标的 y 值。在将矩阵相乘之前，将
    [列表 8-14](ch08.xhtml#ch08list14) 中的代码放入 `draw()` 函数中。
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-14: Linking the up-down and left-right rotations with the movements
    of the mouse*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-14：将上下和左右旋转与鼠标移动关联起来*'
- en: Next, we’ll create a function to multiply the rotation matrices together so
    that all our transformations can be consolidated into one matrix. This is the
    great thing about using matrix multiplication to perform transformations. You
    can just keep “adding” more transformations simply by multiplying!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数，将旋转矩阵相乘，以便将所有的变换合并到一个矩阵中。这就是使用矩阵乘法执行变换的优点。你只需要通过乘法不断“添加”更多的变换！
- en: CREATING THE ROTATION MATRIX
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建旋转矩阵
- en: Now let’s make a single rotation matrix out of two individual matrices. If you
    see 3D rotation matrices in a math book, they may look like the following equations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将两个单独的旋转矩阵合并成一个单一的旋转矩阵。如果你在数学书中看到 3D 旋转矩阵，它们可能会像以下方程那样：
- en: '![image](../images/e163-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e163-01.jpg)'
- en: '*R*[y]() will rotate the points, with the y-axis serving as the axis of rotation,
    so it’s a left/right rotation. *R*[x]() will rotate the points around the x-axis,
    so it’ll be an up-down rotation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*[y]() 会旋转这些点，y 轴作为旋转轴，所以这是一个左右旋转。*R*[x]() 会围绕 x 轴旋转这些点，因此它是一个上下旋转。'
- en: 'Listing 8-15 shows the code for creating the `rottilt()` function, which will
    take the `rot` and `tilt` values and put them into the matrices. This is how we
    combine two matrices into one. Add the code in [Listing 8-15](ch08.xhtml#ch08list15)
    to *matrices3D.pyde*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-15 显示了创建 `rottilt()` 函数的代码，该函数将接收 `rot` 和 `tilt` 值，并将它们放入矩阵中。这就是我们如何将两个矩阵合并成一个矩阵。将
    [列表 8-15](ch08.xhtml#ch08list15) 中的代码添加到 *matrices3D.pyde* 文件中：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-15: Function for creating the rotation matrix*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-15：创建旋转矩阵的函数*'
- en: 'We multiply `rotmatrix_Y` and `rotmatrix_X` to get one rotation matrix as output.
    This is useful when there’s a series of matrix operations, such as rotate about
    the x-axis *R[x]*, rotate about the y-axis *R[y]*, scale *S*, and translate *T*.
    Instead of performing a separate multiplication for each operation, we can combine
    all these operations in a single matrix. Matrix multiplication allows us to create
    a new matrix: *M* = *R[y]*(*R[x]*(*S*(*T*))). That means our `draw()` function
    will change, too. With the new additions above, the `draw()` function should look
    like [Listing 8-16](ch08.xhtml#ch08list16):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`rotmatrix_Y`和`rotmatrix_X`相乘，得到一个旋转矩阵作为输出。当有一系列矩阵操作时，这非常有用，比如围绕 x 轴旋转*R[x]*，围绕
    y 轴旋转*R[y]*，缩放*S*，平移*T*。我们可以将所有这些操作合并到一个矩阵中，而不是为每个操作执行单独的乘法。矩阵乘法使我们能够创建一个新的矩阵：*M*
    = *R[y]*(*R[x]*(*S*(*T*)))。这意味着我们的`draw()`函数也会改变。通过上述新增内容，`draw()`函数应该像[清单 8-16](ch08.xhtml#ch08list16)中所示：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 8-16: The new* `draw()` *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-16：新的* `draw()` *函数*'
- en: When you run the program, you get what’s shown in [Figure 8-8](ch08.xhtml#ch08fig8).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到[图 8-8](ch08.xhtml#ch08fig8)中显示的内容。
- en: '![image](../images/f164-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f164-01.jpg)'
- en: '*Figure 8-8: A 3D* `F`!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：一个 3D* `F`！'
- en: We can remove the blue grid and make the *F* bigger by changing the `xmin`,
    `xmax`, `ymin`, and `ymax` variables and commenting out the call to the `grid()`
    function in `draw()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以去掉蓝色网格，并通过更改`xmin`、`xmax`、`ymin`和`ymax`变量，以及注释掉`draw()`中对`grid()`函数的调用来增大*F*的尺寸。
- en: Listing 8-17 shows the full code for drawing a rotating 3D shape.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-17 展示了绘制旋转 3D 形状的完整代码。
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-17: The full code for rotating the 3D* `F`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-17：旋转 3D* `F`的完整代码'
- en: I got rid of the grid and changed the call to the `background()` function in
    `draw()` to `background(0)`, so the background will be black and the *F* will
    appear to be rotating in outer space (see [Figure 8-9](ch08.xhtml#ch08fig9))!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我去掉了网格，并将`draw()`函数中对`background()`函数的调用更改为`background(0)`，这样背景会变为黑色，*F*将看起来在外太空中旋转（见[图
    8-9](ch08.xhtml#ch08fig9)）！
- en: '![image](../images/f166-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f166-01.jpg)'
- en: '*Figure 8-9: Moving your mouse around will transform the* `F`!'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：移动鼠标将使* `F` *发生变化！*'
- en: SOLVING SYSTEMS OF EQUATIONS WITH MATRICES
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用矩阵解线性方程组
- en: 'Have you ever tried solving a system of equations with two or three unknown
    values? That’s a tricky task for any math student. And as the number of unknowns
    increases, the more complicated the system of equations gets to solve. Matrices
    are very useful for solving systems of equations like this one:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经尝试过解一个有两个或三个未知数的方程组？对于任何数学学生来说，这是一个棘手的任务。随着未知数的增加，方程组变得更加复杂。矩阵在解决这种方程组时非常有用：
- en: '![image](../images/e166-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e166-01.jpg)'
- en: 'For example, you can express this multiplication using matrices:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用矩阵表示这种乘法：
- en: '![image](../images/e166-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e166-02.jpg)'
- en: This looks similar to the algebra equation 2*x* = 10, which we can solve easily
    by dividing both sides by 2\. If only we could divide both sides of our system
    by the matrix on the left!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来类似于代数方程 2*x* = 10，我们可以通过将两边同时除以 2 来轻松求解。如果我们能将系统的两边都除以左边的矩阵就好了！
- en: In fact, there is a way to do just that by finding the inverse of a matrix,
    the same way you can divide a number by 2 by multiplying it by ½. This is known
    as the *multiplicative inverse* of 2, but it’s a complicated method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一种方法可以做到这一点，即通过求矩阵的逆，类似于你可以通过乘以 ½ 来将一个数字除以 2。这被称为 2 的*乘法逆*，但它是一种复杂的方法。
- en: GAUSSIAN ELIMINATION
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高斯消元法
- en: 'The more efficient way to solve a system of equations using matrices is to
    use row operations to transform the 2 × 2 matrix on the left into the *identity
    matrix*, which is the matrix that represents the number 1\. For example, multiplying
    a matrix by the identity matrix would result in the original matrix, like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵解线性方程组的更高效方法是使用行变换将左边的 2 × 2 矩阵转换为*单位矩阵*，单位矩阵代表数字 1。例如，将一个矩阵与单位矩阵相乘，结果就是原矩阵，像这样：
- en: '![image](../images/e167-01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e167-01.jpg)'
- en: 'The numbers on the right would be the solutions for *x* and *y*, so getting
    those zeroes and ones in the right place is our goal. The right place is the diagonal
    of the matrix, like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的数字就是*x*和*y*的解，因此我们的目标是将这些零和一放置在正确的位置。正确的位置就是矩阵的对角线，像这样：
- en: '![image](../images/e167-02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e167-02.jpg)'
- en: The identity matrix in every square matrix has a 1 on the diagonal, where the
    row number equals the column number.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方阵中的单位矩阵在对角线上有1，且行号等于列号。
- en: '*Gaussian elimination* is a method that involves doing operations on entire
    rows of matrices in order to get to the identity matrix. You can multiply or divide
    a row by a constant, and you can add or subtract a row from another row.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*高斯消元法*是一种通过对矩阵的整行进行操作来得到单位矩阵的方法。你可以将一行乘以常数或除以常数，也可以将一行加到或从另一行中减去。'
- en: 'Before using Gaussian elimination, we first have to arrange the coefficients
    and constants into one matrix, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用高斯消元法之前，我们首先需要将系数和常数排列成一个矩阵，如下所示：
- en: '![image](../images/e167-03.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e167-03.jpg)'
- en: 'Then, we divide the entire row by the number that will give us a 1 in the top
    left. This means that first we need to divide all the terms in the first row by
    2, since 2/2 is 1\. That operation gives us the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将整个行除以一个数，使得左上角变为1。这意味着我们首先需要将第一行的所有项除以2，因为2/2等于1。这个操作会给我们以下结果：
- en: '![image](../images/e167-04.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e167-04.jpg)'
- en: 'Now we get the *additive inverse* (the number that gives us 0 when added to
    another number) of the term where we want a zero. For example, in row 2, we want
    a zero where the 3 is because we’re looking to change this matrix into the identity
    matrix. Because the additive inverse of 3 is –3, we multiply each term in the
    first row by –3 and add the product to the corresponding term in row 2\. That
    means we multiply the 1 in the first row by –3 and then add the product, which
    is still –3, to the second row. We repeat the process with all the terms in the
    row. For example, the –1/2 in the third column would be multiplied by –3 (to get
    1.5) and added to all the numbers in that column. In this case, it’s just –13,
    so the sum is –11.5 or –23/2\. Continue this, and you should get the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到我们想要零的位置的*加法逆元*（与另一个数相加得到零的数）。例如，在第二行中，我们希望在3的位置得到零，因为我们希望将这个矩阵转化为单位矩阵。由于3的加法逆元是–3，我们将第一行的每一项乘以–3，并将结果加到第二行对应的项上。也就是说，我们将第一行中的1乘以–3，然后将结果（仍然是–3）加到第二行。我们对行中的所有项都执行这个过程。例如，第三列中的–1/2将乘以–3（得到1.5），然后加到该列中的所有数值上。在这种情况下，它是–13，因此和为–11.5或–23/2。继续这个过程，你应该得到以下结果：
- en: '![image](../images/e168-01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-01.jpg)'
- en: 'Now repeat where we want the 1 to be in the second row. We can multiply everything
    in row 2 by –2/23, which should give us this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在第二行中想要得到1的位置重复这个过程。我们可以将第二行中的所有项乘以–2/23，这应该给我们如下结果：
- en: '![image](../images/e168-02.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-02.jpg)'
- en: 'Finally, we add everything in the first row to the second row, multiplied by
    the additive inverse of 5/2, which is where we want the zero to be in the first
    row. We’ll add every term in the first row to its corresponding term in the second
    row multiplied by –5/2\. Notice this doesn’t affect the 1 in the first row, which
    we want to keep:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将第一行的所有项加到第二行，乘以5/2的加法逆元，这样就能在第一行得到零。我们将第一行的每一项加到对应的第二行项，乘以–5/2。注意，这不会影响第一行中的1，我们希望保留这个1：
- en: '![image](../images/e168-03.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-03.jpg)'
- en: 'The solutions to the system of equations are now in the right column: *x* =
    –3, *y* = 1.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 方程组的解现在在右边的列中：*x* = –3，*y* = 1。
- en: 'We can check our answers by plugging those numbers into the original system
    of equations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将这些数值代入原方程组来检查我们的答案：
- en: '![image](../images/e168-04.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-04.jpg)'
- en: Both solutions are correct, but this is a laborious process. Let’s automate
    this process with Python so we can solve systems that are as big as we want!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 两个解都是正确的，但这个过程非常繁琐。让我们使用Python来自动化这个过程，这样我们就可以解决任意大小的方程组了！
- en: WRITING THE GAUSS() FUNCTION
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写GAUSS()函数
- en: 'In this section, we write a function called `gauss()` that solves systems of
    equations for us. Trying to do this programmatically might seem complicated, but
    there are really only two steps that we need to code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们编写了一个名为`gauss()`的函数，用于为我们解线性方程组。尝试通过编程来实现这个过程看起来可能很复杂，但实际上我们只需要编码两个步骤：
- en: Divide all the elements in a row by the term in the diagonal.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行中的所有元素除以对角线上的元素。
- en: Add each term in one row to the corresponding term in another row.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一行中的每一项加到另一行中对应的项。
- en: Dividing All Items in a Row
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将一行中的所有项除以常数
- en: The first task is to divide all the terms in a row by a number. Let’s say we
    have the row of numbers `[1,2,3,4,5]`. For example, we can use the code in [Listing
    8-18](ch08.xhtml#ch08list18) to divide this row by 2\. Open a new Python file,
    call it *gauss.py* and enter the code in [Listing 8-18](ch08.xhtml#ch08list18).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是将一行中的所有项除以一个数。假设我们有一行数字 `[1,2,3,4,5]`。例如，我们可以使用 [Listing 8-18](ch08.xhtml#ch08list18)
    中的代码将此行除以 2。打开一个新的 Python 文件，命名为 *gauss.py* 并输入 [Listing 8-18](ch08.xhtml#ch08list18)
    中的代码。
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-18: Dividing all the terms in a row by a divisor*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-18: 将每一行的所有项除以一个除数*'
- en: 'This loops over the `row` list, keeping track of the index and the value using
    the `enumerate()` function. We then replace each term `row[i]` with the term divided
    by the divisor. When you run this, you’ll get a list of five values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历 `row` 列表，使用 `enumerate()` 函数跟踪索引和值。然后，我们将每个项 `row[i]` 用除数除过的结果替换。当你运行它时，你将得到一个包含五个值的列表：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding Each Element to Its Corresponding Element
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将每个元素加到其对应元素上
- en: 'The second task is to add each element of one row to the corresponding element
    in the other row. For example, add all the elements in row 0 below to the elements
    in row 1 and replace the elements in row 1 with the sum:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务是将一行中的每个元素与另一行中相应的元素相加。例如，将第 0 行下面的所有元素加到第 1 行的元素上，并用和替换第 1 行的元素：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’re looping over all the items in the second row (index 1) of `my_matrix`.
    Then we’re incrementing each term (index `i`) in the second row by the corresponding
    term in the first row (index 0). We successfully added the terms in the first
    row to those in the second row. Notice the first row didn’t change. We’ll use
    these steps in solving systems of equations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在循环遍历 `my_matrix` 的第二行（索引 1）中的所有项。然后我们将第二行中的每个项（索引 `i`）递增，增加对应第一行（索引 0）中的项。我们成功地将第一行的项加到第二行的项上。请注意，第一行没有改变。我们将在解线性方程组时使用这些步骤。
- en: Repeating the Process for Every Row
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对每一行重复这个过程
- en: 'Now we just have to put those steps together for all the rows in a matrix.
    We’ll call the matrix *A*. Once we’ve put the *x, y*, and *z*’s and the constant
    terms in order, we put only the coefficients and the constants into the matrix:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将这些步骤组合在一起，应用到矩阵中的所有行。我们将矩阵命名为 *A*。一旦我们把 *x, y* 和 *z* 的系数以及常数项排好顺序，我们只需将系数和常数项放入矩阵中：
- en: '![image](../images/e169-01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e169-01.jpg)'
- en: First, we divide every term in the row by the term on the diagonal so that the
    diagonal term will be 1, using the code in [Listing 8-19](ch08.xhtml#ch08list19).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将行中的每个项除以对角线上的项，使得对角线项变为 1，使用 [Listing 8-19](ch08.xhtml#ch08list19) 中的代码。
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 8-19: Dividing every term in a row by the row’s diagonal term*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-19: 将每个项除以该行的对角线项*'
- en: Using `enumerate`, we can get the first row of *A* (`[2,1,-1,8]`), for example,
    and `j` will be the index of that row (in this case, zero). The diagonal terms
    are where the row number is the same as the column number, like row 0, column
    0, or row 1, column 1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `enumerate`，我们可以获取 *A* 的第一行（例如 `[2,1,-1,8]`），并且 `j` 将是该行的索引（在这种情况下为零）。对角线项是行号与列号相同的地方，比如第
    0 行、第 0 列，或者第 1 行、第 1 列。
- en: Now we go through every other row in the matrix and perform the second step.
    Now, for each of the other rows (where `i` is not equal to `j`), calculate the
    additive inverse of the `j`th term, multiply each term in row `j` by that inverse,
    and add those terms to their corresponding terms in the `i`th row. Add the code
    in [Listing 8-20](ch08.xhtml#ch08list20) to the `gauss()` function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遍历矩阵中的每个其他行，执行第二步。对于每个其他行（其中 `i` 不等于 `j`），计算 `j` 项的加法逆元，将该逆元乘以第 `j` 行中的每一项，并将这些项加到对应的第
    `i` 行中的项上。将 [Listing 8-20](ch08.xhtml#ch08list20) 中的代码添加到 `gauss()` 函数中。
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 8-20: Making every nondiagonal term in a row 0*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-20: 将每行的非对角线项变为 0*'
- en: 'This happens to every row, so since m is the number of rows, we start off with
    `for i in range(m)`. We already divided the row in question by the diagonal term,
    so we don’t have to do anything to that row. That’s why we do it only if `i` is
    not equal to `j`. In our example, each term in the first row of A is going to
    be multiplied by 3 and added to the corresponding term in the second row. And
    then every term in the first row is going to be multiplied by 2 and added to the
    corresponding term in the third row. That will get us zeroes in the second and
    third rows of the first column:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这会发生在每一行，因此由于 m 是行数，我们从 `for i in range(m)` 开始。我们已经将相关行除以对角线上的元素，因此无需对该行进行其他操作。也正因如此，只有当
    `i` 不等于 `j` 时我们才会进行操作。在我们的示例中，A 的第一行中的每个元素将乘以 3 并加到第二行的相应元素上。然后，第一行中的每个元素将乘以 2
    并加到第三行的相应元素上。这将使得第一列的第二行和第三行变为零：
- en: '![image](../images/e170-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e170-01.jpg)'
- en: Now our first column is done, and we want a 1 in the diagonal. Therefore, we
    want a 1 in the second row of the second column, so we repeat the process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的第一列已经完成，我们希望对角线上的值是 1。因此，我们希望第二列第二行的值为 1，于是我们重复这一过程。
- en: Putting It All Together
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Put all the code together into a `gauss()` function and print out the results.
    [Listing 8-21](ch08.xhtml#ch08list21) shows the complete code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有代码整合成一个 `gauss()` 函数，并输出结果。[清单 8-21](ch08.xhtml#ch08list21) 显示了完整代码。
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 8-21: The complete code for the* `gauss()` *function*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-21：完整的 `gauss()` 函数代码*'
- en: 'The output should be the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here is how it looks in matrix form:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是矩阵形式的表现：
- en: '![image](../images/e171-01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e171-01.jpg)'
- en: 'We look at the last numbers in each row, so our solutions are *x* = 32, *y* =
    –17, and *z* = 39\. We check this by plugging those values into the original equations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看每行的最后一个数字，因此我们的解是 *x* = 32, *y* = –17 和 *z* = 39。我们通过将这些值代入原始方程来检查：
- en: '![image](../images/e171-02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e171-02.jpg)'
- en: This is a major achievement! Now, not only can we solve systems of two or three
    unknowns, but we can also solve for any number of unknowns! Solving a system of
    four unknowns is a laborious task if the student doesn’t know Python. But luckily
    for us, we do! When the correct solution pops up so quickly in the Python shell,
    I’m always blown away. If you’ve ever had to perform Gaussian elimination by hand,
    Exercise 8-2 will blow you away too.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的成就！现在，我们不仅能解两元或三元的方程组，还能解任意数量未知数的方程组！如果学生不知道 Python，解四元方程组是一项繁重的任务。但幸运的是，我们知道！当正确的解答迅速出现在
    Python 命令行中时，我总是感到震惊。如果你曾经手动执行过高斯消元法，练习 8-2 也会让你震撼。
- en: 'EXERCISE 8-2: ENTER THE MATRIX'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8-2：进入矩阵
- en: 'Solve this system of equations for *w, x, y*, and *z* using the program you
    just wrote:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你刚才编写的程序解这个方程组的 *w, x, y* 和 *z*：
- en: '![image](../images/e172-01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e172-01.jpg)'
- en: SUMMARY
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: You’ve come a long way in your math adventure! You started with some basic Python
    to make turtles walk around and then went on to create more complicated Python
    functions to solve harder math problems. In this chapter, not only did you learn
    how to use Python to add and multiply matrices, but you also experienced first-hand
    how matrices can create an transform 2D and 3D graphics! The power we have to
    add, multiply, transpose, and otherwise operate on matrices using Python is mind-boggling.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你在数学探险的旅程中走了很长一段路！你从一些基本的 Python 开始，做一些简单的海龟图形操作，然后逐步创建更复杂的 Python 函数来解决更难的数学问题。在本章中，你不仅学会了如何使用
    Python 来加法和乘法矩阵，还亲身体验了矩阵如何创建并转换 2D 和 3D 图形！我们使用 Python 来加法、乘法、转置以及进行其他矩阵操作的能力真是让人叹为观止。
- en: You also learned to automate the process you would have done by hand to solve
    a system of equations. The same program that works for a 3 × 3 matrix will also
    work for a 4 × 4 or any larger square matrix!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了自动化你本来会手动完成的过程，以求解一个方程组。适用于 3 × 3 矩阵的同一个程序也能用于 4 × 4 或任何更大的方阵！
- en: Matrices are vital tools in making a neural network, with dozens or even hundreds
    of paths leading to and from virtual neurons. An input is “propagated” through
    the network using matrix multiplication and transposition, the same tools you
    created in this chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是构建神经网络的关键工具，神经网络中有数十个甚至数百条路径连接虚拟神经元。输入通过矩阵乘法和转置在网络中“传播”，这些正是你在本章中创建的工具。
- en: There was a time when what you’ve done in this chapter was out of reach to anyone
    who didn’t have access to an enormous, expensive computer that took up a whole
    floor at a university or major corporation. Now you can perform lightning-fast
    matrix calculations using Python and visualize the results using Processing!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，像你在本章所做的事情，对于没有访问庞大昂贵计算机的人来说是遥不可及的，那些计算机需要占用大学或大型企业整整一层楼的空间。而现在，你可以使用Python进行高速的矩阵计算，并通过Processing可视化结果！
- en: In this chapter, I pointed out how great it is that we get instantaneous solutions
    to our complicated systems of equations as well as immediate responses to our
    mouse movements in our exploration of graphics. In the next chapter, we’ll create
    a model of an ecosystem containing grass and sheep and let it run on its own.
    The model will morph and change over time as the sheep are born, eat, reproduce,
    and die. Only after letting the model run for a minute or more will we be able
    to judge if the environment can find a balance between grass growing and sheep
    eating and multiplying.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我指出了我们能够即时获得复杂方程组的解，以及在探索图形时可以即时响应鼠标移动的优势。在下一章，我们将创建一个包含草和羊的生态系统模型，并让它自行运行。随着羊的出生、吃草、繁殖和死亡，模型将随时间变化。只有在让模型运行一分钟或更长时间后，我们才能判断环境是否能够在草生长和羊吃草、繁殖之间找到平衡。
