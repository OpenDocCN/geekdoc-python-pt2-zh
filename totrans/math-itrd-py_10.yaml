- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: USING MATRICES FOR COMPUTER GRAPHICS AND SYSTEMS OF EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用矩阵进行计算机图形学和方程组解法
- en: '*“I am large, I contain multitudes.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我很庞大，我包含了无数种类。”*'
- en: —Walt Whitman, from “Song of Myself”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——沃尔特·惠特曼，《我自己的歌》*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: In math class, students are taught how to add, subtract, and multiply matrices
    without ever learning how they’re really used. This is too bad because matrices
    allow us to easily group together large collections of items and simulate coordinates
    of an object from multiple perspectives, making them useful in machine learning
    and absolutely crucial to 2D and 3D graphics. In other words, without matrices,
    there would be no video games!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学课上，学生们被教导如何加、减和乘矩阵，却从未学习过它们的真正用途。这很可惜，因为矩阵可以让我们轻松地将大量项归组在一起，并模拟物体从多个视角的坐标，使其在机器学习中非常有用，且在2D和3D图形中至关重要。换句话说，如果没有矩阵，就没有视频游戏！
- en: To understand how matrices are useful for creating graphics, you first need
    to understand how to perform arithmetic on them. In this chapter, you review how
    to add and multiply matrices so that you can create and transform 2D and 3D objects
    in Processing. Finally, you learn how to solve large systems of equations instantaneously
    using matrices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解矩阵在图形创建中的应用，首先需要了解如何对矩阵进行运算。在本章中，你将复习如何加法和乘法运算矩阵，从而能够在Processing中创建和转换2D与3D物体。最后，你将学习如何使用矩阵瞬间解算大型方程组。
- en: '### WHAT IS A MATRIX?'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### 什么是矩阵？'
- en: A *matrix* is a rectangular array of numbers that have specific rules for operating
    on them. [Figure 8-1](ch08.xhtml#ch08fig1) shows what a matrix looks like.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵*是一个由数字组成的矩形数组，具有特定的运算规则。[图 8-1](ch08.xhtml#ch08fig1)显示了矩阵的样子。'
- en: '![image](../images/f146-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f146-01.jpg)'
- en: '*Figure 8-1: Matrices have* m *rows and* n *columns*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：矩阵有* m *行和* n *列*'
- en: 'Here, the numbers are arranged in rows and columns, where *m* and *n* represent
    the total number of rows and columns, respectively. You can have a 2 × 2 matrix,
    with two rows and two columns, like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字被排列成行和列，其中*m*和*n*分别表示行数和列数的总和。你可以拥有一个2 × 2的矩阵，包含两行两列，像这样：
- en: '![image](../images/e146-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e146-01.jpg)'
- en: 'Or you can have a 3 × 4 matrix with three rows and four columns, like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以拥有一个3 × 4的矩阵，它有三行四列，像这样：
- en: '![image](../images/e146-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e146-02.jpg)'
- en: Traditionally, we use the letter *i* to represent the row number and the letter
    *j* to represent the column number. Note that the numbers in a matrix aren’t being
    added to each other; they’re just arranged together. This is similar to how we
    arrange coordinates using the format (x,y), but you don’t operate on coordinates.
    For example, a point at (2,3) doesn’t mean you add or multiply 2 and 3; they just
    sit next to each other and tell you where the point is located on a graph. But
    as you’ll soon see, you *can* add, subtract, and multiply two matrices just like
    you can normal numbers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们用字母*i*表示行号，用字母*j*表示列号。请注意，矩阵中的数字并不是彼此相加；它们只是被排列在一起。这类似于我们使用格式(x,y)来排列坐标，但你不会对坐标进行运算。例如，坐标点(2,3)并不意味着你要加或乘2和3；它们只是并排显示，告诉你点在图表中的位置。但是，正如你很快会看到的，你*可以*像对待普通数字一样加、减、乘矩阵。
- en: ADDING MATRICES
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵相加
- en: 'You can only add and subtract matrices of the same dimensions (size and shape),
    which means that you can add or subtract only the *corresponding elements*. Here
    is an example of how to add two 2 × 2 matrices:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能加减相同尺寸（大小和形状）的矩阵，这意味着你只能加减*对应的元素*。下面是如何加两个2 × 2矩阵的示例：
- en: '![image](../images/e146-03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e146-03.jpg)'
- en: 'For example, we add 1 and 5 because they are corresponding elements in their
    matrices, meaning they’re in the same spot: the first row, first column. Thus,
    we get 6 in the top-left corner. Adding the corresponding elements 3 and –7 gives
    us –4, as you can see in the bottom-left corner of the result.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将1和5相加，因为它们是矩阵中对应的元素，意味着它们处于相同的位置：第一行，第一列。因此，我们在左上角得到6。将对应的元素3和–7相加得到–4，正如你在结果的左下角看到的那样。
- en: That’s easy enough to put into a Python function since you can save a matrix
    to a variable. Open a new file in IDLE and save it as *matrices.py*. Then write
    the code in [Listing 8-1](ch08.xhtml#ch08list1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易转化为一个Python函数，因为你可以将矩阵保存到变量中。在IDLE中打开一个新文件，并将其保存为*matrices.py*。然后编写[示例 8-1](ch08.xhtml#ch08list1)中的代码。
- en: '*matrices.py*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*matrices.py*'
- en: A = [[2,3],[5,-8]]
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: A = [[2,3],[5,-8]]
- en: B = [[1,-4],[8,-6]]
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: B = [[1,-4],[8,-6]]
- en: 'def addMatrices(a,b):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addMatrices(a,b):'
- en: '''''''adds two 2x2 matrices together'''''''
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''将两个2x2矩阵相加'''''''
- en: C = [[a[0][0]+b[0][0],a[0][1]+b[0][1]],
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C = [[a[0][0]+b[0][0],a[0][1]+b[0][1]],
- en: '[a[1][0]+b[1][0],a[1][1]+b[1][1]]]'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[a[1][0]+b[1][0],a[1][1]+b[1][1]]]'
- en: return C
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: return C
- en: C = addMatrices(A,B)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C = addMatrices(A,B)
- en: print(C)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: print(C)
- en: '*Listing 8-1: Writing the* matrices.py *program to add matrices*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：编写* matrices.py *程序以添加矩阵*'
- en: Here, we declare a couple of 2 × 2 matrices, A and B, using Python’s list syntax.
    For example, A is a list that contains two lists, each of which has two elements.
    We then declare a function called addMatrices(), which takes two matrices as arguments.
    Finally, we create another matrix, C, which adds each element in the first matrix
    to the corresponding element in the second.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 Python 的列表语法声明了几个 2 × 2 的矩阵 A 和 B。例如，A 是一个包含两个列表的列表，每个列表包含两个元素。然后，我们声明了一个名为
    addMatrices() 的函数，它接受两个矩阵作为参数。最后，我们创建了另一个矩阵 C，它将第一个矩阵中的每个元素加上第二个矩阵中对应的元素。
- en: 'When you run this, the output should be something like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，输出应该像这样：
- en: '[[3, -1], [13, -14]]'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3, -1], [13, -14]]'
- en: 'This shows the 2 × 2 matrix that results from adding matrices A and B:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过将矩阵 A 和 B 相加得到的 2 × 2 矩阵：
- en: '![image](../images/e147-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e147-01.jpg)'
- en: Now that you know how to add matrices, let’s try multiplying them, which will
    let you transform coordinates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何加法矩阵了，让我们试着乘法它们，这将让你变换坐标。
- en: MULTIPLYING MATRICES
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Multiplying matrices is much more useful than adding them. For example, you
    can rotate a 2D or 3D shape by multiplying a matrix of (x,y) coordinates by a
    transformation matrix, as you’ll do later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法比矩阵加法更有用。例如，你可以通过将 (x, y) 坐标矩阵与变换矩阵相乘来旋转一个二维或三维形状，正如你将在本章后面做的那样。
- en: 'When multiplying matrices, you don’t simply multiply the corresponding elements.
    Instead, you multiply the elements in each row of the first matrix by the corresponding
    elements in each column of the second matrix. This means that the number of columns
    in the first matrix has to equal the number of rows in the second. Otherwise,
    they can’t be multiplied. For example, the following two matrices can be multiplied:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵乘法中，你不仅仅是将对应的元素相乘。相反，你将第一个矩阵每一行的元素与第二个矩阵每一列的相应元素相乘。这意味着第一个矩阵的列数必须等于第二个矩阵的行数。否则，它们不能相乘。例如，以下两个矩阵可以相乘：
- en: '![image](../images/e148-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-01.jpg)'
- en: 'First, we multiply the elements in the first row of the first matrix (1 and
    2) with the elements in only the first column of the second matrix (5 and 6).
    The sum of those products would become the element in the first row and column
    of the resultant matrix. We do the same for the second row of the first matrix,
    and so on. It would look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将第一个矩阵的第一行（1和2）与第二个矩阵的第一列（5和6）中的元素相乘。所有这些乘积的和将成为结果矩阵中第一行第一列的元素。对第一个矩阵的第二行进行相同的操作，以此类推。结果如下：
- en: '![image](../images/e148-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-02.jpg)'
- en: 'Here is the general formula for multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 2 × 2 矩阵乘以 2 × 2 矩阵的通用公式：
- en: '![image](../images/e148-03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-03.jpg)'
- en: 'We can also multiply the following two matrices, because *A* is a 1 × 4 matrix
    and *B* is a 4 × 2 matrix:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以乘以下列两个矩阵，因为 *A* 是一个 1 × 4 矩阵，*B* 是一个 4 × 2 矩阵：
- en: '![image](../images/e148-04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-04.jpg)'
- en: What will the resultant matrix look like? Well, the first row of *A* will be
    multiplied by the first column of *B* to become the number in the first row, first
    column of the result. It works the same way for the first row, second column.
    The resultant matrix will be a 1 × 2 matrix. You can see when you’re multiplying
    matrices, the elements in the rows of the first matrix are being matched up with
    the elements in the columns of the second matrix. That means the resultant matrix
    will have the number of rows of the first matrix and the number of columns of
    the second matrix.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果矩阵会是什么样子？嗯，*A* 的第一行将与 *B* 的第一列相乘，成为结果中第一行第一列的数字。对于第一行第二列，操作也一样。结果矩阵将是一个 1
    × 2 的矩阵。你可以看到，在矩阵乘法中，第一矩阵的行中的元素与第二矩阵的列中的元素相匹配。这意味着结果矩阵将拥有第一矩阵的行数和第二矩阵的列数。
- en: Now we’ll directly multiply the elements in matrix *A* by their corresponding
    elements in matrix *B* and add all the products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将直接将矩阵 *A* 中的元素与矩阵 *B* 中的相应元素相乘并加总所有乘积。
- en: '![image](../images/e148-05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e148-05.jpg)'
- en: This might seem like a complicated process to have to automate, but as long
    as we have the matrices as input, we can easily find out the number of columns
    and rows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一个复杂的过程，需要自动化，但只要我们有矩阵作为输入，我们就能轻松找出列数和行数。
- en: Listing 8-2 shows a matrix multiplication program in Python that requires a
    bit more work than the addition code. Add this code to *matrices.py*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-2显示了一个矩阵乘法程序，用Python编写，需要比加法代码更多的工作。将此代码添加到 *matrices.py* 中。
- en: 'def multmatrix(a,b):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'def multmatrix(a,b):'
- en: '#Returns the product of matrix a and matrix b'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#返回矩阵a和矩阵b的乘积'
- en: 'm = len(a) #number of rows in first matrix'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'm = len(a) #第一个矩阵的行数'
- en: 'n = len(b[0]) #number of columns in second matrix'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'n = len(b[0]) #第二个矩阵的列数'
- en: newmatrix = []
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix = []
- en: 'for i in range(m):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(m):'
- en: row = []
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: row = []
- en: '#for every column in b'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#对于b的每一列'
- en: 'for j in range(n):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(n):'
- en: sum1 = 0
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: sum1 = 0
- en: '#for every element in the column'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '#对于列中的每一个元素'
- en: 'for k in range(len(b)):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k in range(len(b)):'
- en: sum1 += a[i][k]*b[k][j]
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: sum1 += a[i][k]*b[k][j]
- en: row.append(sum1)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: row.append(sum1)
- en: newmatrix.append(row)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix.append(row)
- en: return newmatrix
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: return newmatrix
- en: '*Listing 8-2: Writing a matrix multiplication function*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-2：编写矩阵乘法函数*'
- en: 'In this example, the multmatrix() function takes two matrices as parameters:
    a and b. Right at the beginning of the function we declare m, the number of rows
    in matrix a, and n, the number of columns in matrix b. We create an empty list
    called newmatrix as the resultant matrix. The “row times column” operation will
    occur m times, so the first loop is for i in range(m), making i repeat m number
    of times. For every row, we add an empty row to newmatrix so we can fill the row
    with n elements. The next loop makes j repeat n times because there are n columns
    in b. The tricky part will be matching up the correct elements, but it just takes
    a little thinking.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，multmatrix()函数接收两个矩阵作为参数：a和b。函数的开始，我们声明m为矩阵a的行数，n为矩阵b的列数。我们创建一个名为newmatrix的空列表作为结果矩阵。“行乘列”操作将执行m次，因此第一个循环是for
    i in range(m)，使得i重复m次。对于每一行，我们向newmatrix添加一个空行，以便将该行填充为n个元素。接下来的循环使得j重复n次，因为b有n列。比较复杂的部分是如何正确地匹配元素，但这只需要稍微思考一下。
- en: Just think of what elements will be multiplied together. When j = 0, we multiply
    the elements in the ith row of a by the first column (index 0) of b, and the product
    becomes the first column in the new row of newmatrix, as you saw in the previous
    example. Then, when j = 1, the same happens to the ith row of a and the second
    column (index 1) of b. That product becomes the second column in the new row of
    newmatrix. This process gets repeated for every row of a.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要考虑哪些元素将被相乘。当j = 0时，我们将a的第i行的元素与b的第一列（索引0）的元素相乘，得到的结果成为newmatrix新行的第一列，正如在前面的示例中看到的那样。接着，当j
    = 1时，a的第i行的元素和b的第二列（索引1）的元素也会进行相乘。这个乘积成为newmatrix新行的第二列。这个过程会对a的每一行重复执行。
- en: 'For every element in the row in matrix a, there’s a corresponding element in
    the column in matrix b. The number of columns of a and the number of rows of b
    are the same, but we can express it as len(a[0]) or len(b). I chose len(b). So
    in the third loop, k will repeat len(b) times. The first element in the ith row
    of a and the first element in the jth column of b will be multiplied together,
    which can be written like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵a中每一行的每一个元素，都有一个对应的矩阵b中的列元素。a的列数和b的行数是相同的，但我们可以表示为len(a[0])或len(b)。我选择了len(b)。因此，在第三个循环中，k会重复len(b)次。a的第i行的第一个元素和b的第j列的第一个元素将被相乘，可以写成如下：
- en: a[i][0] * b[0][j]
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: a[i][0] * b[0][j]
- en: 'The same for the second element in the ith row of a and the second element
    in the jth column of b:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于a的第i行的第二个元素和b的第j列的第二个元素，操作是相同的：
- en: a[i][1] * b[1][j]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: a[i][1] * b[1][j]
- en: 'So for every column (in the j loop), we’ll start a running sum at 0 (because
    sum is already a Python keyword, I use sum1), and it will increment for every
    one of the k elements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每一列（在j循环中），我们会将求和初始值设为0（因为sum已经是Python的关键字，所以我用sum1），并且它会对每一个k元素进行累加：
- en: sum1 += a[i][k] * b[k][j]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: sum1 += a[i][k] * b[k][j]
- en: It doesn’t look like much, but that’s the line that’s going to keep track of
    and multiply all the corresponding elements! After going through all k elements
    (after the k loop is finished), we’ll append the sum to the row, and once we’ve
    gone through all the columns in b (after the j loop is finished), we’ll put that
    row into newmatrix. After going through all the rows in a, we return the resultant
    matrix.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没什么，但这就是那条将跟踪并相乘所有对应元素的代码！在完成所有 k 元素的计算后（即 k 循环结束），我们会将总和添加到行中，一旦遍历完 b 中的所有列（即
    j 循环结束），我们将把这一行放入 newmatrix 中。在遍历完 a 中的所有行后，我们返回结果矩阵。
- en: 'Let’s test this program by multiplying our sample matrices, a 1 × 4 matrix
    by a 4 × 2 matrix:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将我们的示例矩阵测试一下这个程序，将一个 1 × 4 矩阵与一个 4 × 2 矩阵相乘：
- en: '>>> a = [[1,2,-3,-1]]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [[1,2,-3,-1]]'
- en: '>>> b = [[4,-1],'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [[4,-1],'
- en: '[-2,3],'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[-2,3],'
- en: '[6,-3],'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[6,-3],'
- en: '[1,0]]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,0]]'
- en: '>>> print(multmatrix(a,b))'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(multmatrix(a,b))'
- en: '[[-19, 14]]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[[-19, 14]]'
- en: 'This checks out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证无误：
- en: '![image](../images/e150-01a.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e150-01a.jpg)'
- en: 'Therefore, our new function for multiplying any two matrices (if they *can*
    be multiplied) works. Let’s test it by multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的新函数用于相乘任何两个矩阵（如果它们*可以*被相乘）是有效的。让我们通过将一个 2 × 2 矩阵与另一个 2 × 2 矩阵相乘来测试它：
- en: '![image](../images/e150-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e150-01.jpg)'
- en: 'Enter the following to multiply matrix a by matrix b:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容以将矩阵 a 与矩阵 b 相乘：
- en: '>>> a = [[1,-2],[2,1]]'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [[1,-2],[2,1]]'
- en: '>>> b = [[3,-4],[5,6]]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [[3,-4],[5,6]]'
- en: '>>> multmatrix(a,b)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> multmatrix(a,b)'
- en: '[[-7, -16], [11, -2]]'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[[-7, -16], [11, -2]]'
- en: 'The code shows how to enter 2 × 2 matrices using Python lists. The multiplication
    also looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何使用 Python 列表输入 2 × 2 矩阵。乘法也如下所示：
- en: '![image](../images/e150-02.jpg) Let’s check these answers. We begin by multiplying
    the first row of a by the first column of b:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e150-02.jpg) 让我们检查这些答案。我们从将 a 的第一行与 b 的第一列相乘开始：'
- en: (1)(3) + (–2)(5) = 3 – 10 = –7
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (1)(3) + (–2)(5) = 3 – 10 = –7
- en: 'And –7 is the number in the first row, first column of the resultant matrix.
    We next multiply the second row of a by the first column of b:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 而 –7 是结果矩阵中第一行、第一列的数字。接下来，我们将 a 的第二行与 b 的第一列相乘：
- en: (2)(3) + (1)(5) = 6 + 5 = 11
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (2)(3) + (1)(5) = 6 + 5 = 11
- en: And 11 is the number in the second row, first column of the resultant matrix.
    The other numbers are correct, too. The multmatrix() function is going to save
    us from doing a lot of laborious arithmetic!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 而 11 是结果矩阵中第二行、第一列的数字。其他的数字也是正确的。`multmatrix()` 函数将帮我们节省大量繁琐的计算！
- en: ORDER MATTERS IN MATRIX MULTIPLICATION
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵乘法中的顺序很重要
- en: 'An important fact about multiplying matrices is that A × B doesn’t necessarily
    equal B × A. Let’s prove that by reversing our previous example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于矩阵乘法的重要事实是，A × B 并不一定等于 B × A。让我们通过反转之前的示例来证明这一点：
- en: '![image](../images/e151-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e151-01.jpg)'
- en: 'Here’s how to multiply these matrices in the other direction in the Python
    shell:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在 Python shell 中反向相乘这些矩阵的方法：
- en: '>>> a = [[1,-2],[2,1]]'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [[1,-2],[2,1]]'
- en: '>>> b = [[3,-4],[5,6]]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [[3,-4],[5,6]]'
- en: '>>> multmatrix(b,a)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> multmatrix(b,a)'
- en: '[[-5, -10], [17, -4]]'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[[-5, -10], [17, -4]]'
- en: As you can see, when you multiply the same matrices in the reverse order using
    multmatrix(b,a) instead of multmatrix(a,b), you get a completely different resultant
    matrix. Remember that when you’re multiplying matrices, *A × B doesn’t necessarily
    equal B × A*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你使用 `multmatrix(b, a)` 而不是 `multmatrix(a, b)` 来反向相乘相同的矩阵时，你会得到一个完全不同的结果矩阵。记住，在矩阵相乘时，*A
    × B 并不等于 B × A*。
- en: DRAWING 2D SHAPES
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制二维图形
- en: Now that you know how to operate on matrices, let’s put a bunch of points into
    a list to make a 2D shape. Open a new sketch in Processing and save it as *matrices.pyde*.
    If you still have your *grid.pyde* sketch from [Listing 4-11](ch04.xhtml#ch04list11),
    you can copy and paste the essentials for drawing a grid. Otherwise, add the code
    in [Listing 8-3](ch08.xhtml#ch08list3).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何对矩阵进行操作了，让我们将一些点放入列表中来绘制一个二维图形。在 Processing 中打开一个新的草图，并将其保存为 *matrices.pyde*。如果你仍然保留着
    [Listing 4-11](ch04.xhtml#ch04list11) 中的 *grid.pyde* 草图，你可以复制并粘贴绘制网格的必要代码。否则，添加
    [Listing 8-3](ch08.xhtml#ch08list3) 中的代码。
- en: '*matrices.pyde*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*matrices.pyde*'
- en: '#set the range of x-values'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置 x 值的范围'
- en: xmin = -10
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -10
- en: xmax = 10
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 10
- en: '#range of y-values'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#y 值的范围'
- en: ymin = -10
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -10
- en: ymax = 10
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = 10
- en: '#calculate the range'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算范围'
- en: rangex = xmax - xmin
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: rangex = xmax - xmin
- en: rangey = ymax - ymin
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: rangey = ymax - ymin
- en: 'def setup():'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global xscl, yscl
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: size(600,600)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '#the scale factors for drawing on the grid:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制网格时的缩放因子：'
- en: xscl= width/rangex
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: xscl = width/rangex
- en: yscl= -height/rangey
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = -height/rangey
- en: noFill()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: noFill()
- en: 'def draw():'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: 'background(255) #white'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色'
- en: translate(width/2,height/2)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: grid(xscl, yscl)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: grid(xscl, yscl)
- en: 'def grid(xscl,yscl):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grid(xscl,yscl):'
- en: '''''''Draws a grid for graphing'''''''
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''绘制一个用于作图的网格'''''''
- en: '#cyan lines'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#青色线条'
- en: strokeWeight(1)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(1)
- en: stroke(0,255,255)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(0,255,255)
- en: 'for i in range(xmin,xmax+1):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax+1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: 'stroke(0) #black axes'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色坐标轴'
- en: line(0,ymin*yscl,0,ymax*yscl)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,ymin*yscl,0,ymax*yscl)
- en: line(xmin*xscl,0,xmax*xscl,0)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,0,xmax*xscl,0)
- en: '*Listing 8-3: The code for drawing a grid*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-3：绘制网格的代码*'
- en: We’re going to draw a simple figure and transform it using matrices. I’ll use
    the letter *F* because it has no rotational or reflectional symmetry (and because
    it’s my initial). We’ll sketch it out to get the points, as shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个简单的图形并使用矩阵进行变换。我将使用字母*F*，因为它没有旋转或反射对称性（而且因为它是我的首字母）。我们将先画出它的草图来获取点，如[图
    8-2](ch08.xhtml#ch08fig2)所示。
- en: '![image](../images/f152-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f152-01.jpg)'
- en: '*Figure 8-2: The points needed to draw an* F'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：绘制* F *所需的点*'
- en: Add the code in [Listing 8-4](ch08.xhtml#ch08list4) after the draw() function
    to enter the points for all the corners of the *F* and draw lines between those
    points.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数后添加[清单 8-4](ch08.xhtml#ch08list4)中的代码，以输入*F*的所有角点，并在这些点之间画线。
- en: fmatrix = [[0,0],[1,0],[1,2],[2,2],[2,3],[1,3],[1,4],[3,4],[3,5],[0,5]]
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: fmatrix = [[0,0],[1,0],[1,2],[2,2],[2,3],[1,3],[1,4],[3,4],[3,5],[0,5]]
- en: 'def graphPoints(matrix):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphPoints(matrix):'
- en: '#draw line segments between consecutive points'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#在连续的点之间绘制线段'
- en: beginShape()
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: 'for pt in matrix:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'for pt in matrix:'
- en: vertex(pt[0]*xscl,pt[1]*yscl)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(pt[0]*xscl,pt[1]*yscl)
- en: endShape(CLOSE)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: '*Listing 8-4: Graphing the points to draw the* F'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-4：绘制* F *的点的图形*'
- en: 'Here, we first create a list called fmatrix and enter points on each row corresponding
    to the points in the letter *F*. The graphPoints() function takes a matrix as
    a parameter, and each row becomes a vertex of the shape using Processing’s beginShape()
    and endShape() functions. Also, we call the graphPoints() function using fmatrix
    as an argument in the draw() function. Add the code in [Listing 8-5](ch08.xhtml#ch08list5)
    to the end of the draw() function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先创建一个名为fmatrix的列表，并在每一行输入对应字母*F*中的点。graphPoints()函数接受一个矩阵作为参数，每一行都会成为使用Processing的beginShape()和endShape()函数创建的图形的一个顶点。此外，我们在`draw()`函数中使用fmatrix作为参数调用graphPoints()函数。将[清单
    8-5](ch08.xhtml#ch08list5)中的代码添加到`draw()`函数的末尾：
- en: 'strokeWeight(2) #thicker line'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'strokeWeight(2) #更粗的线条'
- en: 'stroke(0) #black'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色'
- en: graphPoints(fmatrix)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(fmatrix)
- en: '*Listing 8-5: Getting the program to graph the points in the* F'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-5：让程序绘制* F *的点*'
- en: We’re creating the fmatrix as a list containing a bunch of coordinates, and
    we call the graphPoints() function to tell the program to graph all the points.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建fmatrix作为一个包含多个坐标的列表，并调用graphPoints()函数告诉程序绘制所有的点。
- en: Processing’s built-in strokeWeight() function lets you control how thick you
    want the outline to be, and the stroke() function lets you choose the color of
    the outline. We’ll draw the first *F* in black. The output looks like [Figure
    8-3](ch08.xhtml#ch08fig3).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Processing内建的strokeWeight()函数让你可以控制线条的粗细，而stroke()函数让你选择线条的颜色。我们将首先用黑色绘制*F*。输出看起来像[图
    8-3](ch08.xhtml#ch08fig3)。
- en: '![image](../images/f153-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f153-01.jpg)'
- en: '*Figure 8-3: The output of graphing the points in the matrix, called the “f-matrix”*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：绘制矩阵中点的结果，称为“f-matrix”*'
- en: When we learn about matrices in school, we learn how to add and multiply them,
    but we never learn why. It’s only when you graph them that you realize that multiplying
    matrices is *transforming* them. Next, we’ll use matrix multiplication to transform
    our *F*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在学校学习矩阵时，我们学会了如何加法和乘法运算，但从未学过为什么要这样做。只有当你绘制它们时，你才会意识到矩阵的乘法其实是在*变换*它们。接下来，我们将使用矩阵乘法来变换我们的*F*。
- en: TRANSFORMING MATRICES
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换矩阵
- en: To see how multiplying matrices lets you transform them, we’ll use a 2 × 2 transformation
    matrix I found on the web (see [Figure 8-4](ch08.xhtml#ch08fig4)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到矩阵相乘如何让你变换它们，我们将使用一个在网上找到的2 × 2变换矩阵（见[图 8-4](ch08.xhtml#ch08fig4)）。
- en: '![image](../images/f154-01.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f154-01.jpg)'
- en: '*Figure 8-4: A transformation matrix found online at* mathworld.wolfram.com'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：一个在网上找到的变换矩阵，来自* mathworld.wolfram.com'
- en: It’s going to rotate our *F* counterclockwise by an angle, given by theta (θ).
    If the angle is 90 degrees, cos(90) = 0 and sin(90) = 1\. Therefore, the rotation
    matrix for a counterclockwise rotation of 90 degrees is
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使我们的 *F* 逆时针旋转一个角度，角度由 theta (θ) 给出。如果角度为 90 度，则 cos(90) = 0，sin(90) = 1。因此，90
    度逆时针旋转的旋转矩阵是
- en: '![image](../images/e154-01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e154-01.jpg)'
- en: 'We can create a transformation matrix by adding the following code to *matrices.pyde*
    before the setup() function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 *matrices.pyde* 中的 setup() 函数之前添加以下代码来创建一个变换矩阵：
- en: transformation_matrix = [[0,-1],[1,0]]
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: transformation_matrix = [[0,-1],[1,0]]
- en: Next, we multiply the f-matrix by the transformation matrix and save the result
    to a new matrix. Since the f-matrix is a 10 × 2 matrix and the transformation
    matrix is 2 × 2, the only way to multiply them is F × T, not T × F.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 f-matrix 与变换矩阵相乘，并将结果保存到一个新矩阵中。由于 f-matrix 是一个 10 × 2 矩阵，而变换矩阵是 2 ×
    2，唯一的相乘方式是 F × T，而不是 T × F。
- en: Remember, the number of columns in the first matrix has to equal the number
    of rows in the second matrix. We’ll graph the f-matrix in black and change the
    stroke color to red for the new matrix. Replace graphPoints(fmatrix) by adding
    the following code in [Listing 8-6](ch08.xhtml#ch08list6) to the draw() function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，第一个矩阵的列数必须等于第二个矩阵的行数。我们将以黑色绘制 f-matrix，并将新矩阵的描边颜色改为红色。将 graphPoints(fmatrix)
    替换为在 [Listing 8-6](ch08.xhtml#ch08list6) 中添加以下代码到 draw() 函数。
- en: newmatrix = multmatrix(fmatrix,transformation_matrix)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix = multmatrix(fmatrix,transformation_matrix)
- en: graphPoints(fmatrix)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(fmatrix)
- en: 'stroke(255,0,0) #red resultant matrix'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(255,0,0) # 红色结果矩阵'
- en: graphPoints(newmatrix)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(newmatrix)
- en: '*Listing 8-6: Multiplying the matrices and graphing the points*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-6: 矩阵相乘并绘制点*'
- en: When you run this, it will look like [Figure 8-5](ch08.xhtml#ch08fig5).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，它将看起来像 [Figure 8-5](ch08.xhtml#ch08fig5)。
- en: '![image](../images/f155-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f155-01.jpg)'
- en: '*Figure 8-5: A clockwise rotation?*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 8-5: 一个顺时针旋转？*'
- en: 'That’s not a counterclockwise rotation! Looking at the math notation in [Figure
    8-4](ch08.xhtml#ch08fig4) again, we see the order of the multiplication is different
    from ours. The accepted way is to multiply by the transformation matrix first
    and then the point(s) to be transformed:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那可不是逆时针旋转！再看一下 [Figure 8-4](ch08.xhtml#ch08fig4) 中的数学符号，我们可以看到乘法的顺序与我们的不同。公认的做法是先乘以变换矩阵，再乘以要变换的点：
- en: '![image](../images/e155-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e155-01.jpg)'
- en: This means the transformed vector v (*v'*) is the result of the rotation vector
    R[θ] being multiplied by the initial vector v[0]. Vector notation is different
    from coordinate notation. For instance, the vector that goes 2 in the x-direction
    and 3 in the y-direction is not given as (2,3), like in standard (x,y) coordinates.
    Rather, it’s given as
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着变换后的向量 v (*v'*) 是旋转向量 R[θ] 与初始向量 v[0] 相乘的结果。向量符号与坐标符号不同。例如，沿 x 方向走 2，沿 y
    方向走 3 的向量，不像标准的 (x,y) 坐标表示为 (2,3)，而是表示为
- en: '![image](../images/e155-02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e155-02.jpg)'
- en: like a 2 × 1 matrix, instead of a 1 × 2 matrix. In our list notation, we’d write
    that as [[2],[3]]. That means we have to change our f-matrix to
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像是 2 × 1 的矩阵，而不是 1 × 2 的矩阵。在我们的列表符号中，我们将其写为 [[2],[3]]。这意味着我们必须将 f-matrix 改为
- en: fmatrix = [[[0],[0]],[[1],[0]],[[1],[2]],[[2],[2]],[[2],[3]],
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: fmatrix = [[[0],[0]],[[1],[0]],[[1],[2]],[[2],[2]],[[2],[3]],
- en: '[[1],[3]],[[1],[4]],[[3],[4]],[[3],[5]],[[0],[5]]]'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1],[3]],[[1],[4]],[[3],[4]],[[3],[5]],[[0],[5]]]'
- en: or
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: fmatrix = [[0,1,1,2,2,1,1,3,3,0],[0,0,2,2,3,3,4,4,5,5]]
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: fmatrix = [[0,1,1,2,2,1,1,3,3,0],[0,0,2,2,3,3,4,4,5,5]]
- en: The first example at least keeps the x- and y-values of a point together, but
    that’s a lot of brackets! The second doesn’t even keep the x- and y-values next
    to each other. Let’s see if there’s another way.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例至少保持了点的 x 和 y 值在一起，但括号太多了！第二个甚至连 x 和 y 值都没放在一起。让我们看看是否还有其他方法。
- en: '### TRANSPOSING MATRICES'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '### 转置矩阵'
- en: An important concept in matrices is *transposition*, where the columns become
    the rows, and vice versa. In our example, we want to change *F* into *F^T*, the
    notation for “the f-matrix, transposed.”
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵中的一个重要概念是 *转置*，即列变为行，反之亦然。在我们的例子中，我们希望将 *F* 改为 *F^T*，这是“f-matrix 转置”的符号。
- en: '![image](../images/e156-01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e156-01.jpg)'
- en: Let’s write a transpose() function that will transpose any matrix. Add the code
    in [Listing 8-7](ch08.xhtml#ch08list7) to *matrices.pyde* after the draw() function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来编写一个 transpose() 函数，用来转置任何矩阵。将 [Listing 8-7](ch08.xhtml#ch08list7) 中的代码添加到
    *matrices.pyde* 的 draw() 函数之后。
- en: 'def transpose(a):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transpose(a):'
- en: '''''''Transposes matrix a'''''''
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''转置矩阵 a'''''''
- en: output = []
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: output = []
- en: m = len(a)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: m = len(a)
- en: n = len(a[0])
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: n = len(a[0])
- en: '#create an n x m matrix'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个 n x m 的矩阵'
- en: 'for i in range(n):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: output.append([])
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: output.append([])
- en: 'for j in range(m):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(m):'
- en: '#replace a[i][j] with a[j][i]'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#将 a[i][j] 替换为 a[j][i]'
- en: output[i].append(a[j][i])
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: output[i].append(a[j][i])
- en: return output
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: return output
- en: '*Listing 8-7: The code to transpose a matrix*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：转置矩阵的代码*'
- en: First, we create an empty list called output that will be the transposed matrix.
    We then define m, the number of rows in the matrix, and n, the number of columns.
    We’re going to make output into an n × m matrix. For all n rows, we’re going to
    start an empty list, and then everything in the ith row of the matrix we add to
    the jth column of the transposed matrix.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 output 的空列表，它将是转置矩阵。然后我们定义 m，矩阵的行数，以及 n，矩阵的列数。我们将把 output 转换成一个
    n × m 的矩阵。对于所有 n 行，我们将启动一个空列表，然后把矩阵的第 i 行中的所有元素添加到转置矩阵的第 j 列中。
- en: 'The following line of code in the transpose function switches the rows and
    columns of a:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 转置函数中的以下代码行交换了 a 的行和列：
- en: output[i].append(a[j][i])
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: output[i].append(a[j][i])
- en: 'Finally, we return the transposed matrix. Let’s test it out. Add the transpose()
    function to your *matrices.py* file and run it. Then we can enter the following
    code in the shell:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回转置后的矩阵。让我们测试一下。将 transpose() 函数添加到你的 *matrices.py* 文件中并运行。然后我们可以在终端输入以下代码：
- en: '>>> a = [[1,2,-3,-1]]'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [[1,2,-3,-1]]'
- en: '>>> transpose(a)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> transpose(a)'
- en: '[[1], [2], [-3], [-1]]'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1], [2], [-3], [-1]]'
- en: '>>> b = [[4,-1],'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [[4,-1],'
- en: '[-2,3],'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[-2,3],'
- en: '[6,-3],'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[6,-3],'
- en: '[1,0]]'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,0]]'
- en: '>>> transpose(b)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> transpose(b)'
- en: '[[4, -2, 6, 1], [-1, 3, -3, 0]]'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[[4, -2, 6, 1], [-1, 3, -3, 0]]'
- en: It works! All we’ll have to do is transpose our f-matrix before multiplying
    it by the transformation matrix. To graph it, we’ll transpose it back, as shown
    in [Listing 8-8](ch08.xhtml#ch08list8).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！我们所需要做的就是在将 f-matrix 与转换矩阵相乘之前，先对其进行转置。为了绘制它，我们会将其转置回来，正如 [列表 8-8](ch08.xhtml#ch08list8)
    中所示。
- en: '*matrices.pyde*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*matrices.pyde*'
- en: 'def draw():'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: 'background(255) #white'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色'
- en: translate(width/2,height/2)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: grid(xscl, yscl)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: grid(xscl, yscl)
- en: 'strokeWeight(2) #thicker line'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'strokeWeight(2) #更粗的线'
- en: 'stroke(0) #black'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色'
- en: ➊ newmatrix = transpose(multmatrix(transformation_matrix,
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ newmatrix = transpose(multmatrix(transformation_matrix,
- en: ➋ transpose(fmatrix)))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ transpose(fmatrix)))
- en: graphPoints(fmatrix)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(fmatrix)
- en: 'stroke(255,0,0) #red resultant matrix'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(255,0,0) #红色的结果矩阵'
- en: graphPoints(newmatrix)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(newmatrix)
- en: '*Listing 8-8: Transposing a matrix, multiplying, and then transposing again*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：转置矩阵、乘法运算，然后再转置*'
- en: Add the calls to the transpose() ➋ function to the newmatrix line ➊ of the draw()
    function. This should get you the correct counterclockwise rotation, as shown
    in [Figure 8-6](ch08.xhtml#ch08fig6).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将对 transpose() ➋ 函数的调用添加到 draw() 函数中的 newmatrix 行 ➊。这应该能得到正确的逆时针旋转，如图 [8-6](ch08.xhtml#ch08fig6)
    所示。
- en: '![image](../images/f157-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f157-01.jpg)'
- en: '*Figure 8-6: A counterclockwise rotation, by matrices*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：由矩阵实现的逆时针旋转*'
- en: The final code for *matrices.pyde* should look like [Listing 8-9](ch08.xhtml#ch08list9).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*matrices.pyde* 的最终代码应如下所示 [列表 8-9](ch08.xhtml#ch08list9)。'
- en: '*matrices.pyde*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*matrices.pyde*'
- en: '#set the range of x-values'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置 x 值的范围'
- en: xmin = -10
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -10
- en: xmax = 10
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 10
- en: '#range of y-values'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '#y 值的范围'
- en: ymin = -10
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -10
- en: ymax = 10
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = 10
- en: '#calculate the range'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算范围'
- en: rangex = xmax - xmin
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: rangex = xmax - xmin
- en: rangey = ymax - ymin
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: rangey = ymax - ymin
- en: transformation_matrix = [[0,-1],[1,0]]
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: transformation_matrix = [[0,-1],[1,0]]
- en: 'def setup():'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global xscl, yscl
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: size(600,600)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '#the scale factors for drawing on the grid:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制网格时的缩放因子：'
- en: xscl= width/rangex
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: xscl= width/rangex
- en: yscl= -height/rangey
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: yscl= -height/rangey
- en: noFill()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: noFill()
- en: 'def draw():'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: 'background(255) #white'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色'
- en: translate(width/2,height/2)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: grid(xscl,yscl)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: grid(xscl,yscl)
- en: 'strokeWeight(2) #thicker line'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'strokeWeight(2) #更粗的线'
- en: 'stroke(0) #black'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色'
- en: newmatrix = transpose(multmatrix(transformation_matrix,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix = transpose(multmatrix(transformation_matrix,
- en: transpose(fmatrix)))
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: transpose(fmatrix)))
- en: graphPoints(fmatrix)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(fmatrix)
- en: 'stroke(255,0,0) #red resultant matrix'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(255,0,0) #红色的结果矩阵'
- en: graphPoints(newmatrix)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(newmatrix)
- en: fmatrix = [[0,0],[1,0],[1,2],[2,2],[2,3],[1,3],[1,4],[3,4],[3,5],[0,5]]
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: fmatrix = [[0,0],[1,0],[1,2],[2,2],[2,3],[1,3],[1,4],[3,4],[3,5],[0,5]]
- en: 'def multmatrix(a,b):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'def multmatrix(a,b):'
- en: '''''''Returns the product of'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回乘积'
- en: matrix a and matrix b'''
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 a 和矩阵 b'''
- en: 'm = len(a) #number of rows in first matrix'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'm = len(a) #第一个矩阵的行数'
- en: 'n = len(b[0]) #number of columns in second matrix'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'n = len(b[0]) #第二个矩阵的列数'
- en: newmatrix = []
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix = []
- en: 'for i in range(m): #for every row in a'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(m): #对于 a 中的每一行'
- en: row = []
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: row = []
- en: '#for every column in b'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '#对于 b 中的每一列'
- en: 'for j in range(n):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(n):'
- en: sum1 = 0
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: sum1 = 0
- en: '#for every element in the column'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#对每一列的元素进行操作'
- en: 'for k in range(len(b)):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k in range(len(b)):'
- en: sum1 += a[i][k]*b[k][j]
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: sum1 += a[i][k]*b[k][j]
- en: row.append(sum1)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: row.append(sum1)
- en: newmatrix.append(row)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix.append(row)
- en: return newmatrix
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: return newmatrix
- en: 'def transpose(a):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transpose(a):'
- en: '''''''Transposes matrix a'''''''
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''转置矩阵 a'''''''
- en: output = []
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: output = []
- en: m = len(a)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: m = len(a)
- en: n = len(a[0])
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: n = len(a[0])
- en: '#create an n x m matrix'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个 n x m 矩阵'
- en: 'for i in range(n):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: output.append([])
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: output.append([])
- en: 'for j in range(m):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(m):'
- en: '#replace a[i][j] with a[j][i]'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '#将 a[i][j] 替换为 a[j][i]'
- en: output[i].append(a[j][i])
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: output[i].append(a[j][i])
- en: return output
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: return output
- en: 'def graphPoints(matrix):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphPoints(matrix):'
- en: '#draw line segments between consecutive points'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制连续点之间的线段'
- en: beginShape()
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: 'for pt in matrix:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'for pt in matrix:'
- en: vertex(pt[0]*xscl,pt[1]*yscl)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(pt[0]*xscl,pt[1]*yscl)
- en: endShape(CLOSE)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: 'def grid(xscl, yscl):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grid(xscl, yscl):'
- en: '''''''Draws a grid for graphing'''''''
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''绘制图形网格'''''''
- en: '#cyan lines'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '#青色线条'
- en: strokeWeight(1)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(1)
- en: stroke(0,255,255)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(0,255,255)
- en: 'for i in range(xmin,xmax + 1):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(xmin,xmax + 1):'
- en: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)
- en: 'for i in range(ymin,ymax+1):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ymin,ymax+1):'
- en: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)
- en: 'stroke(0) #black axes'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色坐标轴'
- en: line(0,ymin*yscl,0,ymax*yscl)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,ymin*yscl,0,ymax*yscl)
- en: line(xmin*xscl,0,xmax*xscl,0)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: line(xmin*xscl,0,xmax*xscl,0)
- en: '*Listing 8-9: The entire code to draw and transform the letter* F'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9：绘制和变换字母* F 的完整代码'
- en: 'EXERCISE 8-1: MORE TRANSFORMATION MATRICES'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8-1：更多变换矩阵
- en: 'See what happens to your shape when you change your transformation matrix to
    each of these matrices:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当你将变换矩阵改为这些矩阵时，形状会发生什么：
- en: '![image](../images/e159-01.jpg) ### ROTATING MATRICES IN REAL TIME'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e159-01.jpg) ### 实时旋转矩阵'
- en: So you just learned how matrices can transform points. But this can happen in
    real time, and interactively too! Change the code in the draw() function in *matrices.pyde*
    to what’s in [Listing 8-10](ch08.xhtml#ch08list10).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你刚刚学会了矩阵如何变换点。但这可以实时发生，并且还可以交互式地进行！将 *matrices.pyde* 中的 draw() 函数代码更改为[清单
    8-10](ch08.xhtml#ch08list10)中的内容。
- en: 'def draw():'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xscl, yscl
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: 'background(255) #white'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色背景'
- en: translate(width/2,height/2)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: grid(xscl, yscl)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: grid(xscl, yscl)
- en: ang = map(mouseX,0,width,0,TWO_PI)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ang = map(mouseX,0,width,0,TWO_PI)
- en: rot_matrix = [[cos(ang),-sin(ang)],
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: rot_matrix = [[cos(ang),-sin(ang)],
- en: '[sin(ang),cos(ang)]]'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[sin(ang),cos(ang)]]'
- en: newmatrix = transpose(multmatrix(rot_matrix,transpose(fmatrix)))
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: newmatrix = transpose(multmatrix(rot_matrix,transpose(fmatrix)))
- en: graphPoints(fmatrix)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(fmatrix)
- en: 'strokeWeight(2) #thicker line'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'strokeWeight(2) #更粗的线条'
- en: 'stroke(255,0,0) #red resultant matrix'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(255,0,0) #红色结果矩阵'
- en: graphPoints(newmatrix)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: graphPoints(newmatrix)
- en: '*Listing 8-10: Rotating in real time using matrices*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-10：使用矩阵实时旋转*'
- en: 'Recall that we used sin() and cos() in [Chapter 7](ch07.xhtml#ch07) to rotate
    and oscillate shapes. In this example, we’re transforming a matrix of points using
    a rotation matrix. Here is what a typical 2 × 2 rotation matrix looks like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在[第 7 章](ch07.xhtml#ch07)中使用了 sin() 和 cos() 来旋转和振荡形状。在这个例子中，我们正在使用旋转矩阵来变换一个点矩阵。以下是典型的
    2 × 2 旋转矩阵的样子：
- en: '![image](../images/e160-01.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e160-01.jpg)'
- en: Because I don’t have a theta (θ) key, I’ll call the rotation angle ang. The
    interesting thing we’re doing right now is changing the ang variable with the
    mouse. So, at every loop, the mouse position determines the value of ang and then
    plugs ang into each expression. It then quickly calculates the sine and cosine
    of ang and multiplies the rotation matrix by the f-matrix. For each loop, the
    rotation matrix will be a little different, depending on where your mouse is.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有θ（θ）键，所以我将旋转角度称为 ang。我们现在所做的有趣的事情是通过鼠标来改变 ang 变量。所以，在每次循环中，鼠标的位置决定了 ang
    的值，然后将 ang 代入每个表达式中。它会迅速计算 ang 的正弦和余弦，并将旋转矩阵与 f 矩阵相乘。每次循环中，旋转矩阵都会有所不同，取决于鼠标的位置。
- en: '![image](../images/f160-01.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f160-01.jpg)'
- en: '*Figure 8-7: Transforming points in real time using matrices!*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：使用矩阵实时变换点！*'
- en: Now the red *F* should rotate around the origin as you move your mouse left
    and right over the graph, as shown in [Figure 8-7](ch08.xhtml#ch08fig7).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你左右移动鼠标时，红色 *F* 应该围绕原点旋转，如[图 8-7](ch08.xhtml#ch08fig7)所示。
- en: This is the kind of transformation that’s happening all the time when you see
    any kind of animation on a computer screen. Creating computer graphics is perhaps
    the most common application of matrices.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在电脑屏幕上看到任何动画时，实际上发生的变换。计算机图形学的创建可能是矩阵最常见的应用之一。
- en: '### CREATING 3D SHAPES'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '### 创建 3D 形状'
- en: So far we used matrices to create and manipulate two-dimensional shapes. You
    might be curious as to how we mathematicians crunch the numbers to represent a
    three-dimensional object on a two-dimensional surface like the computer screen.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用矩阵来创建和操作二维形状。你可能会好奇，作为数学家，我们是如何将数字运算处理后，把三维物体表示在二维表面上，比如计算机屏幕上的显示。
- en: 'Return to your code in [Listing 8-11](ch08.xhtml#ch08list11) and save it as
    *matrices3D.pyde*. Turn fmatrix into the following matrix of points:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到[Listing 8-11](ch08.xhtml#ch08list11)中的代码，并将其保存为*matrices3D.pyde*。将fmatrix转换为以下矩阵：
- en: fmatrix = [[0,0,0],[1,0,0],[1,2,0],[2,2,0],[2,3,0],[1,3,0],[1,4,0],
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: fmatrix = [[0,0,0],[1,0,0],[1,2,0],[2,2,0],[2,3,0],[1,3,0],[1,4,0],
- en: '[3,4,0],[3,5,0],[0,5,0],'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,4,0],[3,5,0],[0,5,0],'
- en: '[0,0,1],[1,0,1],[1,2,1],[2,2,1],[2,3,1],[1,3,1],[1,4,1],'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[0,0,1],[1,0,1],[1,2,1],[2,2,1],[2,3,1],[1,3,1],[1,4,1],'
- en: '[3,4,1],[3,5,1],[0,5,1]]'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,4,1],[3,5,1],[0,5,1]]'
- en: '*Listing 8-11: A 3D version of our f-matrix*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-11：我们f-matrix的3D版本*'
- en: Adding depth to our *F* requires adding another layer to our matrix of points.
    Because our *F* only has two dimensions right now, it’s made up of only x- and
    y-values. But we can think of 2D objects as having a third dimension, represented
    by a z-axis. 2D objects have a z-value of 0\. So for each point we’ll add a zero
    as its third value, making the first 10 points three-dimensional. Then we’ll copy
    and paste these values and change the third value to a 1\. This creates the rear
    layer, which is an identical *F* drawn one unit behind the front one.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的*F*添加深度，我们需要在点的矩阵中添加另一个层次。由于目前我们的*F*只有二维，它只由x值和y值构成。但我们可以将二维物体视为具有第三维度，表示为z轴。二维物体的z值为0。所以对于每个点，我们将添加一个0作为其第三个值，使前10个点变成三维点。然后我们复制并粘贴这些值，将第三个值改为1。这样就创建了后层，它是一个与前层相同的*F*，只不过在后面一单位的位置。
- en: Now that we’ve created the two layers for the *F*, we need to connect the points
    on the front layer with those on the rear layer. Let’s create an edges list so
    we can simply tell the program which points to link with line segments, as shown
    in [Listing 8-12](ch08.xhtml#ch08list12).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为*F*创建了两个层次，我们需要将前层的点与后层的点连接起来。让我们创建一个边列表，这样我们就可以简单地告诉程序哪些点用线段连接，如[Listing
    8-12](ch08.xhtml#ch08list12)所示。
- en: '#list of points to connect:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '# 连接点的列表：'
- en: edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],
- en: '[7,8],[8,9],[9,0],'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[7,8],[8,9],[9,0],'
- en: '[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],'
- en: '[17,18],[18,19],[19,10],'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[17,18],[18,19],[19,10],'
- en: '[0,10],[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[0,10],[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],'
- en: '[8,18],[9,19]]'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[8,18],[9,19]]'
- en: '*Listing 8-12: Keeping track of the edges (the lines between the points on
    the* F)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-12：跟踪边（点与点之间的线）的情况（*F*）'
- en: This is a way to keep track of which points are going to be connected with segments,
    or *edges*. For example, the first entry [0,1] draws an edge from point 0 (0,0,0)
    to point 1 (1,0,0). The first 10 edges draw the front *F*, and the next 10 edges
    draw the rear *F*. Then we draw edges between a point on the front *F* and the
    corresponding point on the rear *F*. For example, edge [0,10] draws a segment
    between point 0 (0,0,0) and point 10 (0,0,1).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种跟踪哪些点将被线段（或*边*）连接的方式。例如，第一个条目[0,1]表示从点0 (0,0,0)到点1 (1,0,0)绘制了一条边。前10条边绘制了前面的*F*，接下来的10条边绘制了后面的*F*。然后我们在前面*F*的点和后面*F*的对应点之间绘制边。例如，边[0,10]绘制了一条从点0
    (0,0,0)到点10 (0,0,1)的线段。
- en: Now when we’re graphing the points, we’re not just drawing lines between every
    consecutive point. [Listing 8-13](ch08.xhtml#ch08list13) shows the new graphPoints()
    function that graphs the *edges* between the points in the list. Replace the old
    graphPoints() function with the following code, just before the definition of
    the grid() function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们绘制这些点时，我们不仅仅是将每个连续的点之间画线。[Listing 8-13](ch08.xhtml#ch08list13)展示了新的graphPoints()函数，它绘制了列表中点之间的*边*。将旧的graphPoints()函数替换为以下代码，放在grid()函数定义之前。
- en: 'def graphPoints(pointList,edges):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'def graphPoints(pointList,edges):'
- en: '''''''Graphs the points in a list using segments'''''''
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''使用线段绘制列表中的点'''''''
- en: 'for e in edges:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'for e in edges:'
- en: line(pointList[e[0]][0]*xscl,pointList[e[0]][1]*yscl,
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: line(pointList[e[0]][0]*xscl,pointList[e[0]][1]*yscl,
- en: pointList[e[1]][0]*xscl,pointList[e[1]][1]*yscl)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: pointList[e[1]][0]*xscl,pointList[e[1]][1]*yscl)
- en: '*Listing 8-13: Graphing points using the edges*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-13：使用边绘制点*'
- en: 'Remember that in Processing you draw a line between two points, (x1,y1) and
    (x2,y2), by using line(x1,y1,x2,y2). Here, we call the points in the pointList
    (we’ll send fmatrix when we run this) by using their numbers in the edges list.
    The function loops over every item, e, in the edges list and connects the point
    represented by the first number, e[0], to the point represented by the second
    number, e[1]. The x-coordinates are multiplied by the xscl variable, which scales
    the x-values:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 Processing 中，你是通过使用 line(x1,y1,x2,y2) 来绘制两点之间的线，(x1,y1) 和 (x2,y2)。在这里，我们通过使用点列表中的数字来调用点（当我们运行时会发送
    fmatrix）。该函数循环遍历边列表中的每个项 e，并将由第一个数字 e[0] 表示的点与由第二个数字 e[1] 表示的点连接起来。x 坐标将乘以 xscl
    变量，这个变量用于缩放 x 值：
- en: pointList[e[0]][0]*xscl
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: pointList[e[0]][0]*xscl
- en: 'We do the same for the y-coordinates:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 y 坐标做同样的处理：
- en: pointList[e[0]][1]*yscl
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: pointList[e[0]][1]*yscl
- en: 'We can make our mouse represent the angle of rotation again by creating two
    rotation variables: rot and tilt. The first one, rot, maps the x-value of the
    mouse to an angle between 0 and 2π, and that value will go in a rotation matrix
    like the one we made in [Listing 8-5](ch08.xhtml#ch08list5). We do the same for
    tilt so it can map the y-value of the mouse. Put the code in [Listing 8-14](ch08.xhtml#ch08list14)
    in the draw() function before multiplying the matrices together.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建两个旋转变量：rot 和 tilt，来使鼠标表示旋转角度。第一个变量 rot，将鼠标的 x 值映射到一个 0 到 2π 之间的角度，这个值将放入像我们在
    [Listing 8-5](ch08.xhtml#ch08list5) 中做的旋转矩阵。对于 tilt，我们做同样的事情，以便它能够映射鼠标的 y 值。在将矩阵相乘之前，将
    [Listing 8-14](ch08.xhtml#ch08list14) 中的代码放入 draw() 函数中。
- en: rot = map(mouseX,0,width,0,TWO_PI)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: rot = map(mouseX,0,width,0,TWO_PI)
- en: tilt = map(mouseY,0,height,0,TWO_PI)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: tilt = map(mouseY,0,height,0,TWO_PI)
- en: '*Listing 8-14: Linking the up-down and left-right rotations with the movements
    of the mouse*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-14：通过鼠标的上下左右移动来连接上下和左右旋转*'
- en: Next, we’ll create a function to multiply the rotation matrices together so
    that all our transformations can be consolidated into one matrix. This is the
    great thing about using matrix multiplication to perform transformations. You
    can just keep “adding” more transformations simply by multiplying!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数来将旋转矩阵相乘，这样我们所有的变换就可以合并成一个矩阵。这就是使用矩阵乘法进行变换的优点。你只需要通过乘法“添加”更多的变换！
- en: CREATING THE ROTATION MATRIX
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建旋转矩阵
- en: Now let’s make a single rotation matrix out of two individual matrices. If you
    see 3D rotation matrices in a math book, they may look like the following equations.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把两个单独的旋转矩阵合成一个。如果你在数学书中看到 3D 旋转矩阵，它们可能看起来像下面的方程。
- en: '![image](../images/e163-01.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e163-01.jpg)'
- en: '*R*[y]() will rotate the points, with the y-axis serving as the axis of rotation,
    so it’s a left/right rotation. *R*[x]() will rotate the points around the x-axis,
    so it’ll be an up-down rotation.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*[y]() 将旋转点，以 y 轴作为旋转轴，所以这是一个左右旋转。*R*[x]() 将绕 x 轴旋转点，所以它是一个上下旋转。'
- en: 'Listing 8-15 shows the code for creating the rottilt() function, which will
    take the rot and tilt values and put them into the matrices. This is how we combine
    two matrices into one. Add the code in [Listing 8-15](ch08.xhtml#ch08list15) to
    *matrices3D.pyde*:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-15] 显示了创建 rottilt() 函数的代码，该函数将接受 rot 和 tilt 的值并将其放入矩阵中。这就是我们如何将两个矩阵合并成一个。将
    [Listing 8-15](ch08.xhtml#ch08list15) 中的代码添加到 *matrices3D.pyde*：'
- en: 'def rottilt(rot,tilt):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'def rottilt(rot,tilt):'
- en: '#returns the matrix for rotating a number of degrees'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回用于旋转一定角度的矩阵'
- en: rotmatrix_Y = [[cos(rot),0.0,sin(rot)],
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: rotmatrix_Y = [[cos(rot),0.0,sin(rot)],
- en: '[0.0,1.0,0.0],'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0,1.0,0.0],'
- en: '[-sin(rot),0.0,cos(rot)]]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[-sin(rot),0.0,cos(rot)]]'
- en: rotmatrix_X = [[1.0,0.0,0.0],
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: rotmatrix_X = [[1.0,0.0,0.0],
- en: '[0.0,cos(tilt),sin(tilt)],'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0,cos(tilt),sin(tilt)],'
- en: '[0.0,-sin(tilt),cos(tilt)]]'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0,-sin(tilt),cos(tilt)]]'
- en: return multmatrix(rotmatrix_Y,rotmatrix_X)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: return multmatrix(rotmatrix_Y,rotmatrix_X)
- en: '*Listing 8-15: Function for creating the rotation matrix*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-15：创建旋转矩阵的函数*'
- en: 'We multiply rotmatrix_Y and rotmatrix_X to get one rotation matrix as output.
    This is useful when there’s a series of matrix operations, such as rotate about
    the x-axis *R[x]*, rotate about the y-axis *R[y]*, scale *S*, and translate *T*.
    Instead of performing a separate multiplication for each operation, we can combine
    all these operations in a single matrix. Matrix multiplication allows us to create
    a new matrix: *M* = *R[y]*(*R[x]*(*S*(*T*))). That means our draw() function will
    change, too. With the new additions above, the draw() function should look like
    [Listing 8-16](ch08.xhtml#ch08list16):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'background(255) #white'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: grid(xscl, yscl)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: rot = map(mouseX,0,width,0,TWO_PI)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: tilt = map(mouseY,0,height,0,TWO_PI)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: newmatrix = transpose(multmatrix(rottilt(rot,tilt),transpose(fmatrix)))
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'strokeWeight(2) #thicker line'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(255,0,0) #red resultant matrix'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: graphPoints(newmatrix,edges)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-16: The new* draw() *function*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you get what’s shown in [Figure 8-8](ch08.xhtml#ch08fig8).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f164-01.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: A 3D* F!'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: We can remove the blue grid and make the *F* bigger by changing the xmin, xmax,
    ymin, and ymax variables and commenting out the call to the grid() function in
    draw().
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-17 shows the full code for drawing a rotating 3D shape.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '*matrices3D.pyde*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '#set the range of x-values'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: xmin = -5
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: xmax = 5
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '#range of y-values'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: ymin = -5
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: ymax = 5
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the range'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: rangex = xmax - xmin
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: rangey = ymax - ymin
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '#the scale factors for drawing on the grid:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: xscl= width/rangex
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: yscl= -height/rangey
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: noFill()
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'background(0) #black'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: rot = map(mouseX,0,width,0,TWO_PI)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: tilt = map(mouseY,0,height,0,TWO_PI)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'strokeWeight(2) #thicker line'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: newmatrix = transpose(multmatrix(rottilt(rot,tilt),transpose(fmatrix)))
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '#graphPoints(fmatrix)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(255,0,0) #red resultant matrix'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: graphPoints(newmatrix,edges)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: fmatrix = [[0,0,0],[1,0,0],[1,2,0],[2,2,0],[2,3,0],[1,3,0],[1,4,0],
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[3,4,0],[3,5,0],[0,5,0],'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[0,0,1],[1,0,1],[1,2,1],[2,2,1],[2,3,1],[1,3,1],[1,4,1],'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[3,4,1],[3,5,1],[0,5,1]]'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '#list of points to connect:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[7,8],[8,9],[9,0],'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[17,18],[18,19],[19,10],'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[0,10],[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[8,18],[9,19]]'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'def rottilt(rot,tilt):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '#returns the matrix for rotating a number of degrees'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: rotmatrix_Y = [[cos(rot),0.0,sin(rot)],
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0,1.0,0.0],'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[-sin(rot),0.0,cos(rot)]]'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: rotmatrix_X = [[1.0,0.0,0.0],
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0,cos(tilt),sin(tilt)],'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0,-sin(tilt),cos(tilt)]]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: return multmatrix(rotmatrix_Y,rotmatrix_X)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'def multmatrix(a,b):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Returns the product of'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: matrix a and matrix b'''
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'm = len(a) #number of rows in first matrix'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'n = len(b[0]) #number of columns in second matrix'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: newmatrix = []
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(m): #for every row in a'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: row = []
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '#for every column in b'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(n):'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: sum1 = 0
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '#for every element in the column'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'for k in range(len(b)):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: sum1 += a[i][k]*b[k][j]
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: row.append(sum1)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: newmatrix.append(row)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: return newmatrix
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'def graphPoints(pointList,edges):'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Graphs the points in a list using segments'''''''
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'for e in edges:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: line(pointList[e[0]][0]*xscl,pointList[e[0]][1]*yscl,
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: pointList[e[1]][0]*xscl,pointList[e[1]][1]*yscl)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'def transpose(a):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Transposes matrix a'''''''
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: output = []
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: m = len(a)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: n = len(a[0])
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '#create an n x m matrix'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: output.append([])
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(m):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '#replace a[i][j] with a[j][i]'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: output[i].append(a[j][i])
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: return output
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-17: The full code for rotating the 3D* F'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: I got rid of the grid and changed the call to the background() function in draw()
    to background(0), so the background will be black and the *F* will appear to be
    rotating in outer space (see [Figure 8-9](ch08.xhtml#ch08fig9))!
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f166-01.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Moving your mouse around will transform the* F!'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: SOLVING SYSTEMS OF EQUATIONS WITH MATRICES
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Have you ever tried solving a system of equations with two or three unknown
    values? That’s a tricky task for any math student. And as the number of unknowns
    increases, the more complicated the system of equations gets to solve. Matrices
    are very useful for solving systems of equations like this one:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e166-01.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
- en: 'For example, you can express this multiplication using matrices:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e166-02.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
- en: This looks similar to the algebra equation 2*x* = 10, which we can solve easily
    by dividing both sides by 2\. If only we could divide both sides of our system
    by the matrix on the left!
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there is a way to do just that by finding the inverse of a matrix,
    the same way you can divide a number by 2 by multiplying it by ½. This is known
    as the *multiplicative inverse* of 2, but it’s a complicated method.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: GAUSSIAN ELIMINATION
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The more efficient way to solve a system of equations using matrices is to
    use row operations to transform the 2 × 2 matrix on the left into the *identity
    matrix*, which is the matrix that represents the number 1\. For example, multiplying
    a matrix by the identity matrix would result in the original matrix, like this:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-01.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
- en: 'The numbers on the right would be the solutions for *x* and *y*, so getting
    those zeroes and ones in the right place is our goal. The right place is the diagonal
    of the matrix, like this:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-02.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
- en: The identity matrix in every square matrix has a 1 on the diagonal, where the
    row number equals the column number.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '*Gaussian elimination* is a method that involves doing operations on entire
    rows of matrices in order to get to the identity matrix. You can multiply or divide
    a row by a constant, and you can add or subtract a row from another row.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using Gaussian elimination, we first have to arrange the coefficients
    and constants into one matrix, like this:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-03.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
- en: 'Then, we divide the entire row by the number that will give us a 1 in the top
    left. This means that first we need to divide all the terms in the first row by
    2, since 2/2 is 1\. That operation gives us the following:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将整个行除以一个数字，这个数字将使我们在左上角得到 1。也就是说，我们首先需要将第一行中的所有项都除以 2，因为 2/2 等于 1。这个操作会得到如下结果：
- en: '![image](../images/e167-04.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e167-04.jpg)'
- en: 'Now we get the *additive inverse* (the number that gives us 0 when added to
    another number) of the term where we want a zero. For example, in row 2, we want
    a zero where the 3 is because we’re looking to change this matrix into the identity
    matrix. Because the additive inverse of 3 is –3, we multiply each term in the
    first row by –3 and add the product to the corresponding term in row 2\. That
    means we multiply the 1 in the first row by –3 and then add the product, which
    is still –3, to the second row. We repeat the process with all the terms in the
    row. For example, the –1/2 in the third column would be multiplied by –3 (to get
    1.5) and added to all the numbers in that column. In this case, it’s just –13,
    so the sum is –11.5 or –23/2\. Continue this, and you should get the following:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到我们想要零的项的*加法逆元*（与另一个数相加得到零的数字）。例如，在第二行，我们希望将 3 变为零，因为我们想将这个矩阵转换为单位矩阵。因为
    3 的加法逆元是 –3，所以我们将第一行中的每一项都乘以 –3，然后将积加到第二行中的对应项。这意味着我们将第一行中的 1 乘以 –3，然后加上积，即仍然是
    –3，得到第二行。我们对行中的所有项都重复这个过程。例如，第三列中的 –1/2 会被乘以 –3（得到 1.5），然后加到该列中的所有数字上。在这个例子中，结果是
    –13，所以和为 –11.5 或 –23/2。继续这个过程，最后得到如下结果：
- en: '![image](../images/e168-01.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-01.jpg)'
- en: 'Now repeat where we want the 1 to be in the second row. We can multiply everything
    in row 2 by –2/23, which should give us this:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复操作，我们希望在第二行中得到 1。我们可以将第二行中的所有元素乘以 –2/23，这样就能得到如下结果：
- en: '![image](../images/e168-02.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-02.jpg)'
- en: 'Finally, we add everything in the first row to the second row, multiplied by
    the additive inverse of 5/2, which is where we want the zero to be in the first
    row. We’ll add every term in the first row to its corresponding term in the second
    row multiplied by –5/2\. Notice this doesn’t affect the 1 in the first row, which
    we want to keep:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将第一行的所有项加到第二行中，乘以 5/2 的加法逆元，这就是我们想在第一行中得到零的位置。我们将第一行中的每一项加到第二行中对应项乘以 –5/2
    的结果。注意，这不会影响第一行中的 1，因为我们希望保留它：
- en: '![image](../images/e168-03.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-03.jpg)'
- en: 'The solutions to the system of equations are now in the right column: *x* =
    –3, *y* = 1.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，方程组的解已经在右列中：*x* = –3, *y* = 1。
- en: 'We can check our answers by plugging those numbers into the original system
    of equations:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将这些数字代入原始方程组来检查我们的答案：
- en: '![image](../images/e168-04.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e168-04.jpg)'
- en: Both solutions are correct, but this is a laborious process. Let’s automate
    this process with Python so we can solve systems that are as big as we want!
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 两个解都是正确的，但这个过程很繁琐。让我们用 Python 自动化这个过程，这样我们就可以解任何大小的方程组了！
- en: WRITING THE GAUSS() FUNCTION
  id: totrans-534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 GAUSS() 函数
- en: 'In this section, we write a function called gauss() that solves systems of
    equations for us. Trying to do this programmatically might seem complicated, but
    there are really only two steps that we need to code:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们编写一个名为 gauss() 的函数，用来为我们解方程组。尝试用编程方式实现这一步看似复杂，但实际上我们只需要编写两步代码：
- en: Divide all the elements in a row by the term in the diagonal.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一行中的所有元素除以对角线上的项。
- en: Add each term in one row to the corresponding term in another row.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一行中的每一项加到另一行中的对应项。
- en: Dividing All Items in a Row
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 划分一行中的所有项
- en: The first task is to divide all the terms in a row by a number. Let’s say we
    have the row of numbers [1,2,3,4,5]. For example, we can use the code in [Listing
    8-18](ch08.xhtml#ch08list18) to divide this row by 2\. Open a new Python file,
    call it *gauss.py* and enter the code in [Listing 8-18](ch08.xhtml#ch08list18).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是将一行中的所有项除以一个数字。假设我们有这一行数字 [1,2,3,4,5]。例如，我们可以使用 [Listing 8-18](ch08.xhtml#ch08list18)
    中的代码将这一行除以 2。打开一个新的 Python 文件，命名为 *gauss.py*，然后输入 [Listing 8-18](ch08.xhtml#ch08list18)
    中的代码。
- en: divisor = 2
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: divisor = 2
- en: row = [1,2,3,4,5]
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: row = [1,2,3,4,5]
- en: 'for i, term in enumerate(row):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i, term in enumerate(row):'
- en: row[i] = term / divisor
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: row[i] = term / divisor
- en: print(row)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: print(row)
- en: '*Listing 8-18: Dividing all the terms in a row by a divisor*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-18: 将一行中的所有项除以一个除数*'
- en: 'This loops over the row list, keeping track of the index and the value using
    the enumerate() function. We then replace each term row[i] with the term divided
    by the divisor. When you run this, you’ll get a list of five values:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[0.5, 1.0, 1.5, 2.0, 2.5]'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Adding Each Element to Its Corresponding Element
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second task is to add each element of one row to the corresponding element
    in the other row. For example, add all the elements in row 0 below to the elements
    in row 1 and replace the elements in row 1 with the sum:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '>>> my_matrix = [[2,-4,6,-8],'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[-3,6,-9,12]]'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(my_matrix[1])):'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: my_matrix[1][i] += my_matrix[0][i]
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(my_matrix)'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[[2, -4, 6, -8], [-1, 2, -3, 4]]'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: We’re looping over all the items in the second row (index 1) of my_matrix. Then
    we’re incrementing each term (index i) in the second row by the corresponding
    term in the first row (index 0). We successfully added the terms in the first
    row to those in the second row. Notice the first row didn’t change. We’ll use
    these steps in solving systems of equations.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Repeating the Process for Every Row
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now we just have to put those steps together for all the rows in a matrix.
    We’ll call the matrix *A*. Once we’ve put the *x, y*, and *z*’s and the constant
    terms in order, we put only the coefficients and the constants into the matrix:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e169-01.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
- en: First, we divide every term in the row by the term on the diagonal so that the
    diagonal term will be 1, using the code in [Listing 8-19](ch08.xhtml#ch08list19).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'for j,row in enumerate(A):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '#diagonal term to be 1'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '#by dividing row by diagonal term'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'if row[j] != 0: #diagonal term can''t be 0'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'divisor = row[j] #diagonal term'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'for i, term in enumerate(row):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: row[i] = term / divisor
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-19: Dividing every term in a row by the row’s diagonal term*'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Using enumerate, we can get the first row of *A* ([2,1,-1,8]), for example,
    and j will be the index of that row (in this case, zero). The diagonal terms are
    where the row number is the same as the column number, like row 0, column 0, or
    row 1, column 1.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Now we go through every other row in the matrix and perform the second step.
    Now, for each of the other rows (where i is not equal to j), calculate the additive
    inverse of the jth term, multiply each term in row j by that inverse, and add
    those terms to their corresponding terms in the ith row. Add the code in [Listing
    8-20](ch08.xhtml#ch08list20) to the gauss() function.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(m):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'if i != j: #don''t do this to row j'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the additive inverse'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: addinv = -1*A[i][j]
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '#for every term in the ith row'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'for ind in range(n):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '#add the corresponding term in the jth row'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '#multiplied by the additive inverse'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '#to the term in the ith row'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: A[i][ind] += addinv*A[j][ind]
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-20: Making every nondiagonal term in a row 0*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens to every row, so since m is the number of rows, we start off with
    for i in range(m). We already divided the row in question by the diagonal term,
    so we don’t have to do anything to that row. That’s why we do it only if i is
    not equal to j. In our example, each term in the first row of A is going to be
    multiplied by 3 and added to the corresponding term in the second row. And then
    every term in the first row is going to be multiplied by 2 and added to the corresponding
    term in the third row. That will get us zeroes in the second and third rows of
    the first column:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e170-01.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
- en: Now our first column is done, and we want a 1 in the diagonal. Therefore, we
    want a 1 in the second row of the second column, so we repeat the process.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Put all the code together into a gauss() function and print out the results.
    [Listing 8-21](ch08.xhtml#ch08list21) shows the complete code.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 'def gauss(A):'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Converts a matrix into the identity'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: matrix by Gaussian elimination, with
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: the last column containing the solutions
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: for the variables'''
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: m = len(A)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: n = len(A[0])
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'for j,row in enumerate(A):'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '#diagonal term to be 1'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '#by dividing row by diagonal term'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'if row[j] != 0: #diagonal entry can''t be zero'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: divisor = row[j]
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'for i, term in enumerate(row):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: row[i] = term / divisor
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '#add the other rows to the additive inverse'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '#for every row'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(m):'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'if i != j: #don''t do it to row j'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the additive inverse'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: addinv = -1*A[i][j]
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '#for every term in the ith row'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'for ind in range(n):'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '#add the corresponding term in the jth row'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '#multiplied by the additive inverse'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '#to the term in the ith row'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: A[i][ind] += addinv*A[j][ind]
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: return A
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '#example:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: B = [[2,1,-1,8],
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[-3,-1,2,-1],'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[-2,1,2,-3]]'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: print(gauss(B))
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-21: The complete code for the* gauss() *function*'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be the following:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[[1.0, 0.0, 0.0, 32.0], [0.0, 1.0, 0.0, -17.0], [-0.0, -0.0, 1.0, 39.0]]'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is how it looks in matrix form:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e171-01.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
- en: 'We look at the last numbers in each row, so our solutions are *x* = 32, *y* =
    –17, and *z* = 39\. We check this by plugging those values into the original equations:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e171-02.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
- en: This is a major achievement! Now, not only can we solve systems of two or three
    unknowns, but we can also solve for any number of unknowns! Solving a system of
    four unknowns is a laborious task if the student doesn’t know Python. But luckily
    for us, we do! When the correct solution pops up so quickly in the Python shell,
    I’m always blown away. If you’ve ever had to perform Gaussian elimination by hand,
    Exercise 8-2 will blow you away too.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 8-2: ENTER THE MATRIX'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'Solve this system of equations for *w, x, y*, and *z* using the program you
    just wrote:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e172-01.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
- en: SUMMARY
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve come a long way in your math adventure! You started with some basic Python
    to make turtles walk around and then went on to create more complicated Python
    functions to solve harder math problems. In this chapter, not only did you learn
    how to use Python to add and multiply matrices, but you also experienced first-hand
    how matrices can create an transform 2D and 3D graphics! The power we have to
    add, multiply, transpose, and otherwise operate on matrices using Python is mind-boggling.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: You also learned to automate the process you would have done by hand to solve
    a system of equations. The same program that works for a 3 × 3 matrix will also
    work for a 4 × 4 or any larger square matrix!
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Matrices are vital tools in making a neural network, with dozens or even hundreds
    of paths leading to and from virtual neurons. An input is “propagated” through
    the network using matrix multiplication and transposition, the same tools you
    created in this chapter.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: There was a time when what you’ve done in this chapter was out of reach to anyone
    who didn’t have access to an enormous, expensive computer that took up a whole
    floor at a university or major corporation. Now you can perform lightning-fast
    matrix calculations using Python and visualize the results using Processing!
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I pointed out how great it is that we get instantaneous solutions
    to our complicated systems of equations as well as immediate responses to our
    mouse movements in our exploration of graphics. In the next chapter, we’ll create
    a model of an ecosystem containing grass and sheep and let it run on its own.
    The model will morph and change over time as the sheep are born, eat, reproduce,
    and die. Only after letting the model run for a minute or more will we be able
    to judge if the environment can find a balance between grass growing and sheep
    eating and multiplying.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
