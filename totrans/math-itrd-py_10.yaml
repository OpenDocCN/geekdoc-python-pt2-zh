- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING MATRICES FOR COMPUTER GRAPHICS AND SYSTEMS OF EQUATIONS
  prefs: []
  type: TYPE_NORMAL
- en: '*“I am large, I contain multitudes.”'
  prefs: []
  type: TYPE_NORMAL
- en: —Walt Whitman, from “Song of Myself”*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In math class, students are taught how to add, subtract, and multiply matrices
    without ever learning how they’re really used. This is too bad because matrices
    allow us to easily group together large collections of items and simulate coordinates
    of an object from multiple perspectives, making them useful in machine learning
    and absolutely crucial to 2D and 3D graphics. In other words, without matrices,
    there would be no video games!
  prefs: []
  type: TYPE_NORMAL
- en: To understand how matrices are useful for creating graphics, you first need
    to understand how to perform arithmetic on them. In this chapter, you review how
    to add and multiply matrices so that you can create and transform 2D and 3D objects
    in Processing. Finally, you learn how to solve large systems of equations instantaneously
    using matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '### WHAT IS A MATRIX?'
  prefs: []
  type: TYPE_NORMAL
- en: A *matrix* is a rectangular array of numbers that have specific rules for operating
    on them. [Figure 8-1](ch08.xhtml#ch08fig1) shows what a matrix looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f146-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Matrices have* `m` *rows and* `n` *columns*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the numbers are arranged in rows and columns, where *m* and *n* represent
    the total number of rows and columns, respectively. You can have a 2 × 2 matrix,
    with two rows and two columns, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e146-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or you can have a 3 × 4 matrix with three rows and four columns, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e146-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Traditionally, we use the letter *i* to represent the row number and the letter
    *j* to represent the column number. Note that the numbers in a matrix aren’t being
    added to each other; they’re just arranged together. This is similar to how we
    arrange coordinates using the format (x,y), but you don’t operate on coordinates.
    For example, a point at (2,3) doesn’t mean you add or multiply 2 and 3; they just
    sit next to each other and tell you where the point is located on a graph. But
    as you’ll soon see, you *can* add, subtract, and multiply two matrices just like
    you can normal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: ADDING MATRICES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can only add and subtract matrices of the same dimensions (size and shape),
    which means that you can add or subtract only the *corresponding elements*. Here
    is an example of how to add two 2 × 2 matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e146-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, we add 1 and 5 because they are corresponding elements in their
    matrices, meaning they’re in the same spot: the first row, first column. Thus,
    we get 6 in the top-left corner. Adding the corresponding elements 3 and –7 gives
    us –4, as you can see in the bottom-left corner of the result.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s easy enough to put into a Python function since you can save a matrix
    to a variable. Open a new file in IDLE and save it as *matrices.py*. Then write
    the code in [Listing 8-1](ch08.xhtml#ch08list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Writing the* `matrices.py` *program to add matrices*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we declare a couple of 2 × 2 matrices, `A` and `B`, using Python’s list
    syntax. For example, `A` is a list that contains two lists, each of which has
    two elements. We then declare a function called `addMatrices()`, which takes two
    matrices as arguments. Finally, we create another matrix, `C`, which adds each
    element in the first matrix to the corresponding element in the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this, the output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the 2 × 2 matrix that results from adding matrices A and B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e147-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you know how to add matrices, let’s try multiplying them, which will
    let you transform coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: MULTIPLYING MATRICES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiplying matrices is much more useful than adding them. For example, you
    can rotate a 2D or 3D shape by multiplying a matrix of (x,y) coordinates by a
    transformation matrix, as you’ll do later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When multiplying matrices, you don’t simply multiply the corresponding elements.
    Instead, you multiply the elements in each row of the first matrix by the corresponding
    elements in each column of the second matrix. This means that the number of columns
    in the first matrix has to equal the number of rows in the second. Otherwise,
    they can’t be multiplied. For example, the following two matrices can be multiplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we multiply the elements in the first row of the first matrix (1 and
    2) with the elements in only the first column of the second matrix (5 and 6).
    The sum of those products would become the element in the first row and column
    of the resultant matrix. We do the same for the second row of the first matrix,
    and so on. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the general formula for multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also multiply the following two matrices, because *A* is a 1 × 4 matrix
    and *B* is a 4 × 2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What will the resultant matrix look like? Well, the first row of *A* will be
    multiplied by the first column of *B* to become the number in the first row, first
    column of the result. It works the same way for the first row, second column.
    The resultant matrix will be a 1 × 2 matrix. You can see when you’re multiplying
    matrices, the elements in the rows of the first matrix are being matched up with
    the elements in the columns of the second matrix. That means the resultant matrix
    will have the number of rows of the first matrix and the number of columns of
    the second matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll directly multiply the elements in matrix *A* by their corresponding
    elements in matrix *B* and add all the products.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This might seem like a complicated process to have to automate, but as long
    as we have the matrices as input, we can easily find out the number of columns
    and rows.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-2 shows a matrix multiplication program in Python that requires a
    bit more work than the addition code. Add this code to *matrices.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Writing a matrix multiplication function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `multmatrix()` function takes two matrices as parameters:
    `a` and `b`. Right at the beginning of the function we declare `m`, the number
    of rows in matrix `a`, and `n`, the number of columns in matrix `b`. We create
    an empty list called `newmatrix` as the resultant matrix. The “row times column”
    operation will occur `m` times, so the first loop is `for i in range(m)`, making
    `i` repeat `m` number of times. For every row, we add an empty row to `newmatrix`
    so we can fill the row with `n` elements. The next loop makes `j` repeat `n` times
    because there are `n` columns in `b`. The tricky part will be matching up the
    correct elements, but it just takes a little thinking.'
  prefs: []
  type: TYPE_NORMAL
- en: Just think of what elements will be multiplied together. When `j = 0`, we multiply
    the elements in the `i`th row of `a` by the first column (index 0) of `b`, and
    the product becomes the first column in the new row of `newmatrix`, as you saw
    in the previous example. Then, when `j = 1`, the same happens to the `i`th row
    of `a` and the second column (index 1) of `b`. That product becomes the second
    column in the new row of `newmatrix`. This process gets repeated for every row
    of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every element in the row in matrix `a`, there’s a corresponding element
    in the column in matrix `b`. The number of columns of `a` and the number of rows
    of `b` are the same, but we can express it as `len(a[0])` or `len(b)`. I chose
    `len(b)`. So in the third loop, `k` will repeat `len(b)` times. The first element
    in the `i`th row of `a` and the first element in the `j`th column of `b` will
    be multiplied together, which can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same for the second element in the `i`th row of `a` and the second element
    in the `j`th column of `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So for every column (in the `j` loop), we’ll start a running sum at 0 (because
    `sum` is already a Python keyword, I use `sum1`), and it will increment for every
    one of the `k` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It doesn’t look like much, but that’s the line that’s going to keep track of
    and multiply all the corresponding elements! After going through all `k` elements
    (after the `k` loop is finished), we’ll append the sum to the row, and once we’ve
    gone through all the columns in `b` (after the `j` loop is finished), we’ll put
    that row into `newmatrix`. After going through all the rows in `a`, we return
    the resultant matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this program by multiplying our sample matrices, a 1 × 4 matrix
    by a 4 × 2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e150-01a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, our new function for multiplying any two matrices (if they *can*
    be multiplied) works. Let’s test it by multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e150-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the following to multiply matrix `a` by matrix `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code shows how to enter 2 × 2 matrices using Python lists. The multiplication
    also looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e150-02.jpg) Let’s check these answers. We begin by multiplying
    the first row of `a` by the first column of `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: (1)(3) + (–2)(5) = 3 – 10 = –7
  prefs: []
  type: TYPE_NORMAL
- en: 'And –7 is the number in the first row, first column of the resultant matrix.
    We next multiply the second row of `a` by the first column of `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: (2)(3) + (1)(5) = 6 + 5 = 11
  prefs: []
  type: TYPE_NORMAL
- en: And 11 is the number in the second row, first column of the resultant matrix.
    The other numbers are correct, too. The `multmatrix()` function is going to save
    us from doing a lot of laborious arithmetic!
  prefs: []
  type: TYPE_NORMAL
- en: ORDER MATTERS IN MATRIX MULTIPLICATION
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important fact about multiplying matrices is that A × B doesn’t necessarily
    equal B × A. Let’s prove that by reversing our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e151-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s how to multiply these matrices in the other direction in the Python
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when you multiply the same matrices in the reverse order using
    `multmatrix(b,a)` instead of `multmatrix(a,b)`, you get a completely different
    resultant matrix. Remember that when you’re multiplying matrices, *A × B doesn’t
    necessarily equal B × A*.
  prefs: []
  type: TYPE_NORMAL
- en: DRAWING 2D SHAPES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to operate on matrices, let’s put a bunch of points into
    a list to make a 2D shape. Open a new sketch in Processing and save it as *matrices.pyde*.
    If you still have your *grid.pyde* sketch from [Listing 4-11](ch04.xhtml#ch04list11),
    you can copy and paste the essentials for drawing a grid. Otherwise, add the code
    in [Listing 8-3](ch08.xhtml#ch08list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: The code for drawing a grid*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to draw a simple figure and transform it using matrices. I’ll use
    the letter *F* because it has no rotational or reflectional symmetry (and because
    it’s my initial). We’ll sketch it out to get the points, as shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f152-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: The points needed to draw an* `F`'
  prefs: []
  type: TYPE_NORMAL
- en: Add the code in [Listing 8-4](ch08.xhtml#ch08list4) after the `draw()` function
    to enter the points for all the corners of the *F* and draw lines between those
    points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Graphing the points to draw the* `F`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we first create a list called `fmatrix` and enter points on each row
    corresponding to the points in the letter *F*. The `graphPoints()` function takes
    a matrix as a parameter, and each row becomes a vertex of the shape using Processing’s
    `beginShape()` and `endShape()` functions. Also, we call the `graphPoints()` function
    using `fmatrix` as an argument in the `draw()` function. Add the code in [Listing
    8-5](ch08.xhtml#ch08list5) to the end of the `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Getting the program to graph the points in the* `F`'
  prefs: []
  type: TYPE_NORMAL
- en: We’re creating the `fmatrix` as a list containing a bunch of coordinates, and
    we call the `graphPoints()` function to tell the program to graph all the points.
  prefs: []
  type: TYPE_NORMAL
- en: Processing’s built-in `strokeWeight()` function lets you control how thick you
    want the outline to be, and the `stroke()` function lets you choose the color
    of the outline. We’ll draw the first *F* in black. The output looks like [Figure
    8-3](ch08.xhtml#ch08fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f153-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: The output of graphing the points in the matrix, called the “f-matrix”*'
  prefs: []
  type: TYPE_NORMAL
- en: When we learn about matrices in school, we learn how to add and multiply them,
    but we never learn why. It’s only when you graph them that you realize that multiplying
    matrices is *transforming* them. Next, we’ll use matrix multiplication to transform
    our *F*.
  prefs: []
  type: TYPE_NORMAL
- en: TRANSFORMING MATRICES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see how multiplying matrices lets you transform them, we’ll use a 2 × 2 transformation
    matrix I found on the web (see [Figure 8-4](ch08.xhtml#ch08fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f154-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: A transformation matrix found online at* `mathworld.wolfram.com`'
  prefs: []
  type: TYPE_NORMAL
- en: It’s going to rotate our *F* counterclockwise by an angle, given by theta (θ).
    If the angle is 90 degrees, cos(90) = 0 and sin(90) = 1\. Therefore, the rotation
    matrix for a counterclockwise rotation of 90 degrees is
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e154-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create a transformation matrix by adding the following code to *matrices.pyde*
    before the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we multiply the f-matrix by the transformation matrix and save the result
    to a new matrix. Since the f-matrix is a 10 × 2 matrix and the transformation
    matrix is 2 × 2, the only way to multiply them is F × T, not T × F.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the number of columns in the first matrix has to equal the number
    of rows in the second matrix. We’ll graph the f-matrix in black and change the
    stroke color to red for the new matrix. Replace `graphPoints(fmatrix)` by adding
    the following code in [Listing 8-6](ch08.xhtml#ch08list6) to the `draw()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Multiplying the matrices and graphing the points*'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, it will look like [Figure 8-5](ch08.xhtml#ch08fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f155-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: A clockwise rotation?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not a counterclockwise rotation! Looking at the math notation in [Figure
    8-4](ch08.xhtml#ch08fig4) again, we see the order of the multiplication is different
    from ours. The accepted way is to multiply by the transformation matrix first
    and then the point(s) to be transformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e155-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means the transformed vector v (*v'*) is the result of the rotation vector
    R[θ] being multiplied by the initial vector v[0]. Vector notation is different
    from coordinate notation. For instance, the vector that goes 2 in the x-direction
    and 3 in the y-direction is not given as (2,3), like in standard (x,y) coordinates.
    Rather, it’s given as
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e155-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: like a 2 × 1 matrix, instead of a 1 × 2 matrix. In our list notation, we’d write
    that as `[[2],[3]]`. That means we have to change our f-matrix to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first example at least keeps the x- and y-values of a point together, but
    that’s a lot of brackets! The second doesn’t even keep the x- and y-values next
    to each other. Let’s see if there’s another way.
  prefs: []
  type: TYPE_NORMAL
- en: '### TRANSPOSING MATRICES'
  prefs: []
  type: TYPE_NORMAL
- en: An important concept in matrices is *transposition*, where the columns become
    the rows, and vice versa. In our example, we want to change *F* into *F^T*, the
    notation for “the f-matrix, transposed.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e156-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s write a `transpose()` function that will transpose any matrix. Add the
    code in [Listing 8-7](ch08.xhtml#ch08list7) to *matrices.pyde* after the `draw()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: The code to transpose a matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an empty list called `output` that will be the transposed matrix.
    We then define `m`, the number of rows in the matrix, and `n`, the number of columns.
    We’re going to make output into an `n` × `m` matrix. For all `n` rows, we’re going
    to start an empty list, and then everything in the `i`th row of the matrix we
    add to the `j`th column of the transposed matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code in the `transpose` function switches the rows and
    columns of `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return the transposed matrix. Let’s test it out. Add the `transpose()`
    function to your *matrices.py* file and run it. Then we can enter the following
    code in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It works! All we’ll have to do is transpose our f-matrix before multiplying
    it by the transformation matrix. To graph it, we’ll transpose it back, as shown
    in [Listing 8-8](ch08.xhtml#ch08list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: Transposing a matrix, multiplying, and then transposing again*'
  prefs: []
  type: TYPE_NORMAL
- en: Add the calls to the `transpose()` ➋ function to the `newmatrix` line ➊ of the
    `draw()` function. This should get you the correct counterclockwise rotation,
    as shown in [Figure 8-6](ch08.xhtml#ch08fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f157-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: A counterclockwise rotation, by matrices*'
  prefs: []
  type: TYPE_NORMAL
- en: The final code for *matrices.pyde* should look like [Listing 8-9](ch08.xhtml#ch08list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: The entire code to draw and transform the letter* `F`'
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 8-1: MORE TRANSFORMATION MATRICES'
  prefs: []
  type: TYPE_NORMAL
- en: 'See what happens to your shape when you change your transformation matrix to
    each of these matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e159-01.jpg) ### ROTATING MATRICES IN REAL TIME'
  prefs: []
  type: TYPE_NORMAL
- en: So you just learned how matrices can transform points. But this can happen in
    real time, and interactively too! Change the code in the `draw()` function in
    *matrices.pyde* to what’s in [Listing 8-10](ch08.xhtml#ch08list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: Rotating in real time using matrices*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we used `sin()` and `cos()` in [Chapter 7](ch07.xhtml#ch07) to
    rotate and oscillate shapes. In this example, we’re transforming a matrix of points
    using a rotation matrix. Here is what a typical 2 × 2 rotation matrix looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e160-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because I don’t have a theta (θ) key, I’ll call the rotation angle `ang`. The
    interesting thing we’re doing right now is changing the `ang` variable with the
    mouse. So, at every loop, the mouse position determines the value of `ang` and
    then plugs `ang` into each expression. It then quickly calculates the sine and
    cosine of `ang` and multiplies the rotation matrix by the f-matrix. For each loop,
    the rotation matrix will be a little different, depending on where your mouse
    is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f160-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Transforming points in real time using matrices!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now the red *F* should rotate around the origin as you move your mouse left
    and right over the graph, as shown in [Figure 8-7](ch08.xhtml#ch08fig7).
  prefs: []
  type: TYPE_NORMAL
- en: This is the kind of transformation that’s happening all the time when you see
    any kind of animation on a computer screen. Creating computer graphics is perhaps
    the most common application of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '### CREATING 3D SHAPES'
  prefs: []
  type: TYPE_NORMAL
- en: So far we used matrices to create and manipulate two-dimensional shapes. You
    might be curious as to how we mathematicians crunch the numbers to represent a
    three-dimensional object on a two-dimensional surface like the computer screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to your code in [Listing 8-11](ch08.xhtml#ch08list11) and save it as
    *matrices3D.pyde*. Turn `fmatrix` into the following matrix of points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: A 3D version of our f-matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding depth to our *F* requires adding another layer to our matrix of points.
    Because our *F* only has two dimensions right now, it’s made up of only x- and
    y-values. But we can think of 2D objects as having a third dimension, represented
    by a z-axis. 2D objects have a z-value of 0\. So for each point we’ll add a zero
    as its third value, making the first 10 points three-dimensional. Then we’ll copy
    and paste these values and change the third value to a 1\. This creates the rear
    layer, which is an identical *F* drawn one unit behind the front one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the two layers for the *F*, we need to connect the points
    on the front layer with those on the rear layer. Let’s create an `edges` list
    so we can simply tell the program which points to link with line segments, as
    shown in [Listing 8-12](ch08.xhtml#ch08list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12: Keeping track of the edges (the lines between the points on
    the* `F`)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a way to keep track of which points are going to be connected with segments,
    or *edges*. For example, the first entry `[0,1]` draws an edge from point 0 (0,0,0)
    to point 1 (1,0,0). The first 10 edges draw the front *F*, and the next 10 edges
    draw the rear *F*. Then we draw edges between a point on the front *F* and the
    corresponding point on the rear *F*. For example, edge `[0,10]` draws a segment
    between point 0 (0,0,0) and point 10 (0,0,1).
  prefs: []
  type: TYPE_NORMAL
- en: Now when we’re graphing the points, we’re not just drawing lines between every
    consecutive point. [Listing 8-13](ch08.xhtml#ch08list13) shows the new `graphPoints()`
    function that graphs the *edges* between the points in the list. Replace the old
    `graphPoints()` function with the following code, just before the definition of
    the `grid()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13: Graphing points using the edges*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that in Processing you draw a line between two points, (x1,y1) and
    (x2,y2), by using `line(x1,y1,x2,y2)`. Here, we call the points in the `pointList`
    (we’ll send `fmatrix` when we run this) by using their numbers in the `edges`
    list. The function loops over every item, `e`, in the `edges` list and connects
    the point represented by the first number, `e[0]`, to the point represented by
    the second number, `e[1]`. The x-coordinates are multiplied by the `xscl` variable,
    which scales the x-values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same for the y-coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make our mouse represent the angle of rotation again by creating two
    rotation variables: `rot` and `tilt`. The first one, `rot`, maps the x-value of
    the mouse to an angle between 0 and 2π, and that value will go in a rotation matrix
    like the one we made in [Listing 8-5](ch08.xhtml#ch08list5). We do the same for
    `tilt` so it can map the y-value of the mouse. Put the code in [Listing 8-14](ch08.xhtml#ch08list14)
    in the `draw()` function before multiplying the matrices together.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14: Linking the up-down and left-right rotations with the movements
    of the mouse*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create a function to multiply the rotation matrices together so
    that all our transformations can be consolidated into one matrix. This is the
    great thing about using matrix multiplication to perform transformations. You
    can just keep “adding” more transformations simply by multiplying!
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE ROTATION MATRIX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s make a single rotation matrix out of two individual matrices. If you
    see 3D rotation matrices in a math book, they may look like the following equations.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e163-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*R*[y]() will rotate the points, with the y-axis serving as the axis of rotation,
    so it’s a left/right rotation. *R*[x]() will rotate the points around the x-axis,
    so it’ll be an up-down rotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8-15 shows the code for creating the `rottilt()` function, which will
    take the `rot` and `tilt` values and put them into the matrices. This is how we
    combine two matrices into one. Add the code in [Listing 8-15](ch08.xhtml#ch08list15)
    to *matrices3D.pyde*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-15: Function for creating the rotation matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We multiply `rotmatrix_Y` and `rotmatrix_X` to get one rotation matrix as output.
    This is useful when there’s a series of matrix operations, such as rotate about
    the x-axis *R[x]*, rotate about the y-axis *R[y]*, scale *S*, and translate *T*.
    Instead of performing a separate multiplication for each operation, we can combine
    all these operations in a single matrix. Matrix multiplication allows us to create
    a new matrix: *M* = *R[y]*(*R[x]*(*S*(*T*))). That means our `draw()` function
    will change, too. With the new additions above, the `draw()` function should look
    like [Listing 8-16](ch08.xhtml#ch08list16):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-16: The new* `draw()` *function*'
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you get what’s shown in [Figure 8-8](ch08.xhtml#ch08fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f164-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: A 3D* `F`!'
  prefs: []
  type: TYPE_NORMAL
- en: We can remove the blue grid and make the *F* bigger by changing the `xmin`,
    `xmax`, `ymin`, and `ymax` variables and commenting out the call to the `grid()`
    function in `draw()`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-17 shows the full code for drawing a rotating 3D shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-17: The full code for rotating the 3D* `F`'
  prefs: []
  type: TYPE_NORMAL
- en: I got rid of the grid and changed the call to the `background()` function in
    `draw()` to `background(0)`, so the background will be black and the *F* will
    appear to be rotating in outer space (see [Figure 8-9](ch08.xhtml#ch08fig9))!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f166-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Moving your mouse around will transform the* `F`!'
  prefs: []
  type: TYPE_NORMAL
- en: SOLVING SYSTEMS OF EQUATIONS WITH MATRICES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Have you ever tried solving a system of equations with two or three unknown
    values? That’s a tricky task for any math student. And as the number of unknowns
    increases, the more complicated the system of equations gets to solve. Matrices
    are very useful for solving systems of equations like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e166-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, you can express this multiplication using matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e166-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This looks similar to the algebra equation 2*x* = 10, which we can solve easily
    by dividing both sides by 2\. If only we could divide both sides of our system
    by the matrix on the left!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there is a way to do just that by finding the inverse of a matrix,
    the same way you can divide a number by 2 by multiplying it by ½. This is known
    as the *multiplicative inverse* of 2, but it’s a complicated method.
  prefs: []
  type: TYPE_NORMAL
- en: GAUSSIAN ELIMINATION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The more efficient way to solve a system of equations using matrices is to
    use row operations to transform the 2 × 2 matrix on the left into the *identity
    matrix*, which is the matrix that represents the number 1\. For example, multiplying
    a matrix by the identity matrix would result in the original matrix, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The numbers on the right would be the solutions for *x* and *y*, so getting
    those zeroes and ones in the right place is our goal. The right place is the diagonal
    of the matrix, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The identity matrix in every square matrix has a 1 on the diagonal, where the
    row number equals the column number.
  prefs: []
  type: TYPE_NORMAL
- en: '*Gaussian elimination* is a method that involves doing operations on entire
    rows of matrices in order to get to the identity matrix. You can multiply or divide
    a row by a constant, and you can add or subtract a row from another row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using Gaussian elimination, we first have to arrange the coefficients
    and constants into one matrix, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we divide the entire row by the number that will give us a 1 in the top
    left. This means that first we need to divide all the terms in the first row by
    2, since 2/2 is 1\. That operation gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we get the *additive inverse* (the number that gives us 0 when added to
    another number) of the term where we want a zero. For example, in row 2, we want
    a zero where the 3 is because we’re looking to change this matrix into the identity
    matrix. Because the additive inverse of 3 is –3, we multiply each term in the
    first row by –3 and add the product to the corresponding term in row 2\. That
    means we multiply the 1 in the first row by –3 and then add the product, which
    is still –3, to the second row. We repeat the process with all the terms in the
    row. For example, the –1/2 in the third column would be multiplied by –3 (to get
    1.5) and added to all the numbers in that column. In this case, it’s just –13,
    so the sum is –11.5 or –23/2\. Continue this, and you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now repeat where we want the 1 to be in the second row. We can multiply everything
    in row 2 by –2/23, which should give us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we add everything in the first row to the second row, multiplied by
    the additive inverse of 5/2, which is where we want the zero to be in the first
    row. We’ll add every term in the first row to its corresponding term in the second
    row multiplied by –5/2\. Notice this doesn’t affect the 1 in the first row, which
    we want to keep:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The solutions to the system of equations are now in the right column: *x* =
    –3, *y* = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check our answers by plugging those numbers into the original system
    of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both solutions are correct, but this is a laborious process. Let’s automate
    this process with Python so we can solve systems that are as big as we want!
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE GAUSS() FUNCTION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we write a function called `gauss()` that solves systems of
    equations for us. Trying to do this programmatically might seem complicated, but
    there are really only two steps that we need to code:'
  prefs: []
  type: TYPE_NORMAL
- en: Divide all the elements in a row by the term in the diagonal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each term in one row to the corresponding term in another row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dividing All Items in a Row
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first task is to divide all the terms in a row by a number. Let’s say we
    have the row of numbers `[1,2,3,4,5]`. For example, we can use the code in [Listing
    8-18](ch08.xhtml#ch08list18) to divide this row by 2\. Open a new Python file,
    call it *gauss.py* and enter the code in [Listing 8-18](ch08.xhtml#ch08list18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-18: Dividing all the terms in a row by a divisor*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This loops over the `row` list, keeping track of the index and the value using
    the `enumerate()` function. We then replace each term `row[i]` with the term divided
    by the divisor. When you run this, you’ll get a list of five values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding Each Element to Its Corresponding Element
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second task is to add each element of one row to the corresponding element
    in the other row. For example, add all the elements in row 0 below to the elements
    in row 1 and replace the elements in row 1 with the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We’re looping over all the items in the second row (index 1) of `my_matrix`.
    Then we’re incrementing each term (index `i`) in the second row by the corresponding
    term in the first row (index 0). We successfully added the terms in the first
    row to those in the second row. Notice the first row didn’t change. We’ll use
    these steps in solving systems of equations.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating the Process for Every Row
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now we just have to put those steps together for all the rows in a matrix.
    We’ll call the matrix *A*. Once we’ve put the *x, y*, and *z*’s and the constant
    terms in order, we put only the coefficients and the constants into the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e169-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we divide every term in the row by the term on the diagonal so that the
    diagonal term will be 1, using the code in [Listing 8-19](ch08.xhtml#ch08list19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-19: Dividing every term in a row by the row’s diagonal term*'
  prefs: []
  type: TYPE_NORMAL
- en: Using `enumerate`, we can get the first row of *A* (`[2,1,-1,8]`), for example,
    and `j` will be the index of that row (in this case, zero). The diagonal terms
    are where the row number is the same as the column number, like row 0, column
    0, or row 1, column 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now we go through every other row in the matrix and perform the second step.
    Now, for each of the other rows (where `i` is not equal to `j`), calculate the
    additive inverse of the `j`th term, multiply each term in row `j` by that inverse,
    and add those terms to their corresponding terms in the `i`th row. Add the code
    in [Listing 8-20](ch08.xhtml#ch08list20) to the `gauss()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-20: Making every nondiagonal term in a row 0*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens to every row, so since m is the number of rows, we start off with
    `for i in range(m)`. We already divided the row in question by the diagonal term,
    so we don’t have to do anything to that row. That’s why we do it only if `i` is
    not equal to `j`. In our example, each term in the first row of A is going to
    be multiplied by 3 and added to the corresponding term in the second row. And
    then every term in the first row is going to be multiplied by 2 and added to the
    corresponding term in the third row. That will get us zeroes in the second and
    third rows of the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e170-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now our first column is done, and we want a 1 in the diagonal. Therefore, we
    want a 1 in the second row of the second column, so we repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Put all the code together into a `gauss()` function and print out the results.
    [Listing 8-21](ch08.xhtml#ch08list21) shows the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-21: The complete code for the* `gauss()` *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is how it looks in matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e171-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We look at the last numbers in each row, so our solutions are *x* = 32, *y* =
    –17, and *z* = 39\. We check this by plugging those values into the original equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e171-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a major achievement! Now, not only can we solve systems of two or three
    unknowns, but we can also solve for any number of unknowns! Solving a system of
    four unknowns is a laborious task if the student doesn’t know Python. But luckily
    for us, we do! When the correct solution pops up so quickly in the Python shell,
    I’m always blown away. If you’ve ever had to perform Gaussian elimination by hand,
    Exercise 8-2 will blow you away too.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 8-2: ENTER THE MATRIX'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solve this system of equations for *w, x, y*, and *z* using the program you
    just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e172-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SUMMARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve come a long way in your math adventure! You started with some basic Python
    to make turtles walk around and then went on to create more complicated Python
    functions to solve harder math problems. In this chapter, not only did you learn
    how to use Python to add and multiply matrices, but you also experienced first-hand
    how matrices can create an transform 2D and 3D graphics! The power we have to
    add, multiply, transpose, and otherwise operate on matrices using Python is mind-boggling.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned to automate the process you would have done by hand to solve
    a system of equations. The same program that works for a 3 × 3 matrix will also
    work for a 4 × 4 or any larger square matrix!
  prefs: []
  type: TYPE_NORMAL
- en: Matrices are vital tools in making a neural network, with dozens or even hundreds
    of paths leading to and from virtual neurons. An input is “propagated” through
    the network using matrix multiplication and transposition, the same tools you
    created in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There was a time when what you’ve done in this chapter was out of reach to anyone
    who didn’t have access to an enormous, expensive computer that took up a whole
    floor at a university or major corporation. Now you can perform lightning-fast
    matrix calculations using Python and visualize the results using Processing!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I pointed out how great it is that we get instantaneous solutions
    to our complicated systems of equations as well as immediate responses to our
    mouse movements in our exploration of graphics. In the next chapter, we’ll create
    a model of an ecosystem containing grass and sheep and let it run on its own.
    The model will morph and change over time as the sheep are born, eat, reproduce,
    and die. Only after letting the model run for a minute or more will we be able
    to judge if the environment can find a balance between grass growing and sheep
    eating and multiplying.
  prefs: []
  type: TYPE_NORMAL
