- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING MATRICES FOR COMPUTER GRAPHICS AND SYSTEMS OF EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*“I am large, I contain multitudes.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: —Walt Whitman, from “Song of Myself”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: In math class, students are taught how to add, subtract, and multiply matrices
    without ever learning how they’re really used. This is too bad because matrices
    allow us to easily group together large collections of items and simulate coordinates
    of an object from multiple perspectives, making them useful in machine learning
    and absolutely crucial to 2D and 3D graphics. In other words, without matrices,
    there would be no video games!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: To understand how matrices are useful for creating graphics, you first need
    to understand how to perform arithmetic on them. In this chapter, you review how
    to add and multiply matrices so that you can create and transform 2D and 3D objects
    in Processing. Finally, you learn how to solve large systems of equations instantaneously
    using matrices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '### WHAT IS A MATRIX?'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: A *matrix* is a rectangular array of numbers that have specific rules for operating
    on them. [Figure 8-1](ch08.xhtml#ch08fig1) shows what a matrix looks like.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f146-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Matrices have* `m` *rows and* `n` *columns*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the numbers are arranged in rows and columns, where *m* and *n* represent
    the total number of rows and columns, respectively. You can have a 2 × 2 matrix,
    with two rows and two columns, like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e146-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Or you can have a 3 × 4 matrix with three rows and four columns, like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e146-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Traditionally, we use the letter *i* to represent the row number and the letter
    *j* to represent the column number. Note that the numbers in a matrix aren’t being
    added to each other; they’re just arranged together. This is similar to how we
    arrange coordinates using the format (x,y), but you don’t operate on coordinates.
    For example, a point at (2,3) doesn’t mean you add or multiply 2 and 3; they just
    sit next to each other and tell you where the point is located on a graph. But
    as you’ll soon see, you *can* add, subtract, and multiply two matrices just like
    you can normal numbers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: ADDING MATRICES
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can only add and subtract matrices of the same dimensions (size and shape),
    which means that you can add or subtract only the *corresponding elements*. Here
    is an example of how to add two 2 × 2 matrices:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e146-03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'For example, we add 1 and 5 because they are corresponding elements in their
    matrices, meaning they’re in the same spot: the first row, first column. Thus,
    we get 6 in the top-left corner. Adding the corresponding elements 3 and –7 gives
    us –4, as you can see in the bottom-left corner of the result.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: That’s easy enough to put into a Python function since you can save a matrix
    to a variable. Open a new file in IDLE and save it as *matrices.py*. Then write
    the code in [Listing 8-1](ch08.xhtml#ch08list1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Writing the* `matrices.py` *program to add matrices*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Here, we declare a couple of 2 × 2 matrices, `A` and `B`, using Python’s list
    syntax. For example, `A` is a list that contains two lists, each of which has
    two elements. We then declare a function called `addMatrices()`, which takes two
    matrices as arguments. Finally, we create another matrix, `C`, which adds each
    element in the first matrix to the corresponding element in the second.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this, the output should be something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This shows the 2 × 2 matrix that results from adding matrices A and B:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e147-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Now that you know how to add matrices, let’s try multiplying them, which will
    let you transform coordinates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: MULTIPLYING MATRICES
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiplying matrices is much more useful than adding them. For example, you
    can rotate a 2D or 3D shape by multiplying a matrix of (x,y) coordinates by a
    transformation matrix, as you’ll do later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'When multiplying matrices, you don’t simply multiply the corresponding elements.
    Instead, you multiply the elements in each row of the first matrix by the corresponding
    elements in each column of the second matrix. This means that the number of columns
    in the first matrix has to equal the number of rows in the second. Otherwise,
    they can’t be multiplied. For example, the following two matrices can be multiplied:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'First, we multiply the elements in the first row of the first matrix (1 and
    2) with the elements in only the first column of the second matrix (5 and 6).
    The sum of those products would become the element in the first row and column
    of the resultant matrix. We do the same for the second row of the first matrix,
    and so on. It would look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Here is the general formula for multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'We can also multiply the following two matrices, because *A* is a 1 × 4 matrix
    and *B* is a 4 × 2 matrix:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: What will the resultant matrix look like? Well, the first row of *A* will be
    multiplied by the first column of *B* to become the number in the first row, first
    column of the result. It works the same way for the first row, second column.
    The resultant matrix will be a 1 × 2 matrix. You can see when you’re multiplying
    matrices, the elements in the rows of the first matrix are being matched up with
    the elements in the columns of the second matrix. That means the resultant matrix
    will have the number of rows of the first matrix and the number of columns of
    the second matrix.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll directly multiply the elements in matrix *A* by their corresponding
    elements in matrix *B* and add all the products.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e148-05.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: This might seem like a complicated process to have to automate, but as long
    as we have the matrices as input, we can easily find out the number of columns
    and rows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-2 shows a matrix multiplication program in Python that requires a
    bit more work than the addition code. Add this code to *matrices.py*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-2: Writing a matrix multiplication function*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `multmatrix()` function takes two matrices as parameters:
    `a` and `b`. Right at the beginning of the function we declare `m`, the number
    of rows in matrix `a`, and `n`, the number of columns in matrix `b`. We create
    an empty list called `newmatrix` as the resultant matrix. The “row times column”
    operation will occur `m` times, so the first loop is `for i in range(m)`, making
    `i` repeat `m` number of times. For every row, we add an empty row to `newmatrix`
    so we can fill the row with `n` elements. The next loop makes `j` repeat `n` times
    because there are `n` columns in `b`. The tricky part will be matching up the
    correct elements, but it just takes a little thinking.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Just think of what elements will be multiplied together. When `j = 0`, we multiply
    the elements in the `i`th row of `a` by the first column (index 0) of `b`, and
    the product becomes the first column in the new row of `newmatrix`, as you saw
    in the previous example. Then, when `j = 1`, the same happens to the `i`th row
    of `a` and the second column (index 1) of `b`. That product becomes the second
    column in the new row of `newmatrix`. This process gets repeated for every row
    of `a`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'For every element in the row in matrix `a`, there’s a corresponding element
    in the column in matrix `b`. The number of columns of `a` and the number of rows
    of `b` are the same, but we can express it as `len(a[0])` or `len(b)`. I chose
    `len(b)`. So in the third loop, `k` will repeat `len(b)` times. The first element
    in the `i`th row of `a` and the first element in the `j`th column of `b` will
    be multiplied together, which can be written like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same for the second element in the `i`th row of `a` and the second element
    in the `j`th column of `b`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So for every column (in the `j` loop), we’ll start a running sum at 0 (because
    `sum` is already a Python keyword, I use `sum1`), and it will increment for every
    one of the `k` elements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It doesn’t look like much, but that’s the line that’s going to keep track of
    and multiply all the corresponding elements! After going through all `k` elements
    (after the `k` loop is finished), we’ll append the sum to the row, and once we’ve
    gone through all the columns in `b` (after the `j` loop is finished), we’ll put
    that row into `newmatrix`. After going through all the rows in `a`, we return
    the resultant matrix.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this program by multiplying our sample matrices, a 1 × 4 matrix
    by a 4 × 2 matrix:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This checks out:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e150-01a.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, our new function for multiplying any two matrices (if they *can*
    be multiplied) works. Let’s test it by multiplying a 2 × 2 matrix by a 2 × 2 matrix:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e150-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Enter the following to multiply matrix `a` by matrix `b`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code shows how to enter 2 × 2 matrices using Python lists. The multiplication
    also looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码展示了如何使用 Python 列表输入 2 × 2 的矩阵。矩阵乘法也像这样：
- en: '![image](../images/e150-02.jpg) Let’s check these answers. We begin by multiplying
    the first row of `a` by the first column of `b`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e150-02.jpg) 让我们检查这些答案。我们从将 `a` 的第一行与 `b` 的第一列相乘开始：'
- en: (1)(3) + (–2)(5) = 3 – 10 = –7
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (1)(3) + (–2)(5) = 3 – 10 = –7
- en: 'And –7 is the number in the first row, first column of the resultant matrix.
    We next multiply the second row of `a` by the first column of `b`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 而 –7 是结果矩阵中第一行、第一列的数字。接下来我们将 `a` 的第二行与 `b` 的第一列相乘：
- en: (2)(3) + (1)(5) = 6 + 5 = 11
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (2)(3) + (1)(5) = 6 + 5 = 11
- en: And 11 is the number in the second row, first column of the resultant matrix.
    The other numbers are correct, too. The `multmatrix()` function is going to save
    us from doing a lot of laborious arithmetic!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 11 是结果矩阵中第二行、第一列的数字。其他数字也是正确的。`multmatrix()` 函数将帮助我们避免做大量繁琐的计算！
- en: ORDER MATTERS IN MATRIX MULTIPLICATION
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵乘法中顺序很重要
- en: 'An important fact about multiplying matrices is that A × B doesn’t necessarily
    equal B × A. Let’s prove that by reversing our previous example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于矩阵乘法的一个重要事实是 A × B 不一定等于 B × A。让我们通过反转之前的示例来证明这一点：
- en: '![image](../images/e151-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e151-01.jpg)'
- en: 'Here’s how to multiply these matrices in the other direction in the Python
    shell:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在 Python shell 中反向乘法的方法：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, when you multiply the same matrices in the reverse order using
    `multmatrix(b,a)` instead of `multmatrix(a,b)`, you get a completely different
    resultant matrix. Remember that when you’re multiplying matrices, *A × B doesn’t
    necessarily equal B × A*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你用 `multmatrix(b,a)` 而不是 `multmatrix(a,b)` 反向相乘相同的矩阵时，你会得到完全不同的结果矩阵。记住，矩阵相乘时，*A
    × B 不一定等于 B × A*。
- en: DRAWING 2D SHAPES
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制二维形状
- en: Now that you know how to operate on matrices, let’s put a bunch of points into
    a list to make a 2D shape. Open a new sketch in Processing and save it as *matrices.pyde*.
    If you still have your *grid.pyde* sketch from [Listing 4-11](ch04.xhtml#ch04list11),
    you can copy and paste the essentials for drawing a grid. Otherwise, add the code
    in [Listing 8-3](ch08.xhtml#ch08list3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何进行矩阵操作了，让我们将一堆点放入列表中，形成一个二维形状。在 Processing 中打开一个新草图，并将其保存为 *matrices.pyde*。如果你仍然保留着
    [列表 4-11](ch04.xhtml#ch04list11) 中的 *grid.pyde* 草图，可以复制并粘贴绘制网格的核心代码。否则，请添加 [列表
    8-3](ch08.xhtml#ch08list3) 中的代码。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-3: The code for drawing a grid*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：绘制网格的代码*'
- en: We’re going to draw a simple figure and transform it using matrices. I’ll use
    the letter *F* because it has no rotational or reflectional symmetry (and because
    it’s my initial). We’ll sketch it out to get the points, as shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个简单的图形，并通过矩阵变换它。我将使用字母*F*，因为它没有旋转或对称反射的特性（而且因为它是我的名字首字母）。我们将先画出它的轮廓来获得点，如
    [图 8-2](ch08.xhtml#ch08fig2) 所示。
- en: '![image](../images/f152-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f152-01.jpg)'
- en: '*Figure 8-2: The points needed to draw an* `F`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：绘制 *F* 所需的点*'
- en: Add the code in [Listing 8-4](ch08.xhtml#ch08list4) after the `draw()` function
    to enter the points for all the corners of the *F* and draw lines between those
    points.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw()` 函数后添加 [列表 8-4](ch08.xhtml#ch08list4) 中的代码，以输入 *F* 的所有角点，并在这些点之间画线。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-4: Graphing the points to draw the* `F`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4：绘制 *F* 的点*'
- en: 'Here, we first create a list called `fmatrix` and enter points on each row
    corresponding to the points in the letter *F*. The `graphPoints()` function takes
    a matrix as a parameter, and each row becomes a vertex of the shape using Processing’s
    `beginShape()` and `endShape()` functions. Also, we call the `graphPoints()` function
    using `fmatrix` as an argument in the `draw()` function. Add the code in [Listing
    8-5](ch08.xhtml#ch08list5) to the end of the `draw()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个名为 `fmatrix` 的列表，并在每一行中输入与字母 *F* 中的点相对应的坐标。`graphPoints()` 函数以矩阵为参数，每一行成为形状的一个顶点，使用
    Processing 的 `beginShape()` 和 `endShape()` 函数。同时，我们在 `draw()` 函数中使用 `fmatrix`
    作为参数调用 `graphPoints()` 函数。在 `draw()` 函数的末尾添加 [列表 8-5](ch08.xhtml#ch08list5) 中的代码：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-5: Getting the program to graph the points in the* `F`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：让程序绘制 *F* 的点*'
- en: We’re creating the `fmatrix` as a list containing a bunch of coordinates, and
    we call the `graphPoints()` function to tell the program to graph all the points.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建 `fmatrix`，它是一个包含许多坐标的列表，并且调用 `graphPoints()` 函数来指示程序绘制所有的点。
- en: Processing’s built-in `strokeWeight()` function lets you control how thick you
    want the outline to be, and the `stroke()` function lets you choose the color
    of the outline. We’ll draw the first *F* in black. The output looks like [Figure
    8-3](ch08.xhtml#ch08fig3).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f153-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: The output of graphing the points in the matrix, called the “f-matrix”*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: When we learn about matrices in school, we learn how to add and multiply them,
    but we never learn why. It’s only when you graph them that you realize that multiplying
    matrices is *transforming* them. Next, we’ll use matrix multiplication to transform
    our *F*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: TRANSFORMING MATRICES
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see how multiplying matrices lets you transform them, we’ll use a 2 × 2 transformation
    matrix I found on the web (see [Figure 8-4](ch08.xhtml#ch08fig4)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f154-01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: A transformation matrix found online at* `mathworld.wolfram.com`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: It’s going to rotate our *F* counterclockwise by an angle, given by theta (θ).
    If the angle is 90 degrees, cos(90) = 0 and sin(90) = 1\. Therefore, the rotation
    matrix for a counterclockwise rotation of 90 degrees is
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e154-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'We can create a transformation matrix by adding the following code to *matrices.pyde*
    before the `setup()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we multiply the f-matrix by the transformation matrix and save the result
    to a new matrix. Since the f-matrix is a 10 × 2 matrix and the transformation
    matrix is 2 × 2, the only way to multiply them is F × T, not T × F.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the number of columns in the first matrix has to equal the number
    of rows in the second matrix. We’ll graph the f-matrix in black and change the
    stroke color to red for the new matrix. Replace `graphPoints(fmatrix)` by adding
    the following code in [Listing 8-6](ch08.xhtml#ch08list6) to the `draw()` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-6: Multiplying the matrices and graphing the points*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, it will look like [Figure 8-5](ch08.xhtml#ch08fig5).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f155-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: A clockwise rotation?*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not a counterclockwise rotation! Looking at the math notation in [Figure
    8-4](ch08.xhtml#ch08fig4) again, we see the order of the multiplication is different
    from ours. The accepted way is to multiply by the transformation matrix first
    and then the point(s) to be transformed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e155-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: This means the transformed vector v (*v'*) is the result of the rotation vector
    R[θ] being multiplied by the initial vector v[0]. Vector notation is different
    from coordinate notation. For instance, the vector that goes 2 in the x-direction
    and 3 in the y-direction is not given as (2,3), like in standard (x,y) coordinates.
    Rather, it’s given as
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e155-02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: like a 2 × 1 matrix, instead of a 1 × 2 matrix. In our list notation, we’d write
    that as `[[2],[3]]`. That means we have to change our f-matrix to
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first example at least keeps the x- and y-values of a point together, but
    that’s a lot of brackets! The second doesn’t even keep the x- and y-values next
    to each other. Let’s see if there’s another way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '### TRANSPOSING MATRICES'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: An important concept in matrices is *transposition*, where the columns become
    the rows, and vice versa. In our example, we want to change *F* into *F^T*, the
    notation for “the f-matrix, transposed.”
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e156-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Let’s write a `transpose()` function that will transpose any matrix. Add the
    code in [Listing 8-7](ch08.xhtml#ch08list7) to *matrices.pyde* after the `draw()`
    function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-7: The code to transpose a matrix*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an empty list called `output` that will be the transposed matrix.
    We then define `m`, the number of rows in the matrix, and `n`, the number of columns.
    We’re going to make output into an `n` × `m` matrix. For all `n` rows, we’re going
    to start an empty list, and then everything in the `i`th row of the matrix we
    add to the `j`th column of the transposed matrix.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code in the `transpose` function switches the rows and
    columns of `a`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we return the transposed matrix. Let’s test it out. Add the `transpose()`
    function to your *matrices.py* file and run it. Then we can enter the following
    code in the shell:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It works! All we’ll have to do is transpose our f-matrix before multiplying
    it by the transformation matrix. To graph it, we’ll transpose it back, as shown
    in [Listing 8-8](ch08.xhtml#ch08list8).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-8: Transposing a matrix, multiplying, and then transposing again*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Add the calls to the `transpose()` ➋ function to the `newmatrix` line ➊ of the
    `draw()` function. This should get you the correct counterclockwise rotation,
    as shown in [Figure 8-6](ch08.xhtml#ch08fig6).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f157-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: A counterclockwise rotation, by matrices*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The final code for *matrices.pyde* should look like [Listing 8-9](ch08.xhtml#ch08list9).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-9: The entire code to draw and transform the letter* `F`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 8-1: MORE TRANSFORMATION MATRICES'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'See what happens to your shape when you change your transformation matrix to
    each of these matrices:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e159-01.jpg) ### ROTATING MATRICES IN REAL TIME'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: So you just learned how matrices can transform points. But this can happen in
    real time, and interactively too! Change the code in the `draw()` function in
    *matrices.pyde* to what’s in [Listing 8-10](ch08.xhtml#ch08list10).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-10: Rotating in real time using matrices*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we used `sin()` and `cos()` in [Chapter 7](ch07.xhtml#ch07) to
    rotate and oscillate shapes. In this example, we’re transforming a matrix of points
    using a rotation matrix. Here is what a typical 2 × 2 rotation matrix looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e160-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Because I don’t have a theta (θ) key, I’ll call the rotation angle `ang`. The
    interesting thing we’re doing right now is changing the `ang` variable with the
    mouse. So, at every loop, the mouse position determines the value of `ang` and
    then plugs `ang` into each expression. It then quickly calculates the sine and
    cosine of `ang` and multiplies the rotation matrix by the f-matrix. For each loop,
    the rotation matrix will be a little different, depending on where your mouse
    is.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有 θ（θ）键，我将旋转角度称为`ang`。我们现在做的有趣的事情是通过鼠标改变`ang`变量。因此，在每次循环时，鼠标位置决定`ang`的值，然后将`ang`代入每个表达式。它快速计算`ang`的正弦和余弦，并将旋转矩阵与f矩阵相乘。每次循环时，旋转矩阵会略有不同，具体取决于鼠标的位置。
- en: '![image](../images/f160-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f160-01.jpg)'
- en: '*Figure 8-7: Transforming points in real time using matrices!*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：使用矩阵实时变换点！*'
- en: Now the red *F* should rotate around the origin as you move your mouse left
    and right over the graph, as shown in [Figure 8-7](ch08.xhtml#ch08fig7).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在图表上左右移动鼠标时，红色的*F*应该围绕原点旋转，如[图 8-7](ch08.xhtml#ch08fig7)所示。
- en: This is the kind of transformation that’s happening all the time when you see
    any kind of animation on a computer screen. Creating computer graphics is perhaps
    the most common application of matrices.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在计算机屏幕上看到任何动画时发生的变换。创建计算机图形学可能是矩阵最常见的应用。
- en: '### CREATING 3D SHAPES'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### 创建3D形状'
- en: So far we used matrices to create and manipulate two-dimensional shapes. You
    might be curious as to how we mathematicians crunch the numbers to represent a
    three-dimensional object on a two-dimensional surface like the computer screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用矩阵创建和操作二维形状。你可能会好奇，我们数学家是如何计算数字，将三维物体表示在像计算机屏幕这样的二维表面上的。
- en: 'Return to your code in [Listing 8-11](ch08.xhtml#ch08list11) and save it as
    *matrices3D.pyde*. Turn `fmatrix` into the following matrix of points:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 返回[清单 8-11](ch08.xhtml#ch08list11)中的代码，并将其保存为*matrices3D.pyde*。将`fmatrix`转换为以下点矩阵：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-11: A 3D version of our f-matrix*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：我们f矩阵的3D版本*'
- en: Adding depth to our *F* requires adding another layer to our matrix of points.
    Because our *F* only has two dimensions right now, it’s made up of only x- and
    y-values. But we can think of 2D objects as having a third dimension, represented
    by a z-axis. 2D objects have a z-value of 0\. So for each point we’ll add a zero
    as its third value, making the first 10 points three-dimensional. Then we’ll copy
    and paste these values and change the third value to a 1\. This creates the rear
    layer, which is an identical *F* drawn one unit behind the front one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的*F*添加深度需要向我们的点矩阵中添加另一个层。因为我们的*F*现在只有二维，所以它只由x和y值组成。但是我们可以将二维物体视为具有第三维度，表示为z轴。二维物体的z值为0。因此，对于每个点，我们将添加一个零作为其第三个值，使前10个点成为三维。然后，我们将这些值复制粘贴，并将第三个值更改为1。这将创建后层，这是一个与前层*F*相同的图形，且位于前层后面一个单位。
- en: Now that we’ve created the two layers for the *F*, we need to connect the points
    on the front layer with those on the rear layer. Let’s create an `edges` list
    so we can simply tell the program which points to link with line segments, as
    shown in [Listing 8-12](ch08.xhtml#ch08list12).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为*F*创建了两个层，我们需要将前层的点与后层的点连接起来。我们创建一个`edges`列表，这样就可以简单地告诉程序要用线段连接哪些点，如[清单
    8-12](ch08.xhtml#ch08list12)所示。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 8-12: Keeping track of the edges (the lines between the points on
    the* `F`)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-12：跟踪边（点与点之间的线*`F`）'
- en: This is a way to keep track of which points are going to be connected with segments,
    or *edges*. For example, the first entry `[0,1]` draws an edge from point 0 (0,0,0)
    to point 1 (1,0,0). The first 10 edges draw the front *F*, and the next 10 edges
    draw the rear *F*. Then we draw edges between a point on the front *F* and the
    corresponding point on the rear *F*. For example, edge `[0,10]` draws a segment
    between point 0 (0,0,0) and point 10 (0,0,1).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是跟踪哪些点将被线段连接的方式，或称为*边*。例如，第一个条目`[0,1]`从点0（0,0,0）到点1（1,0,0）画一条边。前10条边画出前*F*，接下来的10条边画出后*F*。然后我们画出连接前*F*上的点与后*F*上相应点之间的边。例如，边`[0,10]`画出点0（0,0,0）与点10（0,0,1）之间的线段。
- en: Now when we’re graphing the points, we’re not just drawing lines between every
    consecutive point. [Listing 8-13](ch08.xhtml#ch08list13) shows the new `graphPoints()`
    function that graphs the *edges* between the points in the list. Replace the old
    `graphPoints()` function with the following code, just before the definition of
    the `grid()` function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-13: Graphing points using the edges*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that in Processing you draw a line between two points, (x1,y1) and
    (x2,y2), by using `line(x1,y1,x2,y2)`. Here, we call the points in the `pointList`
    (we’ll send `fmatrix` when we run this) by using their numbers in the `edges`
    list. The function loops over every item, `e`, in the `edges` list and connects
    the point represented by the first number, `e[0]`, to the point represented by
    the second number, `e[1]`. The x-coordinates are multiplied by the `xscl` variable,
    which scales the x-values:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We do the same for the y-coordinates:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can make our mouse represent the angle of rotation again by creating two
    rotation variables: `rot` and `tilt`. The first one, `rot`, maps the x-value of
    the mouse to an angle between 0 and 2π, and that value will go in a rotation matrix
    like the one we made in [Listing 8-5](ch08.xhtml#ch08list5). We do the same for
    `tilt` so it can map the y-value of the mouse. Put the code in [Listing 8-14](ch08.xhtml#ch08list14)
    in the `draw()` function before multiplying the matrices together.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-14: Linking the up-down and left-right rotations with the movements
    of the mouse*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create a function to multiply the rotation matrices together so
    that all our transformations can be consolidated into one matrix. This is the
    great thing about using matrix multiplication to perform transformations. You
    can just keep “adding” more transformations simply by multiplying!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE ROTATION MATRIX
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s make a single rotation matrix out of two individual matrices. If you
    see 3D rotation matrices in a math book, they may look like the following equations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e163-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: '*R*[y]() will rotate the points, with the y-axis serving as the axis of rotation,
    so it’s a left/right rotation. *R*[x]() will rotate the points around the x-axis,
    so it’ll be an up-down rotation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8-15 shows the code for creating the `rottilt()` function, which will
    take the `rot` and `tilt` values and put them into the matrices. This is how we
    combine two matrices into one. Add the code in [Listing 8-15](ch08.xhtml#ch08list15)
    to *matrices3D.pyde*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-15: Function for creating the rotation matrix*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We multiply `rotmatrix_Y` and `rotmatrix_X` to get one rotation matrix as output.
    This is useful when there’s a series of matrix operations, such as rotate about
    the x-axis *R[x]*, rotate about the y-axis *R[y]*, scale *S*, and translate *T*.
    Instead of performing a separate multiplication for each operation, we can combine
    all these operations in a single matrix. Matrix multiplication allows us to create
    a new matrix: *M* = *R[y]*(*R[x]*(*S*(*T*))). That means our `draw()` function
    will change, too. With the new additions above, the `draw()` function should look
    like [Listing 8-16](ch08.xhtml#ch08list16):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 8-16: The new* `draw()` *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you get what’s shown in [Figure 8-8](ch08.xhtml#ch08fig8).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f164-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: A 3D* `F`!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We can remove the blue grid and make the *F* bigger by changing the `xmin`,
    `xmax`, `ymin`, and `ymax` variables and commenting out the call to the `grid()`
    function in `draw()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-17 shows the full code for drawing a rotating 3D shape.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-17: The full code for rotating the 3D* `F`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: I got rid of the grid and changed the call to the `background()` function in
    `draw()` to `background(0)`, so the background will be black and the *F* will
    appear to be rotating in outer space (see [Figure 8-9](ch08.xhtml#ch08fig9))!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f166-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Moving your mouse around will transform the* `F`!'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: SOLVING SYSTEMS OF EQUATIONS WITH MATRICES
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Have you ever tried solving a system of equations with two or three unknown
    values? That’s a tricky task for any math student. And as the number of unknowns
    increases, the more complicated the system of equations gets to solve. Matrices
    are very useful for solving systems of equations like this one:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e166-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'For example, you can express this multiplication using matrices:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e166-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: This looks similar to the algebra equation 2*x* = 10, which we can solve easily
    by dividing both sides by 2\. If only we could divide both sides of our system
    by the matrix on the left!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there is a way to do just that by finding the inverse of a matrix,
    the same way you can divide a number by 2 by multiplying it by ½. This is known
    as the *multiplicative inverse* of 2, but it’s a complicated method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: GAUSSIAN ELIMINATION
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The more efficient way to solve a system of equations using matrices is to
    use row operations to transform the 2 × 2 matrix on the left into the *identity
    matrix*, which is the matrix that represents the number 1\. For example, multiplying
    a matrix by the identity matrix would result in the original matrix, like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'The numbers on the right would be the solutions for *x* and *y*, so getting
    those zeroes and ones in the right place is our goal. The right place is the diagonal
    of the matrix, like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: The identity matrix in every square matrix has a 1 on the diagonal, where the
    row number equals the column number.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*Gaussian elimination* is a method that involves doing operations on entire
    rows of matrices in order to get to the identity matrix. You can multiply or divide
    a row by a constant, and you can add or subtract a row from another row.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using Gaussian elimination, we first have to arrange the coefficients
    and constants into one matrix, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-03.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'Then, we divide the entire row by the number that will give us a 1 in the top
    left. This means that first we need to divide all the terms in the first row by
    2, since 2/2 is 1\. That operation gives us the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e167-04.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Now we get the *additive inverse* (the number that gives us 0 when added to
    another number) of the term where we want a zero. For example, in row 2, we want
    a zero where the 3 is because we’re looking to change this matrix into the identity
    matrix. Because the additive inverse of 3 is –3, we multiply each term in the
    first row by –3 and add the product to the corresponding term in row 2\. That
    means we multiply the 1 in the first row by –3 and then add the product, which
    is still –3, to the second row. We repeat the process with all the terms in the
    row. For example, the –1/2 in the third column would be multiplied by –3 (to get
    1.5) and added to all the numbers in that column. In this case, it’s just –13,
    so the sum is –11.5 or –23/2\. Continue this, and you should get the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'Now repeat where we want the 1 to be in the second row. We can multiply everything
    in row 2 by –2/23, which should give us this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-02.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we add everything in the first row to the second row, multiplied by
    the additive inverse of 5/2, which is where we want the zero to be in the first
    row. We’ll add every term in the first row to its corresponding term in the second
    row multiplied by –5/2\. Notice this doesn’t affect the 1 in the first row, which
    we want to keep:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-03.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'The solutions to the system of equations are now in the right column: *x* =
    –3, *y* = 1.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check our answers by plugging those numbers into the original system
    of equations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e168-04.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Both solutions are correct, but this is a laborious process. Let’s automate
    this process with Python so we can solve systems that are as big as we want!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE GAUSS() FUNCTION
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we write a function called `gauss()` that solves systems of
    equations for us. Trying to do this programmatically might seem complicated, but
    there are really only two steps that we need to code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Divide all the elements in a row by the term in the diagonal.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each term in one row to the corresponding term in another row.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dividing All Items in a Row
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first task is to divide all the terms in a row by a number. Let’s say we
    have the row of numbers `[1,2,3,4,5]`. For example, we can use the code in [Listing
    8-18](ch08.xhtml#ch08list18) to divide this row by 2\. Open a new Python file,
    call it *gauss.py* and enter the code in [Listing 8-18](ch08.xhtml#ch08list18).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-18: Dividing all the terms in a row by a divisor*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'This loops over the `row` list, keeping track of the index and the value using
    the `enumerate()` function. We then replace each term `row[i]` with the term divided
    by the divisor. When you run this, you’ll get a list of five values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding Each Element to Its Corresponding Element
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second task is to add each element of one row to the corresponding element
    in the other row. For example, add all the elements in row 0 below to the elements
    in row 1 and replace the elements in row 1 with the sum:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’re looping over all the items in the second row (index 1) of `my_matrix`.
    Then we’re incrementing each term (index `i`) in the second row by the corresponding
    term in the first row (index 0). We successfully added the terms in the first
    row to those in the second row. Notice the first row didn’t change. We’ll use
    these steps in solving systems of equations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Repeating the Process for Every Row
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now we just have to put those steps together for all the rows in a matrix.
    We’ll call the matrix *A*. Once we’ve put the *x, y*, and *z*’s and the constant
    terms in order, we put only the coefficients and the constants into the matrix:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e169-01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: First, we divide every term in the row by the term on the diagonal so that the
    diagonal term will be 1, using the code in [Listing 8-19](ch08.xhtml#ch08list19).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 8-19: Dividing every term in a row by the row’s diagonal term*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Using `enumerate`, we can get the first row of *A* (`[2,1,-1,8]`), for example,
    and `j` will be the index of that row (in this case, zero). The diagonal terms
    are where the row number is the same as the column number, like row 0, column
    0, or row 1, column 1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Now we go through every other row in the matrix and perform the second step.
    Now, for each of the other rows (where `i` is not equal to `j`), calculate the
    additive inverse of the `j`th term, multiply each term in row `j` by that inverse,
    and add those terms to their corresponding terms in the `i`th row. Add the code
    in [Listing 8-20](ch08.xhtml#ch08list20) to the `gauss()` function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 8-20: Making every nondiagonal term in a row 0*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens to every row, so since m is the number of rows, we start off with
    `for i in range(m)`. We already divided the row in question by the diagonal term,
    so we don’t have to do anything to that row. That’s why we do it only if `i` is
    not equal to `j`. In our example, each term in the first row of A is going to
    be multiplied by 3 and added to the corresponding term in the second row. And
    then every term in the first row is going to be multiplied by 2 and added to the
    corresponding term in the third row. That will get us zeroes in the second and
    third rows of the first column:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e170-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Now our first column is done, and we want a 1 in the diagonal. Therefore, we
    want a 1 in the second row of the second column, so we repeat the process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Put all the code together into a `gauss()` function and print out the results.
    [Listing 8-21](ch08.xhtml#ch08list21) shows the complete code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 8-21: The complete code for the* `gauss()` *function*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here is how it looks in matrix form:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e171-01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'We look at the last numbers in each row, so our solutions are *x* = 32, *y* =
    –17, and *z* = 39\. We check this by plugging those values into the original equations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e171-02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: This is a major achievement! Now, not only can we solve systems of two or three
    unknowns, but we can also solve for any number of unknowns! Solving a system of
    four unknowns is a laborious task if the student doesn’t know Python. But luckily
    for us, we do! When the correct solution pops up so quickly in the Python shell,
    I’m always blown away. If you’ve ever had to perform Gaussian elimination by hand,
    Exercise 8-2 will blow you away too.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 8-2: ENTER THE MATRIX'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Solve this system of equations for *w, x, y*, and *z* using the program you
    just wrote:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e172-01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: SUMMARY
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve come a long way in your math adventure! You started with some basic Python
    to make turtles walk around and then went on to create more complicated Python
    functions to solve harder math problems. In this chapter, not only did you learn
    how to use Python to add and multiply matrices, but you also experienced first-hand
    how matrices can create an transform 2D and 3D graphics! The power we have to
    add, multiply, transpose, and otherwise operate on matrices using Python is mind-boggling.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: You also learned to automate the process you would have done by hand to solve
    a system of equations. The same program that works for a 3 × 3 matrix will also
    work for a 4 × 4 or any larger square matrix!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Matrices are vital tools in making a neural network, with dozens or even hundreds
    of paths leading to and from virtual neurons. An input is “propagated” through
    the network using matrix multiplication and transposition, the same tools you
    created in this chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: There was a time when what you’ve done in this chapter was out of reach to anyone
    who didn’t have access to an enormous, expensive computer that took up a whole
    floor at a university or major corporation. Now you can perform lightning-fast
    matrix calculations using Python and visualize the results using Processing!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I pointed out how great it is that we get instantaneous solutions
    to our complicated systems of equations as well as immediate responses to our
    mouse movements in our exploration of graphics. In the next chapter, we’ll create
    a model of an ecosystem containing grass and sheep and let it run on its own.
    The model will morph and change over time as the sheep are born, eat, reproduce,
    and die. Only after letting the model run for a minute or more will we be able
    to judge if the environment can find a balance between grass growing and sheep
    eating and multiplying.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
