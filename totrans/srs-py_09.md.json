["```py\n>>> import ast\n>>> ast.parse\n<function parse at 0x7f062731d950>\n>>> ast.parse(\"x = 42\")\n<_ast.Module object at 0x7f0628a5ad10>\n>>> ast.dump(ast.parse(\"x = 42\"))\n\"Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Num(n=42))])\"\n```", "```py\n>>> compile(ast.parse(\"x = 42\"), '<input>', 'exec')\n<code object <module> at 0x111b3b0, file \"<input>\", line 1>\n>>> eval(compile(ast.parse(\"x = 42\"), '<input>', 'exec'))\n>>> x\n42\n```", "```py\n➊ >>> hello_world = ast.Str(s='hello world!', lineno=1, col_offset=1)\n➋ >>> print_name = ast.Name(id='print', ctx=ast.Load(), lineno=1, col_offset=1)\n➌ >>> print_call = ast.Call(func=print_name, ctx=ast.Load(),\n   ... args=[hello_world], keywords=[], lineno=1, col_offset=1)\n➍ >>> module = ast.Module(body=[ast.Expr(print_call, ... lineno=1, col_offset=1)], lineno=1, col_offset=1)\n➎ >>> code = compile(module, '', 'exec')\n   >>> eval(code)\n   hello world!\n```", "```py\n   import ast\n\n   class ReplaceBinOp(ast.NodeTransformer):\n       \"\"\"Replace operation by addition in binary operation\"\"\"\n       def visit_BinOp(self, node):\n           return ast.BinOp(left=node.left,\n                            op=ast.Add(),\n                            right=node.right)\n\n➊ tree = ast.parse(\"x = 1/3\")\n   ast.fix_missing_locations(tree)\n   eval(compile(tree, '', 'exec'))\n   print(ast.dump(tree))\n➋ print(x)\n\n➌ tree = ReplaceBinOp().visit(tree)\n   ast.fix_missing_locations(tree)\n   print(ast.dump(tree))\n   eval(compile(tree, '', 'exec'))\n➍ print(x)\n```", "```py\nModule(body=[Assign(targets=[Name(id='x', ctx=Store())],\n                    value=BinOp(left=Num(n=1), op=Div(), right=Num(n=3)))])\n0.3333333333333333\nModule(body=[Assign(targets=[Name(id='x', ctx=Store())],\n                    value=BinOp(left=Num(n=1), op=Add(), right=Num(n=3)))])\n4\n```", "```py\nclass Bad(object):\n    # self is not used, the method does not need\n    # to be bound, it should be declared static\n    def foo(self, a, b, c):\n        return a + b - c\n\nclass OK(object):\n    # This is correct\n    @staticmethod\n    def foo(a, b, c):\n        return a + b - c\n```", "```py\n[entry_points]\nflake8.extension =\n    --snip--\n    H904 = ast_ext:StaticmethodChecker\n    H905 = ast_ext:StaticmethodChecker\n```", "```py\nclass StaticmethodChecker(object):\n    def __init__(self, tree, filename):\n        self.tree = tree\n\n    def run(self):\n        pass\n```", "```py\nclass StaticmethodChecker(object):\n    def __init__(self, tree, filename):\n        self.tree = tree\n\n    def run(self):\n        for stmt in ast.walk(self.tree):\n            # Ignore non-class\n            if not isinstance(stmt, ast.ClassDef):\n                continue\n```", "```py\nfor stmt in ast.walk(self.tree):\n    # Ignore non-class\n    if not isinstance(stmt, ast.ClassDef):\n        continue\n    # If it's a class, iterate over its body member to find methods\n    for body_item in stmt.body:\n        # Not a method, skip\n        if not isinstance(body_item, ast.FunctionDef):\n            continue\n```", "```py\nfor stmt in ast.walk(self.tree):\n    # Ignore non-class\n    if not isinstance(stmt, ast.ClassDef):\n        continue\n    # If it's a class, iterate over its body member to find methods\n    for body_item in stmt.body:\n        # Not a method, skip\n        if not isinstance(body_item, ast.FunctionDef):\n            continue\n        # Check that it has a decorator\n        for decorator in body_item.decorator_list:\n            if (isinstance(decorator, ast.Name)\n               and decorator.id == 'staticmethod'):\n                # It's a static function, it's OK\n                break else:\n            # Function is not static, we do nothing for now\n            Pass\n```", "```py\n--snip--\n        # Check that it has a decorator\n        for decorator in body_item.decorator_list:\n            if (isinstance(decorator, ast.Name)\n               and decorator.id == 'staticmethod'):\n                # It's a static function, it's OK\n                break\n        else:\n            try:\n                first_arg = body_item.args.args[0]\n            except IndexError:\n                yield (\n                    body_item.lineno,\n                    body_item.col_offset,\n                    \"H905: method misses first argument\",\n                    \"H905\",\n                )\n                # Check next method\n                Continue\n```", "```py\n--snip--\n            try:\n                first_arg = body_item.args.args[0]\n            except IndexError:\n                yield (\n                    body_item.lineno,\n                    body_item.col_offset,\n                    \"H905: method misses first argument\",\n                    \"H905\",\n                )\n                # Check next method\n                continue\n            for func_stmt in ast.walk(body_item):\n                # The checking method must differ between Python 2 and Python 3\n                if six.PY3:\n                    if (isinstance(func_stmt, ast.Name)\n                       and first_arg.arg == func_stmt.id):\n                        # The first argument is used, it's OK\n                        break\n                else:\n                    if (func_stmt != first_arg\n                       and isinstance(func_stmt, ast.Name)\n                       and func_stmt.id == first_arg.id):\n                        # The first argument is used, it's OK\n                        break\n            else:\n                yield (\n                    body_item.lineno,\n                    body_item.col_offset,\n                    \"H904: method should be declared static\",\n                    \"H904\",\n                )\n```", "```py\n% hy\nhy 0.9.10\n=> (+ 1 2)\n3\n```", "```py\n=> (defn hello [name]\n...  (print \"Hello world!\")\n...  (print (% \"Nice to meet you %s\" name)))\n=> (hello \"jd\")\nHello world!\nNice to meet you jd\n```", "```py\n(defclass A [object]\n  [[x 42] [y (fn [self value]\n        (+ self.x value))]])\n```", "```py\n=> (import uuid)\n=> (uuid.uuid4)\nUUID('f823a749-a65a-4a62-b853-2687c69d0e1e')\n=> (str (uuid.uuid4))\n'4efa60f2-23a4-4fc1-8134-00f5c271f809'\n```", "```py\n(cond\n [(> somevar 50)\n  (print \"That variable is too big!\")]\n [(< somevar 10)\n  (print \"That variable is too small!\")]\n [true\n  (print \"That variable is jusssst right!\")])\n```"]