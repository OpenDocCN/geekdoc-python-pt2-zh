["```py\nimport argparse\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom scipy.spatial.distance import squareform, pdist\nfrom numpy.linalg import norm\n❶ width, height = 640, 480\nclass Boids:\n    \"\"\"class that represents Boids simulation\"\"\"\n    def __init__(self, N):\n        \"\"\"initialize the Boids simulation\"\"\"\n        # init position & velocities\n      ❷ self.pos = [width/2.0, height/2.0] +\n                   10*np.random.rand(2*N).reshape(N, 2)\n        # normalized random velocities\n      ❸ angles = 2*math.pi*np.random.rand(N)\n      ❹ self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))\n        self.N = N\n\n```", "```py\n>>> list(`zip([0, 1, 2], [3, 4, 5]))`\n[(0, 3), (1, 4), (2, 5)]\n\n```", "```py\n        # min dist of approach\n      ❶ self.minDist = 25.0\n        # max magnitude of velocities calculated by \"rules\"\n      ❷ self.maxRuleVel = 0.03\n        # max magnitude of final velocity\n      ❸ self.maxVel = 2.0\n\n```", "```py\ndef applyBC(self):\n    \"\"\"apply boundary conditions\"\"\"\n    deltaR = 2.0\n    for coord in self.pos:\n      ❶ if coord[0] > width + deltaR:\n            coord[0] = - deltaR\n        if coord[0] < - deltaR:\n            coord[0] = width + deltaR\n        if coord[1] > height + deltaR:\n            coord[1] = - deltaR\n        if coord[1] < - deltaR:\n            coord[1] = height + deltaR\n\n```", "```py\nfig = plt.figure()\nax = plt.axes(xlim=(0, width), ylim=(0, height))\n❶ pts, = ax.plot([], [], markersize=10, c='k', marker='o', ls='None')\n❷ head, = ax.plot([], [], markersize=4, c='r', marker='o', ls='None')\n❸ anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),\n                               interval=50)\n\n```", "```py\nvec = self.pos + 10*self.vel/self.maxVel\nhead.set_data(vec.reshape(2*self.N)[::2], vec.reshape(2*self.N)[1::2])\n\n```", "```py\ndef test1(pos, radius):\n    # fill output with zeros\n    vel = np.zeros(2*N).reshape(N, 2)\n    # for each pos\n  ❶ for (i1, p1) in enumerate(pos):\n        # velocity contribution\n        val = np.array([0.0, 0.0])\n        # for each other pos\n      ❷ for (i2, p2) in enumerate(pos):\n            if i1 != i2:\n                # calculate distance from p1\n                dist = math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) +\n                                 (p2[1]-p1[1])*(p2[1]-p1[1]))\n                # apply threshold\n              ❸ if dist < radius:\n                  ❹ val += (p2 - p1)\n        # set velocity\n        vel[i1] = val\n    # return computed velocity\n    return vel\n\n```", "```py\ndef test2(pos, radius):\n    # get distance matrix\n  ❶ distMatrix = squareform(pdist(pos))\n    # apply threshold\n  ❷ D = distMatrix < radius\n    # compute velocity\n  ❸ vel = pos*D.sum(axis=1).reshape(N, 1) - D.dot(pos)\n    return vel\n\n```", "```py\n>>> `import numpy as np`\n>>> `from scipy.spatial.distance import squareform, pdist`\n>>> `x = np.array([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]])`\n>>> `squareform(pdist(x))`\narray([[0.        , 1.41421356, 2.82842712],\n       [1.41421356, 0.        , 1.41421356],\n       [2.82842712, 1.41421356, 0.        ]])\n\n```", "```py\n>>> `squareform(``pdist(x)) < 1.4`\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n```", "```py\nimport math\nimport numpy as np\nfrom scipy.spatial.distance import squareform, pdist, cdist\nN = 100\nwidth, height = 640, 480\npos = np.array(list(zip(width*np.random.rand(N), height*np.random.rand(N))))\ndef test1(pos, radius):\n--`snip`--\ndef test2(post, radius):\n--`snip`--\n\n```", "```py\ndef applyRules(self):\n    # get pairwise distances\n  ❶ self.distMatrix = squareform(pdist(self.pos))\n    # apply rule #1: separation\n    D = self.distMatrix < self.minDist\n  ❷ vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)\n  ❸ self.limit(vel, self.maxRuleVel)\n    # distance threshold for alignment (different from separation)\n  ❹ D = self.distMatrix < 50.0\n    # apply rule #2: alignment\n  ❺ vel2 = D.dot(self.vel)\n    self.limit(vel2, self.maxRuleVel)\n  ❻ vel += vel2\n    # apply rule #3: cohesion\n  ❼ vel3 = D.dot(self.pos) - self.pos\n    self.limit(vel3, self.maxRuleVel)\n  ❽ vel += vel3\n    return vel\n\n```", "```py\ndef limit(self, X, maxVal):\n    \"\"\"limit the magnitude of 2D vectors in array X to maxValue\"\"\"\n  ❶ for vec in X:\n        self.limitVec(vec, maxVal)\n\n```", "```py\ndef limitVec(self, vec, maxVal):\n    \"\"\"limit the magnitude of the 2D vector\"\"\"\n  ❶ mag = norm(vec)\n    if mag > maxVal:\n      ❷ vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag\n\n```", "```py\ncid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)\n\n```", "```py\ndef buttonPress(self, event):\n\"\"\"event handler for matplotlib button presses\"\"\"\n# left-click to add a boid\n❶ if event.button is 1:\n  ❷ self.pos = np.concatenate((self.pos,\n                               np.array([[event.xdata, event.ydata]])),\n                               axis=0)\n    # generate a random velocity\n    angles = 2*math.pi*np.random.rand(1)\n    v = np.array(list(zip(np.sin(angles), np.cos(angles))))\n  ❸ self.vel = np.concatenate((self.vel, v), axis=0)\n  ❹ self.N += 1\n\n```", "```py\n    # right-click to scatter boids\n  ❶ elif event.button is 3:\n        # add scattering velocity\n        self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))\n\n```", "```py\ndef tick(frameNum, pts, head, boids):\n    \"\"\"update function for animation\"\"\"\n    boids.tick(frameNum, pts, head)\n    return pts, head\n\n```", "```py\ndef tick(self, frameNum, pts, head):\n    \"\"\"update the simulation by one time step\"\"\"\n    # apply rules\n  ❶ self.vel += self.applyRules()\n  ❷ self.limit(self.vel, self.maxVel)\n  ❸ self.pos += self.vel\n  ❹ self.applyBC()\n    # update data\n  ❺ pts.set_data(self.pos.reshape(2*self.N)[::2],\n                 self.pos.reshape(2*self.N)[1::2])\n  ❻ vec = self.pos + 10*self.vel/self.maxVel\n  ❼ head.set_data(vec.reshape(2*self.N)[::2],\n                  vec.reshape(2*self.N)[1::2])\n\n```", "```py\ndef main():\n    # use sys.argv if needed\n    print('starting boids...')\n    parser = argparse.ArgumentParser(description=\"Implementing Craig\n                                     Reynolds's Boids...\")\n    # add arguments\n  ❶ parser.add_argument('--num-boids', dest='N', required=False)\n    args = parser.parse_args()\n    # set the initial number of boids\n  ❷ N = 100\n    if args.N:\n        N = int(args.N)\n    # create boids\n  ❸ boids = Boids(N)\n\n```", "```py\n$ `python boids.py`\n\n```", "```py\n    self.vel += self.applyRules()\n    self.vel += self.avoidObstacle()\n\n    ```"]