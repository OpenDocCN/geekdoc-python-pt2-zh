["```py\nstrVS = \"\"\"\n# version 410 core\nlayout(location = 0) in vec3 aVert;\nlayout(location = 1) in vec3 aColor;\nlayout(location = 2) in vec3 aNormal;\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n❶ flat out vec3 vColor;\n❷ out vec3 vNormal;\n❸ out vec3 fragPos;\nvoid main() {\n  // transform vertex\n  gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);\n❹ fragPos = aVert;\n  vColor = aColor;\n  vNormal = aNormal;\n}\n\"\"\"\n\n```", "```py\nstrFS = \"\"\"\n# version 410 core\nflat in vec3 vColor;\nin vec3 vNormal;\nin vec3 fragPos;\nout vec4 fragColor;\nvoid main() {\n❶ vec3 lightPos = vec3(10.0, 10.0, 10.0);\n❷ vec3 lightColor = vec3(1.0, 1.0, 1.0);\n❸ vec3 lightDir = normalize(lightPos - fragPos);\n  float diff = max(dot(vNormal, lightDir), 0.0);\n  vec3 diffuse = diff * lightColor;\n  float ambient = 0.1;\n❹ vec3 result = (ambient + diffuse) * vColor.xyz;\n  fragColor = vec4(result, 1.0);\n}\n\"\"\"\n\n```", "```py\nclass Torus:\n    \"\"\" OpenGL 3D scene class\"\"\"\n    # initialization\n  ❶ def __init__(self, R, r, NX, NY):\n        global strVS, strFS\n        # modify shader for flat shading\n        # create shader\n      ❷ self.program = glutils.loadShaders(strVS, strFS)\n        glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)\n        self.pMatrixUniform = glGetUniformLocation(self.program,\n                                                   b'uPMatrix')\n        self.mvMatrixUniform = glGetUniformLocation(self.program,\n                                                    b'uMVMatrix')\n        # torus geometry\n        self.R = R\n        self.r = r\n        # grid size\n        self.NX = NX\n        self.NY = NY\n        # no. of points\n      ❸ self.N = self.NX\n        self.M = self.NY\n        # time\n        self.t = 0\n        # compute parameters for glMultiDrawArrays\n        M1 = 2*self.M + 2\n      ❹ self.first_indices = [2*M1*i for i in range(self.N)]\n        self.counts = [2*M1 for i in range(self.N)]\n        # colors: {(i, j) : (r, g, b)}\n        # with NX * NY entries\n      ❺ self.colors_dict = self.init_colors(self.NX, self.NY)\n        # create an empty array to hold colors\n      ❻ self.colors = np.zeros((3*self.N*(2*self.M + 2), ), np.float32)\n        # get vertices, normals, indices\n      ❼ vertices, normals = self.compute_vertices()\n      ❽ self.compute_colors()\n        # set up vertex buffer objects\n      ❾ self.setup_vao(vertices, normals, self.colors)\n\n```", "```py\ndef init_colors(self, NX, NY):\n    \"\"\"initialize color dictionary\"\"\"\n    colors = {}\n    c1 = [1.0, 1.0, 1.0]\n    for i in range(NX):\n        for j in range(NY):\n          ❶ colors[(i, j)] = c1\n    return colors\n\n```", "```py\ndef compute_vertices(self):\n        R, r, N, M = self.R, self.r, self.N, self.M\n        # create an empty array to hold vertices/normals\n        vertices = []\n        normals = []\n        for i in range(N):\n            # for all M points around a ring\n            for j in range(M+1):\n                # compute angle theta of point\n              ❶ theta = (j % M) *2*math.pi/M\n                #---ring #1------\n                # compute angle\n              ❷ alpha1 = i*2*math.pi/N\n                # compute transforms\n              ❸ RM1, TM1 = self.compute_rt(R, alpha1)\n                # compute points\n              ❹ Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)\n                #---ring #2------\n                # index of next ring\n              ❺ ip1 = (i + 1) % N\n                # compute angle\n              ❻ alpha2 = ip1*2*math.pi/N\n                # compute transforms\n                RM2, TM2 = self.compute_rt(R, alpha2)\n                # compute points\n                Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)\n                # store vertices/normals in right order for GL_TRIANGLE_STRIP\n              ❼ vertices.append(Pt1[0:3])\n                vertices.append(Pt2[0:3])\n                # add normals\n                normals.append(NV1[0:3])\n                normals.append(NV2[0:3])\n        # return vertices and colors in correct format\n      ❽ vertices = np.array(vertices, np.float32).reshape(-1)\n        normals = np.array(normals, np.float32).reshape(-1)\n        # print(vertices.shape)\n        return vertices, normals\n\n```", "```py\ndef compute_rt(self, R, alpha):\n        # compute position of ring\n      ❶ Tx = R*math.cos(alpha)\n        Ty = R*math.sin(alpha)\n        Tz = 0.0\n        # rotation matrix\n      ❷ RM = np.array([\n            [math.cos(alpha), -math.sin(alpha), 0.0, 0.0],\n            [math.sin(alpha), math.cos(alpha), 0.0, 0.0],\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0]\n            ], dtype=np.float32)\n        # translation matrix\n      ❸ TM = np.array([\n            [1.0, 0.0, 0.0, Tx],\n            [0.0, 1.0, 0.0, Ty],\n            [0.0, 0.0, 1.0, Tz],\n            [0.0, 0.0, 0.0, 1.0]\n            ], dtype=np.float32)\n        return (RM, TM)\n\n```", "```py\ndef compute_pt(self, r, theta, RM, TM):\n    # compute point coords\n  ❶ P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],\n                 dtype=np.float32)\n    # print(P)\n    # apply rotation - this also gives us the vertex normals\n  ❷ NV = np.dot(RM, P)\n    # apply translation\n  ❸ Pt = np.dot(TM, NV)\n    return (Pt, NV)\n\n```", "```py\ndef compute_colors(self):\n    R, r, N, M = self.R, self.r, self.N, self.M\n    # the points on the ring are generated on the X-Z plane\n    # then they are rotated and translated into the correct\n    # position on the torus\n    # for all N rings around the torus\n    for i in range(N):\n        # for all M points around a ring\n        for j in range(M+1):\n            # j value\n            jj = j % M\n            # store colors - same color applies to (V_i_j, V_ip1_j)\n          ❶ col = self.colors_dict[(i, jj)]\n            # get index into array\n          ❷ index = 3*(2*i*(M+1) + 2*j)\n            # set color\n          ❸ self.colors[index:index+3] = col\n          ❹ self.colors[index+3:index+6] = col\n\n```", "```py\ndef recalc_colors(self):\n    # get colors\n    self.compute_colors()\n    # bind VAO\n    glBindVertexArray(self.vao)\n    glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)\n    # set buffer data\n  ❶ glBufferSubData(GL_ARRAY_BUFFER, 0, 4*len(self.colors), self.colors)\n    # unbind VAO\n    glBindVertexArray(0)\n\n```", "```py\ndef render(self, pMatrix, mvMatrix):\n    # use shader\n  ❶ glUseProgram(self.program)\n    # set proj matrix\n  ❷ glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)\n    # set modelview matrix\n  ❸ glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)\n    # bind VAO\n  ❹ glBindVertexArray(self.vao)\n    # draw\n  ❺ glMultiDrawArrays(GL_TRIANGLE_STRIP, self.first_indices,\n                      self.counts, self.N)\n    # unbind VAO\n    glBindVertexArray(0)\n\n```", "```py\nclass GOL:\n  ❶ def __init__(self, NX, NY, glider):\n        \"\"\"GOL constructor\"\"\"\n        # a grid of NX x NY random values\n        self.NX, self.NY = NX, NY\n        if glider:\n          ❷ self.addGlider(1, 1, NX, NY)\n        else:\n          ❸ self.grid = np.random.choice([1, 0], NX * NY,\n                                         p=[0.2, 0.8]).reshape(NX, NY)\n\n```", "```py\ndef get_colors(self):\n    colors = {}\n  ❶ c1 = np.array([1.0, 1.0, 1.0], np.float32)\n  ❷ c2 = np.array([0.0, 0.0, 0.0], np.float32)\n    for i in range(self.NX):\n        for j in range (self.NY):\n            if self.grid[i, j] == 1:\n                colors[(i, j)] = c2\n            else :\n                colors[(i, j)] = c1\n    return colors\n\n```", "```py\nclass OrbitCamera:\n    \"\"\"helper class for viewing\"\"\"\n    def __init__(self, height, radius, beta_step=1):\n      ❶ self.radius = radius\n      ❷ self.beta = 0\n      ❸ self.beta_step = beta_step\n      ❹ self.height = height\n        # initial eye vector is (-R, 0, -H)\n        rr = radius/math.sqrt(2.0)\n      ❺ self.eye = np.array([rr, rr, height], np.float32)\n        # compute up vector\n      ❻ self.up = self.__compute_up_vector(self.eye )\n        # center is origin\n      ❼ self.center = np.array([0, 0, 0], np.float32)\n\n```", "```py\ndef __compute_up_vector(self, E):\n    # N = (E x k) x E\n    Z = np.array([0, 0, 1], np.float32)\n  ❶ U = np.cross(np.cross(E, Z), E)\n    # normalize\n  ❷ U = U / np.linalg.norm(U)\n    return U\n\n```", "```py\ndef rotate(self):\n    \"\"\"rotate by one step and compute new camera parameters\"\"\"\n  ❶ self.beta = (self.beta + self.beta_step) % 360\n    # recalculate eye E\n  ❷ self.eye = np.array([self.radius*math.cos(math.radians(self.beta)),\n                         self.radius*math.sin(math.radians(self.beta)),\n                         self.height], np.float32)\n    # up vector\n  ❸ self.up = self.__compute_up_vector(self.eye)\n\n```", "```py\ndef main():\n    print(\"Starting GOL. Press ESC to quit.\")\n    # parse arguments\n    parser = argparse.ArgumentParser(description=\"Runs Conway's Game of Life\n                                     simulation on a Torus.\")\n    # add arguments\n  ❶ parser.add_argument('--glider', action='store_true', required=False)\n    args = parser.parse_args()\n    glider = False\n    if args.glider:\n      ❷ glider = True\n  ❸ rw = RenderWindow(glider)\n  ❹ rw.run()\n\n```", "```py\nclass RenderWindow:\n    def __init__(self, glider):\n    --`snip`--\n       # create 3D\n        NX = 64\n        NY = 64\n        R = 4.0\n        r = 1.0\n      ❶ self.torus = Torus(R, r, NX, NY)\n      ❷ self.gol = GOL(NX, NY, glider)\n        # create a camera\n      ❸ self.camera = OrbitCamera(5.0, 10.0)\n        # exit flag\n      ❹ self.exitNow = False\n      # rotation flag\n      ❺ self.rotate = True\n        # skip count\n      ❻ self.skip = 0\n\n```", "```py\ndef run(self):\n    # initializer timer\n    glfw.glfwSetTime(0)\n    t = 0.0\n  ❶ while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:\n        # update every x seconds\n        currT = glfw.glfwGetTime()\n      ❷ if currT - t > 0.05:\n            # update time\n            t = currT\n            # set viewport\n          ❸ self.width, self.height = glfw.glfwGetFramebufferSize(self.win)\n            self.aspect = self.width/float(self.height)\n            glViewport(0, 0, self.width, self.height)\n            # clear\n            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n            # build projection matrix\n            pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)\n            mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,\n                                      self.camera.up)\n            # render\n          ❹ self.torus.render(pMatrix, mvMatrix)\n            # step\n          ❺ if self.rotate:\n                self.step()\n            glfw.glfwSwapBuffers(self.win)\n            # poll for and process events\n            glfw.glfwPollEvents()\n    # end\n    glfw.glfwTerminate()\n\n```", "```py\ndef step(self):\n  ❶ if self.skip == 9:\n        # update GOL\n      ❷ self.gol.update()\n      ❸ colors = self.gol.get_colors()\n      ❹ self.torus.set_colors(colors)\n        # step\n      ❺ self.torus.step()\n        # reset\n      ❻ self.skip = 0\n    # update skip\n  ❼ self.skip += 1\n    # rotate camera\n  ❽ self.camera.rotate()\n\n```", "```py\n$ `python gol_torus.py`\n\n```", "```py\n$ `python gol_torus.py --glider`\n\n```", "```py\n\"\"\"\ntorus.py\nA Python OpenGL program that generates a torus.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport OpenGL\nfrom OpenGL.GL import *\nimport numpy as np\nimport math, sys, os\nimport glutils\nimport glfw\nstrVS = \"\"\"\n# version 330 core\nlayout(location = 0) in vec3 aVert;\nlayout(location = 1) in vec3 aColor;\nlayout(location = 2) in vec3 aNormal;\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nflat out vec3 vColor;\nout vec3 vNormal;\nout vec3 fragPos;\nvoid main() {\n  // transform vertex\n  gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);\n  fragPos = aVert;\n  vColor = aColor;\n  vNormal = aNormal;\n}\n\"\"\"\nstrFS = \"\"\"\n# version 330 core\nflat in vec3 vColor;\nin vec3 vNormal;\nin vec3 fragPos;\nout vec4 fragColor;\nvoid main() {\n  vec3 lightPos = vec3(10.0, 10.0, 10.0);\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diff = max(dot(vNormal, lightDir), 0.0);\n  vec3 diffuse = diff * lightColor;\n  float ambient = 0.1;\n  vec3 result = (ambient + diffuse) * vColor.xyz;\n  fragColor = vec4(result, 1.0);\n}\n\"\"\"\nclass Torus:\n    \"\"\" OpenGL 3D scene class\"\"\"\n    # initialization\n    def __init__(self, R, r, NX, NY):\n        global strVS, strFS\n        # create shader\n        self.program = glutils.loadShaders(strVS, strFS)\n        glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)\n        self.pMatrixUniform = glGetUniformLocation(self.program,\n                                                   b'uPMatrix')\n        self.mvMatrixUniform = glGetUniformLocation(self.program,\n                                                    b'uMVMatrix')\n        # torus geometry\n        self.R = R\n        self.r = r\n        # grid size\n        self.NX = NX\n        self.NY = NY\n        # no. of points\n        self.N = self.NX\n        self.M = self.NY\n        # time\n        self.t = 0\n        # compute parameters for glMultiDrawArrays\n        M1 = 2*self.M + 2\n        self.first_indices = [2*M1*i for i in range(self.N)]\n        self.counts = [2*M1 for i in range(self.N)]\n        # colors: {(i, j) : (r, g, b)}\n        # with NX * NY entries\n        self.colors_dict = self.init_colors(self.NX, self.NY)\n        # create an empty array to hold colors\n        self.colors = np.zeros((3*self.N*(2*self.M + 2), ), np.float32)\n        # get vertices, normals, indices\n        vertices, normals = self.compute_vertices()\n        self.compute_colors()\n        # set up vertex buffer objects\n        self.setup_vao(vertices, normals, self.colors)\n    def init_colors(self, NX, NY):\n        \"\"\"initialize color dictionary\"\"\"\n        colors = {}\n        c1 = [1.0, 1.0, 1.0]\n        for i in range(NX):\n            for j in range (NY):\n                colors[(i, j)] = c1\n        return colors\n    def compute_rt(self, R, alpha):\n        # compute position of ring\n        Tx = R*math.cos(alpha)\n        Ty = R*math.sin(alpha)\n        Tz = 0.0\n        # rotation matrix\n        RM = np.array([\n            [math.cos(alpha), -math.sin(alpha), 0.0, 0.0],\n            [math.sin(alpha), math.cos(alpha), 0.0, 0.0],\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0]\n            ], dtype=np.float32)\n        # translation matrix\n        TM = np.array([\n            [1.0, 0.0, 0.0, Tx],\n            [0.0, 1.0, 0.0, Ty],\n            [0.0, 0.0, 1.0, Tz],\n            [0.0, 0.0, 0.0, 1.0]\n            ], dtype=np.float32)\n        return (RM, TM)\n    def compute_pt(self, r, theta, RM, TM):\n        # compute point coords\n        P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],\n                     dtype=np.float32)\n        # print(P)\n        # apply rotation - this also gives us the vertex normals\n        NV = np.dot(RM, P)\n        # normalize\n        # NV = NV / np.linalg.norm(NV)\n        # apply translation\n        Pt = np.dot(TM, NV)\n        return (Pt, NV)\n    def compute_vertices(self):\n        \"\"\"compute vertices for the torus\n           returns np float32 array of n coords (x, y, z): shape (3*n, )\n        \"\"\"\n        R, r, N, M = self.R, self.r, self.N, self.M\n        # create an empty array to hold vertices/normals\n        vertices = []\n        normals = []\n        # the points on the ring are generated on the X-Z plane\n        # then they are rotated and translated into the correct\n        # position on the torus\n        # for all N rings around the torus\n        for i in range(N):\n            # for all M points around a ring\n            for j in range(M+1):\n                # compute angle theta of point\n                theta = (j % M) *2*math.pi/M\n                #---ring #1------\n                # compute angle\n                alpha1 = i*2*math.pi/N\n                # compute transforms\n                RM1, TM1 = self.compute_rt(R, alpha1)\n                # compute points\n                Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)\n                #---ring #2------\n                # index of next ring\n                ip1 = (i + 1) % N\n                # compute angle\n                alpha2 = ip1*2*math.pi/N\n                # compute transforms\n                RM2, TM2 = self.compute_rt(R, alpha2)\n                # compute points\n                Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)\n                # store vertices/normals in right order for GL_TRIANGLE_STRIP\n                vertices.append(Pt1[0:3])\n                vertices.append(Pt2[0:3])\n                # add normals\n                normals.append(NV1[0:3])\n                normals.append(NV2[0:3])\n        # return vertices and colors in correct format\n        vertices = np.array(vertices, np.float32).reshape(-1)\n        normals = np.array(normals, np.float32).reshape(-1)\n        # print(vertices.shape)\n        return vertices, normals\n    def compute_colors(self):\n        \"\"\"compute vertices for the torus\n           returns np float32 array of n coords (x, y, z): shape (3*n, )\n        \"\"\"\n        R, r, N, M = self.R, self.r, self.N, self.M\n        # the points on the ring are generated on the X-Z plane\n        # then they are rotated and translated into the correct\n        # position on the torus\n        # for all N rings around the torus\n        for i in range(N):\n            # for all M points around a ring\n            for j in range(M+1):\n                # j value\n                jj = j % M\n                # store colors - same color applies to (V_i_j, V_ip1_j)\n                col = self.colors_dict[(i, jj)]\n                # get index into array\n                index = 3*(2*i*(M+1) + 2*j)\n                # set color\n                self.colors[index:index+3] = col\n                self.colors[index+3:index+6] = col\n    def setup_vao(self, vertices, normals, colors):\n        # set up vertex array object (VAO)\n        self.vao = glGenVertexArrays(1)\n        glBindVertexArray(self.vao)\n        # --------\n        # vertices\n        # --------\n        self.vertexBuffer = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)\n        # set buffer data\n        glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices,\n                     GL_STATIC_DRAW)\n        # enable vertex attribute array\n        glEnableVertexAttribArray(0)\n        # set buffer data pointer\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)\n        # normals\n        # --------\n        self.normalBuffer = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.normalBuffer)\n        # set buffer data\n        glBufferData(GL_ARRAY_BUFFER, 4*len(normals), normals,\n                     GL_STATIC_DRAW)\n        # enable vertex attribute array\n        glEnableVertexAttribArray(2)\n        # set buffer data pointer\n        glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, None)\n        # --------\n        # colors\n        # --------\n        self.colorBuffer = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)\n        # set buffer data\n        glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors,\n                     GL_STATIC_DRAW)\n        # enable color attribute array\n        glEnableVertexAttribArray(1)\n        # set buffer data pointer\n        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, None)\n        # unbind VAO\n        glBindVertexArray(0)\n    def set_colors(self, colors):\n        self.colors_dict = colors\n        self.recalc_colors()\n    def recalc_colors(self):\n        # get colors\n        self.compute_colors()\n        # bind VAO\n        glBindVertexArray(self.vao)\n        # --------\n        # colors\n        # --------\n        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)\n        # set buffer data\n        glBufferSubData(GL_ARRAY_BUFFER, 0, 4*len(self.colors), self.colors)\n        # unbind VAO\n        glBindVertexArray(0)\n    # step\n    def step(self):\n        # recompute colors\n        self.recalc_colors()\n    # render\n    def render(self, pMatrix, mvMatrix):\n        # use shader\n        glUseProgram(self.program)\n        # set proj matrix\n        glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)\n        # set modelview matrix\n        glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)\n        # bind VAO\n        glBindVertexArray(self.vao)\n        # draw\n        glMultiDrawArrays(GL_TRIANGLE_STRIP, self.first_indices,\n                          self.counts, self.N)\n        # unbind VAO\n        glBindVertexArray(0)\n\n```", "```py\n\"\"\"\ncamera.py\nA simple camera class for OpenGL rendering.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport numpy as np\nimport math\nclass OrbitCamera:\n    \"\"\"helper class for viewing\"\"\"\n    def __init__(self, height, radius, beta_step=1):\n        self.radius = radius\n        self.beta = 0\n        self.beta_step = beta_step\n        self.height = height\n        # initial eye vector is (-R, 0, -H)\n        rr = radius/math.sqrt(2.0)\n        self.eye = np.array([rr, rr, height], np.float32)\n        # compute up vector\n        self.up = self.__compute_up_vector(self.eye )\n        # center is origin\n        self.center = np.array([0, 0, 0], np.float32)\n    def __compute_up_vector(self, E):\n        \"\"\"compute up vector\n        N = (E x k) x E\n        \"\"\"\n        # N = (E x k) x E\n        Z = np.array([0, 0, 1], np.float32)\n        U = np.cross(np.cross(E, Z), E)\n        # normalize\n        U = U / np.linalg.norm(U)\n        return U\n    def rotate(self):\n        \"\"\"rotate by one step and compute new camera parameters\"\"\"\n        self.beta = (self.beta + self.beta_step) % 360\n        # recalculate eye E\n        self.eye = np.array([self.radius*math.cos(math.radians(self.beta)),\n                             self.radius*math.sin(math.radians(self.beta)),\n                             self.height], np.float32)\n        # up vector\n        self.up = self.__compute_up_vector(self.eye)\n\n```"]