- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing the Mr. Stick Man Game
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we’ve created the images for *Mr. Stick Man Races for the Exit*, we
    can begin developing the code. The description of the game in the previous chapter
    gives us an idea what we’ll need: a stick figure that can run and jump and platforms
    he must jump to. We’ll write code to display the stick figure and move it across
    the screen, as well as to display the platforms. But before we write this code,
    we need to create the canvas to display our background image.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Game Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we’ll create a class called Game that will be our program’s main controller.
    The Game class will have an __init__ function for initializing the game and a
    mainloop function for doing the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Window Title and Creating the Canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first part of the __init__ function, we’ll set the window title and
    create the canvas. As you’ll see, this part of the code is similar to the code
    we wrote for *Bounce!* in [Chapter 11](ch11.xhtml#ch11). Open a new file in IDLE
    and enter the following code, and then save your file as *stickmangame.py*. Make
    sure you save it in the *stickman* folder we created in [Chapter 13](ch13.xhtml#ch13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first half of this program (the lines from tkinter import * to self.tk.wm_attributes),
    we create the tk object and then set the window title with self.tk.title to (“Mr.
    Stick Man Races for the Exit”). We make the window *fixed* (so it can’t be resized)
    by calling the resizable function, and then we move the window in front of all
    other windows with the wm_attributes function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the canvas with the self.canvas = Canvas line, and call the
    pack and update functions of the tk object. Finally, we create two variables for
    our Game class, height and width, to store the height and width (we use the winfo_height
    and winfo_width functions to get the size of the canvas).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*The backslash (\) in the line self.canvas = Canvas is used only to separate
    a long line of code. It’s not required in this case, but I’ve included it here
    for readability as the entire line won’t fit on the page.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the __init__ Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now enter the rest of the __init__ function into the *stickman game.py* file
    you just created. This code will load the background image and then display it
    on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At the line beginning self.bg, we create the variable bg, which contains a PhotoImage
    object—the background image file called *background.gif* that we created in [Chapter
    13](ch13.xhtml#ch13) on [page 210](ch13.xhtml#ch13lev1sec8). Next, we store the
    width and height of the image in the w and h variables. The PhotoImage class functions
    width and height return the size of the image once it’s been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Next come two loops inside this function. To understand what they do, imagine
    you have a small square rubber stamp, an ink pad, and a large piece of paper.
    How can you use the stamp to fill the paper with colored squares? Well, you could
    just randomly cover the page with stamps until it’s filled. The result would be
    a mess, and it would take a while to complete, but it would fill the page. Or
    you could start stamping down in a column and then move back to the top and start
    stamping down the page in the next column, as shown in [Figure 14-1](ch14.xhtml#ch14fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: Stamping down the page*'
  prefs: []
  type: TYPE_NORMAL
- en: The background image we created in the previous chapter is our stamp. We know
    that the canvas is 500 pixels across and 500 pixels down, and that we created
    a background image of 100 pixels square. This tells us that we need five columns
    across and five rows down to fill the screen with images. We use a for loop ➊
    to calculate the columns across, and another for loop ➋ to calculate rows going
    down.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we multiply the first loop variable x by the width of the image
    (x * w) to determine how far across we’re drawing, and then multiply the second
    loop variable y by the height of the image (y * h) to calculate how far down to
    draw. We use the create_image function of the canvas object (self.canvas.create
    _image) to draw the image on the screen using those coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the variables sprites, which holds an empty list, and running,
    which contains the True Boolean value. We’ll use these variables later in our
    game code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the mainloop Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use the mainloop function in the Game class to animate our game. This
    function looks a lot like the main loop (or animation loop) we created for the
    *Bounce!* game in [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create a while loop that will run until the game window is closed (while
    True is an infinite loop, which we first saw back on [page 175](ch11.xhtml#para95)).
    Next, we check to see if the running variable is equal to True. If it is, we loop
    through any sprites in the list of sprites (self.sprites), calling the move function
    for each one. (We have yet to create any sprites, so this code won’t do anything
    if we run the program now, but it will be useful later.)
  prefs: []
  type: TYPE_NORMAL
- en: The last three lines of the function force the tk object to redraw the screen
    and sleep for a fraction of a second, as we did with the *Bounce!* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So you can run this code, add the following two lines (note that there’s no
    indentation) and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0217-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Be sure to add this code to the bottom of your game file. Also, make sure
    that your images and Python file are all in the* stickman *folder you created
    in [Chapter 13](ch13.xhtml#ch13).*'
  prefs: []
  type: TYPE_NORMAL
- en: This code creates an object of the Game class and saves it as the g variable.
    We then call the mainloop function on the new object to draw the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve saved the program, run it in IDLE with **Run** ▸ **Run Module**.
    A window should appear with the background image filling the canvas, as in [Figure
    14-2](ch14.xhtml#ch14fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Game background*'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we’ve added a nice background for our game and created an animation
    loop that will draw sprites for us (once we’ve created them).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Coords Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create the class that we’ll use to specify the position of sprites
    on our game screen. This class will store the top-left (*x1* and *y1*) and bottom-right
    (*x2* and *y2*) coordinates of any component of our game.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-3](ch14.xhtml#ch14fig03) shows how you might record the position
    of the stick figure image using these coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Where the x and y coordinates can be found on the stick figure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new class, Coords, will contain only an __init__ function, to which we
    pass the four parameters (x1, y1, x2, and y2). Put this code at the beginning
    of the *stickmangame.py* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each parameter is saved as an object variable of the same name (x1,
    y1, x2, and y2). We’ll be using objects of this class shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Collisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we know how to store the position of our game sprites, we need a way to
    tell if one sprite has collided with another, like when Mr. Stick Man jumps around
    the screen and runs into one of the platforms. To make this problem easier to
    solve, we can break it into two smaller problems: checking if sprites are colliding
    vertically, and checking if sprites are colliding horizontally. We can then combine
    our solutions to see if two sprites are colliding in any direction!'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites Colliding Horizontally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we’ll create the within_x function to determine if one set of *x* coordinates
    (*x1* and *x2*) has crossed over another set of *x* coordinates (again, *x1* and
    *x2*). Add the following directly below the Coords class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The within_x function takes the parameters co1 and co2, both Coords objects.
    We first check to see if the leftmost position of the first coordinate object
    (co1.x1) is between the leftmost position (co2.x1) and the rightmost position
    (co2.x2) of the second coordinate object ➊. We return True if it is.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0220-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s take a look at two lines with overlapping *x* coordinates to understand
    how this works. Each line in [Figure 14-4](ch14.xhtml#ch14fig04) starts at x1
    and finishes at x2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Overlapping horizontal (x) coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line in this diagram (co1) starts at pixel position 50 (x1) and finishes
    at 100 (x2). The second line (co2) starts at position 40 and finishes at 150\.
    In this case, because the x1 position of the first line is between the x1 and
    x2 positions of the second line, the if statement in the function would be true
    for these two sets of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the first elif statement ➋, we see whether the rightmost position of the
    first line (co1.x2) is between the leftmost position (co2.x1) and rightmost position
    (co2.x2) of the second. If it is, we return True. The next two elif statements
    do almost the same thing: they check the leftmost and rightmost positions of the
    second line (co2) against the first (co1).'
  prefs: []
  type: TYPE_NORMAL
- en: If none of the if statements match, we reach else and return False. This is
    effectively saying, “No, the two coordinate objects do not cross over each other
    horizontally.”
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example of the function working, look back at [Figure 14-4](ch14.xhtml#ch14fig04).
    The x1 and x2 positions of the first coordinate object are 50 and 100, and the
    x1 and x2 positions of the second coordinate object are 40 and 150\. Here’s what
    happens when we call the within_x function we’ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function returns True. This is the first step in determining whether one
    sprite has bumped into another. For example, when we create a class for Mr. Stick
    Man and for the platforms, we’ll be able to tell if their *x* coordinates have
    crossed one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not best practice to have lots of if or elif statements that return the
    same value. To solve this problem, we can shorten the within_x function by surrounding
    each of its conditions with parentheses, separated by the or keyword. For a slightly
    neater function with fewer lines of code, you can change the function so it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To extend the if statement across multiple lines so that we don’t end up with
    one really long line containing all the conditions, we use a backslash (\), as
    shown above.
  prefs: []
  type: TYPE_NORMAL
- en: Sprites Colliding Vertically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also need to know if sprites collide vertically. The within_y function is
    very similar to the within_x function. To create it, we check whether the *y1*
    position of the first coordinate has crossed over the *y1* and *y2* positions
    of the second, and then vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function below the within_x function. This time, we’ll use
    the shorter version of the code (rather than lots of if statements):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0222-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our within_x and within_y functions look quite similar because, in the end,
    they are doing similar things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting It All Together: Our Final Collision-Detection Code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we’ve determined whether one set of *x* coordinates has crossed over another,
    and done the same for *y* coordinates, we can write functions to see whether a
    sprite has hit another sprite and on which side. We’ll do this with the collided_left,
    collided_right, collided_top, and collided_bottom functions.
  prefs: []
  type: TYPE_NORMAL
- en: The collided_left Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following code for the collided_left function below the two within
    functions we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function tells us whether the left-hand side (the x1 value) of a first
    coordinate object has hit another coordinate object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function takes two parameters: co1 (the first coordinate object) and co2
    (the second coordinate object). We check whether the two coordinate objects have
    crossed over vertically, using the within_y function. After all, there’s no point
    in checking whether Mr. Stick Man has hit a platform if he is floating way above
    it (like [Figure 14-5](ch14.xhtml#ch14fig05)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Mr. Stick Man above the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we see if the value of the leftmost position of the first coordinate object
    (co1.x1) has hit the x2 position of the second coordinate object (co2.x2). If
    so, it should be less than or equal to the x2 position. We also check to make
    sure that it hasn’t gone past the x1 position. If it has hit the side, we return
    True. If none of the if statements are true, we return False.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0224-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The collided_right Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The collided_right function looks a lot like collided_left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with collided_left, we check to see if the *y* coordinates have crossed over
    each other, using the within_y function. We then check to see if the x2 value
    of the first coordinate object is between the x1 and x2 positions of the second
    coordinate object, and return True if it is. Otherwise, we return False.
  prefs: []
  type: TYPE_NORMAL
- en: The collided_top Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The collided_top function is very similar to the two functions we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time, we check to see if the coordinates have crossed over horizontally,
    using the within_x function. Next, we see if the topmost position of the first
    coordinate (co1.y1) has crossed over the y2 position of the second coordinate,
    but not its y1 position. If so, we return True (the top of the first coordinate
    has hit the second coordinate).
  prefs: []
  type: TYPE_NORMAL
- en: The collided_bottom Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our last function, collided_bottom, is just a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function takes an additional parameter, y, a value that we add to the y
    position of the first coordinate. Our if statement checks if the coordinates have
    crossed over horizontally (as we did with collided_top). Next, we add the value
    of the y parameter to the first coordinate’s y2 position, and store the result
    in the y_calc variable. If the newly calculated value is between the y1 and y2
    values of the second coordinate ➊, we return True because the bottom of coordinate
    co1 has hit the top of coordinate co2. However, if none of the if statements are
    true, we return False.
  prefs: []
  type: TYPE_NORMAL
- en: We need the additional y parameter because Mr. Stick Man could fall off a platform.
    Unlike the other collided functions, we need to be able to test if he *would*
    collide at the bottom, rather than whether he already has. If he walks off a platform
    and keeps floating in midair, our game won’t be very realistic; so as he walks,
    we check to see if he has collided with something on the left or right. When we
    check below him, we see if he would collide with the platform; if not, he needs
    to go crashing down!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Sprite Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parent class for our game items, Sprite, will provide two functions: move
    to move the sprite, and coords to return the sprite’s current position on the
    screen. We add the code for the Sprite class below the collided_bottom function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Sprite class’s __init__ function takes a single parameter, game, which will
    be the game object. We need it so that any sprite we create will be able to access
    the list of other sprites in the game. We store the game parameter as an object
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we store the object variable endgame, which we’ll use to indicate the
    end of the game. (At the moment, it’s set to False.) The final object variable,
    coordinates, is set to nothing (None).
  prefs: []
  type: TYPE_NORMAL
- en: The move function does nothing in this parent class, so we use the pass keyword
    in the body of this function. The coords function simply returns the object variable
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: So our Sprite class has a move function that does nothing and a coords function
    that returns no coordinates. That doesn’t sound very useful, does it? However,
    any classes that have Sprite as their parent will always have the move and coords
    functions. So, in the main loop of the game, when we loop through a list of sprites,
    calling the move function won’t cause any errors because each sprite has that
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0226-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Classes with functions that don’t do very much are quite common in programming.
    In a way, they’re an agreement that ensures all the children of a class provide
    the same sort of functionality, even if in some cases the functions in the child
    classes do nothing.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll add the platforms. Our class for platform objects, PlatformSprite,
    will be a child class of Sprite. The __init__ function for this class will take
    a game parameter (as the Sprite parent class does), as well as an image, x and
    y positions, and the image width and height. Here’s the code for the PlatformSprite
    class, which goes directly below the Sprite class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define the PlatformSprite class, we give it a single parameter: the
    name of the parent class (Sprite). The __init__ function has seven parameters:
    self, game, photo_image, x, y, width, and height.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the __init__ function of the parent class, Sprite, using self and game
    as the parameter values, because other than the self parameter, the Sprite class’s
    __init__ function takes only one parameter: game.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if we were to create a PlatformSprite object, it would have all
    the object variables from its parent class (game, endgame, and coordinates), simply
    because we’ve called the __init__ function in Sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0227-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we save the photo_image parameter as an object variable, and we use the
    canvas variable of the game object to draw the image onscreen with create_image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a Coords object with the x and y parameters as the first
    two arguments. We then add the width and height parameters to these parameters
    for the second two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the coordinates variable is set to None in the Sprite parent class,
    we’ve changed it in our PlatformSprite child class to an actual Coords object,
    containing the live location of the platform image on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Platform Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a platform to the game to see how it looks. Change the last two lines
    of the game file (*stickmangame.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We create an object of the PlatformSprite class, passing it the variable for
    our game (g), along with a PhotoImage object (which uses the first of our platform
    images, *platform1.gif*) ➊. We also pass it the position where we want to draw
    the platform (0 pixels across and 480 pixels down, near the bottom of the canvas),
    along with the height and width of our image (100 pixels across and 10 pixels
    high). We add this sprite to the list of sprites in our game object ➋.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, you should see a platform at the bottom-left side of
    the screen, like [Figure 14-6](ch14.xhtml#ch14fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: Displaying a platform*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Bunch of Platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a whole bunch of platforms. Each platform will have different *x*
    and *y* positions, so they’ll be scattered around the screen. Use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We first create a ton of PlatformSprite objects, saving them as variables platform1,
    platform2, platform3, and so on, up to platform10. We then add each platform to
    the sprites variable, which we created in our Game class. If you run the game
    now, it should look like [Figure 14-7](ch14.xhtml#ch14fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: Displaying all the platforms*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created the basics of our game! Now we’re ready to add our main character,
    Mr. Stick Man.
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you created the Game class and drew the background image onto
    the screen. You learned how to determine whether a horizontal or vertical position
    is within the bounds of two other horizontal or vertical positions by creating
    the within_x and within_y functions. You then used these functions to create new
    functions that determine whether one coordinate object had collided with another.
    We’ll use these functions in the next chapters when we animate Mr. Stick Man and
    need to detect whether he has collided with a platform as he moves around the
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a parent class Sprite and its first child class, PlatformSprite,
    which we used to draw the platforms onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Puzzles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following coding puzzles are some ways to experiment with the game’s background
    image. Check your answers at *[http://python-for-kids.com](http://python-for-kids.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: '#1: Checkerboard'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try changing the Game class so that the background image is drawn like a checkerboard,
    as in [Figure 14-8](ch14.xhtml#ch14fig08).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Background as a checkerboard*'
  prefs: []
  type: TYPE_NORMAL
- en: '#2: Two-Image Checkerboard'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve figured out how to create a checkerboard effect, try using two alternating
    images. Come up with another wallpaper image (using your graphics program), and
    then change the Game class so it displays a checkerboard with two alternating
    images instead of one image and the blank background.
  prefs: []
  type: TYPE_NORMAL
- en: '#3: Bookshelf and Lamp'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can create different wallpaper images to make the game’s background more
    interesting. Create a copy of the background image; then draw a simple bookshelf,
    a table with a lamp, or a window. Dot these images around the screen by changing
    the Game class so that it displays a few different wallpaper images.
  prefs: []
  type: TYPE_NORMAL
- en: '#4: Random Background'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an alternative to the two-image checkerboard, try creating five different
    background images. You can either draw them as a repeating pattern of background
    images (1, 2, 3, 4, 5, 1, 2, 3, 4, 5, and so on), or you can draw them randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: If you import the random module and put your images in a list, try using
    random.choice() to pick one randomly.'
  prefs: []
  type: TYPE_NORMAL
