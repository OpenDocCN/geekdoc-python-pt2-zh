- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: Developing the Mr. Stick Man Game
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 Mr. Stick Man 游戏
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: 'Now that we’ve created the images for *Mr. Stick Man Races for the Exit*, we
    can begin developing the code. The description of the game in the previous chapter
    gives us an idea what we’ll need: a stick figure that can run and jump and platforms
    he must jump to. We’ll write code to display the stick figure and move it across
    the screen, as well as to display the platforms. But before we write this code,
    we need to create the canvas to display our background image.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 *Mr. Stick Man Races for the Exit* 的图像，可以开始编写代码了。上一章对游戏的描述让我们知道需要什么：一个可以跑步和跳跃的火柴人，以及他必须跳到的平台。我们将编写代码来显示火柴人并让它在屏幕上移动，同时显示平台。但在编写这些代码之前，我们需要先创建画布来显示我们的背景图像。
- en: Creating the Game Class
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Game 类
- en: First, we’ll create a class called Game that will be our program’s main controller.
    The Game class will have an __init__ function for initializing the game and a
    mainloop function for doing the animation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为 Game 的类，它将作为我们程序的主要控制器。Game 类将有一个 __init__ 函数用于初始化游戏，还有一个 mainloop
    函数用于执行动画。
- en: Setting the Window Title and Creating the Canvas
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置窗口标题并创建画布
- en: 'In the first part of the __init__ function, we’ll set the window title and
    create the canvas. As you’ll see, this part of the code is similar to the code
    we wrote for *Bounce!* in [Chapter 11](ch11.xhtml#ch11). Open a new file in IDLE
    and enter the following code, and then save your file as *stickmangame.py*. Make
    sure you save it in the *stickman* folder we created in [Chapter 13](ch13.xhtml#ch13):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__ 函数的第一部分，我们将设置窗口标题并创建画布。正如你所看到的，这部分代码与我们在[第11章](ch11.xhtml#ch11)为
    *Bounce!* 编写的代码类似。在 IDLE 中打开一个新文件，输入以下代码，并将文件保存为 *stickmangame.py*。确保将文件保存在我们在[第13章](ch13.xhtml#ch13)中创建的
    *stickman* 文件夹中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first half of this program (the lines from tkinter import * to self.tk.wm_attributes),
    we create the tk object and then set the window title with self.tk.title to (“Mr.
    Stick Man Races for the Exit”). We make the window *fixed* (so it can’t be resized)
    by calling the resizable function, and then we move the window in front of all
    other windows with the wm_attributes function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的前半部分（从 tkinter import * 到 self.tk.wm_attributes 的代码行），我们创建了 tk 对象，然后通过 self.tk.title
    设置窗口标题为（“Mr. Stick Man Races for the Exit”）。我们通过调用 resizable 函数使窗口 *固定*（以防止窗口大小被调整），然后通过
    wm_attributes 函数将窗口移到所有其他窗口的前面。
- en: Next, we create the canvas with the self.canvas = Canvas line, and call the
    pack and update functions of the tk object. Finally, we create two variables for
    our Game class, height and width, to store the height and width (we use the winfo_height
    and winfo_width functions to get the size of the canvas).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过 self.canvas = Canvas 行创建了画布，并调用了 tk 对象的 pack 和 update 函数。最后，我们为 Game
    类创建了两个变量 height 和 width，用于存储画布的高度和宽度（我们使用 winfo_height 和 winfo_width 函数来获取画布的尺寸）。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*The backslash (\) in the line self.canvas = Canvas is used only to separate
    a long line of code. It’s not required in this case, but I’ve included it here
    for readability as the entire line won’t fit on the page.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*在代码行 self.canvas = Canvas 中的反斜杠 (\) 仅用于分隔一行较长的代码。虽然在此情况下并不需要它，但为了提高可读性，我在此包含了它，因为整行代码无法在页面上显示完整。*'
- en: Finishing the __init__ Function
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成 __init__ 函数
- en: 'Now enter the rest of the __init__ function into the *stickman game.py* file
    you just created. This code will load the background image and then display it
    on the canvas:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你刚才创建的 *stickman game.py* 文件中输入其余的 __init__ 函数代码。此代码将加载背景图片，并将其显示在画布上：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the line beginning self.bg, we create the variable bg, which contains a PhotoImage
    object—the background image file called *background.gif* that we created in [Chapter
    13](ch13.xhtml#ch13) on [page 210](ch13.xhtml#ch13lev1sec8). Next, we store the
    width and height of the image in the w and h variables. The PhotoImage class functions
    width and height return the size of the image once it’s been loaded.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以 self.bg 开头的代码行中，我们创建了一个名为 bg 的变量，它包含一个 PhotoImage 对象——我们在[第13章](ch13.xhtml#ch13)的[第210页](ch13.xhtml#ch13lev1sec8)中创建的背景图片文件
    *background.gif*。接下来，我们将图片的宽度和高度存储在 w 和 h 变量中。PhotoImage 类的 width 和 height 函数返回加载后的图片大小。
- en: Next come two loops inside this function. To understand what they do, imagine
    you have a small square rubber stamp, an ink pad, and a large piece of paper.
    How can you use the stamp to fill the paper with colored squares? Well, you could
    just randomly cover the page with stamps until it’s filled. The result would be
    a mess, and it would take a while to complete, but it would fill the page. Or
    you could start stamping down in a column and then move back to the top and start
    stamping down the page in the next column, as shown in [Figure 14-1](ch14.xhtml#ch14fig01).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是函数内部的两个循环。为了理解它们的作用，想象你有一个小的橡皮图章、一个印泥垫和一张大纸。你如何用这个图章将纸张填满彩色的小方块呢？你可以随机地把图章盖在纸上，直到纸被填满。结果会很乱，而且需要花费一段时间，但最终会填满页面。或者你可以从一列开始盖印，然后回到顶部，开始在下一列上盖印，正如[图14-1](ch14.xhtml#ch14fig01)所示。
- en: '![Image](Images/14fig01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig01.jpg)'
- en: '*Figure 14-1: Stamping down the page*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：在页面上盖印*'
- en: The background image we created in the previous chapter is our stamp. We know
    that the canvas is 500 pixels across and 500 pixels down, and that we created
    a background image of 100 pixels square. This tells us that we need five columns
    across and five rows down to fill the screen with images. We use a for loop ➊
    to calculate the columns across, and another for loop ➋ to calculate rows going
    down.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章创建的背景图像就是我们的“印章”。我们知道画布的宽度是500像素，高度也是500像素，而且我们创建了一个100像素见方的背景图像。这意味着我们需要五列和五行才能填满屏幕上的图像。我们使用一个for循环➊来计算横向的列数，再用另一个for循环➋来计算纵向的行数。
- en: After this, we multiply the first loop variable x by the width of the image
    (x * w) to determine how far across we’re drawing, and then multiply the second
    loop variable y by the height of the image (y * h) to calculate how far down to
    draw. We use the create_image function of the canvas object (self.canvas.create
    _image) to draw the image on the screen using those coordinates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将第一个循环变量x乘以图像的宽度（x * w），以确定绘制的横向位置，然后将第二个循环变量y乘以图像的高度（y * h），以计算绘制的纵向位置。我们使用画布对象（self.canvas.create_image）的create_image函数，根据这些坐标将图像绘制到屏幕上。
- en: Finally, we create the variables sprites, which holds an empty list, and running,
    which contains the True Boolean value. We’ll use these variables later in our
    game code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了sprites变量，它保存一个空列表，和running变量，它包含True布尔值。稍后我们将在游戏代码中使用这些变量。
- en: Creating the mainloop Function
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建mainloop函数
- en: We’ll use the mainloop function in the Game class to animate our game. This
    function looks a lot like the main loop (or animation loop) we created for the
    *Bounce!* game in [Chapter 11](ch11.xhtml#ch11).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Game类中的mainloop函数来动画化我们的游戏。这个函数看起来和我们在[第11章](ch11.xhtml#ch11)中为*Bounce!*游戏创建的主循环（或动画循环）非常相似。
- en: 'Our function is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create a while loop that will run until the game window is closed (while
    True is an infinite loop, which we first saw back on [page 175](ch11.xhtml#para95)).
    Next, we check to see if the running variable is equal to True. If it is, we loop
    through any sprites in the list of sprites (self.sprites), calling the move function
    for each one. (We have yet to create any sprites, so this code won’t do anything
    if we run the program now, but it will be useful later.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个while循环，它会一直运行直到游戏窗口关闭（while True是一个无限循环，我们第一次在[第175页](ch11.xhtml#para95)看到）。接下来，我们检查running变量是否等于True。如果是，我们就遍历sprites列表中的所有精灵（self.sprites），并为每个精灵调用move函数。（我们还没有创建任何精灵，所以如果现在运行程序，这段代码不会有任何效果，但它以后会很有用。）
- en: The last three lines of the function force the tk object to redraw the screen
    and sleep for a fraction of a second, as we did with the *Bounce!* game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后三行强制tk对象重新绘制屏幕，并休眠片刻，就像我们在*Bounce!*游戏中所做的那样。
- en: 'So you can run this code, add the following two lines (note that there’s no
    indentation) and save the file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行这段代码，添加以下两行（注意没有缩进）并保存文件：
- en: '![Image](Images/f0217-01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0217-01.jpg)'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Be sure to add this code to the bottom of your game file. Also, make sure
    that your images and Python file are all in the* stickman *folder you created
    in [Chapter 13](ch13.xhtml#ch13).*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保将这段代码添加到游戏文件的底部。同时，确保你的图像和Python文件都在你在[第13章](ch13.xhtml#ch13)中创建的*stickman*文件夹中。*'
- en: This code creates an object of the Game class and saves it as the g variable.
    We then call the mainloop function on the new object to draw the screen.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个Game类的对象，并将其保存为g变量。然后，我们在这个新对象上调用mainloop函数来绘制屏幕。
- en: Once you’ve saved the program, run it in IDLE with **Run** ▸ **Run Module**.
    A window should appear with the background image filling the canvas, as in [Figure
    14-2](ch14.xhtml#ch14fig02).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 保存程序后，在 IDLE 中通过 **运行** ▸ **运行模块** 来执行它。一个窗口应该会出现，背景图像填充画布，如[图 14-2](ch14.xhtml#ch14fig02)所示。
- en: '![Image](Images/14fig02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig02.jpg)'
- en: '*Figure 14-2: Game background*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：游戏背景*'
- en: With this, we’ve added a nice background for our game and created an animation
    loop that will draw sprites for us (once we’ve created them).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们为我们的游戏添加了一个漂亮的背景，并创建了一个动画循环，用于绘制精灵（在我们创建精灵后）。
- en: Creating the Coords Class
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Coords 类
- en: Now we’ll create the class that we’ll use to specify the position of sprites
    on our game screen. This class will store the top-left (*x1* and *y1*) and bottom-right
    (*x2* and *y2*) coordinates of any component of our game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个类，用于指定精灵在游戏屏幕上的位置。这个类将存储游戏中任何组件的左上角（*x1* 和 *y1*）和右下角（*x2* 和 *y2*）坐标。
- en: '[Figure 14-3](ch14.xhtml#ch14fig03) shows how you might record the position
    of the stick figure image using these coordinates.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-3](ch14.xhtml#ch14fig03)展示了如何使用这些坐标记录小人图像的位置。'
- en: '![Image](Images/14fig03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig03.jpg)'
- en: '*Figure 14-3: Where the x and y coordinates can be found on the stick figure*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：x 和 y 坐标在小人图像中的位置*'
- en: 'Our new class, Coords, will contain only an __init__ function, to which we
    pass the four parameters (x1, y1, x2, and y2). Put this code at the beginning
    of the *stickmangame.py* file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新类 Coords 将只包含一个 __init__ 函数，我们将四个参数（x1, y1, x2 和 y2）传递给它。将这段代码放在 *stickmangame.py*
    文件的开头：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that each parameter is saved as an object variable of the same name (x1,
    y1, x2, and y2). We’ll be using objects of this class shortly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个参数都作为同名的对象变量（x1, y1, x2 和 y2）保存。我们很快会使用这个类的对象。
- en: Checking for Collisions
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'Once we know how to store the position of our game sprites, we need a way to
    tell if one sprite has collided with another, like when Mr. Stick Man jumps around
    the screen and runs into one of the platforms. To make this problem easier to
    solve, we can break it into two smaller problems: checking if sprites are colliding
    vertically, and checking if sprites are colliding horizontally. We can then combine
    our solutions to see if two sprites are colliding in any direction!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道如何存储游戏精灵的位置，我们就需要一种方法来判断一个精灵是否与另一个精灵发生了碰撞，比如当小人跳动并撞到平台时。为了简化这个问题，我们可以将其分解为两个较小的问题：检查精灵是否在垂直方向发生碰撞，以及检查精灵是否在水平方向发生碰撞。然后，我们可以将这两个解决方案结合起来，查看精灵是否在任何方向上发生碰撞！
- en: Sprites Colliding Horizontally
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平碰撞的精灵
- en: 'First, we’ll create the within_x function to determine if one set of *x* coordinates
    (*x1* and *x2*) has crossed over another set of *x* coordinates (again, *x1* and
    *x2*). Add the following directly below the Coords class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 within_x 函数，来判断一组 *x* 坐标（*x1* 和 *x2*）是否与另一组 *x* 坐标（同样是 *x1* 和 *x2*）相交。直接在
    Coords 类下方添加以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The within_x function takes the parameters co1 and co2, both Coords objects.
    We first check to see if the leftmost position of the first coordinate object
    (co1.x1) is between the leftmost position (co2.x1) and the rightmost position
    (co2.x2) of the second coordinate object ➊. We return True if it is.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: within_x 函数接收两个参数 co1 和 co2，它们都是 Coords 对象。我们首先检查第一个坐标对象（co1.x1）的最左边位置是否位于第二个坐标对象的最左边位置（co2.x1）和最右边位置（co2.x2）之间
    ➊。如果是，返回 True。
- en: '![Image](Images/f0220-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0220-01.jpg)'
- en: Let’s take a look at two lines with overlapping *x* coordinates to understand
    how this works. Each line in [Figure 14-4](ch14.xhtml#ch14fig04) starts at x1
    and finishes at x2.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看两条有重叠的 *x* 坐标的线条，以理解它是如何工作的。[图 14-4](ch14.xhtml#ch14fig04)中的每条线从 x1 开始，到
    x2 结束。
- en: '![Image](Images/14fig04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig04.jpg)'
- en: '*Figure 14-4: Overlapping horizontal (x) coordinates*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：重叠的水平 (x) 坐标*'
- en: The first line in this diagram (co1) starts at pixel position 50 (x1) and finishes
    at 100 (x2). The second line (co2) starts at position 40 and finishes at 150\.
    In this case, because the x1 position of the first line is between the x1 and
    x2 positions of the second line, the if statement in the function would be true
    for these two sets of coordinates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的第一条线（co1）从像素位置 50（x1）开始，到 100（x2）结束。第二条线（co2）从位置 40 开始，到 150 结束。在这种情况下，由于第一条线的
    x1 位置位于第二条线的 x1 和 x2 位置之间，因此该函数中的 if 语句对于这两组坐标是成立的。
- en: 'With the first elif statement ➋, we see whether the rightmost position of the
    first line (co1.x2) is between the leftmost position (co2.x1) and rightmost position
    (co2.x2) of the second. If it is, we return True. The next two elif statements
    do almost the same thing: they check the leftmost and rightmost positions of the
    second line (co2) against the first (co1).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `elif` 语句 ➋ 中，我们检查第一条线的最右位置（`co1.x2`）是否在第二条线的最左位置（`co2.x1`）和最右位置（`co2.x2`）之间。如果是，我们返回
    `True`。接下来的两个 `elif` 语句做的几乎是一样的：它们检查第二条线（`co2`）的最左和最右位置与第一条线（`co1`）的位置是否重叠。
- en: If none of the if statements match, we reach else and return False. This is
    effectively saying, “No, the two coordinate objects do not cross over each other
    horizontally.”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何 `if` 语句匹配，我们会进入 `else` 并返回 `False`。这实际上是在说：“不，这两个坐标对象在水平方向上没有重叠。”
- en: 'To see an example of the function working, look back at [Figure 14-4](ch14.xhtml#ch14fig04).
    The x1 and x2 positions of the first coordinate object are 50 and 100, and the
    x1 and x2 positions of the second coordinate object are 40 and 150\. Here’s what
    happens when we call the within_x function we’ve created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看该函数如何工作的示例，请回顾 [图 14-4](ch14.xhtml#ch14fig04)。第一个坐标对象的 `x1` 和 `x2` 位置分别是
    50 和 100，第二个坐标对象的 `x1` 和 `x2` 位置分别是 40 和 150。以下是我们调用已创建的 `within_x` 函数时发生的情况：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function returns True. This is the first step in determining whether one
    sprite has bumped into another. For example, when we create a class for Mr. Stick
    Man and for the platforms, we’ll be able to tell if their *x* coordinates have
    crossed one another.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回 `True`。这是确定一个精灵是否与另一个精灵发生碰撞的第一步。例如，当我们为小人和平台创建类时，我们就能判断它们的 *x* 坐标是否互相交叉。
- en: 'It’s not best practice to have lots of if or elif statements that return the
    same value. To solve this problem, we can shorten the within_x function by surrounding
    each of its conditions with parentheses, separated by the or keyword. For a slightly
    neater function with fewer lines of code, you can change the function so it looks
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数中有很多返回相同值的 `if` 或 `elif` 语句并不是最佳实践。为了解决这个问题，我们可以通过将每个条件用括号括起来，并用 `or` 关键字将它们连接，来简化
    `within_x` 函数。为了使函数更简洁、代码行数更少，可以将其改为如下形式：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To extend the if statement across multiple lines so that we don’t end up with
    one really long line containing all the conditions, we use a backslash (\), as
    shown above.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `if` 语句扩展到多行，以避免出现包含所有条件的长行，我们使用反斜杠（`\`），如上所示。
- en: Sprites Colliding Vertically
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精灵垂直碰撞
- en: We also need to know if sprites collide vertically. The within_y function is
    very similar to the within_x function. To create it, we check whether the *y1*
    position of the first coordinate has crossed over the *y1* and *y2* positions
    of the second, and then vice versa.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道精灵是否发生了垂直碰撞。`within_y` 函数与 `within_x` 函数非常相似。为了创建它，我们检查第一个坐标的 *y1* 位置是否与第二个坐标的
    *y1* 和 *y2* 位置发生重叠，然后反过来进行检查。
- en: 'Add the following function below the within_x function. This time, we’ll use
    the shorter version of the code (rather than lots of if statements):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `within_x` 函数下面添加以下函数。这次我们将使用代码的简短版本（而不是大量的 `if` 语句）：
- en: '![Image](Images/f0222-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0222-01.jpg)'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our within_x and within_y functions look quite similar because, in the end,
    they are doing similar things.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `within_x` 和 `within_y` 函数看起来非常相似，因为最终它们执行的操作是类似的。
- en: 'Putting It All Together: Our Final Collision-Detection Code'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起：我们的最终碰撞检测代码
- en: Once we’ve determined whether one set of *x* coordinates has crossed over another,
    and done the same for *y* coordinates, we can write functions to see whether a
    sprite has hit another sprite and on which side. We’ll do this with the collided_left,
    collided_right, collided_top, and collided_bottom functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了一个 *x* 坐标是否与另一个 *x* 坐标发生重叠，并且对 *y* 坐标做了同样的判断，我们就可以编写函数来判断一个精灵是否撞上了另一个精灵以及撞击在哪一侧。我们将通过
    `collided_left`、`collided_right`、`collided_top` 和 `collided_bottom` 函数来实现这一点。
- en: The collided_left Function
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`collided_left` 函数'
- en: 'Add the following code for the collided_left function below the two within
    functions we just created:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的两个 `within` 函数下面，添加以下 `collided_left` 函数的代码：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function tells us whether the left-hand side (the x1 value) of a first
    coordinate object has hit another coordinate object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数告诉我们第一个坐标对象的左侧（`x1` 值）是否与另一个坐标对象发生碰撞。
- en: 'The function takes two parameters: co1 (the first coordinate object) and co2
    (the second coordinate object). We check whether the two coordinate objects have
    crossed over vertically, using the within_y function. After all, there’s no point
    in checking whether Mr. Stick Man has hit a platform if he is floating way above
    it (like [Figure 14-5](ch14.xhtml#ch14fig05)).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个参数：co1（第一个坐标对象）和co2（第二个坐标对象）。我们使用`within_y`函数检查这两个坐标对象是否在垂直方向上发生了交叉。毕竟，如果小人漂浮在平台上方，检查他是否与平台碰撞就没有意义了（如[图14-5](ch14.xhtml#ch14fig05)所示）。
- en: '![Image](Images/14fig05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig05.jpg)'
- en: '*Figure 14-5: Mr. Stick Man above the platform*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：小人位于平台上方*'
- en: Then, we see if the value of the leftmost position of the first coordinate object
    (co1.x1) has hit the x2 position of the second coordinate object (co2.x2). If
    so, it should be less than or equal to the x2 position. We also check to make
    sure that it hasn’t gone past the x1 position. If it has hit the side, we return
    True. If none of the if statements are true, we return False.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查第一个坐标对象的最左侧位置（co1.x1）是否已经碰到第二个坐标对象的x2位置（co2.x2）。如果是这样，它应该小于或等于x2位置。我们还检查它是否没有超过x1位置。如果它碰到了侧面，我们返回True。如果没有任何if语句为真，我们返回False。
- en: '![Image](Images/f0224-01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0224-01.jpg)'
- en: The collided_right Function
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: collided_right函数
- en: 'The collided_right function looks a lot like collided_left:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: collided_right函数看起来与collided_left非常相似：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with collided_left, we check to see if the *y* coordinates have crossed over
    each other, using the within_y function. We then check to see if the x2 value
    of the first coordinate object is between the x1 and x2 positions of the second
    coordinate object, and return True if it is. Otherwise, we return False.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与collided_left类似，我们检查*y*坐标是否发生交叉，使用`within_y`函数。然后，我们检查第一个坐标对象的x2值是否介于第二个坐标对象的x1和x2位置之间，如果是，返回True。否则，返回False。
- en: The collided_top Function
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: collided_top函数
- en: 'The collided_top function is very similar to the two functions we just added:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: collided_top函数与我们刚刚添加的两个函数非常相似：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, we check to see if the coordinates have crossed over horizontally,
    using the within_x function. Next, we see if the topmost position of the first
    coordinate (co1.y1) has crossed over the y2 position of the second coordinate,
    but not its y1 position. If so, we return True (the top of the first coordinate
    has hit the second coordinate).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们检查坐标是否在水平方向上发生了交叉，使用`within_x`函数。接下来，我们检查第一个坐标的最顶部位置（co1.y1）是否已经超过第二个坐标的y2位置，但没有超过其y1位置。如果是这样，我们返回True（第一个坐标的顶部已经碰到第二个坐标）。
- en: The collided_bottom Function
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: collided_bottom函数
- en: 'Our last function, collided_bottom, is just a bit different:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个函数，collided_bottom，稍微有点不同：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function takes an additional parameter, y, a value that we add to the y
    position of the first coordinate. Our if statement checks if the coordinates have
    crossed over horizontally (as we did with collided_top). Next, we add the value
    of the y parameter to the first coordinate’s y2 position, and store the result
    in the y_calc variable. If the newly calculated value is between the y1 and y2
    values of the second coordinate ➊, we return True because the bottom of coordinate
    co1 has hit the top of coordinate co2. However, if none of the if statements are
    true, we return False.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个额外的参数y，这是我们加到第一个坐标y位置的值。我们的if语句检查坐标是否在水平方向上发生了交叉（就像在collided_top函数中一样）。接下来，我们将y参数的值加到第一个坐标的y2位置，并将结果存储在y_calc变量中。如果新计算的值介于第二个坐标的y1和y2值之间
    ➊，我们返回True，因为坐标co1的底部已经碰到坐标co2的顶部。然而，如果没有任何if语句为真，我们返回False。
- en: We need the additional y parameter because Mr. Stick Man could fall off a platform.
    Unlike the other collided functions, we need to be able to test if he *would*
    collide at the bottom, rather than whether he already has. If he walks off a platform
    and keeps floating in midair, our game won’t be very realistic; so as he walks,
    we check to see if he has collided with something on the left or right. When we
    check below him, we see if he would collide with the platform; if not, he needs
    to go crashing down!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要额外的y参数，因为小人可能会从平台上掉下来。与其他碰撞函数不同，我们需要能够测试他*是否*会在底部发生碰撞，而不是是否已经碰撞。如果他从平台上走下来并继续漂浮在空中，我们的游戏就不太现实；因此，当他行走时，我们会检查他是否与左侧或右侧的物体发生碰撞。当我们检查他下面时，我们查看他是否会与平台发生碰撞；如果不会，他就需要摔下去了！
- en: Creating the Sprite Class
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Sprite类
- en: 'The parent class for our game items, Sprite, will provide two functions: move
    to move the sprite, and coords to return the sprite’s current position on the
    screen. We add the code for the Sprite class below the collided_bottom function,
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏项目的父类 Sprite 提供了两个函数：move 用于移动精灵，coords 用于返回精灵当前在屏幕上的位置。我们将 Sprite 类的代码添加到
    collided_bottom 函数下面，如下所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Sprite class’s __init__ function takes a single parameter, game, which will
    be the game object. We need it so that any sprite we create will be able to access
    the list of other sprites in the game. We store the game parameter as an object
    variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite 类的 __init__ 函数接受一个参数 game，它将是游戏对象。我们需要它，以便我们创建的任何精灵都能访问游戏中其他精灵的列表。我们将
    game 参数存储为对象变量。
- en: Then, we store the object variable endgame, which we’ll use to indicate the
    end of the game. (At the moment, it’s set to False.) The final object variable,
    coordinates, is set to nothing (None).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将对象变量 endgame 存储起来，用于表示游戏结束。（目前它被设置为 False。）最后一个对象变量 coordinates 被设置为 None（无）。
- en: The move function does nothing in this parent class, so we use the pass keyword
    in the body of this function. The coords function simply returns the object variable
    coordinates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: move 函数在这个父类中什么都不做，因此我们在该函数的主体中使用 pass 关键字。coords 函数仅仅返回对象变量 coordinates。
- en: So our Sprite class has a move function that does nothing and a coords function
    that returns no coordinates. That doesn’t sound very useful, does it? However,
    any classes that have Sprite as their parent will always have the move and coords
    functions. So, in the main loop of the game, when we loop through a list of sprites,
    calling the move function won’t cause any errors because each sprite has that
    function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的 Sprite 类有一个什么都不做的 move 函数和一个不返回坐标的 coords 函数。这听起来并不是很有用，对吧？然而，任何以 Sprite
    作为父类的类都会拥有 move 和 coords 函数。所以，在游戏的主循环中，当我们遍历精灵列表时，调用 move 函数不会导致任何错误，因为每个精灵都有这个函数。
- en: '![Image](Images/f0226-01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0226-01.jpg)'
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Classes with functions that don’t do very much are quite common in programming.
    In a way, they’re an agreement that ensures all the children of a class provide
    the same sort of functionality, even if in some cases the functions in the child
    classes do nothing.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*在编程中，具有功能不多的函数的类是相当常见的。从某种意义上讲，它们是一种约定，确保类的所有子类提供相同类型的功能，即使在某些情况下，子类中的函数什么都不做。*'
- en: Adding the Platforms
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加平台
- en: 'Now we’ll add the platforms. Our class for platform objects, PlatformSprite,
    will be a child class of Sprite. The __init__ function for this class will take
    a game parameter (as the Sprite parent class does), as well as an image, x and
    y positions, and the image width and height. Here’s the code for the PlatformSprite
    class, which goes directly below the Sprite class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加平台。我们的平台对象类 PlatformSprite 将是 Sprite 的子类。这个类的 __init__ 函数将接受一个 game 参数（就像
    Sprite 父类一样），还需要图像、x 和 y 位置以及图像的宽度和高度。下面是 PlatformSprite 类的代码，直接位于 Sprite 类下面：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we define the PlatformSprite class, we give it a single parameter: the
    name of the parent class (Sprite). The __init__ function has seven parameters:
    self, game, photo_image, x, y, width, and height.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义 PlatformSprite 类时，给它一个参数：父类的名称（Sprite）。__init__ 函数有七个参数：self、game、photo_image、x、y、width
    和 height。
- en: 'We call the __init__ function of the parent class, Sprite, using self and game
    as the parameter values, because other than the self parameter, the Sprite class’s
    __init__ function takes only one parameter: game.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 self 和 game 作为参数值来调用父类 Sprite 的 __init__ 函数，因为除了 self 参数外，Sprite 类的 __init__
    函数只接受一个参数：game。
- en: At this point, if we were to create a PlatformSprite object, it would have all
    the object variables from its parent class (game, endgame, and coordinates), simply
    because we’ve called the __init__ function in Sprite.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果我们创建一个 PlatformSprite 对象，它将拥有父类（game、endgame 和 coordinates）中的所有对象变量，仅仅因为我们调用了
    Sprite 中的 __init__ 函数。
- en: '![Image](Images/f0227-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0227-01.jpg)'
- en: Next, we save the photo_image parameter as an object variable, and we use the
    canvas variable of the game object to draw the image onscreen with create_image.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 photo_image 参数保存为对象变量，并使用游戏对象的 canvas 变量通过 create_image 在屏幕上绘制图像。
- en: Finally, we create a Coords object with the x and y parameters as the first
    two arguments. We then add the width and height parameters to these parameters
    for the second two arguments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 Coords 对象，将 x 和 y 参数作为前两个参数。然后，我们将宽度和高度参数添加到这些参数中，作为后两个参数。
- en: Even though the coordinates variable is set to None in the Sprite parent class,
    we’ve changed it in our PlatformSprite child class to an actual Coords object,
    containing the live location of the platform image on the screen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Sprite 父类中坐标变量被设置为 None，但我们在 PlatformSprite 子类中将其更改为实际的 Coords 对象，包含平台图像在屏幕上的当前位置。
- en: Adding a Platform Object
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个平台对象
- en: 'Let’s add a platform to the game to see how it looks. Change the last two lines
    of the game file (*stickmangame.py*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给游戏添加一个平台，看看它的样子。修改游戏文件的最后两行（*stickmangame.py*）：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create an object of the PlatformSprite class, passing it the variable for
    our game (g), along with a PhotoImage object (which uses the first of our platform
    images, *platform1.gif*) ➊. We also pass it the position where we want to draw
    the platform (0 pixels across and 480 pixels down, near the bottom of the canvas),
    along with the height and width of our image (100 pixels across and 10 pixels
    high). We add this sprite to the list of sprites in our game object ➋.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 PlatformSprite 类的对象，将我们的游戏变量（g）和一个 PhotoImage 对象（它使用我们的第一个平台图像，*platform1.gif*）
    ➊ 传递给它。我们还传递了绘制平台的位置（横向 0 像素，纵向 480 像素，接近画布底部），以及图像的高度和宽度（宽 100 像素，高 10 像素）。我们将这个精灵添加到游戏对象中的精灵列表
    ➋。
- en: If you run the game now, you should see a platform at the bottom-left side of
    the screen, like [Figure 14-6](ch14.xhtml#ch14fig06).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你应该能看到屏幕左下角有一个平台，像是[图 14-6](ch14.xhtml#ch14fig06)。
- en: '![Image](Images/14fig06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig06.jpg)'
- en: '*Figure 14-6: Displaying a platform*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：显示一个平台*'
- en: Adding a Bunch of Platforms
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加多个平台
- en: 'Let’s add a whole bunch of platforms. Each platform will have different *x*
    and *y* positions, so they’ll be scattered around the screen. Use the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加许多平台。每个平台将具有不同的 *x* 和 *y* 坐标，因此它们会分散在屏幕上。使用以下代码：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first create a ton of PlatformSprite objects, saving them as variables platform1,
    platform2, platform3, and so on, up to platform10. We then add each platform to
    the sprites variable, which we created in our Game class. If you run the game
    now, it should look like [Figure 14-7](ch14.xhtml#ch14fig07).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了大量的 PlatformSprite 对象，将它们保存为变量 platform1、platform2、platform3 等，直到 platform10。然后我们将每个平台添加到我们在
    Game 类中创建的精灵变量中。如果你现在运行游戏，它应该看起来像是[图 14-7](ch14.xhtml#ch14fig07)。
- en: '![Image](Images/14fig07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig07.jpg)'
- en: '*Figure 14-7: Displaying all the platforms*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：显示所有平台*'
- en: We’ve created the basics of our game! Now we’re ready to add our main character,
    Mr. Stick Man.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了游戏的基础！现在我们准备添加我们的主角——火柴人先生。
- en: What You Learned
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, you created the Game class and drew the background image onto
    the screen. You learned how to determine whether a horizontal or vertical position
    is within the bounds of two other horizontal or vertical positions by creating
    the within_x and within_y functions. You then used these functions to create new
    functions that determine whether one coordinate object had collided with another.
    We’ll use these functions in the next chapters when we animate Mr. Stick Man and
    need to detect whether he has collided with a platform as he moves around the
    canvas.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你创建了 Game 类并将背景图像绘制到屏幕上。你学会了如何通过创建 within_x 和 within_y 函数来判断一个水平或垂直位置是否在另外两个水平或垂直位置的范围内。接着，你利用这些函数创建了新函数来判断一个坐标对象是否与另一个坐标对象发生碰撞。我们将在接下来的章节中使用这些函数，当我们为“火柴人先生”添加动画并需要检测他在画布上移动时是否与平台发生碰撞。
- en: We also created a parent class Sprite and its first child class, PlatformSprite,
    which we used to draw the platforms onto the canvas.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个父类 Sprite 以及它的第一个子类 PlatformSprite，用来将平台绘制到画布上。
- en: Programming Puzzles
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程难题
- en: The following coding puzzles are some ways to experiment with the game’s background
    image. Check your answers at *[http://python-for-kids.com](http://python-for-kids.com)*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编程难题是一些可以用来尝试游戏背景图像的方式。在 *[http://python-for-kids.com](http://python-for-kids.com)*
    检查你的答案。
- en: '#1: Checkerboard'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#1：棋盘格'
- en: Try changing the Game class so that the background image is drawn like a checkerboard,
    as in [Figure 14-8](ch14.xhtml#ch14fig08).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改 Game 类，使背景图像像棋盘格一样绘制，如[图 14-8](ch14.xhtml#ch14fig08)所示。
- en: '![Image](Images/14fig08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig08.jpg)'
- en: '*Figure 14-8: Background as a checkerboard*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：背景为棋盘格*'
- en: '#2: Two-Image Checkerboard'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#2：双图像棋盘格'
- en: Once you’ve figured out how to create a checkerboard effect, try using two alternating
    images. Come up with another wallpaper image (using your graphics program), and
    then change the Game class so it displays a checkerboard with two alternating
    images instead of one image and the blank background.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你弄明白如何创建棋盘格效果，试着使用两张交替的图片。创建另一张壁纸图像（使用你的图形程序），然后修改 Game 类，让它显示一个由两张交替图像组成的棋盘，而不是一张图像和空白背景。
- en: '#3: Bookshelf and Lamp'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#3: 书架与灯'
- en: You can create different wallpaper images to make the game’s background more
    interesting. Create a copy of the background image; then draw a simple bookshelf,
    a table with a lamp, or a window. Dot these images around the screen by changing
    the Game class so that it displays a few different wallpaper images.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建不同的壁纸图像，使游戏背景更有趣。创建背景图像的副本；然后画一个简单的书架、一张带灯的桌子或一扇窗户。通过修改 Game 类，让它显示一些不同的壁纸图像，将这些图像随机分布在屏幕上。
- en: '#4: Random Background'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#4: 随机背景'
- en: As an alternative to the two-image checkerboard, try creating five different
    background images. You can either draw them as a repeating pattern of background
    images (1, 2, 3, 4, 5, 1, 2, 3, 4, 5, and so on), or you can draw them randomly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为两张图像棋盘格的替代方案，尝试创建五张不同的背景图像。你可以将它们画成一个重复的背景图案（1, 2, 3, 4, 5, 1, 2, 3, 4, 5，依此类推），或者你可以将它们随机绘制。
- en: 'Hint: If you import the random module and put your images in a list, try using
    random.choice() to pick one randomly.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你导入了 random 模块并将图片放在一个列表中，可以尝试使用 random.choice() 随机选择一张图片。
