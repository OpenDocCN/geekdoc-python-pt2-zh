- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Hash Tables
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter introduces *hash tables*, dynamic data structures hyper-optimized
    for insertions and lookups. Hash tables use mathematical functions to point us
    toward the data’s location. They are particularly useful in pure storage cases
    where the goal is to find and retrieve information quickly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*哈希表*，这是一种针对插入和查找进行了高度优化的动态数据结构。哈希表使用数学函数指引我们到数据的位置。在纯存储的情况下，它们特别有用，目标是快速找到和检索信息。
- en: 'This is the type of tradeoff we might want to make for our coffee pantry. Forget
    trying to sort coffees by expiration date or tastiness—we are true coffee aficionados
    who effortlessly remember the smallest details of every bean in our pantry. For
    any given attribute (or combination of attributes), we can instantly remember
    the coffee’s name. By the time we walk to the coffee pantry, we’ve already decided
    which coffee we want. Storing our coffee selection in sorted order along these
    other dimensions will just slow us down. What we need is efficient retrieval:
    given just the name of the coffee we want to drink, we want to find those beans
    with minimal effort. Hash tables enable exactly this type of rapid retrieval by
    name.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在咖啡储藏室中可能需要做出的权衡。忘记试图按过期日期或口感排序咖啡吧——我们是真正的咖啡爱好者，能够轻松记住我们储藏室中每一颗咖啡豆的最小细节。对于任何给定的属性（或属性组合），我们都能立即记住咖啡的名称。当我们走到咖啡储藏室时，我们已经决定了要喝哪种咖啡。将咖啡按这些其他维度排序存放只会拖慢我们的速度。我们需要的是高效的检索：只要给出我们想喝的咖啡的名字，我们就希望能够最小化努力地找到这些咖啡豆。哈希表正是通过名称实现这种快速检索的。
- en: Arrays provide a compact structure for storing individual pieces of data and
    a mechanism for efficient retrieval—but only when we know the item’s index. With
    an index, we can look up any element in constant time. As we saw in Chapter 2,
    without an index, the process for looking up items in an array becomes more complicated.
    If we only have the item’s value, then we need to search through the array to
    find its correct location. We can find items efficiently with binary search only
    at the cost of keeping the array in sorted order, which makes for inefficient
    insertions and deletions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数组提供了一种紧凑的结构，用于存储单个数据项，并提供了一种高效的检索机制——但前提是我们知道该项的索引。有了索引，我们可以在常数时间内查找任何元素。正如我们在第二章中看到的，如果没有索引，查找数组中的项目就变得更加复杂。如果我们只有项的值，那么我们需要遍历数组来找到它的正确位置。只有通过二分查找，我们才能高效地查找项目，但前提是保持数组的排序顺序，这会导致插入和删除操作效率低下。
- en: After the past chapters of exploring data structures and algorithms to efficiently
    search for target values, imagine we could build a magical function that mapped
    our target value directly to its index (with a few caveats, of course). This is
    the core idea behind hash tables. Hash tables use mathematical functions to compute
    a value’s index in our data structure, allowing us to map directly from value
    to an array bin. The downside is that no mapping is perfect. We will see how different
    values can map to the same location, causing collisions. We will then examine
    two approaches to resolving collisions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了数据结构和算法，以高效地搜索目标值。想象一下，如果我们能构建一个神奇的函数，将目标值直接映射到它的索引（当然有一些前提条件）。这就是哈希表的核心思想。哈希表使用数学函数来计算数据结构中值的索引，从而使我们能够直接从值映射到数组的桶中。缺点是没有任何映射是完美的。我们将看到不同的值如何映射到同一个位置，导致碰撞。然后我们将探讨解决碰撞的两种方法。
- en: As with all data structures, hash tables are not a perfect solution for every
    problem—we’ll examine both the benefits and the tradeoffs, including the use of
    memory and worst-case performance. In doing so, we’ll examine a new way to organize
    data by using mathematical mappings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有数据结构一样，哈希表并不是解决所有问题的完美方案——我们将探讨它的优缺点，包括内存使用和最坏情况性能。在这个过程中，我们将研究一种通过使用数学映射来组织数据的新方式。
- en: Storage and Search with Keys
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键的存储和搜索
- en: Before we delve into the mechanics of hash tables, let’s consider an idealized
    indexing scheme for efficient retrieval of integer values—maintaining an individual
    array bin for each *possible* value and indexing that bin with the value itself.
    This structure is shown in [Figure 10-1](#figure10-1). To insert the value 9,
    we simply place it in the bin at index 9\. Under this arrangement, we can insert
    or retrieve items in constant time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解哈希表的工作原理之前，让我们考虑一个理想化的索引方案，以高效地检索整数值——为每个*可能的*值维护一个独立的数组槽，并用该值本身来索引该槽。这个结构如[图10-1](#figure10-1)所示。为了插入值9，我们只需将其放入索引为9的槽中。在这种安排下，我们可以以常数时间插入或检索项目。
- en: '![An array with ten bins numbered 0 to 9\. Bins 1, 5, and 7 have arrows to
    data outside the array. The remaining bins have slashes to indicate they are empty.](image_fi/502604c10/f10001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含十个槽的数组，编号从0到9。槽1、5和7指向数组外的数据。其余槽有斜线表示它们是空的。](image_fi/502604c10/f10001.png)'
- en: 'Figure 10-1: A large array with a bin for every potential entry'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：一个为每个潜在条目分配槽的大型数组
- en: The obvious downside of our idealized data structure is the absurd cost of maintaining
    an array of every possible key. Consider the case of storing all possible 16-digit
    credit card numbers. We’d need several quadrillion bins, 10^(16) to be exact.
    That is a lot of memory. Worse, it’s unlikely that we would even use this many
    bins. If we are writing a program to track the corporate credit cards for a 1,000-person
    company, we need only a tiny fraction of the available bins—one bin out of every
    10^(13) we’ve allocated. The rest are wasted. They sit empty, hoping that someday
    they’ll have data to store. Similarly, we wouldn’t want to reserve a spot in the
    library for every possible book, a room in a hotel for every possible patron,
    or a spot in our coffee pantry for every known coffee. That’d be absurd (except
    maybe for the coffee).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理想化的数据结构的明显缺点是维护每个可能键的数组的荒谬成本。考虑存储所有可能的16位数字信用卡号的情况。我们需要几个千万亿个槽，准确地说是10^(16)个。这是一个庞大的内存需求。更糟糕的是，我们甚至不太可能使用这么多槽。如果我们在编写一个程序来跟踪一个1000人公司的企业信用卡，我们只需要一个很小的部分槽——我们分配的10^(13)个槽中的一个。其余的都是浪费。它们空着，希望某天能存储数据。同样，我们也不希望为每一本可能的书籍保留一个图书馆的位置，为每位可能的顾客保留一个酒店房间，或者为每种已知的咖啡在咖啡储藏室中预留一个位置。这太荒谬了（也许咖啡例外）。
- en: 'But, as a thought experiment, let’s consider how this idealized data structure
    could work for other types of data. We immediately run into the question of what
    value to use for more complex data types, such as strings or even composite data
    types. Suppose we’re looking to create a simple database of coffee records. Chapter
    3 showed how to use an array of pointers to store such dynamically sized data,
    as in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为一种思维实验，让我们考虑这个理想化的数据结构如何适用于其他类型的数据。我们立刻遇到的问题是，如何为更复杂的数据类型（如字符串或甚至复合数据类型）选择值。假设我们要创建一个简单的咖啡记录数据库。第3章展示了如何使用指针数组来存储此类动态大小的数据，如以下代码所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We could still place all our items in a single massive array with one bin for
    every *possible* entry. In this case, the bin contains not just a single value
    but a pointer to a more complex data structure, as in the array of pointers in
    [Figure 10-2](#figure10-2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以将所有项目放入一个单一的大型数组中，为每个*可能的*条目设置一个槽。在这种情况下，槽中不仅包含单个值，还包含指向更复杂数据结构的指针，如[图10-2](#figure10-2)中的指针数组。
- en: '![An array for ten bins, numbered 0 through 9\. Each bin contains an arrow
    pointing to data outside the array.](image_fi/502604c10/f10002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含十个槽的数组，编号从0到9。每个槽包含一个指向数组外部数据的箭头。](image_fi/502604c10/f10002.png)'
- en: 'Figure 10-2: An array of pointers'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：一个指针数组
- en: 'However, this still leaves the question of how to do the actual lookup. If
    we want to find the rating we gave for “Jeremy’s Gourmet High-Caffeine Experience:
    Medium Roast,” one of the coffees introduced in Chapter 6, we cannot use the entire
    composite data structure as the value. We do not have all this information on
    hand. Even if we did have the full information on hand, it is not clear how we
    would use a composite data structure or even a string as an index.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这仍然留下了如何进行实际查找的问题。如果我们想要查找我们为“Jeremy’s Gourmet High-Caffeine Experience:
    Medium Roast”——第六章介绍的一款咖啡——给出的评分，我们无法将整个复合数据结构作为值。我们并没有手头上所有这些信息。即使我们手头有完整的信息，也不清楚如何使用复合数据结构甚至是字符串作为索引。'
- en: Computer programs often use keys to identify records. A *key* is a single value
    stored with or derived from the data itself that can be used to identify a record.
    In the case of an RSVP list, the key might be the string containing the invitee’s
    name; in the case of our coffee records, the key could be the name or barcode
    of the coffee. In many data structures, from sorted arrays to tries, we use the
    key to organize the data. For the numerical examples earlier in this book, the
    key is just the value itself. Each search of a sorted array or binary search tree
    for a specific numeric value corresponded to retrieving a record by looking for
    a matching numeric key. Similarly, the tries introduced in Chapter 6 use a string
    for the key.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序通常使用键来标识记录。*键* 是与数据本身一起存储或从数据中派生出来的单一值，可以用来标识一条记录。在 RSVP 列表中，键可能是包含受邀者姓名的字符串；在我们的咖啡记录中，键可以是咖啡的名称或条形码。在许多数据结构中，从排序数组到字典树，我们使用键来组织数据。对于本书早期的数字示例，键就是数值本身。对排序数组或二叉查找树进行的每一次搜索，都是通过查找匹配的数字键来获取记录。类似地，第六章介绍的字典树使用字符串作为键。
- en: 'This does not solve the indexing problem though. Unless we have an integer
    key, we still cannot index the array bin. Arrays do not have a bin with index
    “Jeremy’s Gourmet High-Caffeine Experience: Medium Roast.” We can search over
    our data structure, looking for a record with a matching key. Linear scan and
    binary search both work this way, using a target value as the key. However, we’ve
    lost the magic of our idealized data structure. We are back to searching for a
    matching key.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这并没有解决索引问题。除非我们有整数键，否则我们仍然无法索引数组箱子。数组中并没有一个箱子，其索引为“Jeremy’s Gourmet High-Caffeine
    Experience: Medium Roast”。我们可以在数据结构中进行搜索，寻找一个具有匹配键的记录。线性扫描和二分查找都可以这样工作，使用目标值作为键。然而，我们失去了理想化数据结构的魔力。我们又回到了搜索匹配键的过程。'
- en: 'In some cases, we might be able to find a natural numeric key for our records.
    In the coffee example, we could list every coffee we’ve ever tasted in order of
    when we first tasted it and use the corresponding date as a key. If “Jeremy’s
    Gourmet High-Caffeine Experience: Medium Roast” was first sampled on January 1,
    2020 (and we magically remember that), we could retrieve the record with a binary
    search. Alternatively, we could use the coffee’s barcode or its page number in
    the *Compendium of World Coffees, Brands, and Manufacturers*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '在某些情况下，我们可能能够找到一个自然的数字键来表示我们的记录。在咖啡的例子中，我们可以按照第一次品尝的时间顺序列出我们品尝过的每一款咖啡，并将相应的日期作为键。如果“Jeremy’s
    Gourmet High-Caffeine Experience: Medium Roast”是在 2020 年 1 月 1 日首次品尝的（假设我们记得这一点），我们可以通过二分查找来检索该记录。或者，我们也可以使用咖啡的条形码或它在《世界咖啡、品牌与制造商大全》中的页码。'
- en: More generally, we want a function that generates an index from our key. In
    the next section, we introduce hash functions, which solve exactly this problem.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们希望有一个函数能够根据我们的键生成一个索引。在接下来的章节中，我们将介绍哈希函数，它正是解决这个问题的。
- en: Hash Tables
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希表
- en: Hash tables use mathematical mappings to compress the key space. They squish
    large key spaces into a small domain by using a *hash function* to map the raw
    key into the location in the table (also called the *hash value*). We denote the
    hash function that maps key *k* into a table with *b* bins as a function *f*(*k*)
    with range [*0*, *b* − 1]*.*This mapping solves both problems from the previous
    section. We no longer require an infinite number of bins. We just need *b* of
    them. As we will see, functions can also map non-integers onto a numerical range,
    solving the problem of non-integer keys.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表使用数学映射来压缩键空间。它们通过使用*哈希函数*将原始键映射到表中的位置（也叫做*哈希值*），将大的键空间压缩到一个较小的范围内。我们用哈希函数
    *f*(*k*) 表示将键 *k* 映射到包含 *b* 个箱子的表中，范围为[*0*, *b* − 1]*。这个映射解决了前一部分的两个问题。我们不再需要无限数量的箱子，只需要
    *b* 个箱子。正如我们将看到的，函数也可以将非整数映射到数字范围，从而解决非整数键的问题。
- en: 'A simple example hash function for integer keys is to use the division method
    to compute the hash value from the numeric key. We divide the key by the number
    of bins and take the remainder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的哈希函数示例是使用除法法则，根据数字键计算哈希值。我们将键除以箱子的数量并取余数：
- en: '*f*(*k*) = *k* % *b*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*k*) = *k* % *b*'
- en: where *%* is the modulo operation. Every possible (integer) key is mapped to
    a single bin within the correct range [*0*, *b* − 1]*.* For example, for a 20-bin
    hash table, this function would produce the mappings shown in [Table 10-1](#table10-1).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *%* 是取模操作。每一个可能的（整数）键都被映射到正确范围[*0*, *b* − 1]*内的单一箱子中。例如，对于一个包含 20 个箱子的哈希表，这个函数会生成如[表
    10-1](#table10-1)所示的映射。
- en: 'Table 10-1: Example Mappings for the Division Method of Hashing with 20 Bins'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1：使用 20 个桶的除法法哈希映射示例
- en: '| ***k*** | ***f*(*k*)** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| ***k*** | ***f*(*k*)** |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 5 | 5 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 |'
- en: '| 20 | 0 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 0 |'
- en: '| 21 | 1 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 1 |'
- en: '| 34 | 14 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 34 | 14 |'
- en: '| 41 | 1 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 41 | 1 |'
- en: 'Consider the problem of mapping the space of all credit card numbers into 100
    bins. The division method compresses the key space from 16 digits to 2 digits
    using the last 2 digits of the card’s number. Of course, this simplistic mapping
    might not produce the best results for some key distributions. If we have many
    credit cards ending in 10, they will all map to the same bin. However, it solves
    one of our core problems: with a single (and efficient) mathematical computation,
    we’ve compressed a large range of keys to a limited number of indices.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将所有信用卡号映射到 100 个桶的问题。除法法将键空间从 16 位数字压缩到 2 位数字，方法是使用卡号的最后两位数字。当然，这种简化的映射对于某些键分布可能并不会产生最佳效果。如果我们有许多以
    10 结尾的信用卡，它们都会映射到同一个桶。然而，这也解决了我们的核心问题之一：通过一次（且高效的）数学运算，我们将一个大范围的键压缩到有限数量的索引中。
- en: 'The skeptical reader might balk at the description above: “We can’t store two
    different items in the same element of the array. You told us so in Chapter 1.
    And hash functions can clearly map two different values to the same bin. Just
    look at [Table 10-1](#table10-1). Both 21 and 41 map to bin 1.” This is the aforementioned
    caveat. Unfortunately, hash functions are not truly magical. As we will see in
    the next section, this complexity is where the rest of the hash table’s structure
    comes in—to handle collisions. For now, we can note that the hash function partitions
    our keys into disjoint sets and we only need to worry about collisions within
    a set.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 怀疑的读者可能会对上述描述产生疑问：“我们不能将两个不同的项目存储在数组的同一个元素中。你在第一章中就告诉过我们这一点。而哈希函数显然可以将两个不同的值映射到同一个桶。看看[表
    10-1](#table10-1)。21 和 41 都映射到了桶 1。”这就是前面提到的警告。遗憾的是，哈希函数并非真正的神奇法宝。正如我们将在下一节看到的那样，这种复杂性正是哈希表其他结构的作用所在——用来处理冲突。目前，我们可以注意到哈希函数将我们的键分成不相交的集合，我们只需要担心集合内部的冲突。
- en: Hash functions are not limited to numbers. We can similarly define a hash function
    that maps a coffee’s name to a bin. This allows us to directly access the coffee
    record for any entry in two steps, as shown in [Figure 10-3](#figure10-3). First,
    we use the coffee’s name to compute its hash value. The key “House Blend” is mapped
    to a value of 6; we will describe a simple method for hashing strings later the
    chapter. Second, we look up the hash value in our table by using the hash value
    as an index into our array. We could even use this scheme to map our extensive
    real-world coffee collection to a fixed number of shelves in our coffee pantry.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数不仅限于数字。我们也可以定义一个哈希函数，将咖啡的名称映射到一个桶。这允许我们通过两步直接访问任何条目的咖啡记录，如[图 10-3](#figure10-3)所示。首先，我们使用咖啡的名称计算其哈希值。键“House
    Blend”映射到值 6；我们将在本章稍后描述一种简单的字符串哈希方法。其次，我们通过使用哈希值作为索引，查找表中的哈希值。我们甚至可以使用这种方案将我们庞大的现实世界咖啡收藏映射到咖啡储藏室的固定数量的架子上。
- en: '![The left side shows a list of coffee names, such as “House Blend” and “Morning
    Shock.” The Middle column holds hash functions  that mapping the string to a numeric
    value. House Blend maps to 6\. Arrows point from the hash functions to the corresponding
    bin in the array in the right column.](image_fi/502604c10/f10003.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![左侧显示了一列咖啡名称，如“House Blend”和“Morning Shock”。中间列包含哈希函数，将字符串映射到数字值。House Blend
    映射到 6。箭头指向右侧列中对应桶的哈希函数。](image_fi/502604c10/f10003.png)'
- en: 'Figure 10-3: Hash functions mapping strings to indices within an array'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：哈希函数将字符串映射到数组中的索引
- en: One real-world example of hash tables is the registration tables we see throughout
    our lives, whether at the first day of summer camp, the morning of a race, or
    the beginning of an academic conference. The items to be stored (registration
    packets) are partitioned into unique bins based on their key (the name). People
    can find their correct bin by applying a hash function that is usually as simple
    as a sign mapping a range of the alphabet to a given line. Names starting with
    A−D go to line 1, names with E−G go to line 2, and so forth.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的一个现实世界例子就是我们生活中经常看到的注册表，无论是在夏令营的第一天，比赛的早晨，还是学术会议的开始。要存储的项目（注册包）根据其键（姓名）分配到唯一的桶中。人们可以通过应用一个哈希函数找到正确的桶，这个哈希函数通常很简单，比如将字母范围映射到某一行。以
    A−D 开头的名字放到第 1 行，E−G 开头的名字放到第 2 行，以此类推。
- en: Collisions
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冲突
- en: 'Even the best hash functions in the world won’t provide perfect one-to-one
    mappings of keys to bins. To do that, we’d need to return to our ginormous array
    and its excessive use of memory. Any mathematical function that maps a large set
    of keys to a much smaller set of values will encounter occasional *collisions*—instances
    where two keys map to the same hash value. Imagine applying this approach to mapping
    license plates to 10 parking spaces by taking the first number on the license
    plate. We don’t need our coworker’s license plate to exactly match our own in
    order to start a fight over a parking space. Imagine you go to register your car,
    with the plate “Binary Search Trees Are #1,” only to find that your coworker has
    already claimed the spot with the plate “100,000 Data Structures and Counting.”
    Both plates may happen to hash to 1, so they would be assigned the same spot.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '即使是世界上最好的哈希函数，也无法提供完美的一一映射，将键映射到桶中。为了做到这一点，我们需要回到那个巨大的数组及其过度使用的内存。任何将大量键映射到较小值集合的数学函数，都可能会遇到偶尔的*冲突*——即两个键映射到相同的哈希值。想象一下，如果我们通过提取车牌上的第一个数字将车牌映射到
    10 个停车位上。我们并不需要同事的车牌与自己的车牌完全匹配，就能因为停车位争执起来。假设你去注册你的车，车牌号是“Binary Search Trees
    Are #1”，结果发现同事已经用车牌“100,000 Data Structures and Counting”占用了那个车位。两者的哈希值可能恰好都为
    1，因此它们会被分配到同一个位置。'
- en: We have lines at a conference’s registration table because of collisions. Consider
    a conference registration that hashes into eight lines based on the first letter
    of your last name. Everyone with a name starting with A−D goes to table 1, everyone
    with a name starting with E−G goes to table 2, and so forth. If we have more than
    a handful of attendees, we’re almost guaranteed to see a collision. If there were
    no collisions, everyone would have their own place to check in. Instead, attendees
    with surnames A−D wait in the same line because their keys (last names) collide.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在会议的注册桌前排队，就是因为有了冲突。考虑一个基于姓氏首字母将人分配到八个注册台的情况。姓氏首字母为 A−D 的人去第 1 台，姓氏首字母为 E−G
    的人去第 2 台，以此类推。如果与会者人数超过几位，我们几乎可以保证会发生冲突。如果没有冲突，每个人都会有自己检查的地方。相反，姓氏为 A−D 的与会者将站在同一队伍里，因为他们的键（姓氏）发生了冲突。
- en: We can alleviate some of the collisions by increasing the size of our hash table
    or by choosing a better hash function. However, as long as our key space is larger
    than the number of bins, it’s not possible to eliminate collisions altogether.
    We need a way to gracefully handle two pieces of data fighting to sit in the same
    place. If this were a kindergarten class, we might be able to employ such strategies
    as “Ann was sitting there first,” or “You need to learn to share.” None of these
    approaches work in data structure context. We can’t ignore new keys or overwrite
    the older data. The point of a data structure is to store all the requisite data.
    In the next two sections, we consider chaining and linear probing, two common
    approaches for handling collisions in a hash table.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增大哈希表的大小或选择更好的哈希函数来缓解一些冲突。然而，只要我们的键空间大于桶的数量，就不可能完全消除冲突。我们需要一种优雅的方式来处理两个数据项争抢同一位置的情况。如果这是一个幼儿园班级，我们可能会采用“安妮先坐在那里”或者“你需要学会分享”之类的策略。但这些方法在数据结构的上下文中并不适用。我们不能忽视新的键或覆盖旧的数据。数据结构的目的就是存储所有必需的数据。在接下来的两个章节中，我们将讨论链式法和线性探测法，这两种常见的处理哈希表冲突的方法。
- en: Chaining
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接法
- en: 'Chaining is an approach for handling collisions within a hash table by employing
    additional structure *within* the bins. Instead of storing a fixed piece of data
    (or a pointer to a single piece of data) in each bin, we can store the pointer
    to the head of a linked list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 链接法是一种通过在桶内使用额外结构来处理哈希表中冲突的方法。我们可以将指向链表头的指针存储在每个桶中，而不是在每个桶中存储固定的数据（或指向单一数据的指针）：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: where
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These lists are like our line of conference attendees. Each person in line is
    a unique individual, but maps to the same registration table.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表就像我们的会议注册队伍。队伍中的每个人都是独一无二的个体，但都对应同一个注册桌。
- en: As shown in [Figure 10-4](#figure10-4), each bin’s list contains all the data
    that mapped to that bin. This allows us to store multiple elements in each bin.
    Each item in our linked list corresponds to one of the elements inserted into
    the bin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 10-4](#figure10-4)所示，每个桶的链表包含所有映射到该桶的数据。这使得我们可以在每个桶中存储多个元素。链表中的每个项目对应一个插入该桶的元素。
- en: '![An array with 5 bins is arranged vertically on the left. Each bin has an
    arrow pointing from it, indicating a list. The arrow from the first bin points
    to the start of a linked list with three nodes.](image_fi/502604c10/f10004.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含 5 个桶的数组垂直排列在左侧。每个桶上方有一根箭头指向一个链表。第一个桶的箭头指向一个包含三个节点的链表的起始位置。](image_fi/502604c10/f10004.png)'
- en: 'Figure 10-4: A hash table using a linked list to store entries within the same
    bin'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：使用链表存储同一桶中的条目的哈希表
- en: 'The code for inserting a new item into a hash table with chaining is relatively
    simple:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 向哈希表插入新项的代码相对简单：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start by computing the hash value for the `key` ❶ and checking the corresponding
    bin. If the bin is empty (the pointer is `null`), we create a new linked list
    node holding the `key` and `value` inserted ❷. Otherwise, we need to scan through
    the bin’s linked list and check each element for a matching key ❸. The `WHILE`
    loop checks that we have neither found the correct key (`current.key != key`)
    nor run off the end of the list (`current.next != null`). If the list already
    contains a matching key, we update the value associated with the key ❹. Otherwise,
    we append the new key and its corresponding value to the end of the list ❺.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算`key`的哈希值❶，并检查相应的桶。如果桶为空（即指针为`null`），则创建一个新的链表节点，保存插入的`key`和`value`❷。否则，我们需要扫描桶的链表，并检查每个元素是否匹配键❸。`WHILE`循环检查是否既没有找到正确的键（`current.key
    != key`），也没有扫描到链表末尾（`current.next != null`）。如果链表已经包含匹配的键，我们更新与该键相关联的值❹。否则，我们将新键和其对应的值附加到链表的末尾❺。
- en: 'Search follows a similar approach. However, the logic is simpler because we
    no longer need to insert new nodes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查找过程采用类似的方法。但是，因为我们不再需要插入新节点，逻辑更加简单：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code for search starts by computing the hash value for the `key` ❶, checking
    the corresponding bin, and returning `null` if the bin is empty ❷. Otherwise,
    it scans over each element of the linked list using a `WHILE` loop ❸ and returns
    the value for the matching key ❹. If we make it to the end of the list without
    finding a matching key, the code returns `null` to indicate that the key is not
    present in the table ❺.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 查找的代码首先计算`key`的哈希值❶，检查相应的桶，如果桶为空则返回`null`❷。否则，它使用`WHILE`循环扫描链表中的每个元素❸，并返回匹配键的值❹。如果我们遍历完链表仍未找到匹配的键，代码返回`null`，表示该键不在表中❺。
- en: 'Finally, when removing an item, we need to find it in the list and, if it is
    present, splice it out. The following code both removes and returns the linked
    list node matching the target key:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在删除项时，我们需要在列表中找到该项，并在找到后将其删除。以下代码既删除项又返回与目标键匹配的链表节点：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code again starts by computing the hash value for the `key`, checking the
    corresponding bin, and returning `null` if it is empty ❶. If the bin is not empty,
    we scan through it using a `WHILE` loop and look for a matching key ❷. In order
    to splice out the correct element, we need to track one additional piece of information:
    the final linked list node before the current node. If we find a match ❸, we need
    to check whether we are removing the first element in the list (`last` is `null`).
    If not, we can modify the `last` node’s `next` ``pointer to skip the node we are
    removing ❹. Otherwise, we need to modify the pointer from the start of the hash
    bin to skip the node ❺. Finally, we return `null` if we do not find a matching
    node.``'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先计算`key`的哈希值，检查相应的桶，如果桶为空则返回`null`❶。如果桶不为空，我们使用`WHILE`循环扫描其中的元素，寻找匹配的键❷。为了正确删除元素，我们需要跟踪一条额外的信息：当前节点之前的最后一个链表节点。如果找到了匹配项❸，我们需要检查是否要删除链表中的第一个元素（即`last`为`null`）。如果不是，我们可以修改`last`节点的`next`指针，跳过正在删除的节点❹。否则，我们需要修改哈希桶中指向链表的指针，跳过该节点❺。最后，如果没有找到匹配的节点，返回`null`。
- en: '[PRE6] HashTableEntry {     Type: key     Type: value } [PRE7] HashTable {     Integer:
    size     Integer: num_keys     Array of HashTableEntry: bins } [PRE8] HashTableInsert(HashTable:
    ht, Type: key, Type: value):   ❶ Integer: index = HashFunction(key, ht.size)   ❷
    Integer: count = 0      HashTableEntry: current = ht.bins[index]   ❸ WHILE current
    != null AND current.key != key AND count != ht.size:         index = index + 1       ❹
    IF index >= ht.size:             index = 0         current = ht.bins[index]         count
    = count + 1    ❺ IF count == ht.size:         return False    ❻ IF current ==
    null:         ht.bins[index] = HashTableEntry(key, value)         ht.num_keys
    = ht.num_keys + 1     ELSE:       ❼ ht.bins[index].value = value     return True
    [PRE9] HashTableLookup(HashTable: ht, Type: key):   ❶ Integer: index = HashFunction(key,
    ht.size)   ❷ Integer: count = 0      HashTableEntry: current = ht.bins[index]   ❸
    WHILE current != null AND current.key != key AND count != ht.size:         index
    = index + 1       ❹ IF index >= ht.size:             index = 0         current
    = ht.bins[index]         count = count + 1      # Return the value if we found
    a match.   ❺ IF current != null AND current.key == key:         return current.value   ❻
    return null [PRE10] StringHash(String: key, Integer: size):     Integer: total
    = 0     FOR EACH character in key:         total = CONST * total + CharacterToNumber(character)     return
    total % size [PRE11]`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6] HashTableEntry {     类型: 键     类型: 值 } [PRE7] HashTable {     整数: 大小     整数:
    键的数量     HashTableEntry 数组: 桶 } [PRE8] HashTableInsert(HashTable: ht, 类型: 键, 类型:
    值):   ❶ 整数: 索引 = HashFunction(键, ht.size)   ❷ 整数: 计数 = 0      HashTableEntry:
    当前 = ht.bins[索引]   ❸ 当 当前 != null 且 当前.key != 键 且 计数 != ht.size:         索引 =
    索引 + 1       ❹ 如果 索引 >= ht.size:             索引 = 0         当前 = ht.bins[索引]         计数
    = 计数 + 1    ❺ 如果 计数 == ht.size:         返回 False    ❻ 如果 当前 == null:         ht.bins[索引]
    = HashTableEntry(键, 值)         ht.num_keys = ht.num_keys + 1     否则:       ❼ ht.bins[索引].value
    = 值     返回 True [PRE9] HashTableLookup(HashTable: ht, 类型: 键):   ❶ 整数: 索引 = HashFunction(键,
    ht.size)   ❷ 整数: 计数 = 0      HashTableEntry: 当前 = ht.bins[索引]   ❸ 当 当前 != null
    且 当前.key != 键 且 计数 != ht.size:         索引 = 索引 + 1       ❹ 如果 索引 >= ht.size:             索引
    = 0         当前 = ht.bins[索引]         计数 = 计数 + 1      # 如果找到匹配项，则返回值。   ❺ 如果 当前
    != null 且 当前.key == 键:         返回 当前.value   ❻ 返回 null [PRE10] StringHash(字符串:
    键, 整数: 大小):     整数: 总计 = 0     对于 键中的每个字符:         总计 = CONST * 总计 + CharacterToNumber(字符)     返回
    总计 % 大小 [PRE11]'
