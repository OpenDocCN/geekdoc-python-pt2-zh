- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: WORKING WITH CONTAINER OBJECTS AND CUSTOMIZING SPACY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器对象和定制 spaCy**工作
- en: '![Image](../Images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../Images/comm1.jpg)'
- en: 'You can divide the main objects composing the spaCy API into two categories:
    containers (such as Tokens and Doc objects) and processing pipeline components
    (such as the part-of-speech tagger and named entity recognizer). This chapter
    explores container objects further. Using container objects and their methods,
    you can access the linguistic annotations that spaCy assigns to each token in
    a text.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将构成 spaCy API 的主要对象分为两类：容器（例如 Tokens 和 Doc 对象）和处理管道组件（例如 词性标注器和命名实体识别器）。本章将进一步探讨容器对象。通过使用容器对象及其方法，你可以访问
    spaCy 为文本中的每个词元分配的语言学注释。
- en: You’ll also learn how to customize the pipeline components to suit your needs
    and use Cython code to speed up time-consuming NLP tasks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何定制管道组件以适应你的需求，并使用 Cython 代码加速耗时的 NLP 任务。
- en: '**spaCy’s Container Objects**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**spaCy 的容器对象**'
- en: 'A *container object* groups multiple elements into a single unit. It can be
    a collection of objects, like tokens or sentences, or a set of annotations related
    to a single object. For example, spaCy’s Token object is a container for a set
    of annotations related to a single token in a text, such as that token’s part
    of speech. Container objects in spaCy mimic the structure of natural language
    texts: a text is composed of sentences, and each sentence contains tokens.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *容器对象* 将多个元素组织成一个单一的单元。它可以是一个对象集合，如词元或句子，或与单个对象相关的一组注释。例如，spaCy 的 Token 对象是一个容器，用于存储与文本中单个词元相关的一组注释，如该词元的词性。spaCy
    中的容器对象模仿了自然语言文本的结构：一篇文本由句子组成，每个句子包含多个词元。
- en: Token, Span, and Doc, the most widely used container objects in spaCy from a
    user’s standpoint, represent a token, a phrase or sentence, and a text, respectively.
    A container can contain other containers—for example, a Doc contains Tokens. In
    this section, we’ll explore working with these container objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Token、Span 和 Doc 是从用户角度来看最常用的 spaCy 容器对象，分别表示一个词元、一个短语或句子以及一段文本。一个容器可以包含其他容器——例如，一个
    Doc 包含多个 Token。在本节中，我们将探讨如何与这些容器对象一起工作。
- en: '***Getting the Index of a Token in a Doc Object***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取 Doc 对象中词元的索引***'
- en: A Doc object contains a collection of the Token objects generated as a result of
    the tokenization performed on a submitted text. These tokens have indices, allowing
    you to access them based on their positions in the text, as shown in [Figure 3-1](../Text/ch03.xhtml#ch03fig01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Doc 对象包含通过对提交的文本进行分词处理而生成的 Token 对象集合。这些词元具有索引，使你可以根据它们在文本中的位置来访问它们，如 [图
    3-1](../Text/ch03.xhtml#ch03fig01) 所示。
- en: '![image](../Images/fig3-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig3-1.jpg)'
- en: '*Figure 3-1: The tokens in a Doc object*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：Doc 对象中的词元*'
- en: 'The tokens are indexed starting with 0, which makes the length of the document
    minus 1 the index of the end position. To shred the Doc instance into tokens,
    you derive the tokens into a Python list by iterating over the Doc from the start
    token to the end token:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些词元的索引从 0 开始，这意味着文档的长度减去 1 即为结束位置的索引。为了将 Doc 实例拆分为词元，你可以通过从起始词元到结束词元的迭代，将词元导出为
    Python 列表：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It’s worth noting that we can create a Doc object using its constructor explicitly,
    as illustrated in the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们可以通过显式地使用构造函数来创建一个 Doc 对象，如下例所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We invoke the Doc’s constructor, passing it the following two parameters: a
    *vocab object* ➊—which is a storage container that provides vocabulary data, such
    as lexical types (adjective, verb, noun, and so on)—and a list of tokens to add
    to the Doc object being created ➋.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 Doc 的构造函数，并传入以下两个参数：一个 *词汇对象* ➊——它是一个存储容器，提供词汇数据，如词性（形容词、动词、名词等）——以及一组词元，用于添加到正在创建的
    Doc 对象中 ➋。
- en: '***Iterating over a Token’s Syntactic Children***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***迭代一个词元的句法子节点***'
- en: 'Suppose we need to find the leftward children of a token in the syntactic dependency
    parse of a sentence. For example, we can apply this operation to a noun to obtain
    its adjectives, if any. We might need to do this if we want to know what adjectives
    are able to modify a given noun. As an example, consider the following sentence:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在句子的句法依赖解析中查找一个词元的左子节点。例如，我们可以对一个名词执行此操作，以获得其形容词（如果有的话）。如果我们想知道哪些形容词可以修饰给定的名词，我们可能需要进行此操作。举个例子，考虑以下句子：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The diagram in [Figure 3-2](../Text/ch03.xhtml#ch03fig02) highlights the syntactic
    dependencies of interest.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](../Text/ch03.xhtml#ch03fig02)中的图示突出了相关的句法依赖关系。'
- en: '![image](../Images/fig3-2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig3-2.jpg)'
- en: '*Figure 3-2: An example of leftward syntactic dependencies*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：左侧句法依赖关系示例*'
- en: 'To obtain the leftward syntactic children of the word “apple” in this sample
    sentence programmatically, we might use the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编程方式地获取单词“apple”在此示例句子中的左侧句法子节点，我们可能会使用以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this script, we simply iterate through the apple’s children, outputting them
    in a list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们简单地遍历apple的子节点，并将它们以列表的形式输出。
- en: 'It’s interesting to note that in this example, the leftward syntactic children
    of the word “apple” represent the entire sequence of the token’s syntactic children.
    In practice, this means that we might replace `Token.lefts` with `Token.children`,
    which finds all of a token’s syntactic children:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这个例子中，单词“apple”的左侧句法子节点代表了该标记所有句法子节点的完整序列。实际上，这意味着我们可以用`Token.children`替换`Token.lefts`，后者会找到标记的所有句法子节点：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result list will remain the same.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果列表将保持不变。
- en: 'We could also use `Token.rights` to get a token’s rightward syntactic children:
    in this example, the word “apple” is a rightward child of the word “want,” as
    shown in [Figure 3-1](../Text/ch03.xhtml#ch03fig01).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Token.rights`来获取标记的右侧句法子节点：在这个例子中，单词“apple”是单词“want”的右侧子节点，如[图3-1](../Text/ch03.xhtml#ch03fig01)所示。
- en: '***The doc.sents Container***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***doc.sents容器***'
- en: Typically, the linguistic annotations assigned to a token make sense only in
    the context of the sentence in which the token occurs. For example, information
    about whether the word is a noun or a verb might apply only to the sentence in
    which this word is located (like the word “count,” discussed in previous chapters).
    In such cases, it would be useful to have the ability to access the tokens in
    the document with sentence-level indices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分配给标记的语言注释只有在标记所在的句子上下文中才有意义。例如，关于单词是否为名词或动词的信息可能只适用于该单词所在的句子（如前面章节讨论的“count”一词）。在这种情况下，能够通过句子级索引访问文档中的标记会非常有用。
- en: 'The Doc object’s `doc.sents` property lets us separate a text into its individual
    sentences, as illustrated in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`doc.sents`属性使我们能够将文本分割成单独的句子，如下例所示：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We iterate over the sentences in the `doc` ➊, creating a separate list of tokens
    for each sentence ➋.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历`doc`中的句子 ➊，为每个句子创建一个单独的标记列表 ➋。
- en: 'At the same time, we can still refer to the tokens in a multi-sentence text
    using the global, or document-level, indices, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们仍然可以使用全局或文档级索引引用多句文本中的标记，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The ability to refer to the Token objects in a document by their sentence-level
    indices can be useful if, for example, we need to check whether the first word
    in the second sentence of the text being processed is a pronoun (say we want to
    figure out the connection between two sentences: the first of which contains a
    noun and the second of which contains a pronoun that refers to the noun):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要检查正在处理的文本中第二个句子的第一个单词是否为代词（比如我们想找出两个句子之间的联系：第一个句子包含名词，第二个句子包含指代该名词的代词），那么通过句子级索引引用文档中的标记对象会非常有用：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we use an enumerator in the `for` loop to distinguish the sentences
    by index. This allows us to filter out sentences that we’re not interested in
    and check only the second sentence.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`for`循环中使用枚举器通过索引区分句子。这样我们可以筛选出不感兴趣的句子，只检查第二个句子。
- en: Identifying the first word in a sentence is a breeze, because its index is always
    0\. But what about the last one? For example, what if we need to find out how
    many sentences in the text end with a verb—(not counting any periods, of course)?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确定句子中的第一个单词非常简单，因为它的索引总是0。那最后一个呢？例如，如果我们需要找出文本中有多少个句子以动词结尾（当然不算句号）怎么办？
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Although the lengths of sentences vary, we can easily determine the length
    of a given sentence using the `len()` function. We reduce the value of `len(sent)`
    by 2 for the following reasons: first, the indices always start at 0 and end at
    size-1\. Second, the last token in both sentences in the sample is a period, which
    we need to ignore.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然句子的长度各不相同，但我们可以通过`len()`函数轻松确定给定句子的长度。我们将`len(sent)`的值减去2，原因有二：首先，索引总是从0开始，结束时是size-1；其次，示例中两个句子的最后一个标记是句号，我们需要忽略它。
- en: '***The doc.noun_chunks Container***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***doc.noun_chunks容器***'
- en: 'A Doc object’s `doc.noun_chunks` property allows us to iterate over the noun
    chunks in the document. A *noun chunk* is a phrase that has a noun as its head.
    For example, the previous sentence contains the following noun chunks:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Doc对象的`doc.noun_chunks`属性允许我们迭代文档中的名词短语。*名词短语*是以名词为核心的短语。例如，前一句包含以下名词短语：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With `doc.noun_chunks`, we can extract them as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`doc.noun_chunks`，我们可以按如下方式提取它们：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, we might extract noun chunks by iterating over the nouns in
    the sentence and finding the syntactic children for each noun to form a chunk.
    Earlier in “[Iterating over a Token’s Syntactic Children](../Text/ch03.xhtml#lev28)”
    on [page 33](../Text/ch03.xhtml#page_33), you saw an example of how to extract
    a phrase based on the syntactic dependency parse. Now let’s apply this technique
    to the sample sentence in this example to compose noun chunks manually:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过迭代句子中的名词并找到每个名词的句法子节点来提取名词短语。如在“[迭代标记的句法子节点](../Text/ch03.xhtml#lev28)”中所示，您看到过如何基于句法依赖分析提取短语的示例。现在让我们将这一技术应用到本示例中的样本句子，手动组成名词短语：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Iterating over the tokens, we pick up only nouns ➊. Next, in the inner loop,
    we iterate over a noun’s children ➋, picking up only the tokens that are either
    determiners or adjectives for the noun chunk (noun chunks can also include some
    other parts of speech, say, adverbs) ➌. Then we append the noun to the chunk ➍.
    As a result, the output of the script should be the same as in the previous example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代标记时，我们只选择名词 ➊。接下来，在内层循环中，我们迭代名词的子节点 ➋，只选择那些是限定词或形容词的标记来构成名词短语（名词短语还可以包含其他词性，比如副词）
    ➌。然后我们将名词添加到短语中 ➍。因此，脚本的输出应与前一个示例相同。
- en: '***Try This***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试看***'
- en: Notice that the words used to modify a noun (determiners and adjectives) are
    always the leftward syntactic children of the noun. This makes it possible to
    replace `Token.children` with `Token.lefts` in the previous code and then remove
    the check for the children to be either a determiner or an adjective, as necessary.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于修饰名词的词（限定词和形容词）始终是名词的左侧句法子节点。这使得我们能够在之前的代码中将`Token.children`替换为`Token.lefts`，然后根据需要移除对子节点是限定词或形容词的检查。
- en: Rewrite the previous snippet, incorporating the changes suggested here. The
    resulting set of noun chunks should remain the same in your script.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重写之前的代码片段，整合此处建议的修改。最终生成的名词短语集应该与您的脚本中的保持一致。
- en: '***The Span Object***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Span对象***'
- en: The Span object is a slice from a Doc object. In the previous sections, you
    saw how to use it as a container for a sentence and a noun chunk, derived from
    `doc.sents` and `doc.noun_chunks`, respectively.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Span对象是Doc对象的一个切片。在前面的部分中，您已经看到了如何将它作为句子和名词短语的容器，分别来源于`doc.sents`和`doc.noun_chunks`。
- en: 'The Span object’s usage isn’t limited to being a container for sentences or
    noun chunks only. We can use it to contain an arbitrary set of neighboring tokens
    in the document by specifying a range of indices, as in the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Span对象的使用不仅限于作为句子或名词短语的容器。我们还可以通过指定索引范围，将文档中相邻的多个标记包含在内，如以下示例所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Span object contains several methods, one of the most interesting of which
    is `span.merge()`, which allows us to merge the span into a single token, retokenizing
    the document. This can be useful when the text contains names consisting of several
    words.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Span对象包含几个方法，其中最有趣的一个是`span.merge()`，它允许我们将Span合并为单一标记，从而重新标记文档。当文本包含由多个单词组成的名称时，这非常有用。
- en: 'The sample sentence in the following example contains two place names consisting
    of several words (“Golden Gate Bridge” and “San Francisco”) that we might want
    to group together. The default tokenization won’t recognize these multi-word place
    names as single tokens. Look at what happens when we list the text’s tokens:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的句子包含了两个由多个单词组成的地名（“Golden Gate Bridge”和“San Francisco”），我们可能希望将它们归为一类。默认的标记化方式不会将这些多词地名识别为单一标记。查看当我们列出文本的标记时会发生什么：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each word and punctuation mark is its own token.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单词和标点符号都是它自己的标记。
- en: 'With the `span.merge()` method, we can change this default behavior:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`span.merge()`方法，我们可以改变这种默认行为：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we create a lemma for the “Golden Gate Bridge” span, and then
    pass the lemma to `span.merge()` as a parameter. (To be precise, we pass on the
    lemma’s id obtained through the `doc.vocab.string` attribute.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们为“Golden Gate Bridge”span创建一个词形，然后将该词形作为参数传递给`span.merge()`。（准确地说，我们传递了通过`doc.vocab.string`属性获取的词形ID。）
- en: Note that the `span.merge()` method doesn’t merge the corresponding lemmas by
    default. When called without parameters, it sets the lemma of the merged token
    to the lemma of the first token of the span being merged. To specify the lemma
    we want to assign to the merged token, we pass it to `span.merge()` as the lemma
    parameter, as illustrated here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`span.merge()`方法默认不会合并相应的词形。当没有参数时，它将合并的词元的词形设置为被合并的span中第一个词元的词形。为了指定我们希望分配给合并词元的词形，我们将其作为词形参数传递给`span.merge()`，如下面所示。
- en: 'Let’s check whether the lemmatizer, part-of-speech tagger, and dependency parser
    can handle the newly created lemma correctly:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下词形还原器、词性标注器和依存解析器是否能够正确处理新创建的词形：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should produce the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All the attributes shown in the listing have been assigned to the “Golden Gate
    Bridge” token correctly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中显示的所有属性都已正确分配给“Golden Gate Bridge”词元。
- en: '***Try This***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试看***'
- en: The sentence in the preceding example also contains San Francisco, another multi-word
    place name that you might want to merge into a single token. To achieve this,
    perform the same operations as listed in the previous code snippets for the “Golden
    Gate Bridge” span.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的句子还包含“San Francisco”，这是另一个多词地名，你可能希望将其合并为单个词元。为了实现这一点，请执行与前面的代码片段中“Golden
    Gate Bridge”span相同的操作。
- en: When determining the start and end positions for the “San Francisco” span in
    the document, don’t forget that the indices of the tokens located to the right
    of the newly created “Golden Gate Bridge” token have been shifted downward respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定文档中“San Francisco”span的起始和结束位置时，别忘了，位于新创建的“Golden Gate Bridge”词元右侧的词元索引已经相应地向下移动了。
- en: '**Customizing the Text-Processing Pipeline**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自定义文本处理流水线**'
- en: In the previous sections, you learned how spaCy’s container objects represent
    linguistic units, such as a text and an individual token, allowing you to extract
    linguistic features associated with them. Let’s now look at the objects in the
    spaCy API that create those containers and fill them with relevant data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你了解了spaCy的容器对象如何表示语言单元，如文本和单个词元，从而使你能够提取与它们相关的语言特征。现在，让我们来看看spaCy API中创建这些容器并将相关数据填充到其中的对象。
- en: 'These objects are referred to as processing pipeline components. As you’ve
    already learned, a pipeline set includes—by default—a part-of-speech tagger, a
    dependency parser, and an entity recognizer. You can check what pipeline components
    are available for your nlp object like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象被称为处理流水线组件。正如你已经了解的，默认情况下，流水线设置包括词性标注器、依存解析器和实体识别器。你可以像这样检查你的nlp对象可用的流水线组件：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As discussed in the following sections, spaCy allows you to customize the components
    in your pipeline to best suit your needs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如下文所讨论的，spaCy允许你自定义流水线中的组件，以最适合你的需求。
- en: '***Disabling Pipeline Components***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***禁用流水线组件***'
- en: 'spaCy allows you to load a selected set of pipeline components, disabling those
    that aren’t necessary. You can do this when creating an nlp object by setting
    the `disable` parameter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy允许你加载选定的流水线组件，并禁用不必要的组件。你可以通过设置`disable`参数来做到这一点：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, we create a processing pipeline without a dependency parser.
    If we call this nlp instance on a text, the tokens won’t receive dependency labels.
    The following example illustrates this point clearly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个没有依存解析器的处理流水线。如果我们在文本上调用这个nlp实例，词元将不会收到依存标签。以下示例清楚地说明了这一点：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We try to print out the following information for each token from the sample
    sentence: the text content ➊, a part-of-speech tag ➋, and a dependency label ➌.
    But the dependency labels don’t appear.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试为每个来自示例句子的词元打印出以下信息：文本内容➊、词性标记➋和依存标签➌。但依存标签没有出现。
- en: '***Loading a Model Step by Step***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逐步加载模型***'
- en: 'You can perform several operations in one step with `spacy.load()`, which loads
    a model. For example, when you make this call:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`spacy.load()`一次性执行多个操作来加载模型。例如，当你进行以下调用时：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'spaCy performs the following steps behind the scenes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy在幕后执行以下步骤：
- en: Looking at the name of the model to be loaded, spaCy identifies what Language
    class it should initialize. In this example, spaCy creates an English class instance
    with shared vocabulary and other language data.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看要加载的模型名称时，spaCy 会识别它应该初始化哪个语言类。在这个例子中，spaCy 会创建一个包含共享词汇和其他语言数据的英语类实例。
- en: spaCy iterates over the processing pipeline names, creates corresponding components,
    and adds them to the processing pipeline.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: spaCy 遍历处理管道的名称，创建相应的组件，并将它们添加到处理管道中。
- en: spaCy loads the model data from disk and makes it available to the Language
    class instance.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: spaCy 从磁盘加载模型数据，并将其提供给语言类实例。
- en: These implementation details are hidden by `spacy.load()`, which in most cases
    saves you effort and time. But sometimes, you might need to implement these steps
    explicitly to have fine-grained control over the process. For example, you might
    need to load a custom component to the processing pipeline. The component could
    print some information about the Doc object in the pipeline, such as the number
    of tokens or the presence or absence of certain parts of speech.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现细节被`spacy.load()`隐藏，通常情况下，这会为你节省时间和精力。但有时，你可能需要显式地实现这些步骤，以便对过程进行更精细的控制。例如，你可能需要将一个自定义组件加载到处理管道中。该组件可以打印有关管道中Doc对象的一些信息，如标记数量或某些词性是否存在。
- en: As usual, more fine-grained control requires you to provide more information.
    First, rather than specifying a shortcut, you’ll need to obtain the actual model
    name so you can get the path to the model package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，更精细的控制要求你提供更多的信息。首先，你需要获取实际的模型名称，而不是指定快捷方式，这样你才能获取模型包的路径。
- en: 'You can identify the full name of the model as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式识别模型的完整名称：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `nlp.meta` attribute used in this code is a dictionary that contains the
    metadata of the loaded model. What you need in this example is the model’s language
    and the model’s name.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中使用的`nlp.meta`属性是一个字典，包含已加载模型的元数据。在此示例中，你需要的是模型的语言和模型的名称。
- en: 'Now that you know the model’s name, you can find its location in your system
    by using the `get_package_path` utility function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道了模型的名称，你可以通过使用`get_package_path`工具函数来找到它在系统中的位置：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The path specified in this code might be different on your machine, depending
    on your Python installation directory. Regardless, this is not the full path.
    You’ll need to append one more folder to it. The name of this folder is composed
    of the model name and the model version appended to it. (This is where the model
    package is located.) You can determine its name as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中指定的路径可能会因你的 Python 安装目录不同而有所不同。但无论如何，这不是完整的路径。你需要再附加一个文件夹名。这个文件夹的名称由模型名称和附加的模型版本组成。（这是模型包所在的位置。）你可以通过以下方式确定它的名称：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You might also want to look at the list of pipeline components used with the
    model. (It’s important to know what components are supported in the context of
    the model and therefore can be loaded to the pipeline.) You can obtain this information
    via the `nlp.meta` attribute’s `''pipeline''` field, as shown here (or via the
    `nlp.pipe_names` attribute introduced in the beginning of “[Customizing the Text-Processing
    Pipeline](../Text/ch03.xhtml#lev34)” on [page 37](../Text/ch03.xhtml#page_37)):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想查看与模型一起使用的管道组件列表。（了解在模型上下文中支持哪些组件以及因此可以加载到管道中是很重要的。）你可以通过`nlp.meta`属性的`'pipeline'`字段来获取此信息，如下所示（或通过在“[自定义文本处理管道](../Text/ch03.xhtml#lev34)”一文的第37页([page
    37](../Text/ch03.xhtml#page_37))中介绍的`nlp.pipe_names`属性）：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this information, we can create a script that implements the steps provided
    at the beginning of this section:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以创建一个脚本，按照本节开头提供的步骤进行操作：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this script, we use `spacy.util.get_lang_class()` ➊ to load a Language class.
    Which class we load depends on the two-letter language code specified as the parameter.
    In this example, we load English. Next, in a loop ➋, we create ➌ and add ➍ the
    pipeline components to the processing pipeline. Then we load a model from disk,
    specifying the path to it used on your machine ➎.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用`spacy.util.get_lang_class()` ➊来加载一个语言类。加载哪个类取决于作为参数指定的两字母语言代码。在这个例子中，我们加载英语。接下来，在一个循环中
    ➋，我们创建 ➌ 并添加 ➍ 管道组件到处理管道中。然后，我们从磁盘加载一个模型，指定你机器上使用的路径 ➎。
- en: Looking at the code in this script, it might seem that the pipeline components
    become functional once we’ve added them to the processing pipeline. Actually,
    we can’t use them until we load the model data, so if we omit the last line of
    code in the script, we won’t even be able to create a Doc object using this nlp
    instance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看这段代码，可能会觉得一旦我们将管道组件添加到处理管道中，它们就变得可用。实际上，在加载模型数据之前，我们不能使用它们，所以如果我们省略脚本中的最后一行代码，我们甚至无法使用这个nlp实例创建Doc对象。
- en: '***Customizing the Pipeline Components***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义管道组件***'
- en: 'By customizing pipeline components, you can best meet the needs of your application.
    For example, suppose you want your model’s named entity recognizer system to recognize
    the word Festy as a city district. By default, it recognizes it as an organization,
    as illustrated in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自定义管道组件，你可以最好地满足应用程序的需求。例如，假设你希望模型的命名实体识别系统将“Festy”识别为一个城市区。默认情况下，它会将其识别为一个组织，如下所示：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The label `ORG` stands for companies, agencies, and other institutions. But
    you want to make the entity recognizer classify it as an entity of type `DISTRICT`
    instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 标签`ORG`代表公司、机构和其他组织。但你希望让实体识别器将其分类为`DISTRICT`类型的实体。
- en: The entity recognizer component is implemented in the spaCy API as the `EntityRecognizer`
    class. Using this class’s methods, you can initialize an instance of `ner` and
    then apply it to a text. In most cases, you don’t need to perform these operations
    explicitly; spaCy does it for you under the hood when you create an nlp object
    and then create a Doc object, respectively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实体识别器组件在spaCy API中作为`EntityRecognizer`类实现。通过使用该类的方法，你可以初始化一个`ner`实例，然后将其应用于文本。在大多数情况下，你无需显式执行这些操作；spaCy在你创建nlp对象并创建Doc对象时会自动为你处理这些操作。
- en: But when you want to update the named entity recognition system of an existing
    model with your own examples, you’ll need to work with some of the `ner` object’s
    methods explicitly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你想用自己的示例更新现有模型的命名实体识别系统时，你需要显式地使用一些`ner`对象的方法。
- en: 'In the following example, you’ll first have to add a new label called `DISTRICT`
    to the list of supported entity types. Then you need to create a training example,
    which is what you’ll show the entity recognizer so it will learn what to apply
    the `DISTRICT` label to. The simplest implementation of the preparation steps
    might look as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你首先需要向支持的实体类型列表中添加一个名为`DISTRICT`的新标签。然后你需要创建一个训练示例，这将是你向实体识别器展示的内容，让它学习如何将`DISTRICT`标签应用到文本中。准备步骤的最简单实现可能如下所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For simplicity, this training set contains just two training samples (typically,
    you need to provide many more). Each training sample includes a sentence that
    might or might not contain an entity (or entities) to which the new entity label
    should be assigned ➊. If there is an entity in the sample, you specify its start
    and end position ➋. The second sentence in the training set doesn’t contain the
    word Festy at all ➌. This is due to the way the training process is organized.
    [Chapter 10](../Text/ch10.xhtml#ch10) covers the details of this process in more
    depth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这个训练集只包含两个训练样本（通常，你需要提供更多的样本）。每个训练样本包括一个句子，这个句子可能包含也可能不包含需要分配新实体标签的实体
    ➊。如果样本中包含实体，你需要指定它的起始和结束位置 ➋。训练集中的第二个句子根本不包含“Festy”这个词 ➌。这是因为训练过程的组织方式。第[10章](../Text/ch10.xhtml#ch10)会更深入地讲解这个过程的细节。
- en: 'Your next step is to add a new entity label `DISTRICT` to the entity recognizer:
    but before you can do this, you must get the instance of the `ner` pipeline component.
    You can do this as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向实体识别器添加一个新的实体标签`DISTRICT`：但在此之前，你必须获取`ner`管道组件的实例。你可以通过以下方式实现：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once you have a `ner` object, you can add a new label to it using the `ner.add_label()`
    method, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了`ner`对象，你可以使用`ner.add_label()`方法向其中添加新的标签，如下所示：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another action you need to take before you can start training the entity recognizer
    is to disable the other pipes to make sure that only the entity recognizer will
    be updated during the training process:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在开始训练实体识别器之前需要进行的操作是禁用其他管道，以确保在训练过程中只有实体识别器会被更新：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then you can start training the entity recognizer using the training samples
    in the `TRAIN_DATA` list created earlier in this section:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以开始使用本节前面创建的`TRAIN_DATA`列表中的训练样本来训练实体识别器：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: During training, the sample examples are shown to the model in a loop, in random
    order, to efficiently update the underlying model’s data and avoid any generalizations
    based on the order of training examples. The execution will take a while.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练过程中，样本示例会以循环的方式随机顺序展示给模型，以便有效地更新底层模型的数据，避免根据训练示例的顺序进行任何泛化。执行将花费一些时间。
- en: 'Once the preceding code has successfully completed, you can test how the updated
    optimizer recognizes the token Festy:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的代码成功完成，你可以测试更新后的优化器如何识别Festy这个标记：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: According to the output, it works correctly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，它工作正常。
- en: 'Keep in mind that the updates you just made will be lost when you close this
    Python interpreter session. To address this problem, the `Pipe` class—the parent
    of the `EntityRecognizer` class and other pipeline components classes—has the
    `to_disk()` method, which allows you to serialize the pipe to disk:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当你关闭此Python解释器会话时，你刚刚所做的更新将会丢失。为了解决这个问题，`Pipe`类——`EntityRecognizer`类和其他处理流程组件类的父类——有一个`to_disk()`方法，可以将管道序列化到磁盘：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now you can load the updated component to a new session with the `from_disk()`
    method. To make sure it works, close your current interpreter session, start a
    new one, and then run the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`from_disk()`方法将更新后的组件加载到新的会话中。为了确保它正常工作，关闭当前的解释器会话，启动一个新的会话，然后运行以下代码：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You load the model, disabling its default `ner` component ➊. Next, you create
    a new `ner` instance ➋ and then load it with the data from disk ➌. Then you add
    the `ner` component to the processing pipeline ➍.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你加载模型，禁用其默认的`ner`组件 ➊。接着，你创建一个新的`ner`实例 ➋，并将其从磁盘加载数据 ➌。然后，你将`ner`组件添加到处理流程中
    ➍。
- en: 'Now you can test it, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以这样测试它：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the entity recognizer labels the name Festy correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，实体识别器正确地标记了“Festy”这个名字。
- en: Although I’ve shown you how to customize the named entity recognizer only, you
    can also customize the other pipeline components in a similar way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我只向你展示了如何定制命名实体识别器，但你也可以以类似的方式定制其他处理流程组件。
- en: '**Using spaCy’s C-Level Data Structures**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用spaCy的C级数据结构**'
- en: Even with spaCy, NLP operations that involve processing large amounts of text
    can be very time-consuming. For example, you might need to compose a list of the
    adjectives most appropriate for a certain noun, and to do this, you’ll have to
    examine a large amount of text. If processing speed is critical to your application,
    spaCy allows you to take advantage of Cython’s C-level data structures and interfaces.
    Cython is one of the languages in which spaCy is written (the other one is Python).
    Because it’s a superset of Python, Cython considers almost all Python code valid
    Cython code. In addition to Python’s functionality, Cython allows you to natively
    call C functions and declare fast C types, enabling the compiler to generate very
    efficient code. You might want to use Cython to speed up time-consuming text processing
    operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是spaCy，涉及大量文本处理的自然语言处理（NLP）操作也可能非常耗时。例如，你可能需要为某个特定名词编写最合适的形容词列表，为此你需要检查大量的文本。如果处理速度对你的应用程序至关重要，spaCy允许你利用Cython的C级数据结构和接口。Cython是spaCy编写的语言之一（另一个是Python）。因为Cython是Python的超集，所以Cython几乎认为所有Python代码都是有效的Cython代码。除了Python的功能，Cython还允许你本地调用C函数并声明快速的C类型，从而使编译器能够生成非常高效的代码。你可能希望使用Cython来加速耗时的文本处理操作。
- en: spaCy’s core data structures are implemented as Cython objects, and spaCy’s
    public API allows you to access those structures. For details, refer to the Cython
    Architecture page in the documentation at *[https://spacy.io/api/cython/](https://spacy.io/api/cython/)*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy的核心数据结构作为Cython对象实现，spaCy的公共API允许你访问这些结构。有关详细信息，请参阅文档中的Cython架构页面，链接为 *[https://spacy.io/api/cython/](https://spacy.io/api/cython/)*。
- en: '***How It Works***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: To use Cython code with spaCy, you must turn it into a Python extension module
    that you can then import into your program, as illustrated in [Figure 3-3](../Text/ch03.xhtml#ch03fig03).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在spaCy中使用Cython代码，你必须将其转换为Python扩展模块，然后可以将其导入到你的程序中，如[图3-3](../Text/ch03.xhtml#ch03fig03)所示。
- en: '![image](../Images/fig3-3.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/fig3-3.jpg)'
- en: '*Figure 3-3: Building a Python extension module from a Cython script*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：从Cython脚本构建Python扩展模块*'
- en: You can do this by saving Cython code in a *.pyx* file and then running a *setup.py*
    Python script that first converts Cython code into corresponding C or C++ code
    and then invokes a C or C++ compiler. The script generates the Python extension
    module.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将Cython代码保存为*.pyx*文件，然后运行一个*setup.py* Python脚本来完成这一步，该脚本首先将Cython代码转换为相应的C或C++代码，然后调用C或C++编译器。脚本会生成Python扩展模块。
- en: '***Preparing Your Working Environment and Getting Text Files***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***准备工作环境并获取文本文件***'
- en: Before you can start building Cython code, you need to install Cython on your
    machine and obtain a large text file to work with.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建Cython代码之前，你需要在机器上安装Cython并获取一个大型文本文件作为工作材料。
- en: 'Install Cython on your machine using `pip`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`在你的机器上安装Cython：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, to simulate a time-consuming task and measure performance, you’ll need
    a large text file. For this, you can use a *Wikipedia dump file*, which contains
    a set of pages wrapped in XML. Wikipedia dump files are available for download
    at *[https://dumps.wikimedia.org/enwiki/latest/](https://dumps.wikimedia.org/enwiki/latest/)*.
    Scroll down to the *enwiki-latest-pages-articles*.xml-*.bz2* files and choose
    one that is large enough for your tests. But don’t choose one that is too large
    unless you want to spend hours waiting for your machine to complete your test
    code. A dump file of 10–100MB should be appropriate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了模拟一个耗时的任务并衡量性能，你需要一个大型文本文件。为此，你可以使用一个*Wikipedia dump file*，它包含了一组用XML包装的页面。Wikipedia
    dump文件可以在*[https://dumps.wikimedia.org/enwiki/latest/](https://dumps.wikimedia.org/enwiki/latest/)*下载。滚动到*enwiki-latest-pages-articles*.xml-*.bz2*文件，并选择一个足够大进行测试的文件。但除非你愿意花几个小时等待你的机器完成测试代码，否则不要选择太大的文件。10–100MB大小的dump文件应该足够合适。
- en: Once you’ve downloaded the file, extract raw text from it with a tool like *gensim.corpora.wikicorpus*
    (*[https://radimrehurek.com/gensim/corpora/wikicorpus.html](https://radimrehurek.com/gensim/corpora/wikicorpus.html)*),
    which is designed specifically for constructing a text corpus from a Wikipedia
    database dump.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完文件后，使用像*gensim.corpora.wikicorpus*这样的工具提取原始文本（*[https://radimrehurek.com/gensim/corpora/wikicorpus.html](https://radimrehurek.com/gensim/corpora/wikicorpus.html)*），该工具专为从Wikipedia数据库dump构建文本语料库而设计。
- en: '***Your Cython Script***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你的Cython脚本***'
- en: Now let’s write a Cython script that analyzes the text file. For simplicity,
    suppose all you want to do is count the number of personal pronouns in the submitted
    text. That means you need to count the number of tokens with the `PRP` part-of-speech
    tag assigned to them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来写一个Cython脚本，用于分析文本文件。为简单起见，假设你要做的就是统计提交文本中的人称代词数量。这意味着你需要统计被分配了`PRP`词性标签的token数量。
- en: '**WARNING**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*As stated in the documentation, C-level methods intended for use from Cython
    are designed for speed over safety. Mistakes in the code might cause the execution
    to crash abruptly.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*如文档所述，旨在从Cython使用的C级别方法优先考虑速度而非安全性。代码中的错误可能导致执行突然崩溃。*'
- en: 'In a directory in your local filesystem, create a file called *spacytext.pyx*
    and insert the following code into it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地文件系统中的一个目录下，创建一个名为*spacytext.pyx*的文件，并将以下代码插入其中：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start with a set of `cimport` statements to import necessary Cython modules,
    mostly from the spaCy library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一组`cimport`语句导入必要的Cython模块，主要来自spaCy库。
- en: Then we define the Cython struct `DocStruct` as the container for the text being
    processed and the `TokenC*` variable ➊, a pointer to a `TokenC` struct used in
    spaCy as the data container for the Token object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义Cython结构体`DocStruct`，作为处理中文本的容器，以及`TokenC*`变量 ➊，它是一个指向spaCy中用于表示Token对象的数据容器`TokenC`结构体的指针。
- en: Next, we define a Cython function `counter` ➋ that counts the number of personal
    pronouns in the text.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个Cython函数`counter` ➋，用于统计文本中的人称代词数量。
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* `cdef` *functions won’t be available in the Python code that imports
    the module. If you want to create a function that will be visible to Python and
    to take advantage of C-level data structures and interfaces at the same time,
    you need to declare that function as* `cpdef`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cdef`*函数在导入该模块的Python代码中不可用。如果你想创建一个函数，既能在Python中可见，又能同时利用C级别的数据结构和接口，你需要将该函数声明为`cpdef`。'
- en: Finally, we define a `cpdef` Cython/Python main function ➌ that we can use in
    Python.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个`cpdef`的Cython/Python主函数 ➌，我们可以在Python中使用它。
- en: '***Building a Cython Module***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建Cython模块***'
- en: 'Unlike Python, you must compile Cython code. You can do this in several ways,
    the best of which is to write a distutils/setuptools *setup.py* Python script.
    Create a *setup.py* file in the same directory as your Cython script. Your *setup.py*
    file should include the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，你必须编译Cython代码。你可以通过多种方式进行编译，其中最好的方式是编写一个distutils/setuptools *setup.py*
    Python脚本。在与Cython脚本相同的目录中创建一个*setup.py*文件。你的*setup.py*文件应包括以下代码：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a regular distutils/setuptools *setup.py* script except for two additions
    related to the example we’re working with. First, we import `numpy` ➊ and then
    explicitly specify where to find the *.h* files of the library ➌. We do this to
    avoid the *numpy/arrayobject.h* compilation error that occurs in some systems.
    We use the other setup option, `language = "c++"` ➋ to instruct the setup process
    to employ a C++ compiler rather than performing C compilation, which is the default.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常规的distutils/setuptools *setup.py*脚本，只是多了两个与我们当前示例相关的部分。首先，我们导入了`numpy`
    ➊，然后显式指定了在哪里找到库的*.h*文件 ➌。我们这样做是为了避免在某些系统中发生的*numpy/arrayobject.h*编译错误。我们使用另一个设置选项，`language
    = "c++"` ➋，以指示设置过程使用C++编译器，而不是默认的C编译。
- en: 'Now that we have the setup script, you can build your Cython code. You can
    do this from within a system terminal, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设置脚本，你可以构建你的Cython代码。你可以在系统终端中执行此操作，方法如下：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A bunch of messages will display during the compilation process. Some of them
    might be warnings, but they’re rarely critical. For example, you might see this
    message, which is not critical for the process:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中会显示一堆信息，其中一些可能是警告，但很少是关键性的。例如，你可能会看到这个消息，但它对过程并不关键：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***Testing the Module***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试模块***'
- en: 'After the compilation completes successfully, the `spacytext` module will be
    added to your Python environment. To test the newly created module, open a Python
    session and run the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成功完成后，`spacytext`模块将被添加到你的Python环境中。为了测试新创建的模块，打开一个Python会话并运行以下命令：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If it displays no errors, you can enter the following commands (this assumes
    your text data is in a *test.txt* file):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示错误，你可以输入以下命令（假设你的文本数据保存在一个*test.txt*文件中）：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You open the file in which you have text data for this example in binary mode
    to obtain a bytes object ➊. If the file is too big, you can pick up only part
    of its content when creating a Doc object ➋. Once you’ve created the Doc object,
    you can test the `spacytext` module you just created with Cython, invoking its
    `main()` function ➌.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你以二进制模式打开包含文本数据的文件（在本例中）以获取一个字节对象 ➊。如果文件太大，你可以在创建Doc对象时只选择其部分内容 ➋。一旦你创建了Doc对象，就可以使用Cython创建的`spacytext`模块，调用其`main()`函数
    ➌。
- en: The first figure in the output generated by the `spacytext.main()` function
    shows the total number of tokens found in the submitted text. The second figure
    is the number of personal pronouns found in this same text.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`spacytext.main()`函数生成的输出中的第一个数字表示提交的文本中找到的总词汇数。第二个数字表示在同一文本中找到的人称代词的数量。'
- en: '**Summary**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you looked at the most important of spaCy’s container objects.
    You also learned how to customize your text-processing pipeline and use spaCy’s
    C-level data structures and interfaces from Cython.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了spaCy中最重要的容器对象。你还学会了如何自定义文本处理管道，并使用Cython中的spaCy C级数据结构和接口。
