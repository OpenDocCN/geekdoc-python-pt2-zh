- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to Use Classes and Objects
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why is a giraffe like a sidewalk? Because a giraffe and a sidewalk are both
    *things*, which are known in the English language as nouns and in Python as *objects*.
    In programming, objects are a way to organize code and break things down to more
    easily work with complex ideas. (We used an object in [Chapter 4](ch04.xhtml#ch04)
    when we worked with the turtle module’s Turtle object.)
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand how objects work in Python, we need to think about types
    of objects. Let’s start with giraffes and sidewalks.
  prefs: []
  type: TYPE_NORMAL
- en: A giraffe is a type of mammal, which is a type of animal. A giraffe is also
    an animate object—it’s alive.
  prefs: []
  type: TYPE_NORMAL
- en: There’s not much to say about a sidewalk other than it’s not a living thing.
    Let’s call it an inanimate object (in other words, it’s not alive). The terms
    *mammal*, *animal*, *animate*, and *inanimate* are all ways of classifying things.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0096-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Breaking Things into Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, objects are defined by *classes*, which classify objects into groups.
    For example, the tree diagram in [Figure 8-1](ch08.xhtml#ch08fig01) shows the
    classes that giraffes and sidewalks fit into based on our preceding definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Tree diagram of some classes*'
  prefs: []
  type: TYPE_NORMAL
- en: The main class is Thing. Below the Thing class, we have Inanimate and Animate.
    These classes are further broken down into Sidewalk for Inanimate, and Animal,
    Mammal, and Giraffe for Animate.
  prefs: []
  type: TYPE_NORMAL
- en: We can use classes to organize bits of code. For example, consider the turtle
    module. All the things Python’s turtle module can do—such as moving forward, moving
    backward, turning left, and turning right—are functions in the Turtle class. An
    object is a member of a class, and we can create any number of objects for a class,
    which we’ll get to shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create the same set of classes shown in our tree diagram, starting
    from the top. We define classes using the class keyword followed by a name. Thing
    is the broadest class, so we’ll create it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We name the class Thing and use the pass statement to let Python know we’re
    not going to give any more information. The pass keyword is used when we want
    to provide a class or function but don’t want to fill in the details at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add the other classes and build some relationships between them.
  prefs: []
  type: TYPE_NORMAL
- en: Children and Parents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a class is a part of another class, it’s considered a *child* of that class,
    and the other class is its *parent*. Classes can be both *children of* and *parents
    to* other classes. In our tree diagram, the class above another class is its parent
    and the class below it is its child. For example, Inanimate and Animate are both
    children of the class Thing, meaning that Thing is their parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell Python that a class is a child of another class, we add the name of
    the parent class in parentheses after the name of our new class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a class called Inanimate and tell Python that its parent class
    is Thing. Next, we create a class called Animate and tell Python that its parent
    class is also Thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the Sidewalk class with the parent class Inanimate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can organize the Animal, Mammal, and Giraffe classes using their parent
    classes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding Objects to Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a bunch of classes, but what about putting some more information
    into those classes? Say we have a giraffe named Reginald. We know he belongs in
    the Giraffe class, but what do we use—in programming terms—to describe the single
    giraffe called Reginald?
  prefs: []
  type: TYPE_NORMAL
- en: 'We call Reginald an *object* (also known as an *instance*) of the Giraffe class.
    To “introduce” Reginald to Python, we use this little snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code tells Python to create an object of the Giraffe class and assign it
    to the reginald variable. Like when we call a function, the class name is followed
    by parentheses. Later in this chapter, we’ll see how to create objects and use
    parameters in the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: But what does the reginald object do? Well, nothing at the moment. To make our
    objects useful, when we create our classes, we also need to define functions that
    can be used with the objects in that class. Rather than just using the pass keyword
    immediately after defining the class, we can add function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Functions of Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.xhtml#ch07) introduced functions as a way to reuse code. When
    we define a function that’s associated with a class, we do so in the same way
    that we define any other function, except we indent it beneath the class definition.
    For example, here’s a normal function that isn’t associated with a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are a couple of functions that are defined for a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding Class Characteristics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the child classes of the Animate class we defined in section Children
    and Parents. We can add characteristics to each class that describe what it is
    and what it can do. A *characteristic* is a trait all members of the class (and
    its children) share.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what do all animals have in common? To start with, they breathe,
    move, and eat. What about mammals? Mammals feed their young with milk, and they
    also breathe, move, and eat. We know giraffes eat leaves from high up in trees.
    And like all mammals, they feed their young with milk, breathe, move, and eat.
    When we add these characteristics to our tree diagram, we get something like [Figure
    8-2](ch08.xhtml#ch08fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: Classes with characteristics*'
  prefs: []
  type: TYPE_NORMAL
- en: These characteristics can be thought of as actions, or functions—things that
    an object of that class can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a function to a class, we use the def keyword. So the Animal class will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of this listing, we define the class as we did before, but
    instead of using pass on the next line, we define a function called breathe and
    give it the self parameter. The self parameter is a way for one function in the
    class to call another function in the class (and in the parent class). We’ll see
    this parameter in use later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0100-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the next line, pass tells Python we’re not going to provide any more information
    about the breathe function because it’s going to do nothing for now. Then we add
    the move and eat_food functions and use the pass keyword for both. We’ll recreate
    our classes shortly and put some proper code in the functions. This is a common
    way to develop programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Often, programmers will create classes with functions that do nothing as a
    way to figure out what the class should do before getting into the details of
    the individual functions.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also add functions to the Mammal and Giraffe classes. Each class will
    be able to use the characteristics (or functions) of its parent, meaning you don’t
    need to make one really complicated class. Instead, you can put your functions
    in the highest parent class where the characteristic applies. (This makes your
    classes simpler and easier to understand.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, the Mammal class provides a function feed _young_with_milk.
    The Giraffe class is a child class (or *subclass*) of Mammal and provides another
    function: eat_leaves_from_trees.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Classes and Objects?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve now added functions to our classes, but why use classes and objects at
    all when you could just write normal functions called breathe, move, eat_food,
    and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer that question, we’ll use our giraffe called Reginald, which we created
    earlier as an object of the Giraffe class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Because reginald is an object, we can call (or run) functions provided by the
    Giraffe class and its parent classes. We call functions on an object by using
    the dot (.) operator and the name of the function. To tell Reginald to move or
    eat, we can call the functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose Reginald has a giraffe friend named Harriet. Let’s create another Giraffe
    object called harriet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we’re using objects and classes, we can tell Python which giraffe we’re
    talking about when we want to run the move function. For example, if we want to
    make Harriet move but leave Reginald in place, we could call the move function
    by using our harriet object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, only Harriet would be moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our classes a little to make this more obvious. Add a print statement
    to each function instead of using pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we create our reginald and harriet objects and call functions on them,
    we can see something actually happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On the first two lines, we create the variables reginald and harriet, which
    are objects of the Giraffe class. Next, we call the move function on reginald,
    and Python prints moving on the following line. In the same way, we call the eat_leaves_from_trees
    function on harriet, and Python prints eating leaves. If these were real giraffes,
    rather than objects in a computer, one giraffe would be walking and the other
    would be eating.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0103-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions defined for classes are actually called methods. The terms are almost
    interchangeable except that methods can only be called on objects of a class.
    Another way of saying this is that a method is associated with a class, but a
    function is not. Given they are almost the same, we’ll use the term function in
    this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: Objects and Classes in Pictures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s try taking a more graphical approach to objects and classes and return
    to the turtle module we toyed with in [Chapter 4](ch04.xhtml#ch04). When we use
    turtle.Turtle(), Python creates an object of the Turtle class that is provided
    by the turtle module (similar to our reginald and harriet objects). We can create
    two Turtle objects (named Avery and Kate) just as we created two giraffes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each turtle object (avery and kate) is a member of the Turtle class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here’s where objects start to become powerful. Having created our Turtle
    objects, we can call functions on each, and they will draw independently. Try
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this series of instructions, we tell Avery to move forward 50 pixels, turn
    right 90 degrees, and move forward 20 pixels so she finishes facing downward.
    Remember that turtles always start off facing to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to move Kate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We tell Kate to turn left 90 degrees and then move forward 100 pixels so she
    ends facing up. So far, we have a line with arrowheads moving in two different
    directions, with the head of each arrow representing a different turtle object:
    Avery is pointing down, and Kate is facing up (see [Figure 8-3](ch08.xhtml#ch08fig03)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Kate and Avery*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s add another turtle, Jacob, and move him without bugging Kate or Avery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](Images/f0105-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a new Turtle object called jacob; then we turn him left 180
    degrees and move him forward 80 pixels. Our drawing with three turtles should
    look like [Figure 8-4](ch08.xhtml#ch08fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Kate and Avery and Jacob*'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we call turtle.Turtle() to create a turtle, we add a new, independent
    object. Each object is still an instance of the Turtle class, and we can use the
    same functions on each object. But because we’re using objects, we can move each
    turtle independently. Like our independent Giraffe objects (Reginald and Harriet),
    Avery, Kate, and Jacob are independent Turtle objects. If we create a new object
    with the same variable name as an object we’ve already created, the old object
    won’t necessarily vanish.
  prefs: []
  type: TYPE_NORMAL
- en: Other Useful Features of Objects and Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes and objects make it easy to group functions. They’re also really useful
    when we want to think about a program in smaller chunks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a huge software application like a word processor or a
    3D computer game. It’s nearly impossible for most people to fully understand large
    programs like these because there’s so much code. But break these monster programs
    into smaller pieces, and each piece starts to make sense—as long as you know its
    programming language, of course!
  prefs: []
  type: TYPE_NORMAL
- en: When writing a large program, breaking it up also allows you to divide the work
    among other programmers. The most complicated programs (like your web browser)
    were written by many people, or teams of people, working on different parts at
    the same time around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we want to expand some of the classes we’ve created in this chapter
    (Animal, Mammal, and Giraffe), but we have too much work to do, and our friends
    offer to help. We could divide the work of writing the code so that one person
    works on the Animal class, another on the Mammal class, and still another on the
    Giraffe class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0106-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inherited Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may realize that whoever ends up working on the Giraffe class is lucky,
    because any functions created by the people working on the Animal and Mammal classes
    can also be used by the Giraffe class. The Giraffe class *inherits* functions
    from the Mammal class, which, in turn, inherits functions from the Animal class.
    In other words, when we create a Giraffe object, we can use functions defined
    in the Giraffe class, as well as functions defined in the Mammal and Animal classes.
    And, by the same token, if we create a Mammal object, we can use functions defined
    in the Mammal class as well as its parent class, Animal.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the relationships between the Animal, Mammal, and Giraffe classes again.
    The Animal class is the parent of the Mammal class, and Mammal is the parent of
    the Giraffe class ([Figure 8-5](ch08.xhtml#ch08fig05)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: Classes and inherited functions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though reginald is an object of the Giraffe class, we can still call the
    move function we defined in the Animal class because functions defined in any
    parent class are available to its child classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, all the functions we defined in both the Animal and Mammal classes
    can be called from our reginald object because the functions are inherited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we create an object of the Giraffe class called reginald. When
    we call each function, it prints a message regardless of whether the function
    is defined in Giraffe or in a parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Calling Other Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we call functions on an object, we use the object’s variable name. For
    example, we can call the move function on Reginald the giraffe like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a function in the Giraffe class call the move function, we’d use the
    self parameter. The self parameter is a way for one function in the class to call
    another function. For example, suppose we add a function called find_food to the
    Giraffe class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created a function that combines two other functions, which is quite common
    in programming. Often, you’ll write a function that does something useful, which
    you can then use inside another function. (We’ll do this in [Chapter 11](ch11.xhtml#ch11),
    where we’ll write more complex functions to create a game.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use self to add some functions to the Giraffe class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the eat_food and move functions from the parent Animal class to define
    eat _leaves_from_trees and dance_a_jig for the Giraffe class, because these are
    inherited functions. By adding functions that call other functions, when we create
    objects of these classes, we can call a single function that does more than just
    one thing. See what happens when we call the dance_a_jig function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0109-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this code, our giraffe moves four times (that is, the text moving is printed
    four times).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the find_food function, we get three lines printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initializing an Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes when creating an object, we want to set some values (also called *properties*)
    for later use. When we *initialize* an object, we’re getting it ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we want to set the number of spots on our giraffe objects
    when they’re created (or initialized). To do this, we create an __init__ function
    (note the two underscore characters on each side, for a total of four). The init
    function sets the properties for an object when the object is first created. Python
    will automatically call this function when we create a new object. Here’s how
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the __init__ function with the self and spots parameters. Just
    like the other functions we’ve defined in the class, the __init__ function also
    needs to have self as the first parameter. Next, we set the spots parameter to
    an object variable (its property) called giraffe_spots by using the self parameter.
    You might think of this line of code as saying, “Take the value of the spots parameter
    and save it for later (using the giraffe_spots object variable).” Just as one
    function in a class can call another function using the self parameter, variables
    in the class are also accessed using self.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, if we create a couple of new giraffe objects (called ozwald and gertrude)
    and display their number of spots, you can see the initialization function in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an instance of the Giraffe class using the parameter value
    100\. This has the effect of calling the __init__ function and using 100 for the
    value of the spots parameter. Next, we create another instance of the Giraffe
    class with a value of 150\. Lastly, we print the object variable giraffe_spots
    for each of our giraffe objects, and we see that the results are 100 and 150\.
    It worked!
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when we create an object of a class, such as ozwald in this example,
    we can refer to its variables or functions using the dot operator and the name
    of the variable or function we want to use (for example, ozwald.giraffe_spots).
    But when we’re creating functions inside a class, we refer to those same variables
    (and other functions) by using the self parameter (self.giraffe_spots).
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used classes to create categories of things and made objects
    (or instances) of those classes. You learned how the child of a class inherits
    the functions of its parent, and that even though two objects are of the same
    class, they’re not necessarily clones. For example, two giraffe objects can have
    their own distinct number of spots.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to call (or run) functions on an object and how object variables
    are a way of saving values in those objects. Lastly, we used the self parameter
    in functions to refer to other functions and variables. These concepts are fundamental
    to Python, and you’ll see them multiple times throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Puzzles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Give the following examples a try to experiment with creating your own functions.
    The solutions can be found at *[http://python-for-kids.com](http://python-for-kids.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: '#1: The Giraffe Shuffle'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add functions to the Giraffe class to move the giraffe’s left and right feet
    forward and backward. A function for moving the left foot forward might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a function called dance to teach our giraffes to dance (the function
    will call the four foot functions you’ve just created). The result of calling
    this new function will be a simple dance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#2: Turtle Pitchfork'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create the following picture of a sideways pitchfork using four Turtle objects
    (the exact length of the lines isn’t important). Remember to import the turtle
    module first!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0112-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '#3: Two Small Spirals'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create the following picture of two small spirals using two Turtle objects (again,
    the exact size of the spirals isn’t important).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0112-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '#4: Four Small Spirals'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take the two spirals we created in the previous code and make a mirror
    image to create four spirals, which should look like the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0113-01.jpg)'
  prefs: []
  type: TYPE_IMG
