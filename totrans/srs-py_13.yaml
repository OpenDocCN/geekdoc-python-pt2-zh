- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**WRITE LESS, CODE MORE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**少写代码，多做事情**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In this final chapter, I’ve compiled a few of Python’s more advanced features
    that I use to write better code. These are not limited to the Python Standard
    Library. We’ll cover how to make your code compatible with both Python 2 and 3,
    how to create a Lisp-like method dispatcher, how to use context managers, and
    how to create a boilerplate for classes with the attr module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我总结了我用来编写更好代码的一些 Python 高级特性。这些不仅限于 Python 标准库。我们将讨论如何使你的代码兼容 Python 2
    和 3，如何创建类似 Lisp 的方法调度器，如何使用上下文管理器，以及如何使用 attr 模块为类创建模板。
- en: '**Using six for Python 2 and 3 Support**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 six 支持 Python 2 和 3**'
- en: As you likely know, Python 3 breaks compatibility with Python 2 and shifts things
    around. However, the basics of the language haven’t changed between versions,
    which makes it possible to implement forward and backward compatibility, creating
    a bridge between Python 2 and Python 3.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Python 3 打破了与 Python 2 的兼容性，并进行了许多调整。然而，语言的基础在版本间并未改变，这使得实现向前和向后兼容成为可能，创建了
    Python 2 和 Python 3 之间的桥梁。
- en: Lucky for us, this module already exists! It’s called six—because 2 × 3 = 6.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个模块已经存在了！它叫做 six——因为 2 × 3 = 6。
- en: 'The six module provides the useful six.PY3 variable, which is a Boolean that
    indicates whether you are running Python 3 or not. This is the pivot variable
    for any of your codebase that has two versions: one for Python 2 and one for Python
    3\. However, be careful not to abuse it; scattering your codebase with if six.PY3
    is going to make it difficult for people to read and understand.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: six 模块提供了有用的 six.PY3 变量，它是一个布尔值，表示你是否在运行 Python 3。这是任何同时支持 Python 2 和 Python
    3 版本的代码库中的核心变量。然而，要小心不要滥用它；如果在代码库中到处使用 if six.PY3，会让其他人很难阅读和理解你的代码。
- en: When we discussed generators in “[Generators](ch08.xhtml#lev1sec42)” on [page
    121](ch08.xhtml#page_121), we saw that Python 3 has a great property whereby iterable
    objects are returned instead of lists in various built-in functions, such as map()
    or filter(). Python 3 therefore got rid of methods like dict.iteritems(), which
    was the iterable version of dict.items() in Python 2, in favor of making dict.items()
    return an iterator rather than a list. This change in methods and their return
    types can break your Python 2 code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 “[生成器](ch08.xhtml#lev1sec42)” 中讨论生成器时，曾提到过 Python 3 有一个很好的特性：在许多内置函数（如
    map() 或 filter()）中，返回的是可迭代对象，而不是列表。因此，Python 3 摒弃了像 dict.iteritems() 这样的方法（它是
    Python 2 中 dict.items() 的可迭代版本），转而让 dict.items() 返回一个迭代器而不是列表。这种方法和返回类型的变化可能会破坏你的
    Python 2 代码。
- en: 'The six module provides six.iteritems() for such cases, which can be used to
    replace Python 2–specific code like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: six 模块提供了 six.iteritems() 来解决这种情况，可以用来替代 Python 2 特有的代码，例如：
- en: 'for k, v in mydict.iteritems():'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k, v in mydict.iteritems():'
- en: print(k, v)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: print(k, v)
- en: 'Using six, you would replace the mydict.iteritems() code with Python 2- and
    3-compliant code like so:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 six，你可以将 mydict.iteritems() 代码替换为兼容 Python 2 和 3 的代码，像这样：
- en: import six
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: import six
- en: 'for k, v in six.iteritems(mydict):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k, v in six.iteritems(mydict):'
- en: print(k, v)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: print(k, v)
- en: And *voilà*, both Python 2 and Python 3 compliance achieved in a snap! The six.iteritems()
    function will use either dict.iteritems() or dict.items() to return a generator,
    depending on the version of Python you’re using. The six module provides a lot
    of similar helper functions that can make it easy to support multiple Python versions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而是 *瞧*，Python 2 和 Python 3 的兼容性轻松实现！six.iteritems() 函数将根据你使用的 Python 版本，使用 dict.iteritems()
    或 dict.items() 返回一个生成器。six 模块提供了许多类似的辅助函数，能够轻松支持多个 Python 版本。
- en: Another example would be the six solution to the raise keyword, whose syntax
    is different between Python 2 and Python 3\. In Python 2, raise will accept multiple
    arguments, but in Python 3, raise accepts an exception as its only argument and
    nothing else. Writing a raise statement with two or three arguments in Python
    3 would result in a SyntaxError.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是 six 解决方案中关于 raise 关键字的问题，其语法在 Python 2 和 Python 3 之间有所不同。在 Python 2 中，raise
    可以接受多个参数，但在 Python 3 中，raise 只接受一个异常作为参数，不能有其他参数。如果在 Python 3 中写一个带有两个或三个参数的 raise
    语句，将会导致 SyntaxError。
- en: The six module provides a workaround here in the form of the function six.reraise(),
    which allows you to reraise an exception in whichever version of Python you use.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: six 模块在这里提供了一种解决方法，函数 six.reraise() 允许你在使用的 Python 版本中重新抛出异常。
- en: '***Strings and Unicode***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串与 Unicode***'
- en: Python 3’s enhanced ability to handle advanced encodings solved the string and
    unicode issues of Python 2\. In Python 2, the basic string type is str, which
    can only handle basic ASCII strings. The type unicode, added later in Python 2.5,
    handles real strings of text.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 增强了处理高级编码的能力，解决了 Python 2 中字符串和 unicode 的问题。在 Python 2 中，基本的字符串类型是
    str，只能处理基本的 ASCII 字符串。unicode 类型是在 Python 2.5 后添加的，用于处理真实的文本字符串。
- en: In Python 3, the basic string type is still str, but it shares the properties
    of the Python 2 unicode class and can handle advanced encodings. The bytes type
    replaces the str type for handling basic character streams.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，基本的字符串类型仍然是 str，但它继承了 Python 2 中 unicode 类的特性，并能够处理高级编码。bytes 类型取代了
    str 类型，用于处理基本字符流。
- en: The six module again provides functions and constants, such as six.u and six.string_types,
    to handle the transition. The same compatibility is provided for integers, with
    six.integer_types that will handle the long type that has been removed from Python
    3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: six 模块再次提供了函数和常量，例如 six.u 和 six.string_types，来处理过渡。同样的兼容性也适用于整数，使用 six.integer_types
    来处理 Python 3 中已删除的 long 类型。
- en: '***Handling Python Modules Moves***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理 Python 模块的迁移***'
- en: In the Python Standard Library, some modules have moved or have been renamed
    between Python 2 and 3\. The six module provides a module called six.moves that
    handles a lot of these moves transparently.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 标准库中，一些模块在 Python 2 和 3 之间发生了移动或重命名。six 模块提供了一个名为 six.moves 的模块，能够透明地处理这些变化。
- en: 'For example, the ConfigParser module from Python 2 has been renamed to configparser
    in Python 3\. [Listing 13-1](ch13.xhtml#ch13list1) shows how code can be ported
    and made compatible with both major Python versions using six.moves:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Python 2 中的 ConfigParser 模块在 Python 3 中被重命名为 configparser。 [列表 13-1](ch13.xhtml#ch13list1)
    显示了如何使用 six.moves 将代码移植并使其兼容两个主要的 Python 版本：
- en: from six.moves.configparser import ConfigParser
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: from six.moves.configparser import ConfigParser
- en: conf = ConfigParser()
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: conf = ConfigParser()
- en: '*Listing 13-1: Using six.moves to use ConfigParser() with Python 2 and Python
    3*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-1：使用 six.moves 使 ConfigParser() 兼容 Python 2 和 Python 3*'
- en: You can also add your own moves via six.add_move to handle code transitions
    that six doesn’t handle natively.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 six.add_move 添加自己的迁移，来处理 six 不原生支持的代码迁移。
- en: In the event that the six library doesn’t cover all your use cases, it may be
    worth building a compatibility module encapsulating six itself, thereby ensuring
    that you will be able to enhance the module to fit future versions of Python or
    dispose of (part of) it when you want to stop supporting a particular version
    of the language. Also note that six is open source and that you can contribute
    to it rather than maintain your own hacks!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 six 库未涵盖所有使用场景，可能值得构建一个兼容模块，封装 six 本身，从而确保你能够增强该模块以适应未来版本的 Python，或者在你不再支持某个版本时停止支持它（或部分功能）。还要注意，six
    是开源的，你可以为其做出贡献，而不是自己维护修改过的代码！
- en: '***The modernize Module***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***modernize 模块***'
- en: Lastly, there is a tool named modernize that uses the six module to “modernize”
    your code by porting it to Python 3, rather than simply converting Python 2 syntax
    to Python 3 syntax. This provides support for both Python 2 and Python 3\. The
    modernize tool helps to get your port off to a strong start by doing most of the
    grunt work for you, making this tool a better choice than the standard 2to3 tool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个名为 modernize 的工具，使用 six 模块通过将代码移植到 Python 3 来“现代化”代码，而不仅仅是将 Python 2 的语法转换为
    Python 3 的语法。这为 Python 2 和 Python 3 提供了支持。modernize 工具通过为你完成大部分繁重的工作，帮助你顺利开始移植工作，因此比标准的
    2to3 工具更为合适。
- en: '**Using Python Like Lisp to Make a Single Dispatcher**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**像 Lisp 一样使用 Python 创建单一调度器**'
- en: 'I like to say that Python is a good subset of the Lisp programming language,
    and as time passes, I find that this is more and more true. The PEP 443 proves
    that point: it describes a way to dispatch generic functions in a similar manner
    to what the Common Lisp Object System (CLOS) provides.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我常说 Python 是 Lisp 编程语言的一个良好子集，随着时间的推移，我发现这一点越来越真实。PEP 443 证明了这一点：它描述了一种以类似于
    Common Lisp 对象系统（CLOS）提供的方式来分发通用函数的方法。
- en: If you’re familiar with Lisp, this won’t be news to you. The Lisp object system,
    which is one of the basic components of Common Lisp, provides a simple, efficient
    way to define and handle method dispatching. I’ll show you how generic methods
    work in Lisp first.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Lisp，这对你来说不会是新闻。Lisp 对象系统是 Common Lisp 的基本组成部分之一，提供了一种简单高效的方式来定义和处理方法调度。首先，我会向你展示在
    Lisp 中通用方法的工作原理。
- en: '***Creating Generic Methods in Lisp***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 Lisp 中创建通用方法***'
- en: 'To begin with, let’s define a few very simple classes, without any parent classes
    or attributes, in Lisp:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: (defclass snare-drum ()
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: ())
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: (defclass cymbal ()
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: ())
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: (defclass stick ()
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: ())
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: (defclass brushes ()
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: ())
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'This defines the classes snare-drum, cymbal, stick, and brushes without any
    parent class or attributes. These classes compose a drum kit, and we can combine
    them to play sound. For this, we define a play() method that takes two arguments
    and returns a sound as a string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: (defgeneric play (instrument accessory)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: (:documentation "Play sound with instrument and accessory."))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This only defines a generic method that isn’t attached to any class and so cannot
    yet be called. At this stage, we’ve only informed the object system that the method
    is generic and might be called with two arguments named instrument and accessory.
    In [Listing 13-2](ch13.xhtml#ch13list2), we’ll implement versions of this method
    that simulate playing our snare drum.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: (defmethod play ((instrument snare-drum) (accessory stick))
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '"POC!")'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: (defmethod play ((instrument snare-drum) (accessory brushes))
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '"SHHHH!")'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: (defmethod play ((instrument cymbal) (accessory brushes))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '"FRCCCHHT!")'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-2: Defining generic methods in Lisp, independent of classes*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ve defined concrete methods in code. Each method takes two arguments:
    instrument, which is an instance of snare-drum or cymbal, and accessory, which
    is an instance of stick or brushes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, you should see the first major difference between this system
    and the Python (or similar) object systems: the method isn’t tied to any particular
    class. The methods are *generic*, and they can be implemented for any class.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it. We can call our play() method with some objects:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '* (play (make-instance ''snare-drum) (make-instance ''stick))'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '"POC!"'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '* (play (make-instance ''snare-drum) (make-instance ''brushes))'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '"SHHHH!"'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, which function is called depends on the class of the arguments—the
    object system *dispatches* the function calls to the right function for us, based
    on the type of the arguments we pass. If we call play() with an object whose classes
    do not have a method defined, an error will be thrown.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-3](ch13.xhtml#ch13list3), the play() method is called with a
    cymbal and a stick instance; however, the play() method has never been defined
    for those arguments, so it raises an error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '* (play (make-instance ''cymbal) (make-instance ''stick))'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: debugger invoked on a SIMPLE-ERROR in thread
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '#<THREAD "main thread" RUNNING {1002ADAF23}>:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: There is no applicable method for the generic function
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '#<STANDARD-GENERIC-FUNCTION PLAY (2)>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: when called with arguments
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '(#<CYMBAL {1002B801D3}> #<STICK {1002B82763}>).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'restarts (invokable by number or by possibly abbreviated name):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '0: [RETRY] Retry calling the generic function.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '1: [ABORT] Exit debugger, returning to top level.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '((:METHOD NO-APPLICABLE-METHOD (T)) #<STANDARD-GENERIC-FUNCTION PLAY (2)>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '#<CYMBAL {1002B801D3}> #<STICK {1002B82763}>) [fast-method]'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#<CYMBAL {1002B801D3}> #<STICK {1002B82763}>) [fast-method]'
- en: '*Listing 13-3: Calling a method with an unavailable signature*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-3: 调用一个没有可用签名的方法*'
- en: CLOS provides even more features, such as method inheritance or object-based
    dispatching, rather than using classes. If you’re really curious about the many
    features CLOS provides, I suggest reading “A Brief Guide to CLOS” by Jeff Dalton
    (*[http://www.aiai.ed.ac.uk/~jeff/clos-guide.html](http://www.aiai.ed.ac.uk/~jeff/clos-guide.html)*)
    as a starting point.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CLOS提供了更多的功能，比如方法继承或基于对象的调度，而不是使用类。如果你对CLOS提供的众多功能真的感兴趣，建议阅读Jeff Dalton的《CLOS简明指南》（*[http://www.aiai.ed.ac.uk/~jeff/clos-guide.html](http://www.aiai.ed.ac.uk/~jeff/clos-guide.html)*)，作为入门资料。
- en: '***Generic Methods with Python***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Python的通用方法***'
- en: Python implements a simpler version of this workflow with the singledispatch()
    function, which has been distributed as part of the functools module since Python
    3.4\. In versions 2.6 to 3.3, the singledispatch() function is provided through
    the Python Package Index; for those eager to try it out, just run pip install
    singledispatch.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过singledispatch()函数实现了这个工作流的简化版本，该函数自Python 3.4以来作为functools模块的一部分提供。在2.6到3.3版本中，singledispatch()函数通过Python包索引提供；对于那些急于尝试的人，只需运行pip
    install singledispatch。
- en: '[Listing 13-4](ch13.xhtml#ch13list4) shows a rough equivalent of the Lisp program
    we built in [Listing 13-2](ch13.xhtml#ch13list2).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 13-4](ch13.xhtml#ch13list4)显示了我们在[Listing 13-2](ch13.xhtml#ch13list2)中构建的Lisp程序的粗略等效版本。'
- en: import functools
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: import functools
- en: 'class SnareDrum(object): pass'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SnareDrum(object): pass'
- en: 'class Cymbal(object): pass'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Cymbal(object): pass'
- en: 'class Stick(object): pass'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Stick(object): pass'
- en: 'class Brushes(object): pass'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Brushes(object): pass'
- en: '@functools.singledispatch'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '@functools.singledispatch'
- en: 'def play(instrument, accessory):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(instrument, accessory):'
- en: raise NotImplementedError("Cannot play these")
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError("无法播放这些")
- en: ➊ @play.register(SnareDrum)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ @play.register(SnareDrum)
- en: 'def _(instrument, accessory):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _(instrument, accessory):'
- en: 'if isinstance(accessory, Stick):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(accessory, Stick):'
- en: return "POC!"
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: return "POC!"
- en: 'if isinstance(accessory, Brushes):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(accessory, Brushes):'
- en: return "SHHHH!"
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: return "SHHHH!"
- en: raise NotImplementedError("Cannot play these")
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError("无法播放这些")
- en: '@play.register(Cymbal)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '@play.register(Cymbal)'
- en: 'def _(instrument, accessory):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _(instrument, accessory):'
- en: 'if isinstance(accessory, Brushes):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(accessory, Brushes):'
- en: return "FRCCCHHT!"
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: return "FRCCCHHT!"
- en: raise NotImplementedError("Cannot play these")
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError("无法播放这些")
- en: '*Listing 13-4: Using singledispatch to dispatch method calls*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-4: 使用singledispatch调度方法调用*'
- en: This listing defines our four classes and a base play() function that raises
    NotImplementedError, indicating that by default we don’t know what to do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表定义了我们的四个类和一个基本的play()函数，抛出NotImplementedError，表明默认情况下我们不知道该怎么做。
- en: We then write a specialized version of the play() function for a specific instrument,
    the SnareDrum ➊. This function checks which accessory type has been passed and
    returns the appropriate sound or raises NotImplementedError again if the accessory
    isn’t recognized.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为特定的乐器编写了一个play()函数的专门版本，这里是SnareDrum ➊。该函数检查传入的配件类型，并返回适当的声音，或者如果配件无法识别，则再次抛出NotImplementedError。
- en: 'If we run the program, it works as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行该程序，它的运行方式如下：
- en: '>>> play(SnareDrum(), Stick())'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> play(SnareDrum(), Stick())'
- en: '''POC!'''
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '''POC!'''
- en: '>>> play(SnareDrum(), Brushes())'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> play(SnareDrum(), Brushes())'
- en: '''SHHHH!'''
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '''SHHHH!'''
- en: '>>> play(Cymbal(), Stick())'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> play(Cymbal(), Stick())'
- en: 'Traceback (most recent call last):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: 'NotImplementedError: Cannot play these'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'NotImplementedError: 无法播放这些'
- en: '>>> play(SnareDrum(), Cymbal())'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> play(SnareDrum(), Cymbal())'
- en: 'NotImplementedError: Cannot play these'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'NotImplementedError: 无法播放这些'
- en: The singledispatch module checks the class of the first argument passed and
    calls the appropriate version of the play() function. For the object class, the
    first defined version of the function is always the one that is run. Therefore,
    if our instrument is an instance of a class that we did not register, this base
    function will be called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: singledispatch模块检查传入的第一个参数的类，并调用相应版本的play()函数。对于对象类，始终运行第一个定义的版本。因此，如果我们的乐器是一个未注册的类的实例，那么将调用这个基本函数。
- en: 'As we saw in the Lisp version of the code, CLOS provides a multiple dispatcher
    that can dispatch based on the type of *any of the arguments* defined in the method
    prototype, not just the first one. The Python dispatcher is named singledispatch
    for a good reason: it only knows how to dispatch based on the first argument.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Lisp 版本的代码中看到的，CLOS 提供了一个多重调度器，可以根据方法原型中*任何一个参数*的类型进行调度，而不仅仅是第一个参数。Python
    的调度器被命名为 `singledispatch` 是有原因的：它只知道如何根据第一个参数进行调度。
- en: In addition, singledispatch offers no way to call the parent function directly.
    There is no equivalent of the Python super() function; you’ll have to use various
    tricks to bypass this limitation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`singledispatch` 没有办法直接调用父函数。没有类似 Python `super()` 函数的功能；你必须使用各种技巧来绕过这个限制。
- en: While Python is improving its object system and dispatch mechanism, it still
    lacks a lot of the more advanced features that something like CLOS provides out
    of the box. That makes encountering singledispatch in the wild pretty rare. It’s
    still interesting to know it exists, as you may end up implementing such a mechanism
    yourself at some point.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 正在改进其对象系统和调度机制，但它仍然缺乏像 CLOS 提供的开箱即用的更高级功能。因此，在实际应用中遇到 `singledispatch`
    的情况比较罕见。了解它的存在仍然很有趣，因为你可能会在某个时候自己实现这种机制。
- en: '**Context Managers**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**上下文管理器**'
- en: The with statement introduced in Python 2.6 is likely to remind old-time Lispers
    of the various with-* macros that are often used in that language. Python provides
    a similar-looking mechanism with the use of objects that implement the *context
    management protocol*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.6 引入的 with 语句可能会让老一辈的 Lispers 想起在该语言中经常使用的各种 with-* 宏。Python 提供了一个类似的机制，通过使用实现了*上下文管理协议*的对象。
- en: If you’ve never used the context management protocol, here’s how it works. The
    code block contained inside the with statement is surrounded by two function calls.
    The object being used in the with statement determines the two calls. Those objects
    are said to implement the context management protocol.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过上下文管理协议，下面是它的工作方式。包含在 with 语句中的代码块被两个函数调用包围。with 语句中使用的对象决定了这两个调用。这些对象被认为实现了上下文管理协议。
- en: 'Objects like those returned by open() support this protocol; that’s why you
    can write code along these lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 像 open() 返回的对象那样的对象支持这种协议；这就是为什么你可以像这样编写代码：
- en: 'with open("myfile", "r") as f:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open("myfile", "r") as f:'
- en: line = f.readline()
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: line = f.readline()
- en: 'The object returned by open() has two methods: one called __enter__ and one
    called __exit__. These methods are called at the start of the with block and at
    the end of it, respectively.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: open() 返回的对象有两个方法：一个叫 `__enter__`，另一个叫 `__exit__`。这两个方法分别在 with 块的开始和结束时被调用。
- en: A simple implementation of a context object is shown in [Listing 13-5](ch13.xhtml#ch13list5).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 13-5](ch13.xhtml#ch13list5) 中展示了一个简单的上下文对象实现。'
- en: 'class MyContext(object):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyContext(object):'
- en: 'def __enter__(self):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __enter__(self):'
- en: pass
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'def __exit__(self, exc_type, exc_value, traceback):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __exit__(self, exc_type, exc_value, traceback):'
- en: pass
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '*Listing 13-5: A simple implementation of a context object*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-5: 一个简单的上下文对象实现*'
- en: This implementation does not do anything, but it is valid and shows the signature
    of the methods that need to be defined to provide a class following the context
    protocol.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现并没有做任何事情，但它是有效的，展示了为了提供遵循上下文协议的类所需要定义的方法签名。
- en: 'The context management protocol might be appropriate to use when you identify
    the following pattern in your code, where it is expected that a call to method
    B must *always* be done after a call to A:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中识别出以下模式时，上下文管理协议可能是适用的：在调用方法 A 后，必须*始终*调用方法 B：
- en: Call method A.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法 A。
- en: Execute some code.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些代码。
- en: Call method B.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法 B。
- en: 'The open() function illustrates this pattern well: the constructor that opens
    the file and allocates a file descriptor internally is method A. The close() method
    that releases the file descriptor corresponds to method B. Obviously, the close()
    function is always meant to be called *after* you instantiate the file object.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: open() 函数很好地说明了这一模式：打开文件并内部分配文件描述符的构造函数是方法 A。释放文件描述符的 close() 方法对应方法 B。显然，close()
    函数总是应该在你实例化文件对象之后调用*。
- en: It can be tedious to implement this protocol manually, so the contextlib standard
    library provides the contextmanager decorator to make implementation easier. The
    contextmanager decorator should be used on a generator function. The __enter__
    and __exit__ methods will be dynamically implemented for you based on the code
    that wraps the yield statement of the generator.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 手动实现这个协议可能很繁琐，因此 contextlib 标准库提供了 contextmanager 装饰器，使得实现变得更加简便。contextmanager
    装饰器应该用于生成器函数。__enter__ 和 __exit__ 方法会根据包装生成器 yield 语句的代码动态实现。
- en: In [Listing 13-6](ch13.xhtml#ch13list6), MyContext is defined as a context manager.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 13-6](ch13.xhtml#ch13list6) 中，MyContext 被定义为一个上下文管理器。
- en: import contextlib
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: import contextlib
- en: '@contextlib.contextmanager'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '@contextlib.contextmanager'
- en: 'def MyContext():'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'def MyContext():'
- en: print("do something first")
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print("做一些事情")
- en: yield
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: yield
- en: print("do something else")
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: print("做其他事情")
- en: 'with MyContext():'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'with MyContext():'
- en: print("hello world")
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: print("hello world")
- en: '*Listing 13-6: Using contextlib.contextmanager*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-6：使用 contextlib.contextmanager*'
- en: 'The code before the yield statement will be executed before the with statement
    body is run; the code after the yield statement will be executed once the body
    of the with statement is over. When run, this program outputs the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: yield 语句之前的代码将在 with 语句体运行之前执行；yield 语句之后的代码将在 with 语句体结束后执行。执行时，这个程序输出如下内容：
- en: do something first
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 做一些事情
- en: hello world
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: hello world
- en: do something else
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 做其他事情
- en: There are a couple of things to handle here though. First, it’s possible to
    yield something inside our generator that can be used as part of the with block.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要处理几个问题。首先，我们的生成器中可能会 yield 一些内容，这些内容可以在 with 代码块中使用。
- en: '[Listing 13-7](ch13.xhtml#ch13list7) shows how to yield a value to the caller.
    The keyword as is used to store this value in a variable.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-7](ch13.xhtml#ch13list7) 展示了如何将一个值返回给调用者。关键字 as 用于将这个值存储在一个变量中。'
- en: import contextlib
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: import contextlib
- en: '@contextlib.contextmanager'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '@contextlib.contextmanager'
- en: 'def MyContext():'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'def MyContext():'
- en: print("do something first")
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: print("做一些事情")
- en: yield 42
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: yield 42
- en: print("do something else")
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: print("做其他事情")
- en: 'with MyContext() as value:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'with MyContext() as value:'
- en: print(value)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: print(value)
- en: '*Listing 13-7: Defining a context manager yielding a value*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-7：定义一个返回值的上下文管理器*'
- en: '[Listing 13-7](ch13.xhtml#ch13list7) shows how to yield a value to the caller.
    The keyword as is used to store this value in a variable. When executed, the code
    outputs the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-7](ch13.xhtml#ch13list7) 展示了如何将一个值返回给调用者。关键字 as 用于将这个值存储在一个变量中。执行时，代码输出如下内容：'
- en: do something first
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 做一些事情
- en: '42'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: do something else
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 做其他事情
- en: When using a context manager, you might need to handle exceptions that can be
    raised within the with code block. This can be done by surrounding the yield statement
    with a try...except block, as shown in [Listing 13-8](ch13.xhtml#ch13list8).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上下文管理器时，你可能需要处理在 with 代码块中可能引发的异常。这可以通过将 yield 语句包裹在 try...except 块中来实现，如
    [示例 13-8](ch13.xhtml#ch13list8) 所示。
- en: import contextlib
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: import contextlib
- en: '@contextlib.contextmanager'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '@contextlib.contextmanager'
- en: 'def MyContext():'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'def MyContext():'
- en: print("do something first")
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: print("做一些事情")
- en: 'try:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: yield 42
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: yield 42
- en: 'finally:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'finally:'
- en: print("do something else")
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print("做其他事情")
- en: 'with MyContext() as value:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'with MyContext() as value:'
- en: print("about to raise")
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: print("即将引发")
- en: ➊     raise ValueError("let's try it")
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     引发 ValueError("让我们试试看")
- en: print(value)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: print(value)
- en: '*Listing 13-8: Handling exceptions in a context manager*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-8：在上下文管理器中处理异常*'
- en: Here, a ValueError is raised at the beginning of the with code block ➊; Python
    will propagate this error back to the context manager, and the yield statement
    will appear to raise the exception itself. We enclose the yield statement in try
    and finally to make sure the final print() is run.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，在 with 代码块的开始处引发了一个 ValueError ➊；Python 会将这个错误传播回上下文管理器，yield 语句看起来像是引发了这个异常。我们将
    yield 语句包裹在 try 和 finally 中，以确保最终的 print() 被执行。
- en: 'When executed, [Listing 13-8](ch13.xhtml#ch13list8) outputs the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，[示例 13-8](ch13.xhtml#ch13list8) 输出如下内容：
- en: do something first
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 做一些事情
- en: about to raise
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 即将引发
- en: do something else
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 做其他事情
- en: 'Traceback (most recent call last):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 3, in <module>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 3 行，在 <module>
- en: 'ValueError: let''s try it'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: 让我们试试看'
- en: As you can see, the error is raised back to the context manager, and the program
    resumes and finishes execution because it ignored the exception using a try...finally
    block.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，错误被传递回上下文管理器，程序恢复并完成执行，因为它通过 try...finally 块忽略了异常。
- en: In some contexts, it can be useful to use several context managers at the same
    time, for example, when opening two files at the same time to copy their content,
    as shown in [Listing 13-9](ch13.xhtml#ch13list9).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，同时使用多个上下文管理器是有用的，例如，当同时打开两个文件来复制它们的内容时，如[示例 13-9](ch13.xhtml#ch13list9)所示。
- en: 'with open("file1", "r") as source:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with open("file1", "r") as source:`：
- en: 'with open("file2", "w") as destination:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with open("file2", "w") as destination:`：
- en: destination.write(source.read())
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: destination.write(source.read())
- en: '*Listing 13-9: Opening two files at the same time to copy content*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-9：同时打开两个文件以复制内容*'
- en: That being said, since the with statement supports multiple arguments, it’s
    actually more efficient to write a version using a single with, as shown in [Listing
    13-10](ch13.xhtml#ch13list10).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，由于with语句支持多个参数，实际上使用一个单独的with语句会更高效，如[示例 13-10](ch13.xhtml#ch13list10)所示。
- en: 'with open("file1", "r") as source, open("file2", "w") as destination:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with open("file1", "r") as source, open("file2", "w") as destination:`：
- en: destination.write(source.read())
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: destination.write(source.read())
- en: '*Listing 13-10: Opening two files at the same time using only one with statement*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-10：仅使用一个 with 语句同时打开两个文件*'
- en: Context managers are extremely powerful design patterns that help to ensure
    your code flow is always correct, no matter what exception might occur. They can
    help to provide a consistent and clean programming interface in many situations
    in which code should be wrapped by other code and contextlib.contextmanager.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是非常强大的设计模式，它有助于确保无论发生什么异常，你的代码流始终正确。它们能在许多场合提供一致且清晰的编程接口，这些场合中代码应当被其他代码所包装，并且使用contextlib.contextmanager。
- en: '**Less Boilerplate with attr**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 attr 减少模板代码**'
- en: Writing Python classes can be cumbersome. You’ll often find yourself repeating
    just a few patterns because there are no other options. One of the most common
    examples, as illustrated in [Listing 13-11](ch13.xhtml#ch13list11), is when initializing
    an object with a few attributes passed to the constructor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Python 类可能会很繁琐。你经常会发现自己只是在重复一些固定的模式，因为没有其他选项。最常见的例子之一，如[示例 13-11](ch13.xhtml#ch13list11)所示，就是在初始化一个对象时，通过构造函数传入几个属性。
- en: 'class Car(object):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car(object):'
- en: 'def __init__(self, color, speed=0):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, color, speed=0):'
- en: self.color = color
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = color
- en: self.speed = speed
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: self.speed = speed
- en: '*Listing 13-11: Common class initialization boilerplate*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-11：常见的类初始化模板*'
- en: 'The process is always the same: you copy the value of the argument passed to
    the __init__ function to a few attributes stored in the object. Sometimes you’ll
    also have to check the value that is passed, compute a default, and so on.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程始终是一样的：你将传递给`__init__`函数的参数值复制到对象中存储的几个属性中。有时你还需要检查传入的值，计算默认值，等等。
- en: Obviously, you also want your object to be represented correctly if printed,
    so you’ll have to implement a __repr__ method. There’s a chance some of your classes
    are simple enough to be converted to dictionaries for serialization. Things become
    even more complicated when talking about comparison and hashability (the ability
    to use hash on an object and store it in a set).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果要打印你的对象时正确显示，你还需要实现一个__repr__方法。如果你的某些类足够简单，可能可以将它们转换为字典进行序列化。当涉及到比较和哈希性（能够在对象上使用哈希并将其存储在集合中）时，事情变得更加复杂。
- en: In reality, most Python programmers do none of this, because the burden of writing
    all those checks and methods is too heavy, especially when you’re not always sure
    you’ll need them. For example, you might find that __repr__ is useful in your
    program only that one time you’re trying to debug or trace it and decide to print
    objects in the standard output—and no other times.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数 Python 程序员都不会这么做，因为编写所有这些检查和方法的负担太重，特别是在你并不总是确定是否需要它们的情况下。例如，你可能会发现，__repr__
    在你的程序中只在调试或追踪时才有用，并且只会打印对象一次，并没有其他时间需要使用它。
- en: The attr library aims for a straightforward solution by providing a generic
    boilerplate for all your classes and generating much of the code for you. You
    can install attr using pip with the command pip install attr. Get ready to enjoy!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: attr 库通过为你的所有类提供通用的模板并为你生成大量代码，旨在提供一个简单的解决方案。你可以使用命令`pip install attr`安装 attr。准备好享受吧！
- en: Once installed, the attr.s decorator is your entry point into the wonderful
    world of attr. Use it above a class declaration and then use the function attr.ib()
    to declare attributes in your classes. [Listing 13-12](ch13.xhtml#ch13list12)
    shows a way to rewrite [Listing 13-11](ch13.xhtml#ch13list11) using attr.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，`attr.s` 装饰器是你进入 attr 神奇世界的入口。将它应用在类声明之上，然后使用 `attr.ib()` 函数在你的类中声明属性。[清单
    13-12](ch13.xhtml#ch13list12) 展示了如何使用 attr 重写[清单 13-11](ch13.xhtml#ch13list11)。
- en: import attr
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: import attr
- en: '@attr.s'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '@attr.s'
- en: 'class Car(object):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car(object):'
- en: color = attr.ib()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: color = attr.ib()
- en: speed = attr.ib(default=0)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: speed = attr.ib(default=0)
- en: '*Listing 13-12: Using attr.ib() to declare attributes*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-12: 使用 `attr.ib()` 声明属性*'
- en: 'When declared this way, the class automatically gains a few useful methods
    for free, such as __repr__, which is called to represent objects when they are
    printed on stdout in the Python interpreter:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明时，类自动获得一些有用的方法，比如 `__repr__`，该方法在 Python 解释器中打印对象时被调用：
- en: '>>> Car("blue")'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Car("blue")'
- en: Car(color='blue', speed=0)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Car(color='blue', speed=0)
- en: 'This output is cleaner than the default that __repr__ would have printed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出比 `__repr__` 默认打印的要干净：
- en: <__main__.Car object at 0x104ba4cf8>.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.Car object at 0x104ba4cf8>.
- en: You can also add more validation on your attributes by using the validator and
    converter keyword arguments.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用验证器和转换器关键字参数来为你的属性添加更多验证。
- en: '[Listing 13-13](ch13.xhtml#ch13list13) shows how the attr.ib() function can
    be used to declare an attribute with some constraints.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-13](ch13.xhtml#ch13list13) 展示了如何使用 `attr.ib()` 函数声明带有某些约束的属性。'
- en: import attr
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: import attr
- en: '@attr.s'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '@attr.s'
- en: 'class Car(object):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car(object):'
- en: color = attr.ib(converter=str)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: color = attr.ib(converter=str)
- en: speed = attr.ib(default=0)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: speed = attr.ib(default=0)
- en: '@speed.validator'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '@speed.validator'
- en: 'def speed_validator(self, attribute, value):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'def speed_validator(self, attribute, value):'
- en: 'if value < 0:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'if value < 0:'
- en: raise ValueError("Value cannot be negative")
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError("值不能为负")
- en: '*Listing 13-13: Using attr.ib() with its converter argument*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-13: 使用 attr.ib() 和其转换器参数*'
- en: The converter argument manages the conversion of whatever is passed to the constructor.
    The validator() function can be passed as an argument to attr.ib() or used as
    a decorator, as shown in [Listing 13-13](ch13.xhtml#ch13list13).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器参数负责管理传递给构造函数的值的转换。`validator()` 函数可以作为参数传递给 `attr.ib()`，也可以用作装饰器，如[清单 13-13](ch13.xhtml#ch13list13)所示。
- en: The attr module provides a few validators of its own (for example, attr.validators.instance_of()
    to check the type of the attribute), so be sure to check them out before wasting
    your time building your own.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: attr 模块提供了一些自己的验证器（例如，`attr.validators.instance_of()` 用于检查属性类型），所以在自己编写验证器之前，最好先检查这些内置的。
- en: 'The attr module also provides tweaks to make your object hashable so it can
    be used in a set or a dictionary key: just pass frozen=True to attr.s() to make
    the class instances immutable.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: attr 模块还提供了一些调整，使你的对象可以哈希，从而可以在集合或字典键中使用：只需将 frozen=True 传递给 `attr.s()`，使类实例不可变。
- en: '[Listing 13-14](ch13.xhtml#ch13list14) shows how using the frozen parameter
    changes the behavior of the class.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-14](ch13.xhtml#ch13list14) 展示了使用 frozen 参数如何改变类的行为。'
- en: '>>> import attr'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import attr'
- en: '>>> @attr.s(frozen=True)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> @attr.s(frozen=True)'
- en: '... class Car(object):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '... class Car(object):'
- en: '...     color = attr.ib()'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '...      color = attr.ib()'
- en: '...'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> {Car("blue"), Car("blue"), Car("red")}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {Car("blue"), Car("blue"), Car("red")}'
- en: '{Car(color=''red''), Car(color=''blue'')}'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '{Car(color=''red''), Car(color=''blue'')}'
- en: '>>> Car("blue").color = "red"'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Car("blue").color = "red"'
- en: attr.exceptions.FrozenInstanceError
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: attr.exceptions.FrozenInstanceError
- en: '*Listing 13-14: Using frozen=True*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-14: 使用 frozen=True*'
- en: '[Listing 13-14](ch13.xhtml#ch13list14) shows how using the frozen parameter
    changes the behavior of the Car class: it can be hashed and therefore stored in
    a set, but objects cannot be modified anymore.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-14](ch13.xhtml#ch13list14) 展示了使用 frozen 参数如何改变 Car 类的行为：它可以被哈希，因此可以存储在集合中，但对象不再可修改。'
- en: In summary, attr provides the implementation for a ton of useful methods, thereby
    saving you from writing them yourself. I highly recommend leveraging attr for
    its efficiency when building your classes and modeling your software.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，attr 提供了大量有用的方法实现，帮助你省去了自己编写的麻烦。在构建类和建模软件时，我强烈推荐利用 attr 提高效率。
- en: '**Summary**'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Congratulations! You made it to the end of the book. You’ve just upped your
    Python game and have a better idea of how to write efficient and productive Python
    code. I hope you enjoyed reading this book as much as I enjoyed writing it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经读完了这本书。你提升了你的 Python 技能，对如何编写高效且富有生产力的 Python 代码有了更清晰的理解。我希望你读这本书的体验和我写这本书时一样愉快。
- en: Python is a wonderful language and can be used in many different fields, and
    there are many more areas of Python that we did not touch on in this book. But
    every book needs an ending, right?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一门非常棒的语言，可以应用于许多不同的领域，而且在这本书中我们没有涉及到 Python 的许多其他领域。不过每本书都需要一个结尾，对吧？
- en: I highly recommend profiting from open source projects by reading the available
    source code out there and contributing to it. Having your code reviewed and discussed
    by other developers is often a great way to learn.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐通过阅读现有的开源项目源代码并贡献其中的内容来从中获益。让其他开发者审查和讨论你的代码往往是学习的好方法。
- en: Happy hacking!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你编程愉快！
