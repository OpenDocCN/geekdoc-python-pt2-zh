- en: '**21'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MANAGING DATES AND TIMES WITH PYTHON AND PANDAS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In mathematics, a *time series* is a series of data points indexed in chronological
    order. They are common components in scientific datasets where observations are
    made over periods of time.
  prefs: []
  type: TYPE_NORMAL
- en: Although you and I recognize “11/11/1918” as a date, a computer sees this value
    as a string. To intelligently work with calendar dates as well as hours, minutes,
    seconds, and so on, Python and pandas treat them as special objects. These objects
    are “aware” of the mechanics of the Gregorian calendar, the sexagesimal (base
    60) time system, time zones, daylight-saving time, leap years, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Native Python supports times series through its `datetime` module, and pandas
    is oriented toward using arrays of dates, such as for an index or column in a
    DataFrame. In addition to its built-in tools and algorithms for working with both
    fixed-frequency and irregular time series, pandas also uses the `datetime` module.
    Observations in *fixed frequency* time series are those recorded at regular intervals
    such as once a day. Otherwise, the time series is said to be *irregular* in nature.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at both the Python and pandas approaches here, with the goal of introducing
    you to the basics of working with time series and making you conversant in the
    subject. For more detail, you can visit *[https://docs.python.org/3/library/datetime.html](https://docs.python.org/3/library/datetime.html)*
    for Python’s `datetime` module and *[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)*
    for the pandas tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python datetime Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s built-in `datetime` module includes the `date`, `time`, and combined
    `datetime` types. By treating time information as specific data types, Python
    knows how to manipulate it properly and efficiently. This includes working with
    time zones, daylight saving time (DST), leap years, and different international
    formatting methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this brief introduction, we’ll look at marking time series data with *timestamps*,
    for specific time instants; time *intervals*, delineated by a starting and ending
    timestamp; and fixed *periods*, such as a year. You can keep track of *elapsed*
    time, too, such as the time relative to the start of an experiment. We’ll also
    look at converting `datetime` objects to strings and back again.
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting the Current Date and Time***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `datetime.now()` method returns the current date and time based on your
    computer’s clock. In an environment where you have NumPy, pandas, and Matplotlib
    installed, start the Jupyter Qt console and enter the following (you will see
    a different date, for obvious reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `now()` method returns dates in ISO 8601 format (year-month-day). ISO 8601
    is the global standard format for numeric dates.
  prefs: []
  type: TYPE_NORMAL
- en: The `now` variable represents the `datetime` data type. Other types for storing
    date and time information are shown in [Table 20-1](ch20.xhtml#ch020tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-1:** Data Types in the Python `datetime` Module'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Datatype** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `date` | Gregorian calendar date in year, month, day format |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | Combined `date` and `time` types |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | Twenty-four-hour (military) time in hours, minutes, seconds, and
    microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `timedelta` | Difference between two `datetime` objects in days, seconds,
    and microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `tzinfo` | Time zone information |'
  prefs: []
  type: TYPE_TB
- en: 'To access `date` and `time` data in the `now` object, or any other timestamp,
    use its `datetime` attributes, called with dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the `date` and `time` *objects*, call `datetime` methods with the
    same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '***Assigning Timestamps and Calculating Time Delta***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To assign a timestamp to a variable, pass `datetime()` the date and time in
    the year-month-day-hour-minute-second-microsecond format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To view it as a string, pass the variable to Python’s built-in `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re not interested in time data, just pass `datetime()` the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A `timedelta` object represents a *duration*, or the difference between two
    dates or times. Subtracting two `datetime` objects yields the elapsed time. To
    demonstrate, let’s calculate Python creator Guido van Rossum’s age on October
    28, 2022:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you include both date and time information, the `timedelta` object will
    present days, seconds, and microseconds, which are the only units stored internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `timedelta` object supports arithmetic operations like addition, subtraction,
    multiplication, division, modulus, and more. To see the complete list of supported
    operations, visit *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Timedelta.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Timedelta.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Formatting Dates and Times***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve seen, the datetime output isn’t very human friendly. Converting it
    to a string using the `str()` function helps, but you can accomplish even more
    by using the `datetime` `strftime()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `strftime()` method uses C programming language (ISO C89)–compatible specifications,
    or *directives*, preceded by the `%` sign. Some of the most useful directives
    are listed in [Table 21-2](ch21.xhtml#ch021tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-2:** Selected `Datetime` Format Specifications'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive** | **Description** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| %a | Weekday as abbreviated name | Sun, So, Mon, Mo, Sat, Sa |'
  prefs: []
  type: TYPE_TB
- en: '| %A | Weekday as full name | Sunday, Sonntag |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Two-digit weekday | 01, 02, . . ., 05 |'
  prefs: []
  type: TYPE_TB
- en: '| %b | Month as abbreviated name | Jan, Feb, Dec, Dez |'
  prefs: []
  type: TYPE_TB
- en: '| %B | Month as full name | February, Februar |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Two-digit month | 01, 02, . . ., 31 |'
  prefs: []
  type: TYPE_TB
- en: '| `%y` | Two-digit year | 00, 01, . . ., 99 |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Year with century as a decimal number | 0001, . . . 2022, . . . 9999
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Twenty-four-hour clock hour | 01, 02, . . ., 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `%I` | Twelve-hour clock hour | 01, 02, . . ., 12 |'
  prefs: []
  type: TYPE_TB
- en: '| %p | AM or PM | AM, am, PM, pm |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Two-digit minute | 01, 02, . . ., 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | Two-digit second (60, 61 account for leap seconds) | 01, 02, . . .,
    59 |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Microsecond as decimal number (zero-padded six digits) | 000000, 000001,
    . . ., 999999 |'
  prefs: []
  type: TYPE_TB
- en: '| `%w` | Integer weekday with 0 for Sunday | 0, 1, . . ., 6 |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | Week number of year (Monday = 1st day of week; days before 1st Monday
    are week 0) | 00, 01, . . . 53 |'
  prefs: []
  type: TYPE_TB
- en: '| `%U` | Week number of year (Sunday = 1st day of week; days before 1st Sunday
    are week 0) | 00, 01, . . . 53 |'
  prefs: []
  type: TYPE_TB
- en: '| `%Z` | Time zone name (empty is naive object) | (empty), UTC, GMT |'
  prefs: []
  type: TYPE_TB
- en: '| %c | Appropriate date and time representation for locale | Wed Mar 30 09:14:12
    2022 |'
  prefs: []
  type: TYPE_TB
- en: '| %x | Appropriate date representation for locale | 07/31/1984, 31.07.1984
    |'
  prefs: []
  type: TYPE_TB
- en: '| %X | Appropriate time representation for locale | 13:30:15 |'
  prefs: []
  type: TYPE_TB
- en: '| `%F` | Shortcut for `%Y-%m-%d` format | 2022-03-30 |'
  prefs: []
  type: TYPE_TB
- en: '| `%D` | Shortcut for `%m/%d/%y` format | 03/30/22 |'
  prefs: []
  type: TYPE_TB
- en: '| Bold = locale-specific date formatting |'
  prefs: []
  type: TYPE_TB
- en: 'In the console, enter the following to see some example formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can find more formatting directives at *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Period.strftime.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Period.strftime.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Strings to Dates and Times***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, you might need to import date and time information from a file rather
    than creating it yourself. If the input data is in string format, you’ll need
    to convert the strings into dates. This is basically the opposite of the operation
    we performed in the previous section, and you can do this using either the `dateutil.parser.parse()`
    method or the `datetime.strptime()` method. The third-party `dateutil` date utility
    package extends the `datetime` module and is automatically installed with pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'For common `datetime` formats, use the `parse()` method for convenience. In
    the console, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parse()` method can handle most date representations. If you enter the
    month before the day, as in the US, it will honor this convention in the `datetime`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For locales where the day comes before the month, set the `dayfirst` argument
    to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at a real-world example. Suppose that you’ve recorded, by date,
    the type of animal captured in a trail camera. You’ve loaded the data as a list
    and want to replace the dates in string format with `datetime` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we made a copy (`date_dt`) of the initial data list and then
    looped through the `data` list using the built-in `enumerate()` function to get
    both the item in the list and its index. If the index is an even number, which
    corresponds to the locations of the dates, we parsed the date at that location
    in the `data_dt` list. Now we have the original data plus a version for which
    the dates are `datetime` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `parse()` is useful for common, known date formats, it can’t handle
    every situation. For edge cases, you’ll need to use the `datetime` module’s `strptime()`
    method and pass it the proper format specification. For example, Suppose that
    your lab assistant input a bunch of dates using an underscore to separate the
    date components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parse()` method is unable to recognize this format and will raise an error
    (`ParserError: Unknown string format: 2022_10_31`). To handle this nonstandard
    format, use `strptime()` with directives from [Table 21-2](ch21.xhtml#ch021tab2).
    Be sure to place the underscores in the same relative position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `parse()`, you can convert a sequence of dates using `strptime()`.
    Here’s an example using list comprehension, in place of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For more on the `dateutil` package, visit *[https://pypi.org/project/python-dateutil](https://pypi.org/project/python-dateutil)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting with datetime Objects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Plotting dates can be messy due to the tendency of long date labels to overlap.
    In addition, standard plotting defaults don’t consider proper time intervals when
    displaying ticks. To see an example using Matplotlib, in the console, enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This produces the unreadable results in [Figure 21-1](ch21.xhtml#ch021fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-1: Overlapping date labels on the x-axis*'
  prefs: []
  type: TYPE_NORMAL
- en: To handle dates when plotting, you must inform Matplotlib that it’s dealing
    with `datetime` objects by importing the `matplotlib`.`dates` module. This specialized
    module is built on the `datetime` and third-party `dateutil` modules. Among its
    sophisticated plotting capabilities, it helps you define time scales using *locator*
    methods, which find and comprehend the types of dates you’re using, such as months
    and years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rebuild the previous plot using `matplotlib.dates`. Remember to use CTRL-ENTER
    to prevent early execution when entering the code in line `In [48]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This produces the results in [Figure 21-2](ch21.xhtml#ch021fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-2: A properly formatted plot of dates*'
  prefs: []
  type: TYPE_NORMAL
- en: The date labels are now readable and, if your eyesight is good enough, you’ll
    be able to count the proper number of tick marks for each day of the month. Locator
    functions are also available for other units such as hours, minutes, seconds,
    and weekdays. To learn more, visit the module documentation at *[https://matplotlib.org/stable/api/dates_api.html](https://matplotlib.org/stable/api/dates_api.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Naive vs. Aware Objects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python `datetime` objects may be categorized as either *naive* or *aware* depending
    on whether they include time zone information. A naive object does not contain
    time zone information and can’t locate itself relative to other `datetime` objects.
    With knowledge of metadata such as time zone and DST information, an aware object
    represents a specific and unambiguous moment in time that can be located with
    respect to other aware objects.
  prefs: []
  type: TYPE_NORMAL
- en: To generate an aware object, `datetime` and `time` objects have an optional
    time zone attribute, `tzinfo`, that is used to capture information about the offset
    from the *coordinated universal time (UTC)*, the time zone name, and whether DST
    is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: UTC is the successor to Greenwich Mean Time (GMT) and represents the primary
    time standard by which the world regulates clocks and time. Precision is usually
    in milliseconds, but submicrosecond precision is possible when using satellite
    signals. UTC does not change with the seasons, nor is it affected by DST. By working
    in UTC, you can confidently share your work and remove the need for fiddly time
    zone and similar corrections.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s possible for the `tzinfo` attribute to hold detailed, country-specific
    time zone information, the `datetime` module’s `timezone` class can represent
    only simple time zones with fixed offsets from UTC, such as UTC itself or North
    American EST and EDT time zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access more detailed time zone information, you can use the third-party
    `pytz` library (*[https://pypi.org/project/pytz/](https://pypi.org/project/pytz/)*),
    which is wrapped by pandas. To make an aware timestamp, import `pytz` and pass
    the `datatime` method the `pytz` library’s name for a time zone. You can find
    these names using the `common_timezones` attribute, shown here sliced to the last
    10 items in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s make an *aware* timestamp in UTC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `aware` timestamp has time zone metadata (`tzinfo=<UTC>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert an existing unaware timestamp to an aware timestamp, call the `localize()`
    method on the `pytz` time zone and pass the method the `datetime` object, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert from one time zone to another, you can use the `astimezone()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `pytz` library will consider the idiosyncrasies of your local area, such
    as DST, when making the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because naive datetime objects are treated by many datetime methods as local
    times, it’s preferable to use aware datetimes to represent times in UTC. As such,
    the recommended way to create an object representing the current time in UTC is
    by calling datetime.now(timezone.utc).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Which date is written in the global standard numeric date format?
  prefs: []
  type: TYPE_NORMAL
- en: a.  23-2-2021
  prefs: []
  type: TYPE_NORMAL
- en: b.  2021-2-23
  prefs: []
  type: TYPE_NORMAL
- en: c.  2-23-2021
  prefs: []
  type: TYPE_NORMAL
- en: d.  23/2/21
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Which methods convert a string representation of a date into a `datetime`
    object?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `strftime()`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `str()`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `strptime()`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `parse()`
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Which directive produces the format `'03/30/2022 21:09'`?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `'%m/%d/%y %H:%M'`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `'%M/%D/%Y %H:%m'`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `'%m/%d/%Y %H:%M'`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `'%m/%d/%y %H:%M'`
  prefs: []
  type: TYPE_NORMAL
- en: 4.  What is the global time standard?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `pytz`
  prefs: []
  type: TYPE_NORMAL
- en: b.  US/Eastern
  prefs: []
  type: TYPE_NORMAL
- en: c.  UTC
  prefs: []
  type: TYPE_NORMAL
- en: d.  GMT
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Which method lets you convert naive `datetime` objects to a new time zone?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `mdates()`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `parse()`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `timedelta()`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `localize()`
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Series and Date Functionality with pandas**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might expect, pandas has extensive capabilities for working with time
    series. This functionality is based on the NumPy `datetime64` and `timedelta64`
    data types with nanosecond resolution. In addition, features have been consolidated
    from many other Python libraries, and new functionality has been developed. With
    pandas, you can load time series; convert data to the proper `datetime` format;
    generate ranges of datetimes; index, merge, and resample both fixed- and irregular-frequency
    data; and more.
  prefs: []
  type: TYPE_NORMAL
- en: The pandas library uses four general time-related concepts. These are date times,
    time deltas, time spans, and date offsets ([Table 21-3](ch21.xhtml#ch021tab3)).
    Except for date offsets, each time concept has a *scalar* class, for single observations,
    along with an associated *array* class, which serves as an index structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-3:** Time-Related Concepts in pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **Scalar class** | **Array class** | **Data type** | **Creation
    method** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Date times | `Timestamp` | `DatetimeIndex` | `datetime64[ns]``datetime64[ns,
    tz]` | `to_datetime` or`date_range` |'
  prefs: []
  type: TYPE_TB
- en: '| Time deltas | `Timedelta` | `TimedeltaIndex` | `timedelta64[ns]` | `to_timedelta`
    or`timedelta_range` |'
  prefs: []
  type: TYPE_TB
- en: '| Time spans | `Period` | `PeriodIndex` | `period[freq]` | `Period` or`period_range`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Date offsets | `DateOffset` | None | None | `Dateoffset` |'
  prefs: []
  type: TYPE_TB
- en: A *date time* represents a specific date and time with time zone support. It’s
    similar to `datetime.datetime` from the Python standard library. A *time delta*
    is an absolute time duration, similar to `datetime.timedelta` from the standard
    library. *Time spans* are a period defined by a point in time and its associated
    frequency (daily, monthly, and so on). A *date offset* represents a relative time
    duration that respects calendar arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we’ll look at these various concepts and the methods
    used to create them. For more detail, you can visit the official documentation
    at *[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Parsing Time Series Information***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a timestamp representing the time for a particular event, use the
    `Timestamp` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, to create a `DatetimeIndex` object, use the `DatetimeIndex` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For existing data, the pandas `to_datetime()` method converts scalar, array-like,
    dictionary-like, and pandas series or DataFrame objects to pandas `datetime64[ns]`
    objects. This lets you easily parse time series information from various sources
    and formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what I’m talking about, in the console, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we passed a list of dates in three different formats to the
    `to_datetime()` method. These included a string, a NumPy `datetime64` object,
    and a Python `datetime` object. The method returned a pandas `DatetimeIndex` object
    that consistently stores the dates as `datetime64[ns]` objects in ISO 8601 format
    (year-month-day).
  prefs: []
  type: TYPE_NORMAL
- en: 'The method can accommodate times as well as dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we passed a list of both dates and times, which were all correctly
    converted. Note that we included an empty item (`''`) at the end of the list.
    The `to_datetime()` method converted this entry into a `NaT` (Not a Time) value,
    which is the timestamp equivalent of the pandas `NaN` (Not a Number) value that
    you learned about in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `to_datetime()` method also works with pandas DataFrames. Let’s look at
    an example in which you have recorded (in Microsoft Excel) the date and time a
    trail camera captured an image of an animal. You’ve exported the spreadsheet as
    a .*csv* file that you now want to load and parse using pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the .*csv* file, in a text editor such as Notepad or TextEdit, enter
    the following and then save it as *camera_1.csv*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the console, enter the following to read the file in as a DataFrame
    (substitute your path to the .*csv* file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert the `Date` column to ISO 8601 format, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These datetimes were recorded in the Eastern US time zone, but that information
    is not encoded. To make the datetimes aware, first make the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, assign a variable to a `pytz tzfile` object and then pass the variable
    to the `localize()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do all this in one line, but using a `my_tz` variable makes the code
    more readable and less likely to wrap. To check the results, print the `Date`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though it’s a good idea to work in UTC, it’s also important to have *meaningful*
    time data. For example, you’ll probably want to study when these animals are on
    the prowl in *local* time, so you’ll want to preserve the times recorded in the
    Eastern US. In this case, you’ll want to make a new “UTC-aware” column based on
    the `Date` column so that you can have the best of both worlds. Because the `Date`
    column is now aware of its time zone, you must use `tz_convert()` instead of `tz_localize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the columns to verify the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To remove time zone information from a datetime so that it becomes naive,
    pass the tz_convert() method None, like so: csv_df[''Date''] = csv_df[''Date'']`.`dt.tz_convert(None).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you look at the previous printout of the `csv_df` DataFrame, you’ll
    see that the index values range from 0 to 2\. This is by default, but there’s
    no reason why you can’t use `datetime` values as the index instead. In fact, `datetime`
    indexes can be helpful when doing things like plotting. So, let’s make the `Date_UTC`
    column the index for the DataFrame. In the console, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To read more about the `to_datetime()` method, visit *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html)*.
    You can find the documentation for `dt.tz_localize()` and `dt.tz_convert()` at
    *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_localize.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_localize.html)*
    and *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_convert.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_convert.html)*,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Date Ranges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Time series with a *fixed* frequency occur often in science for jobs as diverse
    as sampling waveforms in signal processing, observing target behaviors in psychology,
    recording stock market movements in economics, and logging traffic flow in transportation
    engineering. Not surprisingly, pandas ships with many standardized frequencies
    and tools that generate them, resample them, and infer them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pandas `date_range()` method returns a `DatetimeIndex` object with a fixed
    frequency. To generate an index composed of days, pass it a start and end date,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass it either a start date or an end date, along with the number
    of periods to generate (such as a number of days). In the following example, we
    start with a timestamp for a certain observation and ask for six periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the six datetimes represent days starting at 12:59:59\. Normally,
    you want the days to start at midnight, so, pandas provides a handy `normalize`
    parameter to make this adjustment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After they’re normalized to days, the output `datetime64` objects no longer
    include a time component.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `date_range()` method assumes that you want a *daily* frequency.
    Other frequencies are available, however, with many designed for business applications
    (such as the end of a business month, end of a business year, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 21-4](ch21.xhtml#ch021tab4) lists some of the time series frequencies
    more relevant for science. For the complete list, including financial frequencies,
    see “DateOffset objects” at *[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-4:** Useful Time Series Frequencies'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Freq string** | **Offset type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | `Nano` | By nanosecond |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | `Micro` | By microsecond |'
  prefs: []
  type: TYPE_TB
- en: '| `L or ms` | `Milli` | By millisecond |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | `Second` | By second |'
  prefs: []
  type: TYPE_TB
- en: '| `T or min` | `Minute` | By minute |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | `Hour` | By hour |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | `Day` | By calendar day |'
  prefs: []
  type: TYPE_TB
- en: '| `W-MON, W-TUE,` . . . | `Week` | Weekly, optionally anchored on a day of
    the week |'
  prefs: []
  type: TYPE_TB
- en: '| `MS` | `MonthBegin` | By first calendar day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | `MonthEnd` | By last calendar day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `Q` | `Quarter` | By quarter year |'
  prefs: []
  type: TYPE_TB
- en: '| `AS-JAN, AS-FEB,` . . . | `YearBegin` | Yearly, anchored on first calendar
    day of given month |'
  prefs: []
  type: TYPE_TB
- en: '| `A-JAN, A-FEB,` . . . | `YearEnd` | Yearly, anchored on last calendar day
    of given month |'
  prefs: []
  type: TYPE_TB
- en: 'To specify an offset type, pass a frequency string alias from [Table 21-4](ch21.xhtml#ch021tab4)
    as the `freq` argument. You can also specify a time zone using the `tz` argument.
    Here’s how to make an hourly frequency referenced to UTC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For an existing time series, you can retrieve its frequency by using the `freq`
    attribute, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The frequencies shown in [Table 21-4](ch21.xhtml#ch021tab4) represent *base*
    frequencies. Think of these as building blocks for alternative frequencies, such
    as bi-hourly. To make this new frequency, just place the integer `2` before the
    `H` in the `freq` argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine offsets by passing frequency strings like `''2H30min''`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '***Creating Periods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Timestamps associate data with points in time. Sometimes, however, data remains
    constant through a certain *time span*, such as a month, and you want to associate
    the data with that interval.
  prefs: []
  type: TYPE_NORMAL
- en: In pandas, regular intervals of time such as a day, month, year, and so on are
    represented by `Period` objects. With the `period_range()` method, `Period` objects
    can be collected into a sequence to form a `PeriodIndex`. You can specify a period’s
    time span using the `freq` keyword with frequency aliases from [Table 21-4](ch21.xhtml#ch021tab4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to keep track of a daily observation for the month of
    September 2022\. First, use the `period_range()` method to create a time span
    with a frequency of days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a pandas series and use the NumPy `random.randn()` method to generate
    some fake data on the fly. Note that the number of data points must equal the
    number of days in the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You now have a time series, organized by day, for the month of September.
  prefs: []
  type: TYPE_NORMAL
- en: 'To shift a period by its own frequency, just add or subtract an integer. Here’s
    an example using a yearly time span:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using a frequency of `'A-DEC'` means that each year represents January 1 through
    December 31\. Adding `10` shifted the periods up by 10 years. You can only perform
    arithmetic in this manner between `Period` objects with the *same* frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of making monthly periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `asfreq()` method, you can convert an existing period to another frequency.
    Here’s an example in which we convert the `month_index` variable’s period to hours,
    anchored on the first hour of each month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To read more about the pandas `Period` class and the `asfreq()` method, visit
    *[https://pandas.pydata.org/docs/reference/api/pandas.Period.html](https://pandas.pydata.org/docs/reference/api/pandas.Period.html)*
    and *[https://pandas.pydata.org/docs/reference/api/pandas.Period.asfreq.html](https://pandas.pydata.org/docs/reference/api/pandas.Period.asfreq.html)*,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Time Deltas***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `timedelta_range()` method creates `TimedeltaIndex` objects. It behaves
    similarly to `date_range()` and `period_range()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the television drama *Lost*, a character had to enter a code and push a
    button every 108 minutes to avert some unknown catastrophe. With the `timedelta_range()`
    method and a frequency argument, he could schedule his day around this requirement.
    Assuming he last pushed the button at midnight, he won’t be getting much uninterrupted
    sleep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '***Shifting Dates with Offsets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to working with frequencies, you can import offsets and use them
    to shift `Timestamp` and `DatetimeIndex` objects. Here’s an example in which we
    import the `Day` class and use it to shift a famous date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also import `DateOffset` class and then pass it the time span as an
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice thing about `DateOffset` objects is that they honor DST transitions.
    You just need to import the appropriate class from `pandas.tseries.offsets`. Here’s
    an example of shifting one hour across the vernal DST transition in the US Central
    time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that the final datetime (`03:00:00`) is *two hours* later than the starting
    datetime (`01:00:00`), even though you shifted it *one hour*. This is due to crossing
    the DST transition.
  prefs: []
  type: TYPE_NORMAL
- en: Along these lines, you can combine two time series even if they are in different
    time zones. The result will be in UTC, as pandas automatically keeps track of
    the equivalent UTC timestamps for each time series.
  prefs: []
  type: TYPE_NORMAL
- en: To see the long list of available offsets, visit *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.tseries.offsets.DateOffset.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.tseries.offsets.DateOffset.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Indexing and Slicing Time Series***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you’re working with time series data, it’s conventional to use the time
    component as the index of a series or DataFrame so that you can perform manipulations
    with respect to the time element. Here, we make a series whose index represents
    a time series and whose data is the integers 0 through 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the indexes are now dates, you can slice and dice the series, just
    as with integer indexes. For example, to select every other row, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the data associated with the January 5, index the series using that
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Conveniently, you don’t need to enter the date in the same format that it was
    input. Any string interpretable as a date will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*Duplicate* dates will produce a *slice* of the series showing all values associated
    with that date. Likewise, you will see all the rows in a DataFrame indexed by
    the same date using the syntax: dataframe`.loc[''`datetime_index`'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you have a time series with multiple years, you can index based
    on the year and retrieve all the indexes and data that include that year. This
    also works for other timespans, such as months.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing works the same way. You can use timestamps not explicitly included
    in the time series, such as `2021-12-31`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we started indexing with December 31, 2021, which precedes the
    dates in the time series.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that pandas is based on NumPy, so slicing creates views rather than
    copies. Any operation you perform on a view will change the source series or DataFrame.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the datetime component to be the data instead of the index, leave
    off the index argument when creating the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The result is a pandas series with an integer index and the dates treated as
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Resampling Time Series***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The process of converting the frequency of a time series to a different frequency
    is called *resampling*. This can involve *downsampling*, by which you aggregate
    data to a lower frequency, perhaps to reduce memory requirements or see trends
    in the data; *upsampling*, wherein you move to a higher frequency, perhaps to
    permit mathematical operations between two datasets with different resolutions;
    or simple resampling, for which you keep the same frequency but change the anchor
    point from, say, the start of the year (`AS-JAN`) to the year end (`A-JAN`).
  prefs: []
  type: TYPE_NORMAL
- en: In pandas, resampling is accomplished by calling the `resample()` method on
    a pandas object using dot notation. Some of its commonly used parameters are listed
    in [Table 21-5](ch21.xhtml#ch021tab5). To see the complete list, visit *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html)*.
    Both series and `dataframe` objects use the same parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-5:** Useful Parameters of the pandas `resample()` Method'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `freq` | `DateOffset` or `Timedelta` object, or string, indicating resampling
    frequency (such as `''D''`, `''Q''`, `''10min''`). |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Axis on which to resample (`0` or `''index''`, `1` or `''columns''`).
    Defaults to `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | When downsampling, indicates which interval end is inclusive,
    either `''right''` or `''left''`. The default value changes depending on `freq`
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `label` | When downsampling, which bin edge to use to label the result, either
    `''right''` or `''left''`. The default value changes depending on `freq` type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `convention` | For `PeriodIndex` only, controls whether to use the start
    or end of `freq` when converting frequencies from low to high. Defaults to `''start''`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `kind` | Pass `''timestamp''` to convert the resulting index to a `DateTimeIndex`
    or `''period''` to convert it to a `PeriodIndex`. By default, the input representation
    is retained. |'
  prefs: []
  type: TYPE_TB
- en: '| `on` | For a DataFrame, specifies the column to use instead of `index` for
    resampling. The column must be datetime-like. |'
  prefs: []
  type: TYPE_TB
- en: '**Upsampling**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Upsampling refers to resampling to a *shorter* time span, such as from daily
    to hourly. This creates bins with `NaN` values that must be filled; for example,
    as with the forward-fill and backfill methods `ffill()` and `bfill()`. This two-step
    process can be accomplished by chaining together the calls to the resample and
    fill methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let’s make a toy dataset with yearly values and expand it to
    quarterly values. This might be necessary when, say, production targets go up
    every year, but progress must be tracked against quarterly production. In the
    console, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: After importing pandas, establish an annual `PeriodIndex` named `dti`. Next,
    create the DataFrame and pass it a dictionary with the values in list form. Then,
    set the `index` argument to the `dti` object. Call the `resample()` method and
    pass it `Q`, for quarterly, and then call the `ffill()` method, chained to the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: The results of this code are broken down in [Figure 21-3](ch21.xhtml#ch021fig3),
    which, from left to right, shows the original DataFrame, the resampling results,
    and the fill results. The original annual values are shown in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-3: Resampling a DataFrame with a yearly range to a quarterly range
    using resample() followed by ffill()*'
  prefs: []
  type: TYPE_NORMAL
- en: The `resample()` method builds the new quarterly index and fills the new rows
    with `NaN` values. Calling `ffill()` fills the empty rows going “forward.” What
    you’re saying here is, “The value for the first quarter of each year (Q1) is the
    value to use for all quarters within that year.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Backfilling does the opposite and assumes that the value at the start of each
    new year (Q1) should apply to the quarters in the previous year *excluding* the
    previous first quarter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The execution of this code is described by [Figure 21-4](ch21.xhtml#ch021fig4).
    Again, original annual values are shown in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-4: Resampling a DataFrame with a yearly range to a quarterly range
    using resample() followed by bfill()*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the values associated with the first quarter are “back filled”
    to the previous three quarters. You must be careful, however, as “leftover” `NaN`s
    can occur. You can see these at the end of the value column in the right-hand
    DataFrame in [Figure 21-4](ch21.xhtml#ch021fig4). The last three values are unchanged
    because no `2024Q1` data was available to set the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill the missing data, let’s assume that the values keep increasing by 10
    each quarter and rerun the code using the `fillna()` method chained to the end.
    Pass it `40` to fill the remaining holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Both `bfill()` and `ffill()` are synonyms for the `fillna()` method. You can
    read more about it at *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downsampling**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Downsampling refers to resampling from a higher frequency to a lower frequency,
    such as from minutes to hours. Because multiple samples must be combined into
    one, the `resample()` method is usually chained to a method for *aggregating*
    the data (see [Table 21-6](ch21.xhtml#ch021tab6)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-6:** Useful Aggregation Methods in pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | Returns the number of non-null values |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Returns the maximum value |'
  prefs: []
  type: TYPE_TB
- en: '| `mean()` | Returns the arithmetic mean of the values |'
  prefs: []
  type: TYPE_TB
- en: '| `median()` | Returns the median of the values |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Returns the minimum value |'
  prefs: []
  type: TYPE_TB
- en: '| `std()` | Returns the standard deviation of the values |'
  prefs: []
  type: TYPE_TB
- en: '| `sum()` | Returns the sum of the values |'
  prefs: []
  type: TYPE_TB
- en: '| `var()` | Returns the variance of the values |'
  prefs: []
  type: TYPE_TB
- en: To practice downsampling, let’s use a real-world dataset from “The COVID Tracking
    Project” at *The Atlantic*. This dataset includes COVID-19 statistics from March
    3, 2020, to March 7, 2021.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the size of the dataset, we’ll download the data for just the state
    of Texas. Navigate to *[https://covidtracking.com/data/download/](https://covidtracking.com/data/download/)*,
    scroll down, and then click the link for **Texas**. For convenience, I recommend
    moving this file to the same folder from which you launched Jupyter Qt console;
    this prevents the need for a file path when loading the data.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, load the data as a pandas DataFrame. The input file has many columns
    of data that we don’t need, so we’ll select only the `date` and `deathIncrease`
    columns. The latter column is the number of COVID-related deaths for the day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s good to keep an eye on what’s happening to the data by calling the `head()`
    method on the DataFrame, which returns the first five rows by default. Here, we
    see that dates are organized in *descending* order, but we generally use and plot
    datetime data in *ascending* order. So, call the pandas `sort_values()` method,
    pass it the column name, and set the ascending argument to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the dates look like dates, but are they? Check the DataFrame’s `dtypes`
    attribute to confirm one way or the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'They’re not. This is important because the `resample()` method works only with
    objects that have a `datetime`-like index, such as `DatetimeIndex`, `PeriodIndex`,
    or `TimedeltaIndex`. We’ll need to change their type and set them as the DataFrame’s
    index, replacing the current integer values. We’ll also drop the `date` column
    because we no longer need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we’ve wrangled the data so that our DataFrame uses a `DatetimeIndex`
    with dates in ascending order. Let’s see how it looks by making a quick plot using
    pandas plotting, which is quick and easy for data exploration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This returns the plot depicted in [Figure 21-5](ch21.xhtml#ch021fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-5: Texas COVID-19-related daily deaths for the period March 3, 2020,
    through March 7, 2021*'
  prefs: []
  type: TYPE_NORMAL
- en: 'One aspect of [Figure 21-5](ch21.xhtml#ch021fig5) that really stands out is
    the spike in values near the start of August 2020\. Because this is clearly a
    *maximum* value, you can easily retrieve the value and its date index by using
    the `max()` and `idxmax()` methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is most likely an anomalous value, especially given that the CDC records
    only 239 deaths on this date, which is more consistent with the adjacent data
    (see *[https://covid.cdc.gov/covid-data-tracker/#trends_dailydeaths/](https://covid.cdc.gov/covid-data-tracker/#trends_dailydeaths/)*).
    Let’s use the CDC value going forward. To change the DataFrame, apply the `.loc`
    indexer, passing it the date (index) and column name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The spike is gone now, and the plot looks more reasonable, as demonstrated in
    [Figure 21-6](ch21.xhtml#ch021fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-6: Texas COVID-19-related daily deaths with the anomalous spike
    removed*'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that’s noticeable is the “sawtooth” nature of the curve caused
    by periodic oscillations in the number of deaths. These oscillations have a high
    frequency, and it’s doubtful that the disease progressed in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To investigate this anomaly, make a new DataFrame that includes a column for
    weekdays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, print out multiple weeks’ worth of data using pandas’ `iloc[]` indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As I’ve highlighted in gray, the lowest reported number of deaths consistently
    occurs on a Monday, and the Sunday results also appear suppressed. This suggests
    a reporting issue over the weekend, with a one-day time lag. You can read more
    about this reporting phenomenon at *[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7363007/](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7363007/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you were on social media during the pandemic, you might have noticed people
    questioning the veracity of COVID data based on plots like [Figure 21-5](ch21.xhtml#ch021fig5).
    This is a good example of how, with a simple application of data science, you
    can easily solve mysteries and quickly quell conspiracy theories.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the oscillations occur *weekly*, downsampling from daily to weekly
    should merge the low and high reports and smooth the curve. Enter the following
    to test the hypothesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 21-7](ch21.xhtml#ch021fig7). The high-frequency
    oscillations are gone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-7: Texas COVID-19-related weekly deaths for the period March 3,
    2020, through March 7, 2021*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s downsample to a monthly period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This produces the even smoother plot in [Figure 21-8](ch21.xhtml#ch021fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-8: Texas COVID-19-related monthly deaths for the period March 3,
    2020, through March 7, 2021*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also downsample to custom periods, such as `'4D'`, for every
    four days.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the Start Date When Resampling**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'So far, we’ve been taking the *default* origin (start date) when aggregating
    intervals, but this can lead to unwanted results. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Despite the first data point being recorded *at* 9 AM, the resampled sums *start*
    at 8 AM. This is because the default for aggregated intervals is `0`, causing
    the two-hour (`'2H'`) frequency timestamps to be `00:00:00`, . . . `08:00:00`,
    `10:00:00`, and so on, skipping `09:00:00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force the output range to start at `09:00:00`, pass the method’s `origin`
    argument `''start''`. Now it should use the actual start of the time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The aggregation starts at 9 AM, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resampling Irregular Time Series Using Interpolation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Scientific observations are often irregular in nature. After all, wildebeests
    don’t show up at waterholes on a fixed schedule. Fortunately, resampling works
    the same whether a time series has an irregular or fixed frequency.
  prefs: []
  type: TYPE_NORMAL
- en: As with upsampling, *regularizing* a time series will generate new timestamps
    with empty values. Previously, we filled these blank values using backfilling
    and front filling. In the next example, we’ll use the pandas `interpolate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by generating a list of irregularly spaced datetimes with a resolution
    measured in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in a single line, create a pandas series object where the index is the
    `datetime` string converted to a `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, resample this time series at the same resolution (`''s''`) and call `interpolate()`
    using `''linear''` for the `method` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You now have timestamps for every second, and new values have been interpolated
    between the original data points. The `method` argument comes with other options,
    including `nearest`, `pad`, `zero`, `spline`, and more. You can read about them
    at *[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resampling and Analyzing Irregular Time Series: A Binary Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at a realistic example of working with irregular time series. Imagine
    that you’ve attached a sensor to the compressor of a refrigeration unit to see
    how often it’s on (`1`) and off (`0`) during a day.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the toy dataset, enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 21-9](ch21.xhtml#ch021fig9). Note that it
    doesn’t reflect the binary (`0` or `1`) nature of the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-9: A plot of an irregular time series of compressor on-off data*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its raw, irregular form, the data is difficult to visualize and work with.
    For example, if you try to check the state of the compressor at 11 AM, you’ll
    get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that series indexing doesn’t interpolate on the fly. We need
    to first resample the data to a “working resolution,” in this case, seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/21fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-10: The plot of time series resampled to one-second frequency*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the plot reflects the binary “on-off” nature of the data, and you can extract
    the state at 11 AM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine how many seconds the compressor was off and on during the time
    period, call the `value_counts()` method on the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine the fraction of the day that the compressor was on, just divide
    the `value_counts()` output at index `1` by the number of seconds in a day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The compressor ran for only three percent of the day. That’s some good insulation!
  prefs: []
  type: TYPE_NORMAL
- en: '**Sliding Window Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The pandas library comes with functions for transforming time series using a
    *sliding window* or with exponentially decaying weights. These functions smooth
    raw data points so that long-term trends are more apparent.
  prefs: []
  type: TYPE_NORMAL
- en: A *moving average* is a commonly used time series technique for smoothing noise
    and gaps and revealing underlying data trends. Well-known examples are the 50-
    and 200-day moving averages used to analyze stock market data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a moving average, a “window” of a specified length is used to average
    rows in a DataFrame column. The window starts at the earliest date and slides
    down the column one time unit at a time, and then it repeats this process. Here’s
    an example for a three-day moving average, with the averaged values in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a “monthly” 30-day moving average of our COVID data from the section
    “Downsampling” on [page 650](ch21.xhtml#ch00lev3sec104), let’s first reimport
    it as a new DataFrame named `df_roll` and replace the anomalous value. (If you
    still have the data in memory, you can use `df_roll = df.copy()` in place of the
    next five lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make a `30_day_ma` column for this DataFrame and calculate the values
    by calling the `rolling()` method on the `deathIncrease` column, passing it `30`
    and then tacking on the `mean()` method. Finish by calling `plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Figure 21-11](ch21.xhtml#ch021fig11), the moving average
    curve is smoother than the curve produced by monthly resampling ([Figure 21-8](ch21.xhtml#ch021fig8))
    but retains some of the periodic oscillations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-11: Texas COVID-related deaths with 30-day moving average curve*'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the averaged values are posted at the *end* of the window, which
    makes the average curve look offset relative to the daily data. To post at the
    *center* of the window, pass `True` to the `rolling()` method’s `center` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now, the peaks and valleys in the averaged curve and the raw data are better
    aligned, as illustrated in [Figure 21-12](ch21.xhtml#ch021fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/21fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-12: Texas COVID-related deaths with 30-day moving average curve
    posted at the center of the window interval*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call other aggregation methods in [Table 21-6](ch21.xhtml#ch021tab6)
    with `rolling()`. Here, we call the standard deviation method on the same 30-day
    sliding window and display the new column with the others ([Figure 21-13](ch21.xhtml#ch021fig13)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/21fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 21-13: A 30-day sliding window standard deviation and moving average
    for COVID-related daily deaths in Texas*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to rolling averages with a fixed-sized window, pandas has methods
    for using expanding windows (`expanding()`), binary moving windows (`corr()`),
    exponentially weighted functions (`ewm()`), and user-defined moving window functions
    (`apply()`). You can read about these at *[https://pandas.pydata.org/pandas-docs/stable/reference/frame.html](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html)*
    for DataFrames, and *[https://pandas.pydata.org/pandas-docs/stable/reference/series.html](https://pandas.pydata.org/pandas-docs/stable/reference/series.html)*
    for series.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  What is the index structure associated with the pandas `Timestamp` class?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `datetime64`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `datetime64[ns]`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `TimedeltaIndex`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `DatetimeIndex`
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Convert `'2021-2-23 00:00:00'` to a pandas `Timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Localize the previous timestamp to the Europe/Warsaw time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Create a PeriodIndex for every hour in May 1, 2021.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Which of the following are examples of downsampling?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Minutes to seconds
  prefs: []
  type: TYPE_NORMAL
- en: b.  Minutes to hours
  prefs: []
  type: TYPE_NORMAL
- en: c.  Years to weeks
  prefs: []
  type: TYPE_NORMAL
- en: d.  Days to months
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Time series represent data indexed to a time reference. Both native Python and
    pandas provide special “time-aware” data types and tools. These let you easily
    handle issues like sexagesimal arithmetic, time zone transitions, daylight saving
    time, leap years, datetime plotting, and more. With the ability to manipulate
    time series, you can gain insights into your data and solve otherwise imponderable
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that does it for *Python Tools for Scientists*. This book had a simple
    goal: to get you up and running as a scientist using Python.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve finished the book, you’ve learned how to set your computer up for
    doing science with the Anaconda distribution, organize your projects using conda
    environments and dedicated project folders, and become familiar with coding tools
    like the Jupyter Qt console, Spyder, Jupyter Notebook, and JupyterLab. If you
    were new to Python, you’ve now learned the basics of the language. You’re aware
    of many of the important scientific and visualization packages, and you should
    have some ideas about how to choose among them. Finally, you’ve gotten some hands-on
    experience with key libraries like NumPy, Matplotlib, pandas, seaborn, and scikit-learn.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, the absolute best way to progress your programming knowledge
    and skill is to *do projects*, either for pay or for play. Projects let you reduce
    the enormous Python universe into manageable chunks, force you to focus your full
    attention on a select group of tasks, and grow your confidence. They’ll lead to
    questions that you never knew you had, and seeking the answers will help you further
    your own education. Onward!
  prefs: []
  type: TYPE_NORMAL
