<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_244"/><span epub:type="pagebreak" id="page_245"/><span class="big">11</span><br/>CREATING AN INTERACTIVE ZOMBIE ESCAPE MAP</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In 2010, <em>The Walking Dead</em> premiered on the AMC television channel. Set at the beginning of a zombie apocalypse, it told the story of a small group of survivors in the area of Atlanta, Georgia. The critically acclaimed show soon became a phenomenon, turning into the most watched series in cable television history, spawning a spin-off called <em>Fear the Walking Dead</em>, and starting an entirely new genre of television, the post-episode discussion show, with <em>Talking Dead</em>.</p>&#13;
<p class="indent">In this chapter, you’ll play a quick-thinking data scientist who foresees the coming collapse of civilization. You’ll prepare a map to help the <em>Walking Dead</em> survivors escape the crowded Atlanta metropolitan area for the more sparsely populated lands west of the Mississippi. In the process, you’ll use the <span class="literal">pandas</span> library to load, analyze, and clean the data, and you’ll use the <span class="literal">bokeh</span> and <span class="literal">holoviews</span> modules to plot the map.</p>&#13;
<h3 class="h3ab" id="ch00lev1sec88"><strong>Project #15: Visualizing Population Density with a Choropleth Map</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_246"/>According to scientists (yes, they’ve studied this), the key to surviving a zombie apocalypse is to live as far from a city as possible. In the United States, that means living in one of the large black areas shown in <a href="ch11.xhtml#ch011fig1">Figure 11-1</a>. The brighter the lights, the greater the population, so if you want to avoid people, don’t “go into the light.”</p>&#13;
<div class="image"><img src="../images/fig11_01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig1"/>Figure 11-1: Nighttime image of US city lights in 2012</p>&#13;
<p class="indent">Unfortunately for our <em>Walking Dead</em> survivors in Atlanta, they’re a long way from the relative safety of the American West. They’ll need to weave their way through a gauntlet of cities and towns, ideally passing through the least populated areas. Service station maps don’t provide that population information, but the US census does. Before civilization collapses and the internet fails, you can download population density data onto your laptop and sort it out later using Python.</p>&#13;
<p class="indent">The best way to present this type of data is with a <em>choropleth map</em>, a visualization tool that uses colors or patterns to represent statistics about predefined geographical regions. You may be familiar with choropleth maps of US presidential election results, which color counties red for a Republican victory and blue for a Democratic one (<a href="ch11.xhtml#ch011fig2">Figure 11-2</a>).</p>&#13;
<p class="indent">If the survivors had a choropleth map of population density that showed the number of people per square mile in each county, they could find the shortest, and theoretically safest, routes out of Atlanta and across the American South. Although you could get even higher-resolution data from the census, using its county-level data should be enough. <em>Walking Dead</em> zombie herds migrate as they get hungry, quickly rendering detailed statistics obsolete.</p>&#13;
<div class="image"><img src="../images/fig11_02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig2"/>Figure 11-2: Choropleth map of the 2016 US presidential election results (light gray = Democrat, dark gray = Republican)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_247"/>To determine the best routes through the counties, the survivors can use state highway maps like the ones found in service stations and welcome centers. These paper maps include county and parish outlines, making it easy to relate their network of cities and roads to a page-sized printout of the choropleth map.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Create an interactive map of the conterminous United States (the 48 adjoining states) that displays population density by county.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec56"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">Like all data visualization exercises, this task consists of the following basic steps: finding and cleaning the data, choosing the type of plot and the tool with which to show the data, preparing the data for plotting, and drawing the data.</p>&#13;
<p class="indent">Finding the data is easy in this case, as the US census population data is made readily available to the public. You still need to <em>clean</em> it, however, by finding and handling bogus data points, null values, and formatting issues. Ideally you would also verify the accuracy of the data, a difficult job that data scientists probably skip far too often. The data should at least pass a sanity check, something that may have to wait until the data is drawn. New York City should have a greater population density than Billings, Montana, for example.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>Next, you must decide how you’ll present the data. You’ll use a map, but other options might include a bar chart or a table. Even more important is choosing the tool—in this case, the Python library—that you’ll use to make the plot. The choice of tool can have a big impact on how you prepare the data and exactly what you end up showing.</p>&#13;
<p class="indent">Years ago, a fast-food company ran a commercial in which a customer claimed to like “a variety, but not too much of a variety.” When it comes to visualization tools in Python, you can argue that there are too many choices, with too little to distinguish them: <span class="literal">matplotlib</span>, <span class="literal">seaborn</span>, <span class="literal">plotly</span>, <span class="literal">bokeh</span>, <span class="literal">folium</span>, <span class="literal">altair</span>, <span class="literal">pygal</span>, <span class="literal">ggplot</span>, <span class="literal">holoviews</span>, <span class="literal">cartopy</span>, <span class="literal">geoplotlib</span>, and built-in functions in <span class="literal">pandas</span>.</p>&#13;
<p class="indent">These various visualization libraries have their strengths and weaknesses, but since this project requires speed, you’ll focus on the easy-to-use <span class="literal">holoviews</span> module, with a <span class="literal">bokeh</span> backend for plotting. This combination will allow you to produce an interactive choropleth map with only a few lines of code, and <span class="literal">bokeh</span> conveniently includes US state and county polygons in its sample data.</p>&#13;
<p class="indent">Once you’ve chosen your visualization tool, you must put the data in the format that the tool expects. You’ll need to figure out how to fill in the county shapes, which you get from one file, with the population data from another file. This will involve a little reverse engineering using example code from the <span class="literal">holoviews</span> gallery. After that, you’ll plot the map with <span class="literal">bokeh</span>.</p>&#13;
<p class="indent">Fortunately, data analysis with Python almost always relies on the Python Data Analysis Library (<span class="literal">pandas</span>). This module will let you load the census data, analyze it, and reformat it for use with <span class="literal">holoviews</span> and <span class="literal">bokeh</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec57"><strong><em>The Python Data Analysis Library</em></strong></h4>&#13;
<p class="noindent">The open source <span class="literal">pandas</span> library is the most popular library available for performing data extraction, processing, and manipulation in Python. It contains data structures designed for working with common data sources, such as SQL relational databases and Excel spreadsheets. If you plan on being a data scientist in any form, you’ll surely encounter <span class="literal">pandas</span> at some point.</p>&#13;
<p class="indent">The <span class="literal">pandas</span> library contains two primary data structures: series and dataframes. A <em>series</em> is a one-dimensional labeled array that can hold any type of data, such as integers, floats, strings, and so on. Because <span class="literal">pandas</span> is based on <span class="literal">NumPy</span>, a series object is basically two associated arrays (see the introduction to arrays on <a href="ch01.xhtml#page_12">page 12</a> in <a href="ch01.xhtml">Chapter 1</a> if you’re new to arrays). One array contains the data point values, which can have any <span class="literal">NumPy</span> data type. The other array contains labels for each data point, called <em>indexes</em> (<a href="ch11.xhtml#ch011table1">Table 11-1</a>).</p>&#13;
<p class="tabcap"><a id="ch011table1"/><strong>Table 11-1:</strong> A Series Object</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Index</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Value</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">25</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">432</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">–112</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">99</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_249"/>Unlike the indexes of Python list items, the indexes in a series don’t have to be integers. In <a href="ch11.xhtml#ch011table2">Table 11-2</a>, the indexes are the names of people, and the values are their ages.</p>&#13;
<p class="tabcap"><a id="ch011table2"/><strong>Table 11-2:</strong> A Series Object with Meaningful Labels</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Index</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Value</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Javier</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">25</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Carol</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">32</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Lora</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">19</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Sarah</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">29</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As with a list or <span class="literal">NumPy</span> array, you can slice a series or select individual elements by specifying an index. You can manipulate the series many ways, such as filtering it, performing mathematical operations on it, and merging it with other series.</p>&#13;
<p class="indent">A <em>dataframe</em> is a more complex structure comprising two dimensions. It has a tabular structure similar to a spreadsheet, with columns, rows, and data (<a href="ch11.xhtml#ch011table3">Table 11-3</a>). You can think of it as an ordered collection of columns with two indexing arrays.</p>&#13;
<p class="tabcap"><a id="ch011table3"/><strong>Table 11-3:</strong> A Dataframe Object</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h_ch11"/>&#13;
<th style="vertical-align: top;" class="table-h"><p>Columns</p></th>&#13;
<th style="vertical-align: top;" class="table-h"/>&#13;
<th style="vertical-align: top;" class="table-h"/>&#13;
<th style="vertical-align: top;" class="table-h"/>&#13;
</tr>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h_ch11"><p class="taba">Index</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Country</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">State</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">County</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Population</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a_ch2"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">USA</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">Alabama</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">Autauga</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11b"><p class="taba">54,571</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a_ch2"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">USA</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">Alabama</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">Baldwin</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11b"><p class="taba">182,265</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a_ch2"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">USA</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">Alabama</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11d"><p class="taba">Barbour</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11b"><p class="taba">27,457</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h_ch11a"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11add"><p class="taba">USA</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11add"><p class="taba">Alabama</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11add"><p class="taba">Bibb</p></td>&#13;
<td style="vertical-align: top;" class="table-h_ch11add"><p class="taba">22,915</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The first index, for the rows, works much like the index array in a series. The second keeps track of the series of labels, with each label representing a column header. Dataframes also resemble dictionaries; the column names form the keys, and the series of data in each column forms the values. This structure lets you easily manipulate dataframes.</p>&#13;
<p class="indent">Covering all the functionality in <span class="literal">pandas</span> would require a whole book, and you can find plenty online! We’ll defer additional discussion until the code section, where we’ll look at specific examples as we apply them.</p>&#13;
<h4 class="h4" id="ch00lev2sec58"><strong><em>The bokeh and holoviews Libraries</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">bokeh</span> module (<em><a href="https://bokeh.org/">https://bokeh.org/</a></em>) is an open source interactive visualization library for modern web browsers. You can use it to construct elegant interactive graphics over large or streaming datasets. It renders its graphics using HTML and JavaScript, the predominant programming languages for creating interactive web pages.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_250"/>The open source <span class="literal">holoviews</span> library (<em><a href="http://holoviews.org/">http://holoviews.org/</a></em>) aims to make data analysis and visualization simple. With <span class="literal">holoviews</span>, instead of building a plot by making a direct call to a plotting library, such as <span class="literal">bokeh</span> or <span class="literal">matplotlib</span>, you first create an object describing your data, and the plots become automatic visual representations of this object.</p>&#13;
<p class="indent">The <span class="literal">holoviews</span> example gallery includes several choropleth maps visualized using <span class="literal">bokeh</span> (such as <em><a href="http://holoviews.org/gallery/demos/bokeh/texas_choropleth_example.html">http://holoviews.org/gallery/demos/bokeh/texas_choropleth_example.html</a></em>). Later, we’ll use the unemployment rate example from this gallery to figure out how to present our population density data in a similar manner.</p>&#13;
<h4 class="h4" id="ch00lev2sec59"><strong><em>Installing pandas, bokeh, and holoviews</em></strong></h4>&#13;
<p class="noindent">If you worked through the project in <a href="ch01.xhtml">Chapter 1</a>, you already have <span class="literal">pandas</span> and <span class="literal">NumPy</span> installed. If not, see the instructions in “Installing the Python Libraries” on <a href="ch01.xhtml#page_6">page 6</a>.</p>&#13;
<p class="indent">One option for installing <span class="literal">holoviews</span>, along with latest version of all the recommended packages for working with the module on Linux, Windows, or macOS, is to use Anaconda.</p>&#13;
<pre><span class="codestrong1">conda install -c pyviz holoviews bokeh</span></pre>&#13;
<p class="indent">This installation method includes the default <span class="literal">matplotlib</span> plotting library backend, the more interactive <span class="literal">bokeh</span> plotting library backend, and the Jupyter/IPython Notebook.</p>&#13;
<p class="indent">You can install a similar set of packages using <span class="literal">pip</span>.</p>&#13;
<pre><span class="codestrong1">pip install 'holoviews[recommended]'</span></pre>&#13;
<p class="indent">Additional minimal installation options are available through <span class="literal">pip</span>, assuming you already have <span class="literal">bokeh</span> installed. You can find these and other installation instructions at <em><a href="http://holoviews.org/install.html">http://holoviews.org/install.html</a></em> and <em><a href="http://holoviews.org/user_guide/Installing_and_Configuring.html">http://holoviews.org/user_guide/Installing_and_Configuring.html</a></em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec60"><strong><em>Accessing the County, State, Unemployment, and Population Data</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">bokeh</span> library comes with data files for the state and county outlines and the 2009 US unemployment data per county. As mentioned, you’ll use the unemployment data to determine how to format the population data, which comes from the 2010 census.</p>&#13;
<p class="indent">To download the <span class="literal">bokeh</span> sample data, connect to the internet, open a Python shell, and enter the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import bokeh</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">import bokeh.sampledata</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">bokeh.sampledata.download()</span>&#13;
Creating C:\Users\lee_v\.bokeh directory&#13;
Creating C:\Users\lee_v\.bokeh\data directory&#13;
Using data directory: C:\Users\lee_v\.bokeh\data</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>As you can see, the program will tell you where on your machine it’s putting the data so that <span class="literal">bokeh</span> can automatically find it. Your path will differ from mine. For more on downloading the sample data, see <em><a href="https://docs.bokeh.org/en/latest/docs/reference/sampledata.html">https://docs.bokeh.org/en/latest/docs/reference/sampledata.html</a></em>.</p>&#13;
<p class="indent">Look for <em>US_Counties.csv</em> and <em>unemployment09.csv</em> in the folder of downloaded files. These plaintext files use the popular <em>comma-separated values</em> (CSV) format, in which each line represents a data record with multiple fields separated by commas. (Good luck saying “CSV” right if you regularly shop at a CVS pharmacy!)</p>&#13;
<p class="indent">The unemployment file is instructive of the plight of the data scientist. If you open it, you’ll see that there are no column names describing the data (<a href="ch11.xhtml#ch011fig3">Figure 11-3</a>), though it’s possible to guess what most of the fields represent. We’ll deal with this later.</p>&#13;
<div class="image"><img src="../images/fig11_03.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig3"/>Figure 11-3: The first few rows of <span class="normal">unemployment09.csv</span></p>&#13;
<p class="indent">If you open the US counties file, you’ll see lots of columns, but at least they have headers (<a href="ch11.xhtml#ch011fig4">Figure 11-4</a>). Your challenge will be to relate the un-employment data in <a href="ch11.xhtml#ch011fig3">Figure 11-3</a> to the geographical data in <a href="ch11.xhtml#ch011fig4">Figure 11-4</a> so that you can do the same later with the census data.</p>&#13;
<div class="image"><img src="../images/fig11_04.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig4"/>Figure 11-4: The first few rows of <span class="normal">US_Counties.csv</span></p>&#13;
<p class="indent">You can find the population data, <em>census_data_popl_2010.csv</em>, in the <em>Chapter_11</em> folder, downloadable from the book’s website. This file, originally named <em>DEC_10_SF1_GCTPH1.US05PR_with_ann.csv</em>, came from the American FactFinder website. By the time this book is published, the US government will have migrated the census data to a new site called <em><a href="https://data.census.gov">https://data.census.gov</a></em> (see <em><a href="https://www.census.gov/data/what-is-data-census-gov.html">https://www.census.gov/data/what-is-data-census-gov.html</a></em>).</p>&#13;
<p class="indent">If you look at the top of the census file, you’ll see lots of columns with two header rows (<a href="ch11.xhtml#ch011fig5">Figure 11-5</a>). You’re interested in column M, titled <em>Density per square mile of land area – Population</em>.</p>&#13;
<div class="image"><img src="../images/fig11_05.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig5"/>Figure 11-5: The first few rows of <span class="normal">census_data_popl_2010.csv</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>At this point, you have all the Python libraries and data files you need to generate a population density choropleth map <em>in theory</em>. Before you can write the code, however, you need to know how you’re going to link the population data to the geographical data so that you can place the correct county data in the correct county shape.</p>&#13;
<h4 class="h4" id="ch00lev2sec61"><strong><em>Hacking holoviews</em></strong></h4>&#13;
<p class="noindent">Learning to adapt existing code for your own use is a valuable skill for a data scientist. This may require a bit of reverse engineering. Because open source software is free, it’s sometimes poorly documented, so you have to figure out how it works on your own. Let’s take a moment and apply this skill to our current problem.</p>&#13;
<p class="indent">In previous chapters, we took advantage of the gallery examples provided by open source modules such as <span class="literal">turtle</span> and <span class="literal">matplotlib</span>. The <span class="literal">holoviews</span> library also has a gallery (<em><a href="http://holoviews.org/gallery/index.html">http://holoviews.org/gallery/index.html</a></em>), and it includes Texas Choropleth Example, a choropleth map of the Texas unemployment rate in 2009 (<a href="ch11.xhtml#ch011fig6">Figure 11-6</a>).</p>&#13;
<div class="image"><img src="../images/fig11_06.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig6"/>Figure 11-6: Choropleth map of the 2009 Texas unemployment rate from the <span class="codeitalic">holoviews</span> gallery</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/><a href="ch11.xhtml#ch011list1">Listing 11-1</a> contains the code provided by <span class="literal">holoviews</span> for this map. You’ll build your project based on this example, but to do so, you’ll have to address two main differences. First, you plan to plot population density rather than unemployment rate. Second, you want a map of the conterminous United States, not just Texas.</p>&#13;
<pre><span class="codeitalic1">texas_choropleth_example.html</span>&#13;
   import holoviews as hv&#13;
   from holoviews import opts&#13;
   hv.extension('bokeh')&#13;
<span class="ent">➊</span> from bokeh.sampledata.us_counties import data as counties&#13;
   from bokeh.sampledata.unemployment import data as unemployment&#13;
   &#13;
   counties = [dict(county, <span class="ent">➋</span>Unemployment=unemployment[cid])&#13;
               for cid, county in counties.items()&#13;
            <span class="ent">➌</span> if county["state"] == "tx"]&#13;
   &#13;
   choropleth = hv.Polygons(counties, ['lons', 'lats'],&#13;
                            [('detailed name', 'County'), 'Unemployment'])&#13;
   &#13;
   choropleth.opts(opts.Polygons(logz=True,&#13;
                                 tools=['hover'],&#13;
                                 xaxis=None, yaxis=None,&#13;
                                 show_grid=False,&#13;
                                 show_frame=False,&#13;
                                 width=500, height=500,&#13;
                                 color_index='Unemployment',&#13;
                                 colorbar=True, toolbar='above',&#13;
                                 line_color='white'))</pre>&#13;
<p class="listing"><a id="ch011list1"/>Listing 11-1: <span class="codeitalic">holoviews</span> gallery code for generating the Texas choropleth</p>&#13;
<p class="indent">The code imports the data from the <span class="literal">bokeh</span> sample data <span class="ent">➊</span>. You’ll need to know the format and content of both the <span class="literal">unemployment</span> and <span class="literal">counties</span> variables. The unemployment rate is accessed later using the <span class="literal">unemployment</span> variable and an index or key of <span class="literal">cid</span>, which may stand for “county ID” <span class="ent">➋</span>. The program selects Texas, rather than the whole United States, based on a conditional using a <span class="literal">state</span> code <span class="ent">➌</span>.</p>&#13;
<p class="indent">Let’s investigate this in the Python shell.</p>&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">from bokeh.sampledata.unemployment import data as unemployment</span>&#13;
<span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">type(unemployment)</span>&#13;
   &lt;class 'dict'&gt;&#13;
<span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">first_2 = {k: unemployment[k] for k in list(unemployment)[:2]}</span>&#13;
   &gt;&gt;&gt; <span class="codestrong1">for k in first_2:</span>&#13;
          <span class="codestrong1">print(f"{k} : {first_2[k]}")</span>&#13;
<span class="ent">➌</span> (1, 1) : 9.7&#13;
   (1, 3) : 9.1&#13;
   &gt;&gt;&gt;&#13;
   &gt;&gt;&gt; <span class="codestrong1">for k in first_2:</span>&#13;
          <span class="codestrong1">for item in k:</span>&#13;
             <span class="codestrong1">print(f"{item}: {type(item)}")</span>&#13;
<span class="ent">➍</span> 1: &lt;class 'int'&gt;&#13;
   1: &lt;class 'int'&gt;&#13;
   1: &lt;class 'int'&gt;&#13;
   3: &lt;class 'int'&gt;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_254"/>Start by importing the <span class="literal">bokeh</span> sample data using the syntax from the gallery example. Next, use the <span class="literal">type()</span> built-in function to check the data type of the <span class="literal">unemployment</span> variable <span class="ent">➊</span>. You’ll see that it’s a dictionary.</p>&#13;
<p class="indent">Now, use dictionary comprehension to make a new dictionary comprising the first two lines in <span class="literal">unemployment</span> <span class="ent">➋</span>. Print the results, and you’ll see that the keys are tuples and the values are numbers, presumably the unemployment rate in percent <span class="ent">➌</span>. Check the data type for the numbers in the key. They’re integers rather than strings <span class="ent">➍</span>.</p>&#13;
<p class="indent">Compare the output at <span class="ent">➌</span> to the first two rows in the CSV file in <a href="ch11.xhtml#ch011fig3">Figure 11-3</a>. The first number in the key tuple, presumably a state code, comes from column B. The second number in the tuple, presumably a county code, comes from column C. The unemployment rate is obviously stored in column I.</p>&#13;
<p class="indent">Now compare the contents of <span class="literal">unemployment</span> to <a href="ch11.xhtml#ch011fig4">Figure 11-4</a>, representing the county data. The <em>STATE num</em> (column J) and <em>COUNTY num</em> (column K) obviously hold the components of the key tuple.</p>&#13;
<p class="indent">So far so good, but if you look at the population data file in <a href="ch11.xhtml#ch011fig5">Figure 11-5</a>, you won’t find a state or county code to direct into a tuple. There are numbers in column E, however, that match those in the last column of the county data, labeled <em>FIPS formula</em> in <a href="ch11.xhtml#ch011fig4">Figure 11-4</a>. These FIPS numbers seem to relate to the state and county codes.</p>&#13;
<p class="indent">As it turns out, a <em>Federal Information Processing Series (FIPS)</em> code is basically a ZIP code for a county. The FIPS code is a five-digit numeric code assigned to each county by the National Institute of Standards and Technology. The first two digits represent the county’s state, and the final three digits represent the county (<a href="ch11.xhtml#ch011table4">Table 11-4</a>).</p>&#13;
<p class="tabcap"><a id="ch011table4"/><strong>Table 11-4:</strong> Identifying US Counties Using a FIPS Code</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">US County</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">State Code</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">County Code</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">FIPS</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Baldwin County, AL</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">01</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">003</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">1003</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Johnson County, IA</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">19</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">103</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">19103</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Congratulations, you now know how to link the US census data to the county shapes in the <span class="literal">bokeh</span> sample data. It’s time to write the final code!</p>&#13;
<h4 class="h4" id="ch00lev2sec62"><strong><em>The Choropleth Code</em></strong></h4>&#13;
<p class="noindent">The <em>choropleth.py</em> program includes code for both cleaning the data and plotting the choropleth map. You can find a copy of the code, along with the population data, in the <em>Chapter_11</em> folder downloadable from the book’s website at <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h5 class="h5"><strong>Importing Modules and Data and Constructing a Dataframe</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_255"/><a href="ch11.xhtml#ch011list2">Listing 11-2</a> imports modules and the <span class="literal">bokeh</span> county sample data that includes coordinates for all the US county polygons. It also loads and creates a dataframe object to represent the population data. Then it begins the process of cleaning and preparing the data for use with the county data.</p>&#13;
<pre><span class="codeitalic1">choropleth.py</span>, part 1&#13;
   from os.path import abspath&#13;
   import webbrowser&#13;
   import pandas as pd&#13;
   import holoviews as hv&#13;
   from holoviews import opts&#13;
<span class="ent">➊</span> hv.extension('bokeh')&#13;
   from bokeh.sampledata.us_counties import data as counties&#13;
   &#13;
<span class="ent">➋</span> df = pd.read_csv('census_data_popl_2010.csv', encoding="ISO-8859-1")&#13;
   &#13;
   df = pd.DataFrame(df,&#13;
                     columns=&#13;
                     ['Target Geo Id2',&#13;
                     'Geographic area.1',&#13;
                     'Density per square mile of land area - Population'])&#13;
                               &#13;
   df.rename(columns =&#13;
             {'Target Geo Id2':'fips',&#13;
              'Geographic area.1': 'County',&#13;
              'Density per square mile of land area - Population':'Density'},&#13;
             inplace = True)&#13;
   &#13;
   print(f"\nInitial popl data:\n {df.head()}")&#13;
   print(f"Shape of df = {df.shape}\n")</pre>&#13;
<p class="listing"><a id="ch011list2"/>Listing 11-2: Importing modules and data, creating a dataframe, and renaming columns</p>&#13;
<p class="indent">Start by importing <span class="literal">abspath</span> from the operating system library. You’ll use this to find the absolute path to the choropleth map HTML file after it’s created. Then import the <span class="literal">webbrowser</span> module so you can launch the HTML file. You need this because the <span class="literal">holoviews</span> library is designed to work with a Jupyter Notebook and won’t automatically display the map without some help.</p>&#13;
<p class="indent">Next, import <span class="literal">pandas</span> and repeat the <span class="literal">holoviews</span> imports from the gallery example in <a href="ch11.xhtml#ch011list1">Listing 11-1</a>. Note that you must specify <span class="literal">bokeh</span> as the <span class="literal">holoviews</span> extension, or <em>backend</em> <span class="ent">➊</span>. This is because <span class="literal">holoviews</span> can work with other plotting libraries, such as <span class="literal">matplotlib</span>, and needs to know which one to use.</p>&#13;
<p class="indent">You brought in the geographical data with the imports. Now load the population data using <span class="literal">pandas</span>. This module includes a set of input/output API functions to facilitate reading and writing data. These <em>readers</em> and <em>writers</em> address major formats such as comma-separated values (<span class="literal">read_csv</span>, <span class="literal">to_csv</span>), Excel (<span class="literal">read_excel</span>, <span class="literal">to_excel</span>), Structured Query Language (<span class="literal">read_sql</span>, <span class="literal">to_sql</span>), HyperText Markup Language (<span class="literal">read_html</span>, <span class="literal">to_html</span>), and more. In this project, you’ll work with the CSV format.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>In most cases, you can read CSV files without specifying the character encoding.</p>&#13;
<pre>df = pd.read_csv('census_data_popl_2010.csv')</pre>&#13;
<p class="indent">In this case, however, you’ll get the following error:</p>&#13;
<pre>UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 31: &#13;
invalid continuation byte</pre>&#13;
<p class="indent">That’s because the file contains characters encoded with Latin-1, also known as ISO-8859-1, rather than the default UTF-8 encoding. Adding the encoding argument will fix the problem <span class="ent">➋</span>.</p>&#13;
<p class="indent">Now, turn the population data file into a tabular dataframe by calling the <span class="literal">DataFrame()</span> constructor. You don’t need all the columns in the original file, so pass the names of the column you want to keep to the constructor. These represent columns E, G, and M in <a href="ch11.xhtml#ch011fig5">Figure 11-5</a>, or the FIPS code, county name (without the state name), and population density, respectively.</p>&#13;
<p class="indent">Next, use the <span class="literal">rename()</span> dataframe method to make the column labels shorter and more meaningful. Call them <em>fips</em>, <em>County</em>, and <em>Density</em>.</p>&#13;
<p class="indent">Finish the listing by printing the first few rows of the dataframe using the <span class="literal">head()</span> method and by printing the shape of the dataframe using its <span class="literal">shape</span> attribute. By default, the <span class="literal">head()</span> method prints the first five rows. If you want to see more rows, you can pass it the number as an argument, such as <span class="literal">head(20)</span>. You should see the following output in the shell:</p>&#13;
<pre>Initial popl data:&#13;
      fips          County  Density&#13;
0     NaN   United States     87.4&#13;
1     1.0         Alabama     94.4&#13;
2  1001.0  Autauga County     91.8&#13;
3  1003.0  Baldwin County    114.6&#13;
4  1005.0  Barbour County     31.0&#13;
Shape of df = (3274, 3)</pre>&#13;
<p class="indent">Notice that the first two rows (rows 0 and 1) are not useful. In fact, you can glean from this output that each state will have a row for its name, which you’ll want to delete. You can also see from the <span class="literal">shape</span> attribute that there are 3,274 rows in the dataframe.</p>&#13;
<h5 class="h5"><strong>Removing Extraneous State Name Rows and Preparing the State and County Codes</strong></h5>&#13;
<p class="noindent"><a href="ch11.xhtml#ch011list3">Listing 11-3</a> removes all rows whose FIPS code is less than or equal to 100. These are header rows that indicate where a new state begins. It then creates new columns for the state and county codes, which it derives from the existing column of FIPS codes. You’ll use these later to select the proper county outline from the <span class="literal">bokeh</span> sample data.<span epub:type="pagebreak" id="page_257"/></p>&#13;
<pre>   <span class="codeitalic1">choropleth.py</span>, part 2&#13;
   df = df[df['fips'] &gt; 100]&#13;
   print(f"Popl data with non-county rows removed:\n {df.head()}")&#13;
   print(f"Shape of df = {df.shape}\n")&#13;
   &#13;
<span class="ent">➊</span> df['state_id'] = (df['fips'] // 1000).astype('int64')&#13;
   df['cid'] = (df['fips'] % 1000).astype('int64') &#13;
   print(f"Popl data with new ID columns:\n {df.head()}")&#13;
   print(f"Shape of df = {df.shape}\n")&#13;
   print("df info:")&#13;
<span class="ent">➋</span> print(df.info())&#13;
   &#13;
   print("\nPopl data at row 500:")&#13;
<span class="ent">➌</span> print(df.loc[500])</pre>&#13;
<p class="listing"><a id="ch011list3"/>Listing 11-3: Removing extraneous rows and preparing the state and county codes</p>&#13;
<p class="indent">To display the population density data in the county polygons, you need to turn it into a dictionary where the keys are a tuple of the state code and county code and the values are the density data. But as you saw previously, the population data does not include separate columns for the state and county codes; it has only the FIPS codes. So, you’ll need to split out the state and county components.</p>&#13;
<p class="indent">First, get rid of all the noncounty rows. If you look at the previous shell output (or rows 3 and 4 in <a href="ch11.xhtml#ch011fig5">Figure 11-5</a>), you’ll see that these rows do not include a four- or five-digit FIPS code. You can thus use the <span class="literal">fips</span> column to make a new dataframe, still named <span class="literal">df</span>, that preserves only rows with a <span class="literal">fips</span> value greater than 100. To check that this worked, repeat the printout from the previous listing, as shown here:</p>&#13;
<pre> Popl data with non-county rows removed:&#13;
      fips          County  Density&#13;
2  1001.0  Autauga County     91.8&#13;
3  1003.0  Baldwin County    114.6&#13;
4  1005.0  Barbour County     31.0&#13;
5  1007.0     Bibb County     36.8&#13;
6  1009.0   Blount County     88.9&#13;
Shape of df = (3221, 3)</pre>&#13;
<p class="indent">The two “bad” rows at the top of the dataframe are now gone, and based on the <span class="literal">shape</span> attribute, you’ve lost a total of 53 rows. These represent the header rows for the 50 states, United States, District of Columbia (DC), and Puerto Rico. Note that DC has a FIPS code of 11001 and Puerto Rico uses a state code of 72 to go with the three-digit county code for its 78 municipalities. You’ll keep DC but remove Puerto Rico later.</p>&#13;
<p class="indent">Next, create columns for state and county code numbers. Name the first new column <span class="literal">state_id</span> <span class="ent">➊</span>. Dividing by 1,000 using floor division (<span class="literal">//</span>) returns the quotient with the digits after the decimal point removed. Since the last three numbers of the FIPS code are reserved for county codes, this leaves you with the state code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/>Although <span class="literal">//</span> returns an integer, the new dataframe column uses the float datatype by default. But our analysis of the <span class="literal">bokeh</span> sample data indicated that it used integers for these codes in the key tuples. Convert the column to the integer datatype using the <span class="literal">pandas</span> <span class="literal">astype()</span> method and pass it <span class="literal">'int64'</span>.</p>&#13;
<p class="indent">Now, make a new column for the county code. Name it <span class="literal">cid</span> so it will match the terminology used in the <span class="literal">holoviews</span> choropleth example. Since you’re after the last three digits in the FIPS code, use the <span class="literal">modulo</span> operator (<span class="literal">%</span>). This returns the remainder from the division of the first argument to the second. Convert this column to the integer datatype as in the previous line.</p>&#13;
<p class="indent">Print the output again, only this time call the <span class="literal">info()</span> method on the dataframe <span class="ent">➋</span>. This method returns a concise summary of the dataframe, including datatypes and memory usage.</p>&#13;
<pre>Popl data with new ID columns:&#13;
      fips          County  Density  state_id  cid&#13;
2  1001.0  Autauga County     91.8         1    1&#13;
3  1003.0  Baldwin County    114.6         1    3&#13;
4  1005.0  Barbour County     31.0         1    5&#13;
5  1007.0     Bibb County     36.8         1    7&#13;
6  1009.0   Blount County     88.9         1    9&#13;
Shape of df = (3221, 5)&#13;
&#13;
df info:&#13;
&lt;class 'pandas.core.frame.DataFrame'&gt;&#13;
Int64Index: 3221 entries, 2 to 3273&#13;
Data columns (total 5 columns):&#13;
fips        3221 non-null float64&#13;
County      3221 non-null object&#13;
Density     3221 non-null float64&#13;
state_id    3221 non-null int64&#13;
cid         3221 non-null int64&#13;
dtypes: float64(2), int64(2), object(1)&#13;
memory usage: 151.0+ KB&#13;
None</pre>&#13;
<p class="indent">As you can see from the columns and information summary, the <span class="literal">state_id</span> and <span class="literal">cid</span> numbers are integer values.</p>&#13;
<p class="indent">The state codes in the first five rows are all single-digit numbers, but it’s possible for state codes to have double digits, as well. Take the time to check the state codes of later rows. You can do this by calling the <span class="literal">loc()</span> method on the dataframe and passing it a high row number <span class="ent">➌</span>. This will let you check double-digit state codes.</p>&#13;
<pre>Popl data at row 500:&#13;
fips                13207&#13;
County      Monroe County&#13;
Density              66.8&#13;
state_id               13&#13;
cid                   207&#13;
Name: 500, dtype: object</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>The <span class="literal">fips</span>, <span class="literal">state_id</span>, and <span class="literal">cid</span> all look reasonable. This completes the data preparation. The next step is to turn this data into a dictionary that <span class="literal">holoviews</span> can use to make the choropleth map.</p>&#13;
<h5 class="h5"><strong>Preparing the Data for Display</strong></h5>&#13;
<p class="noindent"><a href="ch11.xhtml#ch011list4">Listing 11-4</a> converts the state and county IDs and the density data into separate lists. It then recombines them into a dictionary with the same format as the <span class="literal">unemployment</span> dictionary used in the <span class="literal">holoviews</span> gallery example. It also lists the states and territories to exclude from the map and makes a list of the data needed to plot the choropleth map.</p>&#13;
<pre><span class="codeitalic1">choropleth.py</span>, part 3&#13;
state_ids = df.state_id.tolist()&#13;
cids = df.cid.tolist()&#13;
den = df.Density.tolist()&#13;
&#13;
tuple_list = tuple(zip(state_ids, cids))&#13;
popl_dens_dict = dict(zip(tuple_list, den))&#13;
&#13;
EXCLUDED = ('ak', 'hi', 'pr', 'gu', 'vi', 'mp', 'as')&#13;
&#13;
counties = [dict(county, Density=popl_dens_dict[cid])&#13;
            for cid, county in counties.items()&#13;
            if county["state"] not in EXCLUDED]</pre>&#13;
<p class="listing"><a id="ch011list4"/>Listing 11-4: Preparing the population data for plotting</p>&#13;
<p class="indent">Earlier, we looked at the <span class="literal">unemployment</span> variable in the <span class="literal">holoviews</span> gallery example and found that it was a dictionary. Tuples of the state and county codes served as the keys, and the unemployment rates served as the values, as follows:</p>&#13;
<pre>(1, 1) : 9.7&#13;
(1, 3) : 9.1&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">To create a similar dictionary for the population data, first use the <span class="literal">pandas</span> <span class="literal">tolist()</span> method to create separate lists of the dataframe’s <span class="literal">state_id</span>, <span class="literal">cid</span>, and <span class="literal">Density</span> columns. Then, use the built-in <span class="literal">zip()</span> function to merge the state and county code lists as tuple pairs. Create the final dictionary, <span class="literal">popl_dens_dict</span>, by zipping this new <span class="literal">tuple_list</span> with the density list. (The name <span class="literal">tuple_list</span> is misleading; technically, it’s a <span class="literal">tuple_tuple</span>.) That’s it for the data preparation.</p>&#13;
<p class="indent">The <em>Walking Dead</em> survivors will be lucky to get out of Atlanta. Let’s forget about them reaching Alaska. Make a tuple, named <span class="literal">EXCLUDED</span>, of states and territories that are in the <span class="literal">bokeh</span> county data but aren’t part of the conterminous United States. These include Alaska, Hawaii, Puerto Rico, Guam, Virgin Islands, Northern Mariana Islands, and American Samoa. To reduce typing, you can use the abbreviations provided as a column in the county dataset (see <a href="ch11.xhtml#ch011fig4">Figure 11-4</a>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>Next, as in the <span class="literal">holoviews</span> example, make a dictionary and put it in a list named <span class="literal">counties</span>. Here’s where you add the population density data. Link it to the proper county using the <span class="literal">cid</span> county identifier number. Use a conditional to apply the <span class="literal">EXCLUDED</span> tuple.</p>&#13;
<p class="indent">If you print the first index in this list, you’ll get the (truncated) output that follows:</p>&#13;
<pre>[{'name': 'Autauga', 'detailed name': 'Autauga County, Alabama', 'state': &#13;
'al', 'lats': [32.4757, 32.46599, 32.45054, 32.44245, 32.43993, 32.42573, &#13;
32.42417, <span class="codeitalic1">--snip--</span> -86.41231, -86.41234, -86.4122, -86.41212, -86.41197, &#13;
-86.41197, -86.41187], 'Density': 91.8}]</pre>&#13;
<p class="indent">The <span class="literal">Density</span> key-value pair now replaces the unemployment rate pair used in the <span class="literal">holoviews</span> gallery example. Next up, plotting the map!</p>&#13;
<h5 class="h5"><strong>Plotting the Choropleth Map</strong></h5>&#13;
<p class="noindent"><a href="ch11.xhtml#ch011list5">Listing 11-5</a> creates the choropleth map, saves it as an <em>.html</em> file, and opens it with the <span class="literal">webbrowser</span>.</p>&#13;
<pre><span class="codeitalic1">choropleth.py</span>, part 4&#13;
   choropleth = hv.Polygons(counties,&#13;
                            ['lons', 'lats'],&#13;
                            [('detailed name', 'County'), 'Density'])&#13;
   &#13;
<span class="ent">➊</span> choropleth.opts(opts.Polygons(logz=True,&#13;
                     tools=['hover'],&#13;
                     xaxis=None, yaxis=None,&#13;
                     show_grid=False, show_frame=False,&#13;
                     width=1100, height=700,&#13;
                     colorbar=True, toolbar='above',&#13;
                     color_index='Density', cmap='Greys', line_color=None,&#13;
                     title='2010 Population Density per Square Mile of Land Area'&#13;
                     ))&#13;
   &#13;
<span class="ent">➋</span> hv.save(choropleth, 'choropleth.html', backend='bokeh')&#13;
   url = abspath('choropleth.html')&#13;
   webbrowser.open(url)</pre>&#13;
<p class="listing"><a id="ch011list5"/>Listing 11-5: Creating and plotting the choropleth map</p>&#13;
<p class="indent">According to the <span class="literal">holoviews</span> documentation, the <span class="literal">Polygons()</span> class creates a contiguous filled area in a 2D space as a list of polygon geometries. Name a variable <span class="literal">choropleth</span> and pass <span class="literal">Polygons()</span> the <span class="literal">counties</span> variable and the dictionary keys, including the <span class="literal">lons</span> and <span class="literal">lats</span> used to draw the county polygons. Also pass it the county names and population density keys. The <span class="literal">holoviews</span> hover tool will use this tuple, <span class="literal">('detailed name', 'County')</span>, to show you the full county name, such as <span class="literal">County: Claiborne County, Mississippi</span>, when you move the cursor around the map (<a href="ch11.xhtml#ch011fig7">Figure 11-7</a>).</p>&#13;
<div class="image"><img src="../images/fig11_07.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig7"/>Figure 11-7: Choropleth map with the hover feature active</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_261"/>Next, set the options for the map <span class="ent">➊</span>. First, permit use of a logarithmic color bar by setting the <span class="literal">logz</span> argument to <span class="literal">True</span>.</p>&#13;
<p class="indent">The <span class="literal">holoviews</span> window will come with a set of default tools such as pan, zoom, save, refresh, and so on (see the upper-right corner of <a href="ch11.xhtml#ch011fig7">Figure 11-7</a>). Use the <span class="literal">tools</span> argument to add the hover feature to this list. This allows you query the map and get both the county name and detailed information on the population density.</p>&#13;
<p class="indent">You’re not making a standard plot with an annotated <em>x</em>-axis and <em>y</em>-axis, so set these to <span class="literal">None</span>. Likewise, don’t show a grid or frame around the map.</p>&#13;
<p class="indent">Set the width and height of the map in pixels. You may want to adjust this for your monitor. Next set <span class="literal">colorbar</span> to <span class="literal">True</span> and place the <span class="literal">toolbar</span> at the top of the display.</p>&#13;
<p class="indent">Since you want to color the counties based on population density, set the <span class="literal">color_index</span> argument to <span class="literal">Density</span>, which represents the values in <span class="literal">popl_dens_dict</span>. For the fill colors, use the <span class="literal">Greys</span> <span class="literal">cmap</span>. If you want to use brighter colors, you can find a list of available colormaps at <em><a href="http://build.holoviews.org/user_guide/Colormaps.html">http://build.holoviews.org/user_guide/Colormaps.html</a></em>. Be sure to choose one with “bokeh” in the name. Finish the color scheme by selecting a line color for the county outlines. Good choices for a gray colormap are <span class="literal">None</span>, <span class="literal">'white'</span>, or <span class="literal">'black'</span>.</p>&#13;
<p class="indent">Complete the options by adding a title. The choropleth map is now ready for plotting.</p>&#13;
<p class="indent">To save your map in the current directory, use the <span class="literal">holoviews</span> <span class="literal">save()</span> method and pass it the <span class="literal">choropleth</span> variable, a file name with the <em>.html</em> extension, and the name of the plotting backend being used <span class="ent">➋</span>. As mentioned previously, <span class="literal">holoviews</span> is designed for use with a Jupyter Notebook. If you want the map to automatically pop up on your browser, first assign the full path to the saved map to a <span class="literal">url</span> variable. Then use the <span class="literal">webbrowser</span> module to open <span class="literal">url</span> and display the map (<a href="ch11.xhtml#ch011fig8">Figure 11-8</a>).</p>&#13;
<div class="image"><img src="../images/fig11_08.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig8"/>Figure 11-8: The 2010 population density choropleth map. Lighter colors represent lower population density</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/>You can use the toolbar at the top of the map to pan, zoom (using a box or lasso), save, refresh, or hover. The hover tool, shown in <a href="ch11.xhtml#ch011fig7">Figure 11-7</a>, will help you find the least populated counties in places where the map shading makes the difference hard to distinguish visually.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Box Zoom tool permits a quick view of a rectangular area but may stretch or squeeze the map axes. To preserve the map’s aspect ratio when zooming, use a combination of the Wheel Zoom and Pan tools.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec63"><strong><em>Planning the Escape</em></strong></h4>&#13;
<p class="noindent">The Chisos Mountains, an extinct supervolcano in Big Bend National Park, might be one of the best places on Earth to ride out a zombie apocalypse. Remote and fortress-like in appearance (<a href="ch11.xhtml#ch011fig9">Figure 11-9</a>), the mountains tower 4,000 feet above the surrounding desert plain, reaching a maximum elevation of almost 8,000 feet. At their heart lies a natural basin with park facilities, including a lodge, cabins, store, and restaurant. Fish and game are abundant in the area, desert springs provide fresh water, and the banks of the Rio Grande are suitable for farming.</p>&#13;
<div class="image"><img src="../images/fig11_09.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig9"/>Figure 11-9: The Chisos Mountains of west Texas (left) with 3D relief map representation (right)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/>With your choropleth map, you can quickly plan a route to this natural fortress far, far away. But first, you need to escape Atlanta. The shortest route out of the metropolitan area is a narrow passage squeezed between the cities of Birmingham and Montgomery in Alabama (<a href="ch11.xhtml#ch011fig10">Figure 11-10</a>). You can skirt the next big city, Jackson, Mississippi, by going either north or south. To choose the best route, however, you need to look farther ahead.</p>&#13;
<div class="image"><img src="../images/fig11_10.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig10"/>Figure 11-10: Escape from Atlanta</p>&#13;
<p class="indent">The southerly route around Jackson is shorter but forces the survivors to pass over the highly developed I-35 corridor, anchored by San Antonio in the south and Dallas–Fort Worth (DFW) in the north (<a href="ch11.xhtml#ch011fig11">Figure 11-11</a>). This creates a potentially dangerous choke point at Hill County, Texas (circled in <a href="ch11.xhtml#ch011fig11">Figure 11-11</a>).</p>&#13;
<div class="image"><img src="../images/fig11_11.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig11"/>Figure 11-11: The way west</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>Alternatively, the northerly route through the Red River Valley, between Oklahoma and Texas, would be longer but safer, especially if you took advantage of the navigable river. Once west of Fort Worth, the survivors could cross the river and turn south to salvation.</p>&#13;
<p class="indent">This type of planning would be even simpler if <span class="literal">holoviews</span> provided a slider tool that allowed you to interactively alter the color bar. For example, you could filter out or change the shading of counties by simply dragging your cursor up and down the legend. This would make it easier to find connected routes through the lowest population counties.</p>&#13;
<p class="indent">Unfortunately, a slider tool isn’t one of the <span class="literal">holowviews</span> window options. Since you know <span class="literal">pandas</span>, though, that won’t stop you. Simply add the following snippet of code after the line that prints the information at location 500:</p>&#13;
<pre>df.loc[df.Density &gt;= 65, ['Density']] = 1000</pre>&#13;
<p class="indent">This will change the population density values in the dataframe, setting those greater than or equal to 65 to a constant value of <span class="literal">1000</span>. Run the program again, and you’ll get the plot in <a href="ch11.xhtml#ch011fig12">Figure 11-12</a>. With the new values, the San Antonio–Austin–Dallas barrier becomes more apparent, as does the relative safety of the Red River Valley that forms the northern border of east Texas.</p>&#13;
<p class="indent">You may be wondering, where did the survivors go in the TV show? They went nowhere! They spent the first four seasons in the vicinity of Atlanta, first camping at Stone Mountain and then holed up in a prison near the fictional town of Woodbury (<a href="ch11.xhtml#ch011fig13">Figure 11-13</a>).<span epub:type="pagebreak" id="page_265"/></p>&#13;
<div class="image"><img src="../images/fig11_12.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig12"/>Figure 11-12: Counties with more than 65 people per square mile shaded black</p>&#13;
<div class="image"><img src="../images/fig11_13.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch011fig13"/>Figure 11-13: Location of Stone Mountain and the fictional town of Woodbury</p>&#13;
<p class="indent">Stone Mountain is less than 20 miles from downtown Atlanta and in DeKalb County, with 2,586 people per square mile. Woodbury (the real town of Senoia) is only 35 miles from downtown Atlanta and on the border of Coweta County, with 289 people per square mile, and Fayette County, with 549 people per square mile. No wonder these guys had so much trouble. If only there had been a data scientist in the group.</p>&#13;
<h3 class="h3" id="ch00lev1sec89"><strong>Summary</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_266"/>In this chapter, you got to work with the Python Data Analysis Library (<span class="literal">pandas</span>) and the <span class="literal">bokeh</span> and <span class="literal">holoviews</span> visualization modules. In the process, you did some real-world data wrangling to clean and link data from different sources.</p>&#13;
<h3 class="h3" id="ch00lev1sec90"><strong>Further Reading</strong></h3>&#13;
<p class="noindent">“If the Zombie Apocalypse Happens, Scientists Say You Should Run for the Hills” (Business Insider, 2017), by Kevin Loria, describes the application of standard disease models to infection rates in a theoretical zombie outbreak.</p>&#13;
<p class="indent">“What to Consider When Creating Choropleth Maps” (<em>Chartable</em>, 2018), by Lisa Charlotte Rost, provides useful guidelines for making choropleth maps. You can find it at <em><a href="https://blog.datawrapper.de/choroplethmaps/">https://blog.datawrapper.de/choroplethmaps/</a></em>.</p>&#13;
<p class="indent">“Muddy America: Color Balancing the Election Map—Infographic” (STEM Lounge, 2019) by Larry Weru, demonstrates ways to increase the useful detail in choropleth maps, using the iconic red-blue United States election map as an example.</p>&#13;
<p class="indent"><em>Python Data Science Handbook: Essential Tools for Working with Data</em> (O’Reilly Media, 2016), by Jake VanderPlas, is a thorough reference for important Python data science tools, including <span class="literal">pandas</span>.</p>&#13;
<p class="indent"><em>Beneath the Window: Early Ranch Life in the Big Bend Country</em> (Iron Mountain Press, 2003), by Patricia Wilson Clothier, is an engaging recollection of growing up in the early 20th century on a vast ranch in the Big Bend country of Texas, before it became a national park. It provides insight into how apocalypse survivors might deal with life in the harsh country.</p>&#13;
<p class="indent"><em>Game Theory: Real Tips for SURVIVING a Zombie Apocalypse (7 Days to Die)</em> (The Game Theorists, 2016) is a video on the best place <em>in the world</em> to escape a zombie apocalypse. Unlike <em>The Walking Dead</em>, the video assumes that the zombie virus can be transmitted by mosquitoes and ticks, and it selects the location with this in mind. It’s available online.</p>&#13;
<h3 class="h3" id="ch00lev1sec91"><strong>Challenge Project: Mapping US Population Change</strong></h3>&#13;
<p class="noindent">The US government will release population data from the 2020 census in 2021. However, less accurate, intercensal population estimates for 2019 are currently available. Use one of these, along with the 2010 data from Project 15, to generate a new choropleth map that captures population change, by county, over that time period.</p>&#13;
<p class="indent">Hint: you can subtract columns in <span class="literal">pandas</span> dataframes to generate the difference data, as demonstrated in the toy example that follows. The 2020 population values represent dummy data.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import pandas as pd</span>&#13;
&gt;&gt;&gt;&#13;
&gt;&gt;&gt; <span class="codestrong1"># Generate example population data by county:</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">pop_2010 = {'county': ['Autauga', 'Baldwin', 'Barbour', 'Bibb'],</span>&#13;
<span class="codestrong1">                'popl': [54571, 182265, 27457, 22915]}</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">pop_2020 = {'county': ['Autauga', 'Baldwin', 'Barbour', 'Bibb'],</span>&#13;
<span epub:type="pagebreak" id="page_267"/><span class="codestrong1">                'popl': [52910, 258321, 29073, 29881]}</span>&#13;
&gt;&gt;&gt;&#13;
&gt;&gt;&gt; <span class="codestrong1">df_2010 = pd.DataFrame(pop_2010</span>)&#13;
&gt;&gt;&gt; <span class="codestrong1">df_2020 = pd.DataFrame(pop_2020)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">df_diff = df_2020.copy()</span>  # Copy the 2020 dataframe to a new df&#13;
&gt;&gt;&gt; <span class="codestrong1">df_diff['diff'] = df_diff['popl'].sub(df_2010['popl'])</span>  # Subtract popl columns&#13;
&gt;&gt;&gt; <span class="codestrong1">print(df_diff.loc[:4, ['county', 'diff']])</span>&#13;
    county   diff&#13;
0  Autauga  -1661&#13;
1  Baldwin  76056&#13;
2  Barbour   1616&#13;
3     Bibb   6966</pre>&#13;
</body></html>