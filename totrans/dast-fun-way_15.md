# 15

图

![](img/chapterart.png)

图是计算机科学中的基础数据结构之一。它们在许多问题和编程任务中出现。与本书中其他旨在优化特定计算的数据结构不同，*图*的结构是由数据本身自然产生的。换句话说，图反映了它们所代表的数据。研究图算法为我们提供了洞察力，让我们了解到如何定义算法以利用数据固有的结构。

前面的章节集中讨论了如何构建数据结构来帮助算法；高层次的问题，如寻找一个值，激发并推动了有助于数据结构设计的想法。本章讨论的是相反的问题：图展示了数据的结构如何推动新算法的发展。换句话说，给定一个图形结构的数据，我们将研究如何创建利用这种数据的算法。本章讨论了三种图算法，它们利用图结构的不同方面：迪杰斯特拉算法用于最短路径，普里姆算法用于最小生成树，卡恩算法用于拓扑排序。

## 引入图

图由一组*节点*和一组*边*组成。如图 15-1 所示，每条边连接一对节点。这种结构类似于大量的现实世界系统，包括社交网络（节点是人，边是他们之间的联系）、交通网络（节点是城市，边表示路径）和计算机网络（节点是计算机，边表示它们之间的连接）。这种现实世界的类比使得图算法在可视化时更加有趣，简单的搜索变成了对城堡的细致探索或在城市繁忙小巷中疯狂奔跑。

![一个包含标记为 A 到 H 的节点并且节点之间有线条相连的图。](img/f15001.png)

图 15-1：一个带有无向边的图

图的边可以具有附加属性，以捕捉数据的现实世界复杂性，例如边是否是有向的。*无向边*，如图 15-1 中所示，表示双向关系，例如大多数道路和美好的友谊。*有向边*，如图 15-2 所示，类似于单行道，表示单向流动。为了表示无向访问，我们在节点之间使用一对有向边—每个方向一条。在社交语境中，有向边可以表示电视剧中青少年浪漫兴趣：从爱丽丝到鲍勃的边表示爱丽丝喜欢鲍勃，而鲍勃到爱丽丝的边缺失则说明了缺乏互惠的悲哀。

![一个包含标记为 A 到 H 的节点并且节点之间有箭头相连的图。某些节点之间由两条箭头连接，箭头指向相反的方向，某些节点仅由一条箭头连接。](img/f15002.png)

图 15-2：带有有向边的图

除了允许我们模拟单行街道或单相思之外，有向边还使我们能够模拟更抽象的问题，例如任务依赖关系。我们可以将一组任务表示为节点，并使用有向边表示任务之间的顺序依赖关系。通过这种方式，我们可以创建一个图来表示冲泡完美一杯咖啡所需的任务，如图 15-3 所示。节点包括加热水、称量豆子、研磨豆子和将水加入咖啡粉等步骤。边表示这些步骤之间的依赖关系。我们需要从“研磨豆子”节点到“将咖啡粉放入过滤器”节点添加一条有向边，以表明我们必须先研磨豆子。这两个步骤的顺序至关重要，任何尝试过用未研磨的豆子冲泡咖啡的人都会知道这一点。然而，我们不需要在“加热水”和“研磨豆子”之间添加任何方向的边。我们可以并行执行这两个任务。

![制作咖啡的六个任务，如称量豆子、填充水壶、加热水等。一个从“称量豆子”指向“研磨豆子”的箭头表示必要的顺序。](img/f15003.png)

图 15-3：使用图来表示任务操作顺序

边权重进一步增强了图的建模能力。*加权边*不仅捕捉节点之间的连接，还捕捉该连接的成本。例如，我们可以通过地点之间的距离对交通图中的边进行加权。我们可以通过一种亲密度度量（例如过去一个月内两节点之间的对话次数）来增强我们的社交网络。图 15-4 展示了我们的示例图以及加权边。

![一个图包含从 A 到 H 标记的节点，节点之间有连接线。每条连接线都标有一个数字。例如，A 和 C 之间的边的权重为 0.5。](img/f15004.png)

图 15-4：带有加权边的图

使用加权边和有向边的组合，使我们能够捕捉节点之间复杂的相互关系。通过一个构造良好的图，整个社交剧本可以通过节点和边来表示和演绎。

### 表示图

尽管图的抽象结构相对简单，但在计算机内存中表示节点和边的方式有多种。最常见的两种表示方法是*邻接矩阵*和*邻接表*。这两种表示法都可以处理有向边、无向边、加权边和无权边。与本书中的所有其他数据结构一样，这些结构之间的区别在于数据在内存中的存储方式，从而影响不同算法对其的访问方式。

邻接表表示法为每个节点存储一个单独的邻居列表。我们可以在节点复合数据结构中使用数组或链表来存储邻居：

```py
Node {
    String: name
    Array of Nodes: neighbors
}
```

我们甚至可以创建一个独立的边数据结构来存储关于边的辅助信息，例如它们的方向性或权重。以下示例中，我们还为每个节点提供了一个唯一的数字 ID，对应于该节点在父图数据结构中的索引：

```py
Edge {
    Integer: to_node
    Integer: from_node
    Float: weight
}

Node {
    String: name
    Integer: id
    Array of Edges: edges
}
```

在任何情况下，图本身将包含一个节点数组：

```py
Graph {
    Integer: num_nodes
    Array of Nodes: nodes
}
```

无论具体实现如何，我们都可以通过一个与节点本身相连接的列表来访问任何给定节点的邻居。图 15-5 展示了这种结构的一个例子。

对于有向边，一个节点的边列表或邻接节点列表仅包含那些在*离开*节点时可以访问的边。例如，节点 A 可能包含指向节点 B 的边，而节点 B 不包含指向节点 A 的边。

邻接列表提供了一种局部化的邻居关系视图，类似于社交网络等现实世界的情况。每个节点只跟踪它所连接的节点。同样，在社交网络中，每个人决定谁是他们的朋友，从而维护他们自己的连接列表。我们不需要一个独立的中央仓库来告诉我们谁是我们的朋友，并且我们可能无法全面了解其他人的朋友。可以说，我们甚至可能不知道哪些朋友（出边）实际上会把我们当作朋友（入边）。我们只了解自己发出的连接。

![左侧是一个图，节点用圆圈表示，边用线条表示。右侧是相同图的节点数组表示，包含边的列表。例如，节点 A 有一个邻居节点 B、C 和 D 的列表。](img/f15005b.png)

图 15-5：一个图（左）及其邻接列表表示（右）。每个节点存储一个邻接节点的列表。

相比之下，邻接矩阵将图表示为一个矩阵，如图 15-6 所示，每个节点对应一行一列。第 *i* 行，第 *j* 列的值表示从节点 *i* 到节点 *j* 的边的权重。零值表示没有这样的边。此表示方法使我们能够从单一的中央数据源直接查找任意两个节点之间是否存在边。

![图 15-5 中的图表示为矩阵。节点 A 的行全是零，除了 B、C 和 D 列的值为 1。](img/f15006.png)

图 15-6：图的邻接矩阵表示

这种图的全局视图出现在现实世界的情况中，当一个单一的规划者在查看整个网络时。例如，航空公司可能会使用航班路线的全局视图，其中节点是机场，边表示它们之间的航班，以规划新的服务。

虽然邻接图表示在某些情况下很有用，但在本章剩余部分我们将重点讨论邻接表表示。列表表示法与我们在其他数据结构中使用的基于指针的方法自然契合。此外，使用单独的节点数据结构还允许在存储辅助数据时提供额外的灵活性。

### 图形搜索

如果我们回顾第四章中的网页爬虫示例，假设我们在寻找与咖啡研磨机相关的信息，我们可以立即看到我们最喜欢的在线百科全书中的链接形成了一个主题图，每一页代表一个节点，每个超链接代表一条有向边。通过逐步探索每个节点，我们可以不断深入了解咖啡研磨机的世界，并将新的节点添加到我们未来要探索的主题列表中。这种探索方式构成了图形搜索的基础。

假设我们想在图中找到一个特定的节点。也许我们正在进行在线研究，寻找一个我们早已忘记名字的咖啡品牌。我们一次探索相关的网页（图形节点），在浏览完一个页面的信息后再转到下一个页面。正如我们在第四章中看到的，我们探索节点的顺序对搜索模式有很大的影响。通过使用栈数据结构来跟踪我们未来的探索选项，我们可以对图进行深度优先搜索。我们沿着单一路径越来越深入，直到遇到死胡同。然后我们回溯并尝试之前跳过的其他选项。如果我们改为使用队列来跟踪未来的搜索状态，我们就对节点进行广度优先搜索。我们会先检查离起始位置较近的节点，然后再逐步深入图中。当然，还有许多其他方式可以安排我们的搜索顺序。例如，最佳优先搜索根据排名函数对未来节点进行排序，优先探索得分较高的节点。在我们寻找新城市附近的咖啡店时，这种节点优先级排序可以避免我们浪费时间在居民区游荡，而是集中精力在商业区域。

无论顺序如何，通过一次探索一个节点来搜索图形的概念，展示了数据结构对算法的影响。我们使用节点之间的连接（边）来限制并引导探索。在接下来的几节中，我们将介绍一些常见的有用算法，它们正是这样工作的。

## 使用 Dijkstra 算法寻找最短路径

处理实际世界中的图时，可能最常见的任务就是找到两个节点之间的最短距离。假设我们第一次访问一个新城市。清晨，我们从酒店房间迷迷糊糊地走出来，时差反应严重，正在寻找饮品。作为称职的旅行者，我们已做了大量关于城市咖啡文化的研究，并创建了一个包含四家咖啡店的清单，打算在这个城市品尝一下。当电梯到达大堂时，我们拿出了一张城市街道地图，上面标明了酒店和那些咖啡店的位置。现在是时候决定如何前往我们清单上的咖啡店了。

**戴克斯特拉算法**（*Dijkstra’s algorithm*）由计算机科学家埃兹格尔·W·戴克斯特拉（Edsger W. Dijkstra）发明，用于从任何给定的起始节点找到图中到所有其他节点的最短路径。它可以应用于有向图、无向图、加权图或无加权图。唯一的限制是所有边的权重必须是非负的。通过添加边，路径总长度永远不会减少。在我们以咖啡为主题的观光示例中，我们寻找从酒店到每个咖啡店的最短路径。如图 15-7 所示，节点代表街道交叉口或街道上的商店。加权、无向的边表示这些点之间的道路距离。

![顶部显示一张地图，包含一个酒店、四家咖啡店和四个街道交叉口。底部的图形显示了该图的表示形式。酒店（a）和第一个交叉口（b）之间的边的权重为 11，表示距离。](img/f15007b.png)

图 15-7：上面显示的是一张带有相应距离的地图（顶部），下面则是该地图的加权图表示（底部）。

我们的目标是找到从起始节点到每个咖啡店节点的最短路径。交叉口节点本身不是目标节点，而是允许我们在不同的街道上分支的途径。

**戴克斯特拉算法**通过保持一组未访问的节点，并不断更新每个未访问节点的*临时*距离来工作。在每次迭代中，我们访问距离最近的未访问节点。这样做之后，我们从未访问节点集中移除这个新节点，并更新到它的每个未访问邻居的距离。具体来说，我们检查新节点的邻居，并询问是否已经找到到每个邻居的更短路径。我们通过将当前节点的距离与到邻居的距离（边的权重）相加来计算新提出路径的长度。如果这个新距离比到目前为止看到的最佳距离更短，则更新该距离。

```py
Dijkstras(Graph: G, Integer: from_node_index):
  ❶ Array: distance = inf for each node id in G
    Array: last = -1 for each node in G
    Set: unvisited = set of all node indices in G
    distance[from_node_index] = 0.0

  ❷ WHILE unvisited is NOT empty:
      ❸ Integer: next_index = the node index in unvisited
                              with the minimal distance
        Node: current = G.nodes[next_index]
        Remove next_index from unvisited

      ❹ FOR EACH edge IN current.edges:
          ❺ Float: new_dist = distance[edge.from_node] + 
                              edge.weight
          ❻ IF new_dist < distance[edge.to_node]:
                distance[edge.to_node] = new_dist
                last[edge.to_node] = edge.from_node
```

代码开始时会创建一系列辅助数据结构❶，包括到每个节点的距离数组（`distance`）、表示访问某个节点前的最后一个节点的数组（`last`）以及未访问节点的集合（`unvisited`）。然后，代码会逐一处理未访问的节点。`WHILE`循环会一直迭代，直到未访问节点集合为空❷。在每次迭代中，代码选择距离最小的节点并将其从未访问集合中移除❸。`FOR`循环会遍历该节点的每个邻居❹，计算通过当前节点到该邻居的距离❺，并在找到更短路径时更新`distance`和`last`数组❻。

图 15-8 展示了从图 15-4 的加权图中节点 A 开始的最短路径搜索示例。圈出的节点是当前正在被检查的节点。灰色的节点和列表项表示已经从未访问列表中移除的节点，因此不再参与考虑。

对于图 15-8 中的搜索，我们从所有距离设置为无穷大开始，除了节点 A，它的距离被设为零（图 15-8(1)）。这种起始配置对应于我们关于最佳路径的初步了解。我们已经在节点 A，所以从那里到达的最佳路径是显而易见的。由于我们还没有找到到其他节点的路径，它们可能距离我们有任何距离。我们还保持每个节点的前驱节点的信息。`Last`列表示前驱节点。这个信息使我们能够追踪路径的回溯。虽然并非所有的应用都需要重建路径，但我们的咖啡搜索确实需要。要找到到咖啡的最短距离，如果我们没有找到实际路径，那就毫无意义了。为了构造到节点 F 的路径，我们沿着最后指针向回追踪，直到到达节点 A。

搜索从图 15-8(2)所示开始，通过选择距离最小的节点（节点 A），将其从未访问列表中移除，并检查其邻居。对于 A 的每个邻居，我们测试通过 A 到达该邻居的路径是否比迄今为止发现的任何路径都更短。由于到节点 A 的距离为零，因此通过 A 到达每个邻居的距离将等于相应的边权重。每次我们更新一个未访问节点的距离时，我们还会更新返回指针，以反映迄今为止的最佳路径。现在有三个节点指向 A（图 15-8(2)）。

搜索过程继续进行，选择下一个最接近的、未访问的节点。在这种情况下，它可以是 C 或 D。我们使用节点在列表中的顺序来打破平局：节点 C 获胜！然后，我们考虑 C 的邻居并更新它们的最佳距离（图 15-8(3)）。请记住，这些距离代表从起始节点到当前节点的最佳总距离。新的距离是到 C 的距离与从 C 到每个邻居的距离之和。

![九个子图展示了 Dijkstra 算法的每一步。在子图 2 中，节点 A 被灰显并圈出。每个图的右侧表格显示了从每个节点到达当前最佳距离以及沿着该路径的最后一个节点。](img/f15008.png)

图 15-8：Dijkstra 算法在加权图上的示例

搜索继续前进到节点 D——新的未访问节点，且具有最小距离（图 15-8(4)）。在检查节点 D 的邻居时，我们发现到节点 E 和 F 的新最短距离。节点 E 特别有趣，因为我们之前已经通过 C 有了到 E 的候选路径。我们可以从 A 到 C，再到 E，距离为 1.0。然而，这并不是最佳路径。我们的搜索揭示了一条新的路径，通过 D，这条路径稍微短一些，总距离为 0.9。我们更新了潜在距离和反向指针。现在，我们到 E 的最佳路径是通过 D。接下来，我们继续查看下一个最接近的未访问节点，节点 F！

搜索继续遍历剩余的节点，但没有出现其他有趣的情况。剩下的节点都位于最短路径的末端，不提供更短路径的机会。例如，在考虑节点 E 的邻居时（图 15-8(6)），我们检查了节点 C 和 D。当通过 E 时，到任一节点的距离为 1.4，比我们已发现的路径更长。事实上，C 和 D 都已经被访问过，因此我们甚至不会考虑它们。在考虑节点 B、H 和 G 时，类似的逻辑也适用，如 图 15-8(7)、15-8(8) 和 15-8(9) 所示。由于这些节点的邻居都已经被访问过，我们不会再考虑它们。

在检查 Dijkstra 算法如何遍历图并找到最短路径时，我们可以清晰地看到数据结构与算法之间的相互关系。像 Dijkstra 这样的最短路径算法之所以必要，是因为问题本身的结构。如果我们能够轻松地从任何一个节点跳到任何其他节点，那么就不需要沿着边缘寻找路径了。这就像现实世界中的瞬间传送：从酒店大厅传送到目标咖啡店——虽然方便，但在物理世界的结构中并不允许。因此，在寻找这些最短路径时，我们需要遵守图的结构本身。

## 使用 Prim 算法寻找最小生成树

寻找图的*最小生成树*问题提供了另一个示例，说明了图数据的结构如何使我们能够提出新问题，从而创造出适合回答这些问题的新算法。无向图的最小生成树是一个包含最少边的集合，使得所有节点都能连接起来（如果可能的话）。我们可以将这些树类比为一位精打细算的城市规划师，试图确定应该铺设哪些道路。为了确保任何人都能通过一条铺设好的路从一个地方（节点）到达另一个地方（节点），所需的最小道路集合是什么？如果边有权重，例如距离或铺设道路的成本，我们将概念扩展为找到一个最小化总权重的集合：*最小成本生成树*是一个最小化总权重的边集合，能够连接所有节点。

寻找最小生成树的一种方法是*普里姆算法*，该算法由包括计算机科学家 R. C. 普里姆和数学家 Vojtˇech Jarník 在内的多位人士独立提出。该算法与上一节中的 Dijkstra 算法非常相似，通过遍历未访问的节点集并一次构建一个最小生成树。我们从一个未访问的所有节点集合开始，随机选择一个进行访问。这个访问过的节点成为我们最小生成树的起始节点。然后，在每次迭代中，我们找到一个未访问节点，并与我们之前访问过的*任何*节点进行比较，选择具有最小边权重的未访问节点。我们的问题是：“哪个节点最接近我们集合的边缘，因此可以以最小成本添加？”我们将这个新节点从未访问节点集合中移除，并将相应的边添加到我们的最小成本生成树中。我们不断添加节点和边，每次迭代添加一个，直到所有节点都被访问。

我们可以将普里姆算法想象为一家被聘请来在群岛之间架设桥梁的建筑公司。工人们从一个岛屿开始，向外扩展，连接越来越多的岛屿。在每个步骤中，他们选择与当前连接集中的岛屿最接近的岛屿。桥梁的一端坐落在连接集中的岛屿上，另一端坐落在连接集外的岛屿上（将新的岛屿引入连接集）。通过始终从连接集中的岛屿开始建造新桥，工人们能够使用现有的桥梁将设备移动到起始岛屿。而通过始终在连接集外的岛屿上结束桥梁，工人们在每个阶段都扩大了连接集的覆盖范围。

我们可以通过跟踪额外信息来简化算法的代码。在每一步中，我们保持一份到每个节点的最佳边（包括权重）的列表。每次从未访问节点集中移除一个新节点时，我们检查该节点的未访问邻居，并检查是否有更好的（即，低成本的）边指向它们的邻居。如果有，我们更新邻居在列表中的条目，替换为新的边和权重。

```py
Prims(Graph G):
  ❶ Array: distance = inf for each node in G
    Array: last = -1 for each node in G
    Set: unvisited = set of all node indices in G
    Set: mst_edges = empty set

  ❷ WHILE unvisited is NOT empty:
      ❸ Integer: next_id = the node index in unvisited with
                           the minimal distance
      ❹ IF last[next_id] != -1:
            Add the edge between last[next_id] and
            next_id to mst_edges
        Remove next_id from unvisited

        Node: current = G.nodes[next_id]
      ❺ FOR EACH edge IN current.edges:
            IF edge.to_node is in unvisited:
                IF edge.weight < distance[edge.to_node]:
                    distance[edge.to_node] = edge.weight 
                    last[edge.to_node] = current.id
    return mst_edges
```

代码首先创建一系列辅助数据结构 ❶，包括到每个节点的距离数组（`distance`）、指示访问给定节点之前最后访问节点的数组（`last`）、未访问节点集合（`unvisited`）以及最小生成树的最终边集（`mst_edges`）。与 Dijkstra 算法一样，伪代码（以及我们稍后讨论的图）使用了列表和集合的组合来做说明。我们可以通过将未访问节点存储在一个按距离排序的最小堆中来更高效地实现算法。目前，我们将列出所有值，以便清楚地说明正在发生的过程。

代码然后像 Dijkstra 算法一样执行，逐一处理未访问节点。`WHILE` 循环在未访问节点集为空时停止 ❷。在每次迭代中，选择距离任何已访问节点最短的节点，并将其从未访问节点集中移除 ❸。代码检查是否存在指向该节点的入边，因为第一个访问的节点将没有入边 ❹，并将相应的边添加到最小生成树中。添加新节点后，`FOR` 循环遍历每个邻居 ❺，检查邻居是否未访问，如果是，则检查其到当前节点的距离。在此情况下，距离就是边的权重。代码最后返回组成最小生成树的边集。

考虑当我们在图 15-4 中的加权图上运行 Prim 算法时会发生什么，正如图 15-9 所示。我们从所有边设置为 null（尚未找到任何边）以及所有“最佳”距离为无穷大开始。为了简化，我们将按节点的字母顺序打破平局。

首先，我们从未访问节点集中移除第一个节点 A。然后，我们考虑 A 的所有邻居，并检查是否存在从 A 到该邻居的低成本边。鉴于我们当前的最短距离都为无穷大，这并不难。我们为 A 的所有邻居找到低成本边： (A, B)、(A, C) 和 (A, D)。图 15-9(1) 显示了这一新状态。

在第二轮迭代中，我们在未访问节点集合中找到了两个潜在节点：C 和 D。使用字母顺序打破平局时，我们选择了 C。我们将 C 从未访问节点集合中移除，并将边（A, C）添加到最小成本生成树中。在检查 C 的未访问邻居时，我们发现通往节点 E 和 G 的边是更好的候选边（见图 15-9(2)）。

下一个最接近的节点是 D。我们将其从未访问节点集合中移除，并将边（A, D）添加到最小成本生成树中。当我们检查 D 的未访问邻居时，发现通往节点 E 和 F 的边具有更低的成本（见图 15-9(3)）。此时，通向节点 E 的最佳候选边来自节点 D，而非节点 C。

算法继续处理未访问节点集合中的其余节点。接下来，我们访问节点 F，添加边（D, F），如图 15-9(4)所示。然后，如图 15-9(5)所示，我们添加节点 E 和边（D, E）。算法完成时，按顺序添加节点 H、B 和 G。在每一步中，我们都添加了目前为止看到的最佳边：（F, H）、（F, B）和（C, G）。最后三步分别如图 15-9(6)、图 15-9(7) 和 图 15-9(8) 所示。

![八个子图展示了普里姆算法的每一步。在子图 1 中，节点 A 被灰色标出。每个图的右侧表格显示了当前每个剩余节点的最佳距离及相应的边。](img/f15009.png)

图 15-9：普里姆算法在加权图上的示例

普里姆算法不关心从起始节点到其他节点的总路径长度。我们只关心将新节点添加到已访问节点集合的成本——即将该节点连接到已访问集合中任何其他节点的边权重。我们并不是在优化节点间的最终行驶时间，而是在最小化铺设道路或建设新桥的成本。

如果我们在打破平局时随机选择而不是按字母顺序排列，会怎样？在决定从我们的未访问节点集合中选择节点 D 或 E 时（见图 15-9(2)），我们本可以选择任何一个。如果我们选择 E 而不是 D，我们会发现连接 D 的边权重较低。算法会通过 E 而不是 A 将节点 D 链接进图中。这意味着我们可以为相同的图找到不同的最小成本生成树。多个不同的树可能具有相同的成本。普里姆算法只保证我们找到其中一棵具有最小成本的树。

## 使用卡恩算法的拓扑排序

我们的最后一个图算法示例使用*有向无环图*（*DAG*）的边来对节点进行排序。 有向无环图是一种具有有向边的图，其边的排列方式使得图中没有*环*，即没有返回到同一节点的路径，如图 15-10 所示。环在现实世界的道路网络中至关重要。如果道路被建造得使得我们可以从公寓到达我们最喜欢的咖啡馆，但却永远无法返回，那将是非常糟糕的。然而，这正是无环图的特性——任何节点的出边路径永远不会返回到该节点。

![图中有从 A 到 F 标记的节点，并且节点之间有箭头链接。A 节点连接到 C 节点和 D 节点。](img/f15010.png)

图 15-10：有向无环图

我们可以使用有向边来表示节点的顺序。如果图中有一条从 A 到 B 的边，则节点 A 必须出现在节点 B 之前。我们在章节开头的咖啡冲泡示例中以这种方式对节点进行了排序：每个节点代表一个步骤，每条边表示一个步骤对下一个步骤的依赖关系。冲泡咖啡的人必须先执行某个步骤，然后才能进行后续的步骤。这些类型的依赖关系在计算机科学和日常生活中都很常见。一个按照边的顺序对节点进行排序的算法称为*拓扑排序*。

计算机科学家 Arthur B. Kahn 开发了一种方法，现在称为*Kahn 算法*，用于对表示事件的有向无环图执行拓扑排序。该算法通过找到没有入边的节点，将它们从待处理节点列表中移除，加入已排序的列表，然后删除该节点的出边来操作。算法重复此过程，直到所有节点都被加入已排序列表中。直观地说，这种排序方法类似于我们在现实世界中执行复杂任务的方式。我们从一个可以完成的子任务开始——即没有依赖关系的任务。我们完成该子任务后，再选择另一个任务。如果某个子任务要求我们在完成某个尚未完成的任务后才能进行，它必须在列表中等待，直到我们完成所有依赖任务。

在实现 Kahn 算法时，我们不需要真正从图中删除边。只需保持一个辅助数组来计算每个节点的入边数量，并修改这些计数即可。

```py
Kahns(Graph G):
  ❶ Array: sorted = empty array to store result
    Array: count = 0 for each node in G
    Stack: next = empty stack for the next nodes to add

    # Count the incoming edges.
  ❷ FOR EACH node IN G.nodes:
         FOR EACH edge IN node.edges:
            count[edge.to_node] = count[edge.to_node] + 1

    # Find the initial nodes without incoming edges.
  ❸ FOR EACH node IN G.nodes:
        IF count[node.id] == 0:
            next.Push(node)

    # Iteratively process the remaining nodes without 
    # incoming connections.
  ❹ WHILE NOT next.IsEmpty():
        Node: current = next.Pop()
        Append current to the end of sorted
      ❺ FOR EACH edge IN current.edges:
            count[edge.to_node] = count[edge.to_node] - 1
          ❻ IF count[edge.to_node] == 0:
                next.Push(G.nodes[edge.to_node])

    return sorted
```

代码首先创建多个辅助数据结构❶，包括一个用于保存已排序节点列表的数组（`sorted`），一个存储每个节点入边数量的数组（`count`），以及一个用于存放下一个要加入`sorted`的节点的栈（`next`）。代码使用一对嵌套的`FOR`循环遍历节点（外层循环）和每个节点的边（内层循环）来计算每个节点的入边数量❷。然后，通过遍历`count`数组，找到没有入边的节点，并将其插入`next`中❸。

代码随后使用`WHILE`循环处理`next`栈，直到栈为空 ❹。在每次迭代中，代码从栈中弹出一个节点并将其添加到`sorted`数组的末尾。`FOR`循环遍历节点的边，并减少每个邻居的计数（有效地删除传入边） ❺。任何邻居的传入计数为零时，将其添加到`next`中 ❻。最后，代码返回排序后的节点数组。

如果我们的图包含循环，排序后的列表将不完整。我们可能需要在函数的末尾添加额外的检查，测试排序列表中的元素数量是否等于图中的节点数。

考虑对来自图 15-10 的图运行此算法，如图 15-11 所示。我们首先统计每个节点的传入边数（显示为每个节点旁边的数字），并确定节点 A 是唯一没有传入边的节点（图 15-11(1)）。然后，卡恩算法将 A 添加到排序列表，并删除它的传出边（通过减少相应的计数），如图 15-11(2)所示。

![七个子图展示了拓扑排序的每一步。在子图 2 中，节点 A 被灰色显示。接下来的列表包含节点 C，排序后的列表包含节点 A。](img/f15011.png)

图 15-11：对有向无环图进行拓扑排序

我们继续在节点 C 上执行算法（图 15-11(3)），此时它没有任何传入边。我们在处理节点 A 时移除了唯一的传入边。我们将 C 从待处理节点列表（栈`next`）中移除，删除其边并将其添加到排序列表的末尾。在这个过程中，节点 E 没有任何传入邻居。E 被加入到我们的栈中。

排序继续处理列表的其余部分。在处理节点 E 时，我们删除到节点 D 的最后一条传入边，使其成为下一个要处理的节点（图 15-11(4)）。然后，排序将 D、F 和 B 依次添加到排序列表中，如图 15-11(5)、图 15-11(6) 和 图 15-11(7)所示。

卡恩算法展示了有向图中有向边的实用性，以及我们如何设计一个算法来处理这些边。边的方向性进一步限制了我们探索节点的方式。

## 为什么这很重要

图形在计算机科学中无处不在。它们的结构使其能够模拟各种真实世界的现象，从街道到社交网络或计算机网络，再到一系列复杂的任务。图形在路径规划和确定编译程序源代码顺序等任务中非常有用。为了处理这些数据结构，已经设计了无数算法，执行诸如图形搜索、确定最小生成树或确定图形的最大流等任务。我们甚至可以为这种具有巨大影响力的数据结构编写一本完整的书籍。

然而，针对本章的目的，我们关注的是数据结构与操作其上的算法之间的紧密耦合。数据的图形结构引发了新问题，例如寻找最小生成树，从而也催生了新的算法。反过来，算法则利用数据的图形结构，遍历边缘并从一个节点探索到另一个节点。这种相互作用展示了在定义问题和新解决方案时，理解数据结构的重要性。
