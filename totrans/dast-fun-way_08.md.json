["```py\nLinearScanClosestNeighbor(Array: A, Float: target, Function: dist):\n    Integer: N = length(A)\n  ❶ IF N == 0:\n        return null\n\n  ❷ Float: candidate = A[0]\n    Float: closest_distance = dist(target, candidate)\n\n    Integer: i = 1\n  ❸ WHILE i < N:\n        Float: current_distance = dist(target, A[i])\n      ❹ IF current_distance < closest_distance:\n            closest_distance = current_distance\n            candidate = A[i]\n        i = i + 1\n  ❺ return candidate\n```", "```py\nPoint {\n    Float: x\n    Float: y\n}\n```", "```py\nx_bin_width = (x_end – x_start) / num_x_bins\ny_bin_width = (y_end – y_start) / num_y_bins\n```", "```py\nGrid {\n    Integer: num_x_bins\n    Integer: num_y_bins\n    Float: x_start\n    Float: x_end\n Float: x_bin_width\n    Float: y_start\n    Float: y_end\n    Float: y_bin_width\n    Matrix of GridPoints: bins\n}\n```", "```py\nxbin = Floor((x – x_start) / x_bin_width)\nybin = Floor((y – y_start) / y_bin_width)\n```", "```py\nGridPoint {\n    Float: x\n    Float: y\n    GridPoint: next\n}\n```", "```py\nGridInsert(Grid: g, Float: x, Float: y):\n  ❶ Integer: xbin = Floor((x - g.x_start) / g.x_bin_width)\n    Integer: ybin = Floor((y - g.y_start) / g.y_bin_width)\n\n    # Check that the point is within the grid.\n  ❷ IF xbin < 0 OR xbin >= g.num_x_bins:\n        return False\n    IF ybin < 0 OR ybin >= g.num_y_bins:\n        return False\n\n    # Add the point to the front of the list. \n  ❸ GridPoint: next_point = g.bins[xbin][ybin]\n    g.bins[xbin][ybin] = GridPoint(x, y)\n    g.bins[xbin][ybin].next = next_point\n\n  ❹ return True\n```", "```py\napprox_equal(Float: x1, Float: y1, Float: x2, Float: y2):\n    IF abs(x1 – x2) > threshold:\n        return False\n    IF abs(y1 – y2) > threshold:\n        return False\n    return True\n```", "```py\nGridDelete(Grid: g, Float: x, Float: y):\n  ❶ Integer: xbin = Floor((x - g.x_start) / g.x_bin_width)\n    Integer: ybin = Floor((y - g.y_start) / g.y_bin_width)\n\n    # Check that the point is within the grid.\n  ❷ IF xbin < 0 OR xbin >= g.num_x_bins:\n        return False\n    IF ybin < 0 OR ybin >= g.num_y_bins:\n        return False\n\n    # Check if the bin is empty.\n  ❸ IF g.bins[xbin][ybin] == null:\n        return False\n\n    # Find the first matching point and remove it.\n  ❹ GridPoint: current = g.bins[xbin][ybin]\n    GridPoint: previous = null\n    WHILE current != null:\n      ❺ IF approx_equal(x, y, current.x, current.y):\n          ❻ IF previous == null:\n                g.bins[xbin][ybin] = current.next\n            ELSE:\n                previous.next = current.next\n return True\n      ❼ previous = current\n        current = current.next\n    return False\n```", "```py\neuclidean_dist(Float: x1, Float: y1, Float: x2, Float: y2):\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))\n```", "```py\nx_min = x_start + xbin * x_bin_width\nx_max = x_start + (xbin + 1) * x_bin_width\ny_min = y_start + ybin * y_bin_width\ny_max = y_start + (ybin + 1) * y_bin_width\n```", "```py\nMinDistToBin(Grid: g, Integer: xbin, Integer: ybin, Float: x, Float: y):\n    # Check that the bin is valid.\n  ❶ IF xbin < 0 OR xbin >= g.num_x_bins:\n        return Inf\n    IF ybin < 0 OR ybin >= g.num_y_bins:\n        return Inf\n\n  ❷ Float: x_min = g.x_start + xbin * g.x_bin_width\n    Float: x_max = g.x_start + (xbin + 1) * g.x_bin_width\n    Float: x_dist = 0\n    IF x < x_min:\n      x_dist = x_min - x\n    IF x > x_max:\n      x_dist = x - x_max\n\n  ❸ Float: y_min = g.y_start + ybin * g.y_bin_width\n    Float: y_max = g.y_start + (ybin + 1) * g.y_bin_width\n    Float: y_dist = 0\n    IF y < y_min:\n      y_dist = y_min - y\n    IF y > y_max:\n      y_dist = y - y_max\n    return sqrt(x_dist*x_dist + y_dist*y_dist)\n```", "```py\nGridLinearScanNN(Grid: g, Float: x, Float: y): \n  ❶ Float: best_dist = Inf\n    GridPoint: best_candidate = null\n\n    Integer: xbin = 0\n  ❷ WHILE xbin < g.num_x_bins:\n        Integer: ybin = 0\n        WHILE ybin < g.num_y_bins:\n\n            # Check if we need to process the bin.\n          ❸ IF MinDistToBin(g, xbin, ybin, x, y) < best_dist:\n\n                # Check every point in the bin's linked list.\n                GridPoint: current = g.bins[xbin][ybin]\n              ❹ WHILE current != null:\n                    Float: dist = euclidean_dist(x, y, current.x, current.y)\n                  ❺ IF dist < best_dist:\n                        best_dist = dist\n                        best_candidate = current\n                    current = current.next\n            ybin = ybin + 1\n        xbin = xbin + 1\n  ❻ return best_candidate\n```", "```py\nGridCheckBin(Grid: g, Integer: xbin, Integer: ybin, \n             Float: x, Float: y, Float: threshold):\n    # Check that it is a valid bin and within the pruning threshold.\n  ❶ IF xbin < 0 OR xbin >= g.num_x_bins:\n        return null\n    IF ybin < 0 OR ybin >= g.num_y_bins:\n        return null\n\n # Check each of the points in the bin one by one.\n    GridPoint: best_candidate = null\n  ❷ Float: best_dist = threshold\n    GridPoint: current = g.bins[xbin][ybin]\n  ❸ WHILE current != null:\n      ❹ Float: dist = euclidean_dist(x, y, current.x, current.y)\n        IF dist < best_dist:\n            best_dist = dist\n            best_candidate = current\n        current = current.next\n  ❺ return best_candidate\n```", "```py\nGridSearchExpanding(Grid: g, Float: x, Float: y):\n    Float: best_d = Inf\n    GridPoint: best_pt = null\n\n  ❶ # Find the starting x and y bins for our search.\n    Integer: xb = Floor((x - g.x_start) / g.x_bin_width)\n    IF xb < 0:\n        xb = 0\n    IF xb >= g.num_x_bins:\n        xb = g.num_x_bins - 1\n\n    Integer: yb = Floor((y - g.y_start) / g.y_bin_width)\n    IF yb < 0:\n        yb = 0\n    IF yb >= g.num_y_bins:\n        yb = g.num_y_bins - 1\n\n Integer: steps = 0\n    Boolean: explore = True\n  ❷ WHILE explore:\n        explore = False\n\n      ❸ Integer: xoff = -steps\n        WHILE xoff <= steps:\n          ❹ Integer: yoff = steps - abs(xoff)\n          ❺ IF MinDistToBin(g, xb + xoff, yb - yoff, x, y) < best_d:\n              ❻ GridPoint: pt = GridCheckBin(g, xb + xoff, yb - yoff, \n                                             x, y, best_d)\n                IF pt != null:\n                    best_d = euclidean_dist(x, y, pt.x, pt.y)\n                    best_pt = pt\n              ❼ explore = True\n\n          ❽ IF (MinDistToBin(g, xb + xoff, yb + yoff, x, y) < best_d\n                AND yoff != 0):\n                GridPoint: pt = GridCheckBin(g, xb + xoff, yb + yoff, \n                                             x, y, best_d)\n                IF pt != null:\n                    best_d = euclidean_dist(x, y, pt.x, pt.y)\n                    best_pt = pt\n              ❾ explore = True\n\n            xoff = xoff + 1\n        steps = steps + 1\n    return best_pt\n```"]