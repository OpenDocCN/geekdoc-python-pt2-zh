<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0801" class="chapter" epub:type="chapter" id="ch08" role="doc-chapter">
<header id="header0801">
<h1 class="cn"><span aria-label=" Page 135. " class="page" epub:type="pagebreak" id="p135" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch08">8</a></h1>
<h1 class="ct">Autostereograms</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">Stare at <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-1">Figure 8-1</a> for a minute. Do you see anything other than random dots? <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-1">Figure 8-1</a> is an <span class="idx" data-term="illusions"/><span class="idx" data-term="autostereograms"/><i>autostereogram</i>, a two-dimensional image that creates the illusion of three dimensions. Autostereograms usually consist of repeating patterns that resolve into three dimensions on closer inspection. If you can’t see any sort of image, don’t worry; it took me a while and a bit of experimentation before I could. (If you aren’t having any luck with the version printed in this book, try the color version in the <i>images</i> folder of the book’s GitHub repository. The footnote to the caption reveals what you should see.)</p>
<p><span aria-label=" Page 136. " class="page" epub:type="pagebreak" id="p136" role="doc-pagebreak"/>In this project, you’ll use Python to create autostereograms. Here are some of the concepts covered in this project:</p>
<ul style="list-style-type:none">
<li class="blf">• Linear spacing and depth perception</li>
<li class="bl">• Depth maps</li>
<li class="bl">• Creating and editing images using <code>Pillow</code></li>
<li class="bll">• Drawing into images using <code>Pillow</code></li>
</ul>
<figure class="figure" id="fig8-1">
<p class="fig"><img alt="" height="400" src="images/nsp-venkitachalam503045-f08001.jpg" style="width:95%; height:auto;" width="800"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-1:</span> A puzzling <span class="idx" data-level1="example" data-term="autostereograms"/>image that might gnaw at you<a class="fnref" epub:type="noteref" href="nsp-venkitachalam503045-0021.xhtml#fn1" id="fn1r" role="doc-noteref">1</a></p>
</figcaption>
</figure>
<p>The autostereograms you’ll generate in this project are designed for “wall-eyed” viewing. The best way to see them is to focus your eyes on a point behind the image (such as a wall). Almost magically, once you perceive something in the patterns, your eyes should automatically bring it into focus, and when the three-dimensional image “locks in,” you’ll have a hard time shaking it off. (If you’re still having trouble viewing the image, see Gene Levin’s article “How to View Stereograms and Viewing Practice”<a class="fnref" epub:type="noteref" href="nsp-venkitachalam503045-0021.xhtml#fn2" id="fn2r" role="doc-noteref">2</a> for help.)</p>
<section>
<h2 class="ah" id="ah1001"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1001">How It Works</a></h2>
<p class="paft">An autostereogram starts as an image with a repeating tiled pattern. The hidden 3D image is embedded into it by changing the <span class="idx" data-term="linear spacing"/><span class="idx" data-level1="linear spacing" data-term="autostereograms"/>linear spacing between the repeating patterns, thereby creating the illusion of depth. When you look at repeating patterns in an autostereogram, your brain can interpret the spacing as depth information, especially if there are multiple patterns with different <span class="idx" data-level1="spacing" data-term="autostereograms"/>spacing.</p>
<section>
<h3 class="bh" id="bh1001"><span aria-label=" Page 137. " class="page" epub:type="pagebreak" id="p137" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1001">Perceiving Depth in an Autostereogram</a></h3>
<p class="paft">When your eyes converge at an imaginary point behind the image, your brain matches the points seen by your left eye with a different group seen by your right eye, and you see these points lying on a plane behind the image. The perceived distance to this plane depends on the amount of spacing in the pattern. For example, <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-2">Figure 8-2</a> shows three rows of <i>A</i>s. The <i>A</i>s are equidistant within each row, but their horizontal spacing increases from top to bottom.</p>
<figure class="figure" id="fig8-2">
<p class="fig"><img alt="" height="276" src="images/nsp-venkitachalam503045-f08002.jpg" width="597"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-2:</span> Linear <span class="idx" data-term="linear spacing"/>spacing and <span class="idx" data-level1="linear spacing" data-term="autostereograms"/><span class="idx" data-term="depth perception"/>depth <span class="idx" data-level1="depth perception" data-term="autostereograms"/>perception</p>
</figcaption>
</figure>
<p>When this image is viewed “wall-eyed,” the top row in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-2">Figure 8-2</a> should appear to be behind the paper, the middle row should look like it’s a little behind the first row, and the bottom row should appear farthest from your eye. The text that says <i>floating text</i> should appear to “float” on top of these rows.</p>
<p>Why does your brain interpret the spacing between these <span class="idx" data-level1="repeating patterns" data-term="autostereograms"/>patterns as depth? Normally, when you look at a distant object, your eyes work together to focus and converge at the same point, with both eyes rotating inward to point directly at the object. But when viewing a “<span class="idx" data-level1="wall-eyed viewing" data-term="autostereograms"/>wall-eyed” autostereogram, focus and convergence happen at different locations. Your eyes focus on the autostereogram, but your brain sees the repeated patterns as coming from the same virtual (imaginary) object, and your eyes converge on a point behind the image, as shown in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-3">Figure 8-3</a>. This combination of decoupled focus and convergence allows you to see depth in an autostereogram.</p>
<figure class="figure" id="fig8-3">
<p class="fig"><span aria-label=" Page 138. " class="page" epub:type="pagebreak" id="p138" role="doc-pagebreak"/><img alt="" height="998" src="images/nsp-venkitachalam503045-f08003.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-3:</span> Seeing depth in autostereograms</p>
</figcaption>
</figure>
<p>The <span class="idx" data-level1="depth perception" data-term="autostereograms"/>perceived depth of the autostereogram depends on the horizontal spacing of pixels. Because the first row in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-2">Figure 8-2</a> has the closest spacing, it appears in front of the other rows. However, if the spacing of the points were varied in the image, your brain would perceive each point at a different depth, and you could see a virtual three-dimensional image appear.</p>
</section>
<section>
<h3 class="bh" id="bh1002"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1002"><span class="idx" data-level1="depth map" data-term="autostereograms"/>Working with Depth Maps</a></h3>
<p class="paft">The hidden image in an autostereogram comes from a <span class="idx" data-term="depth map"/><i>depth map</i>, an image in which the value of each pixel represents a <span class="idx" data-term="depth encoding"/>depth value, which is the distance from the eye to the part of the object represented by that pixel. A depth map is often shown as a grayscale image, with light areas for nearby points and darker areas for points farther away, as shown in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-4">Figure 8-4</a>.</p>
<figure class="figure" id="fig8-4">
<p class="fig"><img alt="" height="400" src="images/nsp-venkitachalam503045-f08004.jpg" style="width:95%; height:auto;" width="800"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-4:</span> A <span class="idx" data-level1="depth map" data-term="autostereograms"/>depth map</p>
</figcaption>
</figure>
<p><span aria-label=" Page 139. " class="page" epub:type="pagebreak" id="p139" role="doc-pagebreak"/>Notice that the nose of the shark, the lightest part of the image, seems closest to you. The darker area toward the tail seems farthest away. (By the way, the image in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-4">Figure 8-4</a> is the same depth map used to create the first autostereogram shown in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-1">Figure 8-1</a>.)</p>
<p>Because the depth map represents the depth or distance from the center of each pixel to the eye, you can use it to get the depth value associated with a pixel location in the image. You know that horizontal shifts are perceived as depth in images. So if you shift a pixel in a (patterned) image proportionally to the corresponding pixel’s depth value, you would create a depth perception for that pixel consistent with the depth map. If you do this for all pixels, you’ll end up encoding the entire depth map into the image, creating an autostereogram.</p>
<p>Depth maps store depth values for each pixel, and the resolution of the value depends on the number of bits used to represent it. Because you’ll be using common 8-bit images in this chapter, depth values will be in the range [0, 255].</p>
<p>For the purposes of this project, I’ve posted several example depth maps to the book’s GitHub repository. You can download the maps and use them as input for generating autostereograms. However, you may also want to try making your own depth maps to create some fancier images. There are two approaches you can take: using synthetic images created with 3D modeling software or using photographs taken with a smartphone camera.</p>
<section>
<h4 class="ch" id="ch1001">Creating Depth Maps from 3D Models</h4>
<p class="paft">If you create a 3D model of something using a 3D computer graphics program like Blender, you can also use the program to generate a depth map of the model. <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-5">Figure 8-5</a> shows an example.</p>
<figure class="figure" id="fig8-5">
<p class="fig"><img alt="" height="397" src="images/nsp-venkitachalam503045-f08005a.jpg" style="width:95%; height:auto;" width="1200"/></p>
<p class="figh">(a)</p>
<p class="fig"><img alt="" height="397" src="images/nsp-venkitachalam503045-f08005b.jpg" style="width:95%; height:auto;" width="1200"/></p>
<p class="figh">(b)</p>
<p class="figh"><span class="fighn">Figure 8-5:</span> A 3D model (a) and its associated depth map (b)</p>
</figure>
<p><span aria-label=" Page 140. " class="page" epub:type="pagebreak" id="p140" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-5">Figure 8-5(a)</a> shows a 3D model rendered using Blender, and <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-5">Figure 8-5(b)</a> shows the depth map created from this model. Search YouTube for “Blender depth map in 5 minutes!” for a tutorial<a class="fnref" epub:type="noteref" href="nsp-venkitachalam503045-0021.xhtml#fn3" id="fn3r" role="doc-noteref">3</a> from Jonty Schmidt on how to do this. The key is to color the image based on the Z-distance from the camera.</p>
</section>
<section>
<h4 class="ch" id="ch1002">Creating Depth Maps from Smartphone Photographs</h4>
<p class="paft">These days, many smartphone cameras have a <i>portrait mode</i>, which captures depth information along with the photograph to selectively blur out the background. If you could get hold of this depth data, you’d have a depth map of the photograph that you can use to create an autostereogram! <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-6">Figure 8-6</a> shows an example.</p>
<figure class="figure" id="fig8-6">
<p class="fig"><img alt="" height="600" src="images/nsp-venkitachalam503045-f08006a.jpg" style="width:95%; height:auto;" width="800"/></p>
<p class="figh1">(a)</p>
<p class="fig"><img alt="" height="600" src="images/nsp-venkitachalam503045-f08006b.jpg" style="width:95%; height:auto;" width="800"/></p>
<p class="figh1">(b)</p>
<p class="figh"><span class="fighn">Figure 8-6:</span> A portrait mode photo (a) and depth map (b) from an iPhone 11 camera</p>
</figure>
<p><a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-6">Figure 8-6(a)</a> shows a photograph taken in portrait mode with an iPhone 11, and <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-6">Figure 8-6(b)</a> shows the corresponding depth map. The depth map was created with the open source software ExifTool using this command:</p>
<div class="codeline">
<p class="cls">exiftool -b -MPImage2 photo.jpg &gt; depth.jpg</p>
</div>
<p>This command extracts the depth information from the metadata in the file <i>photo.jpg</i> and saves it to the file <i>depth.jpg</i>. Download ExifTool from <a class="url-i" href="https://exiftool.org">https://exiftool.org</a> to try the process for yourself. The command works for photos from an iPhone, but you can use similar techniques to extract the depth data from images taken with other types of phones. There are also various apps available on the Android and iOS app stores that can help you with this. Here’s one online depth map extractor that works with portrait mode images from a variety of phone models: <a class="url-i" href="http://www.hasaranga.com/dmap/">http://www.hasaranga.com/dmap</a>.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1003"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1003">Shifting Pixels</a></h3>
<p class="paft">We’ve looked at how our brains perceive the spacing between repeating elements in an image as depth information, and we’ve seen how depth information is conveyed through a depth map. Now let’s look at how to shift the pixels in a tiled image in proportion to the values in a depth map. This is the key step in creating an autostereogram.</p>
<p><span aria-label=" Page 141. " class="page" epub:type="pagebreak" id="p141" role="doc-pagebreak"/>A tiled image is created by repeating a smaller image (the tile) in the x- and y-directions, although for depth perception, we’re concerned only with the x-direction. If the tile that makes up the image is <i>w</i> pixels wide, you know the color values of the image’s pixels will repeat every <i>w</i> pixels in the x-direction for any given row. Put another way, the color of the pixel in some row at point <i>i</i> along the x-axis can be expressed as:</p>
<div class="equation">
<p class="eq"><i>C</i><sub class="i">i</sub> = <i>C</i><sub class="i">i</sub> <sub>−</sub> <sub class="i">w</sub> for <i>i</i> ≥ <i>w</i></p>
</div>
<p>Let’s consider an example. Given a tile width of 100 pixels, for a pixel with an x-axis position of 140, the equation tells you that <i>C</i><sub>140</sub> = <i>C</i><sub>140 − 100</sub> = <i>C</i><sub>40</sub>. This means the color value of the pixel at x-position 140 is the same as that of the pixel at x-position 40, due to the repetition of the image. (For values of <i>i</i> less than <i>w</i> in the previous formula, the color is just <i>C</i><sub class="i">i</sub>, since the tile hasn’t repeated yet.)</p>
<p>The goal is to shift pixels in the tiled image according to the values in the depth map. Let <span class="dcrit">δ</span><sub class="i">i</sub> be the value at x-position <i>i</i> in the depth map. The shifted color value of the corresponding pixel in the tiled image is given by:</p>
<div class="equation">
<p class="eq"><img alt="" height="36" src="images/nsp-venkitachalam503045-m08001.jpg" width="147"/></p>
</div>
<p>Returning to the example where the tile width is 100 pixels, given a pixel at x-position 140 and a corresponding depth map value of 10, the formula says that <i>C</i><sub>140</sub> = <i>C</i><sub>140 − 100 + 10</sub> = <i>C</i><sub>50</sub>. Because of the depth map, the color of the pixel at position 140 should be changed to match the color of the pixel at position 50. Since <i>C</i><sub>50</sub> is the same as <i>C</i><sub>150</sub>, this is effectively taking the pixel at x-position 150 and shifting it 10 pixels to the left. As a result, the repetition between positions 50 and 150 has become 10 pixels narrower, and your brain will perceive this change as depth information.</p>
<p>To create the complete autostereogram, you’ll repeat this shifting process across the width of the image and over all the rows. You’ll see how the shifting is actually implemented when you review the code.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1002"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1002">Requirements</a></h2>
<p class="paft">In this project, you’ll use <span class="idx" data-term="Pillow module"/><code>Pillow</code> to read in images, access their underlying data, and create and modify images.</p>
</section>
<section>
<h2 class="ah" id="ah1003"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1003">The Code</a></h2>
<p class="paft">The code for this project will follow these steps to create an autostereogram:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Read in a depth map.</li>
<li class="nl">2. Read in a tile image or create a “random dot” tile. This will serve as the basis for the autostereogram’s repeating pattern.</li>
<li class="nl">3. Create a new image by repeating the tile. The dimensions of this image should match those of the depth map.</li>
<li class="nl"><span aria-label=" Page 142. " class="page" epub:type="pagebreak" id="p142" role="doc-pagebreak"/>4. For each pixel in the new image, shift the pixel by an amount proportional to the depth value associated with the corresponding pixel in the depth map.</li>
<li class="nll">5. Write the resulting autostereogram to a file.</li>
</ol>
<p>To see the complete project, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#ah1007">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#p147">page 147</a>. You can also download the full code listing for this chapter from <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/autos">https://github.com/mkvenkit/pp2e/tree/main/autos</a>.</p>
<section>
<h3 class="bh" id="bh1004"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1004">Creating a Tile from Random Circles</a></h3>
<p class="paft">The user will have the option to provide a tile image at the start of the program (I’ve uploaded an image based on an M.C. Escher drawing to GitHub for this purpose). If one isn’t provided, create a tile with <span class="idx" data-level1="random dots" data-term="autostereograms"/>random circles using the <code>createRandomTile()</code> function.</p>
<div class="codeline">
<p class="clf">def createRandomTile(dims):</p>
<p class="cl">    # create image</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ img = Image.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>new('RGB', dims)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ draw = ImageDraw.<span class="idx" data-level1="ImageDraw" data-term="Python Imaging Library"/>Draw(img)</p>
<p class="cl">    # set the radius of a random circle to 1% of</p>
<p class="cl">    # width or height, whichever is smaller</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ r = int(<span class="idx" data-term="min method"/>min(*dims)/100)</p>
<p class="cl">    # number of circles</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ n = 1000</p>
<p class="cl">    # draw random circles</p>
<p class="cl">    for i in range(n):</p>
<p class="cl">        # -r makes sure that the circles stay inside and aren't cut off</p>
<p class="cl">        # at the edges of the image so that they'll look better when tiled</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ x, y = random.<span class="idx" data-level1="randint" data-term="random module"/>randint(r, dims[0]-r), random.randint(r, dims[1]-r)</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ fill = (random.randint(0, 255), random.randint(0, 255),</p>
<p class="cl">                random.randint(0, 255))</p>
<p class="cl">      <!--<ccust1>7</ccust1>-->❼ draw.<span class="idx" data-level1="ImageDraw" data-term="Python Imaging Library"/>ellipse((x-r, y-r, x+r, y+r), fill)</p>
<p class="cll">    return img</p>
</div>
<p>First you create a new Python Imaging Library (PIL) <code>Image</code> object with the dimensions given by <code>dims</code> <!--<ccust1>1</ccust1>-->❶. Then you use <code>ImageDraw.Draw()</code> <!--<ccust1>2</ccust1>-->❷ to draw circles inside the image with an arbitrarily chosen radius (<code>r</code>) of 1/100th of either the width or the height of the image, whichever is smaller <!--<ccust1>3</ccust1>-->❸. (The Python <code>*</code> operator unpacks the width and height values in the <code>dims</code> tuple so that they can be passed into the <code>min()</code> method.)</p>
<p>You set the number of circles to draw to <code>1000</code> <!--<ccust1>4</ccust1>-->❹ and then calculate the x- and y-coordinates of the center of each circle by calling <code>random.randint()</code> to get random integers in the range [<code>r</code>, <code class="i">width</code><code>-r</code>] and [<code>r</code>, <code class="i">height</code><code>-r</code>] <!--<ccust1>5</ccust1>-->❺. Offsetting the range by <code>r</code> ensures the generated circles will fall entirely inside the boundaries of the tile. Without it, you could end up drawing a circle right at the edge of the image, which means it would be partly cut off. If you tiled such an image to create the autostereogram, the result wouldn’t look good because the circles at the edge between two tiles would have no spacing between them.</p>
<p><span aria-label=" Page 143. " class="page" epub:type="pagebreak" id="p143" role="doc-pagebreak"/>Next, you select a fill color for each circle by randomly choosing RGB values from the range [<code>0</code>, <code>255</code>] <!--<ccust1>6</ccust1>-->❻. Finally, you use the <code>ellipse()</code> method in <code>draw</code> to draw each of your circles <!--<ccust1>7</ccust1>-->❼. The first argument to this method is a tuple defining the bounding box of the circle, which is given by the top-left and bottom-right corners as (<code>x-r</code>, <code>y-r</code>) and (<code>x+r</code>, <code>y+r</code>), respectively, where (<code>x</code>, <code>y</code>) is the center of the circle and <code>r</code> is its radius. The other argument is the randomly chosen fill color.</p>
<p>You can test this method in the Python interpreter as follows:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">import autos</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">img = autos.createRandomTile((256, 256))</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">img.save('out.png')</code></p>
<p class="cll">&gt;&gt;&gt; <code class="b">exit()</code></p>
</div>
<p><a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-7">Figure 8-7</a> shows the output from the test.</p>
<figure class="figure" id="fig8-7">
<p class="fig"><img alt="" height="256" src="images/nsp-venkitachalam503045-f08007.jpg" width="256"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-7:</span> A sample run of <code class="i">createRandomTile()</code></p>
</figcaption>
</figure>
<p>As you can see in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-7">Figure 8-7</a>, you’ve created an image with random dots that you can use as the autostereogram’s tiled pattern.</p>
</section>
<section>
<h3 class="bh" id="bh1005"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1005"><span class="idx" data-level1="repeating pattern" data-term="autostereograms"/>Repeating a Given Tile</a></h3>
<p class="paft">Now that you have a tile to work with, you can create an image by repeating that tile. This will form the basis of your autostereogram. Define a <code>createTiledImage()</code> function to do the work.</p>
<div class="codeline">
<p class="clf">def createTiledImage(tile, dims):</p>
<p class="cl">    # create the new image</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ img = Image.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>new('RGB', dims)</p>
<p class="cl">    W, H = dims</p>
<p class="cl">    w, h = tile.size</p>
<p class="cl">    # calculate the number of tiles needed</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ cols = int(W/w) + 1</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ rows = int(H/h) + 1</p>
<p class="cl">    # paste the tiles into the image</p>
<p class="cl">    for i in range(rows):</p>
<p class="cl">        for j in range(cols):</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ img.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>paste(tile, (j*w, i*h))</p>
<p class="cl"><span aria-label=" Page 144. " class="page" epub:type="pagebreak" id="p144" role="doc-pagebreak"/>    # output the image</p>
<p class="cll">    return img</p>
</div>
<p>The function takes in an image that will serve as the tiled pattern (<code>tile</code>), and the desired dimensions of the output image (<code>dims</code>). The dimensions are given as a tuple in the form (<code class="i">width</code>, <code class="i">height</code>). You create a new <code>Image</code> object using the supplied dimensions <!--<ccust1>1</ccust1>-->❶. Next, you store the width and height of both the individual tile and the overall image. Dividing the overall image dimensions by those of the tile gives you the number of columns <!--<ccust1>2</ccust1>-->❷ and rows <!--<ccust1>3</ccust1>-->❸ of tiles you need to have in the image. You add 1 to each calculation to make sure that the last column of tiles on the right and the last row of tiles on the bottom aren’t missed when the output image dimension isn’t an exact integer multiple of the tile dimension. Without this precaution, the right and bottom of the image might be cut off. Finally, you loop through the rows and columns and fill them with tiles <!--<ccust1>4</ccust1>-->❹. You determine the location of the top-left corner of the tile by multiplying <code>(j*w, i*h)</code> so it aligns with the rows and columns, just as you did in the photomosaic project. Once complete, the function returns an <code>Image</code> object of the specified dimensions, tiled with the input image <code>tile</code>.<span class="idx" data-level1="creating tiled image" data-term="autostereograms"/></p>
</section>
<section>
<h3 class="bh" id="bh1006"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1006">Creating Autostereograms</a></h3>
<p class="paft">Now let’s <span class="idx" data-level1="creating" data-term="autostereograms"/>create some autostereograms. The <code>createAutostereogram()</code> function does most of the work. Here it is:</p>
<div class="codeline">
<p class="clf">def createAutostereogram(dmap, tile):</p>
<p class="cl">    # convert the depth map to a single channel if needed</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if dmap.mode != 'L':</p>
<p class="cl">        dmap = dmap.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>convert('L')</p>
<p class="cl">    # if no image is specified for a tile, create a random circles tile</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ if not tile:</p>
<p class="cl">        tile = createRandomTile((100, 100))</p>
<p class="cl">    # create an image by tiling</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ img = createTiledImage(tile, dmap.size)</p>
<p class="cl">    # create a shifted image using depth map values</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ sImg = img.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>copy()</p>
<p class="cl">    # get access to image pixels by loading the Image object first</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ pixD = dmap.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>load()</p>
<p class="cl">    pixS = sImg.load()</p>
<p class="cl">    # shift pixels horizontally based on depth map</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ cols, rows = sImg.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>size</p>
<p class="cl">    for j in range(rows):</p>
<p class="cl">        for i in range(cols):</p>
<p class="cl">          <!--<ccust1>7</ccust1>-->❼ xshift = pixD[i, j]/10</p>
<p class="cl">          <!--<ccust1>8</ccust1>-->❽ xpos = i - tile.size[0] + xshift</p>
<p class="cl">          <!--<ccust1>9</ccust1>-->❾ if xpos &gt; 0 and xpos &lt; cols:</p>
<p class="cl">              <!--<ccust1>10</ccust1>-->❿ pixS[i, j] = pixS[xpos, j]</p>
<p class="cl">    # display the shifted image</p>
<p class="cll">    return sImg</p>
</div>
<p><span aria-label=" Page 145. " class="page" epub:type="pagebreak" id="p145" role="doc-pagebreak"/>First you convert the provided depth map (<code>dmap</code>) into a single-channel grayscale image if needed <!--<ccust1>1</ccust1>-->❶. If the user doesn’t supply an image for the tile, you then create a tile of random circles using the <code>createRandomTile()</code> function you defined earlier <!--<ccust1>2</ccust1>-->❷. Next, you use your <code>createTiledImage()</code> function to create a tiled image that matches the size of the supplied depth map image <!--<ccust1>3</ccust1>-->❸. You then make a copy of this tiled image <!--<ccust1>4</ccust1>-->❹. This copy will become the final autostereogram.</p>
<p>The function continues by using the <code>Image.load()</code> method on the depth map and the output image <!--<ccust1>5</ccust1>-->❺. This method loads image data into memory, allowing you to <span class="idx" data-level1="Image" data-term="Python Imaging Library"/>access an image’s pixels as a two-dimensional array in the form <code>[i, j]</code>. You store the image dimensions as a number of rows and columns <!--<ccust1>6</ccust1>-->❻, treating the image as a grid of individual pixels.</p>
<p>The core of the autostereogram creation algorithm lies in the way you shift the pixels in the tiled image according to the information gathered from the depth map. To do this, you iterate through the tiled image and process each pixel. First you look up the value of the corresponding pixel from the depth map and divide this value by 10 to determine a shift value for the tiled image <!--<ccust1>7</ccust1>-->❼. You divide by 10 because you’re using an 8-bit depth map here, which means the depth varies from 0 to 255. If you divide these values by 10, you get depth values in the approximate range of 0 to 25. Since the depth map input image dimensions are usually in the hundreds of pixels, these shift values work fine. (Play around by changing the value you divide by to see how it affects the final image.)</p>
<p>Next, you use the formula discussed in <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#bh1003">“Shifting Pixels”</a> on <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#p140">page 140</a> to calculate the x-axis coordinate to look for the pixel’s new color value <!--<ccust1>8</ccust1>-->❽. Pixels with a depth map value of 0 (black) won’t be shifted and will be perceived as the background. After checking to make sure you’re not trying to access a pixel that’s not in the image (which can happen at the image’s edges because of the shift) <!--<ccust1>9</ccust1>-->❾, you replace each pixel with its shifted value <!--<ccust1>10</ccust1>-->❿.</p>
</section>
<section>
<h3 class="bh" id="bh1007"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1007">Providing <span class="idx" data-level1="command-line options" data-term="autostereograms"/>Command Line Options</a></h3>
<p class="paft">The <code>main()</code> function of the program provides some command line options to customize the autostereogram.</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    # create a parser</p>
<p class="cl">    parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse module"/>ArgumentParser(description="Autostereograms...")</p>
<p class="cl">    # add expected arguments</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser.add_argument('--depth', dest='dmFile', required=True)</p>
<p class="cl">    parser.add_argument('--tile', dest='tileFile', required=False)</p>
<p class="cl">    parser.add_argument('--out', dest='outFile', required=False)</p>
<p class="cl">    # parse args</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="cl">    # set the output file</p>
<p class="cl">    outFile = 'as.png'</p>
<p class="cl">    if args.outFile:</p>
<p class="cl">        outFile = args.outFile</p>
<p class="cl">    # set tile</p>
<p class="cl"><span aria-label=" Page 146. " class="page" epub:type="pagebreak" id="p146" role="doc-pagebreak"/>    tileFile = False</p>
<p class="cl">    if args.tileFile:</p>
<p class="cll">        tileFile = Image.open(args.tileFile)</p>
</div>
<p>As with previous projects, you define the command line options for the program using <code>argparse</code>. The one required argument is the name of the depth map file <!--<ccust1>1</ccust1>-->❶. There are also two optional arguments, one to provide an image file to use as the tile pattern and the other to set the name of the output file. If a tile image isn’t specified, the program will generate a tile of random circles. If the output filename isn’t specified, the autostereogram is written to a file named <i>as.png</i>.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1004"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1004">Running the Autostereogram Generator</a></h2>
<p class="paft">Now let’s run the program using a depth map of a stool (<i>stool-depth.png</i>), which you’ll find in the <i>data</i> folder of this project’s GitHub repository:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python autos.py --depth data/stool-depth.png</code></p>
</div>
<p><span class="idx" data-level1="example" data-term="autostereograms"/><a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-8">Figure 8-8</a> shows the depth map image on the left and the generated autostereogram on the right. Because you haven’t supplied a graphic for the tile, this autostereogram is created using random tiles.</p>
<figure class="figure" id="fig8-8">
<p class="fig"><img alt="" height="396" src="images/nsp-venkitachalam503045-f08008.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-8:</span> A sample run of <i>autos.py</i></p>
</figcaption>
</figure>
<p>Now let’s give a tile image as input. Use the <i>stool-depth.png</i> depth map as you did earlier, but this time, supply the image <i>escher-tile.jpg</i> for the tiles.</p>
<div class="codeline">
<p class="cls">$ <code class="b">python autos.py --depth data/stool-depth.png –-tile data/escher-tile.jpg</code></p>
</div>
<p><a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-9">Figure 8-9</a> shows the output.</p>
<figure class="figure" id="fig8-9">
<p class="fig"><span aria-label=" Page 147. " class="page" epub:type="pagebreak" id="p147" role="doc-pagebreak"/><img alt="" height="683" src="images/nsp-venkitachalam503045-f08009.jpg" style="width:95%; height:auto;" width="1024"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 8-9:</span> A sample run of <i>autos.py</i> using tiles</p>
</figcaption>
</figure>
<p>Enjoy creating moiré autostereograms using the images I’ve provided on GitHub or using your own depth maps!</p>
</section>
<section>
<h2 class="ah" id="ah1005"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1005">Summary</a></h2>
<p class="paft">In this project, you learned how to create autostereograms. Given a depth map image, you can now create either a random dot autostereogram or one tiled with an image you supply.</p>
</section>
<section>
<h2 class="ah" id="ah1006"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1006">Experiments!</a></h2>
<p class="paft">Here are some ways to further explore autostereograms:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Write code to create an image similar to <a class="xref" href="nsp-venkitachalam503045-0021.xhtml#fig8-2">Figure 8-2</a> that demonstrates how changes in the linear spacing in an image can create illusions of depth. (Hint: use image tiles and the <code>Image.paste()</code> method.)</li>
<li class="nl">2. Add a command line option to the program to specify the scale to be applied to the depth map values. (Remember that the code divides the depth map value by 10.) How does changing the value affect the autostereogram?</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah1007"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1007">The Complete Code</a></h2>
<p class="paft">Here’s the complete autostereogram project code:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">autos.py</p>
<p class="clf">A program to create autostereograms.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf"><span aria-label=" Page 148. " class="page" epub:type="pagebreak" id="p148" role="doc-pagebreak"/>import sys, random, argparse</p>
<p class="cl">from PIL import Image, ImageDraw</p>
<p class="clf"># create spacing/depth example</p>
<p class="cl">def createSpacingDepthExample():</p>
<p class="cl">    tiles = [Image.open('test/a.png'), Image.open('test/b.png'),</p>
<p class="cl">             Image.open('test/c.png')]</p>
<p class="cl">    img = Image.new('RGB', (600, 400), (0, 0, 0))</p>
<p class="cl">    spacing = [10, 20, 40]</p>
<p class="cl">    for j, tile in enumerate(tiles):</p>
<p class="cl">        for i in range(8):</p>
<p class="cl">            img.paste(tile, (10 + i*(100 + j*10), 10 + j*100))</p>
<p class="cl">    img.save('sdepth.png')</p>
<p class="clf"># create image filled with random dots</p>
<p class="cl">def createRandomTile(dims):</p>
<p class="cl">    # create image</p>
<p class="cl">    img = Image.new('RGB', dims)</p>
<p class="cl">    draw = ImageDraw.Draw(img)</p>
<p class="cl">    # calculate radius - % of min dimension</p>
<p class="cl">    r = int(min(*dims)/100)</p>
<p class="cl">    # number of dots</p>
<p class="cl">    n = 1000</p>
<p class="cl">    # draw random circles</p>
<p class="cl">    for i in range(n):</p>
<p class="cl">        # -r is used so circle stays inside - cleaner for tiling</p>
<p class="cl">        x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)</p>
<p class="cl">        fill = (random.randint(0, 255), random.randint(0, 255),</p>
<p class="cl">                random.randint(0, 255))</p>
<p class="cl">        draw.ellipse((x-r, y-r, x+r, y+r), fill)</p>
<p class="cl">    # return image</p>
<p class="cl">    return img</p>
<p class="clf"># create a larger image of size dims by tiling the given image</p>
<p class="cl">def createTiledImage(tile, dims):</p>
<p class="cl">    # create output image</p>
<p class="cl">    img = Image.new('RGB', dims)</p>
<p class="cl">    W, H = dims</p>
<p class="cl">    w, h = tile.size</p>
<p class="cl">    # calculate # of tiles needed</p>
<p class="cl">    cols = int(W/w) + 1</p>
<p class="cl">    rows = int(H/h) + 1</p>
<p class="cl">    # paste tiles</p>
<p class="cl">    for i in range(rows):</p>
<p class="cl">        for j in range(cols):</p>
<p class="cl">            img.paste(tile, (j*w, i*h))</p>
<p class="cl">    # output image</p>
<p class="cl">    return img</p>
<p class="clf"># create a depth map for testing:</p>
<p class="cl">def createDepthMap(dims):</p>
<p class="cl">    dmap = Image.new('L', dims)</p>
<p class="cl">    dmap.paste(10, (200, 25, 300, 125))</p>
<p class="cl">    dmap.paste(30, (200, 150, 300, 250))</p>
<p class="cl">    dmap.paste(20, (200, 275, 300, 375))</p>
<p class="cl">    return dmap</p>
<p class="clf"><span aria-label=" Page 149. " class="page" epub:type="pagebreak" id="p149" role="doc-pagebreak"/># given a depth map (image) and an input image, create a new image</p>
<p class="cl"># with pixels shifted according to depth</p>
<p class="cl">def createDepthShiftedImage(dmap, img):</p>
<p class="cl">    # size check</p>
<p class="cl">    assert dmap.size == img.size</p>
<p class="cl">    # create shifted image</p>
<p class="cl">    sImg = img.copy()</p>
<p class="cl">    # get pixel access</p>
<p class="cl">    pixD = dmap.load()</p>
<p class="cl">    pixS = sImg.load()</p>
<p class="cl">    # shift pixels output based on depth map</p>
<p class="cl">    cols, rows = sImg.size</p>
<p class="cl">    for j in range(rows):</p>
<p class="cl">        for i in range(cols):</p>
<p class="cl">            xshift = pixD[i, j]/10</p>
<p class="cl">            xpos = i - 140 + xshift</p>
<p class="cl">            if xpos &gt; 0 and xpos &lt; cols:</p>
<p class="cl">                pixS[i, j] = pixS[xpos, j]</p>
<p class="cl">    # return shifted image</p>
<p class="cl">    return sImg</p>
<p class="clf"># given a depth map (image) and an input image, create a new image</p>
<p class="cl"># with pixels shifted according to depth</p>
<p class="cl">def createAutostereogram(dmap, tile):</p>
<p class="cl">    # convert depth map to single channel if needed</p>
<p class="cl">    if dmap.mode != 'L':</p>
<p class="cl">        dmap = dmap.convert('L')</p>
<p class="cl">    # if no tile specified, use random image</p>
<p class="cl">    if not tile:</p>
<p class="cl">        tile = createRandomTile((100, 100))</p>
<p class="cl">    # create an image by tiling</p>
<p class="cl">    img = createTiledImage(tile, dmap.size)</p>
<p class="cl">    # create shifted image</p>
<p class="cl">    sImg = img.copy()</p>
<p class="cl">    # get pixel access</p>
<p class="cl">    pixD = dmap.load()</p>
<p class="cl">    pixS = sImg.load()</p>
<p class="cl">    # shift pixels output based on depth map</p>
<p class="cl">    cols, rows = sImg.size</p>
<p class="cl">    for j in range(rows):</p>
<p class="cl">        for i in range(cols):</p>
<p class="cl">            xshift = pixD[i, j]/10</p>
<p class="cl">            xpos = i - tile.size[0] + xshift</p>
<p class="cl">            if xpos &gt; 0 and xpos &lt; cols:</p>
<p class="cl">                pixS[i, j] = pixS[xpos, j]</p>
<p class="cl">    # return shifted image</p>
<p class="cl">    return sImg</p>
<p class="clf"># main() function</p>
<p class="cl">def main():</p>
<p class="cl">    # use sys.argv if needed</p>
<p class="cl">    print('creating autostereogram...')</p>
<p class="cl">    # create parser</p>
<p class="cl">    parser = argparse.ArgumentParser(description="Autostereograms...")</p>
<p class="cl">    # add expected arguments</p>
<p class="cl"><span aria-label=" Page 150. " class="page" epub:type="pagebreak" id="p150" role="doc-pagebreak"/>    parser.add_argument('--depth', dest='dmFile', required=True)</p>
<p class="cl">    parser.add_argument('--tile', dest='tileFile', required=False)</p>
<p class="cl">    parser.add_argument('--out', dest='outFile', required=False)</p>
<p class="cl">    # parse args</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="cl">    # set output file</p>
<p class="cl">    outFile = 'as.png'</p>
<p class="cl">    if args.outFile:</p>
<p class="cl">        outFile = args.outFile</p>
<p class="cl">    # set tile</p>
<p class="cl">    tileFile = False</p>
<p class="cl">    if args.tileFile:</p>
<p class="cl">        tileFile = Image.open(args.tileFile)</p>
<p class="cl">    # open depth map</p>
<p class="cl">    dmImg = Image.open(args.dmFile)</p>
<p class="cl">    # create stereogram</p>
<p class="cl">    asImg = createAutostereogram(dmImg, tileFile)</p>
<p class="cl">    # write output</p>
<p class="cl">    asImg.save(outFile)</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
<div class="notes">
<div class="footnote" role="doc-footnote">
<p class="fn"><a class="fnnum" href="nsp-venkitachalam503045-0021.xhtml#fn1r" id="fn1" role="doc-backlink">1</a> The hidden image is a shark.</p>
</div>
<div class="footnote" role="doc-footnote">
<p class="fn"><a class="fnnum" href="nsp-venkitachalam503045-0021.xhtml#fn2r" id="fn2" role="doc-backlink">2</a> <a class="url-i" href="http://colorstereo.com/texts_.txt/practice.htm">http://colorstereo.com/texts_.txt/practice.htm</a></p>
</div>
<div class="footnote" role="doc-footnote">
<p class="fn"><a class="fnnum" href="nsp-venkitachalam503045-0021.xhtml#fn3r" id="fn3" role="doc-backlink">3</a> <a class="url-i" href="https://www.youtube.com/watch?v=oqpDqKpOChE">https://www.youtube.com/watch?v=oqpDqKpOChE</a></p>
</div>
</div>
</section>
</section>
</div></body></html>