["```py\nHeap {\n    Array: array\n    Integer: array_size\n    Integer: last_index\n}\n```", "```py\nHeapInsert(Heap: heap, Type: value):\n  ❶ IF heap.last_index == heap.array_size - 1:\n        Increase Heap size.\n\n ❷ heap.last_index = heap.last_index + 1\n    heap.array[heap.last_index] = value\n\n    # Swap the new node up the heap.\n  ❸ Integer: current = heap.last_index\n    Integer: parent = Floor(current / 2)\n  ❹ WHILE parent >= 1 AND (heap.array[parent] < \n                           heap.array[current]):\n      ❺ Type: temp = heap.array[parent]\n        heap.array[parent] = heap.array[current]\n        heap.array[current] = temp\n        current = parent\n        parent = Floor(current / 2)\n```", "```py\nHeapRemoveMax(Heap: heap):\n  ❶ IF heap.last_index == 0:\n        return null\n\n    # Swap out the root for the last element and shrink heap.  \n  ❷ Type: result = heap.array[1]\n    heap.array[1] = heap.array[heap.last_index]\n    heap.array[heap.last_index] = null\n    heap.last_index = heap.last_index - 1\n\n    # Bubble the new root down.\n    Integer: i = 1\n  ❸ WHILE i <= heap.last_index:\n        Integer: swap = i\n      ❹ IF 2*i <= heap.last_index AND (heap.array[swap] < \n                                       heap.array[2*i]):\n            swap = 2*i\n      ❺ IF 2*i+1 <= heap.last_index AND (heap.array[swap] <\n                                         heap.array[2*i+1]):\n            swap = 2*i+1\n\n      ❻ IF i != swap:\n            Type: temp = heap.array[i]\n            heap.array[i] = heap.array[swap]\n            heap.array[swap] = temp\n            i = swap\n        ELSE:\n            break\n    return result\n```", "```py\nTaskRecord {\n    Float: Priority\n    String: TaskName\n    String: Instructions\n    String: PersonWhoWillYellIfThisIsNotDone\n    Boolean: Completed\n}\n```", "```py\n WHILE parent >= 1 AND (heap.array[parent].priority < \n                             heap.array[current].priority):\n```", "```py\nIsLessThan(Type: a, Type: b):\n  return a.priority < b.priority\n```", "```py\n WHILE parent >= 1 AND IsLessThan(heap.array[parent], \n                                     heap.array[current]):\n```", "```py\n IF 2*i <= heap.last_index AND IsLessThan(heap.array[swap],\n                                                 heap.array[2*i]):\n            swap = 2*i\n        IF 2*i+1 <= heap.last_index AND IsLessThan(heap.array[swap],\n                                                   heap.array[2*i+1]):\n            swap = 2*i+1\n```", "```py\nUpdateValue(Heap: heap, Integer: index, Float: value):\n    Type: old_value = heap.array[index]\n    heap.array[index] = value\n\n    IF old_value < value:\n        Bubble the element up the heap using the\n        procedure from inserting new elements \n        (swapping with parent).\n    ELSE:\n        Drop the element down the heap using the\n        procedure from removing the max element \n        (swapping with the larger child).\n```", "```py\nMinHeapInsert(MinHeap: heap, Type: value):\n    IF heap.last_index == heap.array_size - 1:\n Increase Heap size.\n\n    heap.last_index = heap.last_index + 1\n    heap.array[heap.last_index] = value\n\n    # Swap the new node up the heap.\n    Integer: current = heap.last_index\n    Integer: parent = Floor(current / 2)\n  ❶ WHILE parent >= 1 AND (heap.array[parent] > \n                           heap.array[current]):\n        Type: temp = heap.array[parent]\n        heap.array[parent] = heap.array[current]\n        heap.array[current] = temp\n        current = parent\n        parent = Floor(current / 2)\n```", "```py\nMinHeapRemoveMin(Heap: heap):\n    IF heap.last_index == 0:\n        return null\n\n    # Swap out the root for the last element and shrink heap.  \n    Type: result = heap.array[1]\n    heap.array[1] = heap.array[heap.last_index]\n    heap.array[heap.last_index] = null\n    heap.last_index = heap.last_index - 1\n\n    # Bubble the new root down.\n    Integer: i = 1\n    WHILE i <= heap.last_index:\n        Integer: swap = i\n      ❶ IF 2*i <= heap.last_index AND (heap.array[swap] > \n                                       heap.array[2*i]):\n            swap = 2*i\n      ❷ IF 2*i+1 <= heap.last_index AND (heap.array[swap] >\n                                         heap.array[2*i+1]):\n            swap = 2*i+1\n\n        IF i != swap:\n            Type: temp = heap.array[i]\n            heap.array[i] = heap.array[swap]\n            heap.array[swap] = temp\n            i = swap\n        ELSE:\n            break\n    return result\n```", "```py\nHeapsort(Array: unsorted):\n    Integer: N = length(unsorted)\n    Heap: tmp_heap = Heap of size N\n    Array: result = array of size N      \n\n    Integer: j = 0\n  ❶ WHILE j < N:\n        HeapInsert(tmp_heap, unsorted[j])\n        j = j + 1\n\n    j = 0\n  ❷ WHILE j < N:\n        result[j] = HeapRemoveMax(tmp_heap)\n        j = j + 1\n    return result\n```"]