<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_337"/><span class="big">13</span><br/>MATRICES AND VECTORS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">This part of the book will deal with solving systems of equations. We can conveniently represent a set of equations using its <em>matrix form</em>, where we store the unknown coefficients in a matrix and the free terms in a vector.</p>&#13;
<p class="indent">We’ve been working with matrices and vectors with our affine transformations, but for the sake of completeness, let’s define them here. A <em>matrix</em> is a two-dimensional array of numbers arranged in rows and columns. Matrices are subject to some mathematical operations, including addition, subtraction, multiplication, and a few more. A <em>vector</em>, in this context, is a matrix with only one row or column (typically one column).</p>&#13;
<p class="indent">Consider the following system of equations:</p>&#13;
<div class="equationc"><img src="../images/f00337-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">We can conveniently write this in matrix form as follows:</p>&#13;
<div class="equationc"><img src="../images/f00337-p2.jpg" alt="Image"/></div>&#13;
<p class="indent">Note how the coefficients of the equation are represented in the 2 (rows) by 3 (columns) matrix. According to the matrix multiplication rules, these <span epub:type="pagebreak" id="page_338"/>coefficients multiplied by the unknowns <em>x</em>, <em>y</em>, and <em>z</em> yield our two equations, each of which needs to equal its corresponding right-side term stored in the ⟨1,–3⟩ vector.</p>&#13;
<p class="indent">It may not be obvious now, but matrices, and by extension vectors, will greatly simplify working with systems of equations. To use them, however, we’ll need to implement new classes for both matrices and vectors.</p>&#13;
<p class="indent">The new <span class="literal">Vector</span> class will represent a uni-dimensional array of numbers (a sequence) of any length. This type of vector should not be confused with the geometric vector we implemented in <a href="ch04.xhtml#ch04">Chapter 4</a>, which was made up of two coordinates (<em>u</em> and <em>v</em>). An instance of our new <span class="literal">Vector</span> class with a size of 2 could look similar to the geometric vector, but they are distinct: the numbers don’t necessarily represent coordinates that define a direction. We’ll have to deal with having two classes named the same: <span class="literal">Vector</span>. As you’ll see, since they’re defined in different modules, it shouldn’t be any problem to disambiguate them.</p>&#13;
<p class="indent">There are quite a few operations we could implement for these two new classes, but we’ll be pragmatic and implement only those we need in the next chapter for solving systems of equations. For instance, we won’t need to implement the addition, subtraction, or multiplication operations, even though these are common.</p>&#13;
<p class="indent">Let’s begin by implementing two simple functions to help us fill newly instantiated vectors and matrices with zeros. We’ll use these functions when we instantiate a vector or matrix.</p>&#13;
<h3 class="h3" id="ch00lev1sec78"><strong>List Utils</strong></h3>&#13;
<p class="noindent">Internally, an instance of this new <span class="literal">Vector</span> class will use a list of numbers to store its data. When an instance of the class is instantiated, we want to fill its internal list with zeros. This way, values that haven’t been explicitly set to some other value will be zero by default. Similarly, the <span class="literal">Matrix</span> class will store its data in a list of lists. We also want every position in the matrix initialized to zero.</p>&#13;
<p class="indent">Create a new Python file inside the <em>utils</em> package, name it <em>lists.py</em>, and enter the code in <a href="ch13.xhtml#ch13lis1">Listing 13-1</a>.</p>&#13;
<pre> def list_of_zeros(length: int):&#13;
    return [0] * length&#13;
&#13;
&#13;
def list_of_list_of_zeros(rows: int, cols: int):&#13;
    return [list_of_zeros(cols) for _ in range(rows)]</pre>&#13;
<p class="caption"><a id="ch13lis1"/><em>Listing 13-1: Lists of zeros</em></p>&#13;
<p class="indent">We’ve defined two functions. The first one, <span class="literal">list_of_zeros</span>, takes in a <span class="literal">length</span> argument and creates a list of that size filled with zeros. The second, <span class="literal">list_of_list_of_zeros</span>, creates as many lists of zeros of size <span class="literal">cols</span> as the parameter <span class="literal">rows</span> instructs.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_339"/>The funny syntax for <span class="literal">[0] * length</span> can be read as follows: “Create a list made up of zeros with the given length.” Give it a try in the Python console:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[0] * 5</span>&#13;
[0, 0, 0, 0, 0]</pre>&#13;
<p class="indent">This is a neat way of initializing a list that contains the same repeating value.</p>&#13;
<p class="indent">The <span class="literal">list_of_list_of_zeros</span> function uses a list comprehension to create a list of size <span class="literal">rows</span> where each item is another list of size <span class="literal">cols</span>. The index in each iteration isn’t used, so an underscore is used:</p>&#13;
<pre>from _ in range(rows)</pre>&#13;
<p class="noindent">Let’s try this function in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from utils.lists import list_of_list_of_zeros</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">list_of_list_of_zeros(2, 3)</span>&#13;
[[0, 0, 0], [0, 0, 0]]</pre>&#13;
<p class="indent">Let’s now set up the new package where we’ll add the new <span class="literal">Matrix</span> and <span class="literal">Vector</span> classes.</p>&#13;
<h3 class="h3" id="ch00lev1sec79"><strong>Setup</strong></h3>&#13;
<p class="noindent">Let’s now create a new package in our project where we’ll add the <span class="literal">Vector</span> and <span class="literal">Matrix</span> implementations. This package will also contain the equation-solving functions that we’ll implement in the next chapters and generally in any math or equation resolution algorithm we write. Create the new package at the project’s top level and name it <em>eqs</em>. Add another package inside it, and name it <em>tests</em>. Your project’s structure should now look something like this:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- apps<br/>      |    |- circle_from_points<br/>      |- eqs<br/>      |    |- tests<br/>      |- geom2d<br/>      |    |- tests<br/>      |- graphic<br/>      |    |- simulation<br/>      |    |- svg<br/>      |- utils</p>&#13;
<p class="indent">You should just have added the <em>eqs</em> directory and its <em>tests</em> subdirectory:</p>&#13;
<p class="pre2">    Mechanics<br/>      | ...<br/>      |- eqs<br/>      |    |- tests<br/>      | ...</p>&#13;
<h3 class="h3" id="ch00lev1sec80"><span epub:type="pagebreak" id="page_340"/><strong>Vectors</strong></h3>&#13;
<p class="noindent">As we saw in the introduction of the chapter, a vector inside the <em>eqs</em> package will represent a sequence of numbers stored together in a list. We won’t confuse it with the <span class="literal">Vector</span> implementation from the <em>geom2d</em> package; it’s unfortunate they share a name, but remember that they are two different (although arguably related) concepts. Vectors here are a special kind of matrix; specifically, they are matrices with only one row or column. For instance, we may refer to a vector like</p>&#13;
<div class="equationc"><img src="../images/f00340-p1.jpg" alt="Image"/></div>&#13;
<p class="noindent">as a <em>column vector</em>, highlighting the fact that it’s a matrix with only one column. Similarly, we call a vector like</p>&#13;
<p class="noindentc">[2  –1  3]</p>&#13;
<p class="noindent">a <em>row vector</em>, as it’s nothing more than a matrix with only one row.</p>&#13;
<p class="indent">We’ll implement matrices and vectors as separate classes (instead of using the <span class="literal">Matrix</span> class to represent both) just for the sake of readability. For example, to get a value from a matrix we indicate both the row and column indices. For a vector, we require just one index, so using the <span class="literal">Matrix</span> class to store a vector could make sense but would force us to pass two indices to get or set values when, conceptually, just one should be enough. Thus, when reading code like</p>&#13;
<pre>m.value_at(2, 4)&#13;
v.value_at(3)</pre>&#13;
<p class="noindent">we can quickly identify that <span class="literal">m</span> is a matrix and <span class="literal">v</span> is a vector.</p>&#13;
<h4 class="h4" id="ch00lev2sec143"><strong><em>Implementing the Vector Class</em></strong></h4>&#13;
<p class="noindent">We’ll use a list to store the vector’s data. We won’t be giving users access to this private list of numbers but instead will provide methods in the class to work with the vector. Create a new file, <em>vector.py</em>, inside <em>eqs</em> and enter the code in <a href="ch13.xhtml#ch13lis2">Listing 13-2</a>.</p>&#13;
<pre>from utils.lists import list_of_zeros&#13;
&#13;
&#13;
class Vector:&#13;
&#13;
    <span epub:type="pagebreak" id="page_341"/>def __init__(self, length: int):&#13;
        self.__length = length&#13;
        self.__data = list_of_zeros(length)&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.__length</pre>&#13;
<p class="caption"><a id="ch13lis2"/><em>Listing 13-2: <span class="codeitalic1">Vector</span> class</em></p>&#13;
<p class="indent">When an instance of the <span class="literal">Vector</span> class is initialized, we pass in a length. This length is kept in a private attribute called <span class="literal">__length</span> of the class and is exposed as a property using the <span class="literal">@property</span> decorator. This ensures the length property won’t be modified once the <span class="literal">Vector</span> class has been instantiated. Recall that properties are read-only attributes.</p>&#13;
<p class="indent">The vector’s data is stored in the <span class="literal">__data</span> attribute, which is initialized using our <span class="literal">list_of_zeros</span> function from before.</p>&#13;
<p class="indent">Let’s implement methods to set values in the vector. In the class, enter the new code in <a href="ch13.xhtml#ch13lis3">Listing 13-3</a>.</p>&#13;
<pre>class Vector:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def set_value(self, value: float, index: int):&#13;
       self.__data[index] = value&#13;
       return self&#13;
&#13;
   def add_to_value(self, amount: float, index: int):&#13;
       self.__data[index] += amount&#13;
       return self&#13;
&#13;
   def set_data(self, data: [float]):&#13;
       if len(data) != self.__length:&#13;
           raise ValueError('Cannot set data: length mismatch')&#13;
&#13;
       for i in range(self.__length):&#13;
           self.__data[i] = data[i]&#13;
&#13;
       return self</pre>&#13;
<p class="caption"><a id="ch13lis3"/><em>Listing 13-3: Setting vector values</em></p>&#13;
<p class="indent">We’ve added three new methods. The first one, <span class="literal">set_value</span>, is the simplest of all: it sets a value at the specified index inside the vector. Note that if the given <span class="literal">index</span> is either greater than or equal to the vector’s length, or smaller than zero, we raise what we commonly refer to as an <em>out of bounds</em> error, namely, an <span class="literal">IndexError</span>. We don’t need to check for this condition ourselves as long as we’re happy with how Python handles it. Note as well that the method returns <span class="literal">self</span>, that is, the instance of the class itself. We’ll keep using this pattern where we return the instance when setting values in our class. This is so that we can chain “set” operations or do things like</p>&#13;
<pre>vec = Vector(5).set_value(3, 2)</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_342"/>instead of having to do this less pretty equivalent:</p>&#13;
<pre>vec = Vector(5)&#13;
vec.set_value(3, 2)</pre>&#13;
<p class="indent">The second method we’ve defined is <span class="literal">add_to_value</span>, which adds the given amount to a value inside the vector. This method will be convenient when working with structures in <a href="part05.xhtml#part05">Part V</a> of the book, as you’ll see.</p>&#13;
<p class="indent">Lastly, we have <span class="literal">set_data</span>, which sets all the values in the vector from a source <span class="literal">data</span> list. To do so, it first checks that the provided list has the same length as the vector; then it copies each of the values to the private list <span class="literal">__data</span>.</p>&#13;
<p class="indent">Let’s now implement a method to retrieve values from the vector at given indices. In the <em>vector.py</em> file, enter the code in <a href="ch13.xhtml#ch13lis4">Listing 13-4</a>.</p>&#13;
<pre>class Vector:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def value_at(self, index: int):&#13;
       return self.__data[index]</pre>&#13;
<p class="caption"><a id="ch13lis4"/><em>Listing 13-4: Getting vector values</em></p>&#13;
<p class="indent">We’re almost done with the <span class="literal">Vector</span> class. We could implement many more methods to do things such as add or subtract vectors, but we won’t need them for the purposes of this book. The only method we’ll need and we haven’t implemented (or overridden) yet is <span class="literal">__eq__</span>, which we can use to check whether two <span class="literal">Vector</span> instances are equal. Let’s do so now. Start by adding the following import in <em>vector.py</em>:</p>&#13;
<pre>from geom2d import are_close_enough</pre>&#13;
<p class="indent">Then enter the new code in <a href="ch13.xhtml#ch13lis5">Listing 13-5</a>.</p>&#13;
<pre><span class="codestrong1">from geom2d import are_close_enough</span>&#13;
from utils.lists import list_of_zeros&#13;
&#13;
&#13;
class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Vector):&#13;
            return False&#13;
&#13;
        if self.__length != other.__length:&#13;
            return False&#13;
&#13;
        <span epub:type="pagebreak" id="page_343"/>for i in range(self.length):&#13;
            if not are_close_enough(&#13;
                    self.value_at(i),&#13;
                    other.value_at(i)&#13;
            ):&#13;
                return False&#13;
&#13;
        return True</pre>&#13;
<p class="caption"><a id="ch13lis5"/><em>Listing 13-5: <span class="codeitalic1">Vector</span> class equality</em></p>&#13;
<p class="indent">We first check whether we’re comparing the same instance against itself, in which case the result is <span class="literal">True</span> and we don’t need to compare anything else. Then, if the passed-in <span class="literal">other</span> is not an instance of the <span class="literal">Vector</span> class, we know the comparison can’t succeed, so we return <span class="literal">False</span>. If we find out we’re comparing two instances of the <span class="literal">Vector</span> class, we start the actual check. First we make sure the lengths of the vectors are the same (vectors with different sizes cannot be equal). If the length check succeeds, we finally check the values one by one using our <span class="literal">are_close_enough</span> function.</p>&#13;
<p class="indent">When we implement potentially computationally expensive <span class="literal">__eq__</span> methods, it’s important to check the less computationally intensive conditions first. Here, for example, we do a fast check on the lengths of the vectors before checking every pair of values for equality. Whereas the pairwise value comparison needs to perform <em>n</em> comparisons (where <em>n</em> is the length of the vectors), the length comparison requires only one comparison.</p>&#13;
<p class="indent">Our finished <span class="literal">Vector</span> class should look like the one in <a href="ch13.xhtml#ch13lis6">Listing 13-6</a>.</p>&#13;
<pre>from geom2d import are_close_enough&#13;
from utils.lists import list_of_zeros&#13;
&#13;
&#13;
class Vector:&#13;
&#13;
    def __init__(self, length: int):&#13;
        self.__length = length&#13;
        self.__data = list_of_zeros(length)&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.__length&#13;
&#13;
    def set_value(self, value: float, index: int):&#13;
        self.__data[index] = value&#13;
        return self&#13;
&#13;
    def add_to_value(self, amount: float, index: int):&#13;
        self.__data[index] += amount&#13;
        return self&#13;
&#13;
    <span epub:type="pagebreak" id="page_344"/>def set_data(self, data: [float]):&#13;
        if len(data) != self.__length:&#13;
            raise ValueError('Cannot set data: length mismatch')&#13;
&#13;
        for i in range(self.__length):&#13;
            self.__data[i] = data[i]&#13;
&#13;
        return self&#13;
&#13;
    def value_at(self, index: int):&#13;
        return self.__data[index]&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Vector):&#13;
            return False&#13;
&#13;
        if self.__length != other.__length:&#13;
            return False&#13;
&#13;
        for i in range(self.length):&#13;
            if not are_close_enough(&#13;
                    self.value_at(i),&#13;
                    other.value_at(i)&#13;
            ):&#13;
                return False&#13;
&#13;
        return True</pre>&#13;
<p class="caption"><a id="ch13lis6"/><em>Listing 13-6: <span class="codeitalic1">Vector</span> class result</em></p>&#13;
<p class="indent">Because this class will serve as the base for the resolution of systems of linear equations, we can’t afford to have any bugs in its implementation: that would render the resolution of such systems useless. Let’s add a few tests to make sure the class is bug-free.</p>&#13;
<h4 class="h4" id="ch00lev2sec144"><strong><em>Testing the Vector Class</em></strong></h4>&#13;
<p class="noindent">At the beginning of the chapter we created a <em>test</em> directory inside the <em>eqs</em> package. Inside that directory, create a new file named <em>vector_test.py</em> and enter the code in <a href="ch13.xhtml#ch13lis7">Listing 13-7</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from eqs.vector import Vector&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_345"/>class VectorTest(unittest.TestCase):&#13;
&#13;
    def test_length(self):&#13;
        self.assertEqual(5, Vector(5).length)&#13;
&#13;
    def test_unset_value_is_zero(self):&#13;
        vector = Vector(2)&#13;
        self.assertEqual(0.0, vector.value_at(0))&#13;
        self.assertEqual(0.0, vector.value_at(1))&#13;
&#13;
    def test_set_get_value(self):&#13;
        value = 10.0&#13;
        vector = Vector(2).set_value(value, 1)&#13;
        self.assertEqual(0.0, vector.value_at(0))&#13;
        self.assertEqual(value, vector.value_at(1))&#13;
&#13;
    def test_add_to_value(self):&#13;
        vector = Vector(2).set_data([1, 2]).add_to_value(10, 0)&#13;
        self.assertEqual(11, vector.value_at(0))&#13;
        self.assertEqual(2, vector.value_at(1))</pre>&#13;
<p class="caption"><a id="ch13lis7"/><em>Listing 13-7: <span class="codeitalic1">Vector</span> class unit tests</em></p>&#13;
<p class="indent">This code defines a new test class, <span class="literal">VectorTest</span>, with four unit tests. Run all the tests to make sure they pass and our implementation is right. You can do so from the bash shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest eqs/tests/vector_test.py</span></pre>&#13;
<p class="indent">The first test, <span class="literal">test_length</span>, checks that the vector’s <span class="literal">length</span> property returns the right number. Then comes <span class="literal">test_unset_value_is_zero</span>, which ensures that we properly initialize the vector, filling it with zeros. The <span class="literal">test_set_get</span> <span class="literal">_value</span> sets the value 10.0 at index 1 and checks that the vector returns that same value when asked for the item at index 1. We also assert that the vector returns a zero for the item at index 0, just to make sure that <span class="literal">set_value</span> doesn’t modify any value other than the one it’s supposed to. Last, we have <span class="literal">test_add_to_value</span> to test the <span class="literal">add_to_value</span> method. The test initializes the vector with values [1, 2], adds 10 units to the item at index 0, and asserts that the value at that index is updated correctly.</p>&#13;
<p class="indent">You may have noticed that the <span class="literal">test_set_get_value</span> test may actually fail for two different reasons: an error in the implementation of the vector’s (1) <span class="literal">set_value</span> method or (2) <span class="literal">value_at</span> method. That’s mostly true, and you’d be right to point out that we broke our first rule for good testing here (see “Three Golden Rules for Unit Testing” on <a href="ch04.xhtml#ch00lev2sec57">page 97</a>). But it’s hard to test <span class="literal">set_value</span> without using the <span class="literal">value_at</span> method in the assertion. We could get the value by somehow accessing the vector’s private <span class="literal">__data</span> instead of using <span class="literal">value_at</span>, but it’s preferable to test a class through its public API and not access its implementation details. We want to be able to change the internal implementation of our classes without altering their behavior, and that <span epub:type="pagebreak" id="page_346"/>shouldn’t break any test. If we rely on the internals of a class to test it, we couple the test to the class’s implementation.</p>&#13;
<p class="indent">As a rule of thumb, the private implementation of a class should always be kept secret to the outside world; only the class itself should know about it. This is called <em>encapsulation</em> in object-oriented parlance.</p>&#13;
<p class="indent">Our <span class="literal">Vector</span> class is now ready and tested. Let’s implement a class to represent matrices.</p>&#13;
<h3 class="h3" id="ch00lev1sec81"><strong>Matrices</strong></h3>&#13;
<p class="noindent">Matrices add an extra dimension to vectors. Matrices are an array of numbers distributed in rows and columns.</p>&#13;
<p class="indent">Let’s create a new file <em>matrix.py</em> inside the <em>eqs</em> directory. Enter the initial definition for the <span class="literal">Matrix</span> class, as in <a href="ch13.xhtml#ch13lis8">Listing 13-8</a>.</p>&#13;
<pre>from utils.lists import list_of_list_of_zeros&#13;
&#13;
&#13;
class Matrix:&#13;
&#13;
    def __init__(self, rows_count: int, cols_count: int):&#13;
        self.__rows_count = rows_count&#13;
        self.__cols_count = cols_count&#13;
        self.__is_square = rows_count == cols_count&#13;
        self.__data = list_of_list_of_zeros(rows_count, cols_count)&#13;
&#13;
    @property&#13;
    def rows_count(self):&#13;
        return self.__rows_count&#13;
&#13;
    @property&#13;
    def cols_count(self):&#13;
        return self.__cols_count&#13;
&#13;
    @property&#13;
    def is_square(self):&#13;
        return self.__is_square</pre>&#13;
<p class="caption"><a id="ch13lis8"/><em>Listing 13-8: <span class="codeitalic1">Matrix</span> class</em></p>&#13;
<p class="indent">The <span class="literal">Matrix</span> class is initialized with the number of rows and columns. These values are saved as private attributes of the class: <span class="literal">__rows_count</span> and <span class="literal">__cols_count</span>. They are exposed as public properties: <span class="literal">rows_count</span> and <span class="literal">cols</span> <span class="literal">_count</span>. A matrix is square if it has the same number of rows and columns. We exposed this as a property as well: <span class="literal">is_square</span>. Last, we initialize the private attribute <span class="literal">__data</span> with a list of lists of zeros using the function that we created at the beginning of the chapter.</p>&#13;
<h4 class="h4" id="ch00lev2sec145"><span epub:type="pagebreak" id="page_347"/><strong><em>Setting Values</em></strong></h4>&#13;
<p class="noindent">Let’s add the methods to set the matrix’s values. In the <span class="literal">Matrix</span> class, enter the two methods in <a href="ch13.xhtml#ch13lis9">Listing 13-9</a>.</p>&#13;
<pre>class Matrix:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def set_value(self, value: float, row: int, col: int):&#13;
       self.__data[row][col] = value&#13;
       return self&#13;
&#13;
   def add_to_value(self, amount: float, row: int, col: int):&#13;
       self.__data[row][col] += amount&#13;
       return self</pre>&#13;
<p class="caption"><a id="ch13lis9"/><em>Listing 13-9: Setting matrix values</em></p>&#13;
<p class="indent">Like we did with our <span class="literal">Vector</span> class, we’ve implemented one method to set a value in the matrix given its position (given by <span class="literal">row</span> and <span class="literal">col</span>) and one method to add a given amount to an existing value in the matrix. Following our convention of returning the instance when a value is set, both <span class="literal">set_value</span> and <span class="literal">add_to_value</span> return <span class="literal">self</span>.</p>&#13;
<p class="indent">It’ll also be handy to have a way to fill the matrix given a list of values, so after what we’ve just written, enter the method in <a href="ch13.xhtml#ch13lis10">Listing 13-10</a>.</p>&#13;
<pre>class Matrix:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def set_data(self, data: [float]):&#13;
    <span class="ent">➊</span> if len(data) != self.__cols_count * self.__rows_count:&#13;
           raise ValueError('Cannot set data: size mismatch')&#13;
&#13;
       for row in range(self.__rows_count):&#13;
        <span class="ent">➋</span> offset = self.__cols_count * row&#13;
           for col in range(self.__cols_count):&#13;
            <span class="ent">➌</span> self.__data[row][col] = data[offset + col]&#13;
&#13;
       return self</pre>&#13;
<p class="caption"><a id="ch13lis10"/><em>Listing 13-10: Setting data to the matrix</em></p>&#13;
<p class="indent">As you can already tell, using the values in a list to set the matrix data is not as straightforward as it was for vectors. There’s a check we need to perform to make sure the data fits inside the matrix: the given <span class="literal">data</span> should have the same length as the number of rows times the number of columns <span class="ent">➊</span>, the total number of values the matrix holds. If it doesn’t, we raise a <span class="literal">ValueError</span>.</p>&#13;
<p class="indent">Then, we iterate through the matrix’s row indices. In the <span class="literal">offset</span> variable we store the offset to the beginning of the current’s row data inside the input list <span class="ent">➋</span>. For the row at index 0, the offset is 0 as well. For the row at index 1, the offset will be the length of a row: the number of columns in the <span epub:type="pagebreak" id="page_348"/>matrix, and so forth. <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> shows this offset. We iterate through the column’s indices and set each of the values in <span class="literal">__data</span> from the input <span class="literal">data</span> <span class="ent">➌</span>.</p>&#13;
<div class="image"><img src="../images/13fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch13fig1"><em>Figure 13-1: Setting matrix data from a list</em></p>&#13;
<p class="indent">As we’ll see in <a href="part05.xhtml#part05">Part V</a> of the book, when we’re working with truss structures, one of the steps for computing the structure’s system of equations is accounting for the external constraints on nodes. We’ll get into all the details later, but for now it’s enough to know that this modification requires that we set a row and a column of the matrix as identity vectors. For example, if we had the following matrix,</p>&#13;
<div class="equationc"><img src="../images/f00348-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">setting the row and column with indices 0 and 1, respectively, as identity vectors would result in the following:</p>&#13;
<div class="equationc"><img src="../images/f00348-p2.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s write two methods to do this in our <span class="literal">Matrix</span> class. Enter the code in <a href="ch13.xhtml#ch13lis11">Listing 13-11</a>.</p>&#13;
<pre>class Matrix:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def set_identity_row(self, row: int):&#13;
        for col in range(self.__cols_count):&#13;
            self.__data[row][col] = 1 if row == col else 0&#13;
&#13;
        return self&#13;
&#13;
    def set_identity_col(self, col: int):&#13;
        for row in range(self.__rows_count):&#13;
            self.__data[row][col] = 1 if row == col else 0&#13;
&#13;
        return self</pre>&#13;
<p class="caption"><a id="ch13lis11"/><em>Listing 13-11: Setting identity rows and columns</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_349"/>We implemented two new methods: <span class="literal">set_identity_row</span> and <span class="literal">set_identity_col</span>. Both are similar in implementation: they set all values in the row or column as 0 except for the position in the main diagonal, which is set to 1.</p>&#13;
<p class="indent">In this code, we’ve used a compact condition expression: a ternary operator. This operator’s syntax is as follows:</p>&#13;
<pre>&lt;<span class="codeitalic1">expression</span>&gt; if &lt;<span class="codeitalic1">condition</span>&gt; else &lt;<span class="codeitalic1">expression</span>&gt;</pre>&#13;
<p class="noindent">It returns one of the two expressions depending on the condition value. In this particular case, our condition is <span class="literal">row == col</span>, which is <span class="literal">True</span> if the row and column indices are equal.</p>&#13;
<p class="indent">Note that if the matrix is not square, it can happen that we set a row or column as the identity vector and it ends up filled with all zeros. For example, see <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>. We have a matrix with three rows and two columns, and we set the third row (the row at index 2) as the identity. Since the matrix has only two columns, the value 1 would be outside the matrix, in the nonexistent third column.</p>&#13;
<div class="image"><img src="../images/13fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch13fig2"><em>Figure 13-2: Setting an identity row in a nonsquare matrix</em></p>&#13;
<p class="indent">Let’s now add two methods to get values from the matrix.</p>&#13;
<h4 class="h4" id="ch00lev2sec146"><strong><em>Getting Values</em></strong></h4>&#13;
<p class="noindent">We need to implement <span class="literal">value_at</span> to get a value at the given row and column indices. We also want another method, <span class="literal">value_transposed_at</span>, which pulls a value from the matrix as if the matrix had been transposed. Quick reminder: the transpose of a matrix [<em>M</em>] is another matrix [<em>M</em>]<sup>′</sup> where [<em>M</em>]’s rows are swapped with its columns:</p>&#13;
<div class="equationc"><img src="../images/f00349-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">We’ll use this second method in <a href="ch14.xhtml#ch14">Chapter 14</a> in our implementation of Cholesky’s factorization algorithm to solve linear systems of equations. We could also implement a method in our <span class="literal">Matrix</span> class that returned a new matrix resulting from transposing the current one and then withdraw the values from this matrix. That would be a good option indeed, but as matrices representing systems of equations are often enough very big, copying all the values into a new matrix is a computationally expensive operation. Being able to get values from the matrix as if it were transposed is a performance optimization we’ll use in our Cholesky implementation.<span epub:type="pagebreak" id="page_350"/></p>&#13;
<p class="indent">In <em>matrix.py</em>, enter the code in <a href="ch13.xhtml#ch13lis12">Listing 13-12</a>.</p>&#13;
<pre>class Matrix:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def value_at(self, row: int, col: int):&#13;
        return self.__data[row][col]&#13;
&#13;
    def value_transposed_at(self, row: int, col: int):&#13;
        return self.__data[col][row]</pre>&#13;
<p class="caption"><a id="ch13lis12"/><em>Listing 13-12: Getting matrix values</em></p>&#13;
<p class="indent">First we implement <span class="literal">value_at</span>. This method returns a value in the given row and column indices from the private data storage. Then we have <span class="literal">value</span> <span class="literal">_transposed_at</span>. As you can see, this method is similar to <span class="literal">value_at</span>. The only difference is that instead of being</p>&#13;
<p class="pre2">    self.__data[row][col]</p>&#13;
<p class="noindent">this time the value pulled from the matrix is</p>&#13;
<p class="pre2">    self.__data[col][row]</p>&#13;
<p class="noindent">This retrieves the value of that matrix as if it were transposed simply by swapping the <span class="literal">row</span> and <span class="literal">col</span> indices. This method will bring us a big performance improvement later.</p>&#13;
<p class="indent">One thing to keep in mind when using this method is that the row index we pass in should be no greater than the number of columns, and the column index should be no greater than the number of rows. Since we’re accessing the matrix’s data as if it were transposed, the actual number or rows is the number of columns from the original matrix. The same goes for the number of columns.</p>&#13;
<h4 class="h4" id="ch00lev2sec147"><strong><em>Scaling Values</em></strong></h4>&#13;
<p class="noindent">Let’s implement one last useful method: scaling the matrix. The same way we can scale a vector, we can scale a matrix by multiplying all of its values by a scalar. Enter the method in <a href="ch13.xhtml#ch13lis13">Listing 13-13</a>.</p>&#13;
<pre>class Matrix:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def scale(self, factor: float):&#13;
        for i in range(self.__rows_count):&#13;
            for j in range(self.__cols_count):&#13;
                self.__data[i][j] *= factor&#13;
&#13;
        return self</pre>&#13;
<p class="caption"><a id="ch13lis13"/><em>Listing 13-13: Scaling a matrix</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_351"/>This method iterates through all the row and column indices and multiplies the value stored in every position by the passed-in <span class="literal">factor</span>. We return <span class="literal">self</span>, as this is a method that sets data.</p>&#13;
<h4 class="h4" id="ch00lev2sec148"><strong><em>Matrix Equality</em></strong></h4>&#13;
<p class="noindent">To finish the implementation for our <span class="literal">Matrix</span> class, let’s include the <span class="literal">__eq__</span> method to compare matrices for equality. Start by adding the following import at the top of <em>matrix.py</em>:</p>&#13;
<pre>from geom2d import are_close_enough</pre>&#13;
<p class="noindent">Then enter the implementation for the <span class="literal">__eq__</span> method in <a href="ch13.xhtml#ch13lis14">Listing 13-14</a>.</p>&#13;
<pre><span class="codestrong1">from geom2d import are_close_enough</span>&#13;
from utils.lists import list_of_list_of_zeros&#13;
&#13;
&#13;
class Matrix:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Matrix):&#13;
            return False&#13;
&#13;
        if self.__rows_count != other.rows_count:&#13;
            return False&#13;
&#13;
        if self.__cols_count != other.cols_count:&#13;
            return False&#13;
&#13;
        for i in range(self.__rows_count):&#13;
            for j in range(self.__cols_count):&#13;
                if not are_close_enough(&#13;
                        self.__data[i][j],&#13;
                        other.__data[i][j]&#13;
                ):&#13;
                    return False&#13;
&#13;
        return True</pre>&#13;
<p class="caption"><a id="ch13lis14"/><em>Listing 13-14: <span class="codeitalic1">Matrix</span> class equality</em></p>&#13;
<p class="indent">As usual, we start by checking the references for <span class="literal">self</span> and <span class="literal">other</span>, because if we’re comparing an instance against itself, there’s no need to compare anything else, and the comparison can safely return <span class="literal">True</span>. Then, we make sure the passed-in <span epub:type="pagebreak" id="page_352"/>object is an instance of the <span class="literal">Matrix</span> class; otherwise, there’s not much we can compare.</p>&#13;
<p class="indent">Before we start comparing values from the matrices one by one, we want to make sure we have matrices of the same size. If we detect that either the row or column lengths don’t match, we return <span class="literal">False</span>.</p>&#13;
<p class="indent">Finally, if all the previous checks haven’t returned a value, we compare the values of both matrices. As soon as we find a pair of values that aren’t equal (according to our <span class="literal">are_close_enough</span> function), we return <span class="literal">False</span>. If all values are equal, we exit the <span class="literal">for</span> loops and finally return <span class="literal">True</span>.</p>&#13;
<p class="indent">For reference, your <em>matrix.py</em> file should look like <a href="ch13.xhtml#ch13lis15">Listing 13-15</a>.</p>&#13;
<pre>from geom2d import are_close_enough&#13;
from utils.lists import list_of_list_of_zeros&#13;
&#13;
&#13;
class Matrix:&#13;
&#13;
    def __init__(self, rows_count: int, cols_count: int):&#13;
        self.__rows_count = rows_count&#13;
        self.__cols_count = cols_count&#13;
        self.__is_square = rows_count == cols_count&#13;
        self.__data = list_of_list_of_zeros(rows_count, cols_count)&#13;
&#13;
    @property&#13;
    def rows_count(self):&#13;
        return self.__rows_count&#13;
&#13;
    @property&#13;
    def cols_count(self):&#13;
        return self.__cols_count&#13;
&#13;
    @property&#13;
    def is_square(self):&#13;
        return self.__is_square&#13;
&#13;
    def set_value(self, value: float, row: int, col: int):&#13;
        self.__data[row][col] = value&#13;
        return self&#13;
&#13;
    def add_to_value(self, amount: float, row: int, col: int):&#13;
        self.__data[row][col] += amount&#13;
        return self&#13;
&#13;
    def set_data(self, data: [float]):&#13;
        if len(data) != self.__cols_count * self.__rows_count:&#13;
            raise ValueError('Cannot set data: size mismatch')&#13;
&#13;
        for row in range(self.__rows_count):&#13;
            <span epub:type="pagebreak" id="page_353"/>offset = self.__cols_count * row&#13;
            for col in range(self.__cols_count):&#13;
                self.__data[row][col] = data[offset + col]&#13;
&#13;
        return self&#13;
&#13;
    def set_identity_row(self, row: int):&#13;
        for col in range(self.__cols_count):&#13;
            self.__data[row][col] = 1 if row == col else 0&#13;
&#13;
        return self&#13;
&#13;
    def set_identity_col(self, col: int):&#13;
        for row in range(self.__rows_count):&#13;
            self.__data[row][col] = 1 if row == col else 0&#13;
&#13;
        return self&#13;
&#13;
    def value_at(self, row: int, col: int):&#13;
        return self.__data[row][col]&#13;
&#13;
    def value_transposed_at(self, row: int, col: int):&#13;
        return self.__data[col][row]&#13;
&#13;
    def scale(self, factor: float):&#13;
        for i in range(self.__rows_count):&#13;
            for j in range(self.__cols_count):&#13;
                self.__data[i][j] *= factor&#13;
&#13;
        return self&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Matrix):&#13;
            return False&#13;
&#13;
        if self.__rows_count != other.rows_count:&#13;
            return False&#13;
&#13;
        if self.__cols_count != other.cols_count:&#13;
            return False&#13;
&#13;
        for i in range(self.__rows_count):&#13;
            for j in range(self.__cols_count):&#13;
                if not are_close_enough(&#13;
                        <span epub:type="pagebreak" id="page_354"/>self.__data[i][j],&#13;
                        other.__data[i][j]&#13;
                ):&#13;
                    return False&#13;
&#13;
        return True</pre>&#13;
<p class="caption"><a id="ch13lis15"/><em>Listing 13-15: <span class="codeitalic1">Matrix</span> class result</em></p>&#13;
<p class="indent">Our <span class="literal">Matrix</span> class is almost ready! We need to check for bugs. We may have made some small mistakes when writing the code. This could be problematic once we start using this class to solve systems of equations. These kinds of calculations are usually mission-critical in engineering applications. Thus, we can’t afford a single bug in our implementation. But that’s no problem for us. We know how to tackle this: let’s add some automated unit tests.</p>&#13;
<h4 class="h4" id="ch00lev2sec149"><strong><em>Testing the Matrix Class</em></strong></h4>&#13;
<p class="noindent">In the <em>tests</em> folder, create a new file named <em>matrix_test.py</em>. Enter the initial code for the test in <a href="ch13.xhtml#ch13lis16">Listing 13-16</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from eqs.matrix import Matrix&#13;
&#13;
&#13;
class MatrixTest(unittest.TestCase):&#13;
&#13;
    def test_is_square(self):&#13;
        self.assertTrue(&#13;
            Matrix(2, 2).is_square&#13;
        )&#13;
&#13;
    def test_is_not_square(self):&#13;
        self.assertFalse(&#13;
            Matrix(2, 3).is_square&#13;
        )</pre>&#13;
<p class="caption"><a id="ch13lis16"/><em>Listing 13-16: <span class="codeitalic1">Matrix</span> unit tests</em></p>&#13;
<p class="indent">In this file we define a new test class called <span class="literal">MatrixTest</span>, which inherits from <span class="literal">TestCase</span>. We created two tests for the <span class="literal">is_square</span> property, one to check if a matrix is actually square, and another to check if a matrix is not square. Run the tests; ideally they both pass, but if not, go back to the implementation of the property and ensure you have the implementation right. You can run the tests from the shell using the following command:</p>&#13;
<pre>$  <span class="codestrong1">python3 -m unittest eqs/tests/matrix_test.py</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_355"/>You should get output similar to the following:</p>&#13;
<pre>Ran 2 tests in 0.001s&#13;
&#13;
OK</pre>&#13;
<p class="indent">Let’s now check the methods that set or get values. After the two tests we just wrote, enter the tests in <a href="ch13.xhtml#ch13lis17">Listing 13-17</a>.</p>&#13;
<pre>class MatrixTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_unset_value_is_zero(self):&#13;
        matrix = Matrix(2, 2)&#13;
        self.assertEqual(0.0, matrix.value_at(0, 1))&#13;
&#13;
    def test_set_get_value(self):&#13;
        value = 10.0&#13;
        matrix = Matrix(2, 2).set_value(value, 0, 1)&#13;
        self.assertEqual(value, matrix.value_at(0, 1))&#13;
&#13;
    def test_add_to_value(self):&#13;
        expected = [1, 12, 3, 4]&#13;
        matrix = Matrix(2, 2) \&#13;
            .set_data([1, 2, 3, 4]) \&#13;
            .add_to_value(10, 0, 1)&#13;
        self.assert_matrix_has_data(matrix, expected)</pre>&#13;
<p class="caption"><a id="ch13lis17"/><em>Listing 13-17: Testing setting and getting values</em></p>&#13;
<p class="indent">The first test ensures that values in the matrix that haven’t been set are zero upon instantiation. Then we test that both the <span class="literal">set_value</span> and <span class="literal">value_at</span> methods actually set and get matrix values. Lastly, we test the <span class="literal">add_to_value</span> method, making sure that it adds a given amount to an already set value.</p>&#13;
<p class="indent">In this last test, we’ve used an assertion method that doesn’t exist: <span class="literal">assert</span> <span class="literal">_matrix_has_data</span>. We need to implement this method ourselves inside the <span class="literal">MatrixTest</span> class, and we’ll use it when we need to ensure all values inside a matrix are as expected. By doing this, we can use only one assertion to check that the values in a matrix are the same as the values in a list passed in as the second parameter. Inside the test class, toward the end, enter the method definition shown in <a href="ch13.xhtml#ch13lis18">Listing 13-18</a>.</p>&#13;
<pre>class MatrixTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
   def assert_matrix_has_data(self, matrix, data):&#13;
       for row in range(matrix.rows_count):&#13;
           offset = matrix.cols_count * row&#13;
           for col in range(matrix.cols_count):&#13;
               <span epub:type="pagebreak" id="page_356"/>self.assertEqual(&#13;
                   data[offset + col],&#13;
                   matrix.value_at(row, col)&#13;
               )</pre>&#13;
<p class="caption"><a id="ch13lis18"/><em>Listing 13-18: Custom assertion for matrix values</em></p>&#13;
<p class="indent">This assertion method has the same structure as <span class="literal">set_data</span> inside the <span class="literal">Matrix</span> class. This time, instead of setting values, we use <span class="literal">assertEqual</span> to test for equality.</p>&#13;
<p class="indent">We have to note that, by including an assertion method that has some logic of its own (the <span class="literal">offset</span> computation in this case), we introduce one more possible reason for the tests to fail: the assertion method itself being wrongly implemented. As always, if we want to be practical, we need to make trade-offs. We can use our engineering common sense to analyze the pros, cons, and alternatives. In this case, having a custom assertion to check matrix values is worth it: it facilitates the simple assertion of matrix values and makes writing new tests and checking matrix values painless. We just have to be extra sure that our logic in the assertion method is correct.</p>&#13;
<p class="indent">Let’s now test the <span class="literal">set_data</span> method. The test is in <a href="ch13.xhtml#ch13lis19">Listing 13-19</a>.</p>&#13;
<pre>class MatrixTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_set_data(self):&#13;
       data = [1, 2, 3, 4, 5, 6]&#13;
       matrix = Matrix(2, 3).set_data(data)&#13;
       self.assert_matrix_has_data(matrix, data)</pre>&#13;
<p class="caption"><a id="ch13lis19"/><em>Listing 13-19: Testing setting data from a list</em></p>&#13;
<p class="indent">In this test we’re using our custom assertion method, which makes the test quite short and concise. We create a matrix with two rows and three columns, set its data using a list with the numbers between 1 and 6, and then assert they’ve been correctly placed in their respective slots.</p>&#13;
<p class="indent">Moving on, our next tests should be for the methods that set identity rows and columns. Enter the tests in <a href="ch13.xhtml#ch13lis20">Listing 13-20</a>.</p>&#13;
<pre>class MatrixTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_set_identity_row(self):&#13;
        expected = [1, 0, 4, 5]&#13;
        matrix = Matrix(2, 2) \&#13;
            .set_data([2, 3, 4, 5]) \&#13;
            .set_identity_row(0)&#13;
        self.assert_matrix_has_data(matrix, expected)&#13;
&#13;
    def test_set_identity_col(self):&#13;
        expected = [2, 0, 4, 1]&#13;
        <span epub:type="pagebreak" id="page_357"/>matrix = Matrix(2, 2) \&#13;
            .set_data([2, 3, 4, 5]) \&#13;
            .set_identity_col(1)&#13;
        self.assert_matrix_has_data(matrix, expected)</pre>&#13;
<p class="caption"><a id="ch13lis20"/><em>Listing 13-20: Testing setting identity rows and columns</em></p>&#13;
<p class="indent">In these two tests we start by specifying the expected values for the resulting matrix. Then, we create a new 2×2 matrix and set its values to the list of numbers between 2 and 5. We set the identity row or column and assert that the values are as expected.</p>&#13;
<p class="indent">We avoided using 1 for any of the initial values in the matrix: the methods we’re testing will set one of the values inside the matrix with a 1. Imagine that our implementation of the <span class="literal">set_identity_row</span> method wrongly set a value in the matrix as a 1 and that it chose to set the same value that we already initialized as 1. Our tests wouldn’t be able to detect such an error because there’s no way to tell whether that 1 is the one we set ourselves in the beginning of the test or a value that the <span class="literal">set_identity_row</span> method set. By not using 1 as an input value, we avoid exposing our test to such a problem.</p>&#13;
<p class="indent">There’s one last method we implemented in our <span class="literal">Matrix</span> class that needs to be tested: <span class="literal">scale</span>. Enter the test in <a href="ch13.xhtml#ch13lis21">Listing 13-21</a>.</p>&#13;
<pre>class MatrixTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_scale(self):&#13;
       expected = [2, 4, 6, 8, 10, 12]&#13;
       matrix = Matrix(2, 3) \&#13;
           .set_data([1, 2, 3, 4, 5, 6]) \&#13;
           .scale(2)&#13;
       self.assert_matrix_has_data(matrix, expected)</pre>&#13;
<p class="caption"><a id="ch13lis21"/><em>Listing 13-21: Testing scaling matrices</em></p>&#13;
<p class="indent">This test creates a 2×3 matrix, sets its data using the numbers from 1 to 6, and then scales everything by 2. Using the custom <span class="literal">assert_matrix_has_data</span> assertion we check that all values have been scaled correctly. Make sure to run the tests in the test class. From the shell, this would be as follows:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest eqs/tests/matrix_test.py</span></pre>&#13;
<p class="noindent">You should get an output similar to the following:</p>&#13;
<pre>Ran 9 tests in 0.001s&#13;
&#13;
OK</pre>&#13;
<h3 class="h3" id="ch00lev1sec82"><strong>Summary</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_358"/>In this chapter, we implemented two classes that we’ll need to work with systems of equations: <span class="literal">Vector</span> and <span class="literal">Matrix</span>. In the next chapter, we’ll use these two classes to represent systems of equations that we’ll solve using numerical methods.</p>&#13;
</body></html>