<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_171"/><span class="big">7</span><br/>AFFINE TRANSFORMATIONS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">If I had to choose my favorite topic from this book, it would be affine transformations. There’s something oddly beautiful about affine transformations, as you’ll see for yourself in <a href="ch12.xhtml#ch12">Chapter 12</a> when we animate them.</p>&#13;
<p class="indent">Affine transformations are crucial to 2D graphic applications; they determine how to pan, zoom, and rotate what you see on the screen. If you’ve used AutoCAD, you’re pretty much used to zooming in to a portion of the drawing, which is done with an affine transformation. Whenever you scale and rotate your pics in Instagram, an affine transformation does the trick. Mastering this topic is essential for writing any piece of software involving graphics, even more so for those where the user is allowed to interact with them.</p>&#13;
<p class="indent">The math behind affine transformations is quite simple, yet the concept is stunningly powerful. By the end of this chapter, you’ll have a class representing these transformations with methods to apply them to geometric primitives. We’ll also learn how to combine transformations to compute compound transformations and take a look at some useful transformations, such as one that zooms a drawing around a concrete point.</p>&#13;
<h3 class="h3" id="ch00lev1sec43"><span epub:type="pagebreak" id="page_172"/><strong>Affine Transformations</strong></h3>&#13;
<p class="noindent">Since affine transformations apply to affine spaces, let’s first try to understand what an affine space is. You can think of an <em>affine space</em> as being a vector space where the origin point can be moved around. The linear transformations used in vector spaces preserve the position of the space’s origin, whereas in an affine space, as we stop caring about a fixed origin, translations are allowed.</p>&#13;
<p class="indent">An <em>affine transformation</em>, then, is a mapping between two affine spaces that preserves points, straight lines, and planes. Points after an affine transformation stay as points, straight lines continue to be straight, and planes remain plane. One interesting property of these transformations is that parallelism between lines is preserved. We’ll see this in action in <a href="ch12.xhtml#ch12">Chapter 12</a> when we animate affine transformations. In that exercise, we’ll see how the sides of polygons that were originally parallel remain parallel during the whole simulation.</p>&#13;
<p class="indent">Affine transformations are similar to <em>linear transformations</em>. The only difference is that the latter preserves the origin; that is, the point (0, 0) doesn’t move. Affine transformations can alter the position of the origin. <a href="ch07.xhtml#ch7fig1">Figure 7-1</a> depicts both a linear transformation and an affine transformation.</p>&#13;
<div class="image"><img src="../images/07fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig1"><em>Figure 7-1: Linear versus affine transformation</em></p>&#13;
<p class="indent">Each pair of axes <em>x,y</em> in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a> shows how the space was before the transformation; each <em>x</em><sup>′</sup>, <em>y</em><sup>′</sup> pair shows what the space looks like after the transformation. In the case of the linear transformation, the origin of coordinates <em>O</em> is preserved; the affine transformation, in addition to scaling and rotating the axes, translated the origin <em>O</em> to <em>O</em><sup>′</sup>.</p>&#13;
<p class="indent">Given a point <em>P</em>, we can define an affine transformation using the expression</p>&#13;
<div class="equationc"><img src="../images/f00172-p1.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>M</em> is a linear transformation, <img class="inline" src="../images/tvictorit.jpg" alt="Image"/> is a translation vector, and <em>P</em><sup>′</sup> is the resulting point after applying the transformation. An affine transformation is thus a linear transformation <em>M</em> plus a translation <img class="inline" src="../images/tvictorit.jpg" alt="Image"/>. This expression can be written with all its terms as shown in <a href="ch07.xhtml#ch07eqa01">Equation 7.1</a>.</p>&#13;
<div class="equationc" id="ch07eqa01"><img src="../images/07eqa01.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/>The linear transformation matrix <em>M</em> has the items</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><em>s</em><sub><em>x</em></sub>    Scale in the x direction</p>&#13;
<p class="noindentin"><em>s</em><sub><em>y</em></sub>    Scale in the y direction</p>&#13;
<p class="noindentin"><em>sh</em><sub><em>x</em></sub>    Shear in the x direction</p>&#13;
<p class="noindentin"><em>sh</em><sub><em>y</em></sub>    Shear in the y direction</p>&#13;
</div>&#13;
<p class="noindent">and the translation <img class="inline" src="../images/tvictorit.jpg" alt="Image"/> has the terms</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><em>t</em><sub><em>x</em></sub>    Translation in the x direction</p>&#13;
<p class="noindentin"><em>t</em><sub><em>y</em></sub>    Translation in the y direction</p>&#13;
</div>&#13;
<p class="indent"><a href="ch07.xhtml#ch07eqa02">Equation 7.2</a> shows an equivalent form using what is known as the <em>augmented matrix</em>.</p>&#13;
<div class="equationc" id="ch07eqa02"><img src="../images/07eqa02.jpg" alt="Image"/></div>&#13;
<p class="indent">This version reduces the transformation to one matrix multiplication by extending the size of the input and output vectors, appending a 1, which serves as an auxiliary value and can be discarded once the transformation has taken place. It’s usually preferred as it requires only one step compared to the extra addition involved in the former. You can observe how in both cases, <a href="ch07.xhtml#ch07eqa01">Equations 7.1</a> and <a href="ch07.xhtml#ch07eqa02">7.2</a>, the resulting coordinates are as shown in <a href="ch07.xhtml#ch07eqa03">Equation 7.3</a>.</p>&#13;
<div class="equationc" id="ch07eqa03"><img src="../images/07eqa03.jpg" alt="Image"/></div>&#13;
<p class="indent">Each of the values in the matrix from <a href="ch07.xhtml#ch07eqa02">Equation 7.2</a> contributes differently in the transformation process. <a href="ch07.xhtml#ch7fig2">Figure 7-2</a> showcases the transformation that each of the components produces. A generic affine transformation is therefore a combination of those unitary transformations.</p>&#13;
<div class="image"><img src="../images/07fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig2"><em>Figure 7-2: Components of affine transformations</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>There is a special affine transformation that maps each point to itself, the <em>identity transformation</em>.</p>&#13;
<div class="equationc"><img src="../images/f0174-01.jpg" alt="Image"/></div>&#13;
<p class="indent">As you can observe, this is an identity matrix: whatever point you multiply this matrix by will stay the same.</p>&#13;
<h4 class="h4" id="ch00lev2sec80"><strong><em>Examples of Affine Transformations</em></strong></h4>&#13;
<p class="noindent">Let’s look at a few examples of affine transformations in action. For this section, leave your computer aside and take out your pen and paper. If you can work through the operations to transform spaces using affine transformations by hand, coding them will be straightforward.</p>&#13;
<h5 class="h5" id="ch00lev3sec46"><strong>Example 1: Scaling</strong></h5>&#13;
<p class="noindent">Given a point (2, 3), what point results after applying a horizontal scale of 2 and a vertical scale of 5?</p>&#13;
<p class="indent">In this case, the terms in the affine transformation matrix are all zero except for <em>s</em><sub><em>x</em></sub> = 2 and <em>s</em><sub><em>y</em></sub> = 5. Plugging these values into <a href="ch07.xhtml#ch07eqa02">Equation 7.2</a>, we get the following:</p>&#13;
<div class="equationc"><img src="../images/f0174-02.jpg" alt="Image"/></div>&#13;
<p class="indent">The resulting point is therefore (4, 15). <a href="ch07.xhtml#ch7fig3">Figure 7-3</a> depicts this transformation’s effect on the point.</p>&#13;
<div class="image"><img src="../images/07fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig3"><em>Figure 7-3: Example of a scale transformation</em></p>&#13;
<h5 class="h5" id="ch00lev3sec47"><span epub:type="pagebreak" id="page_175"/><strong>Example 2: Scaling and Translating</strong></h5>&#13;
<p class="noindent">Given a point (2, 3), what point results after applying a horizontal scale of 2, vertical scale of 5, and translation of ⟨10, 15⟩?</p>&#13;
<p class="indent">This case has the same values for the scale as the previous one, plus a displacement vector. Let’s plug those values into our affine transformation equation:</p>&#13;
<div class="equationc"><img src="../images/f0175-01.jpg" alt="Image"/></div>&#13;
<p class="indent">This time, the resulting point is (14, 30). We’ll take a look at this later, but it’s interesting to note how we could achieve the same effect with two sequential affine transformations, the first one scaling the point and the second one translating it:</p>&#13;
<div class="equationc"><img src="../images/f0175-02.jpg" alt="Image"/></div>&#13;
<p class="indent">Note that transformations are applied from right to left. In the previous case, the scaling goes first and then the translation. If you were to switch the order of transformations, the result would be different, which we can check by multiplying both transformation matrices in both directions and comparing the results. This yields our original matrix:</p>&#13;
<div class="equationc"><img src="../images/f0175-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">But switching the order yields:</p>&#13;
<div class="equationc"><img src="../images/f0175-04.jpg" alt="Image"/></div>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig4">Figure 7-4</a> depicts the effect of applying the scale first and then the translation.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_176"/><img src="../images/07fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig4"><em>Figure 7-4: A scale plus a translation</em></p>&#13;
<h5 class="h5" id="ch00lev3sec48"><strong>Example 3: Vertical Reflection</strong></h5>&#13;
<p class="noindent">Reflections can be achieved by using affine transformations with negative scale values. To reflect a point (2, 3) in the vertical direction, use <em>s</em><sub><em>y</em></sub> = –1:</p>&#13;
<div class="equationc"><img src="../images/f0176-01.jpg" alt="Image"/></div>&#13;
<p class="indent">This yields the vertical reflection of the original point: (2,–3). <a href="ch07.xhtml#ch7fig5">Figure 7-5</a> represents this vertical reflection.</p>&#13;
<div class="image"><img src="../images/07fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig5"><em>Figure 7-5: An example of a vertical reflection</em></p>&#13;
<h5 class="h5" id="ch00lev3sec49"><strong>Example 4: Horizontal Shear</strong></h5>&#13;
<p class="noindent">What is the result of applying a horizontal shear of <em>sh</em><sub><em>x</em></sub> = 2 to a rectangle with its lower-left point located at the origin, a width of 10 units, and a height of 5 units?</p>&#13;
<p class="indent">This time we’ll have to apply the same transformation to all four vertices of the rectangle: (0, 0), (10, 0), (10, 5), and (0, 5). The affine transformation matrix is then as follows:</p>&#13;
<div class="equationc"><img src="../images/f0176-02.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_177"/>Using <a href="ch07.xhtml#ch07eqa02">Equation 7.2</a> with this matrix to transform the vertices yields the following: (0, 0), (10, 0), (20, 5), and (10, 5). Draw the resulting rectangle. It should look something like <a href="ch07.xhtml#ch7fig6">Figure 7-6</a>.</p>&#13;
<div class="image"><img src="../images/07fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig6"><em>Figure 7-6: An example of a shear</em></p>&#13;
<h3 class="h3" id="ch00lev1sec44"><strong>The Affine Transformation Class</strong></h3>&#13;
<p class="noindent">Without further ado, let’s create a new class to represent affine transformations. We want to use a class so that the transformation scale, translation, and shear values are part of its inner state and don’t need to be passed to every transformation method we use. If we used functions to transform geometric primitives instead, we’d need to pass all these values to every function, but that would be a lot of parameters.</p>&#13;
<p class="indent">In the <em>geom2d</em> package, create a new file named <em>affine_transf.py</em> and enter the code in <a href="ch07.xhtml#ch7lis1">Listing 7-1</a>.</p>&#13;
<pre>class AffineTransform:&#13;
    def __init__(self, sx=1, sy=1, tx=0, ty=0, shx=0, shy=0):&#13;
        self.sx = sx&#13;
        self.sy = sy&#13;
        self.tx = tx&#13;
        self.ty = ty&#13;
        self.shx = shx&#13;
        self.shy = shy</pre>&#13;
<p class="caption"><a id="ch7lis1"/><em>Listing 7-1: The <span class="codeitalic1">AffineTransform</span> class</em></p>&#13;
<p class="indent">The affine transformation stores values for the scales <em>s</em><sub><em>x</em></sub> and <em>s</em><sub><em>y</em></sub>, the translations <em>t</em><sub><em>x</em></sub> and <em>t</em><sub><em>y</em></sub>, and the shears <em>sh</em><sub><em>x</em></sub> and <em>sh</em><sub><em>y</em></sub>. All values are given a default value of zero, except for the scales, which are initialized to one, in case they are omitted in the initializer. This is for convenience, as we’ll create many transformations where the shear or translation values are zero.</p>&#13;
<p class="indent">With these values at hand we can already implement a method to apply the transformation to a point with the help of <a href="ch07.xhtml#ch07eqa03">Equation 7.3</a>. Enter the code in <a href="ch07.xhtml#ch7lis2">Listing 7-2</a>.</p>&#13;
<pre><span class="codestrong1">from geom2d.point import Point</span>&#13;
&#13;
&#13;
class AffineTransform:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   <span epub:type="pagebreak" id="page_178"/>def apply_to_point(self, point: Point):&#13;
       return Point(&#13;
           (self.sx * point.x) + (self.shx * point.y) + self.tx,&#13;
           (self.shy * point.x) + (self.sy * point.y) + self.ty&#13;
       )</pre>&#13;
<p class="caption"><a id="ch7lis2"/><em>Listing 7-2: Applying an affine transformation to a point</em></p>&#13;
<p class="indent">To apply the affine transformation to a point, we create a new <span class="literal">Point</span> where the projections are calculated using <a href="ch07.xhtml#ch07eqa03">Equation 7.3</a>. Let’s test this method using several different transformations.</p>&#13;
<h4 class="h4" id="ch00lev2sec81"><strong><em>Testing the Transformation of Points</em></strong></h4>&#13;
<p class="noindent">Create a new file in the <em>geom2d</em> package named <em>affine_transf_test.py</em> and enter the code in <a href="ch07.xhtml#ch7lis3">Listing 7-3</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.point import Point&#13;
from geom2d.affine_transf import AffineTransform&#13;
&#13;
&#13;
class TestAffineTransform(unittest.TestCase):&#13;
    point = Point(2, 3)&#13;
    scale = AffineTransform(2, 5)&#13;
    trans = AffineTransform(1, 1, 10, 15)&#13;
    shear = AffineTransform(1, 1, 0, 0, 3, 4)&#13;
&#13;
 <span class="ent">➊</span> def test_scale_point(self):&#13;
        expected = Point(4, 15)&#13;
        actual = self.scale.apply_to_point(self.point)&#13;
        self.assertEqual(expected, actual)&#13;
 <span class="ent">➋</span> def test_translate_point(self):&#13;
        expected = Point(12, 18)&#13;
        actual = self.trans.apply_to_point(self.point)&#13;
        self.assertEqual(expected, actual)&#13;
 <span class="ent">➌</span> def test_shear_point(self):&#13;
        expected = Point(11, 11)&#13;
        actual = self.shear.apply_to_point(self.point)&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch7lis3"/><em>Listing 7-3: Testing the affine transformation application</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_179"/>The test file contains the <span class="literal">TestAffineTransform</span> class, inheriting from <span class="literal">unittest.TestCase</span> as usual. Inside the class we define a point that is used in all tests as well as all three affine transformations, namely:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">scale</span>    A scaling transformation</p>&#13;
<p class="noindentin"><span class="codestrong">trans</span>    A translation transformation</p>&#13;
<p class="noindentin"><span class="codestrong">shear</span>    A shear transformation</p>&#13;
</div>&#13;
<p class="indent">Then we have our first test ensure the scale is correctly applied to the point <span class="ent">➊</span>. The second test applies the translation to the point and asserts that the result is as expected <span class="ent">➋</span>. The third does the same with the shear transformation <span class="ent">➌</span>. Run the tests. You can do so from the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/affine_transf_test.py</span></pre>&#13;
<p class="noindent">This should produce the following:</p>&#13;
<pre>Ran 3 tests in 0.001s&#13;
&#13;
OK</pre>&#13;
<p class="indent">Great! Now that we’re confident we’re correctly applying affine transformations to points, let’s extend the logic to other more complex primitives.</p>&#13;
<h4 class="h4" id="ch00lev2sec82"><strong><em>Transform Segments and Polygons</em></strong></h4>&#13;
<p class="noindent">We can harness the implementation for transforming <span class="literal">Point</span>s to transform any shape as long as it’s defined using points or vectors. The next logical step is implementing the transformation of segments, so after the <span class="literal">apply_to</span> <span class="literal">_point</span> method, enter the method in <a href="ch07.xhtml#ch7lis4">Listing 7-4</a>.</p>&#13;
<pre><span class="codestrong1">from geom2d.segment import Segment</span>&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
class AffineTransform:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def apply_to_segment(self, segment: Segment):&#13;
       return Segment(&#13;
           self.apply_to_point(segment.start),&#13;
           self.apply_to_point(segment.end)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch7lis4"/><em>Listing 7-4: Applying affine transformations to segments</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_180"/>That was easy, wasn’t it? To transform a segment, we simply create a new segment with both end points transformed using the previous method. We can apply a similar logic to polygons (in <a href="ch07.xhtml#ch7lis5">Listing 7-5</a>).</p>&#13;
<pre><span class="codestrong1">from geom2d.polygon import Polygon</span>&#13;
from geom2d.segment import Segment&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
class AffineTransform:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
   def apply_to_polygon(self, polygon: Polygon):&#13;
       return Polygon(&#13;
           [self.apply_to_point(v) for v in polygon.vertices]&#13;
       )</pre>&#13;
<p class="caption"><a id="ch7lis5"/><em>Listing 7-5: Applying affine transformations to polygons</em></p>&#13;
<p class="indent">In this case, we return a new polygon where all vertices have been transformed. What about rectangles and circles? The idea is similar, with a caveat: after scaling, shearing, and rotating these primitives, the results may no longer be rectangles or circles. This is why, in the previous chapter, we provided <span class="literal">Rect</span> and <span class="literal">Circle</span> with a method <span class="literal">to_polygon</span> that creates a generic polygon representation for the primitive. The code is therefore quite simple. Enter the code from <a href="ch07.xhtml#ch7lis6">Listing 7-6</a>:</p>&#13;
<pre><span class="codestrong1">from geom2d.rect import Rect</span>&#13;
<span class="codestrong1">from geom2d.circle import Circle</span>&#13;
from geom2d.polygon import Polygon&#13;
from geom2d.segment import Segment&#13;
from geom2d.point import Point&#13;
&#13;
class AffineTransform:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
   def apply_to_rect(self, rect: Rect):&#13;
       return self.apply_to_polygon(&#13;
           rect.to_polygon()&#13;
       )&#13;
&#13;
   def apply_to_circle(self, circle: Circle, divisions=30):&#13;
       return self.apply_to_polygon(&#13;
           circle.to_polygon(divisions)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch7lis6"/><em>Listing 7-6: Applying affine transformations to rectangles and circles</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_181"/>The procedure consists of obtaining the polygon representation of the rectangle or circle and delegating the rest of the process to <span class="literal">apply_to_polygon</span>. In the case of circles, the number of divisions must be chosen, which is given a value of 30 by default. Both methods return a <span class="literal">Polygon</span> instance, even if the affine transformation being applied is the identity, which wouldn’t transform the geometries at all. Once a rectangle or a circle goes through an affine transformation, it turns into a generic polygon, no matter what transformation.</p>&#13;
<p class="indent">We won’t do so here for space reasons, but feel free to add unit tests for these three new methods.</p>&#13;
<h4 class="h4" id="ch00lev2sec83"><strong><em>Concatenating Transformations</em></strong></h4>&#13;
<p class="noindent">One interesting property of affine transformations is that any complex transformation can be expressed as a sequence of simpler transformations. In fact, when you work with a 2D graphics application such as Sketch or Photoshop, every zoom or pan on the canvas is a combination, or concatenation, of a new affine transformation with the current one, which defines the projection of what you see on your screen at that particular moment.</p>&#13;
<p class="indent">Given two affine transformations [<em>T</em><sub>1</sub>] and [<em>T</em><sub>2</sub>] and input point <em>P</em>, the result of applying [<em>T</em><sub>1</sub>] to the point is as follows:</p>&#13;
<p class="noindentc"><em>P′</em> = [<em>T</em><sub>1</sub>]<em>P</em></p>&#13;
<p class="noindent">Then, applying the second transformation [<em>T</em><sub>2</sub>] to the previous result, we get this:</p>&#13;
<p class="noindentc"><em>P</em><sup>″</sup> = [<em>T</em><sub>2</sub>]<em>P</em><sup>′</sup></p>&#13;
<p class="noindent">If we substitute <em>P</em><sup>′</sup> from the first expression into the second, we obtain the result of applying both transformations to input point <em>P</em> (<a href="ch07.xhtml#ch07eqa04">Equation 7.4</a>),</p>&#13;
<div class="equationc" id="ch07eqa04"><img src="../images/07eqa04.jpg" alt="Image"/></div>&#13;
<p class="noindent">where [<em>T</em><sub><em>r</em></sub>] is the affine transformation equivalent to applying [<em>T</em><sub>1</sub>] first and [<em>T</em><sub>2</sub>] second. Notice how the order of the original transformations appears in reverse if you read from left to right?</p>&#13;
<p class="noindentc">[<em>T</em><sub>r</sub>] = [<em>T</em><sub>2</sub>][<em>T</em><sub>1</sub>]</p>&#13;
<p class="indent">In the previous equation, reading from left to right [<em>T</em><sub>2</sub>] appears first, but the effect of applying [<em>T</em><sub><em>r</em></sub>] is equivalent to applying [<em>T</em><sub>1</sub>] first and [<em>T</em><sub>2</sub>] second. We need to be careful with the order, as matrix multiplication is noncommutative. If we swap the order of the operands, we obtain a different transformation, which was already proved in a previous exercise. The resulting transformation is then expressed mathematically as the product of matrices (see <a href="ch07.xhtml#ch07eqa05">Equation 7.5</a>).</p>&#13;
<div class="equationc" id="ch07eqa05"><span epub:type="pagebreak" id="page_182"/><img src="../images/07eqa05.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s provide the <span class="literal">AffineTransform</span> class with a method to concatenate affine transformations using <a href="ch07.xhtml#ch07eqa05">Equation 7.5</a>. We’ll call the method <span class="literal">then()</span>, receiving parameters <span class="literal">self</span> and <span class="literal">other</span>. The first argument, <span class="literal">self</span>, is transformation [<em>T</em><sub>1</sub>], and <span class="literal">other</span> is [<em>T</em><sub>2</sub>]. Inside <em>affine_transf.py</em>, toward the end of the class, enter the code in <a href="ch07.xhtml#ch7lis7">Listing 7-7</a>.</p>&#13;
<pre>class AffineTransform:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
   def then(self, other):&#13;
       return AffineTransform(&#13;
           sx=other.sx * self.sx + other.shx * self.shy,&#13;
           sy=other.shy * self.shx + other.sy * self.sy,&#13;
           tx=other.sx * self.tx + other.shx * self.ty + other.tx,&#13;
           ty=other.shy * self.tx + other.sy * self.ty + other.ty,&#13;
           shx=other.sx * self.shx + other.shx * self.sy,&#13;
           shy=other.shy * self.sx + other.sy * self.shy&#13;
       )</pre>&#13;
<p class="caption"><a id="ch7lis7"/><em>Listing 7-7: Method to concatenate transformations</em></p>&#13;
<p class="indent">The name <span class="literal">then</span> is chosen so that it’s absolutely clear that <span class="literal">self</span> is applied before <span class="literal">other</span> (the method’s argument).</p>&#13;
<p class="indent">Since this is such an important method, we’ll want it covered by unit tests; that means we need a way of knowing whether two given affine transformations are equal. Let’s implement the special <span class="literal">__eq__</span> method in <span class="literal">AffineTransform</span> (<a href="ch07.xhtml#ch7lis8">Listing 7-8</a>).</p>&#13;
<pre><span class="codestrong1">from geom2d.nums import are_close_enough</span>&#13;
from geom2d.rect import Rect&#13;
from geom2d.circle import Circle&#13;
from geom2d.polygon import Polygon&#13;
from geom2d.segment import Segment&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
class AffineTransform:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        <span epub:type="pagebreak" id="page_183"/>if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, AffineTransform):&#13;
            return False&#13;
&#13;
        return are_close_enough(self.sx, other.sx) \&#13;
               and are_close_enough(self.sy, other.sy) \&#13;
               and are_close_enough(self.tx, other.tx) \&#13;
               and are_close_enough(self.ty, other.ty) \&#13;
               and are_close_enough(self.shx, other.shx) \&#13;
               and are_close_enough(self.shy, other.shy)</pre>&#13;
<p class="caption"><a id="ch7lis8"/><em>Listing 7-8: Checking affine transformation equality</em></p>&#13;
<h5 class="h5" id="ch00lev3sec50"><strong>Testing the Concatenation of Transformations</strong></h5>&#13;
<p class="noindent">Let’s now enter two new tests in <em>affine_transf_test.py</em>; both are listed in <a href="ch07.xhtml#ch7lis9">Listing 7-9</a>.</p>&#13;
<pre>class TestAffineTransform(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_concatenate_scale_then_translate(self):&#13;
       expected = AffineTransform(2, 5, 10, 15)&#13;
       actual = self.scale.then(self.trans)&#13;
       self.assertEqual(expected, actual)&#13;
&#13;
   def test_concatenate_translate_then_scale(self):&#13;
       expected = AffineTransform(2, 5, 20, 75)&#13;
       actual = self.trans.then(self.scale)&#13;
       self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch7lis9"/><em>Listing 7-9: Testing affine transformation concatenation</em></p>&#13;
<p class="indent">As you’ve probably realized, these two tests are repeating the operations we did by hand in one of the exercises at the beginning of the chapter. Run them to make sure you have the implementation of <span class="literal">then</span> right.</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/affine_transf_test.py</span></pre>&#13;
<p class="indent">There is a lot of adding and multiplying between <span class="literal">self</span> and <span class="literal">other</span>, so it’s easy to get the code wrong. If the tests aren’t passing, well, that means they’re doing their work by pointing out that something in the code is not right. Go back to your implementation and make sure you have everything right line by line.</p>&#13;
<h4 class="h4" id="ch00lev2sec84"><span epub:type="pagebreak" id="page_184"/><strong><em>Inverting Affine Transformations</em></strong></h4>&#13;
<p class="noindent">To undo a transformation or apply the inverse of a known transformation [<em>T</em>], we want to be able to compute a transformation [<em>T</em><sub><em>I</em></sub>] such that</p>&#13;
<p class="noindentc">[<em>T</em>][<em>T</em><sub>I</sub>] = [<em>T</em><sub>I</sub>][<em>T</em>] = [<em>I</em>]</p>&#13;
<p class="indent">where [<em>I</em>] is the identity matrix of size 3:</p>&#13;
<div class="equationc"><img src="../images/f00184-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">An interesting property of these pairs of transformations [<em>T</em>] and [<em>T</em><sub><em>I</em></sub>] is that they cancel each other out. For example, here is the result of applying the transformations one after the other (in whichever order) to a point <em>P</em>:</p>&#13;
<p class="noindentc">[<em>T</em><sub>I</sub>]([<em>T</em>]<em>P</em>) = ([<em>T</em><sub>I</sub>][<em>T</em>])<em>P</em> = [<em>I</em>]<em>P</em> = <em>P</em></p>&#13;
<p class="indent">Another reason the inverse affine transformation is interesting is that it maps a point on the screen back to our “model space,” that is, the affine space where our model is defined. The direct transformation is used to compute how the geometry is projected onto the screen, that is, where each point of the model needs to be drawn—but what about the other way around? Knowing where a given point on the screen lies in the model requires the inverse transformation, the one that transforms the “screen space” into the model space. This is useful, for example, when trying to figure out whether the user’s mouse pointer on the screen maps to something in the model that could potentially be selected.</p>&#13;
<p class="indent">Take a look at <a href="ch07.xhtml#ch7fig7">Figure 7-7</a>. There’s our model space with just a triangle defined in it. To draw the model to the user’s screen, we have to apply an affine transformation that projects every point from model space to screen space. Now imagine the user has the mouse at point <em>P</em><sup>′</sup> on the screen, and we want to know whether that point lies inside our triangle. Since the triangle is a geometry defined in the model space, we want to apply that point in the screen the inverse transformation: that which transforms screen space into model space. Recall that, to project our model geometry into the screen, we applied the direct affine transformation, so to map that geometry back into its original model space, the inverse of that transformation needs to be applied. With the point mapped to our model space (<em>P</em>), we can do the calculations to determine whether <em>P</em> is inside the triangle.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_185"/><img src="../images/07fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig7"><em>Figure 7-7: Model and screen spaces</em></p>&#13;
<p class="indent">You can try to compute the inverse affine transformation matrix by yourself, which is a great exercise, but inverting matrices by hand is a tedious task, so <a href="ch07.xhtml#ch07eqa06">Equation 7.6</a> shows the result.</p>&#13;
<div class="equationc" id="ch07eqa06"><img src="../images/07eqa06.jpg" alt="Image"/></div>&#13;
<p class="indent">Using the transformation from <a href="ch07.xhtml#ch07eqa06">Equation 7.6</a>, computing the inverse requires only a few lines of code. In <span class="literal">AffineTransform</span> and after <span class="literal">then</span>, enter the code in <a href="ch07.xhtml#ch7lis10">Listing 7-10</a>.</p>&#13;
<pre>class AffineTransform:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
   def inverse(self):&#13;
       denom = self.sx * self.sy - self.shx * self.shy&#13;
       return AffineTransform(&#13;
           sx=self.sy / denom,&#13;
           sy=self.sx / denom,&#13;
           tx=(self.ty * self.shx - self.sy * self.tx) / denom,&#13;
           ty=(self.tx * self.shy - self.sx * self.ty) / denom,&#13;
           shx=-self.shx / denom,&#13;
           shy=-self.shy / denom&#13;
       )</pre>&#13;
<p class="caption"><a id="ch7lis10"/><em>Listing 7-10: Inverse affine transformation</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>Let’s also add a test to make sure the inverse is properly computed. In <em>affine_transf_test.py</em>, add a new method to class <span class="literal">TestAffineTransform</span> with the test in <a href="ch07.xhtml#ch7lis11">Listing 7-11</a>.</p>&#13;
<pre>class TestAffineTransform(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_inverse(self):&#13;
       transf = AffineTransform(1, 2, 3, 4, 5, 6)&#13;
       expected = AffineTransform()&#13;
       actual = transf.then(transf.inverse())&#13;
       self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch7lis11"/><em>Listing 7-11: Testing the inverse affine transformation</em></p>&#13;
<p class="indent">In this test, we create a new affine transformation, <span class="literal">transf</span>, with all values set to nonzero values. Then we store the transformation result of concatenating <span class="literal">transf</span> and its inverse in <span class="literal">actual</span>, which, if you recall, should be the identity matrix if the inverse is properly constructed. Lastly, we compare the obtained result with the actual identity matrix. Run all tests in the file to make sure they succeed.</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/affine_transf_test.py</span></pre>&#13;
<p class="indent">Let’s try an example. We’ll apply a translation to a point and then apply the inverse translation to the resulting point, which should yield the original point. In the Python shell, write the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.affine_transf import AffineTransform</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">trans = AffineTransform(tx=10, ty=20)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">original = Point(5, 7)</span></pre>&#13;
<p class="indent">We know if we apply the ⟨10, 20⟩ translation to point (5, 7), the resulting point should be (15, 27). Let’s test it.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">translated = trans.apply_to_point(original)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">str(translated)</span>&#13;
'(15, 27)'</pre>&#13;
<p class="indent">Using the <span class="literal">str</span> function, we get the string representation of <span class="literal">translated</span>, the point after applying the translation. Let’s now apply the inverse translation transformation to that point.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">inverse = trans.inverse().apply_to_point(translated)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">str(inverse)</span>&#13;
'(5.0, 7.0)'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_187"/>Applying the inverse transformation to the translated point yields the original point, as expected.</p>&#13;
<h4 class="h4" id="ch00lev2sec85"><strong><em>Scaling</em></strong></h4>&#13;
<p class="noindent">Whenever you zoom in or out using a graphics application such as AutoCAD or Illustrator, a scaling affine transformation is applied to the geometric model so that it’s drawn on your screen with a different size than the real one. Architects draw blueprints for buildings hundreds of meters tall that need to fit inside a laptop screen a few inches wide. Inside the computer’s memory lives the geometric model with the real dimensions, but to draw it to the screen, a scale is applied: a scaling affine transformation.</p>&#13;
<p class="indent">To get a visual intuition of what happens in this kind of affine transformation, let’s look at <a href="ch07.xhtml#ch7fig8">Figure 7-8</a>. Given a point <em>P</em>, let’s imagine a vector <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> starting at the origin and with its tip on <em>P</em>. Applying scales <em>S</em><sub><em>x</em></sub> and <em>S</em><sub><em>y</em></sub> to point <em>P</em> transforms it into a point <em>P</em><sup>′</sup> whose vector <img class="inline" src="../images/vivictorit.jpg" alt="Image"/> horizontal projection is <em>S</em><sub><em>x</em></sub> ⋅ <em>v</em><sub><em>x</em></sub> and vertical projection is <em>S</em><sub><em>y</em></sub> ⋅ <em>v</em><sub><em>y</em></sub>. As you see, a scale is a measure of how far or close points get to the origin with respect to their original distance to it. The origin, in fact, doesn’t move with pure scaling transformations. Scales with absolute value smaller than the unit pull points closer to the origin, whereas scales greater than one push points away from it.</p>&#13;
<div class="image"><img src="../images/07fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig8"><em>Figure 7-8: A scale affine transformation</em></p>&#13;
<p class="indent">This is useful, but often we want to apply a scale with respect to a point other than the origin. Imagine, for example, working with AutoCAD and wanting to zoom in to the drawing. If instead of zooming in around the center of your screen or mouse position it zoomed with respect to the origin (assuming it’s located in the lower-left corner of the app’s window), you’d feel like the drawing moved away, as depicted in the left diagram of <a href="ch07.xhtml#ch7fig9">Figure 7-9</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_188"/><img src="../images/07fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig9"><em>Figure 7-9: Zooming in around the origin (left) and around the center of the screen (right)</em></p>&#13;
<p class="indent">You’re probably much more used to a zoom in function that scales the drawing around a point somewhere in the middle of your screen, or even the position of your mouse as it actually happens most of the time. Many graphic design programs work like this, and it makes things more convenient for the user, but the way we defined a pure scaling transformation, it can only happen with respect to the origin. So, how is this scaling around an arbitrary point achieved? Well, now that we know about constructing compound transformations, obtaining this transformation is actually a piece of cake.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It took me quite some time to fully understand how to use affine transformations effectively and how to create compound transformations out of simpler ones. I had a really hard time trying to implement a proper “zoom in” option in my software InkStructure, and that’s why the original versions felt a bit buggy when trying to zoom in to the drawing and not have it randomly move around the screen. So when I say “a piece of cake,” I should probably qualify: it becomes easy only once you understand affine transformations.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s quickly state the problem we want to solve: we want to find an affine transformation that applies scales <em>S</em><sub><em>x</em></sub> and <em>S</em><sub><em>y</em></sub> with respect to a center point <em>C</em>. Defining <em>O</em> as the origin of the coordinate system, we can build such a transformation by combining the following simpler transformations:</p>&#13;
<ol>&#13;
<li class="noindent">[<em>T</em><sub>1</sub>]: Translate so that <em>C</em>  coincides with the origin <em>O</em>  (<img class="inline" src="../images/tvictorit.jpg" alt="Image"/> = <img class="inline" src="../images/coline.jpg" alt="Image"/> = ⟨–<em>C</em><sub>x</sub>, –<em>C</em><sub>y</sub>⟩).</li>&#13;
<li class="noindent">[<em>T</em><sub>2</sub>]:  Scale with factors <em>S</em><sub><em>x</em></sub>  and <em>S</em><sub><em>y</em></sub>.</li>&#13;
<li class="noindent">[<em>T</em><sub>3</sub>]:  Translate <em>C</em> back to where it was (<img class="inline" src="../images/tivictor.jpg" alt="Image"/> = <img class="inline" src="../images/ocline.jpg" alt="Image"/> = ⟨<em>C</em><sub>x</sub>, <em>C</em><sub>y</sub>⟩).</li>&#13;
</ol>&#13;
<p class="indent">Since scales can be applied only with respect to the origin, we move the whole space so that our point <em>C</em> lies exactly on the origin, and then we apply the scale and translate things back to where they were initially. Beautiful, isn’t it? Thus, [<em>T</em><sub><em>r</em></sub>] can be computed as shown in <a href="ch07.xhtml#ch07eqa07">Equation 7.7</a>.</p>&#13;
<div class="equationc" id="ch07eqa07"><span epub:type="pagebreak" id="page_189"/><img src="../images/07eqa07.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s create a factory function to generate these kinds of transformations. Start by creating a new file named <em>affine_transforms.py</em>; in it, enter the function in <a href="ch07.xhtml#ch7lis12">Listing 7-12</a>.</p>&#13;
<pre>from geom2d.affine_transf import AffineTransform&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
def make_scale(sx: float, sy: float , center=Point(0, 0)):&#13;
    return AffineTransform(&#13;
        sx=sx,&#13;
        sy=sy,&#13;
        tx=center.x * (1.0 - sx),&#13;
        ty=center.y * (1.0 - sy)&#13;
    )</pre>&#13;
<p class="caption"><a id="ch7lis12"/><em>Listing 7-12: Creating a scale transformation</em></p>&#13;
<p class="indent">It is a good idea to add a few test cases checking the behavior of this function. For brevity, I’ll leave that as an exercise for you.</p>&#13;
<h4 class="h4" id="ch00lev2sec86"><strong><em>Rotating</em></strong></h4>&#13;
<p class="noindent">Similar to scales, rotations always take place around the origin. Just like before, by using a clever sequence of transformations, we can produce a rotation around any point we want. You may have rotated a drawing in Sketch, Illustrator, or a similar application, in which case you’re used to choosing the <em>rotation pivot</em>, a point around which you then rotate using the square handles, something similar to <a href="ch07.xhtml#ch7fig10">Figure 7-10</a>.</p>&#13;
<div class="image"><img src="../images/07fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig10"><em>Figure 7-10: Rotation around the center</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>The pivot point can be moved so the rotation happens around a different point. For example, moving it near the bottom-left corner of the bounding box, the rotation may look like <a href="ch07.xhtml#ch7fig11">Figure 7-11</a>.</p>&#13;
<div class="image"><img src="../images/07fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig11"><em>Figure 7-11: Rotation around a corner</em></p>&#13;
<p class="indent">Let’s start by learning how to construct a rotation affine transformation around the origin; this will serve as the basis for constructing a more complex rotation around any point. <a href="ch07.xhtml#ch07eqa08">Equation 7.8</a> shows how to rotate points <em>θ</em> radians around the origin.</p>&#13;
<div class="equationc" id="ch07eqa08"><img src="../images/07eqa08.jpg" alt="Image"/></div>&#13;
<p class="indent">With this in mind, let’s find an affine transformation that rotates points <em>θ</em> radians around a center point <em>C</em>. With <em>O</em> as the origin of the coordinate system, the transformation is the combination of the following:</p>&#13;
<ol>&#13;
<li class="noindent">[<em>T</em><sub>1</sub>]:  Translate <em>C</em>  to the origin <em>O</em>  so the rotation center is <em>C</em>  (<img class="inline" src="../images/tvictorit.jpg" alt="Image"/> = <img class="inline" src="../images/coline.jpg" alt="Image"/> = ⟨–<em>C</em><sub>x</sub>, –<em>C</em><sub>y</sub>⟩).</li>&#13;
<li class="noindent">[<em>T</em><sub>2</sub>]:  Rotate <em>θ</em>  radians.</li>&#13;
<li class="noindent">[<em>T</em><sub>3</sub>]:  Translate <em>C</em> back to where it was (<img class="inline" src="../images/tivictor.jpg" alt="Image"/> = <img class="inline" src="../images/ocline.jpg" alt="Image"/> = ⟨<em>C</em><sub>x</sub>, <em>C</em><sub>y</sub>⟩).</li>&#13;
</ol>&#13;
<p class="indent">It’s the same algorithm as before, but this time we’ll use a rotation instead of a scale. [<em>T</em><sub><em>r</em></sub>] is now computed as follows:</p>&#13;
<div class="equationc"><img src="../images/f0190-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">This yields the affine transformation in <a href="ch07.xhtml#ch07eqa09">Equation 7.9</a>.</p>&#13;
<div class="equationc" id="ch07eqa09"><img src="../images/07eqa09.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/>Let’s create a new factory function to generate rotations around a center point. In <em>affine_transforms.py</em>, with the help of <a href="ch07.xhtml#ch07eqa09">Equation 7.9</a>, implement the new function in <a href="ch07.xhtml#ch7lis13">Listing 7-13</a>.</p>&#13;
<pre><span class="codestrong1">import math</span>&#13;
&#13;
from geom2d.affine_transf import AffineTransform&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def make_rotation(radians: float, center=Point(0, 0)):&#13;
    cos = math.cos(radians)&#13;
    sin = math.sin(radians)&#13;
    one_minus_cos = 1.0 - cos&#13;
&#13;
    return AffineTransform(&#13;
        sx=cos,&#13;
        sy=cos,&#13;
        tx=center.x * one_minus_cos + center.y * sin,&#13;
        ty=center.y * one_minus_cos - center.x * sin,&#13;
        shx=-sin,&#13;
        shy=sin&#13;
    )</pre>&#13;
<p class="caption"><a id="ch7lis13"/><em>Listing 7-13: Creating a rotation transformation</em></p>&#13;
<p class="indent">Once again, you want to come up with at least one unit test to make sure our implementation is bug free.</p>&#13;
<p class="indent">Let’s give it a try in the shell: let’s create two rotations of <em>π</em>/4 radians, one around the origin and another one around the point (10, 10). Then, we’ll apply both rotations to the point (15, 15) to see where it lands in both cases. Reload the Python shell and write the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.affine_transforms import make_rotation</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">import math</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">point = Point(15, 15)</span></pre>&#13;
<p class="indent">Let’s now try with the rotation around the origin:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">rot_origin = make_rotation(math.pi / 4)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">str(rot_origin.apply_to_point(point))</span>&#13;
'(1.7763568394002505e-15, 21.213203435596427)'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>The resulting point has an x-coordinate that is effectively zero (note the exponent <span class="literal">e-15</span>) and a y-coordinate of 21.2132..., which is the length of the vector going from the origin to the original point <img class="inline" src="../images/f00192.jpg" alt="Image"/>.</p>&#13;
<p class="indent">Let’s try the second rotation:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">rot_other = make_rotation(math.pi / 4, Point(10, 10))</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">str(rot_other.apply_to_point(point))</span>&#13;
'(10.000000000000002, 17.071067811865476)'</pre>&#13;
<p class="indent">The resulting point is (10, 17.071...) this time. To help us make sense of the exercise we’ve just done, <a href="ch07.xhtml#ch7fig12">Figure 7-12</a> illustrates the two rotation transformations.</p>&#13;
<div class="image"><img src="../images/07fig12.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig12"><em>Figure 7-12: Example of a rotation around the origin (left) and around the point (10, 10) (right)</em></p>&#13;
<h3 class="h3" id="ch00lev1sec45"><strong>Interpolating Transformations</strong></h3>&#13;
<p class="noindent">When you zoom in or out, most graphics programs don’t apply the scale all at once, but they typically produce a quick and smooth animation of the zooming process. This helps you, the user, better understand how the drawing is being transformed. To achieve this, graphics programs typically use a transformation interpolation. Later in the book we’ll animate affine transformations, that is, we’ll create a kind of movie where we can appreciate how a given geometry is transformed one step at a time. Each frame in the animation will depict the geometry after applying a fraction of the affine transformation, and this is where we’ll first use <em>interpolations</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec87"><strong><em>Motivating Interpolation</em></strong></h4>&#13;
<p class="noindent">Before we dive into the concept of interpolating transformations, take a look at <a href="ch07.xhtml#ch7fig13">Figure 7-13</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_193"/><img src="../images/07fig13.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig13"><em>Figure 7-13: Animating an affine transformation</em></p>&#13;
<p class="indent">In the figure, there’s a triangle originally in the bottom left of the window that ends up in the top middle after passing through some middle positions drawn in a lighter gray. Each of the triangles represents the result we’d see at a given point in time, a concrete frame in the animation.</p>&#13;
<p class="indent">If we want our animation to have <em>n</em> frames, where <em>n</em> &gt; 1, there needs to be <em>n</em> affine transformations [<em>T</em><sub>0</sub>], [<em>T</em><sub>1</sub>],..., [<em>T</em><sub>n–1</sub>] such that each frame is the result of applying the corresponding transformation to the input geometry. It’s clear that the last transformation, [<em>T</em><sub><em>n–</em>1</sub>], needs to be the target affine transformation, as the final frame should depict the geometry after applying such a transformation. What should [<em>T</em><sub>0</sub>] be then? Let’s give it some thought. What transformation applied to the input geometry results in the geometry itself? Well, there’s only one such transformation that we know doesn’t move things around, the identity transformation. So, our start and end transformations are as follows:</p>&#13;
<div class="equationc"><img src="../images/f0193-01.jpg" alt="Image"/></div>&#13;
<p class="indent">How do we go about computing [<em>T</em><sub>1</sub>],...,[<em>T</em><sub>n–2</sub>]? It’s easy: we can interpolate each of the start and end values to obtain as many intermediate values as we need. For example, a linear interpolation from 0 to 5 using five steps would yield [0, 1, 2, 3, 4, 5]. Note that five steps produce six values, so to obtain <em>n</em> frames, we’ll use <em>n –</em> 1 steps.</p>&#13;
<p class="indent">To interpolate from a start value <em>v</em><sub><em>s</em></sub> to an end value <em>v</em><sub><em>e</em></sub>, we can use any function that passes through them. A straight line (linear function) is the simplest one, and the resulting values are uniformly spaced. This is a linear interpolation. If we used such interpolation to produce the frames of an animation, the result would move at constant speed from the beginning to the end (the slope of the interpolating function is constant), which looks unnatural to the eye. Why is that? Well, it’s because we’re not used to seeing things in real life abruptly accelerating, moving at the same speed, and stopping all of a sudden. This may look fine for projectiles or bullets, but it’s <span epub:type="pagebreak" id="page_194"/>strange for most real-life objects in motion. We can try a more natural-looking interpolating function such as an <em>ease-in-out</em>, plotted in the right-side graph of <a href="ch07.xhtml#ch7fig14">Figure 7-14</a>.</p>&#13;
<div class="image"><img src="../images/07fig14.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig14"><em>Figure 7-14: Two interpolation functions</em></p>&#13;
<p class="indent">In an ease-in-out function, values at the beginning and end vary slowly, which gives the sensation of things accelerating as they start to move and softly decelerating when reaching the end of their motion. This function defines motion in a much more natural way, and animations following this variation of the position with respect to time look nice to the human eye.</p>&#13;
<p class="indent">To obtain a value between <em>v</em><sub><em>s</em></sub> and <em>v</em><sub><em>e</em></sub>, we use a parameter <em>t</em> such that 0 ≤ <em>t</em> ≤ 1 (see <a href="ch07.xhtml#ch07eqa10">Equation 7.10</a>).</p>&#13;
<div class="equationc" id="ch07eqa10"><img src="../images/07eqa10.jpg" alt="Image"/></div>&#13;
<p class="indent">You can easily observe that <a href="ch07.xhtml#ch07eqa10">Equation 7.10</a> yields a result of <em>v</em><sub><em>s</em></sub> for <em>t</em> = 0 and <em>v</em><sub><em>e</em></sub> for <em>t</em> = 1. For any intermediate value of <em>t</em>, the value varies between those two values. If we want to obtain a sequence of values starting with <em>v</em><sub><em>s</em></sub> all the way to <em>v</em><sub><em>e</em></sub> that follow a linear distribution, we just need to use equally spaced values for <em>t</em>, like, for example, [0, 0.25, 0.5, 0.75, 1].</p>&#13;
<p class="indent">To produce an ease-in-out distribution of interpolated values, we need a sequence of <em>t</em> values from 0 to 1 with uneven spacing, with small steps near the extreme values and greater steps around the middle. If we represent the values of <em>t</em> by circles in a horizontal line starting at <em>t</em> = 0 and ending at <em>t</em> = 1, we can get a sense of how uniform and ease-in-out values are distributed from <a href="ch07.xhtml#ch7fig15">Figure 7-15</a>.</p>&#13;
<div class="image"><img src="../images/07fig15.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch7fig15"><em>Figure 7-15: Interpolating <span class="normal">t</span> values</em></p>&#13;
<p class="indent">To build the sequence of <em>t</em> values distributed according to the right-side plot in <a href="ch07.xhtml#ch7fig14">Figure 7-14</a>, we can plug a sequence of evenly spaced <em>t</em> values into <a href="ch07.xhtml#ch07eqa11">Equation 7.11</a>.</p>&#13;
<div class="equationc" id="ch07eqa11"><img src="../images/07eqa11.jpg" alt="Image"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_195"/>This alters their spacing so that more of them lie near the extremes 0 and 1 and fewer are located in the middle.</p>&#13;
<p class="indent">We have all the ingredients that we need; let’s get our hands dirty!</p>&#13;
<h4 class="h4" id="ch00lev2sec88"><strong><em>Implementing Interpolation</em></strong></h4>&#13;
<p class="noindent">Create a new file named <em>interpolation.py</em> inside <em>geom2d</em> and enter the code in <a href="ch07.xhtml#ch7lis14">Listing 7-14</a>.</p>&#13;
<pre>def uniform_t_sequence(steps: int):&#13;
    return [t / steps for t in range(steps + 1)]&#13;
&#13;
&#13;
def ease_in_out_t_sequence(steps: int):&#13;
    return [ease_in_out_t(t) for t in uniform_t_sequence(steps)]&#13;
&#13;
&#13;
def ease_in_out_t(t: float):&#13;
    return t ** 2 / (t ** 2 + (1 - t) ** 2)</pre>&#13;
<p class="caption"><a id="ch7lis14"/><em>Listing 7-14: Interpolated <span class="normal">t</span> values</em></p>&#13;
<p class="indent">Starting from the bottom, we have the function <span class="literal">ease_in_out_t</span>, which is simply the implementation of <a href="ch07.xhtml#ch07eqa11">Equation 7.11</a>. The first function builds a sequence of uniformly distributed <em>t</em> values using the given number of steps, thus producing as many values as steps plus one. We can test that in the shell. Reload it and try the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.interpolation import uniform_t_sequence</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">uniform_t_sequence(10)</span>&#13;
[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]</pre>&#13;
<p class="indent">Function <span class="literal">ease_in_out_t_sequence</span>, on the other hand, creates sequences following an ease-in-out distribution. To do so, it applies <a href="ch07.xhtml#ch07eqa11">Equation 7.11</a> to values of a uniform sequence. Let’s try it as well in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">ease_in_out_t_sequence(10)</span>&#13;
[0.0, 0.012195121951219514, 0.058823529411764705,&#13;
0.15517241379310345, 0.30769230769230776, 0.5,&#13;
0.6923076923076923, 0.8448275862068965,&#13;
0.9411764705882353, 0.9878048780487805, 1.0]</pre>&#13;
<p class="indent">See how values near 0 and 1 are closer together while values in the middle (near 0.5) are farther apart? Great, so we’re just missing a function to interpolate between two values for a given <em>t</em>, just as <a href="ch07.xhtml#ch07eqa10">Equation 7.10</a> defines. Add <a href="ch07.xhtml#ch7lis15">Listing 7-15</a> in <em>interpolation.py</em>.<span epub:type="pagebreak" id="page_196"/></p>&#13;
<pre>import geom2d.tparam as tparam&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def interpolate(vs: float, ve: float, t: float):&#13;
    tparam.ensure_valid(t)&#13;
    return vs + t * (ve - vs)</pre>&#13;
<p class="caption"><a id="ch7lis15"/><em>Listing 7-15: Interpolating between two values given <span class="normal">t</span></em></p>&#13;
<p class="indent">If you recall from <a href="ch05.xhtml#ch05">Chapter 5</a>, when we operate using a passed-in <em>t</em> parameter value, we want to check that it’s inside its expected range, for which the <span class="literal">ensure_valid</span> function is used. We’re now ready for the last step, and I hope you followed along, because here’s the actual interpolation of affine transformations we’ve been pursuing. Open your file <em>affine_transforms.py</em>, where we defined factory functions to create several special types of affine transformations, and enter the code in <a href="ch07.xhtml#ch7lis16">Listing 7-16</a>.</p>&#13;
<pre>import math&#13;
&#13;
from geom2d.affine_transf import AffineTransform&#13;
<span class="codestrong1">from geom2d.interpolation import ease_in_out_t_sequence, interpolate</span>&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def ease_in_out_interpolation(start, end, steps):&#13;
 <span class="ent">➊</span> t_seq = ease_in_out_t_sequence(steps)&#13;
 <span class="ent">➋</span> return [__interpolated(start, end, t) for t in t_seq]&#13;
&#13;
&#13;
def __interpolated(s: AffineTransform, e: AffineTransform, t):&#13;
 <span class="ent">➌</span> return AffineTransform(&#13;
        sx=interpolate(s.sx, e.sx, t),&#13;
        sy=interpolate(s.sy, e.sy, t),&#13;
        tx=interpolate(s.tx, e.tx, t),&#13;
        ty=interpolate(s.ty, e.ty, t),&#13;
        shx=interpolate(s.shx, e.shx, t),&#13;
        shy=interpolate(s.shy, e.shy, t)&#13;
    )</pre>&#13;
<p class="caption"><a id="ch7lis16"/><em>Listing 7-16: Sequence of interpolated affine transformations</em></p>&#13;
<p class="indent">To help generate a sequence of interpolated affine transformations, we define a private function <span class="literal">__interpolated</span>, which, given two transformations and a value for <em>t</em>, returns the interpolation for that <em>t</em> <span class="ent">➌</span>. Each value for the new transformation is the result of interpolating the values of both start <span epub:type="pagebreak" id="page_197"/>and end transformations. Then we build a sequence of <em>t</em> values following the ease-in-out distribution <span class="ent">➊</span>, each of which is mapped to the interpolated transformation using a list comprehension <span class="ent">➋</span>.</p>&#13;
<p class="indent">We’ll leave this for now until <a href="ch12.xhtml#ch12">Chapter 12</a>, where we’ll be using the sequences of interpolated affine transformations to produce animations. Don’t worry if the concepts explored in this last part of the chapter seem a little abstract. We’ll build the foundations of animating motion in the next part of the book, and until then it may be hard to make sense out of this interpolation thing.</p>&#13;
<h3 class="h3" id="ch00lev1sec46"><strong>Geom2D Final Touches</strong></h3>&#13;
<p class="noindent">Our <em>geom2d</em> package is tested and ready to be used throughout the rest of the book. We made it robust, but we can add a few small improvements before concluding this part of the book.</p>&#13;
<h4 class="h4" id="ch00lev2sec89"><strong><em>Test Files</em></strong></h4>&#13;
<p class="noindent">The first thing we want to do is separate implementation and test files, which are all in the same folder at the moment. This is so that the <em>geom2d</em> package folder appears less cluttered and you can find implementation files easier. In the package, create a new folder named <em>tests</em>, and then select all test files, which we conveniently named ending in <em>_test.py</em>, and drag them to the folder. Your folder structure and files should look like the following:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- tests<br/>      |    |    |- affine_transf_test.py<br/>      |    |    |- affine_transforms_test.py<br/>      |    |    |- circle_test.py<br/>      |    |    |- ...<br/>      |    |    |- vector_test.py<br/>      |    |- __init__.py<br/>      |    |- affine_transf.py<br/>      |    |- affine_transforms.py<br/>      |    |- circle.py<br/>      |    |- ...<br/>      |    |- vectors.py</p>&#13;
<h4 class="h4" id="ch00lev2sec90"><strong><em>Running All Tests</em></strong></h4>&#13;
<p class="noindent">Now that all our test files live in the same folder, what about running all test cases at once? It may happen that you changed part of the code and want to make sure you didn’t break anything, for which you decide to run every test in the package. The way we’ve been doing it would take you some time, as you’d have to open the test files one by one and click the green play button beside each of the class names. There’s a better way!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_198"/>Open the Terminal view inside PyCharm. If you can’t see it, from the menu select <strong>View</strong> ▸ <strong>Tool Windows</strong> ▸ <strong>Terminal</strong>. By default, the shell opens right in the root directory of the project, which is exactly what we want. In the shell, run the following command:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest discover -s geom2d/tests/ -p '*_test.py'</span></pre>&#13;
<p class="indent">This command tells Python to discover and run all unit tests in <em>geom2d/tests/</em> inside files matching the pattern <em>*_test.py</em>, that is, all files ending in <em>_test.py</em>. Running the command should result in something similar to the following:</p>&#13;
<pre>Ran 58 tests in 0.004s&#13;
&#13;
OK</pre>&#13;
<p class="indent">You can save this command in a bash file at the project’s root level so you can execute it whenever you want without needing to memorize it.</p>&#13;
<h4 class="h4" id="ch00lev2sec91"><strong><em>Package Imports</em></strong></h4>&#13;
<p class="noindent">The last thing we want to do is include all modules in the package’s exports so that they can be loaded like so:</p>&#13;
<pre>from geom2d import Point, Polygon</pre>&#13;
<p class="indent">Compare this to the following:</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.polygon import Polygon</pre>&#13;
<p class="indent">The latter requires the user to type the path where each module lives in <em>geom2d</em>, but the former doesn’t: everything inside the package can be imported directly from the package itself. This style of exporting modules of a package is convenient for two reasons: (1) because it allows us to change the directory structure within the module without breaking the user’s imports and (2) because users don’t need to know where each module is located within the package and import everything from the package itself. As you can guess, this greatly reduces the cognitive load for using the package.</p>&#13;
<p class="indent">When PyCharm created the package <em>geom2d</em>, it included an empty file inside it named <em>__init__.py</em>. Can you spot it? Files with this name inside packages are loaded when the package itself is imported. We can use them to import what is defined inside the package.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If for whatever reason the file</em> __init__.py <em>doesn’t exist in your</em> geom2d <em>package, simply create it. Maybe you created the package as a normal directory inside PyCharm so the IDE didn’t add it for you.</em></p>&#13;
</div>&#13;
<p class="indent">So, open the file, which should be empty, and import all of the primitives we defined (see <a href="ch07.xhtml#ch7lis17">Listing 7-17</a>).<span epub:type="pagebreak" id="page_199"/></p>&#13;
<pre>from .point import Point&#13;
from .vector import Vector&#13;
from .vectors import *&#13;
from .circle import Circle&#13;
from .circles import *&#13;
from .interpolation import *&#13;
from .line import Line&#13;
from .nums import *&#13;
from .open_interval import OpenInterval&#13;
from .polygon import Polygon&#13;
from .rect import Rect&#13;
from .rects import *&#13;
from .segment import Segment&#13;
from .size import Size&#13;
from .tparam import *&#13;
from .affine_transf import *&#13;
from .affine_transforms import *</pre>&#13;
<p class="caption"><a id="ch7lis17"/><em>Listing 7-17: The <span class="normal">geom2d</span> package <span class="normal">init</span> file</em></p>&#13;
<p class="indent">That’s all! To understand what we achieve with this change, you can try the following in the shell (Python’s shell, not the shell we just used to run commands):</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Point, Size, Rect</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">origin = Point(2, 3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">size = Size(10, 15)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">rect = Rect(origin, size)</span></pre>&#13;
<p class="indent">This will prove convenient in future chapters, as we can import any module from <em>geom2d</em> directly from the package.</p>&#13;
<h3 class="h3" id="ch00lev1sec47"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we explored a core concept in computer graphics: affine transformations. They allow us to transform geometry by scaling, rotating, translating, and shearing it.</p>&#13;
<p class="indent">We started by taking a look at their mathematical definition and how they differ from linear transformations. The takeaway is that affine transformations can move the origin point, while linear transformations cannot. Affine transformations can be expressed as the combination of a linear transformation with a translation, but we saw a more convenient representation: the augmented matrix. Next, we implemented methods in the <span class="literal">AffineTransform</span> class to transform our geometric primitives: points, segments, and polygons.</p>&#13;
<p class="indent">We then learned how transformations can be concatenated to achieve complex transformations out of simpler ones. Thanks to that powerful idea, we were able to construct two essential affine transformations that happen <span epub:type="pagebreak" id="page_200"/>in almost every graphics application we know: scaling and rotating around a point other than the origin.</p>&#13;
<p class="indent">Lastly, we implemented a function to interpolate between two affine transformations, yielding a couple intermediate transformations that we’ll soon be using to produce animations.</p>&#13;
</body></html>