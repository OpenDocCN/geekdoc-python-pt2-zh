- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STRUCTURE RESOLUTION
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, we defined the classes for the structure model: StrNode,
    StrBar, and Structure. We also wrote the classes for the structure’s solution:
    StrNodeSolution, StrBarSolution, and StructureSolution. We use the first three
    to define a structure and the other three to model the solution, including the
    nodes’ displacements and bars’ stresses and strains. The question is, how do we
    go from the definition model to the solution model?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll answer that question by developing the resolution algorithm,
    the link between the original and solution structure models. We’ll revise the
    structure’s resolution process, where we assemble the structure’s stiffness matrix
    [*k*] based on the individual bar’s matrices and assemble the load vector {![Image](../images/fvictorit.jpg)}
    based on the individual node’s loads. Resolving the ![Image](../images/f00427-p1.jpg)
    system of equations yields the displacements of the nodes in the structure in
    global coordinates: ![Image](../images/f00427-p2.jpg). To solve the system of
    equations, we’ll use our Cholesky’s implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will also introduce an advanced unit testing technique: test doubles.
    Test doubles help us isolate a piece of the code by replacing the functions or
    classes it relies on with “fake” implementations so that when we run the test,
    we’re testing only one piece of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure Resolution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous chapter we studied the system of equations that relates the
    forces applied in each of the degrees of freedom of a bar with its displacements.
    A bar has two nodes, each with two degrees of freedom:'
  prefs: []
  type: TYPE_NORMAL
- en: '*u* The displacement in the x direction'
  prefs: []
  type: TYPE_NORMAL
- en: '*v* The displacement in the y direction'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a total of four degrees of freedom per bar: *u*[1] and *v*[1] for
    node 1 and *u*[2] and *v*[2] for node 2\. The forces applied to the nodes—let’s
    call them ![Image](../images/f1victorit.jpg) and ![Image](../images/f2victorit.jpg)—can
    each be decomposed into their two projections. Thus, ![Image](../images/f1victorit.jpg)
    can be decomposed into *F*[1*x*] and *F*[1*y*], and the same goes for ![Image](../images/f2victorit.jpg)
    (see [Figure 16-1](ch16.xhtml#ch16fig1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: A bar’s degrees of freedom*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system of equations relating these forces and the node displacements is
    repeated here from section “Stiffness Matrices in Global Coordinates” on [page
    397](ch15.xhtml#ch00lev1sec92):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0428-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s important to note that these forces and displacements, as well as the stiffness
    matrix [*k*], are all based on the global system of coordinates, which is the
    one represented on the bottom left of [Figure 16-1](ch16.xhtml#ch16fig1). Each
    bar has its own local coordinate system, as you may recall from [Figure 15-18](ch15.xhtml#ch15fig18),
    but to build the structure’s global system of equations, we want the forces and
    displacements referred to this global coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s briefly touch on what each term in the stiffness matrix
    means.
  prefs: []
  type: TYPE_NORMAL
- en: '***Interpreting the Stiffness Matrix Terms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The stiffness matrix terms relate the force in a given degree of freedom with
    the displacement produced in another degree of freedom. They are ordered in a
    well-defined way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0429-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, for example, ![Image](../images/f00429-p1.jpg) can be read as “the relation
    between the force in the first node’s x direction (![Image](../images/f00429-p2.jpg))
    and the displacement it produces in the second node’s y direction (![Image](../images/f00429-p3.jpg)).”
    With this is mind, we can discern a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row contains the stiffness terms relating the force in one degree of freedom
    with the displacements in every degree of freedom. For example, the first row
    includes the terms that relate the force in the x-axis of the start node ![Image](../images/f00429-p2.jpg)
    with all possible displacements: ![Image](../images/f00429-p5.jpg), ![Image](../images/f00429-p6.jpg),
    ![Image](../images/f00429-p7.jpg), and ![Image](../images/f00429-p3.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the columns contains the stiffness terms relating the forces in every
    degree of freedom with the displacement in a given degree of freedom. For example,
    the first column includes the terms that relate the forces in every degree of
    freedom—![Image](../images/f00429-p2.jpg), ![Image](../images/f1yvictorit.jpg),
    ![Image](../images/f2xvictorit.jpg), and ![Image](../images/f2yvictorit.jpg)—with
    the start node’s displacement in the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Remember this interpretation of the stiffness terms; we’ll use this knowledge
    later when we assemble the structure’s global stiffness matrix. Let’s continue
    revising the resolution process and write the code for it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Structure Initialization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the structure’s resolution process there will be some intermediate
    results we want to save in the Structure class as private attributes. Let’s initialize
    these attributes before we dive into the main algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Open your *model/structure.py* file and edit the class so that it includes the
    new attributes we’re adding in the __init__ method, as shown in [Listing 16-1](ch16.xhtml#ch16lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-1: Initializing the structure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add two new imports, Matrix and Vector, from the eqs package ➊.
    Because we’ll later need to import the other Vector class, the one defined in
    the geom2d package, we alias Vector from the eqs package to be named EqVector
    instead. Notice the aliasing syntax in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a constant called __DOF_PER_NODE ➋, which is set to 2. We’ll
    use this constant in our code instead of directly using the number. Its clear
    name should give a good hint as to what the number actually means. We’ll avoid
    using *magic numbers* in our code, that is, numbers that appear in the code where
    it isn’t clear what they represent. Well-named constants tell the readers of our
    code what the number actually stands for.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we define four new private attributes and initialize all of them to
    None ➌.
  prefs: []
  type: TYPE_NORMAL
- en: __dofs_dict A dictionary where the keys are IDs of the nodes, and the values
    are the lists of degrees of freedom numbers assigned to the node. We’ll see what
    this means in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: __system_matrix The stiffness matrix for the structure’s global system of equations.
  prefs: []
  type: TYPE_NORMAL
- en: __system_vector The load vector for the structure’s global system of equations.
  prefs: []
  type: TYPE_NORMAL
- en: __global_displacements The list of a node’s global displacements, where the
    indices of each displacement are the same as their degrees of freedom numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t fully understand what each of these new attributes
    mean; we’ll explain each in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Main Structure Resolution Algorithm***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The structure resolution algorithm can be broken down into three big steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign each degree of freedom a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assemble and resolve the structure’s system of equations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the system’s resulting vector to build the solution model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s try to quickly understand what each of these steps is about; we’ll fill
    in the remaining details later. The first step, numbering the degrees of freedom,
    is a process that assigns every DOF in the structure a unique number. Let’s take
    the structure in [Figure 16-2](ch16.xhtml#ch16fig2) as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: Our example structure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure in [Figure 16-2](ch16.xhtml#ch16fig2) has three nodes (N1, N2,
    and N3), and each node has two degrees of freedom. Assigning numbers to the degrees
    of freedom is as simple as it sounds: we take each DOF and associate a unique
    number with it. [Table 16-1](ch16.xhtml#ch16tab1) shows a possible DOF number
    assignment that uses the natural ordering of the nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-1:** Assigning Degrees of Freedom Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Node** | **DOF numbers** |'
  prefs: []
  type: TYPE_TB
- en: '| N1 | 0, 1 |'
  prefs: []
  type: TYPE_TB
- en: '| N2 | 2, 3 |'
  prefs: []
  type: TYPE_TB
- en: '| N3 | 4, 5 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, we assign DOF numbers starting from zero. We could have chosen
    any other set of numbers, including a numbering scheme starting at any number
    we like, but as we’ll use these numbers to refer to positions in the system’s
    matrix and vector, it’ll be more convenient to have numbers that directly refer
    to indices. Otherwise, we’d need a mapping between the DOF numbers and indices
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the DOF numbers assigned, the next step is to assemble the global system
    of equations. This system has the same structure as the bar’s system of equations:
    ![Image](../images/f00431-p1.jpg). When we solve this system of equations, we
    obtain the global displacements for all DOFs. Using these displacements, we can
    create the structure solution model using the classes we defined in [Chapter 15](ch15.xhtml#ch15).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement this three-step algorithm in a new method in the Structure class
    (from the *model* package). Enter the new method in [Listing 16-2](ch16.xhtml#ch16lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-2: Structure resolution*'
  prefs: []
  type: TYPE_NORMAL
- en: The solve_structure method will compute the solution and return an instance
    of StructureSolution. This method outlines the three steps we just described.
    None of the three private methods exist yet, but we’ll implement them in the following
    sections one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '***Numbering Degrees of Freedom***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step of the resolution process is to assign a number to each of the
    structure’s degrees of freedom. Remember that each node has two degrees of freedom,
    so the __assign_degrees_of_freedom method will assign two numbers to each of the
    structure’s nodes and save them in the __dofs_dict dictionary we initialized in
    [Listing 16-1](ch16.xhtml#ch16lis1). With the DOF numbers assigned, the structure
    we saw in [Figure 16-2](ch16.xhtml#ch16fig2) could now look like [Figure 16-3](ch16.xhtml#ch16fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: Our structure nodes’ degrees of freedom, with number labels*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement the method. Enter the code in [Listing 16-3](ch16.xhtml#ch16lis3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-3: Degrees of freedom assignment*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method first initializes the __dofs_dict attribute, setting it to an empty
    dictionary to make sure that we use a fresh new dictionary each time we run the
    method. Then, we iterate over the enumeration of all the nodes in the structure
    (self.__nodes), adding each node’s id as the key in the dictionary associated
    with a tuple of two numbers: the node’s DOFs.'
  prefs: []
  type: TYPE_NORMAL
- en: The enumerate function in Python returns an iterable sequence of the elements
    that we pass the function, together with their indices. This function is convenient
    for when the logic of what we’re doing requires the index of the items in a list.
    Here, we use the index of the node to compute its DOF numbers, which for a given
    index *i* are 2*i* and 2*i* + 1.
  prefs: []
  type: TYPE_NORMAL
- en: The first node, at index 0, will therefore get the degrees of freedom 0 and
    1\. The node at index 1 will get 2 and 3, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a structure with three nodes whose IDs are 1, 2, and 3, the degrees of
    freedom dictionary could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s move on to the next step, where the heavy lifting happens.
  prefs: []
  type: TYPE_NORMAL
- en: '***Assembling and Resolving the System of Equations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To find the displacements of the structure’s nodes, we need to assemble and
    solve the structure’s global ![Image](../images/f00433-p1.jpg) system of equations.
    This system consists of the bar’s individual systems of equations assembled together.
    The same way a bar’s ![Image](../images/f00433-p1.jpg) system relates the external
    forces and displacements on both its nodes, the structure’s global system of equations
    relates the forces and displacements of every node in the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break this down a bit more so we understand all the details. As always,
    doing a small example by hand will help us understand the process better.
  prefs: []
  type: TYPE_NORMAL
- en: '**An Example by Hand**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before we begin, a quick note on nomenclature: we’ll label each bar using the
    numbers of the nodes it lies on, separated with an arrow. So, 1 → 2 is the bar
    going from node 1 to node 2\. The nomenclature'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0433-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'refers to the ![Image](../images/f00397-p1.jpg) quantity for the bar 1 → 2:
    *E* refers to the bar’s material Young’s modulus, *A* is the bar’s cross section,
    and *l* is the bar’s length.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the structure in [Figure 16-3](ch16.xhtml#ch16fig3). This
    structure has three nodes, three bars, and an external load applied to node 3\.
    Let’s derive the system of equations for each of the three bars using the degrees
    of freedom numbering we’ve defined (see [Figure 16-4](ch16.xhtml#ch16fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-4: Our structure’s nodes and bars, labeled*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bar** 1 → 2 This horizontal bar goes from node 1 to node 2\. Its local x-
    and y-axes are aligned with the global coordinate system; thus, in this case,
    *θ* = 0°, and therefore cos0*°* = 1 and sin0*°* = 0\. The bar’s system of equations
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0434-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you need a refresher on how this system of equations is derived, refer to
    section “Stiffness Matrices in Global Coordinates” on [page 397](ch15.xhtml#ch00lev1sec92).
  prefs: []
  type: TYPE_NORMAL
- en: '**Bar** 1 → 3 This bar going from node 1 to node 3 forms an angle of 30° with
    the global x-axis; therefore, ![Image](../images/f00434-p1.jpg) and ![Image](../images/f00434-p2.jpg).
    The bar’s system of equations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0434-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Bar** 2 → 3 This vertical bar going from node 2 to node 3 makes an angle
    *θ* equal to 90°, so cos90° = 0 and sin90° = 1\. The bar’s system of equations
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0434-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have each bar’s system of equations, we need to assemble the structure’s
    global system. The structure has a total of three nodes, and each node has two
    degrees of freedom, so the size of the system is 3 × 2 = 6\. In this system, the
    forces and displacements need to appear in the position given by their DOF number.
    To make this clear, let’s make a table with the DOF numbers and the forces and
    displacements associated with them ([Table 16-2](ch16.xhtml#ch16tab2)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-2:** DOF Numbers for Each Force and Displacement'
  prefs: []
  type: TYPE_NORMAL
- en: '| **DOF** | **Associated force** | **Associated displacement** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | *F*[1*x*] = 0 | *u*[1] |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | *F*[1*y*] = 0 | *v*[1] |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *F*[2*x*] = 0 | *u*[2] |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *F*[2*y*] = 0 | *v*[2] |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *F*[3*x*] | *u*[3] |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | *F*[3*y*] | *v*[3] |'
  prefs: []
  type: TYPE_TB
- en: 'If the DOF numbering gives us the position in the system of equations that
    each force or displacement term needs to occupy, we can start constructing the
    system like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0435-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that if we decided to number the degrees of freedom differently, the order
    of the force and displacement terms would be different but perfectly valid nevertheless.
  prefs: []
  type: TYPE_NORMAL
- en: In this system of equations, we have yet to compute the stiffness terms. The
    general stiffness term *k*[*ij*] relates the force applied in the *i*^(th) degree
    of freedom with the displacement in the *j*^(th) degree of freedom (the same as
    we saw earlier in the “Interpreting the Stiffness Matrix Terms” on [page 429](ch16.xhtml#ch00lev2sec168)).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, if the *i*^(th) and *j*^(th) degrees of freedom don’t belong
    to the same node or to nodes not joined by a bar, the *k*[*ij*] stiffness term
    will be zero: there can’t be any relation between a force applied in *i* with
    a displacement in *j*. In our example structure, all the nodes are connected,
    so there won’t be zero values in the global matrix (except for those already in
    the bar’s individual matrices). In big structures where a node is connected with
    only a few others, the resulting stiffness matrices tend to have many zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute each of the *k*[*ij*] terms, we need to add all the stiffness values
    in the bar’s stiffness matrices that relate the *i*^(th) and *j*^(th) degrees
    of freedom. For example, to compute *k*[00], we have to account for the stiffness
    of bars 1 → 2 and 1 → 3, because those bars add a stiffness relation between the
    force applied in the DOF 0 and the displacement in the same DOF. To simplify the
    notation of the ![Image](../images/f00397-p1.jpg) terms a bit, let’s use the following
    aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0435-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this, let’s assemble the system’s matrix and vector by adding each of
    the stiffness terms and loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0436-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There’s one last step required to make this system of equations solvable: applying
    the external constraint conditions, that is, setting the constrained displacements
    as zero. This system of equations so far represents the structure without external
    constraints, but there are some imposed displacements of zero, and we have to
    force these conditions into its solution. In this case, node N1 has both its x
    and y displacements constrained, which can be expressed mathematically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*u*[1] = 0 and *v*[1] = 0'
  prefs: []
  type: TYPE_NORMAL
- en: The N2 node has its y displacement constrained. Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '*v*[2] = 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce these conditions in our system of equations so that they appear
    in the solution, we have to set both the row and columns of the given DOF number
    as the identity in the system’s matrix and a zero in the system’s force vector.
    In this case, the displacements *u*[1], *v*[1], and *v*[2] have the 0, 1, and
    3 DOFs assigned to them; let’s make those rows and columns the identity vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0436-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The force vector values at the constrained indices were already zero (there’s
    no force applied in those degrees of freedom), but if they weren’t, we’d have
    to zero them out as well. With this little algebraic trick, we force *u*[1], *v*[1],
    and *v*[2] to be equal to zero in the system’s solution. The resulting system
    matrix is positive definite; thus, the Cholesky numerical method we implemented
    in [Chapter 14](ch14.xhtml#ch14) is a good candidate to solve this system.
  prefs: []
  type: TYPE_NORMAL
- en: The structure’s system of equations is now assembled and ready to be solved.
    If we use a linear system resolution procedure, such as Cholesky’s factorization,
    we’ll obtain the values for the displacements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand this procedure, let’s put it in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Algorithm**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the Structure class, enter the method in [Listing 16-4](ch16.xhtml#ch16lis4).
    This method defines our resolution algorithm step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-4: Solving the system of equations*'
  prefs: []
  type: TYPE_NORMAL
- en: We called __solve_system_of_equations in [Listing 16-2](ch16.xhtml#ch16lis2),
    but we hadn’t yet defined it. This now complete method outlines the main steps
    to assemble and resolve the structure’s system of equations. Note that we’re using
    many methods we have yet to define; we’ll do so in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: We first compute the size of the system by multiplying the number of nodes in
    the structure by the degrees of freedom for each node, a value we stored in the
    constant __DOF_PER_NODE in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we assemble both the system’s matrix and vector using two private methods
    we’ll write later: __assemble_system_matrix and __assemble_system_vector.'
  prefs: []
  type: TYPE_NORMAL
- en: The next method we call, __apply_external_constraints, applies the conditions
    that force the constrained displacements to be zero, similar to the example we
    did by hand shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step uses the recently computed system matrix and force vector to
    find the solution using our Cholesky’s solver function: cholesky_solve. This function
    needs to be imported from the eqs package. The result we get is the displacement
    vector in global coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembling the System’s Matrix**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s write the __assemble_system_matrix method. This is probably the most complex
    piece of code involved in the structural analysis algorithm, but don’t worry,
    I’ll walk you through it. First, enter the code in [Listing 16-5](ch16.xhtml#ch16lis5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-5: Assembling the system of equations matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new Matrix instance with as many rows and columns as
    the passed-in size parameter. Then, we have a for loop that iterates over the
    bars in the structure. In the loop, we call the global_stiffness_matrix method
    on each bar and store the resulting stiffness matrix in the bar_matrix variable
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a list of all the degrees of freedom numbers included in the
    nodes of the bar: dofs ➋. To do this without adding too much noise in the __assemble_system_matrix
    method, we’ve implemented another private method: __bar_dofs.'
  prefs: []
  type: TYPE_NORMAL
- en: This __bar_dofs method uses the ids of the passed-in bar nodes to extract its
    DOF numbers from the __dofs_dict. After extracting the start and end nodes’ DOF
    numbers, we create a new tuple by concatenating the two DOF tuples. Note that
    we can concatenate tuples using the + operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a tuple containing the DOF numbers for a given bar’s nodes. Recall
    that this gives us the bar’s stiffness term’s position in the structure’s system
    of equations matrix: the DOF number is also the index in the system’s matrix.
    Back in __assemble_system_matrix, we use two for loops to cover all the terms
    in the bar’s stiffness matrix. These loops iterate over the matrix’s rows and
    columns and add every visited stiffness value to the structure’s global matrix
    ➌. We use the indices from the enumerations to access the bar’s stiffness matrix
    and the DOF numbers to know the position in the structure’s matrix. To make sure
    you understand this process, take a look at [Figure 16-5](ch16.xhtml#ch16fig5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-5: Assembling the stiffness matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, we’ve taken bar 1 → 3, whose first node, N1, has the DOFs 0 and
    1, and whose second node, N2, has the DOFs 4 and 5\. We’ve annotated the side
    and top of the bar’s stiffness matrix with the degrees of freedom numbers. The
    stiffness terms in the matrix relate these degrees of freedom. For example, the
    term *k*[21] is in the row that corresponds to DOF 4 and the column that corresponds
    to DOF 1; this term relates the force applied in DOF 4 with the displacement in
    DOF 1\. These DOF numbers are the indices in the structure’s stiffness matrix.
    The *k*[21] term, for instance, is located in the 4^(th) row and 1^(st) column
    in this matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The last step in [Listing 16-5](ch16.xhtml#ch16lis5) is to assign the computed
    matrix to the instance’s __system_matrix attribute ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembling the System’s Vector**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We assemble the system’s external-force vector using a similar procedure to
    what we just did with the stiffness matrix. This time, instead of iterating over
    the bars of the structure, we’ll iterate over the nodes: we want to collect the
    external forces on each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: In your file, enter the new private method in [Listing 16-6](ch16.xhtml#ch16lis6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-6: Assembling the system of equations vector*'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a new Vector sized according to the size parameter (don’t forget
    we’ve aliased this class to be named EqVector now).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a for loop that iterates over the nodes. For each node we save
    its net load in the net_load variable. Then we extract the node’s DOF numbers
    from __dofs_dict into the dof_x and dof_y variables. Note that we’re destructuring
    the tuple into these variables; take a look at “Destructuring” on [page 20](ch01.xhtml#ch00lev1sec15)
    if you need a refresher on destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add each of the net load components into the vector variable: the x
    component (net_load.u) in the position given by dof_x and the y component (net_load.v)
    in the position given by dof_y.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we assign the vector we’ve computed to the instance’s __system_vector
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying the External Constraints**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Lastly, we need to include the external constraints in the structure’s stiffness
    matrix and force vector. This means that we want those displacements that are
    externally constrained to be zero in the final solution vector; if they’re constrained,
    they can’t move. To accomplish this, we can use the algebraic trick we explored
    earlier, which consisted of setting the rows and columns of the associated degrees
    of freedom as identity rows and columns in the stiffness matrix and as zero in
    the force vector.
  prefs: []
  type: TYPE_NORMAL
- en: This is easier done than said, so, without further ado, let’s see what the code
    looks like. Enter the code in [Listing 16-7](ch16.xhtml#ch16lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-7: Applying the external constraints*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the existing external constraints, we iterate over the nodes of the
    structure. For each node, we extract its DOF numbers into the dof_x and dof_y
    variables ➊. Then we check whether the node has its displacement in the x direction
    constrained ➋, in which case we do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the stiffness matrix dof_x row to the identity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the stiffness matrix dof_x column to the identity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the force vector dof_x value to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do the same for the displacement in the y direction constraint ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The system is now ready to be solved. Once we have the system’s solution in
    the form of the displacement vector, we can create the structure’s solution model.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating the Solution***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s do a quick recap to remind ourselves where we are. We’ve written a lot
    of code split among a couple private methods. [Figure 16-6](ch16.xhtml#ch16fig6)
    shows a hierarchy of the methods involved in solving the structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-6: Structure resolution code split into a hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes in this diagram are the methods ordered from left to right according
    to their execution order. The solve_structure method is the public method defining
    the main algorithm. If you recall, that method consists of three steps, which
    are written as private methods:'
  prefs: []
  type: TYPE_NORMAL
- en: __assign_degrees_of_freedom
  prefs: []
  type: TYPE_NORMAL
- en: __solve_system_of_equations
  prefs: []
  type: TYPE_NORMAL
- en: __make_structure_solution
  prefs: []
  type: TYPE_NORMAL
- en: The second private method, __solve_system_of_equations, is the one with the
    most submethods, as you can observe in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve written all but the __make_structure_solution method, the third
    and last step in solve_structure. Let’s write this method now. It uses the solution
    to the system of equations (the node’s global displacements) to build the structure
    solution model.
  prefs: []
  type: TYPE_NORMAL
- en: In the *model/structure.py* file, enter the code in [Listing 16-8](ch16.xhtml#ch16lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-8: Creating the solution model*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is add a few imports from the structures.solution
    package. We also import the Vector class from the geom2d package.
  prefs: []
  type: TYPE_NORMAL
- en: Note how we add a type hint for the method’s returned object. These type hints
    are preceded by an arrow (->) and go between the method or function name and the
    colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, using a list comprehension, we map each of the original __nodes to the
    node solution model ➊. We use a private method we have to write: __node_to_solution.
    Given a node, this method looks for its degrees of freedom numbers ➎, creates
    a vector with the two displacements associated with those DOF numbers ➏, and returns
    an instance of StrNodeSolution using the original node and the vector of global
    displacements ➐.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in __make_structure_solution, the next step is an intermediate computation
    that will simplify the construction of the solution bars. We’ll create a dictionary
    of solution nodes where the key is the id of the node and the value is the node
    itself ➋.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of nodes_dict, computing the solution bar model becomes simpler.
    Using a list comprehension, we map each of the original bars to a StrBarSolution
    instance ➌. To instantiate this class, we need to pass it the original bar and
    the two solution nodes; thanks to the dictionary we just created, this is a piece
    of cake. If we hadn’t created the dictionary of nodes by ID, we’d need to search
    the list of solution nodes for a node with a given ID. Performance-wise, this
    isn’t ideal. For each bar, we may need to iterate over the whole list of nodes
    twice. Creating the dictionary to find nodes by ID is a much wiser option; it
    allows for a constant-time search of the nodes. This means that, no matter the
    size of the dictionary, looking up the value associated with a key takes the same
    amount of time. If the structure has a large number of nodes, this improvement
    can noticeably decrease the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we instantiate StructureSolution, passing it the solution nodes and
    bars ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Result***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Resolving the structure required quite a lot of code, so we better bring it
    all together in a single listing for clarity. [Listing 16-9](ch16.xhtml#ch16lis9)
    is the complete Structure class’s code, including the solve_structure implementation
    and every private method we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-9: The final Structure class*'
  prefs: []
  type: TYPE_NORMAL
- en: With this code ready, the only missing thing is some unit tests. We need to
    make sure all the logic we’ve just written is bug-free. But the code we’ve written
    in the previous two chapters has become more complex and requires the interaction
    of several different classes to work. How do we isolate the parts of the code
    we want to test?
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Unit Testing: Test Doubles**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As our classes get more complex, they’ll often rely on other classes and external
    functions. Here’s where unit testing becomes trickier. Unit testing is about isolating
    a small portion of the logic in the class or function we want to test so that
    there’s one single reason for a test to fail. Testing that things run correctly
    when they’re put to work together is known as *integration testing*. Integration
    tests are meant to test bigger chunks of the system; with integration tests, we’re
    interested in knowing whether the smaller pieces of a system still work when they
    interact with each other. We won’t be integration testing here, but I encourage
    you to try it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to unit tests, let’s take our StructureSolution class from the previous
    chapter. Let’s say we want to test its bounds_rect method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method delegates most of its logic to make_rect_containing_with_margin
    and also depends on StrNodeSolution instances to correctly compute their displaced
    position. If we tested this method as is, we’d be testing make_rect_containing_with_margin
    and the Node class’s displaced_pos_scaled method. Those should both already be
    unit tested somewhere else. The test could fail for several reasons that are unrelated
    to the logic in bounds_rect. In this case, we’d be doing an integration test,
    but we first want to make sure our method works well in isolation using unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: We can test this method without relying on other classes’ implementation using
    test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: '***Test Doubles***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *test double* replaces a real implementation used in a test. This test double
    may replace a function, an entire class, or just parts of it. To do the unit test,
    we replace all the parts of the code that are not being directly tested by the
    unit test with test doubles. What exactly the test double does depends on what
    type of test double it is. There are a few flavors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dummy** This is the simplest test double. The *dummy* replaces an object
    whose presence is required but that is never actually used in the test. This could
    be a parameter to the function, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fake** A *fake* test double replaces some part of the code; it has a working
    implementation but takes some shortcuts or is greatly simplified. Say, for example,
    we have a function that reads a text file and parses a structure model from it.
    If this function was used in another part of the code we wanted to test, we could
    create a fake version of it that pretends to read a file, although it really doesn’t
    and creates a structure to return it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stub** A *stub* replaces some part of the code and always returns the same
    value or behaves in a specific way. For example, we could stub our are_close_enough
    function (that compares floating-point numbers) to always return False in a given
    test.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mock** This is a test double that records the way it’s being used so that
    it can be used to make assertions. *Mocks* are probably the most sophisticated
    and versatile type of test doubles. We can mock entire objects, pass them to our
    code in place of the real implementation, and then explore how our code interacted
    with the mock to make sure the right interactions took place. We’ll look at a
    real example of a mock briefly.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explore how Python allows us to create test doubles. We’ll focus on
    mocking, as mocks are so versatile that we can use them in almost every case where
    a test double is required.
  prefs: []
  type: TYPE_NORMAL
- en: '***The unittest.mock Package***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The unittest package in the Python standard library includes its own mocking
    mechanism, found in the unittest.mock package. You can read the package’s documentation
    at [*docs.python.org/3/library/unittest.mock.html*](http://docs.python.org/3/library/unittest.mock.html),
    and I recommend you do, as it contains detailed explanations that will help you
    understand how best to use it. Let’s take a quick look at how to use the unittest.mock
    package’s main functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Mock Object**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Mock is the main class in the unittest.mock package. This class’s instances
    record every interaction they have and provide us with assertions to check those
    interactions. You can call any method you want in a mock object; if the method
    doesn’t exist, it will be created so we can inspect how many times this method
    was called or what parameters were passed in. As stated in the documentation,
  prefs: []
  type: TYPE_NORMAL
- en: Mocks are callable and create attributes as new mocks when you access them.
    Accessing the same attribute will always return the same mock. Mocks record how
    you use them, allowing you to make assertions about what your code has done to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break that documentation down. An instance of the Mock class being “callable”
    means that you can “call” it the same way you call a function. Those calls you
    make on the instance are recorded by the mock. This suggests we can use Mock instances
    to replace functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation also says that mocks “create attributes as new mocks when
    you access them.” This means that when you call a method on a Mock instance, Python
    will create a new Mock for that method, if it doesn’t exist yet, and append it
    as a new attribute of the instance. Don’t forget that mocks are callable: you
    can call these attributes as if they were methods, and their interactions will
    be recorded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a quick example in Python’s shell to start making these
    concepts a bit more concrete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code we create a new instance of the Mock class and call it like a
    function. We also call a method named some_method on our mock and pass it two
    arguments: the string ’foo’ and the number 23. Calling some_method has no side
    effects: it does nothing except for record the call to it; this is because mock
    methods have no implementation by default. We’ll learn later how to make mock
    methods return something or perform some kind of side effect, but for now just
    keep in mind that, by default, mocks do nothing but record their usage.'
  prefs: []
  type: TYPE_NORMAL
- en: If we call a method from a Mock object that we haven’t configured to return
    anything or perform any kind of side effect, by default it’ll return another Mock
    instance. This is the instance that’s stored in the original mock as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ask this mock whether some_method has been called or not, and with what
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All three calls succeed (don’t raise an assertion error), but if we asked for
    arguments that were not passed to some_method,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'we’d get an AssertionError with a helpful message, which would make a test
    fail and give us the reason why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, if we asked for the calls of a method that was never called,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'we’d also get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s not forget that the mock itself is a callable object that records the
    interactions made with it. Therefore, the following also succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Mocking Classes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A common use case for mocks is creating a mock instance of a given class. These
    mocks let us inspect how the class they’re mocking was used and what methods were
    called on it; we can also use the mock to provide return values for the mocked
    methods to use in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mock a class, we pass it to the spec parameter of the Mock constructor.
    Let’s create a mock for our Vector class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This mock object has its __class__ attribute set to Vector so that it looks
    like a real Vector instance. It even passes the isinstance test! This mock can
    be effectively used to replace a real Vector. All of the methods in the Vector
    class are also defined in this test double. We can call any of them as we normally
    would:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This time, rotated_radians didn’t return a new instance of Vector, as we’d expect.
    Instead, it returned a Mock instance. Since a mocked class’s methods have no implementation,
    there is no code to perform the rotating operation and return the resulting vector.
    We can program mock methods to return a predefined value using the mock’s side_effect
    and return_value attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we get to that, there’s one more thing that’s important about class
    mocks: if we try to call a method that doesn’t exist in the class, we’ll get an
    AttributeError. New attributes can be added to a generic mock, but not to a mock
    of a class. The code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'yields this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is good: we can be sure that if some part of our code tries to call methods
    that don’t exist in the original class, we’ll get an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at how we can go about adding a stub implementation or
    simply a predefined return value for mocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Return Values and Side Effects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'By setting a mock’s return_value, we can make it return something when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling rotated_radians now returns an instance of the Vector class: exactly
    the instance we programmed it to return. From now on, every time this method is
    called on the mock, it will return the same Vector instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocks can also execute side effects when called. According to the documentation,
    a side_effect
  prefs: []
  type: TYPE_NORMAL
- en: can either be a function to be called when the mock is called, an iterable or
    an exception (class or instance) to be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first take a look at how a mock can raise an exception. For example,
    if we needed the cosine method to raise a ValueError, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we’re setting the ValueError class itself as the side_effect, but
    as the documentation states, we can also use a concrete instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, every time we call cosine, we get the same ValueError instance.
    In the previous example, every call produces a new instance of the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also assign a function to a mock’s side_effect attribute. This function
    receives the parameters passed to the mock function and might return a value.
    For example, in our Vector mock, we could decide to have the scaled_by method
    return the passed-in factor parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the scaled_by method was passed a 45 as the scaling factor, and
    this parameter was forwarded to the function defined as the mock’s side_effect
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can perform its own side effect, like saving the parameters it
    received or printing something to the shell. We can use this function together
    with return_value. If we use the function to perform a side effect but still want
    to return whatever is set in the return_value attribute, the function should return
    DEFAULT (defined in unittest.mock):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the side_effect function was called, but as it returned the
    DEFAULT value, the call to scaled_by returned the vector we set as return_value.
  prefs: []
  type: TYPE_NORMAL
- en: '**The patch Decorator**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *mock* package includes a unittest.mock.patch decorator we can use to mock
    objects in a test function. The @patch decorator has the ability to mock objects
    instantiated in the test function they decorate. The mocks created by the decorator
    are cleared for us automatically once the function returns, so the mocking is
    only effective in the context of the function. We have to pass the @patch decorator
    the target we want to mock using the format ’package.module.name’ (this is a string,
    so don’t forget the quotation marks), where name can be the name of a class or
    a function. The decorated function will be passed the mocked target as a new argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this test we’re replacing the make_circle_from_points function defined in
    the *geom2d* package’s *circles* module. We have to include the mocked function,
    make_circle_mock, as an argument to the function. Then, in the context of the
    test_something function, we can refer to the mocked function and assert it was
    called like we do with any other mock.
  prefs: []
  type: TYPE_NORMAL
- en: The @patch decorator’s main use case is replacing functions or classes that
    are imported by our test subjects. By using a patch, we force them to import a
    mock instead of the real dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no other easy way of mocking the dependencies of the modules we want
    to unit test: if the module imports their dependencies, we need a way of replacing
    that dependency in Python’s importing mechanism. The @patch decorator does this
    for us in an elegant manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s apply all this knowledge to test our code in isolation: there’s no
    better way of learning how to use test doubles than using them in real use cases.
    If you’re new to using test doubles, you may be a bit confused at this point;
    that’s perfectly normal. As we see mocks in action a couple times, you’ll start
    to grasp the concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the Structure Solution Class**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the example we introduced earlier of the bounds_rect method in the
    StructureSolution class, let’s see how we can go about testing it. Remember, the
    method we want to test is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The method requires that the StrNodeSolution class correctly computes its displaced
    position using a scale and that the make_rect_containing_with_margin function
    returns the correct rectangle using the given margin. We don’t need to test those
    behaviors; that should have been done somewhere else. What we want to do is replace
    their real implementations with test doubles so that they don’t interfere in our
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s create a new file in *structures/tests* named *structure_solution_test.py*.
    In the file, enter the test setup code, as in [Listing 16-10](#ch16lis10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-10: Structure solution class test: the setup*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this test setup, we’re defining two points: p_one and p_two; these are the
    positions for the mock nodes we create in the setUp method. This setUp method
    is executed by the unittest framework before each test, which ensures that each
    test gets fresh mocks; otherwise, mocks would continue to record throughout the
    tests, breaking the independence between tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define two nodes: n_one and n_two. Then we instantiate node mocks using
    the StrNodeSolution class as the value for the spec parameter. Each of the node
    mocks defines one of the defined points as the return value for its displaced_pos_scaled
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s write the first test, which will ensure that the two nodes get the
    displaced_pos_scaled called with the correct value for the scale parameter. After
    the setUp method, enter the test in [Listing 16-11](ch16.xhtml#ch16lis11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-11: Structure solution class test: first test*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a StructureSolution instance with a list containing the two nodes
    defined in the setUp and no bars: we don’t need them to test the bounds_rect method,
    and the StructureSolution doesn’t complain if we instantiate it with an empty
    bars list. If the StructureSolution class initializer complained about getting
    an empty list of bars, this would have been the perfect case for using the dummy
    test double: we’d pass the constructor a list of dummy bars. Dummies are used
    to fill in required parameters, but dummies don’t actually do anything or interfere
    with the test in any way.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve instantiated our StructureSolution, we call the bounds_rect method,
    our test subject, with values for the margin and scale. Lastly, we assert that
    displaced_pos_scaled was called once with the correct value for the scale in both
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test ensures that we use the node’s displaced positions with the corresponding
    scale applied to compute the structure solution bounds. Imagine that, by mistake,
    we confused the margin and scale parameters when implementing the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our unit test would have warned us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You’ve written your first unit test using test doubles. Let’s
    now write a second test that ensures the right usage of the function that computes
    the rectangle. Enter the code in [Listing 16-12](ch16.xhtml#ch16lis12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-12: Structure solution class test: second test*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This test is a bit trickier because the make_rect_containing_with_margin function
    is imported by the StructureSolution class. To make this class import our mock
    instead of the real implementation, we have to patch the function’s path: ’package.module.name’,
    which is, in this case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '''structures.solution.structure.make_rect_containing_with_margin'''
  prefs: []
  type: TYPE_NORMAL
- en: 'But, wait: isn’t make_rect_containing_with_margin defined in the *geom2d* package?
    So why are we patching it as if it were in the *structures.solution* package and
    the *structure* module?'
  prefs: []
  type: TYPE_NORMAL
- en: The @patch decorator has some rules that define how the path should be given
    to mock a given object. In the “Where to patch” section, the documentation states
  prefs: []
  type: TYPE_NORMAL
- en: patch() works by (temporarily) changing the object that a *name* points to with
    another one. There can be many names pointing to any individual object, so for
    patching to work you must ensure that you patch the name used by the system under
    test.
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle is that you patch where an object is *looked up*, which
    is not necessarily the same place as where it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'That second paragraph gives us the key: objects have to be patched where they’re
    looked up. In the case of our test, the function we want to replace is looked
    up in the structures.solution package, in the *structure* module. This may sound
    a bit complicated in the beginning, but it’ll start to make sense after you’ve
    done it a few times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on with our test, the first two lines are identical to the previous
    one: they create the structure solution and call the function under test. Then
    comes the assertion, which is done on the parameter passed to the test function:
    make_rect_mock. Remember, the @patch decorator passes the patched entity to the
    decorated function. We assert that the mock was called only once with the list
    of positions the mocked nodes return and the value for the margin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run these tests using PyCharm, by clicking the green play button to
    the left of the test class name. Alternatively, you can run them from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 16-13](ch16.xhtml#ch16lis13) shows the resulting code for your reference.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-13: Structure solution class test: the result*'
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, there’s one important gotcha we need to take into account.
    If you take a look at both tests, you may be tempted to remove the duplicated
    lines,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: by moving them to the setUp. That seems a reasonable thing to do so that the
    tests don’t need to repeat those lines, but if you want to go ahead and do the
    refactor, you’ll find that the second test now fails. Why?
  prefs: []
  type: TYPE_NORMAL
- en: The answer has to do with how the @patch decorator works. It has to decorate
    the function where the dependency it’s patching gets resolved, and in our case,
    the make_rect_containing_with_margin function is imported when the StructureSolution
    class is instantiated. Therefore, at least for the second test, the instantiation
    of this class needs to happen in the test method, which is annotated with the
    @patch decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the Structure Resolution Process**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now add a few tests to ensure the structure resolution process yields
    the correct results. For these tests, we’ll define the structure in [Figure 16-7](ch16.xhtml#ch16fig7)
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-7: Structure for the unit tests*'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the *structures/tests* directory named *structure_test.py*.
    In the file, enter the code in [Listing 16-14](ch16.xhtml#ch16lis14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-14: Structure resolution test*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing defines the StructureTest test class. In the setUp method, which
    is called before every test, we define the structure in [Figure 16-7](ch16.xhtml#ch16fig7).
    The structure has three nodes: n_1, n_2, and n_3. The last one, n_3, has a load
    applied to it. We’re not adding the external constraints to nodes 1 and 2 yet;
    we’ll see why this is in a minute. Then, we create the bars b_12, b_23, and b_13
    between the nodes we just defined; we use the values 5 and 10 for the cross section
    and Young’s modulus. With all these nodes and bars, the structure is finally instantiated
    ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: Next come three simple tests. The first ensures that the structure counts how
    many nodes it has ➋. The second does the same thing but with bars ➌. The third
    also does the same, this time with the number of loads applied to the structure
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most complex operations in solving the structure is assembling the
    stiffness matrix, so let’s add a test to check this matrix is properly assembled
    before we apply the external constraint conditions. Since we haven’t yet added
    external constraints to the structure, the matrix that is passed to the cholesky_solve
    function is the system’s matrix we’re looking for. If we mock the cholesky_solve
    function, the arguments passed to it are the system’s stiffness matrix and load
    vector, which we can capture to make assertions. By mocking this function, our
    code won’t execute the Cholesky’s method original code, which is fine because
    that logic shouldn’t interfere with our test. Enter the new test in [Listing 16-15](ch16.xhtml#ch16lis15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-15: System’s stiffness matrix assembly test*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first want the cholesky_solve function mocked, so we’ve added an @patch
    decorator with the path to where this function is looked up: the structures/model/structure
    package’s *cholesky_solve* module ➊. Notice how we pass cholesky_mock as an argument
    to the test method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the expected structure’s stiffness matrix: expected_mat. This
    is a 6 × 6 matrix (three nodes with two degrees of freedom each). I’ve done the
    math and assembled the matrix by hand; I suggest you do this as well to make sure
    you understand the process. There are some auxiliary variables defined for bar
    1 → 3:'
  prefs: []
  type: TYPE_NORMAL
- en: eal3 is the ![Image](../images/f00397-p1.jpg) amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: c2_eal3 is ![Image](../images/f00460-p1.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s2_eal3 is ![Image](../images/f00460-p2.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cs_eal3 is ![Image](../images/f00460-p3.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numbers in the stiffness matrices for bars 1 → 2 and 2 → 3 are straightforward
    because their angles are ![Image](../images/f00460-p4.jpg) and 0 radians, respectively.
    After assembling the global matrix using the three bars’ matrices, the result
    is ➋.
  prefs: []
  type: TYPE_NORMAL
- en: To run the resolution code, we have to call the solve_structure method. After
    executing the solve method, we’re interested in knowing which arguments were passed
    to the cholesky_mock function. Mocks have an attribute, call_args, a list containing
    the arguments passed to each of the calls to the mock. Our mock function was called
    only once, so we want the arguments to this first call.
  prefs: []
  type: TYPE_NORMAL
- en: We destructured cholesky_mock’s call_args for the first call (call_args[0])
    and only kept the first one in a variable named actual_mat ➌. As you can see,
    the second element in the left-side list ([actual_mat, _]) is an underscore, meaning
    there is a value for that position in the right-side list (cholesky_mock.call_args[0]),
    but we’re not interested in saving it.
  prefs: []
  type: TYPE_NORMAL
- en: Then come two assertions. The first one checks that cholesky_mock was called
    only once ➍, and the second compares the expected stiffness matrix with the actual
    stiffness matrix passed to the cholesky_mock resolution function ➎.
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we’re ensuring that the Cholesky resolution function gets passed
    the right structure’s stiffness matrix assembled without external constraint conditions
    applied. Let’s now write a new test with these constraints to check that the stiffness
    matrix is correctly modified to include them. Enter the test in [Listing 16-16](ch16.xhtml#ch16lis16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-16: System’s stiffness matrix constraints test*'
  prefs: []
  type: TYPE_NORMAL
- en: This test is similar to the previous one. The cholesky_solve function is patched
    the same way ➊, and the new mock argument, cholesky_mock, is passed to the test
    method. Then, we call a private method to add the external constraints to nodes
    1 and 2, like they appear in [Figure 16-7](ch16.xhtml#ch16fig7) ➋. We’ll have
    to write this method after the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes the definition of the expected matrix, this time with the external
    constraints applied ➌. The only terms that are not zero, apart from the ones in
    the main diagonal, are those that belong to node 3: degrees of freedom 4 and 5\.
    For this reason, only the terms in those row and column indices are nonzero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the test is exactly the same as before: we call the solve_structure
    method on the structure instance. Then we save the matrix argument extracted from
    the call to cholesky_mock into a variable named actual_mat. Note that we’re using
    a list unpacking for this, where the second item, which is the system’s load vector,
    is ignored by using an underscore. There’s the assertion that checks if the Cholesky
    mock function has been called only once, and the check comparing the actual and
    expected system matrices ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to write the _set_external_constraints function that applies
    the external constraints to nodes 1 and 2\. After the method we’ve just written,
    enter the code in [Listing 16-17](ch16.xhtml#ch16lis17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-17: Setting external constraints to nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try one last test to check the load vector assembly process. The idea
    is to follow the structure of the last two tests, but this time checking the load
    vector. Enter the test in [Listing 16-18](ch16.xhtml#ch16lis18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-18: System’s load vector assembly test*'
  prefs: []
  type: TYPE_NORMAL
- en: We patch the cholesky_solve function the same way as before ➊. Then we declare
    the expected load vector ➋, which this time is easy, as there’s only one load
    applied to node 3.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the test is similar. The major difference is that this time we’re
    destructuring the second argument of the first call to the cholesky_mock ➌, which
    is the passed-in vector, the load vector that our code produced. This time we’re
    not asserting that the mock was called once, as we’ve done in the last two tests;
    we could, but that condition is already tested. There’s no need to repeat the
    same assertion. What we do want to check is that the actual_vec equals the expected_vec
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now run our tests. To do so from the shell, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following output, if all of your tests passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We could write a few more unit tests, but we won’t be doing so for brevity reasons.
    Nevertheless, I suggest you come up with more tests and exercise your test doubles
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we developed the structure’s resolution algorithm, a complex
    piece of logic that we split among a few private methods. This resolution process
    does all the heavy lifting in assembling the structure’s global stiffness matrix
    and vector, applying the external constraints, and solving the resulting system
    of equations using the Cholesky’s procedure we implemented earlier. Once the node
    global displacements are obtained, they are used to construct the structure solution
    model. We’ll see in [Chapter 18](ch18.xhtml#ch18) how to produce a graphic result
    for this solution model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also introduced the concept of test doubles, a key technique to write good
    unit tests by isolating a small part of the code from its collaborators. There
    are a few different test doubles; Python’s *unittest* implementation basically
    provides us with one: the mock. Nevertheless, this mock implementation is so flexible
    that it can also be used as a stub or spy. We learned how to use this class and
    the @patch decorator by using them to test our latest code.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to focus on reading and parsing structures from text files so
    we can feed our resolution algorithm with some fine structure definitions. Let’s
    go for it!
  prefs: []
  type: TYPE_NORMAL
