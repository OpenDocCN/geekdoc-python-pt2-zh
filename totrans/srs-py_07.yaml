- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**METHODS AND DECORATORS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法和装饰器**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Python’s decorators are a handy way to modify functions. Decorators were first
    introduced in Python 2.2, with the classmethod() and staticmethod() decorators,
    but were overhauled to become more flexible and readable. Along with these two
    original decorators, Python now provides a few right out of the box and supports
    the simple creation of custom decorators. But it seems as though most developers
    do not understand how they work behind the scenes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的装饰器是修改函数的便捷方式。装饰器最初在 Python 2.2 中引入，当时有 classmethod() 和 staticmethod()
    装饰器，但它们经过大幅改进，变得更加灵活和易于阅读。除了这两个原始装饰器，Python 现在还提供了几个现成的装饰器，并支持轻松创建自定义装饰器。但是，似乎大多数开发者并不理解它们在幕后是如何工作的。
- en: This chapter aims to change that—we’ll cover what a decorator is and how to
    use it, as well as how to create your own decorators. Then we’ll look at using
    decorators to create static, class, and abstract methods and take a close look
    at the super() function, which allows you to place implementable code inside an
    abstract method.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是改变这一点——我们将讨论什么是装饰器，如何使用它们，以及如何创建自己的装饰器。接着我们将看看如何使用装饰器来创建静态方法、类方法和抽象方法，并深入了解
    super() 函数，它允许你在抽象方法中实现可执行代码。
- en: '**Decorators and When to Use Them**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**装饰器及其使用时机**'
- en: A *decorator* is a function that takes another function as an argument and replaces
    it with a new, modified function. The primary use case for decorators is in factoring
    common code that needs to be called before, after, or around multiple functions.
    If you’ve ever written Emacs Lisp code, you may have used the defadvice decorator,
    which allows you to define code called around a function. If you’ve used method
    combinations in the Common Lisp Object System (CLOS), Python decorators follow
    the same concepts. We’ll look at some simple decorator definitions, and then we’ll
    examine some common situations in which you’d use decorators.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *装饰器* 是一个接受另一个函数作为参数并将其替换为新的修改过的函数的函数。装饰器的主要用途是提取需要在多个函数之前、之后或周围调用的公共代码。如果你曾经写过
    Emacs Lisp 代码，你可能使用过 defadvice 装饰器，它允许你定义围绕某个函数调用的代码。如果你使用过 Common Lisp 对象系统（CLOS）中的方法组合，Python
    装饰器遵循相同的概念。我们将先看一些简单的装饰器定义，然后再看看在一些常见场景下如何使用装饰器。
- en: '***Creating Decorators***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建装饰器***'
- en: 'The odds are good that you’ve already used decorators to make your own wrapper
    functions. The dullest possible decorator, and the simplest example, is the identity()
    function, which does nothing except return the original function. Here is its
    definition:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能已经使用过装饰器来创建你自己的包装函数。最简单的装饰器，也是最枯燥的例子，就是 identity() 函数，它除了返回原始函数外什么也不做。下面是它的定义：
- en: 'def identity(f):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'def identity(f):'
- en: return f
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: return f
- en: 'You would then use your decorator like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以像这样使用你的装饰器：
- en: '@identity'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '@identity'
- en: 'def foo():'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo():'
- en: return 'bar'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: return 'bar'
- en: 'You enter the name of the decorator preceded by an @ symbol and then enter
    the function you want to use it on. This is the same as writing the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需在装饰器的名称前加上 @ 符号，然后输入你想要使用它的函数。这与以下代码是等效的：
- en: 'def foo():'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo():'
- en: return 'bar'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: return 'bar'
- en: foo = identity(foo)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: foo = identity(foo)
- en: This decorator is useless, but it works. Let’s look at another, more useful
    example in [Listing 7-1](ch07.xhtml#ch7list1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器是无用的，但它仍然有效。让我们来看一个更有用的例子，在 [Listing 7-1](ch07.xhtml#ch7list1) 中。
- en: _functions = {}
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: _functions = {}
- en: 'def register(f):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'def register(f):'
- en: global _functions
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: global _functions
- en: _functions[f.__name__] = f
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: _functions[f.__name__] = f
- en: return f
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: return f
- en: '@register'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '@register'
- en: 'def foo():'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo():'
- en: return 'bar'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: return 'bar'
- en: '*Listing 7-1: A decorator to organize functions in a dictionary*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-1：一个将函数组织在字典中的装饰器*'
- en: 'In [Listing 7-1](ch07.xhtml#ch7list1), the register decorator stores the decorated
    function name into a dictionary. The _functions dictionary can then be used and
    accessed using the function name to retrieve a function: _functions[''foo''] points
    to the foo() function.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 7-1](ch07.xhtml#ch7list1) 中，register 装饰器将被装饰的函数名称存储到字典中。然后可以使用函数名称来访问
    _functions 字典，进而检索函数：_functions['foo'] 指向 foo() 函数。
- en: In the following sections, I will explain how to write your own decorators.
    Then I’ll cover how the built-in decorators provided by Python work and explain
    how (and when) to use them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将解释如何编写自己的装饰器。然后，我会讲解 Python 提供的内置装饰器如何工作，并解释如何（以及何时）使用它们。
- en: '***Writing Decorators***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写装饰器***'
- en: 'As mentioned, decorators are often used when refactoring repeated code around
    functions. Consider the following set of functions that need to check whether
    the username they receive as an argument is the admin or not and, if the user
    is not an admin, raise an exception:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，装饰器通常用于重构围绕函数的重复代码。考虑以下一组函数，它们需要检查接收到的用户名参数是否为管理员，如果用户不是管理员，则抛出异常：
- en: 'class Store(object):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Store(object):'
- en: 'def get_food(self, username, food):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(self, username, food):'
- en: 'if username != ''admin'':'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'if username != ''admin'':'
- en: raise Exception("This user is not allowed to get food")
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: raise Exception("此用户无法获取食物")
- en: return self.storage.get(food)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: return self.storage.get(food)
- en: 'def put_food(self, username, food):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'def put_food(self, username, food):'
- en: 'if username != ''admin'':'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'if username != ''admin'':'
- en: raise Exception("This user is not allowed to put food")
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: raise Exception("此用户无法放置食物")
- en: self.storage.put(food)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: self.storage.put(food)
- en: 'We can see there’s some repeated code here. The obvious first step to making
    this code more efficient is to factor the code that checks for admin status:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有一些重复的代码。使这段代码更高效的显而易见的第一步是将检查管理员状态的代码提取出来：
- en: '➊ def check_is_admin(username):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def check_is_admin(username):'
- en: 'if username != ''admin'':'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'if username != ''admin'':'
- en: raise Exception("This user is not allowed to get or put food")
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: raise Exception("此用户无法获取或放置食物")
- en: 'class Store(object):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Store(object):'
- en: 'def get_food(self, username, food):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(self, username, food):'
- en: check_is_admin(username)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: check_is_admin(username)
- en: return self.storage.get(food)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: return self.storage.get(food)
- en: 'def put_food(self, username, food):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'def put_food(self, username, food):'
- en: check_is_admin(username)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: check_is_admin(username)
- en: self.storage.put(food)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: self.storage.put(food)
- en: We’ve moved the checking code into its own function ➊. Now our code looks a
    bit cleaner, but we can do even better if we use a decorator, as shown in [Listing
    7-2](ch07.xhtml#ch7list2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查代码移到了它自己的函数中 ➊。现在我们的代码看起来更简洁了，但如果我们使用装饰器，效果会更好，如[清单 7-2](ch07.xhtml#ch7list2)所示。
- en: 'def check_is_admin(f):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'def check_is_admin(f):'
- en: '➊ def wrapper(*args, **kwargs):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def wrapper(*args, **kwargs):'
- en: 'if kwargs.get(''username'') != ''admin'':'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'if kwargs.get(''username'') != ''admin'':'
- en: raise Exception("This user is not allowed to get or put food")
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: raise Exception("此用户无法获取或放置食物")
- en: return f(*args, **kwargs) return wrapper
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: return f(*args, **kwargs) return wrapper
- en: 'class Store(object):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Store(object):'
- en: '@check_is_admin'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '@check_is_admin'
- en: 'def get_food(self, username, food):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(self, username, food):'
- en: return self.storage.get(food)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: return self.storage.get(food)
- en: '@check_is_admin'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '@check_is_admin'
- en: 'def put_food(self, username, food):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'def put_food(self, username, food):'
- en: self.storage.put(food)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: self.storage.put(food)
- en: '*Listing 7-2: Adding a decorator to the factored code*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：为简化代码添加装饰器*'
- en: We define our check_is_admin decorator ➊ and then call it whenever we need to
    check for access rights. The decorator inspects the arguments passed to the function
    using the kwargs variable and retrieves the username argument, performing the
    username check before calling the actual function. Using decorators like this
    makes it easier to manage common functionality. To anyone with much Python experience,
    this is probably old hat, but what you might not realize is that this naive approach
    to implementing decorators has some major drawbacks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的check_is_admin装饰器 ➊，然后每当需要检查访问权限时调用它。装饰器使用kwargs变量检查传递给函数的参数，并获取用户名参数，在调用实际函数之前执行用户名检查。像这样使用装饰器可以更轻松地管理通用功能。对于有经验的Python程序员来说，这可能是老生常谈，但你可能没有意识到，采用这种简单的装饰器实现方法有一些重大的缺陷。
- en: '***Stacking Decorators***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***叠加装饰器***'
- en: You can also use several decorators on top of a single function or method, as
    shown in [Listing 7-3](ch07.xhtml#ch7list3).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在单个函数或方法上使用多个装饰器，如[清单 7-3](ch07.xhtml#ch7list3)所示。
- en: 'def check_user_is_not(username):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'def check_user_is_not(username):'
- en: 'def user_check_decorator(f):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'def user_check_decorator(f):'
- en: 'def wrapper(*args, **kwargs):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'def wrapper(*args, **kwargs):'
- en: 'if kwargs.get(''username'') == username:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'if kwargs.get(''username'') == username:'
- en: raise Exception("This user is not allowed to get food")
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: raise Exception("此用户无法获取食物")
- en: return f(*args, **kwargs)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: return f(*args, **kwargs)
- en: return wrapper
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: return wrapper
- en: return user_check_decorator
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: return user_check_decorator
- en: 'class Store(object):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Store(object):'
- en: '@check_user_is_not("admin")'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '@check_user_is_not("admin")'
- en: '@check_user_is_not("user123")'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '@check_user_is_not("user123")'
- en: 'def get_food(self, username, food):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(self, username, food):'
- en: return self.storage.get(food)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: return self.storage.get(food)
- en: '*Listing 7-3: Using more than one decorator with a single function*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：使用多个装饰器修饰单个函数*'
- en: Here, check_user_is_not() is a factory function for our decorator user_check_decorator().
    It creates a function decorator that depends on the username variable and then
    returns that variable. The function user_check_decorator() will serve as a function
    decorator for get_food().
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，check_user_is_not() 是我们装饰器 user_check_decorator() 的工厂函数。它创建了一个依赖于用户名变量的函数装饰器，并返回该变量。函数
    user_check_decorator() 将作为 get_food() 的函数装饰器。
- en: The function get_food() gets decorated twice using check_user_is_not(). The
    question here is which username should be checked first—admin or user123? The
    answer is in the following code, where I translated [Listing 7-3](ch07.xhtml#ch7list3)
    into equivalent code without using a decorator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 get_food() 被 check_user_is_not() 装饰了两次。问题在于，应该首先检查哪个用户名——admin 还是 user123？答案在下面的代码中，我将[列表
    7-3](ch07.xhtml#ch7list3)转换成了不使用装饰器的等效代码。
- en: 'class Store(object):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Store(object):'
- en: 'def get_food(self, username, food):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(self, username, food):'
- en: return self.storage.get(food)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: return self.storage.get(food)
- en: Store.get_food = check_user_is_not("user123")(Store.get_food)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Store.get_food = check_user_is_not("user123")(Store.get_food)
- en: Store.get_food = check_user_is_not("admin")(Store.get_food)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Store.get_food = check_user_is_not("admin")(Store.get_food)
- en: The decorator list is applied from top to bottom, so the decorators closest
    to the def keyword will be applied first and executed last. In the example above,
    the program will check for admin first and then for user123.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器列表是从上到下应用的，因此离 `def` 关键字最近的装饰器将首先应用并最后执行。在上面的例子中，程序会先检查 admin，然后检查 user123。
- en: '***Writing Class Decorators***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写类装饰器***'
- en: 'It’s also possible to implement class decorators, though these are less often
    used in the wild. *Class decorators* work in the same way as function decorators,
    but they act on classes rather than functions. The following is an example of
    a class decorator that sets attributes for two classes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以实现类装饰器，尽管这些在实际使用中较少见。*类装饰器*的工作原理与函数装饰器相同，但它们作用于类而不是函数。以下是一个类装饰器的示例，它为两个类设置属性：
- en: import uuid
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: import uuid
- en: 'def set_class_name_and_id(klass):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'def set_class_name_and_id(klass):'
- en: klass.name = str(klass)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: klass.name = str(klass)
- en: klass.random_id = uuid.uuid4()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: klass.random_id = uuid.uuid4()
- en: return klass
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: return klass
- en: '@set_class_name_and_id'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '@set_class_name_and_id'
- en: 'class SomeClass(object):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SomeClass(object):'
- en: pass
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'When the class is loaded and defined, it will set the name and random_id attributes,
    like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被加载和定义时，它将像下面这样设置名称和 random_id 属性：
- en: '>>> SomeClass.name'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> SomeClass.name'
- en: '"<class ''__main__.SomeClass''>"'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '"<class ''__main__.SomeClass''>"'
- en: '>>> SomeClass.random_id'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> SomeClass.random_id'
- en: UUID('d244dc42-f0ca-451c-9670-732dc32417cd')
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: UUID('d244dc42-f0ca-451c-9670-732dc32417cd')
- en: As with function decorators, this can be handy for factorizing common code that
    manipulates classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数装饰器类似，类装饰器对于提取操作类的公共代码非常有用。
- en: 'Another possible use for class decorators is to wrap a function or class with
    classes. For example, class decorators are often used for wrapping a function
    that’s storing a state. The following example wraps the print() function to check
    how many times it has been called in a session:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器的另一种可能用途是将函数或类与类进行封装。例如，类装饰器通常用于封装一个存储状态的函数。以下示例封装了 print() 函数，以检查它在一个会话中被调用了多少次：
- en: 'class CountCalls(object):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'class CountCalls(object):'
- en: 'def __init__(self, f):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, f):'
- en: self.f = f
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: self.f = f
- en: 'self.called = 0 def __call__(self, *args, **kwargs):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.called = 0 def __call__(self, *args, **kwargs):'
- en: self.called += 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: self.called += 1
- en: return self.f(*args, **kwargs)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: return self.f(*args, **kwargs)
- en: '@CountCalls'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '@CountCalls'
- en: 'def print_hello():'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'def print_hello():'
- en: print("hello")
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: print("hello")
- en: 'We can then use this to check how many times the function print_hello() has
    been called:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用它来检查函数 print_hello() 被调用了多少次：
- en: '>>> print_hello.called'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print_hello.called'
- en: '0'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> print_hello()'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print_hello()'
- en: hello
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: hello
- en: '>>> print_hello.called'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print_hello.called'
- en: '1'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '**Retrieving Original Attributes with the update_wrapper Decorator**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 update_wrapper 装饰器获取原始属性**'
- en: As mentioned, a decorator replaces the original function with a new one built
    on the fly. However, this new function lacks many of the attributes of the original
    function, such as its docstring and its name. [Listing 7-4](ch07.xhtml#ch7list4)
    shows how the function foobar() loses its docstring and its name attribute once
    it is decorated with the is_admin decorator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，装饰器将原始函数替换为一个新的即时生成的函数。然而，这个新函数缺少原始函数的许多属性，如其文档字符串和名称。[列表 7-4](ch07.xhtml#ch7list4)
    显示了函数 foobar() 被 is_admin 装饰器装饰后，如何丧失其文档字符串和名称属性。
- en: '>>> def is_admin(f):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def is_admin(f):'
- en: '...     def wrapper(*args, **kwargs):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '...     def wrapper(*args, **kwargs):'
- en: '...         if kwargs.get(''username'') != ''admin'':'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '...         if kwargs.get(''username'') != ''admin'':'
- en: '...             raise Exception("This user is not allowed to get food")'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '...             raise Exception("该用户没有权限获取食物")'
- en: '...         return f(*args, **kwargs)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return f(*args, **kwargs)'
- en: '...     return wrapper'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '...     return wrapper'
- en: '...'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> def foobar(username="someone"):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def foobar(username="someone"):'
- en: '...     """Do crazy stuff."""'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """做疯狂的事情。"""'
- en: '...     pass'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '...     pass'
- en: '...'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> foobar.func_doc'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar.func_doc'
- en: '''Do crazy stuff.'''
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '''做疯狂的事情。'''
- en: '>>> foobar.__name__'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar.__name__'
- en: '''foobar'''
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '''foobar'''
- en: '>>> @is_admin'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> @is_admin'
- en: '... def foobar(username="someone"):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '... def foobar(username="someone"):'
- en: '...     """Do crazy stuff."""'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """做疯狂的事情。"""'
- en: '...     pass'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '...     pass'
- en: '...'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> foobar.__doc__'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar.__doc__'
- en: '>>> foobar.__name__'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar.__name__'
- en: '''wrapper'''
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '''wrapper'''
- en: '*Listing 7-4: A decorated function loses its docstring and name attributes.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-4: 一个被装饰的函数失去了它的文档字符串和名称属性。*'
- en: Not having the correct docstring and name attribute for a function can be problematic
    in various situations, such as when generating the source code documentation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数没有正确的文档字符串和名称属性，在生成源代码文档等各种情况下可能会造成问题。
- en: Fortunately, the functools module in the Python Standard Library solves this
    problem with the update_wrapper() function, which copies the attributes from the
    original function that were lost to the wrapper itself. The source code of update_wrapper()
    is shown in [Listing 7-5](ch07.xhtml#ch7list5).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 标准库中的 functools 模块通过 update_wrapper() 函数解决了这个问题，该函数将从原始函数中丢失的属性复制到包装器本身。update_wrapper()
    的源代码显示在 [Listing 7-5](ch07.xhtml#ch7list5) 中。
- en: WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',
- en: '''__annotations__'')'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '''__annotations__'')'
- en: WRAPPER_UPDATES = ('__dict__',)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: WRAPPER_UPDATES = ('__dict__',)
- en: def update_wrapper(wrapper,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: def update_wrapper(wrapper,
- en: wrapped,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: wrapped,
- en: assigned = WRAPPER_ASSIGNMENTS,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: assigned = WRAPPER_ASSIGNMENTS,
- en: 'updated = WRAPPER_UPDATES):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'updated = WRAPPER_UPDATES):'
- en: 'for attr in assigned:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'for attr in assigned:'
- en: 'try:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: value = getattr(wrapped, attr)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: value = getattr(wrapped, attr)
- en: 'except AttributeError:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'except AttributeError:'
- en: pass
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'else:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: setattr(wrapper, attr, value)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: setattr(wrapper, attr, value)
- en: 'for attr in updated:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'for attr in updated:'
- en: getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
- en: '# Issue #17482: set __wrapped__ last so we don''t inadvertently copy it'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '# 问题 #17482：最后设置 __wrapped__，以避免不小心复制它'
- en: '# from the wrapped function when updating __dict__'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在更新 __dict__ 时来自包装函数'
- en: wrapper.__wrapped__ = wrapped
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: wrapper.__wrapped__ = wrapped
- en: '# Return the wrapper so this can be used as a decorator via partial()'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回包装器，以便可以通过 partial() 用作装饰器'
- en: return wrapper
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: return wrapper
- en: '*Listing 7-5: The update_wrapper() source code*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-5: update_wrapper() 源代码*'
- en: 'In [Listing 7-5](ch07.xhtml#ch7list5), the update_wrapper() source code highlights
    which attributes are worth saving when wrapping a function with a decorator. By
    default, the __name__ attribute, __doc__ attribute, and some other attributes
    are copied. You can also personalize which attributes of a function are copied
    to the decorated function. When we use update_wrapper() to rewrite our example
    from [Listing 7-4](ch07.xhtml#ch7list4), things are much nicer:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 7-5](ch07.xhtml#ch7list5) 中，update_wrapper() 源代码突出了包装函数时值得保存的属性。默认情况下，__name__
    属性、__doc__ 属性以及一些其他属性会被复制。你还可以个性化哪些函数的属性会被复制到装饰函数中。当我们使用 update_wrapper() 重写我们在
    [Listing 7-4](ch07.xhtml#ch7list4) 中的示例时，效果要好得多：
- en: '>>> def foobar(username="someone"):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def foobar(username="someone"):'
- en: '...     """Do crazy stuff."""'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """做疯狂的事情。"""'
- en: '...     pass'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '...     pass'
- en: '...'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> foobar = functools.update_wrapper(is_admin, foobar)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar = functools.update_wrapper(is_admin, foobar)'
- en: '>>> foobar.__name__'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar.__name__'
- en: '''foobar'''
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '''foobar'''
- en: '>>> foobar.__doc__'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> foobar.__doc__'
- en: '''Do crazy stuff.'''
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '''做疯狂的事情。'''
- en: Now the foobar() function has the correct name and docstring even when decorated
    by is_admin.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，foobar() 函数即使被 is_admin 装饰，也具有正确的名称和文档字符串。
- en: '**wraps: A Decorator for Decorators**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**wraps：装饰器的装饰器**'
- en: It can get tedious to use update_wrapper() manually when creating decorators,
    so functools provides a decorator for decorators called wraps. [Listing 7-6](ch07.xhtml#ch7list6)
    shows the wraps decorator in use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 update_wrapper() 手动创建装饰器时可能会变得繁琐，因此 functools 提供了一个装饰器装饰器，叫做 wraps。[Listing
    7-6](ch07.xhtml#ch7list6) 展示了 wraps 装饰器的使用。
- en: import functools
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: import functools
- en: 'def check_is_admin(f):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'def check_is_admin(f):'
- en: '@functools.wraps(f)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '@functools.wraps(f)'
- en: 'def wrapper(*args, **kwargs):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'def wrapper(*args, **kwargs):'
- en: 'if kwargs.get(''username'') != ''admin'':'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'if kwargs.get(''username'') != ''admin'':'
- en: raise Exception("This user is not allowed to get food")
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: raise Exception("该用户没有权限获取食物")
- en: return f(*args, **kwargs)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: return f(*args, **kwargs)
- en: return wrapper
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: return wrapper
- en: 'class Store(object):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Store(object):'
- en: '@check_is_admin'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '@check_is_admin'
- en: 'def get_food(self, username, food):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(self, username, food):'
- en: '"""Get food from storage."""'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从存储中获取食物。"""'
- en: return self.storage.get(food)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `self.storage.get(food)`
- en: '*Listing 7-6: Updating our decorator with wraps from functools*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：使用 functools 中的 wraps 更新我们的装饰器*'
- en: With functools.wrap, the decorator function check_is_admin() that returns the
    wrapper() function takes care of copying the docstring, name function, and other
    information from the function f passed as argument. Thus, the decorated function
    (get_food(), in this case) still sees its unchanged signature.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 functools.wrap，返回 `wrapper()` 函数的装饰器函数 `check_is_admin()` 会负责复制传入的函数 `f`
    的文档字符串、函数名和其他信息。因此，被装饰的函数（在这个例子中是 `get_food()`）仍然保留其未改变的签名。
- en: '**Extracting Relevant Information with inspect**'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 inspect 提取相关信息**'
- en: In our examples so far, we have assumed that the decorated function will always
    have a username passed to it as a keyword argument, but that might not be the
    case. It might instead have a bunch of information from which we need to extract
    the username to check. With this in mind, we’ll build a smarter version of our
    decorator that can look at the decorated function’s arguments and pull out what
    it needs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的示例中，我们假设被装饰的函数会总是作为关键字参数传入一个 `username`，但实际情况可能并非如此。它可能会传入一堆信息，我们需要从中提取出
    `username` 进行检查。考虑到这一点，我们将构建一个更智能的装饰器版本，它可以查看被装饰函数的参数并提取所需的信息。
- en: For this, Python has the inspect module, which allows us to retrieve a function’s
    signature and operate on it, as shown in [Listing 7-7](ch07.xhtml#ch7list7).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Python 有一个 inspect 模块，它允许我们检索一个函数的签名并对其进行操作，如 [列表 7-7](ch07.xhtml#ch7list7)
    所示。
- en: import functools
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 functools
- en: import inspect
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 inspect
- en: 'def check_is_admin(f):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'def check_is_admin(f):'
- en: '@functools.wraps(f)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '@functools.wraps(f)'
- en: 'def wrapper(*args, **kwargs):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'def wrapper(*args, **kwargs):'
- en: func_args = inspect.getcallargs(f, *args, **kwargs)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: func_args = inspect.getcallargs(f, *args, **kwargs)
- en: 'if func_args.get(''username'') != ''admin'':'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `func_args.get('username')` 不等于 'admin'：
- en: raise Exception("This user is not allowed to get food")
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常("该用户没有权限获取食物")
- en: return f(*args, **kwargs)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 f(*args, **kwargs)
- en: return wrapper @check_is_admin
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 wrapper @check_is_admin
- en: 'def get_food(username, type=''chocolate''):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_food(username, type=''chocolate''):'
- en: return type + " nom nom nom!"
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型 + " nom nom nom!"
- en: '*Listing 7-7: Using tools from the inspect module to extract information*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：使用 inspect 模块中的工具提取信息*'
- en: 'The function that does the heavy lifting here is inspect.getcallargs(), which
    returns a dictionary containing the names and values of the arguments as key-value
    pairs. In our example, this function returns {''username'': ''admin'',''type'':
    ''chocolate''}. That means that our decorator does not have to check whether the
    username parameter is a positional or a keyword argument; all the decorator has
    to do is look for username in the dictionary.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '这里负责主要工作的函数是 `inspect.getcallargs()`，它返回一个字典，其中包含参数的名称和值作为键值对。在我们的示例中，这个函数返回
    `{''username'': ''admin'', ''type'': ''chocolate''}`。这意味着我们的装饰器不需要检查 `username`
    参数是位置参数还是关键字参数；装饰器只需要在字典中查找 `username`。'
- en: 'Using functools.wraps and the inspect module, you should be able to write any
    custom decorator that you would ever need. However, do not abuse the inspect module:
    while being able to guess what the function will accept as an argument sounds
    handy, this capability can be fragile, breaking easily when function signatures
    change. Decorators are a terrific way to implement the *Don’t Repeat Yourself*
    mantra so cherished by developers.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 functools.wraps 和 inspect 模块，你应该能够编写任何你所需要的自定义装饰器。然而，千万不要滥用 inspect 模块：尽管能够猜测函数将接受什么参数听起来很方便，但这种能力可能会变得脆弱，当函数签名发生变化时，可能会轻易破坏。装饰器是实现
    *不要重复自己（Don’t Repeat Yourself）* 这一开发者理念的绝佳方式。
- en: '**How Methods Work in Python**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Python 中的方法是如何工作的**'
- en: Methods are pretty simple to use and understand, and you’ve likely just used
    them correctly without delving in much deeper than you needed to. But to understand
    what certain decorators do, you need to know how methods work behind the scenes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 方法使用起来相当简单，你可能已经在不深入了解的情况下正确使用过它们。但要理解某些装饰器的作用，你需要了解方法在幕后是如何工作的。
- en: 'A *method* is a function that is stored as a class attribute. Let’s have a
    look at what happens when we try to access such an attribute directly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 是一个作为类属性存储的函数。让我们看看当我们直接访问这样的属性时会发生什么：'
- en: '>>> class Pizza(object):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> class Pizza(object):'
- en: '...     def __init__(self, size):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '...     def __init__(self, size):'
- en: '...         self.size = size'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '...         self.size = size'
- en: '...     def get_size(self):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '...     def get_size(self):'
- en: '...         return self.size'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '...         返回 self.size'
- en: '...'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> Pizza.get_size'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza.get_size'
- en: <function Pizza.get_size at 0x7fdbfd1a8b90>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <function Pizza.get_size at 0x7fdbfd1a8b90>
- en: 'We are told that get_size() is a function—but why is that? The reason is that
    at this stage, get_size() is not tied to any particular object. Therefore, it
    is treated as a normal function. Python will raise an error if we try to call
    it directly, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知 get_size() 是一个函数——但为什么会是这样呢？原因在于此时，get_size() 并没有绑定到任何特定的对象上。因此，它被当作普通函数对待。如果我们试图直接调用它，Python
    会抛出错误，像这样：
- en: '>>> Pizza.get_size()'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza.get_size()'
- en: 'Traceback (most recent call last):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'TypeError: get_size() missing 1 required positional argument: ''self'''
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: get_size() 缺少 1 个必需的位置参数：''self'''
- en: 'Python complains that we have not provided the necessary self argument. Indeed,
    as it is not bound to any object, the self argument cannot be set automatically.
    However, we are able to use the get_size() function not only by passing an arbitrary
    instance of the class to the method if we want to but also by passing *any* object,
    as long as it has the properties that the method expects to find. Here’s an example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Python 报告我们没有提供必要的 self 参数。确实，由于它没有绑定到任何对象，self 参数无法自动设置。然而，我们能够使用 get_size()
    函数，不仅可以传递类的任意实例给方法，如果需要的话，还可以传递 *任何* 对象，只要它具备该方法期望找到的属性。下面是一个例子：
- en: '>>> Pizza.get_size(Pizza(42))'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza.get_size(Pizza(42))'
- en: '42'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: 'This call works, just as promised. It is, however, not very convenient: we
    have to refer to the class every time we want to call one of its methods.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用成功了，正如承诺的那样。然而，它并不是特别方便：每次我们想调用某个方法时，都必须引用类。
- en: 'So Python goes the extra mile for us by binding a class’s methods to its instances.
    In other words, we can access get_size() from any Pizza instance, and, better
    still, Python will automatically pass the object itself to the method’s self parameter,
    like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 Python 为我们额外做了一步，将类的方法绑定到它的实例上。换句话说，我们可以从任何 Pizza 实例访问 get_size()，而且更好的是，Python
    会自动将对象本身传递给方法的 self 参数，像这样：
- en: '>>> Pizza(42).get_size'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza(42).get_size'
- en: <bound method Pizza.get_size of <__main__.Pizza object at 0x7f3138827910>>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <bound method Pizza.get_size of <__main__.Pizza object at 0x7f3138827910>>
- en: '>>> Pizza(42).get_size()'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza(42).get_size()'
- en: '42'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: 'As expected, we do not have to provide any argument to get_size(), since it’s
    a bound method: its self argument is automatically set to our Pizza instance.
    Here is an even clearer example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们不需要为 get_size() 提供任何参数，因为它是一个绑定方法：它的 self 参数会自动设置为我们的 Pizza 实例。这里有一个更清晰的例子：
- en: '>>> m = Pizza(42).get_size'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m = Pizza(42).get_size'
- en: '>>> m()'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m()'
- en: '42'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: 'As long as you have a reference to the bound method, you do not even have to
    keep a reference to your Pizza object. Moreover, if you have a reference to a
    method but you want to find out which object it is bound to, you can just check
    the method’s __self__ property, like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你有绑定方法的引用，你甚至不需要保存对 Pizza 对象的引用。此外，如果你有一个方法的引用，但你想知道它绑定的是哪个对象，你可以直接检查该方法的
    __self__ 属性，像这样：
- en: '>>> m = Pizza(42).get_size'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m = Pizza(42).get_size'
- en: '>>> m.__self__'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.__self__'
- en: <__main__.Pizza object at 0x7f3138827910>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.Pizza object at 0x7f3138827910>
- en: '>>> m == m.__self__.get_size'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m == m.__self__.get_size'
- en: 'True'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: Obviously, we still have a reference to our object, and we can find it if we
    want.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们仍然可以访问到我们的对象引用，如果需要的话，我们可以找到它。
- en: '**Static Methods**'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**静态方法**'
- en: '*Static methods* belong to a class, rather than an instance of a class, so
    they don’t actually operate on or affect class instances. Instead, a static method
    operates on the parameters it takes. Static methods are generally used to create
    utility functions, because they do not depend on the state of the class or its
    objects.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法* 属于类，而不是类的实例，因此它们实际上并不操作或影响类的实例。相反，静态方法作用于它所接受的参数。静态方法通常用于创建工具函数，因为它们不依赖于类或对象的状态。'
- en: For example, in [Listing 7-8](ch07.xhtml#ch7list8), the static mix_ingredients()
    method belongs to the Pizza class but could actually be used to mix ingredients
    for any other food.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 [Listing 7-8](ch07.xhtml#ch7list8) 中，静态方法 mix_ingredients() 属于 Pizza 类，但实际上它可以用于混合任何其他食物的食材。
- en: 'class Pizza(object):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Pizza(object):'
- en: '@staticmethod'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '@staticmethod'
- en: 'def mix_ingredients(x, y):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'def mix_ingredients(x, y):'
- en: return x + y
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: return x + y
- en: 'def cook(self):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cook(self):'
- en: return self.mix_ingredients(self.cheese, self.vegetables)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: return self.mix_ingredients(self.cheese, self.vegetables)
- en: '*Listing 7-8: Creating a static method as part of a class*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-8: 作为类一部分创建静态方法*'
- en: You could write mix_ingredients() as a non-static method if you wanted to, but
    it would take a self argument that would never actually be used. Using the @staticmethod
    decorator gives us several things.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以将 mix_ingredients() 写成一个非静态方法，但它会需要一个 self 参数，而这个参数实际上永远不会被使用。使用 @staticmethod
    装饰器为我们带来了几个好处。
- en: 'The first is speed: Python does not have to instantiate a bound method for
    each Pizza object we create. Bound methods are objects, too, and creating them
    has a CPU and memory cost—even if it’s low. Using a static method lets us avoid
    that, like so:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个好处是速度：Python 不需要为我们创建的每一个 Pizza 对象实例化一个绑定方法。绑定方法本身也是对象，创建它们会消耗 CPU 和内存资源——尽管这个开销很小。使用静态方法可以避免这种开销，像这样：
- en: '>>> Pizza().cook is Pizza().cook'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza().cook 是 Pizza().cook'
- en: 'False'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> Pizza().mix_ingredients is Pizza.mix_ingredients'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza().mix_ingredients 是 Pizza.mix_ingredients'
- en: 'True'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> Pizza().mix_ingredients is Pizza().mix_ingredients'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza().mix_ingredients 是 Pizza().mix_ingredients'
- en: 'True'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: Second, static methods improve the readability of the code. When we see @staticmethod,
    we know that the method does not depend on the state of the object.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，静态方法提高了代码的可读性。当我们看到 @staticmethod 时，我们知道该方法不依赖于对象的状态。
- en: Third, static methods can be overridden in subclasses. If instead of a static
    method, we used a mix_ingredients() function defined at the top level of our module,
    a class inheriting from Pizza wouldn’t be able to change the way we mix ingredients
    for our pizza without overriding the cook() method itself. With static methods,
    the subclasses can override the method for their own purposes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，静态方法可以在子类中被重写。如果我们不是使用静态方法，而是使用在模块顶层定义的 mix_ingredients() 函数，那么继承自 Pizza
    的类就无法在不重写 cook() 方法的情况下改变我们混合比萨配料的方式。使用静态方法后，子类可以根据自己的需求重写该方法。
- en: Unfortunately, Python is not always able to detect for itself whether a method
    is static or not—I call that a defect of the language design. One possible approach
    is to add a check that detects such pattern and emits a warning using flake8.
    We will look into how to do this in “Extending flake8 with AST Checks” on [page
    140](ch09.xhtml#page_140).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 并不总是能够自动检测一个方法是否是静态方法——我认为这是语言设计上的一个缺陷。一种可能的做法是添加一个检查，检测到这种模式时通过
    flake8 发出警告。我们将在《扩展 flake8 与 AST 检查》一节中探讨如何做到这一点，详见 [第 140 页](ch09.xhtml#page_140)。
- en: '**Class Methods**'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类方法**'
- en: '*Class methods* are bound to a class rather than its instances. That means
    that those methods cannot access the state of the object but only the state and
    methods of the class. [Listing 7-9](ch07.xhtml#ch7list9) shows how to write a
    class method.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*类方法* 是绑定到类而不是其实例的。这意味着这些方法无法访问对象的状态，只能访问类的状态和方法。[清单 7-9](ch07.xhtml#ch7list9)展示了如何编写类方法。'
- en: '>>> class Pizza(object):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> class Pizza(object):'
- en: '...     radius = 42'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '...     radius = 42'
- en: '...     @classmethod'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '...     @classmethod'
- en: '...     def get_radius(cls):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '...     def get_radius(cls):'
- en: '...         return cls.radius'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return cls.radius'
- en: '...'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> Pizza.get_radius'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza.get_radius'
- en: <bound method type.get_radius of <class '__main__.Pizza'>>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <bound method type.get_radius of <class '__main__.Pizza'>>
- en: '>>> Pizza().get_radius'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza().get_radius'
- en: <bound method type.get_radius of <class '__main__.Pizza'>>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <bound method type.get_radius of <class '__main__.Pizza'>>
- en: '>>> Pizza.get_radius is Pizza().get_radius'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza.get_radius 是 Pizza().get_radius'
- en: 'True'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> Pizza.get_radius()'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza.get_radius()'
- en: '42'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: '*Listing 7-9: Binding a class method to its class*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-9：将类方法绑定到类*'
- en: 'As you can see, there are various ways to access the get_radius() class method,
    but however you choose to access it, the method is always bound to the class it
    is attached to. Also, its first argument must be the class itself. Remember: classes
    are objects too!'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有多种方式可以访问 get_radius() 类方法，但无论你选择哪种方式，方法总是与它所附加的类绑定在一起。而且，它的第一个参数必须是类本身。记住：类也是对象！
- en: 'Class methods are principally useful for creating *factory methods*, which
    instantiate objects using a different signature than __init__:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法主要用于创建 *工厂方法*，这些方法使用不同于 __init__ 的签名来实例化对象：
- en: 'class Pizza(object):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Pizza(object):'
- en: 'def __init__(self, ingredients):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, ingredients):'
- en: self.ingredients = ingredients
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: self.ingredients = ingredients
- en: '@classmethod'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '@classmethod'
- en: 'def from_fridge(cls, fridge):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'def from_fridge(cls, fridge):'
- en: return cls(fridge.get_cheese() + fridge.get_vegetables())
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: return cls(fridge.get_cheese() + fridge.get_vegetables())
- en: If we used a @staticmethod here instead of a @classmethod, we would have to
    hardcode the Pizza class name in our method, making any class inheriting from
    Pizza unable to use our factory for its own purposes. In this case, however, we
    provide a from_fridge() factory method that we can pass a Fridge object to. If
    we call this method with something like Pizza.from_fridge(myfridge), it returns
    a brand-new Pizza with ingredients taken from what’s available in myfridge.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里使用@staticmethod而不是@classmethod，我们将不得不在方法中硬编码Pizza类的名称，这样任何继承自Pizza的类都无法使用我们的工厂方法。在这种情况下，我们提供了一个from_fridge()工厂方法，允许我们传入一个Fridge对象。如果我们像这样调用该方法Pizza.from_fridge(myfridge)，它会返回一个全新的Pizza，使用myfridge中可用的食材。
- en: Any time you write a method that cares only about the class of the object and
    not about the object’s state, it should be declared as a class method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你编写一个仅关心对象类而不关心对象状态的方法时，它应该被声明为类方法。
- en: '**Abstract Methods**'
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**抽象方法**'
- en: An *abstract method* is defined in an abstract base class that may not itself
    provide any implementation. When a class has an abstract method, it cannot be
    instantiated. As a consequence, an *abstract class* (defined as a class that has
    at least one abstract method) must be used as a parent class by another class.
    This subclass will be in charge of implementing the abstract method, making it
    possible to instantiate the parent class.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象方法*定义在抽象基类中，该类本身可能不提供任何实现。当一个类有一个抽象方法时，它不能被实例化。因此，*抽象类*（定义为至少有一个抽象方法的类）必须作为另一个类的父类。这个子类将负责实现抽象方法，从而使得父类能够被实例化。'
- en: 'We can use abstract base classes to make clear the relationships between other,
    connected classes derived from the base class but make the abstract base class
    itself impossible to instantiate. By using abstract base classes, you can ensure
    the classes derived from the base class implement particular methods from the
    base class, or an exception will be raised. The following example shows the simplest
    way to write an abstract method in Python:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用抽象基类明确表示从基类派生的其他相关类之间的关系，但使得抽象基类本身无法被实例化。通过使用抽象基类，你可以确保从基类派生的类实现基类中特定的方法，否则将引发异常。以下示例展示了在Python中编写抽象方法的最简单方法：
- en: 'class Pizza(object):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Pizza(object):'
- en: '@staticmethod'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '@staticmethod'
- en: 'def get_radius():'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_radius():'
- en: raise NotImplementedError
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: With this definition, any class inheriting from Pizza must implement and override
    the get_radius() method; otherwise, calling the method raises the exception shown
    here. This is handy for making sure that each subclass of Pizza implements its
    own way of computing and returning its radius.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，任何继承Pizza的类必须实现并重写get_radius()方法；否则，调用该方法时将引发如这里所示的异常。这对于确保Pizza的每个子类都实现其计算并返回半径的方式非常有用。
- en: 'This way of implementing abstract methods has a drawback: if you write a class
    that inherits from Pizza but forget to implement get_radius(), the error is raised
    only if you try to use that method at runtime. Here’s an example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现抽象方法的方式有一个缺点：如果你编写了一个继承自Pizza的类，但忘记实现get_radius()方法，只有在你尝试在运行时使用该方法时，才会引发错误。以下是一个示例：
- en: '>>> Pizza()'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza()'
- en: <__main__.Pizza object at 0x7fb747353d90>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <__main__.Pizza对象，位于0x7fb747353d90>
- en: '>>> Pizza().get_radius()'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Pizza().get_radius()'
- en: 'Traceback (most recent call last):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 文件“<stdin>”，第1行，位于<module>
- en: File "<stdin>", line 3, in get_radius
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 文件“<stdin>”，第3行，位于get_radius
- en: NotImplementedError
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: NotImplementedError
- en: 'As Pizza is directly instantiable, there’s no way to prevent this from happening.
    One way to make sure you get an early warning about forgetting to implement and
    override the method, or trying to instantiate an object with abstract methods,
    is to use Python’s built-in abc (abstract base classes) module instead, like so:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pizza是可以直接实例化的，因此无法阻止这种情况的发生。为了确保你能提前警告忘记实现和重写方法，或者尝试实例化一个带有抽象方法的对象，可以改用Python的内置abc（抽象基类）模块，像这样：
- en: import abc
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: import abc
- en: 'class BasePizza(object, metaclass=abc.ABCMeta):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BasePizza(object, metaclass=abc.ABCMeta):'
- en: '@abc.abstractmethod'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '@abc.abstractmethod'
- en: 'def get_radius(self):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_radius(self):'
- en: '"""Method that should do something."""'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '"""此方法应执行某个操作。"""'
- en: 'The abc module provides a set of decorators to use on top of methods that will
    be defined as abstracts and a metaclass to enable this. When you use abc and its
    special metaclass, as shown above, instantiating a BasePizza or a class inheriting
    from it that doesn’t override get_radius() causes a TypeError:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: abc 模块提供了一组装饰器，可以用于定义为抽象方法的方法，并提供一个元类来启用这一功能。当你使用 abc 及其特殊元类，如上所示，如果实例化一个 BasePizza
    或其子类而没有重写 `get_radius()`，就会导致 TypeError：
- en: '>>> BasePizza()'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> BasePizza()'
- en: 'Traceback (most recent call last):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'TypeError: Can''t instantiate abstract class BasePizza with abstract methods'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 无法实例化具有抽象方法的抽象类 BasePizza'
- en: get_radius
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: get_radius
- en: We try to instantiate the abstract BasePizza class and are immediately told
    it can’t be done!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试实例化抽象的 BasePizza 类，立即被告知无法完成此操作！
- en: While using abstract methods doesn’t guarantee that the method is implemented
    by the user, this decorator helps you catch the error earlier. This is especially
    handy when you are providing interfaces that must be implemented by other developers;
    it’s a good documentation hint.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用抽象方法不能保证用户实现该方法，但这个装饰器帮助你更早地捕获错误。特别是在你提供必须由其他开发者实现的接口时，这是一种很好的文档提示。
- en: '**Mixing Static, Class, and Abstract Methods**'
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**混合静态方法、类方法和抽象方法**'
- en: Each of these decorators is useful on its own, but the time may come when you’ll
    have to use them together.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器各自独立有用，但有时你可能需要将它们结合使用。
- en: For example, you could define a factory method as a class method while forcing
    the implementation to be made in a subclass. In that case, you’d need to have
    a class method defined as both an abstract method and a class method. This section
    gives some tips that will help you with that.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将工厂方法定义为类方法，同时强制要求在子类中实现。在这种情况下，你需要将类方法同时定义为抽象方法和类方法。本节提供了一些帮助你实现这一点的提示。
- en: First, an abstract method’s prototype is not set in stone. When you implement
    the method, there is nothing stopping you from extending the argument list as
    you see fit. [Listing 7-10](ch07.xhtml#ch7list10) is an example of code in which
    a subclass extends the signature of the abstract method of its parent.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，抽象方法的原型并非固定不变。当你实现该方法时，没有什么能阻止你根据需要扩展参数列表。[清单 7-10](ch07.xhtml#ch7list10)
    就是一个例子，展示了子类如何扩展其父类抽象方法的签名。
- en: import abc
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: import abc
- en: 'class BasePizza(object, metaclass=abc.ABCMeta):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BasePizza(object, metaclass=abc.ABCMeta):'
- en: '@abc.abstractmethod'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '@abc.abstractmethod'
- en: 'def get_ingredients(self):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients(self):'
- en: '"""Returns the ingredient list."""'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回配料列表。"""'
- en: 'class Calzone(BasePizza):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Calzone(BasePizza):'
- en: 'def get_ingredients(self, with_egg=False):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients(self, with_egg=False):'
- en: egg = Egg() if with_egg else None
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: egg = Egg() if with_egg else None
- en: return self.ingredients + [egg]
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: return self.ingredients + [egg]
- en: '*Listing 7-10: Using a subclass to extend the signature of the abstract method
    of its parent*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：使用子类扩展其父类的抽象方法签名*'
- en: 'We define the Calzone subclass to inherit from the BasePizza class. We can
    define the Calzone subclass’s methods any way we like, as long as they support
    the interface we define in BasePizza. This includes implementing the methods as
    either class or static methods. The following code defines an abstract get_ingredients()
    method in the base class and a static get_ingredients() method in the DietPizza
    subclass:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 Calzone 子类继承自 BasePizza 类。我们可以按任何方式定义 Calzone 子类的方法，只要它们支持我们在 BasePizza
    中定义的接口。这包括将方法实现为类方法或静态方法。以下代码定义了一个抽象的 `get_ingredients()` 方法在基类中，并在 DietPizza
    子类中定义了一个静态 `get_ingredients()` 方法：
- en: import abc
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: import abc
- en: 'class BasePizza(object, metaclass=abc.ABCMeta):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BasePizza(object, metaclass=abc.ABCMeta):'
- en: '@abc.abstractmethod'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '@abc.abstractmethod'
- en: 'def get_ingredients(self):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients(self):'
- en: '"""Returns the ingredient list."""'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回配料列表。"""'
- en: 'class DietPizza(BasePizza):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'class DietPizza(BasePizza):'
- en: '@staticmethod'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '@staticmethod'
- en: 'def get_ingredients():'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients():'
- en: return None
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: return None
- en: Even though our static get_ingredients() method doesn’t return a result based
    on the object’s state, it supports our abstract BasePizza class’s interface, so
    it’s still valid.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的静态 `get_ingredients()` 方法并没有基于对象的状态返回结果，但它支持我们抽象的 BasePizza 类接口，因此它仍然有效。
- en: It is also possible to use the @staticmethod and @classmethod decorators on
    top of @abstractmethod in order to indicate that a method is, for example, both
    static and abstract, as shown in [Listing 7-11](ch07.xhtml#ch7list11).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在@abstractmethod之上使用@staticmethod和@classmethod装饰器，表示一个方法是静态方法且是抽象的，正如在[示例7-11](ch07.xhtml#ch7list11)中展示的那样。
- en: import abc
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: import abc
- en: 'class BasePizza(object, metaclass=abc.ABCMeta):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BasePizza(object, metaclass=abc.ABCMeta):'
- en: ingredients = ['cheese']
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ingredients = ['cheese']
- en: '@classmethod'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '@classmethod'
- en: '@abc.abstractmethod'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '@abc.abstractmethod'
- en: 'def get_ingredients(cls):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients(cls):'
- en: '"""Returns the ingredient list."""'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回食材列表。"""'
- en: return cls.ingredients
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: return cls.ingredients
- en: '*Listing 7-11: Using a class method decorator with abstract methods*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-11：将类方法装饰器与抽象方法一起使用*'
- en: The abstract method get_ingredients() needs to be implemented by a subclass,
    but it’s also a class method, meaning the first argument it will receive will
    be a class (not an object).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法get_ingredients()需要在子类中实现，但它也是一个类方法，这意味着它接收的第一个参数将是一个类（而不是一个对象）。
- en: 'Note that by defining get_ingredients() as a class method in BasePizza like
    this, you are not forcing any subclasses to define get_ingredients() as a class
    method—it could be a regular method. The same would apply if we had defined it
    as a static method: there’s no way to force subclasses to implement abstract methods
    as a specific kind of method. As we have seen, you can change the signature of
    an abstract method when implementing it in a subclass in any way you like.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过像这样在BasePizza中将get_ingredients()定义为类方法，你并没有强制任何子类必须将get_ingredients()定义为类方法——它也可以是一个普通方法。如果我们将其定义为静态方法，也是一样的：没有办法强制子类将抽象方法实现为特定类型的方法。正如我们所看到的，你可以在子类中以任何你喜欢的方式改变抽象方法的签名。
- en: '***Putting Implementations in Abstract Methods***'
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在抽象方法中放置实现***'
- en: 'Hold the phone: in [Listing 7-12](ch07.xhtml#ch7list12), we have an implementation
    *in* an abstract method. Can we *do* that? The answer is yes. Python does not
    have a problem with it! You can put code in your abstract methods and call it
    using super(), as demonstrated in [Listing 7-12](ch07.xhtml#ch7list12).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下：在[示例7-12](ch07.xhtml#ch7list12)中，我们在一个抽象方法中实现了代码。我们能*这样做*吗？答案是可以的。Python对此没有问题！你可以在抽象方法中放置代码，并通过super()调用它，正如在[示例7-12](ch07.xhtml#ch7list12)中展示的那样。
- en: import abc
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: import abc
- en: 'class BasePizza(object, metaclass=abc.ABCMeta):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BasePizza(object, metaclass=abc.ABCMeta):'
- en: default_ingredients = ['cheese']
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: default_ingredients = ['cheese']
- en: '@classmethod'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '@classmethod'
- en: '@abc.abstractmethod'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '@abc.abstractmethod'
- en: 'def get_ingredients(cls):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients(cls):'
- en: '"""Returns the default ingredient list."""'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回默认食材列表。"""'
- en: return cls.default_ingredients
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: return cls.default_ingredients
- en: 'class DietPizza(BasePizza):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'class DietPizza(BasePizza):'
- en: 'def get_ingredients(self):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_ingredients(self):'
- en: return [Egg()] + super(DietPizza, self).get_ingredients()
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: return [Egg()] + super(DietPizza, self).get_ingredients()
- en: '*Listing 7-12: Using an implementation in an abstract method*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-12：在抽象方法中使用实现*'
- en: In this example, every Pizza you make that inherits from BasePizza has to override
    the get_ingredients() method, but every Pizza also has access to the base class’s
    default mechanism for getting the ingredients list. This mechanism is especially
    useful when providing an interface to implement while also providing base code
    that might be useful to all inheriting classes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，继承自BasePizza的每个Pizza都必须重写get_ingredients()方法，但每个Pizza也可以访问基类的获取食材列表的默认机制。这个机制在提供接口的同时，也提供了可能对所有继承类都有用的基础代码。
- en: '***The Truth About super***'
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关于super的真相***'
- en: Python has always allowed developers to use both single and multiple inheritances
    to extend their classes, but even today, many developers do not seem to understand
    how these mechanisms, and the super() method that is associated with them, work.
    To fully understand your code, you need to understand the trade-offs.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Python一直允许开发者使用单继承和多继承来扩展他们的类，但即使到今天，许多开发者似乎并不理解这些机制，以及与之相关的super()方法是如何工作的。要完全理解你的代码，你需要理解这些权衡。
- en: Multiple inheritances are used in many places, particularly in code involving
    a mixin pattern. A *mixin* is a class that inherits from two or more other classes,
    combining their features.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承在许多地方都有使用，特别是在涉及mixin模式的代码中。*mixin*是一种从两个或更多类继承的类，它将这些类的特性结合在一起。
- en: '**NOTE**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many of the pros and cons of single and multiple inheritances, composition,
    or even duck typing are out of scope for this book, so we won’t cover everything
    here. If you are not familiar with these notions, I suggest you read about them
    to form your own opinions.*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'As you should know by now, classes are objects in Python. The construct used
    to create a class is a special statement that you should be well familiar with:
    class classname(expression of inheritance).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in parentheses is a Python expression that returns the list of class
    objects to be used as the class’s parents. Ordinarily, you would specify them
    directly, but you could also write something like this to specify the list of
    parent objects:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '>>> def parent():'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '...     return object'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '>>> class A(parent()):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '...     pass'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '>>> A.mro()'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[<class ''__main__.A''>, <type ''object''>]'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works as expected: we declare class A with object as its parent class.
    The class method mro() returns the *method resolution order* used to resolve attributes—it
    defines how the next method to call is found via the tree of inheritance between
    classes. The current MRO system was first implemented in Python 2.3, and its internal
    workings are described in the Python 2.3 release notes. It defines how the system
    browses the tree of inheritance between classes to find the method to call.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw that the canonical way to call a method in a parent class is
    to use the super() function, but what you probably don’t know is that super()
    is actually a constructor and you instantiate a super object each time you call
    it. It takes either one or two arguments: the first argument is a class, and the
    second, optional argument is either a subclass or an instance of the first argument.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The object returned by the constructor functions as a proxy for the parent classes
    of the first argument. It has its own __getattribute__ method that iterates over
    the classes in the MRO list and returns the first matching attribute it finds.
    The __getattribute__ method is called when an attribute of the super() object
    is retrieved, as shown in [Listing 7-13](ch07.xhtml#ch7list13).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '>>> class A(object):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '...     bar = 42'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '...     def foo(self):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '...             pass'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '>>> class B(object):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '...     bar = 0'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '>>> class C(A, B):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '...     xyz = ''abc'''
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '>>> C.mro()'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[<class ''__main__.C''>, <class ''__main__.A''>, <class ''__main__.B''>, <type
    ''object''>]'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(C, C()).bar'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(C, C()).foo'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: <bound method C.foo of <__main__.C object at 0x7f0299255a90>>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(B).__self__ >>> super(B, B()).__self__'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: <__main__.B object at 0x1096717f0>
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-13: The super() function is a constructor that instantiates a super
    object.*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: When requesting an attribute of the super object of an instance of C, the __getattribute__
    method of the super() object walks through the MRO list and returns the attribute
    from the first class it finds that has the super attribute.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 7-13](ch07.xhtml#ch7list13), we called super() with two arguments,
    meaning we used a *bound* super object. If we call super() with only one argument,
    it returns an *unbound* super object instead:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(C)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '<super: <class ''C''>, NULL>'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Since no instance has been provided as the second argument, the super object
    cannot be bound to any instance. Therefore, you cannot use this unbound object
    to access class attributes. If you try, you’ll get the following errors:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(C).foo'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'AttributeError: ''super'' object has no attribute ''foo'''
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(C).bar'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'AttributeError: ''super'' object has no attribute ''bar'''
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '>>> super(C).xyz'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'AttributeError: ''super'' object has no attribute ''xyz'''
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it might seem like this unbound kind of super object is useless,
    but actually the way the super class implements the descriptor protocol __get__
    makes unbound super objects useful as class attributes:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '>>> class D(C):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '...     sup = super(C)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '>>> D().sup'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '<super: <class ''C''>, <D object>>'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '>>> D().sup.foo'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: <bound method D.foo of <__main__.D object at 0x7f0299255bd0>>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '>>> D().sup.bar'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The unbound super object’s __get__ method is called using the instance super(C).__get__(D())
    and the attribute name 'foo' as arguments, allowing it to find and resolve foo.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '*Even if you’ve never heard of the descriptor protocol, it’s likely you’ve
    used it through the @property decorator without knowing it. The descriptor protocol
    is the mechanism in Python that allows an object stored as an attribute to return
    something other than itself. This protocol is not covered in this book, but you
    can find out more about it in the Python data model documentation.*'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of situations in which using super() can be tricky, such as
    when handling different method signatures along the inheritance chain. Unfortunately,
    there’s no silver bullet for all occasions. The best precaution is to use tricks
    such as having all your methods accept their arguments using *args, **kwargs.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3, super() has picked up a bit of magic: it can now be called
    from within a method without any arguments. When no arguments are passed to super(),
    it automatically searches the stack frame for arguments:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'class B(A):'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'def foo(self):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: super().foo()
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: The standard way of accessing parent attributes in subclasses is super(), and
    you should always use it. It allows cooperative calls of parent methods without
    any surprises, such as parent methods not being called or being called twice when
    multiple inheritances are used.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Equipped with what you learned in this chapter, you should be unbeatable on
    everything that concerns methods definition in Python. Decorators are essential
    when it comes to code factorization, and proper use of the built-in decorators
    provided by Python can vastly improve the neatness of your Python code. Abstract
    classes are especially useful when providing an API to other developers and services.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了本章内容后，你应该在任何与 Python 方法定义相关的事情上无往不利。装饰器在代码抽象化方面至关重要，合理使用 Python 提供的内置装饰器可以极大地提升
    Python 代码的整洁度。抽象类在向其他开发者和服务提供 API 时尤为有用。
- en: Class inheritance is not often fully understood, and having an overview of the
    internal machinery of the language is a good way to fully apprehend how this works.
    There should be no secrets left on this topic for you now!
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承往往难以完全理解，了解语言内部机制的概览是全面掌握其工作原理的好方法。现在，这个话题对你来说应该没有任何秘密了！
