- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**METHODS AND DECORATORS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法和装饰器**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Python’s decorators are a handy way to modify functions. Decorators were first
    introduced in Python 2.2, with the `classmethod()` and `staticmethod()` decorators,
    but were overhauled to become more flexible and readable. Along with these two
    original decorators, Python now provides a few right out of the box and supports
    the simple creation of custom decorators. But it seems as though most developers
    do not understand how they work behind the scenes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的装饰器是修改函数的便捷方式。装饰器首次在 Python 2.2 中引入，最初是 `classmethod()` 和 `staticmethod()`
    装饰器，但后来进行了重构，使其更加灵活和易读。除了这两个原始的装饰器，Python 现在提供了一些现成的装饰器，并支持自定义装饰器的简单创建。但似乎大多数开发者并不理解它们背后的工作原理。
- en: This chapter aims to change that—we’ll cover what a decorator is and how to
    use it, as well as how to create your own decorators. Then we’ll look at using
    decorators to create static, class, and abstract methods and take a close look
    at the `super()` function, which allows you to place implementable code inside
    an abstract method.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在改变这一点——我们将讨论什么是装饰器以及如何使用它们，并且还会介绍如何创建自己的装饰器。然后，我们将探讨如何使用装饰器创建静态方法、类方法和抽象方法，并深入了解
    `super()` 函数，它允许你将可实现的代码放入抽象方法中。
- en: '**Decorators and When to Use Them**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**装饰器及其使用时机**'
- en: A *decorator* is a function that takes another function as an argument and replaces
    it with a new, modified function. The primary use case for decorators is in factoring
    common code that needs to be called before, after, or around multiple functions.
    If you’ve ever written Emacs Lisp code, you may have used the `defadvice` decorator,
    which allows you to define code called around a function. If you’ve used method
    combinations in the Common Lisp Object System (CLOS), Python decorators follow
    the same concepts. We’ll look at some simple decorator definitions, and then we’ll
    examine some common situations in which you’d use decorators.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*是一个接受另一个函数作为参数并将其替换为一个新的、修改后的函数的函数。装饰器的主要用法是在需要在多个函数之前、之后或周围调用的公共代码进行提取。如果你曾经编写过
    Emacs Lisp 代码，你可能使用过 `defadvice` 装饰器，它允许你定义在函数周围调用的代码。如果你使用过 Common Lisp 对象系统（CLOS）中的方法组合，Python
    的装饰器遵循相同的概念。我们将查看一些简单的装饰器定义，然后我们将研究一些常见的使用装饰器的场景。'
- en: '***Creating Decorators***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建装饰器***'
- en: 'The odds are good that you’ve already used decorators to make your own wrapper
    functions. The dullest possible decorator, and the simplest example, is the `identity()`
    function, which does nothing except return the original function. Here is its
    definition:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能已经使用过装饰器来创建自己的包装函数。最简单的装饰器，也是最无聊的例子，就是 `identity()` 函数，它除了返回原始函数外什么也不做。以下是它的定义：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You would then use your decorator like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以像这样使用你的装饰器：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You enter the name of the decorator preceded by an `@` symbol and then enter
    the function you want to use it on. This is the same as writing the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你输入装饰器的名称，前面加上 `@` 符号，然后输入你想要使用装饰器的函数。这与以下代码是等效的：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This decorator is useless, but it works. Let’s look at another, more useful
    example in [Listing 7-1](ch07.xhtml#ch7list1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器没有用处，但它能正常工作。我们来看看另一个更有用的例子，参见[清单 7-1](ch07.xhtml#ch7list1)。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-1: A decorator to organize functions in a dictionary*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：用于将函数组织到字典中的装饰器*'
- en: 'In [Listing 7-1](ch07.xhtml#ch7list1), the `register` decorator stores the
    decorated function name into a dictionary. The `_functions` dictionary can then
    be used and accessed using the function name to retrieve a function: `_functions[''foo'']`
    points to the `foo()` function.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 7-1](ch07.xhtml#ch7list1)中，`register` 装饰器将装饰的函数名称存储到字典中。然后，可以使用函数名称访问 `_functions`
    字典来检索函数：`_functions['foo']` 指向 `foo()` 函数。
- en: In the following sections, I will explain how to write your own decorators.
    Then I’ll cover how the built-in decorators provided by Python work and explain
    how (and when) to use them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将解释如何编写自己的装饰器。然后我将介绍 Python 提供的内置装饰器是如何工作的，并解释如何（以及何时）使用它们。
- en: '***Writing Decorators***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写装饰器***'
- en: 'As mentioned, decorators are often used when refactoring repeated code around
    functions. Consider the following set of functions that need to check whether
    the username they receive as an argument is the admin or not and, if the user
    is not an admin, raise an exception:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，装饰器通常用于重构围绕函数的重复代码。考虑以下一组函数，它们需要检查作为参数传入的用户名是否是管理员，如果不是管理员，则引发异常：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see there’s some repeated code here. The obvious first step to making
    this code more efficient is to factor the code that checks for admin status:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有一些重复的代码。使这段代码更高效的明显第一步是提取检查管理员状态的代码：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve moved the checking code into its own function ➊. Now our code looks a
    bit cleaner, but we can do even better if we use a decorator, as shown in [Listing
    7-2](ch07.xhtml#ch7list2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将检查代码移到它自己的函数中➊。现在我们的代码看起来更简洁了，但如果使用装饰器的话，我们可以做得更好，如[列表 7-2](ch07.xhtml#ch7list2)所示。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-2: Adding a decorator to the factored code*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：将装饰器添加到提取的代码中*'
- en: We define our `check_is_admin` decorator ➊ and then call it whenever we need
    to check for access rights. The decorator inspects the arguments passed to the
    function using the `kwargs` variable and retrieves the `username` argument, performing
    the username check before calling the actual function. Using decorators like this
    makes it easier to manage common functionality. To anyone with much Python experience,
    this is probably old hat, but what you might not realize is that this naive approach
    to implementing decorators has some major drawbacks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`check_is_admin`装饰器➊，然后每当需要检查访问权限时就调用它。装饰器使用`kwargs`变量检查传递给函数的参数，并获取`username`参数，在调用实际函数之前执行用户名检查。像这样使用装饰器使得管理通用功能变得更加容易。对于有较多Python经验的人来说，这可能是司空见惯的事，但你可能没有意识到，这种实现装饰器的简单方法存在一些重大缺陷。
- en: '***Stacking Decorators***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***堆叠装饰器***'
- en: You can also use several decorators on top of a single function or method, as
    shown in [Listing 7-3](ch07.xhtml#ch7list3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在单个函数或方法上使用多个装饰器，如[列表 7-3](ch07.xhtml#ch7list3)所示。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-3: Using more than one decorator with a single function*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：在单个函数上使用多个装饰器*'
- en: Here, `check_user_is_not()` is a factory function for our decorator `user_check_decorator()`.
    It creates a function decorator that depends on the `username` variable and then
    returns that variable. The function `user_check_decorator()` will serve as a function
    decorator for `get_food()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`check_user_is_not()`是我们的装饰器`user_check_decorator()`的工厂函数。它创建一个依赖于`username`变量的函数装饰器，然后返回该变量。函数`user_check_decorator()`将作为`get_food()`的函数装饰器。
- en: The function `get_food()` gets decorated twice using `check_user_is_not()`.
    The question here is which username should be checked first—`admin` or `user123`?
    The answer is in the following code, where I translated [Listing 7-3](ch07.xhtml#ch7list3)
    into equivalent code without using a decorator.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`get_food()`被`check_user_is_not()`装饰了两次。这里的问题是应该先检查哪个用户名——`admin`还是`user123`？答案在下面的代码中，我将[列表
    7-3](ch07.xhtml#ch7list3)翻译成了没有使用装饰器的等效代码。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The decorator list is applied from top to bottom, so the decorators closest
    to the `def` keyword will be applied first and executed last. In the example above,
    the program will check for `admin` first and then for `user123`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器列表是从上到下应用的，因此最靠近`def`关键字的装饰器会首先被应用并最后执行。在上面的示例中，程序会首先检查`admin`，然后检查`user123`。
- en: '***Writing Class Decorators***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写类装饰器***'
- en: 'It’s also possible to implement class decorators, though these are less often
    used in the wild. *Class decorators* work in the same way as function decorators,
    but they act on classes rather than functions. The following is an example of
    a class decorator that sets attributes for two classes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以实现类装饰器，尽管这些在实际应用中使用得较少。*类装饰器*的工作方式与函数装饰器相同，但它们作用于类而不是函数。以下是一个类装饰器的示例，它为两个类设置属性：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the class is loaded and defined, it will set the `name` and `random_id`
    attributes, like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被加载和定义时，它将设置`name`和`random_id`属性，如下所示：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with function decorators, this can be handy for factorizing common code that
    manipulates classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数装饰器一样，这对于提取处理类的通用代码非常有用。
- en: 'Another possible use for class decorators is to wrap a function or class with
    classes. For example, class decorators are often used for wrapping a function
    that’s storing a state. The following example wraps the `print()` function to
    check how many times it has been called in a session:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器的另一个可能用途是用类来包装函数或类。例如，类装饰器通常用于包装存储状态的函数。以下示例包装了`print()`函数，用于检查它在一个会话中被调用了多少次：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then use this to check how many times the function `print_hello()` has
    been called:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用它来检查`print_hello()`函数被调用了多少次：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Retrieving Original Attributes with the update_wrapper Decorator**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用update_wrapper装饰器获取原始属性**'
- en: As mentioned, a decorator replaces the original function with a new one built
    on the fly. However, this new function lacks many of the attributes of the original
    function, such as its docstring and its name. [Listing 7-4](ch07.xhtml#ch7list4)
    shows how the function `foobar()` loses its docstring and its name attribute once
    it is decorated with the `is_admin` decorator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，装饰器会用一个新的函数替换原始函数，这个新函数是动态生成的。然而，这个新函数缺少了原始函数的许多属性，如文档字符串和名称。[示例 7-4](ch07.xhtml#ch7list4)展示了函数`foobar()`在被`is_admin`装饰器装饰后，失去了文档字符串和名称属性。
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-4: A decorated function loses its docstring and name attributes.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-4：一个被装饰的函数失去了其文档字符串和名称属性。*'
- en: Not having the correct docstring and name attribute for a function can be problematic
    in various situations, such as when generating the source code documentation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种情况下，函数没有正确的文档字符串和名称属性可能会带来问题，例如在生成源代码文档时。
- en: Fortunately, the `functools` module in the Python Standard Library solves this
    problem with the `update_wrapper()` function, which copies the attributes from
    the original function that were lost to the wrapper itself. The source code of
    `update_wrapper()` is shown in [Listing 7-5](ch07.xhtml#ch7list5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python标准库中的`functools`模块通过`update_wrapper()`函数解决了这个问题，该函数将原始函数丢失的属性复制到包装器本身。[示例
    7-5](ch07.xhtml#ch7list5)展示了`update_wrapper()`的源代码。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 7-5: The update_wrapper() source code*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-5：update_wrapper()源代码*'
- en: 'In [Listing 7-5](ch07.xhtml#ch7list5), the `update_wrapper()` source code highlights
    which attributes are worth saving when wrapping a function with a decorator. By
    default, the `__name__` attribute, `__doc__` attribute, and some other attributes
    are copied. You can also personalize which attributes of a function are copied
    to the decorated function. When we use `update_wrapper()` to rewrite our example
    from [Listing 7-4](ch07.xhtml#ch7list4), things are much nicer:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 7-5](ch07.xhtml#ch7list5)中，`update_wrapper()`源代码突出了在使用装饰器包装函数时哪些属性值得保存。默认情况下，`__name__`属性、`__doc__`属性以及其他一些属性会被复制。你也可以自定义哪些函数的属性被复制到装饰后的函数上。当我们使用`update_wrapper()`重写[示例
    7-4](ch07.xhtml#ch7list4)中的例子时，效果更好：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the `foobar()` function has the correct name and docstring even when decorated
    by `is_admin`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使`foobar()`函数被`is_admin`装饰，它仍然拥有正确的名称和文档字符串。
- en: '**wraps: A Decorator for Decorators**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**wraps：为装饰器设计的装饰器**'
- en: It can get tedious to use `update_wrapper()` manually when creating decorators,
    so `functools` provides a decorator for decorators called `wraps`. [Listing 7-6](ch07.xhtml#ch7list6)
    shows the `wraps` decorator in use.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建装饰器时，手动使用`update_wrapper()`可能会变得很繁琐，因此`functools`提供了一个装饰器，用于装饰器本身，称为`wraps`。[示例
    7-6](ch07.xhtml#ch7list6)展示了`wraps`装饰器的使用。
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-6: Updating our decorator with wraps from functools*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6：使用functools中的wraps更新我们的装饰器*'
- en: With `functools.wrap`, the decorator function `check_is_admin()` that returns
    the `wrapper()` function takes care of copying the docstring, name function, and
    other information from the function `f` passed as argument. Thus, the decorated
    function (`get_food()`, in this case) still sees its unchanged signature.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`functools.wrap`时，返回`wrapper()`函数的装饰器函数`check_is_admin()`会负责从传入参数`f`的函数中复制文档字符串、名称函数以及其他信息。因此，被装饰的函数（在本例中是`get_food()`）仍然保持不变的签名。
- en: '**Extracting Relevant Information with inspect**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用inspect提取相关信息**'
- en: In our examples so far, we have assumed that the decorated function will always
    have a `username` passed to it as a keyword argument, but that might not be the
    case. It might instead have a bunch of information from which we need to extract
    the username to check. With this in mind, we’ll build a smarter version of our
    decorator that can look at the decorated function’s arguments and pull out what
    it needs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的例子中，我们假设被装饰的函数总是会接收到一个作为关键字参数传递的`username`，但实际情况可能并非如此。它可能会接收到一堆信息，我们需要从中提取出`username`来进行检查。考虑到这一点，我们将构建一个更智能的装饰器版本，能够查看被装饰函数的参数并提取所需的信息。
- en: For this, Python has the `inspect` module, which allows us to retrieve a function’s
    signature and operate on it, as shown in [Listing 7-7](ch07.xhtml#ch7list7).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Python提供了`inspect`模块，它允许我们获取一个函数的签名并对其进行操作，如[示例 7-7](ch07.xhtml#ch7list7)所示。
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-7: Using tools from the inspect module to extract information*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-7：使用inspect模块中的工具来提取信息*'
- en: 'The function that does the heavy lifting here is `inspect.getcallargs()`, which
    returns a dictionary containing the names and values of the arguments as key-value
    pairs. In our example, this function returns `{''username'': ''admin'',''type'':
    ''chocolate''}`. That means that our decorator does not have to check whether
    the `username` parameter is a positional or a keyword argument; all the decorator
    has to do is look for `username` in the dictionary.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '执行繁重工作的函数是`inspect.getcallargs()`，它返回一个字典，字典包含了参数的名称和值，以键值对的形式。在我们的示例中，这个函数返回`{''username'':
    ''admin'',''type'': ''chocolate''}`。这意味着我们的装饰器不需要检查`username`参数是位置参数还是关键字参数；装饰器只需要在字典中查找`username`即可。'
- en: 'Using `functools.wraps` and the `inspect` module, you should be able to write
    any custom decorator that you would ever need. However, do not abuse the `inspect`
    module: while being able to guess what the function will accept as an argument
    sounds handy, this capability can be fragile, breaking easily when function signatures
    change. Decorators are a terrific way to implement the *Don’t Repeat Yourself*
    mantra so cherished by developers.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`functools.wraps`和`inspect`模块，你应该能够编写任何自定义装饰器。不过，不要滥用`inspect`模块：虽然能够猜测函数会接受什么样的参数听起来很方便，但这个功能可能是脆弱的，在函数签名发生变化时容易破坏。装饰器是实现开发者所珍视的*不要重复自己（DRY）*原则的绝佳方式。
- en: '**How Methods Work in Python**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Python中的方法是如何工作的**'
- en: Methods are pretty simple to use and understand, and you’ve likely just used
    them correctly without delving in much deeper than you needed to. But to understand
    what certain decorators do, you need to know how methods work behind the scenes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的使用和理解相当简单，你很可能已经正确使用了它们，而无需深入探讨。但是，要理解某些装饰器的作用，你需要知道方法背后是如何运作的。
- en: 'A *method* is a function that is stored as a class attribute. Let’s have a
    look at what happens when we try to access such an attribute directly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是作为类属性存储的函数。让我们看看当我们尝试直接访问这样的属性时会发生什么：'
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are told that `get_size()` is a function—but why is that? The reason is
    that at this stage, `get_size()` is not tied to any particular object. Therefore,
    it is treated as a normal function. Python will raise an error if we try to call
    it directly, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知`get_size()`是一个函数——但为什么会这样呢？原因是，在这个阶段，`get_size()`并没有绑定到任何特定的对象。因此，它被当作普通的函数来处理。如果我们直接调用它，Python会抛出错误，像这样：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Python complains that we have not provided the necessary `self` argument. Indeed,
    as it is not bound to any object, the `self` argument cannot be set automatically.
    However, we are able to use the `get_size()` function not only by passing an arbitrary
    instance of the class to the method if we want to but also by passing *any* object,
    as long as it has the properties that the method expects to find. Here’s an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python会抱怨我们没有提供必要的`self`参数。确实，由于它没有绑定到任何对象，`self`参数无法自动设置。然而，我们不仅可以通过传递类的任意实例来调用`get_size()`函数，如果我们愿意，还可以传递*任何*对象，只要它具备方法所期待的属性。以下是一个示例：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This call works, just as promised. It is, however, not very convenient: we
    have to refer to the class every time we want to call one of its methods.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用是有效的，正如所承诺的那样。然而，它并不是很方便：每次我们想调用类的某个方法时，都需要提到类本身。
- en: 'So Python goes the extra mile for us by binding a class’s methods to its instances.
    In other words, we can access `get_size()` from any `Pizza` instance, and, better
    still, Python will automatically pass the object itself to the method’s `self`
    parameter, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Python为我们做了额外的工作，通过将类的方法绑定到其实例上。换句话说，我们可以从任何`Pizza`实例访问`get_size()`，更重要的是，Python会自动将对象本身传递给方法的`self`参数，像这样：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As expected, we do not have to provide any argument to `get_size()`, since
    it’s a bound method: its `self` argument is automatically set to our `Pizza` instance.
    Here is an even clearer example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们不需要向`get_size()`提供任何参数，因为它是一个绑定方法：它的`self`参数会自动设置为我们的`Pizza`实例。这里有一个更清晰的示例：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As long as you have a reference to the bound method, you do not even have to
    keep a reference to your `Pizza` object. Moreover, if you have a reference to
    a method but you want to find out which object it is bound to, you can just check
    the method’s `__self__` property, like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你有绑定方法的引用，你甚至不需要保留对`Pizza`对象的引用。此外，如果你有方法的引用，但想知道它绑定到哪个对象，你可以直接检查方法的`__self__`属性，像这样：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Obviously, we still have a reference to our object, and we can find it if we
    want.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们仍然可以访问我们的对象，如果需要，我们可以找到它。
- en: '**Static Methods**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**静态方法**'
- en: '*Static methods* belong to a class, rather than an instance of a class, so
    they don’t actually operate on or affect class instances. Instead, a static method
    operates on the parameters it takes. Static methods are generally used to create
    utility functions, because they do not depend on the state of the class or its
    objects.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法*属于类，而不是类的实例，因此它们不会实际操作或影响类的实例。相反，静态方法操作的是它所接受的参数。静态方法通常用于创建实用函数，因为它们不依赖于类或其对象的状态。'
- en: For example, in [Listing 7-8](ch07.xhtml#ch7list8), the static `mix_ingredients()`
    method belongs to the `Pizza` class but could actually be used to mix ingredients
    for any other food.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[示例 7-8](ch07.xhtml#ch7list8)中，静态`mix_ingredients()`方法属于`Pizza`类，但实际上可以用于混合任何其他食物的配料。
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 7-8: Creating a static method as part of a class*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-8：将静态方法作为类的一部分创建*'
- en: You could write `mix_ingredients()` as a non-static method if you wanted to,
    but it would take a `self` argument that would never actually be used. Using the
    `@staticmethod` decorator gives us several things.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以将`mix_ingredients()`编写为一个非静态方法，但它将需要一个`self`参数，而这个参数实际上从未被使用过。使用`@staticmethod`装饰器能为我们带来多个好处。
- en: 'The first is speed: Python does not have to instantiate a bound method for
    each `Pizza` object we create. Bound methods are objects, too, and creating them
    has a CPU and memory cost—even if it’s low. Using a static method lets us avoid
    that, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个优点是速度：Python不必为我们创建的每个`Pizza`对象实例化一个绑定方法。绑定方法本身也是对象，创建它们会有CPU和内存的开销——即使开销很小。使用静态方法可以避免这种情况，像这样：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Second, static methods improve the readability of the code. When we see `@staticmethod`,
    we know that the method does not depend on the state of the object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，静态方法提高了代码的可读性。当我们看到`@staticmethod`时，我们就知道该方法不依赖于对象的状态。
- en: Third, static methods can be overridden in subclasses. If instead of a static
    method, we used a `mix_ingredients()` function defined at the top level of our
    module, a class inheriting from `Pizza` wouldn’t be able to change the way we
    mix ingredients for our pizza without overriding the `cook()` method itself. With
    static methods, the subclasses can override the method for their own purposes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，静态方法可以在子类中被重写。如果我们使用的是一个在模块顶部定义的`mix_ingredients()`函数，而不是静态方法，那么继承自`Pizza`类的子类就无法改变我们混合比萨配料的方式，除非重写`cook()`方法本身。使用静态方法时，子类可以根据自己的需求重写该方法。
- en: Unfortunately, Python is not always able to detect for itself whether a method
    is static or not—I call that a defect of the language design. One possible approach
    is to add a check that detects such pattern and emits a warning using `flake8`.
    We will look into how to do this in “Extending `flake8` with AST Checks” on [page
    140](ch09.xhtml#page_140).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python并不总是能够自己检测一个方法是否是静态的——我称之为语言设计的缺陷。一种可能的方法是添加一个检测此模式的检查，并使用`flake8`发出警告。我们将在《通过AST检查扩展`flake8`》一章中，查看如何实现这一点，详见[第140页](ch09.xhtml#page_140)。
- en: '**Class Methods**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类方法**'
- en: '*Class methods* are bound to a class rather than its instances. That means
    that those methods cannot access the state of the object but only the state and
    methods of the class. [Listing 7-9](ch07.xhtml#ch7list9) shows how to write a
    class method.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*类方法*是绑定到类本身，而不是其实例。这意味着这些方法无法访问对象的状态，而只能访问类的状态和方法。[示例 7-9](ch07.xhtml#ch7list9)展示了如何编写类方法。'
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 7-9: Binding a class method to its class*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-9：将类方法绑定到类上*'
- en: 'As you can see, there are various ways to access the `get_radius()` class method,
    but however you choose to access it, the method is always bound to the class it
    is attached to. Also, its first argument must be the class itself. Remember: classes
    are objects too!'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，访问`get_radius()`类方法有多种方式，但无论你选择哪种方式，方法总是绑定到它所属的类上。此外，它的第一个参数必须是类本身。记住：类也是对象！
- en: 'Class methods are principally useful for creating *factory methods*, which
    instantiate objects using a different signature than `__init__`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法主要用于创建*工厂方法*，这些方法使用不同于`__init__`的签名来实例化对象：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we used a `@staticmethod` here instead of a `@classmethod`, we would have
    to hardcode the `Pizza` class name in our method, making any class inheriting
    from `Pizza` unable to use our factory for its own purposes. In this case, however,
    we provide a `from_fridge()` factory method that we can pass a `Fridge` object
    to. If we call this method with something like `Pizza.from_fridge(myfridge)`,
    it returns a brand-new `Pizza` with ingredients taken from what’s available in
    `myfridge`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里使用`@staticmethod`而不是`@classmethod`，我们将不得不在方法中硬编码`Pizza`类名，这样任何继承自`Pizza`的类都无法使用我们的工厂方法。可是，在这种情况下，我们提供了一个`from_fridge()`工厂方法，允许我们传入一个`Fridge`对象。如果我们用类似`Pizza.from_fridge(myfridge)`的方式调用该方法，它将返回一个从`myfridge`中获取的全新`Pizza`。
- en: Any time you write a method that cares only about the class of the object and
    not about the object’s state, it should be declared as a class method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你编写一个只关心对象的类而不关心对象状态的方法时，应该将其声明为类方法。
- en: '**Abstract Methods**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**抽象方法**'
- en: An *abstract method* is defined in an abstract base class that may not itself
    provide any implementation. When a class has an abstract method, it cannot be
    instantiated. As a consequence, an *abstract class* (defined as a class that has
    at least one abstract method) must be used as a parent class by another class.
    This subclass will be in charge of implementing the abstract method, making it
    possible to instantiate the parent class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象方法*定义在一个抽象基类中，该基类本身可能不提供任何实现。当一个类有抽象方法时，它无法被实例化。因此，*抽象类*（定义为至少有一个抽象方法的类）必须作为父类被另一个类继承。这个子类将负责实现抽象方法，从而使得可以实例化父类。'
- en: 'We can use abstract base classes to make clear the relationships between other,
    connected classes derived from the base class but make the abstract base class
    itself impossible to instantiate. By using abstract base classes, you can ensure
    the classes derived from the base class implement particular methods from the
    base class, or an exception will be raised. The following example shows the simplest
    way to write an abstract method in Python:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用抽象基类来明确基类与其他连接类之间的关系，同时使得抽象基类本身无法实例化。通过使用抽象基类，你可以确保从基类派生的类实现基类的特定方法，否则会引发异常。以下示例展示了在Python中编写抽象方法的最简单方式：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this definition, any class inheriting from `Pizza` must implement and override
    the `get_radius()` method; otherwise, calling the method raises the exception
    shown here. This is handy for making sure that each subclass of `Pizza` implements
    its own way of computing and returning its radius.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个定义，任何继承自`Pizza`的类都必须实现并覆盖`get_radius()`方法；否则，调用该方法时会抛出如示例中的异常。这对于确保`Pizza`的每个子类都能实现并返回自己的半径计算方法非常有用。
- en: 'This way of implementing abstract methods has a drawback: if you write a class
    that inherits from `Pizza` but forget to implement `get_radius()`, the error is
    raised only if you try to use that method at runtime. Here’s an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现抽象方法的方式有一个缺点：如果你编写一个继承自`Pizza`的类，但忘记实现`get_radius()`，只有在你尝试在运行时使用该方法时才会抛出错误。下面是一个例子：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As `Pizza` is directly instantiable, there’s no way to prevent this from happening.
    One way to make sure you get an early warning about forgetting to implement and
    override the method, or trying to instantiate an object with abstract methods,
    is to use Python’s built-in `abc` (abstract base classes) module instead, like
    so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Pizza`是直接可实例化的，因此无法阻止这种情况的发生。确保在忘记实现和覆盖方法，或者尝试实例化包含抽象方法的对象时收到早期警告的一种方法是使用Python的内置`abc`（抽象基类）模块，示例如下：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `abc` module provides a set of decorators to use on top of methods that
    will be defined as abstracts and a metaclass to enable this. When you use `abc`
    and its special `metaclass`, as shown above, instantiating a `BasePizza` or a
    class inheriting from it that doesn’t override `get_radius()` causes a `TypeError`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc`模块提供了一组装饰器，可以用来装饰定义为抽象的那些方法，并且提供一个元类来支持这一点。当你使用`abc`及其特殊的`metaclass`时，如上所示，实例化一个没有覆盖`get_radius()`方法的`BasePizza`类或继承它的类会导致`TypeError`：'
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We try to instantiate the abstract `BasePizza` class and are immediately told
    it can’t be done!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试实例化抽象类`BasePizza`，并立即被告知无法执行此操作！
- en: While using abstract methods doesn’t guarantee that the method is implemented
    by the user, this decorator helps you catch the error earlier. This is especially
    handy when you are providing interfaces that must be implemented by other developers;
    it’s a good documentation hint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用抽象方法不能保证方法一定会被用户实现，但这个装饰器帮助你更早地发现错误。当你提供必须由其他开发者实现的接口时，这非常有用；它是一个很好的文档提示。
- en: '**Mixing Static, Class, and Abstract Methods**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**混合静态方法、类方法和抽象方法**'
- en: Each of these decorators is useful on its own, but the time may come when you’ll
    have to use them together.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个装饰器都有其独立的用处，但有时你可能需要将它们一起使用。
- en: For example, you could define a factory method as a class method while forcing
    the implementation to be made in a subclass. In that case, you’d need to have
    a class method defined as both an abstract method and a class method. This section
    gives some tips that will help you with that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将工厂方法定义为类方法，同时强制要求在子类中实现。在这种情况下，你需要将类方法同时定义为抽象方法和类方法。本节提供了一些可以帮助你解决这个问题的技巧。
- en: First, an abstract method’s prototype is not set in stone. When you implement
    the method, there is nothing stopping you from extending the argument list as
    you see fit. [Listing 7-10](ch07.xhtml#ch7list10) is an example of code in which
    a subclass extends the signature of the abstract method of its parent.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，抽象方法的原型并不是一成不变的。当你实现方法时，并没有什么阻止你根据需要扩展参数列表。[示例 7-10](ch07.xhtml#ch7list10)是一个代码示例，其中子类扩展了其父类抽象方法的签名。
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 7-10: Using a subclass to extend the signature of the abstract method
    of its parent*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-10：使用子类扩展其父类抽象方法的签名*'
- en: 'We define the `Calzone` subclass to inherit from the `BasePizza` class. We
    can define the `Calzone` subclass’s methods any way we like, as long as they support
    the interface we define in `BasePizza`. This includes implementing the methods
    as either class or static methods. The following code defines an abstract `get_ingredients()`
    method in the base class and a static `get_ingredients()` method in the `DietPizza`
    subclass:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`Calzone`子类继承自`BasePizza`类。我们可以根据需要定义`Calzone`子类的方法，只要它们支持我们在`BasePizza`中定义的接口。这包括将方法实现为类方法或静态方法。以下代码在基类中定义了一个抽象的`get_ingredients()`方法，并在`DietPizza`子类中定义了一个静态的`get_ingredients()`方法：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Even though our static `get_ingredients()` method doesn’t return a result based
    on the object’s state, it supports our abstract `BasePizza` class’s interface,
    so it’s still valid.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的静态`get_ingredients()`方法并不基于对象的状态返回结果，它仍然支持我们抽象`BasePizza`类的接口，因此它是有效的。
- en: It is also possible to use the `@staticmethod` and `@classmethod` decorators
    on top of `@abstractmethod` in order to indicate that a method is, for example,
    both static and abstract, as shown in [Listing 7-11](ch07.xhtml#ch7list11).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`@abstractmethod`上方使用`@staticmethod`和`@classmethod`装饰器，以表示一个方法例如既是静态的又是抽象的，如在[示例
    7-11](ch07.xhtml#ch7list11)中所示。
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 7-11: Using a class method decorator with abstract methods*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-11：在抽象方法中使用类方法装饰器*'
- en: The abstract method `get_ingredients()` needs to be implemented by a subclass,
    but it’s also a class method, meaning the first argument it will receive will
    be a class (not an object).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法`get_ingredients()`需要由子类实现，但它也是一个类方法，这意味着它将接收的第一个参数是类（而不是对象）。
- en: 'Note that by defining `get_ingredients()` as a class method in `BasePizza`
    like this, you are not forcing any subclasses to define `get_ingredients()` as
    a class method—it could be a regular method. The same would apply if we had defined
    it as a static method: there’s no way to force subclasses to implement abstract
    methods as a specific kind of method. As we have seen, you can change the signature
    of an abstract method when implementing it in a subclass in any way you like.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过像这样在`BasePizza`中将`get_ingredients()`定义为类方法，并不会强制任何子类将`get_ingredients()`定义为类方法——它可以是一个普通方法。如果我们将其定义为静态方法，同样不会强制子类将抽象方法实现为特定类型的方法。正如我们所见，子类在实现抽象方法时可以根据需要改变方法的签名。
- en: '***Putting Implementations in Abstract Methods***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将实现放入抽象方法中***'
- en: 'Hold the phone: in [Listing 7-12](ch07.xhtml#ch7list12), we have an implementation
    *in* an abstract method. Can we *do* that? The answer is yes. Python does not
    have a problem with it! You can put code in your abstract methods and call it
    using `super()`, as demonstrated in [Listing 7-12](ch07.xhtml#ch7list12).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 等等：在[Listing 7-12](ch07.xhtml#ch7list12)中，我们有一个实现 *在* 抽象方法中的例子。我们能*这么做*吗？答案是肯定的。Python
    对此没有问题！你可以在抽象方法中写代码，并使用`super()`调用它，正如[Listing 7-12](ch07.xhtml#ch7list12)所示。
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 7-12: Using an implementation in an abstract method*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-12：在抽象方法中使用实现*'
- en: In this example, every `Pizza` you make that inherits from `BasePizza` has to
    override the `get_ingredients()` method, but every `Pizza` also has access to
    the base class’s default mechanism for getting the ingredients list. This mechanism
    is especially useful when providing an interface to implement while also providing
    base code that might be useful to all inheriting classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个继承自`BasePizza`的`Pizza`都必须重写`get_ingredients()`方法，但每个`Pizza`也可以访问基类提供的默认机制来获取配料列表。这个机制在提供接口实现的同时，也提供了可能对所有继承类有用的基础代码，非常有用。
- en: '***The Truth About super***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关于 super 的真相***'
- en: Python has always allowed developers to use both single and multiple inheritances
    to extend their classes, but even today, many developers do not seem to understand
    how these mechanisms, and the `super()` method that is associated with them, work.
    To fully understand your code, you need to understand the trade-offs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Python 一直允许开发者使用单继承和多重继承来扩展他们的类，但即使在今天，许多开发者似乎并不完全理解这些机制，以及与之相关的`super()`方法是如何工作的。要完全理解你的代码，你需要理解这些机制的权衡。
- en: Multiple inheritances are used in many places, particularly in code involving
    a mixin pattern. A *mixin* is a class that inherits from two or more other classes,
    combining their features.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承在许多地方都有使用，尤其是在涉及混入模式的代码中。*混入*是一个继承自两个或更多其他类的类，它结合了这些类的特性。
- en: '**NOTE**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many of the pros and cons of single and multiple inheritances, composition,
    or even duck typing are out of scope for this book, so we won’t cover everything
    here. If you are not familiar with these notions, I suggest you read about them
    to form your own opinions.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*单继承和多重继承、组合甚至鸭子类型的优缺点超出了本书的范围，因此我们不会在这里讨论所有内容。如果你不熟悉这些概念，我建议你阅读相关资料，形成自己的看法。*'
- en: 'As you should know by now, classes are objects in Python. The construct used
    to create a class is a special statement that you should be well familiar with:
    `class classname`(expression of inheritance).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在应该已经知道的，类在 Python 中是对象。用于创建类的构造是一个你应该非常熟悉的特殊语句：`class classname`（继承的表达式）。
- en: 'The code in parentheses is a Python expression that returns the list of class
    objects to be used as the class’s parents. Ordinarily, you would specify them
    directly, but you could also write something like this to specify the list of
    parent objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的代码是一个 Python 表达式，它返回用于指定类的父类列表。通常，你会直接指定这些父类，但你也可以像这样写来指定父类对象的列表：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code works as expected: we declare class `A` with `object` as its parent
    class. The class method `mro()` returns the *method resolution order* used to
    resolve attributes—it defines how the next method to call is found via the tree
    of inheritance between classes. The current MRO system was first implemented in
    Python 2.3, and its internal workings are described in the Python 2.3 release
    notes. It defines how the system browses the tree of inheritance between classes
    to find the method to call.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按预期工作：我们声明类`A`，其父类是`object`。类方法`mro()`返回*方法解析顺序*，用于解析属性——它定义了如何通过类之间的继承树找到下一个要调用的方法。当前的
    MRO 系统最早在 Python 2.3 中实现，其内部工作原理在 Python 2.3 的发布说明中有所描述。它定义了系统如何浏览类之间的继承树来找到要调用的方法。
- en: 'We already saw that the canonical way to call a method in a parent class is
    to use the `super()` function, but what you probably don’t know is that `super()`
    is actually a constructor and you instantiate a `super` object each time you call
    it. It takes either one or two arguments: the first argument is a class, and the
    second, optional argument is either a subclass or an instance of the first argument.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在父类中调用方法的标准方式是使用`super()`函数，但你可能不知道的是，`super()`实际上是一个构造函数，每次调用它时，你都会实例化一个`super`对象。它接受一个或两个参数：第一个参数是一个类，第二个参数是可选的，要么是第一个参数的子类，要么是第一个参数的实例。
- en: The object returned by the constructor functions as a proxy for the parent classes
    of the first argument. It has its own `__getattribute__` method that iterates
    over the classes in the MRO list and returns the first matching attribute it finds.
    The `__getattribute__` method is called when an attribute of the `super()` object
    is retrieved, as shown in [Listing 7-13](ch07.xhtml#ch7list13).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数返回的对象充当了第一个参数的父类代理。它有自己的 `__getattribute__` 方法，遍历 MRO（方法解析顺序）列表并返回它找到的第一个匹配属性。当获取
    `super()` 对象的属性时，会调用 `__getattribute__` 方法，如 [Listing 7-13](ch07.xhtml#ch7list13)
    所示。
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 7-13: The super() function is a constructor that instantiates a super
    object.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-13：super() 函数是一个构造函数，用于实例化一个 super 对象。*'
- en: When requesting an attribute of the `super` object of an instance of `C`, the
    `__getattribute__` method of the `super()` object walks through the MRO list and
    returns the attribute from the first class it finds that has the `super` attribute.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求 `C` 类实例的 `super` 对象的属性时，`super()` 对象的 `__getattribute__` 方法会遍历 MRO 列表，并返回它找到的第一个包含
    `super` 属性的类的属性。
- en: 'In [Listing 7-13](ch07.xhtml#ch7list13), we called `super()` with two arguments,
    meaning we used a *bound* `super` object. If we call `super()` with only one argument,
    it returns an *unbound* `super` object instead:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 7-13](ch07.xhtml#ch7list13) 中，我们传递了两个参数调用了 `super()`，这意味着我们使用了一个
    *绑定* 的 `super` 对象。如果我们仅用一个参数调用 `super()`，它将返回一个 *未绑定* 的 `super` 对象：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since no instance has been provided as the second argument, the `super` object
    cannot be bound to any instance. Therefore, you cannot use this unbound object
    to access class attributes. If you try, you’ll get the following errors:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有提供实例作为第二个参数，`super` 对象无法绑定到任何实例。因此，你不能使用这个未绑定的对象来访问类属性。如果你尝试这样做，你将得到以下错误：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At first glance, it might seem like this unbound kind of `super` object is
    useless, but actually the way the `super` class implements the descriptor protocol
    `__get__` makes unbound `super` objects useful as class attributes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎这个未绑定的 `super` 对象毫无用处，但实际上，`super` 类通过实现描述符协议 `__get__` 的方式，使得未绑定的 `super`
    对象可以作为类属性使用：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The unbound `super` object’s `__get__` method is called using the instance `super(C).__get__(D())`
    and the attribute name `'foo'` as arguments, allowing it to find and resolve `foo`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 未绑定的 `super` 对象的 `__get__` 方法使用实例 `super(C).__get__(D())` 和属性名 `'foo'` 作为参数调用，从而能够找到并解析
    `foo`。
- en: '**NOTE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even if you’ve never heard of the descriptor protocol, it’s likely you’ve
    used it through the @property decorator without knowing it. The descriptor protocol
    is the mechanism in Python that allows an object stored as an attribute to return
    something other than itself. This protocol is not covered in this book, but you
    can find out more about it in the Python data model documentation.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使你从未听说过描述符协议，你很可能已经通过 @property 装饰器使用过它，而你自己并未意识到。描述符协议是 Python 中的一种机制，允许存储为属性的对象返回除了自身之外的其他内容。本书中没有覆盖描述符协议的内容，但你可以在
    Python 数据模型文档中找到更多相关信息。*'
- en: There are plenty of situations in which using `super()` can be tricky, such
    as when handling different method signatures along the inheritance chain. Unfortunately,
    there’s no silver bullet for all occasions. The best precaution is to use tricks
    such as having all your methods accept their arguments using `*args, **kwargs`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `super()` 可能会有很多棘手的情况，例如在继承链中处理不同的方法签名。不幸的是，并没有一种万能的解决方案来应对所有场合。最好的预防措施是使用技巧，例如让你的所有方法都接受
    `*args, **kwargs` 作为参数。
- en: 'Since Python 3, `super()` has picked up a bit of magic: it can now be called
    from within a method without any arguments. When no arguments are passed to `super()`,
    it automatically searches the stack frame for arguments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3 开始，`super()` 增添了一些魔法：它现在可以在方法内部不带任何参数地调用。当不向 `super()` 传递任何参数时，它会自动在栈帧中查找参数：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The standard way of accessing parent attributes in subclasses is `super()`,
    and you should always use it. It allows cooperative calls of parent methods without
    any surprises, such as parent methods not being called or being called twice when
    multiple inheritances are used.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 访问子类父类属性的标准方式是 `super()`，你应该始终使用它。它可以在不引发意外的情况下协作调用父类方法，避免出现父类方法没有被调用或在多重继承时被调用两次的情况。
- en: '**Summary**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Equipped with what you learned in this chapter, you should be unbeatable on
    everything that concerns methods definition in Python. Decorators are essential
    when it comes to code factorization, and proper use of the built-in decorators
    provided by Python can vastly improve the neatness of your Python code. Abstract
    classes are especially useful when providing an API to other developers and services.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借你在本章中学到的知识，你应该在涉及Python方法定义的所有问题上都能无敌了。装饰器在代码抽象化时至关重要，正确使用Python提供的内置装饰器可以极大提升Python代码的整洁性。抽象类在为其他开发者和服务提供API时尤其有用。
- en: Class inheritance is not often fully understood, and having an overview of the
    internal machinery of the language is a good way to fully apprehend how this works.
    There should be no secrets left on this topic for you now!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承往往不容易完全理解，了解语言内部机制的概览是全面理解其工作原理的好方法。现在这个话题应该没有什么你无法掌握的秘密了！
