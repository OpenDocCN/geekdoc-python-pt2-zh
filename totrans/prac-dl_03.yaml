- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: USING NUMPY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NUMPY**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: NumPy is foundational to all of the machine learning we’ll explore in this book.
    If you’re already comfortable with NumPy, you can skip this chapter. If you’re
    not, don’t be shy; consider this chapter a refresher and dive in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是本书中所有机器学习内容的基础。如果你已经熟悉 NumPy，可以跳过这一章。如果你不熟悉，不用害羞；把这一章当作复习，尽情深入学习吧。
- en: A full tutorial of NumPy is beyond what we can cover here, so if you’re interested,
    you can look further at *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的完整教程超出了我们本书的范围，因此，如果你有兴趣，可以进一步查看 *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*。
- en: Why NumPy?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择 NumPy？
- en: 'Python is an elegant programming language but it lacks an important data structure
    that’s fundamental to scientific and mathematical programming: the array. Yes,
    you could use a dictionary as an array, or a sizeable predefined list, but this
    would be an abuse of those data structures—and, more practically, it would be
    slow. Let’s look at the difference in implementation between an array and a list.
    Python lists are more advanced than the notion of a list we’re using here, but
    in essence they’re the same.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种优雅的编程语言，但它缺少一个在科学和数学编程中至关重要的数据结构：数组。是的，你可以使用字典作为数组，或者使用一个相当大的预定义列表，但这会滥用这些数据结构——而且，从实际角度来看，这会非常慢。我们来看看数组和列表在实现上的区别。Python
    列表比我们在这里使用的列表概念更为先进，但从本质上讲，它们是相同的。
- en: Arrays vs. Lists
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组与列表
- en: The *array* is simply a fixed-size block of *contiguous* memory, a single block
    of RAM with no gaps, used to represent a set of *n* elements, each of which uses
    exactly *m* bytes. For example, an IEEE 754 double precision floating-point number
    occupies 64 bits of memory, 8 bytes, and is what Python uses under the hood for
    its `float` data type. Therefore, an array of *n* = 100 Python floats would occupy,
    at a minimum, *nm* = 100(8) = 800 bytes of memory. If Python had arrays as a data
    structure, it would allocate 800 bytes of memory and point the array variable
    name, `A`, to the memory as in [Figure 3-1](ch03.xhtml#ch3fig1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*只是一个固定大小的*连续*内存块，一块没有间隙的 RAM，用于表示一组 *n* 个元素，每个元素使用 *m* 字节。例如，IEEE 754 双精度浮点数占用
    64 位内存，即 8 字节，这是 Python 在底层为其 `float` 数据类型使用的方式。因此，*n* = 100 的 Python 浮点数组至少会占用
    *nm* = 100(8) = 800 字节内存。如果 Python 有数组作为数据结构，它将分配 800 字节内存，并将数组变量名 `A` 指向该内存，正如
    [图 3-1](ch03.xhtml#ch3fig1) 所示。'
- en: '![image](Images/03fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/03fig01.jpg)'
- en: '*Figure 3-1: An array stored in contiguous memory*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：存储在连续内存中的数组*'
- en: Whenever we want to access an element of the array, say `x[3]`, we can very
    quickly calculate the exact location in memory by adding 3(8) = 24 to the memory
    address of the base of the array. This is the indexing operation for an array.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想访问数组中的一个元素，比如 `x[3]`，我们可以通过将 3(8) = 24 加到数组基址的内存地址来非常快速地计算出该元素在内存中的确切位置。这就是数组的索引操作。
- en: 'Multidimensional arrays are also stored in memory as contiguous blocks, and
    the indexing operation is only slightly more complicated. A *multi-dimensional
    array* uses two or more numbers to index the elements. Think of a chess board;
    two numbers are needed to determine the location of a piece: the row and the column.
    Therefore, the chess board is a two-dimensional array. If we add one more dimension
    to turn the chess board into a stack of chess boards, we need three numbers to
    locate a piece: the row, the column, and the board number. Therefore, we have
    a three-dimensional array.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组也存储在内存中作为连续的块，索引操作仅稍微复杂一些。*多维数组*使用两个或更多的数字来索引元素。想象一个棋盘；确定棋子位置需要两个数字：行号和列号。因此，棋盘是一个二维数组。如果我们增加一个维度，将棋盘变成一堆棋盘，我们就需要三个数字来定位棋子：行号、列号和棋盘号。因此，我们有了一个三维数组。
- en: We will use arrays with one, two, and three dimensions throughout the book.
    All of these are stored in memory as a single block of RAM. The point is, an array
    is quick to index, and therefore operations on array elements can be performed
    very quickly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用一维、二维和三维数组。所有这些都存储在内存中作为一个单一的 RAM 块。关键是，数组的索引速度很快，因此对数组元素的操作可以非常迅速地执行。
- en: Contrast this with a list. [Figure 3-2](ch03.xhtml#ch3fig2) shows the basic
    structure of a list, `B`, in memory. In this case, the elements in the list are
    not in contiguous memory, but are scattered throughout RAM with pointers linking
    one element to the next, like a chain. Each link in the chain contains the data
    value we want to store and a pointer to the memory of the next link in the chain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与列表进行对比。[图 3-2](ch03.xhtml#ch3fig2)展示了列表 `B` 在内存中的基本结构。在这种情况下，列表中的元素并不是连续存储在内存中的，而是分散在
    RAM 中，通过指针将一个元素与下一个元素连接，像链条一样。链条中的每个链接包含我们要存储的数据值和指向下一个链接内存的指针。
- en: '![image](Images/03fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/03fig02.jpg)'
- en: '*Figure 3-2: A list stored as a collection of linked nodes scattered throughout
    memory*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：作为一系列链式节点存储在内存中的列表*'
- en: We can’t index into a list by just adding an offset to a base memory address.
    Instead, if we want the fourth element of the list, then we need to start at the
    head of the list, use the link there to the next element, and the next, and the
    next, to reach the memory associated with the fourth element, the `3` in [Figure
    3-2](ch03.xhtml#ch3fig2). This isn’t too bad until we want to index the 1,000,000th
    element and have to repeat the process 1 million times instead of adding 8 million
    once to a base address.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法通过简单地对基本内存地址添加偏移量来索引一个列表。相反，如果我们想要列表中的第四个元素，我们需要从列表的头开始，使用那里指向下一个元素的链接，再使用下一个链接，以此类推，直到到达与第四个元素相关的内存，即[图
    3-2](ch03.xhtml#ch3fig2)中的 `3`。这种方式还算可以接受，直到我们要索引第 1,000,000 个元素，而不得不重复这个过程一百万次，而不是一次性将
    8百万加到基本地址上。
- en: Most machine learning involves arrays. If the array has a single dimension,
    we call it a *vector*; vectors are the inputs to many of our models. If the array
    has two dimensions, it’s a *matrix*. A matrix can be thought of as a chess board
    or an image where each pixel of the image is one of the board locations. Matrices
    can also be an input to our models, or used internally by the model; for example,
    the weight matrices of a neural network, or the convolution kernels and filter
    outputs of a convolutional neural network are matrices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数机器学习都涉及数组。如果数组是单维的，我们称之为 *向量*；向量是我们模型的输入之一。如果数组是二维的，则它是 *矩阵*。矩阵可以被看作是棋盘或图像，其中图像的每个像素都是棋盘上的一个位置。矩阵也可以作为模型的输入，或在模型内部使用；例如，神经网络的权重矩阵，或卷积神经网络的卷积核和过滤器输出都是矩阵。
- en: Therefore, it’s critically important to be able to quickly operate on array
    data. This is where the `numpy` library comes in. It adds the missing array data
    type to Python so that we can perform calculations rapidly. Frankly, without it,
    Python would be unsuitable for implementing anything but the simplest of machine
    learning algorithms. However, with NumPy, Python immediately becomes the premier
    environment for machine learning research.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够快速操作数组数据至关重要。这就是 `numpy` 库发挥作用的地方。它为 Python 添加了缺失的数组数据类型，让我们能够快速执行计算。坦率地说，没有它，Python
    只适合实现最简单的机器学习算法。然而，有了 NumPy，Python 立刻成为了机器学习研究的首选环境。
- en: Testing Array and List Speed
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组与列表的速度测试
- en: Let’s see a quick example of how much speed NumPy gives us over pure Python.
    The code we’ll execute is in [Listing 3-1](ch03.xhtml#ch3lis1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下 NumPy 比纯 Python 提供的速度优势。我们将执行的代码在[列表 3-1](ch03.xhtml#ch3lis1)中。
- en: ❶ import numpy as np
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ import numpy as np
- en: import time
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import random
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: n = 1000000
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: n = 1000000
- en: a = [random.random() for i in range(n)]
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: a = [random.random() for i in range(n)]
- en: b = [random.random() for i in range(n)]
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: b = [random.random() for i in range(n)]
- en: s = time.time()
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: ❷ c = [a[i]*b[i] for i in range(n)]
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ c = [a[i]*b[i] for i in range(n)]
- en: print("comprehension:", time.time()-s)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: print("列表推导:", time.time()-s)
- en: s = time.time()
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: c = []
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: c = []
- en: '❸ for i in range(n):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for i in range(n):'
- en: c.append(a[i]*b[i])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: c.append(a[i]*b[i])
- en: print("for loop:", time.time()-s)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: print("for 循环:", time.time()-s)
- en: s = time.time()
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: ❹ c = [0]*n
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ c = [0]*n
- en: 'for i in range(n):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: c[i] = a[i]*b[i]
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: c[i] = a[i]*b[i]
- en: print("existing list:", time.time()-s)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: print("现有列表:", time.time()-s)
- en: ❺ x = np.array(a)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ x = np.array(a)
- en: y = np.array(b)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: y = np.array(b)
- en: s = time.time()
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: c = x*y
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: c = x*y
- en: print("NumPy time", time.time()-s)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: print("NumPy 时间", time.time()-s)
- en: '*Listing 3-1: Comparing NumPy to pure Python. See `numpy_speed_test.py`.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：将 NumPy 与纯 Python 进行比较。请参阅 `numpy_speed_test.py`。*'
- en: In [Listing 3-1](ch03.xhtml#ch3lis1), we first import the `numpy` library ❶
    and then create two lists of random numbers using a list comprehension. These
    lists include 1,000,000 elements each. Our goal is to multiply the two lists together,
    element by element, as quickly as possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 3-1](ch03.xhtml#ch3lis1) 中，我们首先导入 `numpy` 库❶，然后使用列表推导式创建两个包含 1,000,000
    个元素的随机数列表。我们的目标是尽可能快地将这两个列表逐个元素相乘。
- en: We can measure the time the program takes to run by logging our starting time
    in `s` and subtracting it from our ending time when we print. The `time` function
    of the `time` module returns the number of seconds, including fractions of a second,
    since a set origin time (January 1, 1970). We print `time.time()-s` after each
    operation we run.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `s` 中记录程序开始时间，并在打印时从结束时间中减去它，来衡量程序运行所需的时间。`time` 模块的 `time` 函数返回自设定起始时间（1970年1月1日）以来的秒数，包括秒的分数部分。我们在每次运行的操作后打印
    `time.time()-s`。
- en: In our first attempt to multiply `a` and `b`, we use a list comprehension ❷.
    Next, we use a loop ❸ to select each element from `a` and `b` and append their
    product to the list `c`. Note that this approach starts with an empty list and
    appends each new product to it so that the list needs to grow in memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次尝试将 `a` 和 `b` 相乘时，我们使用了列表推导式❷。接下来，我们使用一个循环❸来选择 `a` 和 `b` 中的每个元素，并将它们的乘积追加到列表
    `c` 中。注意，这种方法从一个空列表开始，并将每个新的乘积添加到其中，因此列表需要在内存中不断增长。
- en: As a third approach, we pre-allocate the output list so that instead of appending
    each output to `c`, we update the corresponding element of `c` ❹. This approach
    might be a bit faster—we’ll see.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第三种方法，我们预分配输出列表，这样我们就不再将每个输出追加到 `c` 中，而是更新 `c` 中相应的元素❹。这种方法可能会稍微快一点——我们来看看。
- en: Finally, we use NumPy to do the calculation ❺. We exclude the time it takes
    to make the two lists into NumPy arrays (lines 25–26) since we could have easily
    created the random arrays (vectors since they are 1D) with a call to the NumPy
    random number module. The entire operation with NumPy vectors is `c = x*y`. Notice
    that there’s no explicit looping. NumPy is an array-processing library, and it
    will automatically iterate over all the elements of the arrays for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 NumPy 进行计算❺。我们排除了将两个列表转换为 NumPy 数组所需的时间（第25–26行），因为我们本可以通过调用 NumPy 随机数模块轻松创建这些随机数组（向量，因为它们是
    1D）。使用 NumPy 向量的整个操作是 `c = x*y`。请注意，这里没有显式的循环。NumPy 是一个数组处理库，它会自动遍历数组中的所有元素。
- en: 'If we run the code in [Listing 3-1](ch03.xhtml#ch3lis1) ten times to get an
    average runtime for each of the four approaches, we find the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 [清单 3-1](ch03.xhtml#ch3lis1) 中的代码十次，以获得每四种方法的平均运行时间，我们会发现以下结果：
- en: '| ***Approach*** | ***Runtime (seconds, mean* ± *SE)*** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ***方法*** | ***运行时间（秒，平均值* ± *标准误差）*** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| List comprehension | 0.158855 ± 0.000426 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 列表推导式 | 0.158855 ± 0.000426 |'
- en: '| `for` loop | 0.226371 ± 0.000823 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `for` 循环 | 0.226371 ± 0.000823 |'
- en: '| `for` loop w/existing list | 0.201825 ± 0.000409 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `for` 循环与现有列表 | 0.201825 ± 0.000409 |'
- en: '| NumPy | 0.009253 ± 0.000027 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| NumPy | 0.009253 ± 0.000027 |'
- en: This table shows that NumPy is on average just under 25× faster than pure Python
    with a naïve implementation. This is why we want to use NumPy for machine learning
    in Python! Here, *SE* means *standard error of the mean*, which is the standard
    deviation divided by the square root of the number of values that went into the
    mean, 10 in this case. The *standard deviation* is a measure of how the values
    differ from the mean. A large standard deviation means that the values are spread
    over a broad range. These standard deviations are small, meaning the times are
    consistent from run to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这张表显示，NumPy 的平均速度比纯 Python 的初级实现快了接近 25 倍。这就是为什么我们想在 Python 中使用 NumPy 进行机器学习的原因！这里，*SE*
    指的是 *均值的标准误差*，它是标准差除以均值中数据个数的平方根，这里是 10。*标准差* 是衡量数值与均值之间差异的指标。标准差较大意味着数值分布在较广泛的范围内。这些标准差很小，意味着每次运行的时间都比较一致。
- en: '[Listing 3-1](ch03.xhtml#ch3lis1) shows us the true power of NumPy. Operations
    are immediately broadcast across compatible dimensions without requiring explicit
    loops. The normal linear algebra operations on vectors and matrices are also present,
    but in general, operations on NumPy arrays are performed automatically element-wise,
    without looping.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](ch03.xhtml#ch3lis1) 向我们展示了 NumPy 的真正强大之处。操作会立即跨兼容维度进行广播，而无需显式的循环。向量和矩阵上的常规线性代数操作也可以执行，但通常情况下，NumPy
    数组的操作是自动按元素执行的，无需循环。'
- en: Now that you’ve seen why we’re using NumPy, let’s take a look at some of its
    features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了我们为什么使用 NumPy，让我们来看一下它的一些特性。
- en: Basic Arrays
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本数组
- en: NumPy is all about arrays, so we’ll start there. Let’s dive right in with some
    basic examples and then explain what they do and why they look the way they do.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 完全围绕数组展开，因此我们从这里开始。让我们直接通过一些基本示例来进行探讨，然后解释它们的功能以及它们为何呈现出这样的形式。
- en: Defining an Array with np.array
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 np.array 定义数组
- en: 'Let’s start with some basic array creation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本的数组创建开始：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we define an array, `a`, using the `array` function. The argument to the
    `array` function needs to be something that NumPy can turn into an array. A list
    is something that NumPy can turn into an array, as is a tuple, so these are most
    often the arguments to the `array` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `array` 函数定义了一个数组 `a`。`array` 函数的参数需要是 NumPy 可以转换成数组的对象。列表是 NumPy 可以转换成数组的对象，元组也是如此，因此这些通常是
    `array` 函数的参数。
- en: If we ask Python to show us what’s in `a`, we’re told it’s an array and given
    the values. NumPy will display the contents of an array, but if the array has
    many elements, it will show us only the first and last few.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求 Python 显示 `a` 中的内容，它会告诉我们这是一个数组，并显示其值。NumPy 会显示数组的内容，但如果数组包含很多元素，它只会显示前几个和最后几个元素。
- en: 'We next ask for the three most common properties of a NumPy array: the size,
    the shape, and the data type (`dtype`). The array `a` has four elements, so its
    size is 4\. The size of an array is the number of elements it contains. The array
    `a` is a vector, meaning it’s only one-dimensional, so the shape is returned as
    a tuple, always, where the first and only dimension is 4, meaning there are four
    elements along the first dimension.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们询问 NumPy 数组的三个最常见属性：大小、形状和数据类型（`dtype`）。数组 `a` 包含四个元素，因此其大小为 4。数组的大小是指它包含的元素个数。数组
    `a` 是一个向量，这意味着它只有一维，因此它的形状以元组形式返回，始终如此，其中第一个也是唯一的维度为 4，意味着第一维上有四个元素。
- en: The data type is new in that Python normally doesn’t care about data types.
    But to be memory efficient, the `numpy` library has to care about them. When we
    created `a` using `array`, we didn’t specify a data type, so NumPy defaulted to
    64-bit integers because all the values in the list we gave to `array` were integers.
    If even one of them had been a float, NumPy would have instead defaulted to 64-bit
    floating-point numbers, the same as the `double` type in languages like C, C++,
    and Java.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是新的，因为 Python 通常不关心数据类型。但为了内存效率，`numpy` 库必须关心这些数据类型。当我们使用 `array` 创建 `a`
    时，我们没有指定数据类型，因此 NumPy 默认使用 64 位整数，因为我们传给 `array` 的列表中的所有值都是整数。如果其中有一个是浮点数，NumPy
    会改为默认使用 64 位浮点数，这与 C、C++ 和 Java 等语言中的 `double` 类型相同。
- en: 'Now let’s be explicit about the type of data that we want the NumPy array to
    hold:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们明确指定 NumPy 数组应包含的数据类型：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we define two arrays, `b` and `c`. Both arrays contain the same elements
    from the list `[1,2,3,4]`. However, notice the `dtype` keyword argument to `array`.
    This tells NumPy the data type to use for the array. For `b`, we are telling NumPy
    to use an unsigned 8-bit integer (`uint8`). This is a byte or a single ASCII character.
    If we ask for the `dtype` property, we are told that the array `b` is, indeed,
    of data type unsigned 8-bit integer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们定义了两个数组 `b` 和 `c`。两个数组都包含来自列表 `[1,2,3,4]` 的相同元素。然而，注意 `dtype` 关键字参数传递给了
    `array`。这告诉 NumPy 使用某种数据类型来创建数组。对于 `b`，我们告诉 NumPy 使用无符号 8 位整数（`uint8`）。这相当于一个字节或单个
    ASCII 字符。如果我们请求 `dtype` 属性，NumPy 会告诉我们数组 `b` 的确是无符号 8 位整数类型。
- en: The array `c` contains the same elements as `b`, but here we tell NumPy to make
    the array hold 64-bit floating-point numbers. Again, asking for the data type
    tells us that the array `c` is of the requested type. When working with NumPy,
    we must be aware of the type of data our arrays will hold.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `c` 包含与 `b` 相同的元素，但在这里我们告诉 NumPy 创建一个包含 64 位浮点数的数组。再次询问数据类型会告诉我们数组 `c` 的类型就是我们要求的类型。在使用
    NumPy 时，我们必须注意数组所包含的数据类型。
- en: The most commonly used NumPy data types, and their C equivalents, are given
    in [Table 3-1](ch03.xhtml#ch3tab1). When defining arrays, specify the NumPy data
    type as a string with the data type name. We will see examples of this next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 NumPy 数据类型及其 C 语言等效类型列在 [表 3-1](ch03.xhtml#ch3tab1) 中。在定义数组时，请通过数据类型名称的字符串来指定
    NumPy 数据类型。接下来我们将看到这些示例。
- en: '**Table 3-1:** NumPy Data Type Names, C Equivalents, and Range'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** NumPy 数据类型名称、C 语言等效类型及范围'
- en: '| **NumPy name** | **Equivalent C type** | **Range** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **NumPy 名称** | **C 等效类型** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| float64 | double | ± [2.225 × 10^(–308), 1.798 × 10^(308)] |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| float64 | 双精度浮点数 | ± [2.225 × 10^(–308), 1.798 × 10^(308)] |'
- en: '| float32 | float | ± [1.175 × 10^(–38), 3.403 × 10^(38)] |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| float32 | 浮点数 | ± [1.175 × 10^(–38), 3.403 × 10^(38)] |'
- en: '| int64 | long long | [–2^(63), 2^(63)–1] |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| int64 | 长长整型 | [–2^(63), 2^(63)–1] |'
- en: '| uint64 | unsigned long long | [0, 2^(64)–1] |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 无符号长长整型 | [0, 2^(64)–1] |'
- en: '| int32 | long | [–2^(31), 2^(31)–1 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| int32 | 长整型 | [–2^(31), 2^(31)–1] |'
- en: '| uint32 | unsigned long | [0, 2^(32)–1] |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 无符号长整型 | [0, 2^(32)–1] |'
- en: '| uint8 | unsigned char | [0, 255 = 2⁸–1] |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| uint8 | 无符号字符 | [0, 255 = 2⁸–1] |'
- en: 'So far, we’ve created only vectors with NumPy. Let’s look at how to create
    a matrix, a two-dimensional array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只用NumPy创建了向量。现在我们来看一下如何创建一个矩阵，即一个二维数组：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `array` function as before, but instead of a single list, we pass
    in a list of lists. Each element of the supplied list is itself a list of three
    elements, and there are three such lists. Therefore, the resulting NumPy array
    will be a 3×3 matrix. The first row of the matrix is the first list of three elements
    (`[1,2,3]`), the second row is the second list (`[4,5,6]`), and the third row
    is the third list (`[7,8,9]`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样使用`array`函数，但这次我们传递的是一个列表的列表。提供的列表中的每个元素本身是一个包含三个元素的列表，并且有三个这样的列表。因此，生成的NumPy数组将是一个3×3的矩阵。矩阵的第一行是第一个包含三个元素的列表（`[1,2,3]`），第二行是第二个列表（`[4,5,6]`），第三行是第三个列表（`[7,8,9]`）。
- en: If we ask for the shape of `d`, we’re told that it’s `(3, 3)`. This tuple says
    that there are two dimensions to the array, since there are two elements in the
    tuple, and that the first dimension has length 3 (three rows) and that the second
    dimension also has length 3 (three columns). Asking for the size of `d` tells
    us that there are nine elements. The size of a NumPy array is equal to the product
    of all the values in the tuple returned by `shape`, here 3 × 3 = 9.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查询`d`的形状，会得到`(3, 3)`。这个元组表示数组有两个维度，因为元组中有两个元素，且第一个维度的长度为3（即三行），第二个维度的长度也为3（三列）。查询`d`的大小会告诉我们它包含九个元素。NumPy数组的大小等于`shape`返回的元组中所有值的乘积，这里是3
    × 3 = 9。
- en: 'Asking for the array itself causes NumPy to print it. As the array is small,
    NumPy shows us the entire array as a two-dimensional matrix:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数组本身会导致NumPy输出它。由于数组很小，NumPy将整个数组显示为一个二维矩阵：
- en: '![image](Images/035equ01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/035equ01.jpg)'
- en: 'NumPy is not limited to two-dimensional arrays. For example, here’s a three-dimensional
    array:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy不仅限于二维数组。例如，这里有一个三维数组：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We know that `d` is three-dimensional because `shape` returns a tuple with three
    elements. We also know that `d` is three-dimensional because the list we passed
    to `array` contains two sublists, each of which contains two sublists with three
    elements each, hence a shape of `(2, 2, 3)`. NumPy displays `d` using a blank
    line between the two 2×2 subarrays. We can think of a three-dimensional array
    as a vector where each element of the vector is a matrix. We will use three-dimensional
    NumPy arrays to hold collections of images. For this example, `d` can be thought
    of as holding two images, each of two rows by three columns.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`d`是三维的，因为`shape`返回了一个包含三个元素的元组。我们也知道`d`是三维的，因为我们传递给`array`的列表包含两个子列表，每个子列表包含两个子列表，每个子列表有三个元素，因此形状为`(2,
    2, 3)`。NumPy使用一个空行来显示`d`，将两个2×2的子数组分开。我们可以将三维数组看作是一个向量，其中向量的每个元素都是一个矩阵。我们将使用三维的NumPy数组来存储图像集合。在这个例子中，`d`可以被看作是包含两张图片的数组，每张图片是由两行三列组成的。
- en: Defining Arrays with 0s and 1s
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用0和1定义数组
- en: 'Defining NumPy arrays with the `array` function would be very tedious if we
    wanted a large array since we need to supply the elements of the array. Fortunately,
    NumPy is not so cruel. Let’s look now at two NumPy workhorse functions that we’ll
    use often in this book. The first builds arrays where every element is initialized
    to 0:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个大数组，通过`array`函数定义NumPy数组会非常繁琐，因为我们需要提供数组的所有元素。幸运的是，NumPy并不会那么苛刻。现在我们来看两个在本书中将经常使用的NumPy常用函数，第一个函数构建一个所有元素都初始化为0的数组：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `zeros` function returns new arrays with every element set to 0\. The example
    defines `x` to be a three-dimensional array since the argument to `zeros` is the
    shape of the new array—in this case, the tuple `(2,3,4)`. This array can be thought
    of as a pair of tiny images, each 3×4 pixels. Notice that the default type for
    an array created with `zeros` is a 64-bit float (`dtype`). This means each element
    of the array uses 8 bytes in memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeros` 函数返回一个新数组，每个元素都初始化为 0。示例中定义了 `x` 为一个三维数组，因为传递给 `zeros` 的参数是新数组的形状——在这个例子中是元组
    `(2,3,4)`。这个数组可以被看作是一对小图片，每张图片是 3×4 像素。注意，使用 `zeros` 创建的数组的默认类型是 64 位浮动数（`dtype`）。这意味着数组的每个元素在内存中使用
    8 字节。'
- en: The array `b` has two dimensions, 10×10 elements, and we’ve explicitly declared
    it to be of 32-bit unsigned integers. This means that each element uses only 4
    bytes in memory. When using NumPy, we need to be aware of how much memory an array
    might be using to avoid allocating arrays that are exceptionally large or of a
    large data type, such as `float64`, that wastes memory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `b` 有两个维度，包含 10×10 个元素，我们已经明确声明它是 32 位无符号整数。这意味着每个元素只使用 4 字节的内存。在使用 NumPy
    时，我们需要注意数组可能使用的内存量，以避免分配过于庞大或使用大数据类型（如 `float64`）浪费内存的数组。
- en: 'Our second workhorse function is similar to `zeros` but instead initializes
    each element to 1:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个常用函数与 `zeros` 类似，但它会初始化每个元素为 1：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just like `zeros`, `ones` takes a tuple specifying the number of elements along
    each dimension of the array, here a 3×3 matrix. We can also optionally specify
    a `dtype` to make the array hold something other than 64-bit floats.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `zeros` 一样，`ones` 接受一个元组，指定数组每个维度的元素数量，这里是一个 3×3 的矩阵。我们还可以选择性地指定一个 `dtype`，使数组保存除
    64 位浮动数以外的其他数据类型。
- en: The real utility of `ones` is creating arrays initialized to any value. We do
    this by multiplying the `ones` array by the value we want, here 10\. Notice how
    NumPy realizes that we’re multiplying by a scalar value and performs the operation
    on every element of the array automatically—no loops required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ones` 的真正用途是创建初始化为任何值的数组。我们通过将 `ones` 数组乘以我们想要的值来做到这一点，这里是 10。注意，NumPy 会自动识别我们在与标量值相乘，并对数组中的每个元素执行操作——不需要循环。'
- en: We slipped in something new, the `astype` method. This method on an array returns
    a copy of the array, casting each element to the given data type. Note, casting
    to a data type that cannot hold the original values, like casting 64-bit floats
    to unsigned bytes, will result in data being lost. NumPy will do its best, but
    this is also something to be aware of when using NumPy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个新的方法，`astype` 方法。这个方法返回数组的副本，并将每个元素转换为指定的数据类型。注意，将数据类型转换为无法容纳原始值的类型，例如将
    64 位浮动数转换为无符号字节，将导致数据丢失。NumPy 会尽力处理，但这是使用 NumPy 时需要注意的事项。
- en: 'Finally, in Python, a list or dictionary object is passed by reference so that
    assigning one to a new variable doesn’t make a copy; it simply creates an alias
    that points back to the original memory. This saves time and space but can lead
    to unintended consequences if we get careless. The same is true with NumPy arrays.
    They can be very large, so it doesn’t make sense to copy them every time they
    are passed to a function. If you want to actually create a new copy of a NumPy
    array, use the `copy` method or an array slice that represents all the elements
    of the array. Unlike Python lists, NumPy arrays are flat: the value in a particular
    place in the array cannot be another array.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 Python 中，列表或字典对象是通过引用传递的，因此将其赋值给一个新变量并不会创建副本；它仅仅是创建一个指向原始内存的别名。这节省了时间和空间，但如果我们不小心，可能会导致意想不到的后果。NumPy
    数组也有同样的特点。它们可能非常大，因此每次将它们传递给函数时，复制它们是没有意义的。如果你想真正创建一个 NumPy 数组的副本，可以使用 `copy`
    方法或表示数组所有元素的数组切片。与 Python 列表不同，NumPy 数组是平坦的：数组中特定位置的值不能是另一个数组。
- en: 'So, all the following statements, except the second, create a copy of the array
    `a`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下所有语句，除了第二个，都将创建数组 `a` 的副本：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Changing an element of `a` will change the corresponding element of `b` since
    `b` is pointing to the same memory as `a`, but the elements of `c` and `d` will
    be unaffected.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `a` 的元素会改变 `b` 对应的元素，因为 `b` 指向与 `a` 相同的内存，但 `c` 和 `d` 的元素将不受影响。
- en: Accessing Elements in an Array
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问数组中的元素
- en: In this section, we’ll look at two different ways to access elements in an array.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两种不同的访问数组元素的方法。
- en: Indexing into an Array
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 索引数组
- en: 'Arrays aren’t much use if we can’t refer to the elements within them and update
    them when necessary. This is called *array indexing*. Understanding array indexing
    is critical to making good use of NumPy. Let’s jump in with some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能引用数组中的元素并在必要时更新它们，那么数组就没有多大用处。这就是*数组索引*。理解数组索引对于充分利用NumPy至关重要。让我们通过一些示例来深入了解：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We index arrays in the same way that we index lists, with square brackets:
    `[` begins the index and `]` ends it. In between the square brackets goes an expression
    that tells NumPy which elements of the array to return or assign—this is the *subscript*.
    A subscript is appended to an array name to specify one or more elements of the
    array.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与索引列表相同的方式索引数组，使用方括号：`[`表示索引的开始，`]`表示索引的结束。在方括号之间是一个表达式，告诉NumPy返回或赋值数组中的哪些元素——这就是*下标*。下标附加在数组名称后面，用来指定一个或多个数组元素。
- en: In the example above, `b` is a matrix of three rows and four columns with each
    element initialized to 0\. We see this when we evaluate `b`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`b`是一个三行四列的矩阵，每个元素都被初始化为0。当我们计算`b`时，可以看到这一点。
- en: 'Next, we do something new: we set up an assignment statement ❶ where the left-hand
    side of the statement is not a single variable name but a variable name with a
    subscript, the text `[0,1]`. This subscript tells NumPy that the value of the
    right-hand side of the statement, here just 1, should be put into the element
    of `b` at row 0 and column 1\. Likewise, NumPy should put a 2 into the element
    at row 1, column 0\. We see that NumPy did as we asked when we look at `b` and
    see that the second column of row 0 is now 1, and the first column of row 1 is
    now 2.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们做一些新尝试：我们设置了一个赋值语句 ❶，其中语句的左侧不是单一的变量名，而是带有下标的变量名`[0,1]`。这个下标告诉NumPy，语句右侧的值，这里是1，应该被放入`b`中第0行第1列的元素中。同样，NumPy应该将2放入第1行第0列的元素中。当我们查看`b`时，我们看到NumPy按照我们的要求执行了操作，结果是第0行的第二列现在是1，第1行的第一列现在是2。
- en: 'If we continue working with `b` as defined previously, we see how to ask NumPy
    for elements from the array:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续使用之前定义的`b`，我们可以看到如何从数组中请求元素：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since `b` is a matrix, we need subscripts to select a specific element of it,
    one for the row, another for the column. Therefore, `b[1,0]` should return the
    value in the second row and first column, as we see it does.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`b`是一个矩阵，我们需要使用下标来选择其中的特定元素，一个用于行，另一个用于列。因此，`b[1,0]`应该返回第二行第一列的值，正如我们所看到的那样。
- en: The next line uses a single subscript, `b[1]`, and returns the entire second
    row of `b`. This is a very useful feature that we’ll see in our own code throughout
    the book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用了单个下标`b[1]`，并返回了`b`的整个第二行。这是一个非常有用的功能，我们将在本书的代码中看到这一点。
- en: Lastly, if `b[1]` returns the entire second row of the matrix, `b`, then we
    can use `b[1][0]` to ask for the first element of that row. We see that it matches
    the result of the `b[1,0]` syntax we started with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`b[1]`返回整个矩阵`b`的第二行，那么我们可以使用`b[1][0]`来请求该行的第一个元素。我们看到它与我们最初使用的`b[1,0]`语法的结果一致。
- en: Slicing an Array
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组切片
- en: 'Accessing individual elements of an array, or an entire subarray, with a single
    index is useful, but NumPy is far more flexible than that. It’s possible to specify
    parts of the array by using *slicing*, which returns subarrays carved out of the
    larger array as if with a knife. Let’s look at how it works:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个索引访问数组的单个元素或整个子数组是有用的，但NumPy远比这更加灵活。我们可以通过使用*切片*来指定数组的部分内容，切片会像用刀一样从更大的数组中切出子数组。让我们看看它是如何工作的：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we use `arange`, which is the NumPy analogue of the Python `range` function,
    to set `a` to a vector of the digits [0,9]. We then ask for a slice of this vector,
    `a[1:4]`, and see that it returns `[1, 2, 3]`. The slice was specified with two
    values: the first is the starting index, 1, and the second is the ending index,
    4.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用`arange`，它是NumPy的Python `range`函数的类比，将`a`设置为数字[0,9]的向量。然后，我们请求这个向量的一部分，`a[1:4]`，结果返回了`[1,
    2, 3]`。切片是用两个值指定的：第一个是起始索引1，第二个是结束索引4。
- en: Wait—if the ending index is 4,then shouldn’t the slice have returned `[1, 2,
    3, 4]` instead? NumPy follows the Python convention for lists, so the ending index
    is never included in the returned subarray. We can read the slice as asking for
    all the elements of `a` starting at index 1 and up to *but not including* index
    4\. Mathematically, a slice given as `a[x:y]` means all elements, *i*, of `a`
    such that *x* ≤ *i* < *y*. Therefore, the second example, `a[3:7]`, now makes
    sense as it’s asking for all elements of `a` starting with index 3 up to but not
    including index 7.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——如果结束索引是 4，那么切片不是应该返回 `[1, 2, 3, 4]` 吗？NumPy 遵循 Python 列表的惯例，所以结束索引从不包含在返回的子数组中。我们可以理解切片为请求从索引
    1 开始，直到 *但不包括* 索引 4 的所有元素。在数学上，`a[x:y]` 这样的切片表示所有满足 *x* ≤ *i* < *y* 的元素 *i*。因此，第二个例子
    `a[3:7]` 现在是可以理解的，因为它请求从索引 3 开始，到 *但不包括* 索引 7 的所有元素。
- en: 'The slices selected all elements in the given range. NumPy allows for an optional
    third slice argument that specifies a step size. If not given, the step size is
    1\. Therefore, with `a` as a vector of the digits as before, we get this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些切片选取了给定范围内的所有元素。NumPy 还允许使用一个可选的第三个切片参数来指定步长。如果没有给出，步长默认为 1。因此，如果 `a` 作为一个包含数字的向量，如之前所示，我们得到如下结果：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first slice starts at the beginning of the array, index 0, and goes to index
    8 (but not including index 8) returning every second element. The second example
    does the same starting with index 3.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个切片从数组的开始位置（索引 0）开始，直到索引 8（但不包括索引 8），返回每隔一个元素。第二个例子做的是相同的操作，只是从索引 3 开始。
- en: 'Any part of the full slice syntax, `[x:y:z]`, may be omitted, but at least
    one colon must remain. If so, the default value is the first index (for `x`),
    the last index (for `y`), and 1 (for `z`). For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完整切片语法的任何部分 `[x:y:z]` 都可以省略，但至少必须保留一个冒号。如果省略某部分，默认值将是第一个索引（对于 `x`），最后一个索引（对于
    `y`），以及步长 1（对于 `z`）。例如：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first example, the starting index is omitted so it defaults to 0 and
    we’re given the first six elements of `a`. In the second example, the ending index
    is omitted so it defaults to the last index, meaning “return everything from index
    6 to the end.” In both cases, the increment was omitted and defaulted to 1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，起始索引被省略，所以默认值是 0，返回 `a` 的前六个元素。在第二个例子中，结束索引被省略，所以默认值是最后一个索引，意味着“返回从索引
    6 到结尾的所有元素。”在这两个例子中，步长省略了，默认值为 1。
- en: 'Array slicing leads to some handy shortcuts. Two are given here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片提供了一些便捷的快捷方式。这里给出两个例子：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first example shows us that like Python lists, NumPy arrays can be indexed
    with negative values to count from the end of an axis. So, asking for index –1
    will always return the last element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子向我们展示了，像 Python 列表一样，NumPy 数组可以通过负数索引从轴的末尾开始计数。因此，索引 -1 总是返回最后一个元素。
- en: The second example is a bit mysterious at first. We know that `a` is a vector
    of the digits from 0 through 9\. The example returns the vector in reverse order.
    How? Let’s break down the meaning of `::-1`. We said that any part of the array
    slice notation can be omitted, and if it is, the default is either the first index,
    the last index, or the increment. In this case, the first index is omitted so
    it defaults to 0\. The required colon (`:`) is present, and then the last index
    is omitted so it defaults to the last index. Then there’s a `:` for the increment,
    which is given as –1, to count backward from the ending index to the starting
    index. This is what counts backward and reverses the elements of the array.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子一开始有点神秘。我们知道 `a` 是一个包含数字 0 到 9 的向量。这个例子返回了该向量的逆序。怎么做到的呢？我们来解析一下 `::-1`
    的含义。我们说过，数组切片的任何部分都可以省略，如果省略了，默认值将是第一个索引、最后一个索引或步长。在这种情况下，第一个索引被省略，所以它默认是 0。需要的冒号（`:`）存在，然后最后一个索引被省略，所以它默认是最后一个索引。接着是步长的冒号，步长给定为
    -1，用于从结束索引倒数到起始索引。这就是如何反转数组元素的方式。
- en: 'Naturally, array slicing works with NumPy arrays with any number of dimensions.
    Let’s look at slicing a two-dimensional matrix:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，数组切片也适用于任何维度的 NumPy 数组。让我们看一下对二维矩阵进行切片的例子：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We define `b` to be a vector of the numbers [0,19] by using `arange` and then
    immediately use `reshape` to change the vector into a matrix of four rows and
    five columns. The argument to `reshape` is a tuple specifying the new shape for
    the array. There must be exactly as many elements in the array as the new shape.
    The vector had 20 elements, and the new shape has 4 × 5 = 20 elements, so we are
    okay in this case.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`b`定义为一个包含[0,19]的向量，通过`arange`生成，然后立即使用`reshape`将该向量转变为一个具有四行五列的矩阵。`reshape`的参数是一个元组，指定了数组的新形状。数组中的元素数量必须与新形状一致。向量有20个元素，新的形状是4
    × 5 = 20个元素，因此在这种情况下是可以的。
- en: 'Array slicing applies per dimension, so the second example, `b[1:3,:]` is asking
    for rows 1 and 2 and all the columns in those rows. That is what : by itself means—all
    the elements along that axis.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片按维度应用，因此第二个例子`b[1:3,:]`请求的是第1和第2行以及这些行中的所有列。这就是单独使用`:`的意思——该轴上所有的元素。
- en: The next example asks for all the rows and columns starting with row 2 and column
    2\. This is the submatrix pulled from the lower-right corner of the full matrix
    `b`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例请求从第2行、第2列开始的所有行和列。这是从完整矩阵`b`的右下角提取的子矩阵。
- en: The Ellipsis
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 省略号
- en: 'NumPy supports a shorthand notation for slicing that’s sometimes useful. Let’s
    show it and then discuss what it’s doing. First, however, we need to define some
    arrays to work with:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy支持一种有时很有用的切片简写符号。我们先展示它，然后讨论它的作用。不过，首先我们需要定义一些数组来操作：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First we define `c` to be a three-dimensional array with three elements along
    each dimension. We use the same `reshape` trick that we used previously, and we
    know it will work because 3 × 3 × 3 = 27 and there are 27 elements in the initial
    vector produced by `arange`. Again, we can think of `c` as three 3×3 images stacked
    together. Next we use `ones` to define a simple 3×3 matrix with every value set
    to 1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义`c`为一个三维数组，每个维度上有三个元素。我们使用之前的`reshape`技巧，知道它会起作用，因为3 × 3 × 3 = 27，而通过`arange`生成的初始向量有27个元素。我们可以将`c`看作是三个3×3的图像堆叠在一起。接下来，我们使用`ones`定义一个简单的3×3矩阵，所有值都设置为1。
- en: 'From our discussion of array slicing so far, we know that we can replace the
    3×3 subarray in `c` for any particular “image” by using the colon notation. For
    example, let’s replace the second “image” of `c` by `a`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前对数组切片的讨论中，我们知道通过使用冒号符号，可以替换`c`中的任何特定“图像”的3×3子数组。例如，我们来用`a`替换`c`中的第二个“图像”：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we tell NumPy to replace the second subarray, which is 3×3, with the 3×3
    array in `a`. It’s the second subarray because the first index is given as 1\.
    When we print `c`, we see that the second 3×3 subarray is now all 1s.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉NumPy将第二个子数组（一个3×3的数组）替换为`a`中的3×3数组。之所以是第二个子数组，是因为第一个索引为1。当我们打印`c`时，会看到第二个3×3子数组现在全是1。
- en: 'Now for the shorthand notation. This time, we want to replace the first 3×3
    subarray of `c` with `a`. We could do this with a syntax of `c[0,:,:]` but instead
    we’ll use the shorthand notation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看简写符号。这次，我们希望用`a`替换`c`的第一个3×3子数组。我们本可以使用`c[0,:,:]`这样的语法，但我们将使用简写符号：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that instead of `c[0,:,:]`, where we specified all the indices of all
    the remaining dimensions of `c`, we used `c[0,...]` which NumPy interprets as
    meaning “and as many colons as necessary to cover all the remaining dimensions.”
    Of course, the shape of `a` must match the shape of the subarray specified by
    all the remaining dimensions. In this example, there are two remaining dimensions
    and `a` is a two-dimensional array, so we do match. The ellipsis notation (`...`)
    is commonly used in Python code related to machine learning, so that’s why I mention
    it here. You could argue that from a readability standpoint, using `...` is not
    a good idea because it requires the reader of the code to remember how many dimensions
    a particular array has.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`c[0,:,:]`（我们指定了`c`的所有剩余维度的索引）不同，我们使用了`c[0,...]`，NumPy将其解释为“用尽可能多的冒号来覆盖所有剩余维度”。当然，`a`的形状必须与所有剩余维度指定的子数组形状匹配。在这个例子中，剩余维度有两个，`a`是一个二维数组，因此它们是匹配的。省略号符号（`...`）在与机器学习相关的Python代码中常常被使用，所以我在这里提到它。你可以说，从可读性的角度来看，使用`...`并不是一个好主意，因为它要求代码的读者记住特定数组的维度数量。
- en: Operators and Broadcasting
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符和广播
- en: 'NumPy uses all the standard math operators as well as a heap of other methods
    and functions that implement more advanced operations. NumPy also uses a concept
    called *broadcasting* to decide how to apply an operator to arrays. Let’s look
    at some simple operators and broadcasting:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy使用所有标准数学运算符，以及大量其他方法和函数来实现更高级的操作。NumPy还使用一个叫做*广播*的概念来决定如何将操作符应用于数组。让我们看一些简单的运算符和广播的例子：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From earlier examples, we know that `a` is a vector of the digits 0 through
    4\. And, we know because of our discussion of array slicing, that `c` is a vector
    of the digits 4 down to 0, the reverse of `a`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的例子中，我们知道`a`是一个包含数字0到4的向量。而且，通过我们对数组切片的讨论，我们知道`c`是一个从4到0的数字向量，实际上是`a`的反向。
- en: With that in mind, we see that multiplying `a` by 3.14 multiplies each element
    by 3.14\. NumPy has broadcast the scalar 3.14 across all the elements of the array
    `a`. NumPy would do this no matter what shape `a` has. Operating on an array with
    a scalar performs the operation on all elements of the array, regardless of its
    shape.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以看到，将`a`乘以3.14会将每个元素乘以3.14。NumPy将标量3.14广播到数组`a`的所有元素上。无论`a`的形状如何，NumPy都会这么做。对数组进行标量操作时，会对数组的所有元素执行该操作，无论数组的形状如何。
- en: The expression `a*a` multiplies `a` by itself. In this case, NumPy sees that
    the two arrays have the same shape, so it multiplies corresponding elements, thereby
    squaring each element of `a`. Multiplying `a` by `c` is also straightforward because
    `c` has the same shape as `a`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`a*a`将`a`与其自身相乘。在这种情况下，NumPy发现这两个数组具有相同的形状，因此它会逐个元素相乘，从而对`a`中的每个元素进行平方。将`a`与`c`相乘也很简单，因为`c`与`a`的形状相同。
- en: The last example uses broadcasting twice. First, it broadcasts the scalar 1
    across `c` to add one to each element of `c`. This operation does not change the
    shape of `c`, so dividing `a` by using integer division (`//` not `/`), by the
    expression `(c+1)`, works since each has the same shape.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子使用了两次广播。首先，它通过广播标量1到`c`上，使`c`的每个元素都加1。这个操作并不会改变`c`的形状，因此通过整数除法（`//`而不是`/`）使用表达式`(c+1)`对`a`进行除法操作是可行的，因为它们的形状相同。
- en: 'Let’s look at some more examples. There’s no end to the number of examples
    we could give, but one more small set should cement the concepts for us. First
    a more complex broadcasting example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些更多的例子。我们可以给出无数个例子，但再举一个小例子应该可以帮助我们巩固这些概念。首先是一个更复杂的广播例子：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remember that `a` is a vector of digits. We then define `b` to be a 5×5 matrix
    of the numbers 0 through 24\. Next, we multiply `a` and `b`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`a`是一个包含数字的向量。然后我们定义`b`为一个5×5的矩阵，包含数字0到24。接下来，我们将`a`和`b`相乘。
- en: At this point, you should object. How can we multiply these two arrays when
    their shapes don’t match? The array `a` has only 5 elements, while `b` has 25\.
    This is where broadcasting comes into play. NumPy recognizes that the five-element
    vector in `a` matches the size of each *row* of `b` so it multiplies each row
    of `b` by `a` to return a new 5×5 matrix. This sort of broadcasting is actually
    quite handy. We’ll be storing our datasets primarily as two-dimensional NumPy
    arrays, where each row is a sample and the columns correspond to input values
    for that sample.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你应该提出疑问。我们怎么能在两个数组的形状不匹配的情况下相乘呢？数组`a`只有5个元素，而`b`有25个元素。这就是广播发挥作用的地方。NumPy识别到`a`中的5个元素向量与`b`的每一*行*的大小匹配，因此它将`a`与`b`的每一行相乘，返回一个新的5×5矩阵。这种广播实际上非常方便。我们将主要以二维NumPy数组的形式存储数据集，其中每一行是一个样本，每一列对应该样本的输入值。
- en: 'NumPy also supports matrix math operations. These are the operations on vectors
    and matrices that we find in linear algebra. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还支持矩阵数学操作。这些是我们在线性代数中遇到的向量和矩阵操作。例如：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we define `x` to be a simple vector of five elements. We then introduce
    NumPy’s primary vector and matrix product function, `dot`, to multiply `x` by
    itself. We already know that if we multiply `x` by itself in the standard way,
    using `x*x`, we’ll get each element times itself, giving `[0,1,4,9,16]`, but that’s
    not what we get here. Instead we get the scalar value, 30\. Why?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义`x`为一个简单的包含五个元素的向量。然后我们引入NumPy的主要向量和矩阵乘积函数`dot`，用它来将`x`与自身相乘。我们已经知道，如果按照标准方法将`x`与自身相乘，使用`x*x`，我们将得到每个元素自乘的结果，得到`[0,1,4,9,16]`，但这里得到的却不是这个结果，而是标量值30。为什么？
- en: 'The answer has to do with what `dot` does. It doesn’t implement element-wise
    multiplication but instead implements linear algebra multiplication. Specifically,
    because both arguments to `dot` are vectors, it implements vector times vector,
    which is known as the *dot product*, hence the name of the NumPy function. The
    dot product for vectors multiplies each element of the first vector by the corresponding
    element of the second vector and then adds all those products together. So, for
    `dot(x,x)` NumPy is calculating as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与`dot`的作用有关。它并不执行元素级的乘法，而是实现了线性代数的乘法。具体来说，由于`dot`的两个参数都是向量，它实现了向量与向量的乘法，这就是所谓的*点积*，因此NumPy函数得名“dot”。向量的点积是将第一个向量的每个元素与第二个向量的相应元素相乘，然后将所有这些积相加。所以，对于`dot(x,x)`，NumPy是这样计算的：
- en: '[0, 1, 2, 3, 4] × [0, 1, 2, 3, 4] = [0, 1, 4, 9, 16]; 0 + 1 + 4 + 9 + 16 =
    30'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 2, 3, 4] × [0, 1, 2, 3, 4] = [0, 1, 4, 9, 16]; 0 + 1 + 4 + 9 + 16 =
    30'
- en: The `dot` function can be used to multiply two vectors, a vector and a matrix,
    or two matrices, all following the rules of linear algebra, which are beyond the
    scope of this book to explore in detail. That said, the `dot` function is of great
    importance to us because it is the workhorse function of machine learning with
    NumPy. In the end, most of modern machine learning boils down to math with vectors
    and matrices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`dot`函数可以用于两个向量、一个向量与一个矩阵，或者两个矩阵的乘法，所有这些都遵循线性代数的规则，这些规则超出了本书的讨论范围。话虽如此，`dot`函数对我们来说非常重要，因为它是NumPy中机器学习的主要计算函数。最终，现代机器学习大多数都归结为向量和矩阵的数学运算。'
- en: 'Let’s look at an example using `dot` with two matrices:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用`dot`进行两个矩阵运算的例子：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we define both `a` and `b` to be the same 3×3 matrix of the digits 0 through
    9\. We then use `dot` with these two matrices. For comparison purposes, we also
    show normal multiplication of the two matrices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将`a`和`b`都定义为相同的3×3矩阵，包含数字0到9。然后，我们使用`dot`函数对这两个矩阵进行运算。为了对比，我们还展示了这两个矩阵的普通乘法。
- en: 'The two results are not the same. The first uses linear algebra rules for multiplying
    two 3×3 matrices, which says that the first element of the 3×3 output will be
    the first column of `b`, [0, 3, 6], multiplied element by element with the first
    row of `a`, [0, 1, 2], with each product summed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个结果并不相同。第一个结果使用线性代数规则来乘法运算两个3×3矩阵，规则是3×3输出的第一个元素将是矩阵`b`的第一列[0, 3, 6]与矩阵`a`的第一行[0,
    1, 2]逐元素相乘，并将每个积相加：
- en: '[0, 3, 6] × [0, 1, 2] = [0, 3, 12]; 0 + 3 + 12 = 15'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 3, 6] × [0, 1, 2] = [0, 3, 12]; 0 + 3 + 12 = 15'
- en: A similar process creates each of the other entries. For the simple multiplication,
    the first element of the 3×3 output is simply 0 × 0 = 0.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的过程也会创建其他每个条目的值。对于简单的乘法，3×3输出的第一个元素就是0 × 0 = 0。
- en: 'If the inputs to `dot` are matrices, then `dot` acts as we expect: it’s matrix
    multiplication. It’s when one of the inputs is a vector and the other a matrix
    that things get a little sloppy. NumPy is somewhat careless about whether the
    vector is a row or column vector—it produces the correct result regardless, though
    the shape of the result might not follow linear algebra rules precisely.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dot`的输入是矩阵，那么`dot`会按我们预期的方式执行：它是矩阵乘法。问题出现在一个输入是向量，另一个是矩阵时，事情就有点混乱。NumPy在是否将向量视为行向量或列向量时有些不太严格——它会正确计算结果，尽管结果的形状可能不完全符合线性代数规则。
- en: We trudged through the linear algebra examples because as you continue to explore
    machine learning, you’ll encounter code using `dot` quite frequently. It’s good
    to know what it does, but because of its tolerance of the shape of its inputs,
    you might need to work through the code paying careful attention to the actual
    shapes of your arrays to avoid getting lost.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们艰难地走过了这些线性代数例子，因为当你继续探索机器学习时，会经常遇到使用`dot`的代码。了解它的作用是好的，但由于它对输入形状的宽容，你可能需要仔细查看代码，特别注意数组的实际形状，以免迷失。
- en: Array Input and Output
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组输入和输出
- en: NumPy would be difficult to use if it didn’t provide the means for storing arrays
    on disk and reading arrays from disk. Sure, we could use a standard Python module
    like `pickle`, but that’s inefficient and makes interchange between software packages
    difficult. Fortunately for us, the creators of NumPy were thorough and included
    input/output functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供在磁盘上存储数组和从磁盘读取数组的功能，NumPy将很难使用。当然，我们可以使用像`pickle`这样的标准Python模块，但那样效率低下，并且会使不同软件包之间的交换变得困难。幸运的是，NumPy的创建者考虑周全，包含了输入/输出函数。
- en: 'In the following, we’ll refer to several disk files. The first is *abc.txt*,
    which looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将涉及几个磁盘文件。第一个是*abc.txt*，看起来是这样的：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s a file of three lines with three numbers per line separated by a space.
    The second is *abc_tab.txt*, which is identical to *abc.txt*, but the spaces have
    been replaced by a tab character, `\t` in Python. Tab-delimited files are commonly
    used to store data in files. The last file is *abc.csv*, which is a comma-separated
    values (CSV) file often used by spreadsheet programs. It’s also the same as *abc.txt*,
    but the spaces have been replaced by commas. Now, let’s look at NumPy’s basic
    input/output capabilities.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个三行文件，每行有三个数字，用空格分隔。第二个是*abc_tab.txt*，与*abc.txt*相同，但空格被制表符`\t`替换。在Python中，制表符分隔的文件通常用于存储文件中的数据。最后一个文件是*abc.csv*，是逗号分隔值（CSV）文件，常用于电子表格程序。它与*abc.txt*相同，但空格被逗号替换。现在，让我们看看NumPy的基本输入/输出能力。
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first three examples use `loadtxt`, which reads text files and produces
    NumPy arrays from them. The first two examples show that `loadtxt` knows how to
    parse files with values separated by spaces and tab characters. The function uses
    the rows of the text file as rows of the matrix, and the values on each line as
    the elements in each row.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个示例使用`loadtxt`从文本文件中读取数据，并生成NumPy数组。前两个示例显示了`loadtxt`如何解析使用空格和制表符分隔值的文件。该函数将文本文件的行用作矩阵的行，并将每行的值用作每行的元素。
- en: The third example explicitly states that the delimiter (separator) between values
    in the text file is the comma character (`,`) ❶. This is how to read a *.csv*
    file in NumPy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子明确说明了文本文件中值之间的分隔符是逗号字符（`,`）❶。这是在NumPy中读取*.csv*文件的方法。
- en: NumPy uses the `save` function to write arrays to disk ❷. This function writes
    a single array to the given filename. NumPy uses a *.npy* file extension to identify
    the file as containing a NumPy array. We’ll make extensive use of *.npy* files
    throughout this book.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy使用`save`函数将数组写入磁盘 ❷。此函数将单个数组写入指定的文件名。NumPy使用*.npy*文件扩展名标识包含NumPy数组的文件。我们将在本书中广泛使用*.npy*文件。
- en: To read an array back into memory from disk, use `load` ❸. Note that the data
    in the array is loaded, but you must assign it to a new variable name. The *.npy*
    file doesn’t store the original name of the array.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要从磁盘中读取数组到内存中，请使用`load` ❸。注意，数组中的数据被加载，但必须将其分配给一个新的变量名。*.npy*文件不会存储数组的原始名称。
- en: Sometimes we’ll want to write arrays in a format that will be readable by other
    programs or humans. On those occasions, we’ll use the `savetxt` function ❹. These
    examples write text files, first using spaces between values and then using a
    comma between values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望以其他程序或人类可读的格式写入数组。在这些场合，我们将使用`savetxt`函数 ❹。这些示例写入文本文件，首先使用值之间的空格，然后使用逗号。
- en: What if we want to write multiple arrays to disk? Are we forced to use a single
    file for each array? Fortunately, no, we can use `savez` and read them with `load`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将多个数组写入磁盘，应该使用单个文件吗？幸运的是，不用，我们可以使用`savez`保存它们，并用`load`读取。
- en: 'For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we store the two arrays, `a` and `b`, to a single file, *arrays.npz* ❶.
    We still read the file with `load`, but instead of the arrays, `q` is more like
    a dictionary so that if we ask for the keys as a list ❷, we get a list of the
    names of the arrays read from the file. Referencing an array by its name returns
    it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将数组`a`和`b`存储到单个文件*arrays.npz* ❶中。我们仍然使用`load`读取文件，但是`q`更像一个字典，因此如果我们请求键作为列表
    ❷，我们将得到从文件中读取的数组名称列表。通过其名称引用数组会返回它。
- en: 'Look again at the call to `savez` ❶. Notice how we specified the arrays? This
    is the keyword approach, and it gives the arrays the keyword name, which we made
    the same as the variable name so that when we asked for the keys after opening
    the file, we got back the names we expect. We could have dispensed with the keyword
    names and simply used the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看对`savez`的调用 ❶。注意我们如何指定数组？这是关键字方法，它给数组分配了关键字名称，我们使其与变量名相同，以便在打开文件后请求键时，我们得到预期的名称。我们本可以省略关键字名称，只需使用以下内容：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This would write the arrays to the file by using default names of `arr_0` and
    `arr_1`. Lastly, since arrays can be quite large, we might want to compress them
    (losslessly!), and for that, we’d have used `savez_compressed` in place of `savez`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用默认名称`arr_0`和`arr_1`将数组写入文件。最后，由于数组可能相当大，我们可能希望对其进行压缩（无损！），为此，我们将使用`savez_compressed`替代`savez`。
- en: Compression might be worth it, but it does slow reading and writing. For example,
    a 64-bit floating-point array of 10 million element requires at a minimum 80,000,000
    bytes of memory. Using `savez` to write such an array to disk uses 80,000,244
    bytes and takes only a fraction of a second. The extra 244 bytes are overhead
    for the structure of the dictionary. Writing the compressed file to disk takes
    a second or two but results in a file of 11,960,115 bytes, considerably smaller.
    Since this example was made using `arange`, each element of the output array was
    unique so the compression is not the result of storing an array of 10 million
    zeros. For the curious, storing 10 million zeros uncompressed still uses 80,000,244
    bytes but compressed uses only 77,959 bytes on disk. So, the more redundant the
    array, the more the savings when compressed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩可能是值得的，但会减慢读写速度。例如，一个包含 1000 万个元素的 64 位浮点数数组至少需要 80,000,000 字节的内存。使用 `savez`
    将这样的数组写入磁盘需要使用 80,000,244 字节，并且只需不到一秒钟的时间。额外的 244 字节是字典结构的开销。将压缩文件写入磁盘需要一两秒钟，但结果是一个大小为
    11,960,115 字节的文件，远比原始文件小。由于这个例子是使用 `arange` 生成的，因此输出数组的每个元素都是唯一的，所以压缩并非是存储 1000
    万个零的结果。好奇的人可以了解，存储 1000 万个零的未压缩文件仍然需要 80,000,244 字节，但压缩后在磁盘上仅使用了 77,959 字节。因此，数组越是冗余，压缩时节省的空间就越多。
- en: Random Numbers
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机数
- en: NumPy has extensive support for pseudorandom number generation. We’ll be sloppy
    and simply call them *random numbers*, understanding that computers are not capable
    by any algorithmic process of producing actual random numbers—if you’re curious
    about pseudorandom number generation, you can read my book, *Random Numbers and
    Computers* (Springer 2018). The NumPy random number library is under `random`
    and can generate samples from many different distributions, the most common being
    a uniform distribution, [0,1). This means that any (representable) floating-point
    number in that range is equally likely. Usually, this is what we want. At other
    times we might want to use a normal distribution that looks like the classic bell-shaped
    curve. Many physical processes follow this curve. NumPy can generate such samples
    as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 在伪随机数生成方面有着广泛的支持。我们会简单地称它们为 *随机数*，理解到计算机通过任何算法过程都不可能生成真正的随机数——如果你对伪随机数生成感兴趣，可以阅读我的书籍
    *Random Numbers and Computers*（Springer 2018）。NumPy 随机数库位于 `random` 下，可以从许多不同的分布中生成样本，其中最常见的是均匀分布
    [0,1)。这意味着该范围内的任何（可表示的）浮点数具有相等的可能性。通常这是我们想要的。其他时候，我们可能希望使用类似于经典钟形曲线的正态分布。许多物理过程遵循这种曲线。NumPy
    也可以生成这样的样本。
- en: The random number functions we’ll use in this book are `random.random` to generate
    random numbers from [0,1), `random.normal` to generate random numbers drawn from
    a bell-shaped curve, and `random.seed` to set the seed of the generator so we
    can produce the same sequence of random numbers over and over. We’ll leave it
    to the philosophers to decide if such a sequence still deserves the label *random*
    or, for that matter, if it ever did, regardless of the seed value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们将使用的随机数函数有 `random.random` 用于生成区间 [0,1) 内的随机数，`random.normal` 用于生成服从钟形曲线分布的随机数，以及
    `random.seed` 用于设置生成器的种子，使我们能够反复生成相同的随机数序列。关于这样的序列是否依然应该被称为 *随机*，或者说它曾经是否应该，我们将这些问题留给哲学家来决定，无论种子值如何。
- en: NumPy and Images
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy 和图像
- en: Some of the datasets we’ll use are image based. We’ll want to work with the
    datasets in NumPy, so we need to know something about how to work with images
    in Python and how to get images into and out of NumPy arrays. Fortunately, it’s
    pretty straightforward. Besides NumPy, we’ll need to work with the Pillow module
    (`PIL`) to read and write images. We have Pillow installed already—it comes with
    the installation of our main toolkits. We also have some sample images as part
    of `sklearn`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的一些数据集是基于图像的。我们希望在 NumPy 中处理这些数据集，因此需要了解如何在 Python 中处理图像以及如何将图像导入和导出 NumPy
    数组。幸运的是，这是相当直接的。除了 NumPy 外，我们还需要使用 Pillow 模块（`PIL`）来读取和写入图像。我们已经安装了 Pillow ——它随我们主要工具包的安装而来。我们也有一些样本图像作为
    `sklearn` 的一部分。
- en: We need to think in terms of two worlds when working with images. There’s the
    “NumPy” world, where the image has been converted into a NumPy array, and there’s
    the `PIL` world that reads and writes images in common graphics formats like JPEG
    and PNG. The distinction really isn’t so black-and-white—we can do image processing
    in `PIL` too, and sometimes that is more convenient; but for now, we’ll use `PIL`
    only as a way to read and write image files.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Images are two-dimensional arrays of numbers, but if the image is color, we
    will have three or even four numbers for each pixel, each a byte value representing
    the intensity of the red, green, blue, and sometimes, alpha, channels of the image.
    We’ll assume that all of our images are either one-channel grayscale or three-channel
    RGB. We’ll eliminate any alpha channel when we encounter one. The alpha channel
    determines how transparent the pixel is.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s see how to get at the example images `sklearn` provides and how
    to turn them into `PIL` images, store them on disk, and display them:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we need to import `PIL` ❶ and the sample images function from `sklearn`.
    Once we have those, we can get at the actual images as NumPy arrays ❷. We see
    that the *china* and *flower* images are three-dimensional arrays, meaning they
    are RGB images. The images are 427×640 pixels. The third dimension is 3, corresponding
    to the red, green, and blue channels. If the images were grayscale, they would
    have only two dimensions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We can convert the NumPy arrays to `PIL` image objects ❸ by using the `fromarray`
    function. The argument is assumed to be a NumPy array of the proper format for
    conversion. Usually this means that the array must have a data type of `uint8`.
    Once we have the `PIL` image objects, we can view the images with the `show` method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: To write the images to disk as actual graphics files, not NumPy arrays, we use
    the `save` method on the `PIL` objects ❹. The format of the output file is determined
    by the file extension. Here we’re using PNG.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: To read an image file from disk, we use the `open` function ❺. Note that `open`
    returns a `PIL` image object, not a NumPy array.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to turn the `PIL` image object into a NumPy array. Also, let’s
    see how to use `PIL` to make a color image grayscale before turning it into a
    NumPy array. We’ll use each of these steps later in the book:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We first load the image from disk into a `PIL` image object, `im`. We then pass
    the image object to NumPy via the `array` function ❶. This function is savvy enough
    to recognize a `PIL` image object and make the proper conversion to a NumPy array.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We can also turn the `PIL` RGB image into a grayscale image using the `convert`
    method. Note that `PIL` uses `L` for *luminance* to refer to grayscale images
    ❷. Again, `array` converts the now grayscale image into a NumPy array. We see
    that the image has only two dimensions, as we would expect from a grayscale image,
    where each pixel value is just a shade of gray, not a color.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The `PIL` module has many other abilities. It’s a good idea to look at the Pillow
    website, *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*,
    to see the other things you can do with PIL.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`PIL`模块还有许多其他功能。最好去看看Pillow官网，*([https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/))*，了解你可以用PIL做的其他事情。'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed how to work with NumPy, the foundational toolkit
    used by both `sklearn` and Keras. This gives us the background we need to understand
    the code examples we’ll see later in the book. It’s essential to understand how
    to use NumPy, at least at a basic level. The examples in this chapter should help.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了如何使用NumPy，这是`sklearn`和Keras都使用的基础工具包。这为我们后续理解书中的代码示例提供了背景知识。理解如何使用NumPy，至少在基础层面上，是至关重要的。本章中的示例应该能帮助你掌握这一点。
- en: Now that we’re familiar with NumPy, we are ready to dive into working with data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了NumPy，准备好开始处理数据了。
