- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: USING NUMPY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NUMPY**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: NumPy is foundational to all of the machine learning we’ll explore in this book.
    If you’re already comfortable with NumPy, you can skip this chapter. If you’re
    not, don’t be shy; consider this chapter a refresher and dive in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是本书中所有机器学习内容的基础。如果你已经熟悉 NumPy，可以跳过本章。如果不熟悉，不要害羞，把本章当作复习，尽情深入学习吧。
- en: A full tutorial of NumPy is beyond what we can cover here, so if you’re interested,
    you can look further at *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的完整教程超出了我们在此讨论的范围，所以如果你有兴趣，可以进一步查阅 *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*。
- en: Why NumPy?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择 NumPy？
- en: 'Python is an elegant programming language but it lacks an important data structure
    that’s fundamental to scientific and mathematical programming: the array. Yes,
    you could use a dictionary as an array, or a sizeable predefined list, but this
    would be an abuse of those data structures—and, more practically, it would be
    slow. Let’s look at the difference in implementation between an array and a list.
    Python lists are more advanced than the notion of a list we’re using here, but
    in essence they’re the same.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种优雅的编程语言，但它缺乏一个对科学和数学编程至关重要的数据结构：数组。是的，你可以使用字典作为数组，或者使用一个预定义的较大列表，但这会滥用这些数据结构——而且，更实际的是，这样会很慢。让我们来看看数组和列表之间的实现差异。Python
    列表比我们这里使用的列表概念更为先进，但本质上它们是一样的。
- en: Arrays vs. Lists
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组与列表
- en: The *array* is simply a fixed-size block of *contiguous* memory, a single block
    of RAM with no gaps, used to represent a set of *n* elements, each of which uses
    exactly *m* bytes. For example, an IEEE 754 double precision floating-point number
    occupies 64 bits of memory, 8 bytes, and is what Python uses under the hood for
    its float data type. Therefore, an array of *n* = 100 Python floats would occupy,
    at a minimum, *nm* = 100(8) = 800 bytes of memory. If Python had arrays as a data
    structure, it would allocate 800 bytes of memory and point the array variable
    name, A, to the memory as in [Figure 3-1](ch03.xhtml#ch3fig1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 只是一个固定大小的*连续*内存块，是一块没有空隙的单一 RAM 区域，用来表示一个包含 *n* 个元素的集合，每个元素占用恰好 *m* 字节。例如，一个
    IEEE 754 双精度浮点数占用 64 位内存，即 8 字节，Python 在底层使用这一格式来表示其 float 数据类型。因此，一个包含 *n* =
    100 个 Python 浮点数的数组至少会占用 *nm* = 100(8) = 800 字节内存。如果 Python 有数组这种数据结构，它将分配 800
    字节内存，并将数组变量名 A 指向该内存区域，如[图 3-1](ch03.xhtml#ch3fig1)所示。'
- en: '![image](Images/03fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/03fig01.jpg)'
- en: '*Figure 3-1: An array stored in contiguous memory*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：存储在连续内存中的数组*'
- en: Whenever we want to access an element of the array, say x[3], we can very quickly
    calculate the exact location in memory by adding 3(8) = 24 to the memory address
    of the base of the array. This is the indexing operation for an array.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想访问数组的一个元素，比如 x[3]，我们可以通过将 3(8) = 24 加到数组基址的内存地址，快速计算出该元素在内存中的精确位置。这就是数组的索引操作。
- en: 'Multidimensional arrays are also stored in memory as contiguous blocks, and
    the indexing operation is only slightly more complicated. A *multi-dimensional
    array* uses two or more numbers to index the elements. Think of a chess board;
    two numbers are needed to determine the location of a piece: the row and the column.
    Therefore, the chess board is a two-dimensional array. If we add one more dimension
    to turn the chess board into a stack of chess boards, we need three numbers to
    locate a piece: the row, the column, and the board number. Therefore, we have
    a three-dimensional array.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组也存储在内存中作为连续的内存块，索引操作只是稍微复杂一点。*多维数组* 使用两个或更多的数字来索引元素。想象一个棋盘；需要两个数字来确定棋子的所在位置：行和列。因此，棋盘是一个二维数组。如果我们再增加一个维度，将棋盘变成一个棋盘堆叠，则需要三个数字来定位棋子：行、列和棋盘编号。因此，我们有了一个三维数组。
- en: We will use arrays with one, two, and three dimensions throughout the book.
    All of these are stored in memory as a single block of RAM. The point is, an array
    is quick to index, and therefore operations on array elements can be performed
    very quickly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用一维、二维和三维数组。这些数组都作为一个连续的内存块存储。重点是，数组的索引操作非常快速，因此可以非常高效地对数组元素进行操作。
- en: Contrast this with a list. [Figure 3-2](ch03.xhtml#ch3fig2) shows the basic
    structure of a list, B, in memory. In this case, the elements in the list are
    not in contiguous memory, but are scattered throughout RAM with pointers linking
    one element to the next, like a chain. Each link in the chain contains the data
    value we want to store and a pointer to the memory of the next link in the chain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与列表进行对比。[图 3-2](ch03.xhtml#ch3fig2)展示了内存中列表 B 的基本结构。在这种情况下，列表中的元素并不是存储在连续的内存空间中，而是分散在
    RAM 中，通过指针将一个元素与下一个元素连接，像一条链条。链条中的每个链接包含我们要存储的数据值，以及指向链中下一个链接内存的指针。
- en: '![image](Images/03fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig02.jpg)'
- en: '*Figure 3-2: A list stored as a collection of linked nodes scattered throughout
    memory*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：以一系列散布在内存中的链接节点形式存储的列表*'
- en: We can’t index into a list by just adding an offset to a base memory address.
    Instead, if we want the fourth element of the list, then we need to start at the
    head of the list, use the link there to the next element, and the next, and the
    next, to reach the memory associated with the fourth element, the 3 in [Figure
    3-2](ch03.xhtml#ch3fig2). This isn’t too bad until we want to index the 1,000,000th
    element and have to repeat the process 1 million times instead of adding 8 million
    once to a base address.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能通过仅仅将偏移量添加到基本内存地址来索引列表。相反，如果我们想要列表中的第四个元素，那么我们需要从列表的头部开始，利用那里到下一个元素的链接，再到下一个，再到下一个，直到找到与第四个元素相关联的内存，即[图
    3-2](ch03.xhtml#ch3fig2)中的 3。这个过程还不算太麻烦，直到我们想要索引第 1,000,000 个元素，并且不得不重复这个过程一百万次，而不是一次性将
    8 百万加到基本地址上。
- en: Most machine learning involves arrays. If the array has a single dimension,
    we call it a *vector*; vectors are the inputs to many of our models. If the array
    has two dimensions, it’s a *matrix*. A matrix can be thought of as a chess board
    or an image where each pixel of the image is one of the board locations. Matrices
    can also be an input to our models, or used internally by the model; for example,
    the weight matrices of a neural network, or the convolution kernels and filter
    outputs of a convolutional neural network are matrices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数机器学习任务涉及数组。如果数组只有一个维度，我们称之为*向量*；向量是许多模型的输入。如果数组有两个维度，它就是*矩阵*。矩阵可以被看作是棋盘或图像，每个像素代表棋盘上的一个位置。矩阵也可以作为我们模型的输入，或者由模型内部使用；例如，神经网络的权重矩阵，或卷积神经网络的卷积核和滤波器输出都是矩阵。
- en: Therefore, it’s critically important to be able to quickly operate on array
    data. This is where the numpy library comes in. It adds the missing array data
    type to Python so that we can perform calculations rapidly. Frankly, without it,
    Python would be unsuitable for implementing anything but the simplest of machine
    learning algorithms. However, with NumPy, Python immediately becomes the premier
    environment for machine learning research.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够快速操作数组数据至关重要。这就是 numpy 库的用武之地。它为 Python 增加了缺失的数组数据类型，使我们能够快速进行计算。坦率地说，没有它，Python
    不适合实现复杂的机器学习算法。然而，有了 NumPy，Python 立即成为机器学习研究的首选环境。
- en: Testing Array and List Speed
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试数组和列表的速度
- en: Let’s see a quick example of how much speed NumPy gives us over pure Python.
    The code we’ll execute is in [Listing 3-1](ch03.xhtml#ch3lis1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一个示例，看看 NumPy 相较于纯 Python 能提高多少速度。我们将执行的代码在[清单 3-1](ch03.xhtml#ch3lis1)中。
- en: ❶ import numpy as np
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ import numpy as np
- en: import time
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import random
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: n = 1000000
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: n = 1000000
- en: a = [random.random() for i in range(n)]
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: a = [random.random() for i in range(n)]
- en: b = [random.random() for i in range(n)]
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: b = [random.random() for i in range(n)]
- en: s = time.time()
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: ❷ c = [a[i]*b[i] for i in range(n)]
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ c = [a[i]*b[i] for i in range(n)]
- en: print("comprehension:", time.time()-s)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: print("列表推导式:", time.time()-s)
- en: s = time.time()
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: c = []
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: c = []
- en: '❸ for i in range(n):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for i in range(n):'
- en: c.append(a[i]*b[i])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: c.append(a[i]*b[i])
- en: print("for loop:", time.time()-s)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: print("for 循环:", time.time()-s)
- en: s = time.time()
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: ❹ c = [0]*n
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ c = [0]*n
- en: 'for i in range(n):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: c[i] = a[i]*b[i]
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: c[i] = a[i]*b[i]
- en: print("existing list:", time.time()-s)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: print("现有列表:", time.time()-s)
- en: ❺ x = np.array(a)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ x = np.array(a)
- en: y = np.array(b)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: y = np.array(b)
- en: s = time.time()
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: s = time.time()
- en: c = x*y
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: c = x*y
- en: print("NumPy time", time.time()-s)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: print("NumPy 时间", time.time()-s)
- en: '*Listing 3-1: Comparing NumPy to pure Python. See numpy_speed_test.py.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：将 NumPy 与纯 Python 进行比较。请参见 numpy_speed_test.py。*'
- en: In [Listing 3-1](ch03.xhtml#ch3lis1), we first import the numpy library ❶ and
    then create two lists of random numbers using a list comprehension. These lists
    include 1,000,000 elements each. Our goal is to multiply the two lists together,
    element by element, as quickly as possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 3-1](ch03.xhtml#ch3lis1)中，我们首先导入numpy库❶，然后使用列表推导式创建两个包含1,000,000个元素的随机数列表。我们的目标是尽可能快速地将这两个列表逐元素相乘。
- en: We can measure the time the program takes to run by logging our starting time
    in s and subtracting it from our ending time when we print. The time function
    of the time module returns the number of seconds, including fractions of a second,
    since a set origin time (January 1, 1970). We print time.time()-s after each operation
    we run.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过记录程序的开始时间（单位为秒），然后从结束时间中减去它来测量程序的运行时间。当我们打印时，time模块的time函数返回自设定起始时间（1970年1月1日）以来的秒数，包括秒的小数部分。我们在每次运行操作后打印time.time()-s。
- en: In our first attempt to multiply a and b, we use a list comprehension ❷. Next,
    we use a loop ❸ to select each element from a and b and append their product to
    the list c. Note that this approach starts with an empty list and appends each
    new product to it so that the list needs to grow in memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次尝试将a和b相乘时，我们使用了列表推导式❷。接下来，我们使用循环❸从a和b中选择每个元素，并将它们的乘积附加到列表c中。请注意，这种方法从一个空列表开始，并将每个新的乘积附加到其中，因此列表需要在内存中增长。
- en: As a third approach, we pre-allocate the output list so that instead of appending
    each output to c, we update the corresponding element of c ❹. This approach might
    be a bit faster—we’ll see.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第三种方法，我们预先分配了输出列表，这样我们就不需要将每个输出附加到c，而是更新c中相应的元素❹。这种方法可能稍微快一些——我们将看看结果。
- en: Finally, we use NumPy to do the calculation ❺. We exclude the time it takes
    to make the two lists into NumPy arrays (lines 25–26) since we could have easily
    created the random arrays (vectors since they are 1D) with a call to the NumPy
    random number module. The entire operation with NumPy vectors is c = x*y. Notice
    that there’s no explicit looping. NumPy is an array-processing library, and it
    will automatically iterate over all the elements of the arrays for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用NumPy进行计算❺。我们排除了将两个列表转换为NumPy数组（第25-26行）所花费的时间，因为我们本可以轻松地使用NumPy随机数模块创建随机数组（由于它们是一维的，所以是向量）。整个NumPy向量操作是c
    = x*y。注意，这里没有显式的循环。NumPy是一个数组处理库，它会自动遍历所有数组元素。
- en: 'If we run the code in [Listing 3-1](ch03.xhtml#ch3lis1) ten times to get an
    average runtime for each of the four approaches, we find the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行[Listing 3-1](ch03.xhtml#ch3lis1)中的代码十次，以获取四种方法的平均运行时间，我们会得到以下结果：
- en: '| ***Approach*** | ***Runtime (seconds, mean* ± *SE)*** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ***方法*** | ***运行时间（秒，均值* ± *SE）*** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| List comprehension | 0.158855 ± 0.000426 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 列表推导式 | 0.158855 ± 0.000426 |'
- en: '| for loop | 0.226371 ± 0.000823 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| for循环 | 0.226371 ± 0.000823 |'
- en: '| for loop w/existing list | 0.201825 ± 0.000409 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 带有现有列表的for循环 | 0.201825 ± 0.000409 |'
- en: '| NumPy | 0.009253 ± 0.000027 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| NumPy | 0.009253 ± 0.000027 |'
- en: This table shows that NumPy is on average just under 25× faster than pure Python
    with a naïve implementation. This is why we want to use NumPy for machine learning
    in Python! Here, *SE* means *standard error of the mean*, which is the standard
    deviation divided by the square root of the number of values that went into the
    mean, 10 in this case. The *standard deviation* is a measure of how the values
    differ from the mean. A large standard deviation means that the values are spread
    over a broad range. These standard deviations are small, meaning the times are
    consistent from run to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该表显示，NumPy的平均速度比纯Python的简单实现快了大约25倍。这就是为什么我们在Python中进行机器学习时想要使用NumPy！这里，*SE*表示*均值的标准误差*，即标准差除以参与计算均值的值的平方根，在此例中是10。*标准差*是衡量数据点与均值之间差异的一个指标。标准差较大意味着数据值分布在较宽的范围内。由于这些标准差很小，说明每次运行的时间是一致的。
- en: '[Listing 3-1](ch03.xhtml#ch3lis1) shows us the true power of NumPy. Operations
    are immediately broadcast across compatible dimensions without requiring explicit
    loops. The normal linear algebra operations on vectors and matrices are also present,
    but in general, operations on NumPy arrays are performed automatically element-wise,
    without looping.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-1](ch03.xhtml#ch3lis1)展示了NumPy的真正强大之处。操作会立即广播到兼容的维度，而无需显式的循环。向量和矩阵上的常规线性代数操作也可以使用，但通常，NumPy数组上的操作是逐元素自动执行的，而无需循环。'
- en: Now that you’ve seen why we’re using NumPy, let’s take a look at some of its
    features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了我们为什么要使用NumPy，接下来我们来看看它的一些功能。
- en: Basic Arrays
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本数组
- en: NumPy is all about arrays, so we’ll start there. Let’s dive right in with some
    basic examples and then explain what they do and why they look the way they do.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 完全是围绕数组的，因此我们从这里开始。让我们先从一些基本的例子开始，然后解释它们的功能以及为什么它们看起来是这样的。
- en: Defining an Array with np.array
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 np.array 定义一个数组
- en: 'Let’s start with some basic array creation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些基本的数组创建开始：
- en: '>>> import numpy as np'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import numpy as np'
- en: '>>> a = np.array([1,2,3,4])'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.array([1,2,3,4])'
- en: '>>> a'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([1, 2, 3, 4])
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: array([1, 2, 3, 4])
- en: '>>> a.size'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.size'
- en: '4'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> a.shape'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.shape'
- en: (4,)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (4,)
- en: '>>> a.dtype'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.dtype'
- en: dtype('int64')
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('int64')
- en: Here we define an array, a, using the array function. The argument to the array
    function needs to be something that NumPy can turn into an array. A list is something
    that NumPy can turn into an array, as is a tuple, so these are most often the
    arguments to the array function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 `array` 函数定义了一个数组 a。传递给 `array` 函数的参数需要是 NumPy 可以转换为数组的东西。列表是 NumPy 可以转换为数组的类型，元组也是，因此这些通常是传递给
    `array` 函数的参数。
- en: If we ask Python to show us what’s in a, we’re told it’s an array and given
    the values. NumPy will display the contents of an array, but if the array has
    many elements, it will show us only the first and last few.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让 Python 展示数组 a 的内容，它会告诉我们这是一个数组，并给出值。NumPy 会显示数组的内容，但如果数组有很多元素，它只会显示前几个和最后几个元素。
- en: 'We next ask for the three most common properties of a NumPy array: the size,
    the shape, and the data type (dtype). The array a has four elements, so its size
    is 4\. The size of an array is the number of elements it contains. The array a
    is a vector, meaning it’s only one-dimensional, so the shape is returned as a
    tuple, always, where the first and only dimension is 4, meaning there are four
    elements along the first dimension.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查询 NumPy 数组的三个最常见属性：大小、形状和数据类型 (`dtype`)。数组 a 有四个元素，因此它的大小是 4。数组的大小是它包含的元素数量。数组
    a 是一个向量，意味着它只有一个维度，因此返回的形状是一个元组，其中第一个也是唯一一个维度为 4，表示第一维包含四个元素。
- en: The data type is new in that Python normally doesn’t care about data types.
    But to be memory efficient, the numpy library has to care about them. When we
    created a using array, we didn’t specify a data type, so NumPy defaulted to 64-bit
    integers because all the values in the list we gave to array were integers. If
    even one of them had been a float, NumPy would have instead defaulted to 64-bit
    floating-point numbers, the same as the double type in languages like C, C++,
    and Java.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是新的，因为 Python 通常不关心数据类型。但为了提高内存效率，numpy 库必须关心数据类型。当我们使用 `array` 创建数组时，并没有指定数据类型，因此
    NumPy 默认使用 64 位整数，因为我们给 `array` 的列表中所有值都是整数。如果其中有一个值是浮点数，NumPy 会默认使用 64 位浮点数，这与
    C、C++ 和 Java 等语言中的 double 类型相同。
- en: 'Now let’s be explicit about the type of data that we want the NumPy array to
    hold:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们明确指定我们希望 NumPy 数组存储的数据类型：
- en: '>>> b = np.array([1,2,3,4], dtype="uint8")'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.array([1,2,3,4], dtype="uint8")'
- en: '>>> b.dtype'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b.dtype'
- en: dtype('uint8')
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('uint8')
- en: '>>> c = np.array([1,2,3,4], dtype="float64")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = np.array([1,2,3,4], dtype="float64")'
- en: '>>> c.dtype'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c.dtype'
- en: dtype('float64')
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('float64')
- en: Here we define two arrays, b and c. Both arrays contain the same elements from
    the list [1,2,3,4]. However, notice the dtype keyword argument to array. This
    tells NumPy the data type to use for the array. For b, we are telling NumPy to
    use an unsigned 8-bit integer (uint8). This is a byte or a single ASCII character.
    If we ask for the dtype property, we are told that the array b is, indeed, of
    data type unsigned 8-bit integer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了两个数组 b 和 c。两个数组都包含来自列表 [1,2,3,4] 的相同元素。然而，请注意 `array` 中的 `dtype` 关键字参数。这告诉
    NumPy 使用什么数据类型来创建数组。对于 b，我们告诉 NumPy 使用无符号 8 位整数（uint8），即一个字节或一个 ASCII 字符。如果我们查询
    `dtype` 属性，我们会看到数组 b 确实是无符号 8 位整数类型。
- en: The array c contains the same elements as b, but here we tell NumPy to make
    the array hold 64-bit floating-point numbers. Again, asking for the data type
    tells us that the array c is of the requested type. When working with NumPy, we
    must be aware of the type of data our arrays will hold.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 c 包含与 b 相同的元素，但这里我们告诉 NumPy 使数组存储 64 位浮点数。同样，查询数据类型告诉我们数组 c 是请求的类型。在使用 NumPy
    时，我们必须注意数组将存储的数据类型。
- en: The most commonly used NumPy data types, and their C equivalents, are given
    in [Table 3-1](ch03.xhtml#ch3tab1). When defining arrays, specify the NumPy data
    type as a string with the data type name. We will see examples of this next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 NumPy 数据类型及其 C 语言中的对应类型，请参见 [表 3-1](ch03.xhtml#ch3tab1)。在定义数组时，使用数据类型名称的字符串来指定
    NumPy 数据类型。接下来我们将看到相关的示例。
- en: '**Table 3-1:** NumPy Data Type Names, C Equivalents, and Range'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** NumPy 数据类型名称、C 语言等效类型和范围'
- en: '| **NumPy name** | **Equivalent C type** | **Range** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **NumPy 名称** | **C 语言等效类型** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| float64 | double | ± [2.225 × 10^(–308), 1.798 × 10^(308)] |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| float64 | 双精度浮动小数型 | ± [2.225 × 10^(–308), 1.798 × 10^(308)] |'
- en: '| float32 | float | ± [1.175 × 10^(–38), 3.403 × 10^(38)] |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| float32 | 浮动小数型 | ± [1.175 × 10^(–38), 3.403 × 10^(38)] |'
- en: '| int64 | long long | [–2^(63), 2^(63)–1] |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| int64 | 长整型 | [–2^(63), 2^(63)–1] |'
- en: '| uint64 | unsigned long long | [0, 2^(64)–1] |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 无符号长整型 | [0, 2^(64)–1] |'
- en: '| int32 | long | [–2^(31), 2^(31)–1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| int32 | 长整型 | [–2^(31), 2^(31)–1 |'
- en: '| uint32 | unsigned long | [0, 2^(32)–1] |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 无符号长整型 | [0, 2^(32)–1] |'
- en: '| uint8 | unsigned char | [0, 255 = 2⁸–1] |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| uint8 | 无符号字符型 | [0, 255 = 2⁸–1] |'
- en: 'So far, we’ve created only vectors with NumPy. Let’s look at how to create
    a matrix, a two-dimensional array:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用 NumPy 创建了向量。接下来看看如何创建矩阵，一个二维数组：
- en: '>>> d = np.array([[1,2,3],[4,5,6],[7,8,9]])'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = np.array([[1,2,3],[4,5,6],[7,8,9]])'
- en: '>>> d.shape'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.shape'
- en: (3, 3)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (3, 3)
- en: '>>> d.size'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.size'
- en: '9'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '>>> d'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: array([[1, 2, 3],
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: array([[1, 2, 3],
- en: '[4, 5, 6],'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 6],'
- en: '[7, 8, 9]])'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[7, 8, 9]])'
- en: We use the array function as before, but instead of a single list, we pass in
    a list of lists. Each element of the supplied list is itself a list of three elements,
    and there are three such lists. Therefore, the resulting NumPy array will be a
    3×3 matrix. The first row of the matrix is the first list of three elements ([1,2,3]),
    the second row is the second list ([4,5,6]), and the third row is the third list
    ([7,8,9]).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用和之前相同的 array 函数，但这次我们传入的是一个列表的列表，而不是单一的列表。提供的列表的每个元素本身是一个包含三个元素的列表，总共有三个这样的列表。因此，结果的
    NumPy 数组将是一个 3×3 的矩阵。矩阵的第一行是第一个包含三个元素的列表 ([1,2,3])，第二行是第二个列表 ([4,5,6])，第三行是第三个列表
    ([7,8,9])。
- en: If we ask for the shape of d, we’re told that it’s (3, 3). This tuple says that
    there are two dimensions to the array, since there are two elements in the tuple,
    and that the first dimension has length 3 (three rows) and that the second dimension
    also has length 3 (three columns). Asking for the size of d tells us that there
    are nine elements. The size of a NumPy array is equal to the product of all the
    values in the tuple returned by shape, here 3 × 3 = 9.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求 d 的形状，系统会告诉我们它是 (3, 3)。这个元组表示数组有两个维度，因为元组中有两个元素，第一个维度长度为 3（三行），第二个维度也为
    3（三列）。请求 d 的大小会告诉我们它包含九个元素。NumPy 数组的大小等于 shape 返回的元组中所有值的乘积，这里是 3 × 3 = 9。
- en: 'Asking for the array itself causes NumPy to print it. As the array is small,
    NumPy shows us the entire array as a two-dimensional matrix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请求数组本身会导致 NumPy 打印出来。由于数组很小，NumPy 会将整个数组作为二维矩阵显示：
- en: '![image](Images/035equ01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/035equ01.jpg)'
- en: 'NumPy is not limited to two-dimensional arrays. For example, here’s a three-dimensional
    array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 不仅限于二维数组。例如，下面是一个三维数组：
- en: '>>> d = np.array([[[1,11,111],[2,22,222]],'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = np.array([[[1,11,111],[2,22,222]],'
- en: '[[3,33,333],[4,44,444]]])'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3,33,333],[4,44,444]]])'
- en: '>>> d.shape'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.shape'
- en: (2, 2, 3)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 2, 3)
- en: '>>> d'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: array([[[  1,  11, 111],
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: array([[[ 1, 11, 111],
- en: '[  2,  22, 222]],'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 2, 22, 222]],'
- en: '[[  3,  33, 333],'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 3, 33, 333],'
- en: '[  4,  44, 444]]])'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 4, 44, 444]]])'
- en: We know that d is three-dimensional because shape returns a tuple with three
    elements. We also know that d is three-dimensional because the list we passed
    to array contains two sublists, each of which contains two sublists with three
    elements each, hence a shape of (2, 2, 3). NumPy displays d using a blank line
    between the two 2×2 subarrays. We can think of a three-dimensional array as a
    vector where each element of the vector is a matrix. We will use three-dimensional
    NumPy arrays to hold collections of images. For this example, d can be thought
    of as holding two images, each of two rows by three columns.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 d 是三维的，因为 shape 返回的是一个包含三个元素的元组。我们还知道 d 是三维的，因为传递给 array 的列表包含两个子列表，每个子列表包含两个包含三个元素的子列表，因此形状为
    (2, 2, 3)。NumPy 在两个 2×2 子数组之间显示 d 时，会插入一个空行。我们可以将三维数组视为一个向量，其中向量的每个元素都是一个矩阵。我们将使用三维
    NumPy 数组来存储图像集合。在这个示例中，d 可以被视为存储了两张图片，每张图片有两行三列。
- en: Defining Arrays with 0s and 1s
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义包含 0 和 1 的数组
- en: 'Defining NumPy arrays with the array function would be very tedious if we wanted
    a large array since we need to supply the elements of the array. Fortunately,
    NumPy is not so cruel. Let’s look now at two NumPy workhorse functions that we’ll
    use often in this book. The first builds arrays where every element is initialized
    to 0:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用array函数定义NumPy数组会非常繁琐，尤其是当我们想要一个大数组时，因为我们需要提供数组的所有元素。幸运的是，NumPy并不那么残忍。现在让我们看看两种在本书中经常使用的NumPy核心函数。第一个函数用于创建每个元素初始化为0的数组：
- en: '>>> x = np.zeros((2,3,4))'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = np.zeros((2,3,4))'
- en: '>>> x.shape'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x.shape'
- en: (2, 3, 4)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 3, 4)
- en: '>>> x.dtype'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x.dtype'
- en: dtype('float64')
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('float64')
- en: '>>> b = np.zeros((10,10),dtype="uint32")'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.zeros((10,10),dtype="uint32")'
- en: '>>> b.shape'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b.shape'
- en: (10, 10)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (10, 10)
- en: '>>> b.dtype'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b.dtype'
- en: dtype('uint32')
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('uint32')
- en: The zeros function returns new arrays with every element set to 0\. The example
    defines x to be a three-dimensional array since the argument to zeros is the shape
    of the new array—in this case, the tuple (2,3,4). This array can be thought of
    as a pair of tiny images, each 3×4 pixels. Notice that the default type for an
    array created with zeros is a 64-bit float (dtype). This means each element of
    the array uses 8 bytes in memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: zeros函数返回新数组，数组中的每个元素都被设置为0。这个例子将x定义为一个三维数组，因为zeros函数的参数是新数组的形状——在这个例子中是元组(2,3,4)。可以将这个数组视为一对小图像，每个图像大小为3×4像素。注意，使用zeros创建的数组的默认数据类型是64位浮点数（dtype）。这意味着每个数组元素占用8个字节的内存。
- en: The array b has two dimensions, 10×10 elements, and we’ve explicitly declared
    it to be of 32-bit unsigned integers. This means that each element uses only 4
    bytes in memory. When using NumPy, we need to be aware of how much memory an array
    might be using to avoid allocating arrays that are exceptionally large or of a
    large data type, such as float64, that wastes memory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组b有两个维度，包含10×10个元素，我们已经显式声明它为32位无符号整数。这意味着每个元素只占用4个字节的内存。在使用NumPy时，我们需要关注数组可能占用的内存量，以避免分配异常大的数组或数据类型较大的数组，例如float64，这会浪费内存。
- en: 'Our second workhorse function is similar to zeros but instead initializes each
    element to 1:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个核心函数类似于zeros，但它会将每个元素初始化为1：
- en: '>>> y = np.ones((3,3))'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = np.ones((3,3))'
- en: '>>> y'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y'
- en: array([[1., 1., 1.],
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: array([[1., 1., 1.],
- en: '[1., 1., 1.],'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[1., 1., 1.],'
- en: '[1., 1., 1.]])'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[1., 1., 1.]])'
- en: '>>> y = 10*np.ones((3,3))'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = 10*np.ones((3,3))'
- en: '>>> y'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y'
- en: array([[10., 10., 10.],
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: array([[10., 10., 10.],
- en: '[10., 10., 10.],'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[10., 10., 10.],'
- en: '[10., 10., 10.]])'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[10., 10., 10.]])'
- en: '>>> y.dtype'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y.dtype'
- en: dtype('float64')
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('float64')
- en: '>>> y.astype("uint8")'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y.astype("uint8")'
- en: array([[10, 10, 10],
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: array([[10, 10, 10],
- en: '[10, 10, 10],'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 10, 10],'
- en: '[10, 10, 10]], dtype=uint8)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 10, 10]], dtype=uint8)'
- en: Just like zeros, ones takes a tuple specifying the number of elements along
    each dimension of the array, here a 3×3 matrix. We can also optionally specify
    a dtype to make the array hold something other than 64-bit floats.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与zeros一样，ones接受一个元组，指定数组每个维度的元素数量，这里是一个3×3的矩阵。我们也可以选择性地指定dtype，使数组存储其他类型的数据，而不是64位浮点数。
- en: The real utility of ones is creating arrays initialized to any value. We do
    this by multiplying the ones array by the value we want, here 10\. Notice how
    NumPy realizes that we’re multiplying by a scalar value and performs the operation
    on every element of the array automatically—no loops required.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ones的实际用途是创建初始化为任意值的数组。我们通过将ones数组与所需值相乘来实现这一点，这里是10。注意，NumPy会自动识别我们正在与一个标量值相乘，并对数组的每个元素执行该操作——无需循环。
- en: We slipped in something new, the astype method. This method on an array returns
    a copy of the array, casting each element to the given data type. Note, casting
    to a data type that cannot hold the original values, like casting 64-bit floats
    to unsigned bytes, will result in data being lost. NumPy will do its best, but
    this is also something to be aware of when using NumPy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个新方法，astype方法。这个方法作用于一个数组，返回该数组的副本，并将每个元素转换为指定的数据类型。请注意，转换为无法容纳原始值的数据类型（例如将64位浮点数转换为无符号字节）会导致数据丢失。NumPy会尽力处理，但在使用NumPy时需要注意这一点。
- en: 'Finally, in Python, a list or dictionary object is passed by reference so that
    assigning one to a new variable doesn’t make a copy; it simply creates an alias
    that points back to the original memory. This saves time and space but can lead
    to unintended consequences if we get careless. The same is true with NumPy arrays.
    They can be very large, so it doesn’t make sense to copy them every time they
    are passed to a function. If you want to actually create a new copy of a NumPy
    array, use the copy method or an array slice that represents all the elements
    of the array. Unlike Python lists, NumPy arrays are flat: the value in a particular
    place in the array cannot be another array.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 Python 中，列表或字典对象是通过引用传递的，因此将其赋给一个新变量不会创建副本；它只是创建一个指向原始内存的别名。这节省了时间和空间，但如果我们不小心，可能会导致意外后果。NumPy
    数组也是如此。它们可能非常大，因此每次将它们传递给函数时复制它们是没有意义的。如果你想真正创建一个 NumPy 数组的副本，可以使用 `copy` 方法或表示数组所有元素的数组切片。与
    Python 列表不同，NumPy 数组是扁平的：数组中特定位置的值不能是另一个数组。
- en: 'So, all the following statements, except the second, create a copy of the array
    a:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除了第二条，所有以下语句都会创建数组 a 的副本：
- en: '>>> a = np.arange(10)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.arange(10)'
- en: '>>> b = a'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = a'
- en: '>>> c = a.copy()'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = a.copy()'
- en: '>>> d = a[:]'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = a[:]'
- en: Changing an element of a will change the corresponding element of b since b
    is pointing to the same memory as a, but the elements of c and d will be unaffected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 a 中的一个元素将改变 b 中对应的元素，因为 b 指向与 a 相同的内存，但 c 和 d 中的元素不会受到影响。
- en: Accessing Elements in an Array
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问数组中的元素
- en: In this section, we’ll look at two different ways to access elements in an array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两种不同的方式来访问数组中的元素。
- en: Indexing into an Array
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组索引
- en: 'Arrays aren’t much use if we can’t refer to the elements within them and update
    them when necessary. This is called *array indexing*. Understanding array indexing
    is critical to making good use of NumPy. Let’s jump in with some examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能引用数组中的元素并在必要时更新它们，那么数组就没什么用处了。这就是所谓的*数组索引*。理解数组索引对于充分利用 NumPy 至关重要。让我们通过一些示例来了解一下：
- en: '>>> b = np.zeros((3,4),dtype=''uint8'')'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.zeros((3,4),dtype=''uint8'')'
- en: '>>> b'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: array([[0, 0, 0, 0],
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: array([[0, 0, 0, 0],
- en: '[0, 0, 0, 0],'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 0, 0, 0],'
- en: '[0, 0, 0, 0]], dtype=uint8)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 0, 0, 0]], dtype=uint8)'
- en: ❶ >>> b[0,1] = 1
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> b[0,1] = 1
- en: '>>> b[1,0] = 2'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[1,0] = 2'
- en: '>>> b'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: array([[0, 1, 0, 0],
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: array([[0, 1, 0, 0],
- en: '[2, 0, 0, 0],'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[2, 0, 0, 0],'
- en: '[0, 0, 0, 0]], dtype=uint8)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 0, 0, 0]], dtype=uint8)'
- en: 'We index arrays in the same way that we index lists, with square brackets:
    [ begins the index and ] ends it. In between the square brackets goes an expression
    that tells NumPy which elements of the array to return or assign—this is the *subscript*.
    A subscript is appended to an array name to specify one or more elements of the
    array.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对数组的索引方式与对列表的索引方式相同，使用方括号：`[`开始索引，`]`结束索引。在方括号之间放置一个表达式，告诉 NumPy 要返回或赋值数组的哪些元素——这就是*下标*。下标附加到数组名后面，用于指定一个或多个数组元素。
- en: In the example above, b is a matrix of three rows and four columns with each
    element initialized to 0\. We see this when we evaluate b.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，b 是一个包含三行四列的矩阵，每个元素都初始化为 0。我们在评估 b 时可以看到这一点。
- en: 'Next, we do something new: we set up an assignment statement ❶ where the left-hand
    side of the statement is not a single variable name but a variable name with a
    subscript, the text [0,1]. This subscript tells NumPy that the value of the right-hand
    side of the statement, here just 1, should be put into the element of b at row
    0 and column 1\. Likewise, NumPy should put a 2 into the element at row 1, column
    0\. We see that NumPy did as we asked when we look at b and see that the second
    column of row 0 is now 1, and the first column of row 1 is now 2.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们做一些新的事情：我们设置一个赋值语句 ❶，其中语句的左侧不是一个单一的变量名，而是一个带有下标的变量名，文本为 [0,1]。这个下标告诉 NumPy
    语句右侧的值，在这里是 1，应该放入 b 中第 0 行第 1 列的元素。同样，NumPy 应该将 2 放入第 1 行第 0 列的元素。我们可以通过查看 b
    来看到 NumPy 按照我们的要求进行了操作，结果是第 0 行的第二列现在是 1，第 1 行的第一列现在是 2。
- en: 'If we continue working with b as defined previously, we see how to ask NumPy
    for elements from the array:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续使用之前定义的 b，我们可以看到如何从数组中向 NumPy 请求元素：
- en: '>>> b[1,0]'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[1,0]'
- en: '2'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> b[1]'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[1]'
- en: array([2, 0, 0, 0], dtype=uint8)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: array([2, 0, 0, 0], dtype=uint8)
- en: '>>> b[1][0]'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[1][0]'
- en: '2'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: Since b is a matrix, we need subscripts to select a specific element of it,
    one for the row, another for the column. Therefore, b[1,0] should return the value
    in the second row and first column, as we see it does.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 b 是一个矩阵，我们需要下标来选择其中的特定元素，一个用于行，一个用于列。因此，b[1,0] 应该返回第二行第一列的值，正如我们看到的那样。
- en: The next line uses a single subscript, b[1], and returns the entire second row
    of b. This is a very useful feature that we’ll see in our own code throughout
    the book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用了单个下标，b[1]，并返回了b的整个第二行。这是一个非常有用的功能，我们将在本书中的代码中看到它。
- en: Lastly, if b[1] returns the entire second row of the matrix, b, then we can
    use b[1][0] to ask for the first element of that row. We see that it matches the
    result of the b[1,0] syntax we started with.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果b[1]返回矩阵b的整个第二行，那么我们可以使用b[1][0]来获取该行的第一个元素。我们看到它与我们最开始使用的b[1,0]语法的结果相匹配。
- en: Slicing an Array
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片数组
- en: 'Accessing individual elements of an array, or an entire subarray, with a single
    index is useful, but NumPy is far more flexible than that. It’s possible to specify
    parts of the array by using *slicing*, which returns subarrays carved out of the
    larger array as if with a knife. Let’s look at how it works:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一索引访问数组的单个元素或整个子数组是有用的，但NumPy的灵活性远不止如此。可以通过使用*切片*来指定数组的部分，这会像刀切割一样返回从大数组中切出来的子数组。让我们看看它是如何工作的：
- en: '>>> a = np.arange(10)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.arange(10)'
- en: '>>> a'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
- en: '>>> a[1:4]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[1:4]'
- en: array([1, 2, 3])
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: array([1, 2, 3])
- en: '>>> a[3:7]'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[3:7]'
- en: array([3, 4, 5, 6])
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: array([3, 4, 5, 6])
- en: 'Here we use arange, which is the NumPy analogue of the Python range function,
    to set a to a vector of the digits [0,9]. We then ask for a slice of this vector,
    a[1:4], and see that it returns [1, 2, 3]. The slice was specified with two values:
    the first is the starting index, 1, and the second is the ending index, 4.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用arange，这是NumPy中的Python range函数的类似功能，将a设置为一个包含数字[0,9]的向量。然后我们请求这个向量的切片a[1:4]，并看到它返回了[1,
    2, 3]。该切片使用了两个值进行指定：第一个是起始索引1，第二个是结束索引4。
- en: Wait—if the ending index is 4,then shouldn’t the slice have returned [1, 2,
    3, 4] instead? NumPy follows the Python convention for lists, so the ending index
    is never included in the returned subarray. We can read the slice as asking for
    all the elements of a starting at index 1 and up to *but not including* index
    4\. Mathematically, a slice given as a[x:y] means all elements, *i*, of a such
    that *x* ≤ *i* < *y*. Therefore, the second example, a[3:7], now makes sense as
    it’s asking for all elements of a starting with index 3 up to but not including
    index 7.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——如果结束索引是4，那切片应该返回[1, 2, 3, 4]才对吧？NumPy遵循Python列表的约定，因此结束索引永远不会包含在返回的子数组中。我们可以将切片理解为请求所有从索引1开始、直到*但不包括*索引4的a中的元素。数学上，表示为a[x:y]的切片意味着所有满足*x*
    ≤ *i* < *y*的a中的元素。因此，第二个例子a[3:7]现在就能理解了，它是请求所有从索引3开始、直到但不包括索引7的a中的元素。
- en: 'The slices selected all elements in the given range. NumPy allows for an optional
    third slice argument that specifies a step size. If not given, the step size is
    1\. Therefore, with a as a vector of the digits as before, we get this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些切片选择了给定范围内的所有元素。NumPy允许一个可选的第三个切片参数来指定步长。如果没有给定，步长默认为1。因此，当a作为一个数字向量时，我们得到：
- en: '>>> a[0:8:2]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[0:8:2]'
- en: array([0, 2, 4, 6])
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 2, 4, 6])
- en: '>>> a[3:7:2]'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[3:7:2]'
- en: array([3, 5])
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: array([3, 5])
- en: The first slice starts at the beginning of the array, index 0, and goes to index
    8 (but not including index 8) returning every second element. The second example
    does the same starting with index 3.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个切片从数组的起始位置，即索引0开始，到索引8（但不包括索引8）结束，返回每隔一个的元素。第二个例子从索引3开始，做同样的操作。
- en: 'Any part of the full slice syntax, [x:y:z], may be omitted, but at least one
    colon must remain. If so, the default value is the first index (for x), the last
    index (for y), and 1 (for z). For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的切片语法[x:y:z]的任何部分都可以省略，但至少需要保留一个冒号。如果省略了某部分，则默认值为第一个索引（对于x），最后一个索引（对于y），以及1（对于z）。例如：
- en: '>>> a[:6]'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[:6]'
- en: array([0, 1, 2, 3, 4, 5])
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 1, 2, 3, 4, 5])
- en: '>>> a[6:]'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[6:]'
- en: array([6, 7, 8, 9])
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: array([6, 7, 8, 9])
- en: In the first example, the starting index is omitted so it defaults to 0 and
    we’re given the first six elements of a. In the second example, the ending index
    is omitted so it defaults to the last index, meaning “return everything from index
    6 to the end.” In both cases, the increment was omitted and defaulted to 1.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，起始索引被省略，因此默认为0，我们得到了a的前六个元素。在第二个例子中，结束索引被省略，因此默认为最后一个索引，这意味着“返回从索引6到结束的所有内容。”在这两种情况下，增量都被省略，默认为1。
- en: 'Array slicing leads to some handy shortcuts. Two are given here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片提供了一些便捷的快捷方式。这里给出了两个示例：
- en: '>>> a[-1]'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[-1]'
- en: '9'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '>>> a[::-1]'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[::-1]'
- en: array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
- en: The first example shows us that like Python lists, NumPy arrays can be indexed
    with negative values to count from the end of an axis. So, asking for index –1
    will always return the last element.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子告诉我们，就像 Python 列表一样，NumPy 数组也可以用负值进行索引，从轴的末尾开始计数。因此，索引为 -1 时将总是返回最后一个元素。
- en: 'The second example is a bit mysterious at first. We know that a is a vector
    of the digits from 0 through 9\. The example returns the vector in reverse order.
    How? Let’s break down the meaning of ::-1. We said that any part of the array
    slice notation can be omitted, and if it is, the default is either the first index,
    the last index, or the increment. In this case, the first index is omitted so
    it defaults to 0\. The required colon (:) is present, and then the last index
    is omitted so it defaults to the last index. Then there’s a : for the increment,
    which is given as –1, to count backward from the ending index to the starting
    index. This is what counts backward and reverses the elements of the array.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子刚开始看起来有点神秘。我们知道 a 是一个包含数字 0 到 9 的向量。这个例子将向量按相反顺序返回。怎么做到的呢？让我们来解析 `::-1`
    的含义。我们之前说过，数组切片的任何部分都可以省略，如果省略了，默认值是第一个索引、最后一个索引或增量。在这个例子中，省略了第一个索引，所以它默认是 0。需要的冒号（:）存在，然后省略了最后一个索引，默认它是最后一个索引。接着是一个增量的
    `:`，它被指定为 -1，表示从结束索引向开始索引倒数。这就是倒着数并反转数组元素的方式。
- en: 'Naturally, array slicing works with NumPy arrays with any number of dimensions.
    Let’s look at slicing a two-dimensional matrix:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，数组切片适用于任意维度的 NumPy 数组。让我们看一下切片一个二维矩阵的例子：
- en: '>>> b = np.arange(20).reshape((4,5))'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.arange(20).reshape((4,5))'
- en: '>>> b'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: array([[ 0,  1,  2,  3,  4],
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 0,  1,  2,  3,  4],
- en: '[ 5,  6,  7,  8,  9],'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 5,  6,  7,  8,  9],'
- en: '[10, 11, 12, 13, 14],'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 11, 12, 13, 14],'
- en: '[15, 16, 17, 18, 19]])'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[15, 16, 17, 18, 19]])'
- en: '>>> b[1:3,:]'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[1:3,:]'
- en: array([[ 5,  6,  7,  8,  9],
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 5,  6,  7,  8,  9],
- en: '[10, 11, 12, 13, 14]])'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 11, 12, 13, 14]])'
- en: '>>> b[2:,2:]'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[2:,2:]'
- en: array([[12, 13, 14],
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: array([[12, 13, 14],
- en: '[17, 18, 19]])'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[17, 18, 19]])'
- en: We define b to be a vector of the numbers [0,19] by using arange and then immediately
    use reshape to change the vector into a matrix of four rows and five columns.
    The argument to reshape is a tuple specifying the new shape for the array. There
    must be exactly as many elements in the array as the new shape. The vector had
    20 elements, and the new shape has 4 × 5 = 20 elements, so we are okay in this
    case.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `arange` 定义 b 为一个包含 [0, 19] 数字的向量，然后立即使用 `reshape` 将这个向量转换为一个 4 行 5 列的矩阵。传给
    `reshape` 的参数是一个元组，指定了数组的新形状。数组中的元素个数必须与新形状中的元素个数一致。这个向量有 20 个元素，而新形状有 4 × 5 =
    20 个元素，所以在这个例子中是可以的。
- en: 'Array slicing applies per dimension, so the second example, b[1:3,:] is asking
    for rows 1 and 2 and all the columns in those rows. That is what : by itself means—all
    the elements along that axis.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片按维度应用，因此第二个例子 `b[1:3,:]` 是要求获取第 1 和第 2 行以及这些行的所有列。`:` 代表所有元素——在该轴上的所有元素。
- en: The next example asks for all the rows and columns starting with row 2 and column
    2\. This is the submatrix pulled from the lower-right corner of the full matrix
    b.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子要求获取从第 2 行和第 2 列开始的所有行和列。这是从完整矩阵 b 的右下角提取出的子矩阵。
- en: The Ellipsis
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 省略号
- en: 'NumPy supports a shorthand notation for slicing that’s sometimes useful. Let’s
    show it and then discuss what it’s doing. First, however, we need to define some
    arrays to work with:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 支持一种简写的切片方式，有时非常有用。我们先展示这个方式，然后再讨论它的作用。不过，在此之前，我们需要定义一些数组来操作：
- en: '>>> c = np.arange(27).reshape((3,3,3))'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = np.arange(27).reshape((3,3,3))'
- en: '>>> c'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c'
- en: array([[[ 0,  1,  2],
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: array([[[ 0,  1,  2],
- en: '[ 3,  4,  5],'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 3,  4,  5],'
- en: '[ 6,  7,  8]],'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 6,  7,  8]],'
- en: '[[ 9, 10, 11],'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 9, 10, 11],'
- en: '[12, 13, 14],'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[12, 13, 14],'
- en: '[15, 16, 17]],'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[15, 16, 17]],'
- en: '[[18, 19, 20],'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[[18, 19, 20],'
- en: '[21, 22, 23],'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[21, 22, 23],'
- en: '[24, 25, 26]]])'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[24, 25, 26]]])'
- en: '>>> a = np.ones((3,3))'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.ones((3,3))'
- en: '>>> a'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([[1., 1., 1.],
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: array([[1., 1., 1.],
- en: '[1., 1., 1.],'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[1., 1., 1.],'
- en: '[1., 1., 1.]])'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[1., 1., 1.]])'
- en: First we define c to be a three-dimensional array with three elements along
    each dimension. We use the same reshape trick that we used previously, and we
    know it will work because 3 × 3 × 3 = 27 and there are 27 elements in the initial
    vector produced by arange. Again, we can think of c as three 3×3 images stacked
    together. Next we use ones to define a simple 3×3 matrix with every value set
    to 1.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义 c 为一个三维数组，每个维度上有三个元素。我们使用与之前相同的 `reshape` 技巧，知道它会成功，因为 3 × 3 × 3 = 27，而初始向量由
    `arange` 生成了 27 个元素。我们可以将 c 看作是三张 3×3 的图像堆叠在一起。接下来我们使用 `ones` 定义了一个简单的 3×3 矩阵，其中每个值都设置为
    1。
- en: 'From our discussion of array slicing so far, we know that we can replace the
    3×3 subarray in c for any particular “image” by using the colon notation. For
    example, let’s replace the second “image” of c by a:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前对数组切片的讨论中，我们知道可以通过使用冒号表示法来替换 c 中任何特定的“图像”的 3×3 子数组。例如，让我们用 a 替换 c 的第二个“图像”：
- en: '>>> c[1,:,:] = a'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c[1,:,:] = a'
- en: '>>> c'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c'
- en: array([[[ 0,  1,  2],
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: array([[[ 0,  1,  2],
- en: '[ 3,  4,  5],'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 3,  4,  5],'
- en: '[ 6,  7,  8]],'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 6,  7,  8]],'
- en: '[[ 1,  1,  1],'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 1,  1,  1],'
- en: '[ 1,  1,  1],'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1,  1,  1],'
- en: '[ 1,  1,  1]],'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1,  1,  1]],'
- en: '[[18, 19, 20],'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[[18, 19, 20],'
- en: '[21, 22, 23],'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[21, 22, 23],'
- en: '[24, 25, 26]]])'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[24, 25, 26]]])'
- en: Here we tell NumPy to replace the second subarray, which is 3×3, with the 3×3
    array in a. It’s the second subarray because the first index is given as 1\. When
    we print c, we see that the second 3×3 subarray is now all 1s.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 NumPy 用 a 中的 3×3 数组替换第二个子数组，即 3×3 数组。它是第二个子数组，因为第一个索引是 1。当我们打印 c 时，我们看到第二个
    3×3 子数组现在全是 1。
- en: 'Now for the shorthand notation. This time, we want to replace the first 3×3
    subarray of c with a. We could do this with a syntax of c[0,:,:] but instead we’ll
    use the shorthand notation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一下简写表示法。这次，我们要用 a 替换 c 的第一个 3×3 子数组。我们可以用 c[0,:,:] 来实现，但我们将使用简写表示法：
- en: '>>> c[0,...] = a'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c[0,...] = a'
- en: '>>> c'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c'
- en: array([[[ 1,  1,  1],
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: array([[[ 1,  1,  1],
- en: '[ 1,  1,  1],'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1,  1,  1],'
- en: '[ 1,  1,  1]],'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1,  1,  1]],'
- en: '[[ 1,  1,  1],'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 1,  1,  1],'
- en: '[ 1,  1,  1],'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1,  1,  1],'
- en: '[ 1,  1,  1]],'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1,  1,  1]],'
- en: '[[18, 19, 20],'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[[18, 19, 20],'
- en: '[21, 22, 23],'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[21, 22, 23],'
- en: '[24, 25, 26]]])'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[24, 25, 26]]])'
- en: Notice that instead of c[0,:,:], where we specified all the indices of all the
    remaining dimensions of c, we used c[0,...] which NumPy interprets as meaning
    “and as many colons as necessary to cover all the remaining dimensions.” Of course,
    the shape of a must match the shape of the subarray specified by all the remaining
    dimensions. In this example, there are two remaining dimensions and a is a two-dimensional
    array, so we do match. The ellipsis notation (...) is commonly used in Python
    code related to machine learning, so that’s why I mention it here. You could argue
    that from a readability standpoint, using ... is not a good idea because it requires
    the reader of the code to remember how many dimensions a particular array has.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们使用了 c[0,...]，而不是 c[0,:,:]，在后者中，我们指定了 c 的所有剩余维度的所有索引。NumPy 将 c[0,...] 解释为“根据需要用尽可能多的冒号来覆盖所有剩余的维度”。当然，a
    的形状必须与所有剩余维度指定的子数组的形状匹配。在这个例子中，有两个剩余维度，而 a 是一个二维数组，因此它们匹配。省略号表示法 (...) 在与机器学习相关的
    Python 代码中很常见，所以我在这里提到它。你可以认为，从可读性的角度来看，使用 ... 并不是一个好主意，因为它要求读者记住一个数组有多少维度。
- en: Operators and Broadcasting
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符和广播
- en: 'NumPy uses all the standard math operators as well as a heap of other methods
    and functions that implement more advanced operations. NumPy also uses a concept
    called *broadcasting* to decide how to apply an operator to arrays. Let’s look
    at some simple operators and broadcasting:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 使用所有标准的数学运算符以及一堆其他实现更高级操作的方法和函数。NumPy 还使用一个叫做 *广播* 的概念来决定如何将运算符应用于数组。让我们来看一些简单的运算符和广播：
- en: '>>> a = np.arange(5)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.arange(5)'
- en: '>>> a'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([ 0, 1, 2, 3, 4])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: array([ 0, 1, 2, 3, 4])
- en: '>>> c = np.arange(5)[::-1]'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = np.arange(5)[::-1]'
- en: '>>> c'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c'
- en: array([ 4, 3, 2, 1, 0])
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: array([ 4, 3, 2, 1, 0])
- en: '>>> a*3.14'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a*3.14'
- en: array([ 0., 3.14, 6.28, 9.42, 12.56])
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: array([ 0., 3.14, 6.28, 9.42, 12.56])
- en: '>>> a*a'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a*a'
- en: array([ 0,  1,  4,  9, 16])
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: array([ 0,  1,  4,  9, 16])
- en: '>>> a*c'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a*c'
- en: array([0, 3, 4, 3, 0])
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 3, 4, 3, 0])
- en: '>>> a//(c+1)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a//(c+1)'
- en: array([0, 0, 0, 1, 4])
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: array([0, 0, 0, 1, 4])
- en: From earlier examples, we know that a is a vector of the digits 0 through 4\.
    And, we know because of our discussion of array slicing, that c is a vector of
    the digits 4 down to 0, the reverse of a.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的例子中我们知道，a 是一个包含数字 0 到 4 的向量。而且，我们知道根据数组切片的讨论，c 是一个包含从 4 到 0 的数字的向量，也就是 a
    的反转。
- en: With that in mind, we see that multiplying a by 3.14 multiplies each element
    by 3.14\. NumPy has broadcast the scalar 3.14 across all the elements of the array
    a. NumPy would do this no matter what shape a has. Operating on an array with
    a scalar performs the operation on all elements of the array, regardless of its
    shape.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有鉴于此，我们看到将 a 乘以 3.14 会将每个元素乘以 3.14。NumPy 将标量 3.14 广播到数组 a 的所有元素上。无论 a 的形状如何，NumPy
    都会执行此操作。对数组与标量进行运算时，操作会应用于数组的所有元素，而不管其形状如何。
- en: The expression a*a multiplies a by itself. In this case, NumPy sees that the
    two arrays have the same shape, so it multiplies corresponding elements, thereby
    squaring each element of a. Multiplying a by c is also straightforward because
    c has the same shape as a.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The last example uses broadcasting twice. First, it broadcasts the scalar 1
    across c to add one to each element of c. This operation does not change the shape
    of c, so dividing a by using integer division (// not /), by the expression (c+1),
    works since each has the same shape.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some more examples. There’s no end to the number of examples
    we could give, but one more small set should cement the concepts for us. First
    a more complex broadcasting example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: array([0, 1, 2, 3, 4])
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b=np.arange(25).reshape((5,5))'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3,  4],
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[ 5,  6,  7,  8,  9],'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[10, 11, 12, 13, 14],'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[15, 16, 17, 18, 19],'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21, 22, 23, 24]])'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a*b'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  4,  9, 16],
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0,  6, 14, 24, 36],'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0, 11, 24, 39, 56],'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0, 16, 34, 54, 76],'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0, 21, 44, 69, 96]])'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a is a vector of digits. We then define b to be a 5×5 matrix of
    the numbers 0 through 24\. Next, we multiply a and b.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should object. How can we multiply these two arrays when
    their shapes don’t match? The array a has only 5 elements, while b has 25\. This
    is where broadcasting comes into play. NumPy recognizes that the five-element
    vector in a matches the size of each *row* of b so it multiplies each row of b
    by a to return a new 5×5 matrix. This sort of broadcasting is actually quite handy.
    We’ll be storing our datasets primarily as two-dimensional NumPy arrays, where
    each row is a sample and the columns correspond to input values for that sample.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy also supports matrix math operations. These are the operations on vectors
    and matrices that we find in linear algebra. For example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = np.arange(5)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: array([0, 1, 2, 3, 4])
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '>>> np.dot(x,x)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Here we define x to be a simple vector of five elements. We then introduce NumPy’s
    primary vector and matrix product function, dot, to multiply x by itself. We already
    know that if we multiply x by itself in the standard way, using x*x, we’ll get
    each element times itself, giving [0,1,4,9,16], but that’s not what we get here.
    Instead we get the scalar value, 30\. Why?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer has to do with what dot does. It doesn’t implement element-wise
    multiplication but instead implements linear algebra multiplication. Specifically,
    because both arguments to dot are vectors, it implements vector times vector,
    which is known as the *dot product*, hence the name of the NumPy function. The
    dot product for vectors multiplies each element of the first vector by the corresponding
    element of the second vector and then adds all those products together. So, for
    dot(x,x) NumPy is calculating as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 1, 2, 3, 4] × [0, 1, 2, 3, 4] = [0, 1, 4, 9, 16]; 0 + 1 + 4 + 9 + 16 =
    30'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The dot function can be used to multiply two vectors, a vector and a matrix,
    or two matrices, all following the rules of linear algebra, which are beyond the
    scope of this book to explore in detail. That said, the dot function is of great
    importance to us because it is the workhorse function of machine learning with
    NumPy. In the end, most of modern machine learning boils down to math with vectors
    and matrices.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: dot 函数可以用来乘以两个向量，一个向量和一个矩阵，或者两个矩阵，所有操作都遵循线性代数的规则，这些规则超出了本书的讨论范围。不过，dot 函数对我们来说非常重要，因为它是机器学习中使用
    NumPy 的核心函数。最终，现代机器学习的核心就是与向量和矩阵相关的数学。
- en: 'Let’s look at an example using dot with two matrices:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用 dot 计算两个矩阵的例子：
- en: '>>> a = np.arange(9).reshape((3,3))'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.arange(9).reshape((3,3))'
- en: '>>> b = np.arange(9).reshape((3,3))'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.arange(9).reshape((3,3))'
- en: '>>> a'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([[0, 1, 2],
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: array([[0, 1, 2],
- en: '[3, 4, 5],'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[3, 4, 5],'
- en: '[6, 7, 8]])'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[6, 7, 8]])'
- en: '>>> np.dot(a,b)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> np.dot(a,b)'
- en: array([[ 15,  18,  21],
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 15,  18,  21],
- en: '[ 42,  54,  66],'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 42,  54,  66],'
- en: '[ 69,  90, 111]])'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 69,  90, 111]])'
- en: '>>> a*b'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a*b'
- en: array([[ 0,  1,  4],
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 0,  1,  4],
- en: '[ 9, 16, 25],'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 9, 16, 25],'
- en: '[36, 49, 64]])'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[36, 49, 64]])'
- en: Here we define both a and b to be the same 3×3 matrix of the digits 0 through
    9\. We then use dot with these two matrices. For comparison purposes, we also
    show normal multiplication of the two matrices.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义 a 和 b 都是包含数字 0 到 9 的 3×3 矩阵。然后我们使用 dot 对这两个矩阵进行计算。为了对比，我们也展示了这两个矩阵的常规乘法。
- en: 'The two results are not the same. The first uses linear algebra rules for multiplying
    two 3×3 matrices, which says that the first element of the 3×3 output will be
    the first column of b, [0, 3, 6], multiplied element by element with the first
    row of a, [0, 1, 2], with each product summed:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个结果并不相同。第一个结果使用线性代数规则来乘以两个 3×3 矩阵，该规则指出，3×3 输出的第一个元素将是 b 的第一列 [0, 3, 6]，与
    a 的第一行 [0, 1, 2] 按元素相乘，每个乘积相加：
- en: '[0, 3, 6] × [0, 1, 2] = [0, 3, 12]; 0 + 3 + 12 = 15'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 3, 6] × [0, 1, 2] = [0, 3, 12]; 0 + 3 + 12 = 15'
- en: A similar process creates each of the other entries. For the simple multiplication,
    the first element of the 3×3 output is simply 0 × 0 = 0.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的过程也适用于其他条目的创建。对于简单的乘法，3×3 输出的第一个元素就是 0 × 0 = 0。
- en: 'If the inputs to dot are matrices, then dot acts as we expect: it’s matrix
    multiplication. It’s when one of the inputs is a vector and the other a matrix
    that things get a little sloppy. NumPy is somewhat careless about whether the
    vector is a row or column vector—it produces the correct result regardless, though
    the shape of the result might not follow linear algebra rules precisely.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 dot 的输入是矩阵，那么 dot 的作用如我们所预期：它是矩阵乘法。只有当一个输入是向量而另一个是矩阵时，情况才会有些混乱。NumPy 对向量是行向量还是列向量不太在意——它会产生正确的结果，尽管结果的形状可能不会完全遵循线性代数规则。
- en: We trudged through the linear algebra examples because as you continue to explore
    machine learning, you’ll encounter code using dot quite frequently. It’s good
    to know what it does, but because of its tolerance of the shape of its inputs,
    you might need to work through the code paying careful attention to the actual
    shapes of your arrays to avoid getting lost.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在经历了线性代数的例子后，因为在你继续探索机器学习的过程中，你会频繁遇到使用 dot 的代码。了解它的功能是很有必要的，但由于它对输入的形状具有容忍性，你可能需要仔细检查代码，特别关注数组的实际形状，以避免迷失。
- en: Array Input and Output
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组输入与输出
- en: NumPy would be difficult to use if it didn’t provide the means for storing arrays
    on disk and reading arrays from disk. Sure, we could use a standard Python module
    like pickle, but that’s inefficient and makes interchange between software packages
    difficult. Fortunately for us, the creators of NumPy were thorough and included
    input/output functions.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 NumPy 不提供将数组存储到磁盘和从磁盘读取数组的功能，它将很难使用。当然，我们可以使用像 pickle 这样的标准 Python 模块，但那样效率低下，而且让不同软件包之间的交换变得困难。幸运的是，NumPy
    的创始人考虑周到，包含了输入/输出函数。
- en: 'In the following, we’ll refer to several disk files. The first is *abc.txt*,
    which looks like this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提到几个磁盘文件。第一个是 *abc.txt*，内容如下：
- en: 1 2 3
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3
- en: 4 5 6
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 4 5 6
- en: 7 8 9
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 7 8 9
- en: It’s a file of three lines with three numbers per line separated by a space.
    The second is *abc_tab.txt*, which is identical to *abc.txt*, but the spaces have
    been replaced by a tab character, \t in Python. Tab-delimited files are commonly
    used to store data in files. The last file is *abc.csv*, which is a comma-separated
    values (CSV) file often used by spreadsheet programs. It’s also the same as *abc.txt*,
    but the spaces have been replaced by commas. Now, let’s look at NumPy’s basic
    input/output capabilities.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.loadtxt("abc.txt")'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.loadtxt("abc_tab.txt")'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> a = np.loadtxt("abc.csv", delimiter=",")
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: ❷ >>> np.save("abc.npy", a)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ❸ >>> b = np.load("abc.npy")
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: ❹ >>> np.savetxt("ABC.txt", b)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '>>> np.savetxt("ABC.csv", b, delimiter=",")'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The first three examples use loadtxt, which reads text files and produces NumPy
    arrays from them. The first two examples show that loadtxt knows how to parse
    files with values separated by spaces and tab characters. The function uses the
    rows of the text file as rows of the matrix, and the values on each line as the
    elements in each row.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The third example explicitly states that the delimiter (separator) between values
    in the text file is the comma character (,) ❶. This is how to read a *.csv* file
    in NumPy.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: NumPy uses the save function to write arrays to disk ❷. This function writes
    a single array to the given filename. NumPy uses a *.npy* file extension to identify
    the file as containing a NumPy array. We’ll make extensive use of *.npy* files
    throughout this book.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: To read an array back into memory from disk, use load ❸. Note that the data
    in the array is loaded, but you must assign it to a new variable name. The *.npy*
    file doesn’t store the original name of the array.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we’ll want to write arrays in a format that will be readable by other
    programs or humans. On those occasions, we’ll use the savetxt function ❹. These
    examples write text files, first using spaces between values and then using a
    comma between values.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to write multiple arrays to disk? Are we forced to use a single
    file for each array? Fortunately, no, we can use savez and read them with load.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> np.savez("arrays.npz", a=a, b=b)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '>>> q = np.load("arrays.npz")'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: ❷ >>> list(q.keys())
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[''a'', ''b'']'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '>>> q[''a'']'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '>>> q[''b'']'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: array([[1., 2., 3.],
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[4., 5., 6.],'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[7., 8., 9.]])'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Here we store the two arrays, a and b, to a single file, *arrays.npz* ❶. We
    still read the file with load, but instead of the arrays, q is more like a dictionary
    so that if we ask for the keys as a list ❷, we get a list of the names of the
    arrays read from the file. Referencing an array by its name returns it.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Look again at the call to savez ❶. Notice how we specified the arrays? This
    is the keyword approach, and it gives the arrays the keyword name, which we made
    the same as the variable name so that when we asked for the keys after opening
    the file, we got back the names we expect. We could have dispensed with the keyword
    names and simply used the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '>>> np.savez("arrays.npz", a, b)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: This would write the arrays to the file by using default names of arr_0 and
    arr_1. Lastly, since arrays can be quite large, we might want to compress them
    (losslessly!), and for that, we’d have used savez_compressed in place of savez.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Compression might be worth it, but it does slow reading and writing. For example,
    a 64-bit floating-point array of 10 million element requires at a minimum 80,000,000
    bytes of memory. Using savez to write such an array to disk uses 80,000,244 bytes
    and takes only a fraction of a second. The extra 244 bytes are overhead for the
    structure of the dictionary. Writing the compressed file to disk takes a second
    or two but results in a file of 11,960,115 bytes, considerably smaller. Since
    this example was made using arange, each element of the output array was unique
    so the compression is not the result of storing an array of 10 million zeros.
    For the curious, storing 10 million zeros uncompressed still uses 80,000,244 bytes
    but compressed uses only 77,959 bytes on disk. So, the more redundant the array,
    the more the savings when compressed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Random Numbers
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy has extensive support for pseudorandom number generation. We’ll be sloppy
    and simply call them *random numbers*, understanding that computers are not capable
    by any algorithmic process of producing actual random numbers—if you’re curious
    about pseudorandom number generation, you can read my book, *Random Numbers and
    Computers* (Springer 2018). The NumPy random number library is under random and
    can generate samples from many different distributions, the most common being
    a uniform distribution, [0,1). This means that any (representable) floating-point
    number in that range is equally likely. Usually, this is what we want. At other
    times we might want to use a normal distribution that looks like the classic bell-shaped
    curve. Many physical processes follow this curve. NumPy can generate such samples
    as well.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The random number functions we’ll use in this book are random.random to generate
    random numbers from [0,1), random.normal to generate random numbers drawn from
    a bell-shaped curve, and random.seed to set the seed of the generator so we can
    produce the same sequence of random numbers over and over. We’ll leave it to the
    philosophers to decide if such a sequence still deserves the label *random* or,
    for that matter, if it ever did, regardless of the seed value.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将使用的随机数函数包括random.random（从[0,1)区间生成随机数），random.normal（从钟形曲线中生成随机数），以及random.seed（设置生成器的种子，以便我们可以多次生成相同的随机数序列）。我们将留给哲学家们来决定，是否这种序列仍然值得被称为*随机*，或者说，它是否曾经是，甚至不管种子值如何。
- en: NumPy and Images
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy与图像
- en: Some of the datasets we’ll use are image based. We’ll want to work with the
    datasets in NumPy, so we need to know something about how to work with images
    in Python and how to get images into and out of NumPy arrays. Fortunately, it’s
    pretty straightforward. Besides NumPy, we’ll need to work with the Pillow module
    (PIL) to read and write images. We have Pillow installed already—it comes with
    the installation of our main toolkits. We also have some sample images as part
    of sklearn.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的一些数据集是基于图像的。我们希望在NumPy中处理这些数据集，因此我们需要了解如何在Python中处理图像，以及如何将图像导入和导出NumPy数组。幸运的是，这个过程相当简单。除了NumPy，我们还需要使用Pillow模块（PIL）来读取和写入图像。我们已经安装了Pillow，它与我们的主要工具包一起安装。我们还可以使用一些作为sklearn一部分的示例图像。
- en: We need to think in terms of two worlds when working with images. There’s the
    “NumPy” world, where the image has been converted into a NumPy array, and there’s
    the PIL world that reads and writes images in common graphics formats like JPEG
    and PNG. The distinction really isn’t so black-and-white—we can do image processing
    in PIL too, and sometimes that is more convenient; but for now, we’ll use PIL
    only as a way to read and write image files.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理图像时，我们需要考虑两个世界。一个是“NumPy”世界，图像已被转换为NumPy数组，另一个是PIL世界，PIL可以读取和写入常见的图像格式，如JPEG和PNG。其实，这个区分并不是绝对的——我们也可以在PIL中进行图像处理，有时这更为方便；但目前，我们只将PIL用作读取和写入图像文件的工具。
- en: Images are two-dimensional arrays of numbers, but if the image is color, we
    will have three or even four numbers for each pixel, each a byte value representing
    the intensity of the red, green, blue, and sometimes, alpha, channels of the image.
    We’ll assume that all of our images are either one-channel grayscale or three-channel
    RGB. We’ll eliminate any alpha channel when we encounter one. The alpha channel
    determines how transparent the pixel is.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是二维数字数组，但如果图像是彩色的，每个像素将有三个或甚至四个数字，每个数字表示红色、绿色、蓝色以及有时是透明度（alpha）通道的强度。我们假设所有图像要么是单通道的灰度图像，要么是三通道的RGB图像。当我们遇到带有alpha通道的图像时，我们会将其去除。alpha通道决定了像素的透明度。
- en: 'First, let’s see how to get at the example images sklearn provides and how
    to turn them into PIL images, store them on disk, and display them:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何获取sklearn提供的示例图像，如何将它们转换为PIL图像，保存到磁盘，并显示它们：
- en: ❶ >>> from PIL import Image
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> from PIL import Image
- en: '>>> from sklearn.datasets import load_sample_images'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sklearn.datasets import load_sample_images'
- en: ❷ >>> china = load_sample_images().images[0]
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> china = load_sample_images().images[0]
- en: '>>> flower = load_sample_images().images[1]'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> flower = load_sample_images().images[1]'
- en: '>>> china.shape, china.dtype'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> china.shape, china.dtype'
- en: ((427, 640, 3), dtype('uint8'))
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ((427, 640, 3), dtype('uint8'))
- en: '>>> flower.shape, flower.dtype'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> flower.shape, flower.dtype'
- en: ((427, 640, 3), dtype('uint8'))
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ((427, 640, 3), dtype('uint8'))
- en: ❸ >>> imChina = Image.fromarray(china)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ >>> imChina = Image.fromarray(china)
- en: '>>> imFlower = Image.fromarray(flower)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> imFlower = Image.fromarray(flower)'
- en: '>>> imChina.show()'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> imChina.show()'
- en: '>>> imFlower.show()'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> imFlower.show()'
- en: ❹ >>> imChina.save("china.png")
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ >>> imChina.save("china.png")
- en: '>>> imFlower.save("flower.png")'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> imFlower.save("flower.png")'
- en: ❺ >>> im = Image.open("china.png")
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ >>> im = Image.open("china.png")
- en: '>>> im.show()'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> im.show()'
- en: First, we need to import PIL ❶ and the sample images function from sklearn.
    Once we have those, we can get at the actual images as NumPy arrays ❷. We see
    that the *china* and *flower* images are three-dimensional arrays, meaning they
    are RGB images. The images are 427×640 pixels. The third dimension is 3, corresponding
    to the red, green, and blue channels. If the images were grayscale, they would
    have only two dimensions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入PIL ❶ 和来自sklearn的示例图像函数。一旦有了这些，我们就能将实际的图像作为NumPy数组 ❷。我们看到，*china* 和
    *flower* 图像是三维数组，这意味着它们是RGB图像。这些图像的大小是427×640像素，第三维是3，分别对应红色、绿色和蓝色通道。如果图像是灰度图像，它们将只有二维。
- en: We can convert the NumPy arrays to PIL image objects ❸ by using the fromarray
    function. The argument is assumed to be a NumPy array of the proper format for
    conversion. Usually this means that the array must have a data type of uint8.
    Once we have the PIL image objects, we can view the images with the show method.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: To write the images to disk as actual graphics files, not NumPy arrays, we use
    the save method on the PIL objects ❹. The format of the output file is determined
    by the file extension. Here we’re using PNG.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: To read an image file from disk, we use the open function ❺. Note that open
    returns a PIL image object, not a NumPy array.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to turn the PIL image object into a NumPy array. Also, let’s
    see how to use PIL to make a color image grayscale before turning it into a NumPy
    array. We’ll use each of these steps later in the book:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '>>> im = Image.open("china.png")'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> img = np.array(im)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '>>> img.shape, img.dtype'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: ((427, 640, 3), dtype('uint8'))
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: ❷ >>> gray = im.convert("L")
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '>>> gray.show()'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '>>> g = np.array(gray)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '>>> g.shape, g.dtype'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: ((427, 640), dtype('uint8'))
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: We first load the image from disk into a PIL image object, im. We then pass
    the image object to NumPy via the array function ❶. This function is savvy enough
    to recognize a PIL image object and make the proper conversion to a NumPy array.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: We can also turn the PIL RGB image into a grayscale image using the convert
    method. Note that PIL uses L for *luminance* to refer to grayscale images ❷. Again,
    array converts the now grayscale image into a NumPy array. We see that the image
    has only two dimensions, as we would expect from a grayscale image, where each
    pixel value is just a shade of gray, not a color.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: The PIL module has many other abilities. It’s a good idea to look at the Pillow
    website, *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*,
    to see the other things you can do with PIL.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we reviewed how to work with NumPy, the foundational toolkit
    used by both sklearn and Keras. This gives us the background we need to understand
    the code examples we’ll see later in the book. It’s essential to understand how
    to use NumPy, at least at a basic level. The examples in this chapter should help.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re familiar with NumPy, we are ready to dive into working with data.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
