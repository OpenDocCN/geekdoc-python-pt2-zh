- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING NUMPY**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: NumPy is foundational to all of the machine learning we’ll explore in this book.
    If you’re already comfortable with NumPy, you can skip this chapter. If you’re
    not, don’t be shy; consider this chapter a refresher and dive in.
  prefs: []
  type: TYPE_NORMAL
- en: A full tutorial of NumPy is beyond what we can cover here, so if you’re interested,
    you can look further at *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: Why NumPy?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python is an elegant programming language but it lacks an important data structure
    that’s fundamental to scientific and mathematical programming: the array. Yes,
    you could use a dictionary as an array, or a sizeable predefined list, but this
    would be an abuse of those data structures—and, more practically, it would be
    slow. Let’s look at the difference in implementation between an array and a list.
    Python lists are more advanced than the notion of a list we’re using here, but
    in essence they’re the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays vs. Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *array* is simply a fixed-size block of *contiguous* memory, a single block
    of RAM with no gaps, used to represent a set of *n* elements, each of which uses
    exactly *m* bytes. For example, an IEEE 754 double precision floating-point number
    occupies 64 bits of memory, 8 bytes, and is what Python uses under the hood for
    its `float` data type. Therefore, an array of *n* = 100 Python floats would occupy,
    at a minimum, *nm* = 100(8) = 800 bytes of memory. If Python had arrays as a data
    structure, it would allocate 800 bytes of memory and point the array variable
    name, `A`, to the memory as in [Figure 3-1](ch03.xhtml#ch3fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: An array stored in contiguous memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we want to access an element of the array, say `x[3]`, we can very
    quickly calculate the exact location in memory by adding 3(8) = 24 to the memory
    address of the base of the array. This is the indexing operation for an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multidimensional arrays are also stored in memory as contiguous blocks, and
    the indexing operation is only slightly more complicated. A *multi-dimensional
    array* uses two or more numbers to index the elements. Think of a chess board;
    two numbers are needed to determine the location of a piece: the row and the column.
    Therefore, the chess board is a two-dimensional array. If we add one more dimension
    to turn the chess board into a stack of chess boards, we need three numbers to
    locate a piece: the row, the column, and the board number. Therefore, we have
    a three-dimensional array.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use arrays with one, two, and three dimensions throughout the book.
    All of these are stored in memory as a single block of RAM. The point is, an array
    is quick to index, and therefore operations on array elements can be performed
    very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with a list. [Figure 3-2](ch03.xhtml#ch3fig2) shows the basic
    structure of a list, `B`, in memory. In this case, the elements in the list are
    not in contiguous memory, but are scattered throughout RAM with pointers linking
    one element to the next, like a chain. Each link in the chain contains the data
    value we want to store and a pointer to the memory of the next link in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: A list stored as a collection of linked nodes scattered throughout
    memory*'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t index into a list by just adding an offset to a base memory address.
    Instead, if we want the fourth element of the list, then we need to start at the
    head of the list, use the link there to the next element, and the next, and the
    next, to reach the memory associated with the fourth element, the `3` in [Figure
    3-2](ch03.xhtml#ch3fig2). This isn’t too bad until we want to index the 1,000,000th
    element and have to repeat the process 1 million times instead of adding 8 million
    once to a base address.
  prefs: []
  type: TYPE_NORMAL
- en: Most machine learning involves arrays. If the array has a single dimension,
    we call it a *vector*; vectors are the inputs to many of our models. If the array
    has two dimensions, it’s a *matrix*. A matrix can be thought of as a chess board
    or an image where each pixel of the image is one of the board locations. Matrices
    can also be an input to our models, or used internally by the model; for example,
    the weight matrices of a neural network, or the convolution kernels and filter
    outputs of a convolutional neural network are matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it’s critically important to be able to quickly operate on array
    data. This is where the `numpy` library comes in. It adds the missing array data
    type to Python so that we can perform calculations rapidly. Frankly, without it,
    Python would be unsuitable for implementing anything but the simplest of machine
    learning algorithms. However, with NumPy, Python immediately becomes the premier
    environment for machine learning research.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Array and List Speed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s see a quick example of how much speed NumPy gives us over pure Python.
    The code we’ll execute is in [Listing 3-1](ch03.xhtml#ch3lis1).
  prefs: []
  type: TYPE_NORMAL
- en: ❶ import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import time
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: n = 1000000
  prefs: []
  type: TYPE_NORMAL
- en: a = [random.random() for i in range(n)]
  prefs: []
  type: TYPE_NORMAL
- en: b = [random.random() for i in range(n)]
  prefs: []
  type: TYPE_NORMAL
- en: s = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: ❷ c = [a[i]*b[i] for i in range(n)]
  prefs: []
  type: TYPE_NORMAL
- en: print("comprehension:", time.time()-s)
  prefs: []
  type: TYPE_NORMAL
- en: s = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: c = []
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: c.append(a[i]*b[i])
  prefs: []
  type: TYPE_NORMAL
- en: print("for loop:", time.time()-s)
  prefs: []
  type: TYPE_NORMAL
- en: s = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: ❹ c = [0]*n
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: c[i] = a[i]*b[i]
  prefs: []
  type: TYPE_NORMAL
- en: print("existing list:", time.time()-s)
  prefs: []
  type: TYPE_NORMAL
- en: ❺ x = np.array(a)
  prefs: []
  type: TYPE_NORMAL
- en: y = np.array(b)
  prefs: []
  type: TYPE_NORMAL
- en: s = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: c = x*y
  prefs: []
  type: TYPE_NORMAL
- en: print("NumPy time", time.time()-s)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-1: Comparing NumPy to pure Python. See `numpy_speed_test.py`.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 3-1](ch03.xhtml#ch3lis1), we first import the `numpy` library ❶
    and then create two lists of random numbers using a list comprehension. These
    lists include 1,000,000 elements each. Our goal is to multiply the two lists together,
    element by element, as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We can measure the time the program takes to run by logging our starting time
    in `s` and subtracting it from our ending time when we print. The `time` function
    of the `time` module returns the number of seconds, including fractions of a second,
    since a set origin time (January 1, 1970). We print `time.time()-s` after each
    operation we run.
  prefs: []
  type: TYPE_NORMAL
- en: In our first attempt to multiply `a` and `b`, we use a list comprehension ❷.
    Next, we use a loop ❸ to select each element from `a` and `b` and append their
    product to the list `c`. Note that this approach starts with an empty list and
    appends each new product to it so that the list needs to grow in memory.
  prefs: []
  type: TYPE_NORMAL
- en: As a third approach, we pre-allocate the output list so that instead of appending
    each output to `c`, we update the corresponding element of `c` ❹. This approach
    might be a bit faster—we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use NumPy to do the calculation ❺. We exclude the time it takes
    to make the two lists into NumPy arrays (lines 25–26) since we could have easily
    created the random arrays (vectors since they are 1D) with a call to the NumPy
    random number module. The entire operation with NumPy vectors is `c = x*y`. Notice
    that there’s no explicit looping. NumPy is an array-processing library, and it
    will automatically iterate over all the elements of the arrays for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code in [Listing 3-1](ch03.xhtml#ch3lis1) ten times to get an
    average runtime for each of the four approaches, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***Approach*** | ***Runtime (seconds, mean* ± *SE)*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| List comprehension | 0.158855 ± 0.000426 |'
  prefs: []
  type: TYPE_TB
- en: '| `for` loop | 0.226371 ± 0.000823 |'
  prefs: []
  type: TYPE_TB
- en: '| `for` loop w/existing list | 0.201825 ± 0.000409 |'
  prefs: []
  type: TYPE_TB
- en: '| NumPy | 0.009253 ± 0.000027 |'
  prefs: []
  type: TYPE_TB
- en: This table shows that NumPy is on average just under 25× faster than pure Python
    with a naïve implementation. This is why we want to use NumPy for machine learning
    in Python! Here, *SE* means *standard error of the mean*, which is the standard
    deviation divided by the square root of the number of values that went into the
    mean, 10 in this case. The *standard deviation* is a measure of how the values
    differ from the mean. A large standard deviation means that the values are spread
    over a broad range. These standard deviations are small, meaning the times are
    consistent from run to run.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-1](ch03.xhtml#ch3lis1) shows us the true power of NumPy. Operations
    are immediately broadcast across compatible dimensions without requiring explicit
    loops. The normal linear algebra operations on vectors and matrices are also present,
    but in general, operations on NumPy arrays are performed automatically element-wise,
    without looping.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen why we’re using NumPy, let’s take a look at some of its
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy is all about arrays, so we’ll start there. Let’s dive right in with some
    basic examples and then explain what they do and why they look the way they do.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Array with np.array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with some basic array creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we define an array, `a`, using the `array` function. The argument to the
    `array` function needs to be something that NumPy can turn into an array. A list
    is something that NumPy can turn into an array, as is a tuple, so these are most
    often the arguments to the `array` function.
  prefs: []
  type: TYPE_NORMAL
- en: If we ask Python to show us what’s in `a`, we’re told it’s an array and given
    the values. NumPy will display the contents of an array, but if the array has
    many elements, it will show us only the first and last few.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next ask for the three most common properties of a NumPy array: the size,
    the shape, and the data type (`dtype`). The array `a` has four elements, so its
    size is 4\. The size of an array is the number of elements it contains. The array
    `a` is a vector, meaning it’s only one-dimensional, so the shape is returned as
    a tuple, always, where the first and only dimension is 4, meaning there are four
    elements along the first dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: The data type is new in that Python normally doesn’t care about data types.
    But to be memory efficient, the `numpy` library has to care about them. When we
    created `a` using `array`, we didn’t specify a data type, so NumPy defaulted to
    64-bit integers because all the values in the list we gave to `array` were integers.
    If even one of them had been a float, NumPy would have instead defaulted to 64-bit
    floating-point numbers, the same as the `double` type in languages like C, C++,
    and Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s be explicit about the type of data that we want the NumPy array to
    hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we define two arrays, `b` and `c`. Both arrays contain the same elements
    from the list `[1,2,3,4]`. However, notice the `dtype` keyword argument to `array`.
    This tells NumPy the data type to use for the array. For `b`, we are telling NumPy
    to use an unsigned 8-bit integer (`uint8`). This is a byte or a single ASCII character.
    If we ask for the `dtype` property, we are told that the array `b` is, indeed,
    of data type unsigned 8-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: The array `c` contains the same elements as `b`, but here we tell NumPy to make
    the array hold 64-bit floating-point numbers. Again, asking for the data type
    tells us that the array `c` is of the requested type. When working with NumPy,
    we must be aware of the type of data our arrays will hold.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used NumPy data types, and their C equivalents, are given
    in [Table 3-1](ch03.xhtml#ch3tab1). When defining arrays, specify the NumPy data
    type as a string with the data type name. We will see examples of this next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** NumPy Data Type Names, C Equivalents, and Range'
  prefs: []
  type: TYPE_NORMAL
- en: '| **NumPy name** | **Equivalent C type** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| float64 | double | ± [2.225 × 10^(–308), 1.798 × 10^(308)] |'
  prefs: []
  type: TYPE_TB
- en: '| float32 | float | ± [1.175 × 10^(–38), 3.403 × 10^(38)] |'
  prefs: []
  type: TYPE_TB
- en: '| int64 | long long | [–2^(63), 2^(63)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| uint64 | unsigned long long | [0, 2^(64)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| int32 | long | [–2^(31), 2^(31)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| uint32 | unsigned long | [0, 2^(32)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| uint8 | unsigned char | [0, 255 = 2⁸–1] |'
  prefs: []
  type: TYPE_TB
- en: 'So far, we’ve created only vectors with NumPy. Let’s look at how to create
    a matrix, a two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the `array` function as before, but instead of a single list, we pass
    in a list of lists. Each element of the supplied list is itself a list of three
    elements, and there are three such lists. Therefore, the resulting NumPy array
    will be a 3×3 matrix. The first row of the matrix is the first list of three elements
    (`[1,2,3]`), the second row is the second list (`[4,5,6]`), and the third row
    is the third list (`[7,8,9]`).
  prefs: []
  type: TYPE_NORMAL
- en: If we ask for the shape of `d`, we’re told that it’s `(3, 3)`. This tuple says
    that there are two dimensions to the array, since there are two elements in the
    tuple, and that the first dimension has length 3 (three rows) and that the second
    dimension also has length 3 (three columns). Asking for the size of `d` tells
    us that there are nine elements. The size of a NumPy array is equal to the product
    of all the values in the tuple returned by `shape`, here 3 × 3 = 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asking for the array itself causes NumPy to print it. As the array is small,
    NumPy shows us the entire array as a two-dimensional matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/035equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'NumPy is not limited to two-dimensional arrays. For example, here’s a three-dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We know that `d` is three-dimensional because `shape` returns a tuple with three
    elements. We also know that `d` is three-dimensional because the list we passed
    to `array` contains two sublists, each of which contains two sublists with three
    elements each, hence a shape of `(2, 2, 3)`. NumPy displays `d` using a blank
    line between the two 2×2 subarrays. We can think of a three-dimensional array
    as a vector where each element of the vector is a matrix. We will use three-dimensional
    NumPy arrays to hold collections of images. For this example, `d` can be thought
    of as holding two images, each of two rows by three columns.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Arrays with 0s and 1s
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Defining NumPy arrays with the `array` function would be very tedious if we
    wanted a large array since we need to supply the elements of the array. Fortunately,
    NumPy is not so cruel. Let’s look now at two NumPy workhorse functions that we’ll
    use often in this book. The first builds arrays where every element is initialized
    to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `zeros` function returns new arrays with every element set to 0\. The example
    defines `x` to be a three-dimensional array since the argument to `zeros` is the
    shape of the new array—in this case, the tuple `(2,3,4)`. This array can be thought
    of as a pair of tiny images, each 3×4 pixels. Notice that the default type for
    an array created with `zeros` is a 64-bit float (`dtype`). This means each element
    of the array uses 8 bytes in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The array `b` has two dimensions, 10×10 elements, and we’ve explicitly declared
    it to be of 32-bit unsigned integers. This means that each element uses only 4
    bytes in memory. When using NumPy, we need to be aware of how much memory an array
    might be using to avoid allocating arrays that are exceptionally large or of a
    large data type, such as `float64`, that wastes memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second workhorse function is similar to `zeros` but instead initializes
    each element to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Just like `zeros`, `ones` takes a tuple specifying the number of elements along
    each dimension of the array, here a 3×3 matrix. We can also optionally specify
    a `dtype` to make the array hold something other than 64-bit floats.
  prefs: []
  type: TYPE_NORMAL
- en: The real utility of `ones` is creating arrays initialized to any value. We do
    this by multiplying the `ones` array by the value we want, here 10\. Notice how
    NumPy realizes that we’re multiplying by a scalar value and performs the operation
    on every element of the array automatically—no loops required.
  prefs: []
  type: TYPE_NORMAL
- en: We slipped in something new, the `astype` method. This method on an array returns
    a copy of the array, casting each element to the given data type. Note, casting
    to a data type that cannot hold the original values, like casting 64-bit floats
    to unsigned bytes, will result in data being lost. NumPy will do its best, but
    this is also something to be aware of when using NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in Python, a list or dictionary object is passed by reference so that
    assigning one to a new variable doesn’t make a copy; it simply creates an alias
    that points back to the original memory. This saves time and space but can lead
    to unintended consequences if we get careless. The same is true with NumPy arrays.
    They can be very large, so it doesn’t make sense to copy them every time they
    are passed to a function. If you want to actually create a new copy of a NumPy
    array, use the `copy` method or an array slice that represents all the elements
    of the array. Unlike Python lists, NumPy arrays are flat: the value in a particular
    place in the array cannot be another array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, all the following statements, except the second, create a copy of the array
    `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Changing an element of `a` will change the corresponding element of `b` since
    `b` is pointing to the same memory as `a`, but the elements of `c` and `d` will
    be unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Elements in an Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll look at two different ways to access elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing into an Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrays aren’t much use if we can’t refer to the elements within them and update
    them when necessary. This is called *array indexing*. Understanding array indexing
    is critical to making good use of NumPy. Let’s jump in with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We index arrays in the same way that we index lists, with square brackets:
    `[` begins the index and `]` ends it. In between the square brackets goes an expression
    that tells NumPy which elements of the array to return or assign—this is the *subscript*.
    A subscript is appended to an array name to specify one or more elements of the
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, `b` is a matrix of three rows and four columns with each
    element initialized to 0\. We see this when we evaluate `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we do something new: we set up an assignment statement ❶ where the left-hand
    side of the statement is not a single variable name but a variable name with a
    subscript, the text `[0,1]`. This subscript tells NumPy that the value of the
    right-hand side of the statement, here just 1, should be put into the element
    of `b` at row 0 and column 1\. Likewise, NumPy should put a 2 into the element
    at row 1, column 0\. We see that NumPy did as we asked when we look at `b` and
    see that the second column of row 0 is now 1, and the first column of row 1 is
    now 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we continue working with `b` as defined previously, we see how to ask NumPy
    for elements from the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since `b` is a matrix, we need subscripts to select a specific element of it,
    one for the row, another for the column. Therefore, `b[1,0]` should return the
    value in the second row and first column, as we see it does.
  prefs: []
  type: TYPE_NORMAL
- en: The next line uses a single subscript, `b[1]`, and returns the entire second
    row of `b`. This is a very useful feature that we’ll see in our own code throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if `b[1]` returns the entire second row of the matrix, `b`, then we
    can use `b[1][0]` to ask for the first element of that row. We see that it matches
    the result of the `b[1,0]` syntax we started with.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing an Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Accessing individual elements of an array, or an entire subarray, with a single
    index is useful, but NumPy is far more flexible than that. It’s possible to specify
    parts of the array by using *slicing*, which returns subarrays carved out of the
    larger array as if with a knife. Let’s look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use `arange`, which is the NumPy analogue of the Python `range` function,
    to set `a` to a vector of the digits [0,9]. We then ask for a slice of this vector,
    `a[1:4]`, and see that it returns `[1, 2, 3]`. The slice was specified with two
    values: the first is the starting index, 1, and the second is the ending index,
    4.'
  prefs: []
  type: TYPE_NORMAL
- en: Wait—if the ending index is 4,then shouldn’t the slice have returned `[1, 2,
    3, 4]` instead? NumPy follows the Python convention for lists, so the ending index
    is never included in the returned subarray. We can read the slice as asking for
    all the elements of `a` starting at index 1 and up to *but not including* index
    4\. Mathematically, a slice given as `a[x:y]` means all elements, *i*, of `a`
    such that *x* ≤ *i* < *y*. Therefore, the second example, `a[3:7]`, now makes
    sense as it’s asking for all elements of `a` starting with index 3 up to but not
    including index 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The slices selected all elements in the given range. NumPy allows for an optional
    third slice argument that specifies a step size. If not given, the step size is
    1\. Therefore, with `a` as a vector of the digits as before, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first slice starts at the beginning of the array, index 0, and goes to index
    8 (but not including index 8) returning every second element. The second example
    does the same starting with index 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any part of the full slice syntax, `[x:y:z]`, may be omitted, but at least
    one colon must remain. If so, the default value is the first index (for `x`),
    the last index (for `y`), and 1 (for `z`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the starting index is omitted so it defaults to 0 and
    we’re given the first six elements of `a`. In the second example, the ending index
    is omitted so it defaults to the last index, meaning “return everything from index
    6 to the end.” In both cases, the increment was omitted and defaulted to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Array slicing leads to some handy shortcuts. Two are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first example shows us that like Python lists, NumPy arrays can be indexed
    with negative values to count from the end of an axis. So, asking for index –1
    will always return the last element.
  prefs: []
  type: TYPE_NORMAL
- en: The second example is a bit mysterious at first. We know that `a` is a vector
    of the digits from 0 through 9\. The example returns the vector in reverse order.
    How? Let’s break down the meaning of `::-1`. We said that any part of the array
    slice notation can be omitted, and if it is, the default is either the first index,
    the last index, or the increment. In this case, the first index is omitted so
    it defaults to 0\. The required colon (`:`) is present, and then the last index
    is omitted so it defaults to the last index. Then there’s a `:` for the increment,
    which is given as –1, to count backward from the ending index to the starting
    index. This is what counts backward and reverses the elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, array slicing works with NumPy arrays with any number of dimensions.
    Let’s look at slicing a two-dimensional matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We define `b` to be a vector of the numbers [0,19] by using `arange` and then
    immediately use `reshape` to change the vector into a matrix of four rows and
    five columns. The argument to `reshape` is a tuple specifying the new shape for
    the array. There must be exactly as many elements in the array as the new shape.
    The vector had 20 elements, and the new shape has 4 × 5 = 20 elements, so we are
    okay in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Array slicing applies per dimension, so the second example, `b[1:3,:]` is asking
    for rows 1 and 2 and all the columns in those rows. That is what : by itself means—all
    the elements along that axis.'
  prefs: []
  type: TYPE_NORMAL
- en: The next example asks for all the rows and columns starting with row 2 and column
    2\. This is the submatrix pulled from the lower-right corner of the full matrix
    `b`.
  prefs: []
  type: TYPE_NORMAL
- en: The Ellipsis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy supports a shorthand notation for slicing that’s sometimes useful. Let’s
    show it and then discuss what it’s doing. First, however, we need to define some
    arrays to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First we define `c` to be a three-dimensional array with three elements along
    each dimension. We use the same `reshape` trick that we used previously, and we
    know it will work because 3 × 3 × 3 = 27 and there are 27 elements in the initial
    vector produced by `arange`. Again, we can think of `c` as three 3×3 images stacked
    together. Next we use `ones` to define a simple 3×3 matrix with every value set
    to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our discussion of array slicing so far, we know that we can replace the
    3×3 subarray in `c` for any particular “image” by using the colon notation. For
    example, let’s replace the second “image” of `c` by `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we tell NumPy to replace the second subarray, which is 3×3, with the 3×3
    array in `a`. It’s the second subarray because the first index is given as 1\.
    When we print `c`, we see that the second 3×3 subarray is now all 1s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the shorthand notation. This time, we want to replace the first 3×3
    subarray of `c` with `a`. We could do this with a syntax of `c[0,:,:]` but instead
    we’ll use the shorthand notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that instead of `c[0,:,:]`, where we specified all the indices of all
    the remaining dimensions of `c`, we used `c[0,...]` which NumPy interprets as
    meaning “and as many colons as necessary to cover all the remaining dimensions.”
    Of course, the shape of `a` must match the shape of the subarray specified by
    all the remaining dimensions. In this example, there are two remaining dimensions
    and `a` is a two-dimensional array, so we do match. The ellipsis notation (`...`)
    is commonly used in Python code related to machine learning, so that’s why I mention
    it here. You could argue that from a readability standpoint, using `...` is not
    a good idea because it requires the reader of the code to remember how many dimensions
    a particular array has.
  prefs: []
  type: TYPE_NORMAL
- en: Operators and Broadcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NumPy uses all the standard math operators as well as a heap of other methods
    and functions that implement more advanced operations. NumPy also uses a concept
    called *broadcasting* to decide how to apply an operator to arrays. Let’s look
    at some simple operators and broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From earlier examples, we know that `a` is a vector of the digits 0 through
    4\. And, we know because of our discussion of array slicing, that `c` is a vector
    of the digits 4 down to 0, the reverse of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, we see that multiplying `a` by 3.14 multiplies each element
    by 3.14\. NumPy has broadcast the scalar 3.14 across all the elements of the array
    `a`. NumPy would do this no matter what shape `a` has. Operating on an array with
    a scalar performs the operation on all elements of the array, regardless of its
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: The expression `a*a` multiplies `a` by itself. In this case, NumPy sees that
    the two arrays have the same shape, so it multiplies corresponding elements, thereby
    squaring each element of `a`. Multiplying `a` by `c` is also straightforward because
    `c` has the same shape as `a`.
  prefs: []
  type: TYPE_NORMAL
- en: The last example uses broadcasting twice. First, it broadcasts the scalar 1
    across `c` to add one to each element of `c`. This operation does not change the
    shape of `c`, so dividing `a` by using integer division (`//` not `/`), by the
    expression `(c+1)`, works since each has the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some more examples. There’s no end to the number of examples
    we could give, but one more small set should cement the concepts for us. First
    a more complex broadcasting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `a` is a vector of digits. We then define `b` to be a 5×5 matrix
    of the numbers 0 through 24\. Next, we multiply `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should object. How can we multiply these two arrays when
    their shapes don’t match? The array `a` has only 5 elements, while `b` has 25\.
    This is where broadcasting comes into play. NumPy recognizes that the five-element
    vector in `a` matches the size of each *row* of `b` so it multiplies each row
    of `b` by `a` to return a new 5×5 matrix. This sort of broadcasting is actually
    quite handy. We’ll be storing our datasets primarily as two-dimensional NumPy
    arrays, where each row is a sample and the columns correspond to input values
    for that sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy also supports matrix math operations. These are the operations on vectors
    and matrices that we find in linear algebra. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we define `x` to be a simple vector of five elements. We then introduce
    NumPy’s primary vector and matrix product function, `dot`, to multiply `x` by
    itself. We already know that if we multiply `x` by itself in the standard way,
    using `x*x`, we’ll get each element times itself, giving `[0,1,4,9,16]`, but that’s
    not what we get here. Instead we get the scalar value, 30\. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer has to do with what `dot` does. It doesn’t implement element-wise
    multiplication but instead implements linear algebra multiplication. Specifically,
    because both arguments to `dot` are vectors, it implements vector times vector,
    which is known as the *dot product*, hence the name of the NumPy function. The
    dot product for vectors multiplies each element of the first vector by the corresponding
    element of the second vector and then adds all those products together. So, for
    `dot(x,x)` NumPy is calculating as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 1, 2, 3, 4] × [0, 1, 2, 3, 4] = [0, 1, 4, 9, 16]; 0 + 1 + 4 + 9 + 16 =
    30'
  prefs: []
  type: TYPE_NORMAL
- en: The `dot` function can be used to multiply two vectors, a vector and a matrix,
    or two matrices, all following the rules of linear algebra, which are beyond the
    scope of this book to explore in detail. That said, the `dot` function is of great
    importance to us because it is the workhorse function of machine learning with
    NumPy. In the end, most of modern machine learning boils down to math with vectors
    and matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example using `dot` with two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we define both `a` and `b` to be the same 3×3 matrix of the digits 0 through
    9\. We then use `dot` with these two matrices. For comparison purposes, we also
    show normal multiplication of the two matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two results are not the same. The first uses linear algebra rules for multiplying
    two 3×3 matrices, which says that the first element of the 3×3 output will be
    the first column of `b`, [0, 3, 6], multiplied element by element with the first
    row of `a`, [0, 1, 2], with each product summed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 3, 6] × [0, 1, 2] = [0, 3, 12]; 0 + 3 + 12 = 15'
  prefs: []
  type: TYPE_NORMAL
- en: A similar process creates each of the other entries. For the simple multiplication,
    the first element of the 3×3 output is simply 0 × 0 = 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the inputs to `dot` are matrices, then `dot` acts as we expect: it’s matrix
    multiplication. It’s when one of the inputs is a vector and the other a matrix
    that things get a little sloppy. NumPy is somewhat careless about whether the
    vector is a row or column vector—it produces the correct result regardless, though
    the shape of the result might not follow linear algebra rules precisely.'
  prefs: []
  type: TYPE_NORMAL
- en: We trudged through the linear algebra examples because as you continue to explore
    machine learning, you’ll encounter code using `dot` quite frequently. It’s good
    to know what it does, but because of its tolerance of the shape of its inputs,
    you might need to work through the code paying careful attention to the actual
    shapes of your arrays to avoid getting lost.
  prefs: []
  type: TYPE_NORMAL
- en: Array Input and Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy would be difficult to use if it didn’t provide the means for storing arrays
    on disk and reading arrays from disk. Sure, we could use a standard Python module
    like `pickle`, but that’s inefficient and makes interchange between software packages
    difficult. Fortunately for us, the creators of NumPy were thorough and included
    input/output functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we’ll refer to several disk files. The first is *abc.txt*,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It’s a file of three lines with three numbers per line separated by a space.
    The second is *abc_tab.txt*, which is identical to *abc.txt*, but the spaces have
    been replaced by a tab character, `\t` in Python. Tab-delimited files are commonly
    used to store data in files. The last file is *abc.csv*, which is a comma-separated
    values (CSV) file often used by spreadsheet programs. It’s also the same as *abc.txt*,
    but the spaces have been replaced by commas. Now, let’s look at NumPy’s basic
    input/output capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first three examples use `loadtxt`, which reads text files and produces
    NumPy arrays from them. The first two examples show that `loadtxt` knows how to
    parse files with values separated by spaces and tab characters. The function uses
    the rows of the text file as rows of the matrix, and the values on each line as
    the elements in each row.
  prefs: []
  type: TYPE_NORMAL
- en: The third example explicitly states that the delimiter (separator) between values
    in the text file is the comma character (`,`) ❶. This is how to read a *.csv*
    file in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy uses the `save` function to write arrays to disk ❷. This function writes
    a single array to the given filename. NumPy uses a *.npy* file extension to identify
    the file as containing a NumPy array. We’ll make extensive use of *.npy* files
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: To read an array back into memory from disk, use `load` ❸. Note that the data
    in the array is loaded, but you must assign it to a new variable name. The *.npy*
    file doesn’t store the original name of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we’ll want to write arrays in a format that will be readable by other
    programs or humans. On those occasions, we’ll use the `savetxt` function ❹. These
    examples write text files, first using spaces between values and then using a
    comma between values.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to write multiple arrays to disk? Are we forced to use a single
    file for each array? Fortunately, no, we can use `savez` and read them with `load`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we store the two arrays, `a` and `b`, to a single file, *arrays.npz* ❶.
    We still read the file with `load`, but instead of the arrays, `q` is more like
    a dictionary so that if we ask for the keys as a list ❷, we get a list of the
    names of the arrays read from the file. Referencing an array by its name returns
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look again at the call to `savez` ❶. Notice how we specified the arrays? This
    is the keyword approach, and it gives the arrays the keyword name, which we made
    the same as the variable name so that when we asked for the keys after opening
    the file, we got back the names we expect. We could have dispensed with the keyword
    names and simply used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This would write the arrays to the file by using default names of `arr_0` and
    `arr_1`. Lastly, since arrays can be quite large, we might want to compress them
    (losslessly!), and for that, we’d have used `savez_compressed` in place of `savez`.
  prefs: []
  type: TYPE_NORMAL
- en: Compression might be worth it, but it does slow reading and writing. For example,
    a 64-bit floating-point array of 10 million element requires at a minimum 80,000,000
    bytes of memory. Using `savez` to write such an array to disk uses 80,000,244
    bytes and takes only a fraction of a second. The extra 244 bytes are overhead
    for the structure of the dictionary. Writing the compressed file to disk takes
    a second or two but results in a file of 11,960,115 bytes, considerably smaller.
    Since this example was made using `arange`, each element of the output array was
    unique so the compression is not the result of storing an array of 10 million
    zeros. For the curious, storing 10 million zeros uncompressed still uses 80,000,244
    bytes but compressed uses only 77,959 bytes on disk. So, the more redundant the
    array, the more the savings when compressed.
  prefs: []
  type: TYPE_NORMAL
- en: Random Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy has extensive support for pseudorandom number generation. We’ll be sloppy
    and simply call them *random numbers*, understanding that computers are not capable
    by any algorithmic process of producing actual random numbers—if you’re curious
    about pseudorandom number generation, you can read my book, *Random Numbers and
    Computers* (Springer 2018). The NumPy random number library is under `random`
    and can generate samples from many different distributions, the most common being
    a uniform distribution, [0,1). This means that any (representable) floating-point
    number in that range is equally likely. Usually, this is what we want. At other
    times we might want to use a normal distribution that looks like the classic bell-shaped
    curve. Many physical processes follow this curve. NumPy can generate such samples
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The random number functions we’ll use in this book are `random.random` to generate
    random numbers from [0,1), `random.normal` to generate random numbers drawn from
    a bell-shaped curve, and `random.seed` to set the seed of the generator so we
    can produce the same sequence of random numbers over and over. We’ll leave it
    to the philosophers to decide if such a sequence still deserves the label *random*
    or, for that matter, if it ever did, regardless of the seed value.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy and Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the datasets we’ll use are image based. We’ll want to work with the
    datasets in NumPy, so we need to know something about how to work with images
    in Python and how to get images into and out of NumPy arrays. Fortunately, it’s
    pretty straightforward. Besides NumPy, we’ll need to work with the Pillow module
    (`PIL`) to read and write images. We have Pillow installed already—it comes with
    the installation of our main toolkits. We also have some sample images as part
    of `sklearn`.
  prefs: []
  type: TYPE_NORMAL
- en: We need to think in terms of two worlds when working with images. There’s the
    “NumPy” world, where the image has been converted into a NumPy array, and there’s
    the `PIL` world that reads and writes images in common graphics formats like JPEG
    and PNG. The distinction really isn’t so black-and-white—we can do image processing
    in `PIL` too, and sometimes that is more convenient; but for now, we’ll use `PIL`
    only as a way to read and write image files.
  prefs: []
  type: TYPE_NORMAL
- en: Images are two-dimensional arrays of numbers, but if the image is color, we
    will have three or even four numbers for each pixel, each a byte value representing
    the intensity of the red, green, blue, and sometimes, alpha, channels of the image.
    We’ll assume that all of our images are either one-channel grayscale or three-channel
    RGB. We’ll eliminate any alpha channel when we encounter one. The alpha channel
    determines how transparent the pixel is.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s see how to get at the example images `sklearn` provides and how
    to turn them into `PIL` images, store them on disk, and display them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to import `PIL` ❶ and the sample images function from `sklearn`.
    Once we have those, we can get at the actual images as NumPy arrays ❷. We see
    that the *china* and *flower* images are three-dimensional arrays, meaning they
    are RGB images. The images are 427×640 pixels. The third dimension is 3, corresponding
    to the red, green, and blue channels. If the images were grayscale, they would
    have only two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: We can convert the NumPy arrays to `PIL` image objects ❸ by using the `fromarray`
    function. The argument is assumed to be a NumPy array of the proper format for
    conversion. Usually this means that the array must have a data type of `uint8`.
    Once we have the `PIL` image objects, we can view the images with the `show` method.
  prefs: []
  type: TYPE_NORMAL
- en: To write the images to disk as actual graphics files, not NumPy arrays, we use
    the `save` method on the `PIL` objects ❹. The format of the output file is determined
    by the file extension. Here we’re using PNG.
  prefs: []
  type: TYPE_NORMAL
- en: To read an image file from disk, we use the `open` function ❺. Note that `open`
    returns a `PIL` image object, not a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to turn the `PIL` image object into a NumPy array. Also, let’s
    see how to use `PIL` to make a color image grayscale before turning it into a
    NumPy array. We’ll use each of these steps later in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We first load the image from disk into a `PIL` image object, `im`. We then pass
    the image object to NumPy via the `array` function ❶. This function is savvy enough
    to recognize a `PIL` image object and make the proper conversion to a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: We can also turn the `PIL` RGB image into a grayscale image using the `convert`
    method. Note that `PIL` uses `L` for *luminance* to refer to grayscale images
    ❷. Again, `array` converts the now grayscale image into a NumPy array. We see
    that the image has only two dimensions, as we would expect from a grayscale image,
    where each pixel value is just a shade of gray, not a color.
  prefs: []
  type: TYPE_NORMAL
- en: The `PIL` module has many other abilities. It’s a good idea to look at the Pillow
    website, *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*,
    to see the other things you can do with PIL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we reviewed how to work with NumPy, the foundational toolkit
    used by both `sklearn` and Keras. This gives us the background we need to understand
    the code examples we’ll see later in the book. It’s essential to understand how
    to use NumPy, at least at a basic level. The examples in this chapter should help.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re familiar with NumPy, we are ready to dive into working with data.
  prefs: []
  type: TYPE_NORMAL
