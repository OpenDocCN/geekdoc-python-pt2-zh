["```py\nQuadTreeNode {\n    Boolean: is_leaf\n    Integer: num_points\n    Float: x_min\n    Float: x_max\n    Float: y_min\n    Float: y_max\n    Matrix of QuadTreeNodes: children\n    Array of Points: points\n}\n```", "```py\nPoint {\n    Float: x\n    Float: y\n}\n```", "```py\nQuadTree {\n    QuadTreeNode: root\n}\n```", "```py\nQuadTreeInsert(QuadTree: tree, Float: x, Float: y):\n    IF x < tree.root.x_min OR x > tree.root.x_max:\n        return False\n    IF y < tree.root.y_min OR y > tree.root.y_max:\n        return False\n    QuadTreeNodeInsert(tree.root, x, y)\n    return True\n```", "```py\nQuadTreeNodeInsert(QuadTreeNode: node, Float: x, Float: y):\n  ❶ node.num_points = node.num_points + 1\n\n    # Determine into which child bin the point should go.\n  ❷ Float: x_bin_size = (node.x_max - node.x_min) / 2.0\n    Float: y_bin_size = (node.y_max - node.y_min) / 2.0\n    Integer: xbin = Floor((x - node.x_min) / x_bin_size)\n    Integer: ybin = Floor((y - node.y_min) / y_bin_size)\n\n    # Add the point to the correct child.\n  ❸ IF NOT node.is_leaf:\n      ❹ IF node.children[xbin][ybin] == null:\n            node.children[xbin][ybin] = QuadTreeNode(\n                  node.x_min + xbin * x_bin_size,\n                  node.x_min + (xbin + 1) * x_bin_size,\n                  node.y_min + ybin * y_bin_size,\n                  node.y_min + (ybin + 1) * y_bin_size)\n        QuadTreeNodeInsert(node.children[xbin][ybin], x, y)\n        return\n\n # Add the point to a leaf node and split if needed.\n  ❺ node.points.append(Point(x, y))\n  ❻ IF we satisfy the conditions to split:\n        node.is_leaf = False\n      ❼ FOR EACH pt IN node.points:\n            QuadTreeNodeInsert(node, pt.x, pt.y)\n      ❽ node.num_points = (node.num_points -\n                           length(node.points))\n        node.points = []\n```", "```py\nQuadTreeNodeCollapse(QuadTreeNode: node):\n  ❶ IF node.is_leaf:\n        return node.points\n\n  ❷ FOR i IN [0, 1]:\n        FOR j IN [0, 1]:\n            IF node.children[i][j] != null:\n                Array: sub_pts = QuadTreeNodeCollapse(node.children[i][j])\n                FOR EACH pt IN sub_pts:\n                    node.points.append(pt)\n                node.children[i][j] = null\n  ❸ node.is_leaf = True\n  ❹ return node.points\n```", "```py\nQuadTreeDelete(QuadTree: tree, Float: x, Float: y):\n    IF x < tree.root.x_min OR x > tree.root.x_max:\n        return False\n    IF y < tree.root.y_min OR y > tree.root.y_max:\n        return False\n    return QuadTreeNodeDelete(tree.root, x, y)\n```", "```py\nQuadTreeNodeDelete(QuadTreeNode: node, Float: x, Float: y):\n  ❶ IF node.is_leaf:\n        Integer: i = 0\n      ❷ WHILE i < length(node.points):\n          ❸ IF approx_equal(node.points[i].x, node.points[i].y, x, y):\n                remove point i from node.points\n                node.num_points = node.num_points - 1\n                return True\n i = i + 1\n        return False\n\n    # Determine into which child bin the point to be removed would go.\n  ❹ Float: x_bin_size = (node.x_max - node.x_min) / 2.0\n    Float: y_bin_size = (node.y_max - node.y_min) / 2.0\n    Integer: xbin = Floor((x - node.x_min) / x_bin_size)\n    Integer: ybin = Floor((y - node.y_min) / y_bin_size)\n\n  ❺ IF node.children[xbin][ybin] == null:\n        return False\n\n  ❻ IF QuadTreeNodeDelete(node.children[xbin][ybin], x, y):\n        node.num_points = node.num_points - 1\n\n      ❼ IF node.children[xbin][ybin].num_points == 0:\n            node.children[xbin][ybin] = null\n\n      ❽ IF node no longer meets the split conditions\n            node.points = QuadTreeNodeCollapse(node)\n        return True\n  ❾ return False\n```", "```py\nMinDist(QuadTreeNode: node, Float: x, Float: y):\n    Float: x_dist = 0.0\n    IF x < node.x_min:\n        x_dist = node.x_min – x\n    IF x > node.x_max:\n        x_dist = x – node.x_max\n\n    Float: y_dist = 0.0\n    IF y < node.y_min:\n        y_dist = node.y_min – y\n    IF y > node.y_max:\n        y_dist = y – node.y_max\n\n    return sqrt(x_dist*x_dist + y_dist*y_dist)\n```", "```py\nQuadTreeNearestNeighbor(QuadTree: tree, Float: x, Float: y):\n    return QuadTreeNodeNearestNeighbor(tree.root, x, y, Inf)\n```", "```py\nQuadTreeNodeNearestNeighbor(QuadTreeNode: node, Float: x,\n                            Float: y, Float: best_dist):\n    # Prune if the node is too far away. \n  ❶ IF MinDist(node, x, y) >= best_dist:\n        return null\n    Point: best_candidate = null\n\n # If we are in a leaf, search the points.\n  ❷ IF node.is_leaf:\n        FOR EACH current IN node.points:\n            Float: dist = euclidean_dist(x, y, current.x, current.y)\n\n            IF dist < best_dist:\n                best_dist = dist\n                best_candidate = current\n        return best_candidate\n\n    # Recursively check all 4 children starting with the closest.\n  ❸ Float: x_bin_size = (node.x_max - node.x_min) / 2.0 \n    Float: y_bin_size = (node.y_max - node.y_min) / 2.0 \n    Integer: xbin = Floor((x - node.x_min) / x_bin_size)\n    IF xbin < 0:\n        xbin = 0\n    IF xbin > 1:\n        xbin = 1\n\n    Integer: ybin = Floor((y - node.y_min) / y_bin_size)\n    IF ybin < 0:\n        ybin = 0\n    IF ybin > 1:\n        ybin = 1\n\n  ❹ FOR EACH i IN [xbin, (xbin + 1) % 2]:\n        FOR EACH j IN [ybin, (ybin + 1) % 2]:\n            IF node.children[i][j] != null:\n                Point: quad_best = QuadTreeNodeNearestNeighbor(\n                                       node.children[i][j], \n                                       x, y, best_dist)\n              ❺ IF quad_best != null:\n                    best_candidate = quad_best\n                    best_dist = euclidean_dist(x, y, quad_best.x, \n                                               quad_best.y)\n    return best_candidate\n```", "```py\npt[split_dim] <= split_val\n```", "```py\nx_min[d] <= pt[d] <= x_max[d] FOR ALL d\n```", "```py\nKDTreeNode {\n    Boolean: is_leaf\n    Integer: num_dimensions\n    Integer: num_points\n    Array of Floats: x_min\n    Array of Floats: x_max\n    Integer: split_dim\n    Float: split_val\n    KDTreeNode: left\n    KDTreeNode: right\n    Array of Arrays: points\n}\n```", "```py\nKDTree {\n    Integer: num_dimensions\n    KDTreeNode: root\n}\n```", "```py\nComputeBoundingBox(Array of Arrays: pts):\n  ❶ Integer: num_points = length(pts)\n    IF num_points == 0:\n        return Error\n    Integer: num_dims = length(pts[0])\n\n  ❷ Array: L = Array of length num_dims\n    Array: H = Array of length num_dims\n    Integer: d = 0\n  ❸ WHILE d < num_dims:\n        L[d] = pts[0][d]\n        H[d] = pts[0][d]\n        d = d + 1\n\n    Integer: i = 1\n  ❹ WHILE i < num_points:\n        d = 0\n        WHILE d < num_dims:\n            IF L[d] > pts[i][d]:\n                L[d] = pts[i][d]\n            IF H[d] < pts[i][d]:\n                H[d] = pts[i][d]\n            d = d + 1\n        i = i + 1\n  ❺ return (L, H)\n```", "```py\nBuildKDTree(KDTree: tree, Array of Arrays: pts):\n  FOR EACH pt IN pts:\n      IF length(pt) != tree.num_dimensions:\n          Return an error.\n  IF length(pts) > 0:\n      tree.root = KDTreeNode()\n      RecursiveBuildKDTree(tree.root, tree.num_dimensions, pts)\n  ELSE:\n      tree.root = null\n```", "```py\nRecursiveBuildKDTree(KDTreeNode: node, Integer: num_dims,\n                     Array of Arrays: pts):\n  ❶ node.num_points = length(pts)\n    node.num_dimensions = num_dims\n    node.left = null\n    node.right = null\n    node.points = empty array\n    node.split_dim = -1\n    node.split_val = 0.0\n    node.is_leaf = True\n\n    # Compute the bounding box of the points.\n  ❷ (node.x_min, node.x_max) = ComputeBoundingBox(pts)\n\n    # Compute the width of the widest dimension.\n  ❸ Float: max_width = 0.0\n    Integer: d = 0\n    WHILE d < node.num_dimensions:\n        IF node.x_max[d] - node.x_min[d] > max_width:\n            max_width = node.x_max[d] - node.x_min[d]\n        d = d + 1\n # If we meet the conditions for a leaf, append the\n    # remaining points to the node's point list.\n  ❹ IF we do not satisfy the conditions to split:\n        FOR EACH pt IN pts:\n            node.points.append(pt)\n        return\n\n    # Choose split dimension and value.\n  ❺ node.split_dim = chosen split dimension\n    node.split_val = chosen split value along node.split_dim\n    node.is_leaf = False\n\n    # Partition the points into two sets based on\n    # the split dimension and value.\n    Array of Arrays: left_pts = []\n    Array of Arrays: right_pts = []\n  ❻ FOR EACH pt IN pts:\n        IF pt[node.split_dim] <= node.split_val:\n            left_pts.append(pt)\n        ELSE:\n            right_pts.append(pt)\n\n    # Recursively build the child nodes.\n  ❼ node.left = KDTreeNode()\n    RecursiveBuildKDTree(node.left, num_dims, left_pts)\n\n    node.right = KDTreeNode()\n    RecursiveBuildKDTree(node.right, num_dims, right_pts)\n```", "```py\n Float: max_width = 0.0\n    Integer: split_dim = 0\n    Integer: d = 0\n WHILE d < node.num_dimensions:\n        IF node.x_max[d] - node.x_min[d] > max_width:\n            max_width = node.x_max[d] - node.x_min[d]\n            split_dim = d\n        d = d + 1\n```", "```py\n node.split_dim = split_dim\n    node.split_val = (node.x_min[node.split_dim] + \n                      node.x_max[node.split_dim]) / 2.0\n```", "```py\n     Integer: d = 0\n        WHILE d < node.num_dimensions:\n            IF x[d] < node.x_min[d]:\n                node.x_min[d] = x[d]\n            IF x[d] > node.x_max[d]:\n                node.x_max[d] = x[d]\n            d = d + 1\n    ```", "```py\n    KDTreeNodeMinDist(KDTreeNode: node, Point: pt):\n        Float: dist_sum = 0.0\n        Integer: d = 0\n        WHILE d < node.num_dimensions:\n            Float: diff = 0.0\n            IF pt[d] < node.x_min[d]:\n                diff = node.x_min[d] - pt[d]\n            IF pt[d] > node.x_max[d]:\n                diff = pt[d] - node.x_max[d]\n            dist_sum = dist_sum + diff * diff\n            d = d + 1\n        return sqrt(dist_sum)\n    ```"]