<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><span class="big">1</span><br/>SAVING SHIPWRECKED SAILORS WITH BAYES’ RULE</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Sometime around 1740, an English Presbyterian minister named Thomas Bayes decided to mathematically prove the existence of God. His ingenious solution, now known as <em>Bayes’ rule</em>, would become one of the most successful statistical concepts of all time. But for 200 years it languished, largely ignored, because its tedious mathematics were impractical to do by hand. It took the invention of the modern computer for Bayes’ rule to reach its full potential. Now, thanks to our fast processors, it forms a key component of data science and machine learning.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_2"/>Because Bayes’ rule shows us the mathematically correct way to incorporate new data and recalculate probability estimates, it penetrates almost all human endeavors, from cracking codes to picking presidential winners to demonstrating that high cholesterol causes heart attacks. A list of applications of Bayes’ rule could easily fill this chapter. But since nothing is more important than saving lives, we’ll focus on the use of Bayes’ rule to help save sailors lost at sea.</p>&#13;
<p class="indent">In this chapter, you’ll create a simulation game for a Coast Guard search and rescue effort. Players will use Bayes’ rule to guide their decisions so they can locate the sailor as quickly as possible. In the process, you’ll start working with popular computer vision and data science tools like Open Source Computer Vision Library (OpenCV) and <span class="literal">NumPy</span>.</p>&#13;
<h3 class="h3" id="ch00lev1sec5"><strong>Bayes’ Rule</strong></h3>&#13;
<p class="noindent">Bayes’ rule helps investigators determine the probability that something is true given new evidence. As the great French mathematician Laplace put it, “The probability of a cause—given an event—is proportional to the probability of the event—given its cause.” The basic formula is</p>&#13;
<div class="image1"><img src="../images/equ_page_2_01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>A</em> is a hypothesis and <em>B</em> is data. <em>P</em>(<em>A</em>/<em>B</em>) means the probability of <em>A</em> given <em>B</em>. <em>P</em>(<em>B</em>/<em>A</em>) means the probability of <em>B</em> given <em>A</em>. For example, assume we know that a certain test for a certain cancer is not always accurate and can give false positives, indicating that you have cancer when you don’t. The Bayes expression would be</p>&#13;
<div class="image1"><img src="../images/equ_page_2_02.jpg" alt="Image"/></div>&#13;
<p class="indent">The initial probabilities would be based on clinical studies. For example, 800 out of 1,000 people who have cancer may receive a positive test result, and 100 out of 1,000 may be misdiagnosed. Based on disease rates, the overall chance of a given person having cancer may only be 50 out of 10,000. So, if the overall probability of having cancer is low and the overall probability of getting a positive test result is relatively high, the probability of having cancer given a positive test goes down. If studies have recorded the frequency of inaccurate test results, Bayes’ rule can correct for measurement errors!</p>&#13;
<p class="indent">Now that you’ve seen an example application, look at <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>, which shows the names of the various terms in Bayes’ rule, along with how they relate to the cancer example.</p>&#13;
<div class="image"><img src="../images/fig01_01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig1"/>Figure 1-1: Bayes’ rule with terms defined and related to the cancer test example<span epub:type="pagebreak" id="page_3"/></p>&#13;
<p class="indent">To illustrate further, let’s consider a woman who has lost her reading glasses in her house. The last time she remembers wearing them, she was in her study. She goes there and looks around. She doesn’t see her glasses, but she does see a teacup and remembers that she went to the kitchen. At this point, she must make a choice: search the study more thoroughly or leave and check the kitchen. She decides to go to the kitchen. She has unknowingly made a Bayesian decision.</p>&#13;
<p class="indent">She went to the study first because she felt it offered the highest probability for success. In Bayesian terms, this initial probability of finding the glasses in the study is called the <em>prior</em>. After a cursory search, she changed her decision based on two new bits of information: she did not easily find the glasses, and she saw the teacup. This represents a <em>Bayesian update</em>, in which a new posterior estimate (<em>P</em>(<em>A</em>/<em>B</em>) in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>) is calculated as more evidence becomes available.</p>&#13;
<p class="indent">Let’s imagine that the woman decided to use Bayes’ rule for her search. She would assign actual probabilities both to the likelihood of the glasses being in either the study or the kitchen and to the effectiveness of her searches in the two rooms. Rather than intuitive hunches, her decisions are now grounded in mathematics that can be continuously updated if future searches fail.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01fig2">Figure 1-2</a> illustrates the woman’s search for her glasses with these probabilities assigned.<span epub:type="pagebreak" id="page_4"/></p>&#13;
<div class="image"><img src="../images/fig01_02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig2"/>Figure 1-2: Initial probabilities for the location of the glasses and search effectiveness (left) versus updated target probabilities for the glasses (right)</p>&#13;
<p class="indent">The left diagram represents the initial situation; the right diagram is updated with Bayes’ rule. Initially, let’s say there was an 85 percent chance of finding the glasses in the study and a 10 percent chance that the glasses are in the kitchen. Other possible rooms are given 1 percent because Bayes’ rule can’t update a target probability of zero (plus there’s always a small chance the woman left them in one of the other rooms).</p>&#13;
<p class="indent">Each number after a slash in the left diagram represents the <em>search effectiveness probability (SEP)</em>. The SEP is an estimate of how effectively you’ve searched an area. Because the woman has searched only in the study at this point, this value is zero for all other rooms. After the Bayesian update (the discovery of the teacup), she can recalculate the probabilities based on the search results, shown on the right. The kitchen is now the most likely place to look, but the probability for the other rooms increases as well.</p>&#13;
<p class="indent">Human intuition tells us that if something isn’t where we think it is, the odds that it is someplace else go up. Bayes’ rule takes this into account, and thus the probability that the glasses are in other rooms increases. But this can happen only if there was a chance of them being in the other room in the first place.</p>&#13;
<p class="indent">The formula used for calculating the probability that the glasses are in a given room, given the search effectiveness, is</p>&#13;
<div class="image1"><img src="../images/equ_page_4_01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>G</em> is the probability that the glasses are in a room, <em>E</em> is the search effectiveness, and <em>P</em><sub>prior</sub> is the prior, or initial, probability estimate before receiving the new evidence.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_5"/>You can obtain the updated possibility that the glasses are in the study by inserting the target and search effectiveness probabilities into the equation as follows:</p>&#13;
<div class="image1"><img src="../images/equ_page_5_01.jpg" alt="Image"/></div>&#13;
<p class="indent">As you can see, the simple math behind Bayes’ rule can quickly get tedious if you do it by hand. Fortunately for us, we live in the wonderous age of computers, so we can let Python handle the boring stuff!</p>&#13;
<h3 class="h3ab" id="ch00lev1sec6"><strong>Project #1: Search and Rescue</strong></h3>&#13;
<p class="noindent">In this project, you’ll write a Python program that uses Bayes’ rule to find a solitary fisherman who has gone missing off Cape Python. As the director of the Coast Guard’s search and rescue operations for the region, you’ve already interviewed his wife and determined his last known position, now more than six hours old. He radioed that he was abandoning ship, but no one knows if he is in a life raft or floating in the sea. The waters around the cape are warm, but if he’s immersed, he’ll experience hypothermia in 12 hours or so. If he’s wearing a personal flotation device and lucky, he might last three days.</p>&#13;
<p class="indent">The ocean currents off Cape Python are complex (<a href="ch01.xhtml#ch01fig3">Figure 1-3</a>), and the wind is currently blowing from the southwest. Visibility is good, but the waves are choppy, making a human head hard to spot.</p>&#13;
<div class="image"><img src="../images/fig01_03.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig3"/>Figure 1-3: Ocean currents off Cape Python</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_6"/>In real life, your next course of action would be to plug all the information you have into the Coast Guard’s Search and Rescue Optimal Planning System (SAROPS). This software considers factors such as winds, tides, currents, whether a body is in the water or in a boat, and so on. It then generates rectangular search areas, calculates the initial probabilities for finding the sailor in each area, and plots the most efficient flight patterns.</p>&#13;
<p class="indent">For this project, you’ll assume that SAROPS has identified three search areas. All you need to do is write the program that applies Bayes’ rule. You also have enough resources available to search two of the three areas in a day. You’ll have to decide how to allocate those resources. It’s a lot of pressure, but you have a powerful assistant to help you out: Bayes’ rule.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Create a search and rescue game that uses Bayes’ rule to inform player choices on how to conduct a search.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec5"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">Searching for the sailor is like looking for the lost glasses in our previous example. You’ll start with initial target probabilities for the sailor’s location and update them for the search results. If you achieve an effective search of an area but find nothing, the probability that the sailor is in another area will increase.</p>&#13;
<p class="indent">But just as in real life, there are two ways things could go wrong: you thoroughly search an area but still miss the sailor, or your search goes poorly, wasting a day’s effort. To equate this to search effectiveness scores, in the first case, you might get an SEP of 0.85, but the sailor is in the remaining 15 percent of the area not searched. In the second case, your SEP is 0.2, and you’ve left 80 percent of the area unsearched!</p>&#13;
<p class="indent">You can see the dilemma real commanders face. Do you go with your gut and ignore Bayes? Do you stick with the pure, cold logic of Bayes because you believe it’s the best answer? Or do you act expediently and protect your career and reputation by going with Bayes even when you doubt it?</p>&#13;
<p class="indent">To aid the player, you’ll use the OpenCV library to build an interface for working with the program. Although the interface can be something simple, like a menu built in the shell, you’ll also want a map of the cape and the search areas. You’ll use this map to display the sailor’s last known position and his position when found. The OpenCV library is an excellent choice for this game since it lets you display images and add drawings and text.</p>&#13;
<h4 class="h4" id="ch00lev2sec6"><strong><em>Installing the Python Libraries</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_7"/><em>OpenCV</em> is the world’s most popular computer vision library. <em>Computer vision</em> is a field of deep learning that enables machines to see, identify, and process images like humans. OpenCV began as an Intel Research initiative in 1999 and is now maintained by the OpenCV Foundation, a nonprofit foundation which provides the software for free.</p>&#13;
<p class="indent">OpenCV is written in C++, but there are bindings in other languages, such as Python and Java. Although aimed primarily at real-time computer vision applications, OpenCV also includes common image manipulation tools such as those found in the Python Imaging Library. As of this writing, the current version is OpenCV 4.1.</p>&#13;
<p class="indent">OpenCV requires both the Numerical Python (<span class="literal">NumPy</span>) and <span class="literal">SciPy</span> packages to perform numerical and scientific computing in Python. OpenCV treats images as three-dimensional <span class="literal">NumPy</span> arrays (<a href="ch01.xhtml#ch01fig4">Figure 1-4</a>). This allows for maximum interoperability with other Python scientific libraries.</p>&#13;
<div class="image"><img src="../images/fig01_04.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig4"/>Figure 1-4: Visual representation of a three-channel color image array</p>&#13;
<p class="indent">OpenCV stores properties as rows, columns, and channels. For the image represented in <a href="ch01.xhtml#ch01fig4">Figure 1-4</a>, its “shape” would be a three-element tuple (4, 5, 3). Each stack of cells, like 0-20-40 or 19-39-59, represents a single pixel. The numbers shown are the intensity values for each color channel for that pixel.</p>&#13;
<p class="indent">As many projects in this book require scientific Python libraries like <span class="literal">NumPy</span> and <span class="literal">matplotlib</span>, this is a good time to install them.</p>&#13;
<p class="indent">There are numerous ways to install these packages. One way is to use <span class="literal">SciPy</span>, an open source Python library used for scientific and technical computing (see <em><a href="https://scipy.org/index.html">https://scipy.org/index.html</a></em>).</p>&#13;
<p class="indent">Alternatively, if you’re going to do a lot of data analysis and plotting on your own time, you may want to download and use a free Python distribution like Anaconda or Enthought Canopy, which work with Windows, Linux, and macOS. These distributions spare you the task of finding and installing the correct versions of all the required data science libraries, such as <span class="literal">NumPy</span>, <span class="literal">SciPy</span>, and so on. A listing of these types of distributions, along with links to their websites, can be found at <em><a href="https://scipy.org/install.html">https://scipy.org/install.html</a></em>.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_8"/><strong>Installing NumPy and Other Scientific Packages with pip</strong></h5>&#13;
<p class="noindent">If you want to install the products directly, use the <em>Preferred Installer Program (pip)</em>, a package management system that makes it easy to install Python-based software (see <em><a href="https://docs.python.org/3/installing/">https://docs.python.org/3/installing/</a></em>). For Windows and macOS, Python versions 3.4 and newer come with pip preinstalled. Linux users may have to install pip separately. To install or upgrade pip, see the instructions at <em><a href="https://pip.pypa.io/en/stable/installing/">https://pip.pypa.io/en/stable/installing/</a></em> or search online for instructions on installing pip on your particular operating system.</p>&#13;
<p class="indent">I used pip to install the scientific packages using the instructions at <em><a href="https://scipy.org/install.html">https://scipy.org/install.html</a></em>. Because <span class="literal">matplotlib</span> requires multiple dependen-cies, you’ll need to install these as well. For Windows, run the following Python 3–specific command using PowerShell, launched (using <small>SHIFT</small>-right-click) from within the folder containing the current Python installation:</p>&#13;
<pre><span class="codestrong1">$ python -m pip install --user numpy scipy matplotlib ipython jupyter pandas sympy nose</span></pre>&#13;
<p class="indent">If you have both Python 2 and 3 installed, use <span class="literal">python3</span> in place of <span class="literal">python</span>.</p>&#13;
<p class="indent">To verify that <span class="literal">NumPy</span> has been installed and is available for OpenCV, open a Python shell and enter the following:</p>&#13;
<pre><span class="codestrong1">&gt;&gt;&gt; import numpy</span></pre>&#13;
<p class="indent">If you don’t see an error, you’re ready to install OpenCV.</p>&#13;
<h5 class="h5"><strong>Installing OpenCV with pip</strong></h5>&#13;
<p class="noindent">You can find installation instructions for OpenCV at <em><a href="https://pypi.org/project/opencv-python/">https://pypi.org/project/opencv-python/</a></em>. To install OpenCV for standard desktop environments (Windows, macOS, and almost any GNU/Linux distribution), enter the following in a PowerShell or terminal window:</p>&#13;
<pre><span class="codestrong1">pip install opencv-contrib-python</span></pre>&#13;
<p class="indent">or</p>&#13;
<pre><span class="codestrong1">python -m pip install opencv-contrib-python</span></pre>&#13;
<p class="indent">If you have multiple versions of Python installed (such as versions 2.7 and 3.7), you will need to specify the Python version you want to use.</p>&#13;
<pre><span class="codestrong1">py -3.7 -m pip install --user opencv-contrib-python</span></pre>&#13;
<p class="indent">If you’re using Anaconda as a distribution medium, you can run this:</p>&#13;
<pre><span class="codestrong1">conda install opencv</span></pre>&#13;
<p class="indent">To check that everything loaded properly, enter the following in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import cv2</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>No error means you’re good to go! If you get an error, read the troubleshooting list at <em><a href="https://pypi.org/project/opencv-python/">https://pypi.org/project/opencv-python/</a></em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec7"><strong><em>The Bayes Code</em></strong></h4>&#13;
<p class="noindent">The <em>bayes.py</em> program you’ll write in this section simulates the search for a missing sailor over three contiguous search areas. It will display a map, print a menu of search choices for the user, randomly choose a location for the sailor, and either reveal the location if a search locates him or do a Bayesian update of the probabilities of finding the sailor for each search area. You can download the code, along with the map image (<em>cape_python.png</em>), from <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h5 class="h5"><strong>Importing Modules</strong></h5>&#13;
<p class="noindent"><a href="ch01.xhtml#ch01list1">Listing 1-1</a> starts the <em>bayes.py</em> program by importing the required modules and assigning some constants. We’ll look at what these modules do as we implement them in the code.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 1&#13;
import sys&#13;
import random&#13;
import itertools&#13;
import numpy as np&#13;
import cv2 as cv&#13;
&#13;
MAP_FILE = 'cape_python.png'&#13;
 &#13;
SA1_CORNERS = (130, 265, 180, 315)  # (UL-X, UL-Y, LR-X, LR-Y)&#13;
SA2_CORNERS = (80, 255, 130, 305)  # (UL-X, UL-Y, LR-X, LR-Y)&#13;
SA3_CORNERS = (105, 205, 155, 255)  # (UL-X, UL-Y, LR-X, LR-Y)</pre>&#13;
<p class="listing"><a id="ch01list1"/>Listing 1-1: Importing modules and assigning constants used in the <span class="normal">bayes.py</span> program</p>&#13;
<p class="indent">When importing modules into a program, the preferred order is the Python Standard Library modules, followed by third-party modules, followed by user-defined modules. The <span class="literal">sys</span> module includes commands for the operating system, such as exiting. The <span class="literal">random</span> module lets you generate pseudorandom numbers. The <span class="literal">itertools</span> module helps you with looping. Finally, <span class="literal">numpy</span> and <span class="literal">cv2</span> import <span class="literal">NumPy</span> and OpenCV, respectively. You can also assign shorthand names (<span class="literal">np</span>, <span class="literal">cv</span>) to reduce keystrokes later.</p>&#13;
<p class="indent">Next, assign some constants. As per the PEP8 Python style guide (<em><a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></em>), constant names should be all caps. This doesn’t make the variables truly immutable, but it does alert other developers that they shouldn’t change these variables.</p>&#13;
<p class="indent">The map you’ll use for the fictional Cape Python area is an image file called <em>cape_python.png</em> (<a href="ch01.xhtml#ch01fig5">Figure 1-5</a>). Assign this image file to a constant variable named <span class="literal">MAP_FILE</span>.</p>&#13;
<div class="image"><img src="../images/fig01_05.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig5"/>Figure 1-5: Grayscale base map of Cape Python (<span class="normal">cape_python.png</span>)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_10"/>You’ll draw the search areas on the image as rectangles. OpenCV will define each rectangle by the pixel number at the corner points, so assign a variable to hold these four points as a tuple. The required order is upper-left <em>x</em>, upper-left <em>y</em>, lower-right <em>x</em>, and lower-right <em>y</em>. Use <span class="literal">SA</span> in the variable name to represent “search area.”</p>&#13;
<h5 class="h5"><strong>Defining the Search Class</strong></h5>&#13;
<p class="noindent">A <em>class</em> is a data type in object-oriented programming (OOP). OOP is an alternative approach to functional/procedural programming. It’s especially useful for large, complex programs, as it produces code that’s easier to update, maintain, and reuse, while reducing code duplication. OOP is built around data structures known as <em>objects</em>, which consist of data, methods, and the interactions between them. As such, it works well with game programs, which typically use interacting objects, such as spaceships and asteroids.</p>&#13;
<p class="indent">A class is a template from which multiple objects can be created. For example, you could have a class that builds battleships in a World War II game. Each battleship would inherit certain consistent characteristics, such as tonnage, cruising speed, fuel level, damage level, weaponry, and so on. You could also give each battleship object unique characteristics, such as a different name. Once created, or <em>instantiated</em>, the individual characteristics of each battleship would begin to diverge depending on how much fuel the ships burn, how much damage they take, how much ammo they use, and so on.</p>&#13;
<p class="indent">In <em>bayes.py</em>, you’ll use a class as a template to create a search and rescue mission that allows for three search areas. <a href="ch01.xhtml#ch01list2">Listing 1-2</a> defines the <span class="literal">Search</span> class, which will act as a blueprint for your game.<span epub:type="pagebreak" id="page_11"/></p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 2&#13;
class Search():&#13;
    """Bayesian Search &amp; Rescue game with 3 search areas."""&#13;
&#13;
    def __init__(self, name):&#13;
        self.name = name&#13;
&#13;
     <span class="ent">➊</span> self.img = cv.imread(MAP_FILE, cv.IMREAD_COLOR)&#13;
        if self.img is None:&#13;
            print('Could not load map file {}'.format(MAP_FILE),&#13;
                  file=sys.stderr)&#13;
            sys.exit(1)&#13;
    &#13;
     <span class="ent">➋</span> self.area_actual = 0 &#13;
        self.sailor_actual = [0, 0] # As "local" coords within search area&#13;
    &#13;
     <span class="ent">➌</span> self.sa1 = self.img[SA1_CORNERS[1] : SA1_CORNERS[3], &#13;
                            SA1_CORNERS[0] : SA1_CORNERS[2]]&#13;
    &#13;
        self.sa2 = self.img[SA2_CORNERS[1] : SA2_CORNERS[3], &#13;
                            SA2_CORNERS[0] : SA2_CORNERS[2]]&#13;
    &#13;
        self.sa3 = self.img[SA3_CORNERS[1] : SA3_CORNERS[3], &#13;
                            SA3_CORNERS[0] : SA3_CORNERS[2]]&#13;
    &#13;
     <span class="ent">➍</span> self.p1 = 0.2&#13;
        self.p2 = 0.5&#13;
        self.p3 = 0.3&#13;
&#13;
        self.sep1 = 0&#13;
        self.sep2 = 0&#13;
        self.sep3 = 0</pre>&#13;
<p class="listing"><a id="ch01list2"/>Listing 1-2: Defining the <span class="codeitalic">Search</span> class and <span class="codeitalic">__init__()</span> method</p>&#13;
<p class="indent">Start by defining a class called <span class="literal">Search</span>. According to PEP8, the first letter of a class name should be capitalized.</p>&#13;
<p class="indent">Next, define a method that sets up the initial attribute values for your object. In OOP, an <em>attribute</em> is a named value associated with an object. If your object is a person, an attribute might be their weight or eye color. <em>Methods</em> are attributes that also happen to be functions, which are passed a reference to their instance when they run. The<span class="literal"> __init__()</span> method is a special built-in function that Python automatically invokes as soon as a new object is created. It binds the attributes of each newly created instance of a class. In this case, you pass it two arguments: <span class="literal">self</span> and the name you want to use for your object.</p>&#13;
<p class="indent">The <span class="literal">self</span> parameter is a reference to the instance of the class that is being created, or that a method was invoked on, technically referred to as a <em>context</em> instance. For example, if you create a battleship named the <em>Missouri</em>, then for that object, <span class="literal">self</span> becomes <span class="literal">Missouri</span>, and you can call a method for that object, like one for firing the big guns, with dot notation: <span class="literal">Missouri.fire_big_guns()</span>. By giving objects unique names when they are instantiated, the scope of each object’s attributes is kept separate from all others. This way, damage taken by one battleship isn’t shared with the rest of the fleet.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>It’s good practice to list all the initial attribute values for an object under the <span class="literal">__init__()</span> method. This way, users can see all the key attributes of the object that will be used later in various methods, and your code will be more readable and updatable. In <a href="ch01.xhtml#ch01list2">Listing 1-2</a>, these are the <span class="literal">self</span> attributes, such as <span class="literal">self.name</span>.</p>&#13;
<p class="indent">Attributes assigned to <span class="literal">self</span> will also behave like global variables in procedural programming. Methods in the class will be able to access them directly, without the need for arguments. Because these attributes are “shielded” under the <em>class</em> umbrella, their use is not discouraged as with true global variables, which are assigned within the global scope and are modified within the local scope of individual functions.</p>&#13;
<p class="indent">Assign the <span class="literal">MAP_FILE</span> variable to the <span class="literal">self.img</span> attribute using OpenCV’s <span class="literal">imread()</span> method <span class="ent">➊</span>. The <span class="literal">MAP_FILE</span> image is grayscale, but you’ll want to add some color to it during the search. So, use <span class="literal">ImreadFlag</span>, as <span class="literal">cv.IMREAD_COLOR</span>, to load the image in color mode. This will set up three color channels (B, G, R) for you to exploit later.</p>&#13;
<p class="indent">If the image file doesn’t exist (or the user entered the wrong filename), OpenCV will throw a confusing error (<span class="literal">NoneType object is not subscriptable</span>). To handle this, use a conditional to check whether <span class="literal">self.img</span> is <span class="literal">None</span>. If it is, print an error message and then use the <span class="literal">sys</span> module to exit the program. Passing it an exit code of <span class="literal">1</span> indicates that the program terminated with an error. Setting <span class="literal">file=stderr</span> will result in the use of the standard “error red” text color in the Python interpreter window, though not in other windows such as PowerShell.</p>&#13;
<p class="indent">Next, assign two attributes for the sailor’s actual location when found. The first will hold the number of the search area <span class="ent">➋</span> and the second the precise (<em>x</em>, <em>y</em>) location. The assigned values will be placeholders for now. Later, you’ll define a method to randomly choose the final values. Note that you use a list for the location coordinates as you need a mutable container.</p>&#13;
<p class="indent">The map image is loaded as an <em>array</em>. An array is a fixed-size collection of objects of the same type. Arrays are memory-efficient containers that provide fast numerical operations and effectively use the addressing logic of computers. One concept that makes <span class="literal">NumPy</span> particularly powerful is <em>vectorization</em>, which replaces explicit loops with more efficient array expressions. Basically, operations occur on entire arrays rather than their individual elements. With <span class="literal">NumPy</span>, internal looping is directed to efficient C and Fortran functions that are faster than standard Python techniques.</p>&#13;
<p class="indent">So that you can work with local coordinates <em>within</em> a search area, you can create a subarray from the array <span class="ent">➌</span>. Notice that this is done with indexing. You first provide the range from the upper-left <em>y</em> value to the lower-right <em>y</em> and then from the upper-left <em>x</em> to the lower-right <em>x</em>. This is a <span class="literal">NumPy</span> feature that takes some getting used to, especially since most of us are used to <em>x</em> coming before <em>y</em> in Cartesian coordinates.</p>&#13;
<p class="indent">Repeat the procedure for the next two search areas and then set the pre-search probabilities for finding the sailor in each of the search areas <span class="ent">➍</span>. In real life, these would come from the SAROPS program. Of course, <span class="literal">p1</span> represents area 1, <span class="literal">p2</span> is for area 2, and so on. Finish with placeholder attributes for the SEP.</p>&#13;
<h5 class="h5"><strong>Drawing the Map</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_13"/>Inside the <span class="literal">Search</span> class, you’ll use functionality within OpenCV to create a method that displays the base map. This map will include the search areas, a scale bar, and the sailor’s last known position (<a href="ch01.xhtml#ch01fig6">Figure 1-6</a>).</p>&#13;
<div class="image"><img src="../images/fig01_06.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig6"/>Figure 1-6: Initial game screen (base map) for <span class="normal">bayes.py</span></p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list3">Listing 1-3</a> defines the <span class="literal">draw_map()</span> method that displays the initial map.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 3&#13;
def draw_map(self, last_known):&#13;
    """Display basemap with scale, last known xy location, search areas."""&#13;
    cv.line(self.img, (20, 370), (70, 370), (0, 0, 0), 2)&#13;
    cv.putText(self.img, '0', (8, 370), cv.FONT_HERSHEY_PLAIN, 1, (0, 0, 0))&#13;
    cv.putText(self.img, '50 Nautical Miles', (71, 370),&#13;
               cv.FONT_HERSHEY_PLAIN, 1, (0, 0, 0))&#13;
&#13;
<span class="ent">➊</span> cv.rectangle(self.img, (SA1_CORNERS[0], SA1_CORNERS[1]),&#13;
                           (SA1_CORNERS[2], SA1_CORNERS[3]), (0, 0, 0), 1)&#13;
   cv.putText(self.img, '1',&#13;
              (SA1_CORNERS[0] + 3, SA1_CORNERS[1] + 15),&#13;
              cv.FONT_HERSHEY_PLAIN, 1, 0)&#13;
   cv.rectangle(self.img, (SA2_CORNERS[0], SA2_CORNERS[1]),&#13;
                (SA2_CORNERS[2], SA2_CORNERS[3]), (0, 0, 0), 1)&#13;
   cv.putText(self.img, '2',&#13;
              (SA2_CORNERS[0] + 3, SA2_CORNERS[1] + 15),&#13;
              cv.FONT_HERSHEY_PLAIN, 1, 0)&#13;
   cv.rectangle(self.img, (SA3_CORNERS[0], SA3_CORNERS[1]),&#13;
                (SA3_CORNERS[2], SA3_CORNERS[3]), (0, 0, 0), 1)&#13;
   cv.putText(self.img, '3',&#13;
              (SA3_CORNERS[0] + 3, SA3_CORNERS[1] + 15),&#13;
              cv.FONT_HERSHEY_PLAIN, 1, 0)&#13;
&#13;
<span class="ent">➋</span> cv.putText(self.img, '+', (last_known),&#13;
              cv.FONT_HERSHEY_PLAIN, 1, (0, 0, 255))&#13;
   cv.putText(self.img, '+ = Last Known Position', (274, 355),&#13;
              cv.FONT_HERSHEY_PLAIN, 1, (0, 0, 255))&#13;
   <span epub:type="pagebreak" id="page_14"/>cv.putText(self.img, '* = Actual Position', (275, 370),&#13;
              cv.FONT_HERSHEY_PLAIN, 1, (255, 0, 0))&#13;
&#13;
<span class="ent">➌</span> cv.imshow('Search Area', self.img)&#13;
   cv.moveWindow('Search Area', 750, 10)&#13;
   cv.waitKey(500)</pre>&#13;
<p class="listing"><a id="ch01list3"/>Listing 1-3: Defining a method for displaying the base map</p>&#13;
<p class="indent">Define the <span class="literal">draw_map()</span> method with <span class="literal">self</span> and the sailor’s last known coordinates (<span class="literal">last_known</span>) as its two parameters. Then use OpenCV’s <span class="literal">line()</span> method to draw a scale bar. Pass it the base map image, a tuple of the left and right (<em>x</em>, <em>y</em>) coordinates, a line color tuple, and a line width as arguments.</p>&#13;
<p class="indent">Use the <span class="literal">putText()</span> method to annotate the scale bar. Pass it the attribute for the base map image and then the actual text, followed by a tuple of the coordinates of the bottom-left corner of the text. Then add the font name, font scale, and color tuple.</p>&#13;
<p class="indent">Now draw a rectangle for the first search area <span class="ent">➊</span>. As usual, pass the base map image, then the variables representing the four corners of the box, and finally a color tuple and a line weight. Use <span class="literal">putText()</span> again to place the search area number just inside the upper-left corner. Repeat these steps for search areas 2 and 3.</p>&#13;
<p class="indent">Use <span class="literal">putText()</span> to post a <span class="literal">+</span> at the sailor’s last known position <span class="ent">➋</span>. Note that the symbol is red, but the color tuple reads <span class="literal">(0, 0, 255)</span>, instead of <span class="literal">(255, 0, 0)</span>. This is because OpenCV uses a Blue-Green-Red (BGR) color format, not the more common Red-Green-Blue (RGB) format.</p>&#13;
<p class="indent">Continue by placing text for a legend that describes the symbols for the last known position and actual position, which should display when a player’s search finds the sailor. Use blue for the actual position marker.</p>&#13;
<p class="indent">Complete the method by showing the base map, using OpenCV’s <span class="literal">imshow()</span> method <span class="ent">➌</span>. Pass it a title for the window and the image.</p>&#13;
<p class="indent">To avoid the base map and interpreter windows interfering with each other as much as possible, force the base map to display in the upper-right corner of your monitor (you may need to adjust the coordinates for your machine). Use OpenCV’s <span class="literal">moveWindow()</span> method and pass it the name of the window, <span class="literal">'Search Area'</span>, and the coordinates for the top-left corner.</p>&#13;
<p class="indent">Finish by using the <span class="literal">waitKey()</span> method, which introduces a delay of <em>n</em> milliseconds while rendering images to windows. Pass it <span class="literal">500</span>, for 500 milliseconds. This should result in the game menu appearing a half-second after the base map.</p>&#13;
<h5 class="h5"><strong>Choosing the Sailor’s Final Location</strong></h5>&#13;
<p class="noindent"><a href="ch01.xhtml#ch01list4">Listing 1-4</a> defines a method to randomly choose the sailor’s actual location. For convenience, the coordinates are initially found within a search area subarray and then converted to global coordinates with respect to the full base map image. This methodology works because all the search areas are the same size and shape and can thus use the same internal coordinates.<span epub:type="pagebreak" id="page_15"/></p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 4&#13;
def sailor_final_location(self, num_search_areas):&#13;
    """Return the actual x,y location of the missing sailor."""   &#13;
    # Find sailor coordinates with respect to any Search Area subarray.&#13;
    self.sailor_actual[0] = np.random.choice(self.sa1.shape[1], 1)&#13;
    self.sailor_actual[1] = np.random.choice(self.sa1.shape[0], 1)&#13;
&#13;
<span class="ent">➊</span> area = int(random.triangular(1, num_search_areas + 1))&#13;
&#13;
    if area == 1:&#13;
        x = self.sailor_actual[0] + SA1_CORNERS[0]&#13;
        y = self.sailor_actual[1] + SA1_CORNERS[1]&#13;
     <span class="ent">➋</span> self.area_actual = 1&#13;
    elif area == 2:&#13;
        x = self.sailor_actual[0] + SA2_CORNERS[0]&#13;
        y = self.sailor_actual[1] + SA2_CORNERS[1]&#13;
        self.area_actual = 2&#13;
    elif area == 3:&#13;
        x = self.sailor_actual[0] + SA3_CORNERS[0]&#13;
        y = self.sailor_actual[1] + SA3_CORNERS[1]&#13;
        self.area_actual = 3&#13;
    return x, y</pre>&#13;
<p class="listing"><a id="ch01list4"/>Listing 1-4: Defining a method to randomly choose the sailor’s actual location</p>&#13;
<p class="indent">Define the <span class="literal">sailor_final_location()</span> method with two parameters: <span class="literal">self</span> and the number of search areas being used. For the first (<em>x</em>) coordinate in the <span class="literal">self.sailor_actual</span> list, use <span class="literal">NumPy</span>’s <span class="literal">random.choice()</span> method to choose a value from the area 1 subarray. Remember, the search areas are <span class="literal">NumPy</span> arrays copied out of the larger image array. Because the search areas/subarrays are all the same size, coordinates you choose from one will apply to all.</p>&#13;
<p class="indent">You can get the coordinates of an array with <span class="literal">shape</span>, as shown here:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">print(np.shape(self.SA1))</span>&#13;
(50, 50, 3)</pre>&#13;
<p class="indent">The <span class="literal">shape</span> attribute for a <span class="literal">NumPy</span> array must be a tuple with as many elements as dimensions in the array. And remember that, for an array in OpenCV, the order of elements in the tuple is rows, columns, and then channels.</p>&#13;
<p class="indent">Each of the existing search areas is a three-dimensional array 50×50 pixels in size. So, internal coordinates for both <em>x</em> and <em>y</em> will range from 0 to 49. Selecting <span class="literal">[0]</span> with <span class="literal">random.choice()</span> means that rows are used, and the final argument, <span class="literal">1</span>, selects a single element. Selecting <span class="literal">[1]</span> chooses from columns.</p>&#13;
<p class="indent">The coordinates generated by <span class="literal">random.choice()</span> will range from 0 to 49. To use these with the full base map image, you first need to pick a search area <span class="ent">➊</span>. Do this with the <span class="literal">random</span> module, which you imported at the start of the program. According to the SAROPS output, the sailor is most likely in area 2, followed by area 3. Since these initial target probabilities are guesses that won’t correspond directly to reality, use a <span class="literal">triangular</span> distribution to choose the area containing the sailor. The arguments are the low and high endpoints. If a final mode argument is not provided, the mode defaults <span epub:type="pagebreak" id="page_16"/>to the midpoint between the endpoints. This will align with the SAROPS results as area 2 will be picked the most often.</p>&#13;
<p class="indent">Note that you use the local variable <span class="literal">area</span> within the method, rather than the <span class="literal">self.area</span> attribute, as there’s no need to share this variable with other methods.</p>&#13;
<p class="indent">To plot the sailor’s location on the base map, you need to add the appropriate search area corner-point coordinate. This converts the “local” search area coordinates to the “global” coordinates of the full base map image. You’ll also want to keep track of the search area, so update the <span class="literal">self.area_actual</span> attribute <span class="ent">➋</span>.</p>&#13;
<p class="indent">Repeat these steps for search areas 2 and 3 and then return the (<em>x</em>, <em>y</em>) coordinates.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In real life, the sailor would drift along, and the odds of his moving into area 3 would increase with each search. I chose to use a static location, however, to make the logic behind Bayes’ rule as clear as possible. As a result, this scenario behaves more like a search for a sunken submarine.</em></p>&#13;
</div>&#13;
<h5 class="h5"><strong>Calculating Search Effectiveness and Conducting the Search</strong></h5>&#13;
<p class="noindent">In real life, weather and mechanical problems can result in low search effectiveness scores. Thus, the strategy for each search will be to generate a list of all possible locations within a search area, shuffle the list, and then sample it based on the search effectiveness value. Because the SEP will never be 1.0, if you just sample from the start or end of the list—without shuffling—you’ll never be able to access coordinates tucked away in its “tail.”</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list5">Listing 1-5</a>, still in the <span class="literal">Search</span> class, defines a method to randomly calculate the effectiveness of a given search and defines another method to conduct the search.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 5&#13;
   def calc_search_effectiveness(self):&#13;
       """Set decimal search effectiveness value per search area."""&#13;
       self.sep1 = random.uniform(0.2, 0.9)&#13;
       self.sep2 = random.uniform(0.2, 0.9)&#13;
       self.sep3 = random.uniform(0.2, 0.9)&#13;
&#13;
<span class="ent">➊</span> def conduct_search(self, area_num, area_array, effectiveness_prob):&#13;
       """Return search results and list of searched coordinates."""&#13;
       local_y_range = range(area_array.shape[0])&#13;
       local_x_range = range(area_array.shape[1])&#13;
     <span class="ent">➋</span> coords = list(itertools.product(local_x_range, local_y_range))&#13;
       random.shuffle(coords)&#13;
       coords = coords[:int((len(coords) * effectiveness_prob))]&#13;
     <span class="ent">➌</span> loc_actual = (self.sailor_actual[0], self.sailor_actual[1])&#13;
       if area_num == self.area_actual and loc_actual in coords:&#13;
           return 'Found in Area {}.'.format(area_num), coords    &#13;
       else:&#13;
           return 'Not Found', coords</pre>&#13;
<p class="listing"><a id="ch01list5"/>Listing 1-5: Defining methods to randomly choose search effectiveness and conduct search</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_17"/>Start by defining the search effectiveness method. The only parameter needed is <span class="literal">self</span>. For each of the search effectiveness attributes, such as E1, randomly choose a value between 0.2 and 0.9. These are arbitrary values that mean you will always search at least 20 percent of the area but never more than 90 percent.</p>&#13;
<p class="indent">You could argue that the search effectiveness attributes for the three search areas are dependent. Fog, for example, might affect all three areas, yielding uniformly poor results. On the other hand, some of your helicopters may have infrared imaging equipment and would fare better. At any rate, making these independent, as you’ve done here, makes for a more dynamic simulation.</p>&#13;
<p class="indent">Next, define a method for conducting a search <span class="ent">➊</span>. Necessary parameters are the object itself, the area number (chosen by the user), the subarray for the chosen area, and the randomly chosen search effectiveness value.</p>&#13;
<p class="indent">You’ll need to generate a list of all the coordinates within a given search area. Name a variable <span class="literal">local_y_range</span> and assign it a range based on the first index from the array shape tuple, which represents rows. Repeat for the <span class="literal">x_range</span> value.</p>&#13;
<p class="indent">To generate the list of all coordinates in the search area, use the <span class="literal">itertools</span> module <span class="ent">➋</span>. This module is a group of functions in the Python Standard Library that create iterators for efficient looping. The <span class="literal">product()</span> function returns tuples of all the permutations-with-repetition for a given sequence. In this case, you’re finding all the possible ways to combine <em>x</em> and <em>y</em> in the search area. To see it in action, type the following in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import itertools</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">x_range = [1, 2, 3]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">y_range = [4, 5, 6]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">coords = list(itertools.product(x_range, y_range))</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">coords</span>&#13;
[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]</pre>&#13;
<p class="indent">As you can see, the <span class="literal">coords</span> list contains every possible paired combination of the elements in the <span class="literal">x_range</span> and <span class="literal">y_range</span> lists.</p>&#13;
<p class="indent">Next, shuffle the list of coordinates. This is so you won’t keep searching the same end of the list with each search event. In the next line, use index slicing to trim the list based on the search effectiveness probability. For example, a poor search effectiveness of 0.3 means that only one-third of the possible locations in an area are included in the list. As you’ll check the sailor’s actual location against this list, you’ll effectively leave two-thirds of the area “unsearched.”</p>&#13;
<p class="indent">Assign a local variable, <span class="literal">loc_actual</span>, to hold the sailor’s actual location <span class="ent">➌</span>. Then use a conditional to check that the sailor has been found. If the user chose the correct search area and the shuffled and trimmed <span class="literal">coords</span> list contains the sailor’s (<em>x</em>, <em>y</em>) location, return a string stating the sailor has been found, along with the <span class="literal">coords</span> list. Otherwise, return a string stating the sailor has not been found and the <span class="literal">coords</span> list.</p>&#13;
<h5 class="h5"><strong>Applying Bayes’ Rule and Drawing a Menu</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_18"/><a href="ch01.xhtml#ch01list6">Listing 1-6</a>, still in the <span class="literal">Search</span> class, defines a method and a function. The <span class="literal">revise_target_probs()</span> method uses Bayes’ rule to update the target probabilities. These represent the probability of the sailor being found per search area. The <span class="literal">draw_menu()</span> function, defined outside of the <span class="literal">Search</span> class, displays a menu that will serve as a graphical user interface (GUI) to run the game.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 6&#13;
    def revise_target_probs(self):&#13;
        """Update area target probabilities based on search effectiveness.""" &#13;
        denom = self.p1 * (1 - self.sep1) + self.p2 * (1 - self.sep2) \&#13;
                + self.p3 * (1 - self.sep3)&#13;
        self.p1 = self.p1 * (1 - self.sep1) / denom&#13;
        self.p2 = self.p2 * (1 - self.sep2) / denom&#13;
        self.p3 = self.p3 * (1 - self.sep3) / denom&#13;
    &#13;
&#13;
def draw_menu(search_num):&#13;
    """Print menu of choices for conducting area searches."""&#13;
    print('\nSearch {}'.format(search_num))&#13;
    print(&#13;
        """&#13;
        Choose next areas to search:&#13;
&#13;
        0 - Quit&#13;
        1 - Search Area 1 twice&#13;
        2 - Search Area 2 twice&#13;
        3 - Search Area 3 twice&#13;
        4 - Search Areas 1 &amp; 2&#13;
        5 - Search Areas 1 &amp; 3&#13;
        6 - Search Areas 2 &amp; 3&#13;
        7 - Start Over&#13;
        """&#13;
        )</pre>&#13;
<p class="listing"><a id="ch01list6"/>Listing 1-6: Defining ways to apply Bayes’ rule and draw a menu in the Python shell</p>&#13;
<p class="indent">Define the <span class="literal">revise_target_probs()</span> method to update the probability of the sailor being in each search area. Its only parameter is <span class="literal">self</span>.</p>&#13;
<p class="indent">For convenience, break Bayes’ equation into two parts, starting with the denominator. You need to multiply the previous target probability by the current search effectiveness value (see <a href="ch01.xhtml#page_5">page 5</a> to review how this works).</p>&#13;
<p class="indent">With the denominator calculated, use it to complete Bayes’ equation. In OOP, you don’t need to return anything. You can simply update the attribute directly in the method, as if it were a declared global variable in procedural programming.</p>&#13;
<p class="indent">Next, in the global space, define the <span class="literal">draw_menu()</span> function to draw a menu. Its only parameter is the number of the search being conducted. Because this function has no “self-use,” you don’t have to include it in the class definition, though that is a valid option.</p>&#13;
<p class="indent">Start by printing the search number. You’ll need this to keep track of whether you’ve found the sailor in the requisite number of searches, which we’ve currently set as 3.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>Use triple quotes with the <span class="literal">print()</span> function to display the menu. Note that the user will have the option to allocate both search parties to a given area or divide them between two areas.</p>&#13;
<h5 class="h5"><strong>Defining the main() Function</strong></h5>&#13;
<p class="noindent">Now that you’re finished with the <span class="literal">Search</span> class, you’re ready to put all those attributes and methods to work! <a href="ch01.xhtml#ch01list7">Listing 1-7</a> begins the definition of the <span class="literal">main()</span> function, used to run the program.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 7 &#13;
def main():    &#13;
    app = Search('Cape_Python')&#13;
    app.draw_map(last_known=(160, 290))&#13;
    sailor_x, sailor_y = app.sailor_final_location(num_search_areas=3)&#13;
    print("-" * 65)&#13;
    print("\nInitial Target (P) Probabilities:")&#13;
    print("P1 = {:.3f}, P2 = {:.3f}, P3 = {:.3f}".format(app.p1, app.p2, app.p3))&#13;
    search_num = 1</pre>&#13;
<p class="listing"><a id="ch01list7"/>Listing 1-7: Defining the start of the <span class="codeitalic">main()</span> function, used to run the program</p>&#13;
<p class="indent">The <span class="literal">main()</span> function requires no arguments. Start by creating a game application, named <span class="literal">app</span>, using the <span class="literal">Search</span> class. Name the object <span class="literal">Cape_Python</span>.</p>&#13;
<p class="indent">Next, call the method that displays the map. Pass it the last known position of the sailor as a tuple of (<em>x</em>, <em>y</em>) coordinates. Note the use of the keyword argument, <span class="literal">last_known=(160, 290)</span>, for clarity.</p>&#13;
<p class="indent">Now, get the sailor’s <em>x</em> and <em>y</em> location by calling the method for that task and passing it the number of search areas. Then print the initial target probabilities, or priors, which were calculated by your Coast Guard underlings using Monte Carlo simulation, not Bayes’ rule. Finally, name a variable <span class="literal">search_num</span> and assign it <span class="literal">1</span>. This variable will keep track of how many searches you’ve conducted.</p>&#13;
<h5 class="h5"><strong>Evaluating the Menu Choices</strong></h5>&#13;
<p class="noindent"><a href="ch01.xhtml#ch01list8">Listing 1-8</a> starts the <span class="literal">while</span> loop used to run the game in <span class="literal">main()</span>. Within this loop, the player evaluates and selects menu choices. Choices include searching a single area twice, splitting search efforts between two areas, restarting the game, and exiting the game. Note that the player can conduct as many searches as it takes to find the sailor; our three-day limit hasn’t been “hardwired” into the game.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 8 &#13;
while True:&#13;
    app.calc_search_effectiveness()&#13;
    draw_menu(search_num)&#13;
    choice = input("Choice: ")&#13;
&#13;
    if choice == "0":&#13;
        sys.exit()&#13;
<span epub:type="pagebreak" id="page_20"/><span class="ent">➊</span> elif choice == "1":&#13;
       results_1, coords_1 = app.conduct_search(1, app.sa1, app.sep1)&#13;
       results_2, coords_2 = app.conduct_search(1, app.sa1, app.sep1)&#13;
    <span class="ent">➋</span> app.sep1 = (len(set(coords_1 + coords_2))) / (len(app.sa1)**2)&#13;
       app.sep2 = 0&#13;
       app.sep3 = 0&#13;
&#13;
    elif choice == "2":&#13;
        results_1, coords_1 = app.conduct_search(2, app.sa2, app.sep2)&#13;
        results_2, coords_2 = app.conduct_search(2, app.sa2, app.sep2)&#13;
        app.sep1 = 0&#13;
        app.sep2 = (len(set(coords_1 + coords_2))) / (len(app.sa2)**2)&#13;
        app.sep3 = 0&#13;
&#13;
    elif choice == "3":&#13;
        results_1, coords_1 = app.conduct_search(3, app.sa3, app.sep3)&#13;
        results_2, coords_2 = app.conduct_search(3, app.sa3, app.sep3)&#13;
        app.sep1 = 0&#13;
        app.sep2 = 0&#13;
        app.sep3 = (len(set(coords_1 + coords_2))) / (len(app.sa3)**2)&#13;
&#13;
<span class="ent">➌</span> elif choice == "4":&#13;
       results_1, coords_1 = app.conduct_search(1, app.sa1, app.sep1)&#13;
       results_2, coords_2 = app.conduct_search(2, app.sa2, app.sep2)&#13;
       app.sep3 = 0&#13;
&#13;
   elif choice == "5":&#13;
       results_1, coords_1 = app.conduct_search(1, app.sa1, app.sep1)&#13;
       results_2, coords_2 = app.conduct_search(3, app.sa3, app.sep3)&#13;
       app.sep2 = 0&#13;
&#13;
   elif choice == "6":&#13;
       results_1, coords_1 = app.conduct_search(2, app.sa2, app.sep2)&#13;
       results_2, coords_2 = app.conduct_search(3, app.sa3, app.sep3)&#13;
       app.sep1 = 0&#13;
&#13;
<span class="ent">➍</span> elif choice == "7":&#13;
       main()&#13;
&#13;
   else:&#13;
       print("\nSorry, but that isn't a valid choice.", file=sys.stderr)&#13;
       continue</pre>&#13;
<p class="listing"><a id="ch01list8"/>Listing 1-8: Using a loop to evaluate menu choices and run the game</p>&#13;
<p class="indent">Start a <span class="literal">while</span> loop that will run until the user chooses to exit. Immediately use dot notation to call the method that calculates the effectiveness of the search. Then call the function that displays the game menu and pass it the search number. Finish the preparatory stage by asking the user to make a choice, using the <span class="literal">input()</span> function.</p>&#13;
<p class="indent">The player’s choice will be evaluated using a series of conditional statements. If they choose <span class="literal">0</span>, exit the game. Exiting uses the <span class="literal">sys</span> module you imported at the beginning of the program.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_21"/>If the player chooses 1, 2, or 3, it means they want to commit both search teams to the area with the corresponding number. You’ll need to call the <span class="literal">conduct_search()</span> method twice to generate two sets of results and coordinates <span class="ent">➊</span>. The tricky part here is determining the overall SEP, since each search has its own SEP. To do this, add the two <span class="literal">coords</span> lists together and convert the result to a set to remove any duplicates <span class="ent">➋</span>. Get the length of the set and then divide it by the number of pixels in the 50×50 search area. Since you didn’t search the other areas, set their SEPs to <span class="literal">0</span>.</p>&#13;
<p class="indent">Repeat and tailor the previous code for search areas 2 and 3. Use an <span class="literal">elif</span> statement since only one menu choice is valid per loop. This is more efficient than using additional <span class="literal">if</span> statements, as all <span class="literal">elif</span> statements below a true response will be skipped.</p>&#13;
<p class="indent">If the player chooses a 4, 5, or 6, it means they want to divide their teams between two areas. In this case, there’s no need to recalculate the SEP <span class="ent">➌</span>.</p>&#13;
<p class="indent">If the player finds the sailor and wants to play again or just wants to restart, call the <span class="literal">main()</span> function <span class="ent">➍</span>. This will reset the game and clear the map.</p>&#13;
<p class="indent">If the player makes a nonvalid choice, like “Bob”, let them know with a message and then use <span class="literal">continue</span> to skip back to the start of the loop and request the player’s choice again.</p>&#13;
<h5 class="h5"><strong>Finishing and Calling main()</strong></h5>&#13;
<p class="noindent"><a href="ch01.xhtml#ch01list9">Listing 1-9</a>, still in the <span class="literal">while</span> loop, finishes the <span class="literal">main()</span> function and then calls it to run the program.</p>&#13;
<pre><span class="codeitalic1">bayes.py,</span> part 9 &#13;
        app.revise_target_probs()  # Use Bayes' rule to update target probs.&#13;
&#13;
        print("\nSearch {} Results 1 = {}"&#13;
              .format(search_num, results_1), file=sys.stderr)&#13;
        print("Search {} Results 2 = {}\n"&#13;
              .format(search_num, results_2), file=sys.stderr)&#13;
        print("Search {} Effectiveness (E):".format(search_num))&#13;
        print("E1 = {:.3f}, E2 = {:.3f}, E3 = {:.3f}"&#13;
              .format(app.sep1, app.sep2, app.sep3))&#13;
&#13;
     <span class="ent">➊</span> if results_1 == 'Not Found' and results_2 == 'Not Found':&#13;
            print("\nNew Target Probabilities (P) for Search {}:"&#13;
                  .format(search_num + 1))&#13;
            print("P1 = {:.3f}, P2 = {:.3f}, P3 = {:.3f}"&#13;
                  .format(app.p1, app.p2, app.p3))&#13;
        else:&#13;
            cv.circle(app.img, (sailor_x, sailor_y), 3, (255, 0, 0), -1)&#13;
         <span class="ent">➋</span> cv.imshow('Search Area', app.img)&#13;
            cv.waitKey(1500)&#13;
            main()&#13;
        search_num += 1&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<p class="listing"><a id="ch01list9"/>Listing 1-9: Completing and calling the <span class="codeitalic">main()</span> function</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>Call the <span class="literal">revise_target_probs()</span> method to apply Bayes’ rule and recalculate the probability of the sailor being in each search area, given the search results. Next, display the search results and search effectiveness probabilities in the shell.</p>&#13;
<p class="indent">If the results of both searches are negative, display the updated target probabilities, which the player will use to guide their next search <span class="ent">➊</span>. Otherwise, display the sailor’s location on the map. Use OpenCV to draw a circle and pass the method the base map image, the sailor’s (<em>x</em>, <em>y</em>) tuple for the center point, a radius (in pixels), a color, and a thickness of –1. A negative thickness value will fill the circle with the color.</p>&#13;
<p class="indent">Finish <span class="literal">main()</span> by showing the base map using code similar to <a href="ch01.xhtml#ch01list3">Listing 1-3</a> <span class="ent">➋</span>. Pass the <span class="literal">waitKey()</span> method <span class="literal">1500</span> to display the sailor’s actual location for 1.5 seconds before the game calls <span class="literal">main()</span> and resets automatically. At the end of the loop, increment the search number variable by 1. You want to do this <em>after</em> the loop so that an invalid choice isn’t counted as a search.</p>&#13;
<p class="indent">Back in the global space, apply the code that lets the program be imported as a module or run in stand-alone mode. The <span class="literal">__name__</span> variable is a built-in variable used to evaluate whether a program is autonomous or imported into another program. If you run this program directly, <span class="literal">__name__</span> is set to <span class="literal">__main__</span>, the condition of the <span class="literal">if</span> statement is met, and <span class="literal">main()</span> is called automatically. If the program is imported, the <span class="literal">main()</span> function won’t be run until it is intentionally called.</p>&#13;
<h4 class="h4" id="ch00lev2sec8"><strong><em>Playing the Game</em></strong></h4>&#13;
<p class="noindent">To play the game, select <strong>Run</strong>▸<strong>Run Module</strong> in the text editor or just press F5. <a href="ch01.xhtml#ch01fig7">Figures 1-7</a> and <a href="ch01.xhtml#ch01fig8">1-8</a> show the final game screens, with the results of a successful first search.</p>&#13;
<div class="image"><img src="../images/fig01_07.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig7"/>Figure 1-7: Python interpreter window with a successful search result</p>&#13;
<div class="image"><img src="../images/fig01_08.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch01fig8"/>Figure 1-8: Base map image for a successful search result<span epub:type="pagebreak" id="page_23"/></p>&#13;
<p class="indent">In this example search, the player chose to commit both searches to area 2, which had an initial 50 percent probability of containing the sailor. The first search was unsuccessful, but the second one found the sailor. Note that the search effectiveness was only slightly better than 50 percent. This means there was only a one-in-four chance (0.5 × 0.521 = 0.260) of finding the sailor in the first search. Despite choosing wisely, the player still had to rely on a bit of luck in the end!</p>&#13;
<p class="indent">When you play the game, try to immerse yourself in the scenario. Your decisions determine whether a human being lives or dies, and you don’t have much time. If the sailor’s floating in the water, you’ve got only three guesses to get it right. Use them wisely!</p>&#13;
<p class="indent">Based on the target probabilities at the start of the game, the sailor is most likely in area 2, followed by area 3. So, a good initial strategy is to either search area 2 twice (menu option 2) or search areas 2 and 3 simultaneously (menu option 6). You’ll want to keep a close eye on the search effectiveness output. If an area gets a high effectiveness score, which means that it’s been thoroughly searched, you may want to focus your efforts elsewhere for the rest of the game.</p>&#13;
<p class="indent">The following output represents one of the worst situations you can find yourself in as a decision maker:</p>&#13;
<pre>Search 2 Results 1 = Not Found&#13;
Search 2 Results 2 = Not Found&#13;
&#13;
Search 2 Effectiveness (E):&#13;
E1 = 0.000, E2 = 0.234, E3 = 0.610&#13;
&#13;
New Target Probabilities (P) for Search 3:&#13;
P1 = 0.382, P2 = 0.395, P3 = 0.223</pre>&#13;
<p class="indent">After search 2, with only one search left, the target probabilities are so similar they provide little guidance for where to search next. In this case, it’s best to divide your searches between two areas and hope for the best.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_24"/>Play the game a few times by blindly searching the areas in order of initial probability, doubling up on area 2, then 3, then 1. Then try obeying the Bayes results religiously, always doubling your searches in the area with the highest current target probability. Next, try dividing your searches between the areas with the two highest probabilities. After that, allow your own intuition to have a say, overruling Bayes when you feel it’s appropriate. As you can imagine, with more search areas and more search days, human intuition would quickly get overwhelmed.</p>&#13;
<h3 class="h3" id="ch00lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about Bayes’ rule, a simple statistical theorem with broad applications in our modern world. You wrote a program that used the rule to take new information—in the form of estimates of search effectiveness—and update the probability of finding a lost sailor in each area being searched.</p>&#13;
<p class="indent">You also loaded and used multiple scientific packages, like <span class="literal">NumPy</span> and OpenCV, that you’ll implement throughout the book. And you applied the useful <span class="literal">itertools</span>, <span class="literal">sys</span>, and <span class="literal">random</span> modules from the Python Standard Library.</p>&#13;
<h3 class="h3" id="ch00lev1sec8"><strong>Further Reading</strong></h3>&#13;
<p class="noindent"><em>The Theory That Would Not Die: How Bayes’ Rule Cracked the Enigma Code, Hunted Down Russian Submarines, and Emerged Triumphant from Two Centuries of Controversy</em> (Yale University Press, 2011), by Sharon Bertsch McGrayne, recounts the discovery and controversial history of Bayes’ rule. The appendix includes several example applications of Bayes’ rule, one of which inspired the missing-sailor scenario used in this chapter.</p>&#13;
<p class="indent">A major source of documentation for <span class="literal">NumPy</span> is <em><a href="https://docs.scipy.org/doc/">https://docs.scipy.org/doc/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec9"><strong>Challenge Project: Smarter Searches</strong></h3>&#13;
<p class="noindent">Currently, the <em>bayes.py</em> program places all the coordinates within a search area into a list and randomly shuffles them. Subsequent searches in the same area may end up retracing previous tracks. This isn’t necessarily bad from a real-life perspective, as the sailor will be drifting around the whole time, but overall it would be best to cover as much of the area as possible without repetition.</p>&#13;
<p class="indent">Copy and edit the program so that it keeps track of which coordinates have been searched within an area and excludes them from future searches (until <span class="literal">main()</span> is called again, either because the player finds the sailor or chooses menu option 7 to restart). Test the two versions of the game to see whether your changes noticeably impact the results.</p>&#13;
<h3 class="h3" id="ch00lev1sec10"><strong>Challenge Project: Finding the Best Strategy with MCS</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_25"/>Monte Carlo simulation (MCS) uses repeated random sampling to predict different outcomes under a specified range of conditions. Create a version of <em>bayes.py</em> that automatically chooses menu items and keeps track of thousands of results, allowing you to determine the most successful search strategy. For example, have the program choose menu item 1, 2, or 3 based on the highest Bayesian target probability and then record the search number when the sailor is found. Repeat this procedure 10,000 times and take the average of all the search numbers. Then loop again, choosing from menu item 4, 5, or 6 based on the highest combined target probability. Compare the final averages. Is it better to double up your searches in a single area or split them between two areas?</p>&#13;
<h3 class="h3" id="ch00lev1sec11"><strong>Challenge Project: Calculating the Probability of Detection</strong></h3>&#13;
<p class="noindent">In a real-life search and rescue operation, you would make an estimate of the <em>expected</em> search effectiveness probability for each area prior to making a search. This expected, or <em>planned</em>, probability would be informed primarily by weather reports. For example, fog might roll into one search area, while the other two enjoy clear skies.</p>&#13;
<p class="indent">Multiplying target probability by the planned SEP yields the <em>probability of detection (PoD)</em> for an area. The PoD is the probability an object will be detected given all known error and noise sources.</p>&#13;
<p class="indent">Write a version of <em>bayes.py</em> that includes a randomly generated planned SEP for each search area. Multiply the target probability for each area (such as <span class="literal">self.p1</span>, <span class="literal">self.p2</span>, or <span class="literal">self.p3</span>) by these new variables to produce a PoD for the area. For example, if the Bayes target probability for area 3 is 0.90 but the planned SEP is only 0.1, then the probability of detection is 0.09.</p>&#13;
<p class="indent">In the shell display, show the player the target probabilities, the planned SEPs, and the PoD for each area, as shown next. Players can then use this information to guide their choice from the search menu.</p>&#13;
<pre>Actual Search 1 Effectiveness (E):&#13;
E1 = 0.190, E2 = 0.000, E3 = 0.000&#13;
&#13;
New Planned Search Effectiveness and Target Probabilities (P) for Search 2:&#13;
E1 = 0.509, E2 = 0.826, E3 = 0.686&#13;
P1 = 0.168, P2 = 0.520, P3 = 0.312&#13;
&#13;
Search 2&#13;
&#13;
    Choose next areas to search:&#13;
&#13;
    0 - Quit&#13;
    &#13;
    1 - Search Area 1 twice&#13;
      Probability of detection: 0.164&#13;
      &#13;
    <span epub:type="pagebreak" id="page_26"/>2 - Search Area 2 twice&#13;
      Probability of detection: 0.674&#13;
      &#13;
    3 - Search Area 3 twice&#13;
      Probability of detection: 0.382&#13;
      &#13;
    4 - Search Areas 1 &amp; 2&#13;
      Probability of detection: 0.515&#13;
      &#13;
    5 - Search Areas 1 &amp; 3&#13;
      Probability of detection: 0.3&#13;
      &#13;
    6 - Search Areas 2 &amp; 3&#13;
      Probability of detection: 0.643&#13;
      &#13;
    7 - Start Over&#13;
    &#13;
Choice:</pre>&#13;
<p class="indent">To combine PoD when searching the same area twice, use this formula:</p>&#13;
<div class="image1"><img src="../images/equ_page_26_01.jpg" alt="Image"/></div>&#13;
<p class="indent">Otherwise, just sum the probabilities.</p>&#13;
<p class="indent">When calculating the actual SEP for an area, constrain it somewhat to the expected value. This considers the general accuracy of weather reports made only a day in advance. Replace the <span class="literal">random.uniform()</span> method with a distribution, such as triangular, built around the planned SEP value. For a list of available distribution types, see <em><a href="https://docs.python.org/3/library/random.html#real-valued-distributions">https://docs.python.org/3/library/random.html#real-valued-distributions</a></em>. Of course, the actual SEP for an unsearched area will always be zero.</p>&#13;
<p class="indent">How does incorporating planned SEPs affect gameplay? Is it easier or harder to win? Is it harder to grasp how Bayes’ rule is being applied? If you oversaw a real search, how would you deal with an area with a high target probability but a low planned SEP due to rough seas? Would you search anyway, call off the search, or move the search to an area with a low target probability but better weather?</p>&#13;
</body></html>