- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WINNING THE MOON RACE WITH APOLLO 8
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the summer of 1968, America was losing the space race. The Soviet Zond spacecraft
    appeared moon-ready, the Central Intelligence Agency had photographed a giant
    Soviet N-1 rocket sitting on its launch pad, and the Americans’ troubled Apollo
    program still needed three more test flights. But in August, NASA manager George
    Low had an audacious idea. Let’s go to the moon *now*. Instead of more tests in
    the earth’s orbit, let’s circle the moon in December and let *that* be the test.
    In that moment, the space race was essentially over. Less than a year later, the
    Soviets had capitulated, and Neil Armstrong had taken his great leap for all mankind.
  prefs: []
  type: TYPE_NORMAL
- en: The decision to take the Apollo 8 spacecraft to the moon was hardly trivial.
    In 1967, three men had died in the Apollo 1 capsule, and multiple unmanned missions
    had blown up or otherwise failed. Against this backdrop and with so much at stake,
    everything hinged on the concept of the *free return*. The mission was designed
    so that if the service module engine failed to fire, the ship would simply swing
    around the moon and return to the earth like a boomerang ([Figure 6-1](ch06.xhtml#ch06fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The Apollo 8 insignia, with the circumlunar free return trajectory
    serving as the mission number'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll write a Python program that uses a drawing board module
    called turtle to simulate Apollo 8’s free return trajectory. You’ll also work
    with one of the classic conundrums in physics: the three-body problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the Apollo 8 Mission**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of the Apollo 8 mission was merely to circle the moon, so there was
    no need to take a lunar lander component. The astronauts traveled in the command
    and service modules, collectively known as the *CSM* ([Figure 6-2](ch06.xhtml#ch06fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Apollo command and service modules'
  prefs: []
  type: TYPE_NORMAL
- en: In the fall of 1968, the CSM engine had been tested in the earth’s orbit only,
    and there were legitimate concerns about its reliability. To orbit the moon, the
    engine would have to fire twice, once to slow the spacecraft to enter lunar orbit
    and then again to leave orbit. With the free return trajectory, if the first maneuver
    failed, the astronauts could still coast home. As it turned out, the engine fired
    perfectly both times, and Apollo 8 orbited the moon 10 times. (The ill-fated Apollo
    13, however, made great use of its free return trajectory!)
  prefs: []
  type: TYPE_NORMAL
- en: '***The Free Return Trajectory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plotting a free return trajectory requires a lot of intense mathematics. It
    *is* rocket science, after all! Fortunately, you can simulate the trajectory in
    a two-dimensional graph with a few simplified parameters ([Figure 6-3](ch06.xhtml#ch06fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: The free return trajectory (not to scale)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This 2D simulation of the free return uses a few key values: the starting position
    of the CSM (R[0]), the velocity and orientation of the CSM (V[0]), and the phase
    angle between the CSM and the moon (γ[0]). The *phase angle*, also called the
    *lead angle*, is the change in the orbital time position of the CSM required to
    get from a starting position to a final position. The *translunar injection velocity*
    (V[0]) is a propulsive maneuver used to set the CSM on a trajectory to the moon.
    It’s achieved from a *parking orbit* around the earth, where the spacecraft performs
    internal checks and waits until the phase angle with the moon is optimal. At this
    point, the third stage of the *Saturn V* rocket fires and falls away, leaving
    the CSM to coast to the moon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the moon is moving, before you perform the translunar injection, you
    have to predict its future position, or *lead* it, like when you’re shooting skeet
    with a shotgun. This requires knowing the phase angle (γ[0]) at the time of translunar
    injection. Leading the moon is a little different from shooting a shotgun, however,
    as space is curved and you need to factor in the gravity of the earth and the
    moon. The tug of these two bodies on the spacecraft creates perturbations that
    are difficult to calculate—so difficult, in fact, that the calculation has earned
    its own special name in the field of physics: the three-body problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Three-Body Problem***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *three-body problem* is the challenge of predicting the behavior of three
    interacting bodies. Isaac Newton’s gravity equations work great for predicting
    the behavior of two orbiting bodies, such as the earth and the moon, but add one
    more body to the mix, whether a spacecraft, comet, moon, or so on, and things
    get complicated. Newton was never able to encapsulate the behavior of three or
    more bodies into a simple equation. For 275 years— even with kings offering prizes
    for a solution—the world’s greatest mathematicians worked the problem in vain.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that the three-body problem can’t be solved using simple algebraic
    expressions or integrals. Calculating the impact of multiple gravitational fields
    requires numerical iteration on a scale that’s impractical without a high-speed
    computer, such as your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: In 1961, Michael Minovitch, a summer intern at the Jet Propulsion Laboratory,
    found the first numerical solution using an IBM 7090 mainframe, at the time the
    fastest computer in the world. He discovered that mathematicians could reduce
    the number of computations needed to solve a restricted three-body problem, like
    our earth-moon-CSM problem, by using a patched conic method.
  prefs: []
  type: TYPE_NORMAL
- en: The *patched conic method* is an analytical approximation that assumes you’re
    working with a simple two-body problem while the spacecraft is in the earth’s
    gravitational sphere of influence and another when you’re within the moon’s sphere
    of influence. It’s a rough, “back-of-the-envelope” calculation that provides reasonable
    estimates of departure and arrival conditions, reducing the number of choices
    for initial velocity and position vectors. All that’s left is to refine the flight
    path with repeated computer simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Because researchers have already found and documented the Apollo 8 mission’s
    patched conic solution, you won’t need to calculate it. I’ve already adapted it
    to the 2D scenario you’ll be doing here. You can experiment with alternative solutions
    later, however, by varying parameters such as R[0] and V[0] and rerunning the
    simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #9: To the Moon with Apollo 8!**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a summer intern at NASA, you’ve been asked to create a simple simulation
    of the Apollo 8 free return trajectory for consumption by the press and general
    public. As NASA is always strapped for cash, you’ll need to use open source software
    and complete the project quickly and cheaply.
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that graphically simulates the free return trajectory
    proposed for the Apollo 8 mission.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the turtle Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To simulate the flight of Apollo 8, you’ll need a way to draw and move images
    on the screen. There are a lot of third-party modules that can help you do this,
    but we’ll keep things simple by using the preinstalled turtle module. Although
    originally invented to help kids learn programming, turtle can easily be adapted
    to more sophisticated uses.
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module lets you use Python commands to move a small image, called
    a *turtle*, around a screen. The image can be invisible, an actual image, a custom
    shape, or one of the predefined shapes shown in [Figure 6-4](ch06.xhtml#ch06fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Standard turtle shapes provided with the turtle module'
  prefs: []
  type: TYPE_NORMAL
- en: As the turtle moves, you can choose to draw a line behind it to trace its movement
    ([Figure 6-5](ch06.xhtml#ch06fig5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Moving the turtle around the Turtle Graphics window'
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple drawing was made with the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can use Python functionality with turtle to write more concise code. For
    example, you can use a for loop to create the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, steve moves forward 50 pixels and then turns to the left at a right angle.
    These steps are repeated three times by the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: Other turtle methods let you change the shape of the turtle, change its color,
    lift the pen so no path is drawn, “stamp” its current position on the screen,
    set the heading of the turtle, and get its position on the screen. [Figure 6-6](ch06.xhtml#ch06fig6)
    shows this functionality, which is described in the script that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: More examples of turtle behaviors. Numbers refer to script annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After importing the turtle module and instantiating a turtle object named steve,
    leave behind an image of steve using the stamp() method ➊. Then use the position()
    method ➋ to get the turtle’s current (*x*, *y*) coordinates as a tuple ➌. This
    will come in handy when calculating the distance between objects for the gravity
    equation.
  prefs: []
  type: TYPE_NORMAL
- en: Move the turtle forward 150 spaces and change its color to gray ➍. Then leave
    a stamp behind, rotate the turtle 45 degrees, and move it backward 75 spaces using
    the bk() (backward) method ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Leave another stamp and then stop drawing the turtle’s path by using the penup()
    method ➏. Move steve backward another 75 spaces and color him black. Now use an
    alternative to rotate(), which is to directly set the heading of the turtle ➐.
    The heading is simply the direction the turtle is traveling. Note that the default
    “standard mode” directions are referenced to the east, not the north ([Table 6-1](ch06.xhtml#ch06table1)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Common Directions in Degrees for the turtle Module in Standard
    Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '| Degrees | Direction |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | East |'
  prefs: []
  type: TYPE_TB
- en: '| 90 | North |'
  prefs: []
  type: TYPE_TB
- en: '| 180 | West |'
  prefs: []
  type: TYPE_TB
- en: '| 270 | South |'
  prefs: []
  type: TYPE_TB
- en: Leave another stamp and then put the pen down to once more draw a path behind
    the turtle ➑. Move steve forward 50 spaces and then change his shape to a triangle
    ➒. That completes the drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be fooled by the simplicity of what we’ve done so far. With the right
    commands, you can draw intricate designs, such as the Penrose tiling in [Figure
    6-7](ch06.xhtml#ch06fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: A Penrose tiling produced by the turtle module demo, penrose.py'
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module is part of the Python Standard Library, and you can find the
    official documentation at *[https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/](https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/)*.
    For a quick tutorial, do an online search for Al Sweigart’s *Simple Turtle Tutorial
    for Python*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve now made a strategic decision to use turtle to draw the simulation, but
    how should the simulation look? For convenience, I’d suggest basing it on [Figure
    6-3](ch06.xhtml#ch06fig3). You’ll start with the CSM in the same parking orbit
    position around the earth (R[0]) and the moon at the same approximate phase angle
    (γ[0]). You can use images to represent the earth and the moon and custom turtle
    shapes to build the CSM.
  prefs: []
  type: TYPE_NORMAL
- en: Another big decision at this point is whether to use procedural or object-oriented
    programming (OOP). When you plan to generate multiple objects that behave similarly
    and interact with each other, OOP is a good choice. You can use an OOP class as
    a blueprint for the earth, the moon, and the CSM objects and automatically update
    the object attributes as the simulation runs.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the simulation using *time steps*. Basically, each program loop
    will represent one unit of dimensionless time. With each loop, you’ll need to
    calculate each object’s position and update (redraw) it on the screen. This requires
    solving the three-body problem. Fortunately, not only has someone done this already,
    they’ve done it using turtle.
  prefs: []
  type: TYPE_NORMAL
- en: Python modules often include example scripts to show you how to use the product.
    For instance, the matplotlib gallery includes code snippets and tutorials for
    making a huge number of charts and plots. Likewise, the turtle module comes with
    *turtle-example-suite*, which includes demonstrations of turtle applications.
  prefs: []
  type: TYPE_NORMAL
- en: One of the demos, *planet_and_moon.py*, provides a nice “recipe” for handling
    a three-body problem in turtle ([Figure 6-8](ch06.xhtml#ch06fig8)). To see the
    demos, open a PowerShell or terminal window and enter python –m turtledemo. Depending
    on your platform and how many versions of Python you have installed, you may need
    to use python3 -m turtledemo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-8: Screen capture of the planet_and_moon.py turtle demo'
  prefs: []
  type: TYPE_NORMAL
- en: This demo addresses the sun-earth-moon three-body problem, but it can be easily
    adapted to handle an earth-moon-CSM problem. Again, for the specific Apollo 8
    situation, you’ll use [Figure 6-3](ch06.xhtml#ch06fig3) to guide development of
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Apollo 8 Free Return Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *apollo_8_free_return.py* program uses turtle graphics to generate a top-down
    view of the Apollo 8 CSM leaving the earth’s orbit, circling the moon, and returning
    to the earth. The core of the program is based on the *planet_and_moon.py* demo
    discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the program in the *Chapter_6* folder, downloadable from the book’s
    website at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
    You’ll also need the earth and moon images found there ([Figure 6-9](ch06.xhtml#ch06fig9)).
    Be sure to keep them in the same folder as the code and don’t rename them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: earth_100x100.gif and moon_27x27.gif images used in the simulation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing turtle and Assigning Constants**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-1](ch06.xhtml#ch06list1) imports the turtle module and assigns constants
    that represent key parameters: the gravitational constant, the number of times
    to run the main loop, and the *x* and *y* values for R[0] and V[0] (see [Figure
    6-3](ch06.xhtml#ch06fig3)). Listing these values near the top of the program makes
    them easy to find and alter later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: Importing turtle and assigning constants'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to import four helper classes from turtle. You’ll use the Shape
    class to make a custom turtle that looks like the CSM. The Screen subclass makes
    the screen, called a *drawing board* in turtle parlance. The Turtle subclass creates
    the turtle objects. The Vec2D import is a two-dimensional vector class. It will
    help you define velocity as a vector of magnitude and direction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign some variables that the user may want to tweak later. Start with
    the gravitational constant, used in Newton’s gravity equations to ensure the units
    come out right. Assign it 8, the value used in the turtle demo. Think of this
    as a *scaled* gravitational constant. You can’t use the true constant, as the
    simulation doesn’t use real-world units.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll run the simulation in a loop, and each iteration will represent a time
    step. With each step, the program will recalculate the position of the CSM as
    it moves through the gravity fields of the earth and the moon. The value of 4100,
    arrived at by trial and error, will stop the simulation just after the spacecraft
    arrives back on the earth.
  prefs: []
  type: TYPE_NORMAL
- en: In 1968, a round-trip to the moon took about six days. Since you’re incrementing
    the time unit by 0.001 with each loop and running 4,100 loops, this means a time
    step in the simulation represents about two minutes of time in the real world.
    The longer the time step, the faster the simulation but the less accurate the
    results, as small errors compound over time. In actual fight path simulations,
    you can optimize the time step by first running a small step, for maximum accuracy,
    and then using the results to find the largest time step that yields a similar
    result.
  prefs: []
  type: TYPE_NORMAL
- en: The next two variables, Ro_X and Ro_Y, represent the (*x*, *y*) coordinates
    of the CSM at the time of the translunar injection (see [Figure 6-3](ch06.xhtml#ch06fig3)).
    Likewise, Vo_X and Vo_Y represent the *x*- and *y*-direction components of the
    translunar injection velocity, which is applied by the third stage of the *Saturn
    V* rocket. These values started out as best guesses and were refined with repeated
    simulations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Gravity System**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because the earth, the moon, and CSM form a continuously interacting gravity
    system, you’ll want a convenient way to represent them and their respective forces.
    For this, you’ll need two classes, one to create a gravity system and one to create
    the bodies within it. [Listing 6-2](ch06.xhtml#ch06list2) defines the GravSys
    class that helps you create a mini solar system. This class will use a list to
    keep track of all the bodies in motion and loop them through a series of time
    steps. It’s based on the *planet_and_moon.py* demo in the turtle library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Defining a class to manage the bodies in the gravity system'
  prefs: []
  type: TYPE_NORMAL
- en: The GravSys class defines how long the simulation will run, how much time will
    pass between time steps (loops), and what bodies will be involved. It also calls
    the step() method of the Body class you’ll define in [Listing 6-3](ch06.xhtml#ch06list3).
    This method will update each body’s position as a result of gravitational acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Define the initialization method and, as per convention, pass it self as a parameter.
    The self parameter represents the GravSys object you’ll create later in the main()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty list named bodies to hold the earth, the moon, and the CSM objects.
    Then assign attributes for when the simulation starts and the amount to increment
    time with each loop, known as *delta time* or dt. Set the starting time to 0 and
    set the dt time step to 0.001. As discussed in the previous section, this time
    step will correspond to about two minutes in the real world and will produce a
    smooth, accurate, and fast simulation.
  prefs: []
  type: TYPE_NORMAL
- en: The last method controls the time steps in the simulation ➊. It uses a for loop
    with the range set to the NUM_LOOPS variable. Use a single underscore (_) rather
    than i to indicate the use of an insignificant variable (see [Listing 5-3](ch05.xhtml#ch05list3)
    in [Chapter 5](ch05.xhtml) for details).
  prefs: []
  type: TYPE_NORMAL
- en: With each loop, increment the gravity system’s time variable by dt. Then, apply
    the time shift to each body by looping through the list of bodies and calling
    the body.step() method, which you’ll define later within the Body class. This
    method updates the position and velocity of the bodies due to gravitational attraction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Celestial Bodies**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-3](ch06.xhtml#ch06list3) defines the Body class used to build the
    earth, the moon, and the CSM Body objects. Although no one would ever mistake
    a planet for a small spacecraft, they’re not that different from a gravitational
    standpoint, and you can stamp them both out of the same mold.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: Defining a class to create objects for the earth, the moon, and
    the CSM'
  prefs: []
  type: TYPE_NORMAL
- en: Define a new class by using the Turtle class as its *ancestor*. This means the
    Body class will conveniently inherit all the Turtle class’s methods and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define an initializer method for the body object. You’ll use this to create
    new Body objects in the simulation, a process called *instantiation* in OOP. As
    parameters, the initialize method takes itself, a mass attribute, a starting location,
    a starting velocity, the gravity system object, and a shape.
  prefs: []
  type: TYPE_NORMAL
- en: The super() function lets you invoke the method of a superclass to gain access
    to inherited methods from the ancestor class. This allows your Body objects to
    use attributes from the prebuilt Turtle class. Pass it the shape attribute, which
    will allow you to pass a custom shape or image to your bodies when you build them
    in the main() function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign an instance attribute for the gravsys object. This will allow the
    gravity system and body to interact. Note that it’s best to initialize attributes
    through the __init__() method, as we do in this case, since it’s the first method
    called after the object is created. This way, these attributes will be immediately
    available to any other methods in the class, and other developers can see a list
    of all the attributes in one place.
  prefs: []
  type: TYPE_NORMAL
- en: The following penup() method of the Turtle class will remove the drawing pen
    so the object doesn’t leave a path behind it as it moves. This gives you the option
    of running the simulation with and without visible orbital paths.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a mass attribute for the body. You’ll need this to calculate the
    force of gravity. Next, assign the body’s starting position using the setpos()
    method of the Turtle class. The starting position of each body will be an (*x*,
    *y*) tuple. The origin point (0, 0) will be at the center of the screen. The *x*-coordinate
    increases to the right, and the *y*-coordinate increases upward.
  prefs: []
  type: TYPE_NORMAL
- en: Assign an initialization attribute for velocity. This will hold the starting
    velocity for each object. For the CSM, this value will change throughout the simulation
    as the ship moves through the gravity fields of the earth and the moon.
  prefs: []
  type: TYPE_NORMAL
- en: As each body is instantiated, use dot notation to append it to the list of bodies
    in the gravity system. You’ll create the gravsys object from the GravSys() class
    in the main() function.
  prefs: []
  type: TYPE_NORMAL
- en: The final two lines, commented out, allow the user to change the simulation
    window size and choose to draw a path behind each object. Start out with a full-screen
    display and keep the pen in the up position to let the simulation run quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating Acceleration Due to Gravity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Apollo 8 simulation will begin immediately after the translunar injection.
    At this point, the third stage of the *Saturn V* has fired and fallen away, and
    the CSM is beginning its coast to the moon. All changes in velocity or direction
    will be entirely due to changes in gravitational force.
  prefs: []
  type: TYPE_NORMAL
- en: The method in [Listing 6-4](ch06.xhtml#ch06list4) loops through the bodies in
    the bodies list, calculates acceleration due to gravity for each body, and returns
    a vector representing the body’s acceleration in the *x* and *y* directions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: Calculating acceleration due to gravity'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still within the Body class, define the acceleration method, called acc(),
    and pass it self. Within the method, name a local variable a, again for acceleration,
    and assign it to a vector tuple using the Vec2D helper class. A 2D vector is a
    pair of real numbers (*a*, *b*), which in this case represent *x* and *y* components,
    respectively. The Vec2D helper class enforces rules that permit easy mathematical
    operations using vectors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (*a*, *b*) + (*c*, *d*) = (*a* + *c*, *b* + *d*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (*a*, *b*) – (*c*, *d*) = (*a* – *c*, *b* – *d*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (*a*, *b*) × (*c*, *d*) = *ac* + *bd*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, start looping through the items in the bodies list, which contains the
    earth, the moon, and the CSM. You’ll use the gravitational force of each body
    to determine the acceleration of the object for which you’re calling the acc()
    method. It doesn’t make sense for a body to accelerate itself, so exclude the
    body if it’s the same as self.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate gravitational acceleration (stored in the g variable) at a point
    in space, you’ll use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_136_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *M* is the mass of the attracting body, *r* is the distance (radius)
    between bodies, *G* is the gravitational constant you defined earlier, and *r*
    is the unit vector from the center of mass of the attracting body to the center
    of mass of the body being accelerated. The *unit vector*, also known as the *direction
    vector* or *normalized vector*, can be described as *r/|r|*, or:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_136_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The unit vector allows you to capture the direction of acceleration, which will
    be either positive or negative. To calculate the unit vector, you’ll have to calculate
    the distance between bodies by using the turtle pos() method to get each body’s
    current position as a Vec2D vector. As described previously, this is a tuple of
    the (*x*, *y*) coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll then input that tuple into the acceleration equation. Each time you loop
    through a new body, you’ll change the a variable based on the gravitational pull
    of the body being examined. For example, while the earth’s gravity may slow the
    CSM, the moon’s gravity may pull in the opposite direction and cause it to speed
    up. The a variable will capture the net effect at the end of the loop. Complete
    the method by returning a.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stepping Through the Simulation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-5](ch06.xhtml#ch06list5), still in the Body class, defines a method
    to solve the three-body problem. It updates the position, orientation, and velocity
    of bodies in the gravity system with each time step. The shorter the time steps,
    the more accurate the solution, though at the cost of computational efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: Applying the time step and rotating the CSM'
  prefs: []
  type: TYPE_NORMAL
- en: Define a step() method to calculate position, orientation, and velocity of a
    body. Assign it self as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Within the method definition, set a local variable, dt, to the gravsys object
    of the same name. This variable has no link to any real-time system; it’s just
    a floating-point number that you’ll use to increment velocity with each time step.
    The larger the dt variable is, the faster the simulation will run.
  prefs: []
  type: TYPE_NORMAL
- en: Now call the self.acc() method to calculate the acceleration that the current
    body experiences due to the combined gravitational fields of the other bodies.
    This method returns a vector tuple of (*x*, *y*) coordinates. Multiply it by dt
    and add the results to self.vel(), which is also a vector, to update the body’s
    velocity for the current time step. Recall that, behind the scenes, the Vec2D
    class will manage the vector arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: To update the body’s position in the turtle graphics window, multiply the body’s
    velocity by the time step and add the result to the body’s position attribute.
    Now each body will move according to the gravitational pull of the other bodies.
    You just solved the three-body problem!
  prefs: []
  type: TYPE_NORMAL
- en: Next, add some code to refine the CSM’s behavior. Thrust comes out of the back
    of the CSM, so in real missions, the rear of the spacecraft is oriented toward
    its target. This way, the engine can fire and slow the ship enough to enter lunar
    orbit or the earth’s atmosphere. Orienting the ship this way isn’t necessary with
    a free return trajectory, but since Apollo 8 planned to fire its engines and enter
    lunar orbit (and did), you should orient the ship properly throughout its journey.
  prefs: []
  type: TYPE_NORMAL
- en: Start by selecting the CSM from the list of bodies ➊. In the main() function,
    you’ll create the bodies in order of size, so the CSM will be the third item in
    the list, at index 2.
  prefs: []
  type: TYPE_NORMAL
- en: To get the CSM to rotate as it coasts through space, assign a small number to
    a local variable named rotate_factor. I arrived at this number through trial and
    error. Next, set the heading of the CSM turtle object using its selfheading attribute.
    Instead of passing it (*x*, *y*) coordinates, call the self.heading() method,
    which returns the object’s current heading in degrees, and subtract from it the
    rotate_factor variable multiplied by the body’s current *x* location, obtained
    by calling the self.xcor() method. This will cause the CSM to rotate faster as
    it approaches the moon to keep its tail pointed in the direction of travel.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to eject the service module before the spacecraft enters the earth’s
    atmosphere. To do this at a position similar to that in real Apollo missions,
    use another conditional to check the spacecraft’s *x*-coordinate ➋. The simulation
    expects the earth to be near the center of the screen, at coordinates (0, 0).
    In turtle, the *x*-coordinate will decrease as you move left of the center and
    increase as you move to the right. If the CSM’s *x*-coordinate is less than –20
    pixels, you can assume that it’s returning home and that it’s time to part company
    with the service module.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll model this event by changing the shape of the turtle representing the
    CSM. Since turtle includes a standard shape—called arrow—that looks similar to
    the command module, all you need to do now is call the self.shape() method and
    pass it the name of the shape. Then call the self.shapesize() method and halve
    the size of the arrow to make it match the command module in the CSM custom shape,
    which you’ll make later. When the CSM passes the –20 *x*-position, the service
    module will magically disappear, leaving the command module to complete the voyage
    home.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll want to orient the base of the command module, with its heat-resistant
    shielding, toward the earth. Do this by setting the arrow shape’s heading to 105
    degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining main(), Setting Up the Screen, and Instantiating the Gravity System**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You used object-oriented programming to build the gravity system and the bodies
    within it. To run the simulation, you’ll return to procedural programming and
    use a main() function. This function sets up the turtle graphics screen, instantiates
    objects for the gravity system and the three bodies, builds a custom shape for
    the CSM, and calls the gravity system’s sim_loop() method to walk through the
    time steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-6](ch06.xhtml#ch06list6) defines main() and sets up the screen.
    It also creates a gravity system object to manage your mini solar system.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: Setting up the screen and making a gravsys object in main()'
  prefs: []
  type: TYPE_NORMAL
- en: Define main() and then instantiate a screen object (a drawing window) based
    on the TurtleScreen subclass. Then invoke the screen object’s setup() method to
    set the size of screen to full. Do this by passing width and height arguments
    of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want the drawing window to take up the full screen, pass setup()
    the pixel arguments shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that a negative startx value uses right justification, a negative starty
    uses bottom alignment, and the default settings create a centered window. Feel
    free to experiment with these parameters to get the best fit to your monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Complete setting up the screen by setting its background color to black and
    giving it a title. Next, instantiate a gravity system object, gravsys, using the
    GravSys class. This object will give you access to the attributes and methods
    in the GravSys class. You’ll pass it to each body when you instantiate them shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Earth and Moon**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-7](ch06.xhtml#ch06list7), still in the main() function, creates
    turtle objects for the earth and the moon using the Body class you defined earlier.
    The earth will remain stationary at the center of the screen, while the moon will
    revolve around the earth.'
  prefs: []
  type: TYPE_NORMAL
- en: When you create these objects, you’ll set their starting coordinates. The starting
    position of the earth is near the center of the screen, biased downward a bit
    to give the moon and CSM room to interact near the top of the window.
  prefs: []
  type: TYPE_NORMAL
- en: The starting position of the moon and CSM should reflect what you see in [Figure
    6-3](ch06.xhtml#ch06fig3), with the CSM vertically beneath the center of the earth.
    This way, you only need to thrust in the *x* direction, rather than calculate
    a vector component velocity that includes some movement in the *x* direction and
    some in the *y* direction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: Instantiating turtles for the earth and moon'
  prefs: []
  type: TYPE_NORMAL
- en: Start by assigning the image of the earth, which is included in the folder for
    this project, to a variable. Note that images should be *gif* files and cannot
    be rotated to show the turtle’s heading. So that turtle recognizes the new shape,
    add it to the TurtleScreen shapelist using the screen.register_shape() method.
    Pass it the variable that references the earth image.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to instantiate the turtle object for the earth. You call the Body
    class and pass it the arguments for mass, starting position, starting velocity,
    gravity system, and turtle shape—in this case, the image. Let’s talk about each
    of these arguments in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: You’re not using real-world units here, so mass is an arbitrary number. I started
    with the value used for the sun in the turtle demo *planet_and_moon.py*, on which
    this program is based.
  prefs: []
  type: TYPE_NORMAL
- en: The starting position is an (*x*, *y*) tuple that places the earth near the
    center of the screen. It’s biased downward 25 pixels, however, as most of the
    action will take place in the upper quadrant of the screen. This placement will
    provide a little more room in that region.
  prefs: []
  type: TYPE_NORMAL
- en: The starting velocity is a simple (*x*, *y*) tuple provided as an argument to
    the Vec2D helper class. As discussed previously, this will allow later methods
    to alter the velocity attribute using vector arithmetic. Note that the earth’s
    velocity is not (0, 0), but (0, -2.5). In real life and in the simulation, the
    moon is massive enough to affect the earth so that the center of gravity between
    the two is not at the center of the earth, but farther out. This will cause the
    earth turtle to wobble and shift positions in a distracting manner during the
    simulation. Because the moon will be in the upper part of the screen during simulation,
    shifting the earth downward a small amount each time step will dampen the wobbling.
  prefs: []
  type: TYPE_NORMAL
- en: The last two arguments are the gravsys object you instantiated in the previous
    listing and the image variable for the earth. Passing gravsys means the earth
    turtle will be added to the list of bodies and included in the sim_loop() class
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you don’t want to use a lot of arguments when instantiating an
    object, you can change an object’s attributes after it’s created. For example,
    when defining the Body class, you could’ve set self.mass = 0, rather than using
    an argument for mass. Then, after instantiating the earth body, you could reset
    the mass value using earth.mass = 1000000.
  prefs: []
  type: TYPE_NORMAL
- en: Because the earth wobbles a little, its orbital path will form a tight circle
    at the top of the planet. To hide it in the polar cap, use the turtle pencolor()
    method and set the line color to white.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the earth turtle with code that delays the start of the simulation and
    prevents the various turtles from flashing on the screen as the program first
    draws and resizes them. The getscreen() method returns the TurtleScreen object
    the turtle is drawing on. TurtleScreen methods can then be called for that object.
    In the same line, call the tracer() method that turns the turtle animation on
    or off and sets a delay for drawing updates. The *n* parameter determines the
    number of times the screen updates. A value of 0 means the screen updates with
    every loop; larger values progressively repress the updates. This can be used
    to accelerate the drawing of complex graphics, but at the cost of image quality.
    The second argument sets a delay value, in milliseconds, between screen updates.
    Increasing the delay slows the animation.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll build the moon turtle in a similar fashion to the one for the earth.
    Start by assigning a new variable to hold the moon image ➊. The moon’s mass is
    only a few percent of the earth’s mass, so use a much smaller value for the moon.
    I started out with a mass of around 16,000 and tweaked the value until the CSM’s
    flight path produced a visually pleasing loop around the moon.
  prefs: []
  type: TYPE_NORMAL
- en: The moon’s starting position is controlled by the phase angle shown in [Figure
    6-3](ch06.xhtml#ch06fig3). Like this figure, the simulation you’re creating here
    is not to scale. Although the earth and moon images will have the correct relative
    sizes, the distance between the two is smaller than the actual distance, so the
    phase angle will need to be adjusted accordingly. I’ve reduced the distance in
    the model because space is big. Really big. If you want to show the simulation
    to scale and fit it all on your computer monitor, then you must settle for a ridiculously
    tiny earth and moon ([Figure 6-10](ch06.xhtml#ch06fig10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: Earth and moon system at closest approach, or perigee, shown to
    scale'
  prefs: []
  type: TYPE_NORMAL
- en: To keep the two bodies recognizable, you’ll instead use larger, properly scaled
    images but reduce the distance between them ([Figure 6-11](ch06.xhtml#ch06fig11)).
    This configuration will be more relatable to the viewer and still allow you to
    replicate the free return trajectory.
  prefs: []
  type: TYPE_NORMAL
- en: Because the earth and the moon are closer together in the simulation, the moon’s
    orbital velocity will be faster than in real life, as per Kepler’s second law
    of planetary motion. To compensate for this, the moon’s starting position is designed
    to reduce the phase angle compared to that shown in [Figure 6-3](ch06.xhtml#ch06fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: The earth and moon system in the simulation, with only the body
    sizes at the correct scale'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll want the option to draw a line behind the moon to trace its
    orbit. Use the turtle pencolor() method and set the line color to gray.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters such as mass, initial position, and initial velocity are good candidates
    for global constants. Despite this, I chose to enter them as method arguments
    to avoid overloading the user with too many input variables at the start of the
    program.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Custom Shape for the CSM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now it’s time to instantiate a turtle object to represent the CSM. This requires
    a little more work than the last two objects.
  prefs: []
  type: TYPE_NORMAL
- en: First, there’s no way to show the CSM at the same scale as the earth and the
    moon. To do that, you’d need *less than* a pixel, which is impossible. Plus, where’s
    the fun in that? So, once again, you’ll take liberties with scale and make the
    CSM large enough to be recognizable as an Apollo spacecraft.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you won’t use an image for the CSM, as you did with the other two bodies.
    Because image shapes don’t automatically rotate when a turtle turns and you want
    to orient the CSM tail-first through most of its journey, you must instead customize
    your own shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-8](ch06.xhtml#ch06list8), still in main(), builds a representation
    of the CSM by drawing basic shapes, such as rectangles and triangles. You then
    combine these individual primitives into a final compound shape.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: Building a custom shape for the CSM turtle'
  prefs: []
  type: TYPE_NORMAL
- en: Name a variable csm and call the turtle Shape class. Pass it 'compound', indicating
    you want to build the shape using multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: The first component will be the command module. Name a variable cm and assign
    it to a tuple of coordinate pairs, known as a *polygon type* in turtle. These
    coordinates build a triangle, as shown in [Figure 6-12](ch06.xhtml#ch06fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: CSM compound shape with coordinates for nozzle, service module,
    and command module'
  prefs: []
  type: TYPE_NORMAL
- en: Add this triangle component to the csm shape using the addcomponent() method,
    called with dot notation. Pass it the cm variable, a fill color, and an outline
    color. Good fill colors are white, silver, gray, or red.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this general process for the service module rectangle. Set the outline
    color to black when you add the component to delineate the service and command
    modules (see [Figure 6-12](ch06.xhtml#ch06fig12)).
  prefs: []
  type: TYPE_NORMAL
- en: Use another triangle for the nozzle, also called the *engine bell*. Add the
    component and then register the new csm compound shape to the screen. Pass the
    method a name for the shape and then the variable referencing the shape.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the CSM, Starting the Simulation, and Calling main()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch06list9) completes the main() function by instantiating
    a turtle for the CSM and calling the simulation loop that runs the time steps.
    It then calls main() if the program is run in stand-alone mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: Instantiating a CSM turtle, calling the simulation loop and main()'
  prefs: []
  type: TYPE_NORMAL
- en: Create a turtle named ship to represent the CSM. The starting position is an
    (*x*, *y*) tuple that places the CSM in a parking orbit directly below the earth
    on the screen. I first approximated the proper height for the parking orbit (R[0]
    in [Figure 6-3](ch06.xhtml#ch06fig3)) and then fine-tuned it by repeatedly running
    the simulation. Note that you use the constants assigned at the start of the program,
    rather than actual values. This is to make it easier for you to experiment with
    these values later.
  prefs: []
  type: TYPE_NORMAL
- en: The velocity argument (Vo_X, Vo_Y) represents the speed of the CSM at the moment
    the Saturn third stage stops firing during translunar injection. All the thrust
    is in the *x* direction, but the earth’s gravity will cause the flight path to
    immediately curve upward. Like the R[0] parameter, a best-guess velocity was input
    and refined through simulation. Note that the velocity is a tuple input using
    the Vec2D helper class, which allows later methods to alter the velocity using
    vector arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the size of the ship turtle using the shapesize() method. Then set
    its path color to white so it will match the ship color. Other attractive colors
    are silver, gray, and red.
  prefs: []
  type: TYPE_NORMAL
- en: Control the screen updates with the getscreen() and tracer() methods, described
    in [Listing 6-7](ch06.xhtml#ch06list7), and then set the ship’s heading to 90
    degrees, which will point it due east on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the body objects. Now all that’s left is to launch the simulation
    loop, using the gravsys object’s sim_loop() method. Back in the global space,
    finish the program with the code to run the program as an imported module or in
    stand-alone mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the program is currently written, you’ll have to manually close the Turtle
    Graphics window. If you want the window to close automatically, add the following
    command as the last line in main():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '***Running the Simulation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you first run the simulation, the pen will be up, and none of the bodies
    will draw their orbital path ([Figure 6-13](ch06.xhtml#ch06fig13)). The CSM will
    smoothly rotate and reorient itself as it approaches the moon and then the earth.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: The simulation run with the pen up and the CSM approaching the
    moon'
  prefs: []
  type: TYPE_NORMAL
- en: 'To trace the journey of the CSM, go to the definition of the Body class and
    uncomment this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should now see the figure-eight shape of the free return trajectory ([Figure
    6-14](ch06.xhtml#ch06fig14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: The simulation run with the pen down and the CM at splashdown
    in the Pacific'
  prefs: []
  type: TYPE_NORMAL
- en: You can also simulate *gravity propulsion*—otherwise known as a *slingshot maneuver*—by
    setting the Vo_X velocity variable to a value between 520 and 540 and rerunning
    the simulation. This will cause the CSM to pass behind the moon and steal some
    of its momentum, increasing the ship’s velocity and deflecting its flight path
    ([Figure 6-15](ch06.xhtml#ch06fig15)). Bye-bye Apollo 8!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The gravitational slingshot maneuver achieved with Vo_X = 520'
  prefs: []
  type: TYPE_NORMAL
- en: This project should teach you that space travel is a game of seconds and centimeters.
    If you continue to experiment with value of the Vo_X variable, you’ll find that
    even small changes can doom the mission. If you don’t crash into the moon, you’ll
    reenter the earth’s atmosphere too steeply or miss it entirely!
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about simulations is that, if you fail, you can live to try again.
    NASA runs countless simulations for all its proposed missions. The results help
    NASA choose between competing flight plans, find the most efficient routes, decide
    what to do if things go wrong, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Simulations are especially important for outer solar system exploration, where
    great distances make real-time communications impossible. The timing of key events,
    such as firing thrusters, taking photographs, or dropping probes, are all preprogrammed
    based on meticulous simulations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the turtle drawing program, including
    how to make customized turtle shapes. You also learned how to use Python to simulate
    gravity and solve the famous three-body problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Apollo 8: The Thrilling Story of the First Mission to the Moon* (Henry Holt
    and Co., 2017), by Jeffrey Kluger, covers the historic Apollo 8 mission from its
    unlikely beginning to its “unimaginable triumph.”'
  prefs: []
  type: TYPE_NORMAL
- en: An online search for *PBS Nova How Apollo 8 Left Earth Orbit* should return
    a short video clip on the Apollo 8 translunar injection maneuver, marking the
    first time humans left the earth’s orbit and traveled to another celestial body.
  prefs: []
  type: TYPE_NORMAL
- en: '*NASA Voyager 1 & 2 Owner’s Workshop Manual* (Haynes, 2015), by Christopher
    Riley, Richard Corfield, and Philip Dolling, provides interesting background on
    the three-body problem and Michael Minovitch’s many contributions to space travel.'
  prefs: []
  type: TYPE_NORMAL
- en: The Wikipedia *Gravity assist* page contains lots of interesting animations
    of various gravity-assist maneuvers and historic planetary flybys that you can
    reproduce with your Apollo 8 simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chasing New Horizons: Inside the Epic First Mission to Pluto* (Picador, 2018),
    by Alan Stern and David Grinspoon, documents the importance—and ubiquity—of simulations
    in NASA missions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Simulating a Search Pattern**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), you used Bayes’ rule to help the Coast Guard search
    for a sailor lost at sea. Now, use turtle to design a helicopter search pattern
    to find the missing sailor. Assume the spotters can see for 20 pixels and make
    the spacing between long tracks 40 pixels (see [Figure 6-16](ch06.xhtml#ch06fig16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-16: Two screenshots from practice_search_pattern.py'
  prefs: []
  type: TYPE_NORMAL
- en: For fun, add a helicopter turtle and orient it properly for each pass. Also
    add a randomly positioned sailor turtle, stop the simulation when the sailor is
    found, and post the joyous news to the screen ([Figure 6-17](ch06.xhtml#ch06fig17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-17: The sailor is spotted in practice_search_pattern.py.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_search_pattern.py*, in the appendix. I’ve
    included a digital version, along with helicopter and sailor images, in the *Chapter_6*
    folder, downloadable from the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Start Me Up!**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that a moving moon approaches a stationary
    CSM, causes the CSM to start moving, and then swings it up and away. For fun,
    orient the CSM turtle so that it always points in the direction of travel, as
    if under its own propulsion (see [Figure 6-18](ch06.xhtml#ch06fig18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-18: The moon approaches a stationary CSM (left) and then flings it
    to the stars (right).'
  prefs: []
  type: TYPE_NORMAL
- en: For a solution, see *practice_grav_assist_stationary.py* in the appendix or
    download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Shut Me Down!**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that the CSM and moon have crossing orbits,
    the CSM passes before the moon, and the moon’s gravity slows the CSM’s progress
    to a crawl while changing its direction by about 90 degrees. As in the previous
    practice project, have the CSM point in the direction of travel (see [Figure 6-19](ch06.xhtml#ch06fig19)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-19: The moon and CSM cross orbits, and the moon slows and turns the
    CSM.'
  prefs: []
  type: TYPE_NORMAL
- en: For a solution, see *practice_grav_assist_intersecting.py* in the appendix or
    download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: True-Scale Simulation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that the earth, the moon, and the distance
    between them are all accurately scaled, as shown in [Figure 6-10](ch06.xhtml#ch06fig10).
    Use colored circles, rather than images, for the earth and the moon and make the
    CSM invisible (just draw a line behind it). Use [Table 6-2](ch06.xhtml#ch06table2)
    to help determine the relative sizes and distances to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** Length Parameters for the Earth-Moon System'
  prefs: []
  type: TYPE_NORMAL
- en: '| Earth radius | 6,371 km |'
  prefs: []
  type: TYPE_TB
- en: '| Moon radius | 1,737 km |'
  prefs: []
  type: TYPE_TB
- en: '| Earth-moon distance | 356,700 km* |'
  prefs: []
  type: TYPE_TB
- en: '*Closest approach during Apollo 8 mission in December 1968'
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: The Real Apollo 8**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that it simulates the entire Apollo 8 mission,
    not just the free return component. The CSM should orbit the moon 10 times before
    returning to the earth.
  prefs: []
  type: TYPE_NORMAL
