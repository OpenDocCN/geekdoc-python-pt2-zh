- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: WINNING THE MOON RACE WITH APOLLO 8
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗 8 号赢得月球竞赛
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the summer of 1968, America was losing the space race. The Soviet Zond spacecraft
    appeared moon-ready, the Central Intelligence Agency had photographed a giant
    Soviet N-1 rocket sitting on its launch pad, and the Americans’ troubled Apollo
    program still needed three more test flights. But in August, NASA manager George
    Low had an audacious idea. Let’s go to the moon *now*. Instead of more tests in
    the earth’s orbit, let’s circle the moon in December and let *that* be the test.
    In that moment, the space race was essentially over. Less than a year later, the
    Soviets had capitulated, and Neil Armstrong had taken his great leap for all mankind.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年夏，美国在太空竞赛中处于下风。苏联的“宗德”号飞船看起来已经准备好登月，中央情报局拍摄到了停在发射台上的巨型苏联 N-1 火箭，而美国的阿波罗计划仍然需要三次测试飞行。但在8月，NASA经理乔治·洛提出了一个大胆的想法。我们*现在*就去月球吧！与其在地球轨道上做更多测试，不如让我们在12月绕月飞行，让*那*成为测试。就在那一刻，太空竞赛几乎已经结束。不到一年后，苏联投降了，尼尔·阿姆斯特朗为全人类迈出了伟大的一步。
- en: The decision to take the Apollo 8 spacecraft to the moon was hardly trivial.
    In 1967, three men had died in the Apollo 1 capsule, and multiple unmanned missions
    had blown up or otherwise failed. Against this backdrop and with so much at stake,
    everything hinged on the concept of the *free return*. The mission was designed
    so that if the service module engine failed to fire, the ship would simply swing
    around the moon and return to the earth like a boomerang ([Figure 6-1](ch06.xhtml#ch06fig1)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将阿波罗 8 号宇宙飞船送上月球的决定绝非轻松之举。1967年，三名宇航员在阿波罗 1 号舱内遇难，多次无人驾驶任务爆炸或以其他方式失败。在这种背景下，且事关重大，一切都取决于*自由返回*的概念。任务的设计是，如果服务舱的引擎未能点燃，飞船将直接绕月飞行，然后像回旋镖一样返回地球（[图
    6-1](ch06.xhtml#ch06fig1)）。
- en: '![Image](../images/fig06_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_01.jpg)'
- en: 'Figure 6-1: The Apollo 8 insignia, with the circumlunar free return trajectory
    serving as the mission number'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：阿波罗 8 号徽标，其中绕月自由返回轨道作为任务编号
- en: 'In this chapter, you’ll write a Python program that uses a drawing board module
    called turtle to simulate Apollo 8’s free return trajectory. You’ll also work
    with one of the classic conundrums in physics: the three-body problem.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将编写一个使用名为 turtle 的绘图板模块的 Python 程序，用来模拟阿波罗 8 号的自由返回轨道。你还将研究物理学中的一个经典难题：三体问题。
- en: '**Understanding the Apollo 8 Mission**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解阿波罗 8 号任务**'
- en: The goal of the Apollo 8 mission was merely to circle the moon, so there was
    no need to take a lunar lander component. The astronauts traveled in the command
    and service modules, collectively known as the *CSM* ([Figure 6-2](ch06.xhtml#ch06fig2)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗 8 号任务的目标仅仅是绕月飞行，因此不需要携带月球着陆舱组件。宇航员们乘坐的是指令舱和服务舱，统称为*CSM*（[图 6-2](ch06.xhtml#ch06fig2)）。
- en: '![Image](../images/fig06_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_02.jpg)'
- en: 'Figure 6-2: Apollo command and service modules'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：阿波罗指令舱与服务舱模块
- en: In the fall of 1968, the CSM engine had been tested in the earth’s orbit only,
    and there were legitimate concerns about its reliability. To orbit the moon, the
    engine would have to fire twice, once to slow the spacecraft to enter lunar orbit
    and then again to leave orbit. With the free return trajectory, if the first maneuver
    failed, the astronauts could still coast home. As it turned out, the engine fired
    perfectly both times, and Apollo 8 orbited the moon 10 times. (The ill-fated Apollo
    13, however, made great use of its free return trajectory!)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年秋，CSM 引擎仅在地球轨道上进行了测试，且存在关于其可靠性的正当担忧。为了绕月飞行，引擎需要两次点火：第一次是减速以进入月球轨道，第二次是离开轨道。使用自由返回轨道时，如果第一次操作失败，宇航员仍然可以滑行返回地球。事实证明，引擎两次点火都非常成功，阿波罗
    8 号绕月飞行了 10 次。（然而，命运多舛的阿波罗 13 号则充分利用了其自由返回轨道！）
- en: '***The Free Return Trajectory***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自由返回轨道***'
- en: Plotting a free return trajectory requires a lot of intense mathematics. It
    *is* rocket science, after all! Fortunately, you can simulate the trajectory in
    a two-dimensional graph with a few simplified parameters ([Figure 6-3](ch06.xhtml#ch06fig3)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制自由返回轨道需要大量复杂的数学运算。毕竟，这*就是*火箭科学！幸运的是，你可以用几个简化的参数在二维图表中模拟该轨道（[图 6-3](ch06.xhtml#ch06fig3)）。
- en: '![Image](../images/fig06_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_03.jpg)'
- en: 'Figure 6-3: The free return trajectory (not to scale)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：自由返回轨道（非比例图）
- en: 'This 2D simulation of the free return uses a few key values: the starting position
    of the CSM (R[0]), the velocity and orientation of the CSM (V[0]), and the phase
    angle between the CSM and the moon (γ[0]). The *phase angle*, also called the
    *lead angle*, is the change in the orbital time position of the CSM required to
    get from a starting position to a final position. The *translunar injection velocity*
    (V[0]) is a propulsive maneuver used to set the CSM on a trajectory to the moon.
    It’s achieved from a *parking orbit* around the earth, where the spacecraft performs
    internal checks and waits until the phase angle with the moon is optimal. At this
    point, the third stage of the *Saturn V* rocket fires and falls away, leaving
    the CSM to coast to the moon.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自由返回的二维模拟使用了几个关键值：指令舱的起始位置（R[0]）、指令舱的速度和方向（V[0]）以及指令舱和月球之间的相位角（γ[0]）。*相位角*，也叫做*领先角度*，是从起始位置到最终位置所需的指令舱轨道时间位置的变化。*跨月注入速度*（V[0]）是一种推进操作，用来将指令舱设置为月球轨迹。它通过从绕地轨道（*停车轨道*）中实现，航天器在此轨道上进行内部检查，并等待与月球的相位角达到最优。这时，*土星五号*火箭的第三级发动机会点燃并脱落，指令舱则继续滑行向月球。
- en: 'Because the moon is moving, before you perform the translunar injection, you
    have to predict its future position, or *lead* it, like when you’re shooting skeet
    with a shotgun. This requires knowing the phase angle (γ[0]) at the time of translunar
    injection. Leading the moon is a little different from shooting a shotgun, however,
    as space is curved and you need to factor in the gravity of the earth and the
    moon. The tug of these two bodies on the spacecraft creates perturbations that
    are difficult to calculate—so difficult, in fact, that the calculation has earned
    its own special name in the field of physics: the three-body problem.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于月球在移动，在执行跨月注入之前，你必须预测月球的未来位置，或者*领先*它，就像用霰弹枪打飞碟一样。然而，这个过程与射击霰弹枪略有不同，因为太空是弯曲的，你需要考虑地球和月球的引力。这两个天体对航天器的拉力会产生难以计算的扰动——这些扰动甚至难度之大，以至于这个计算问题在物理学领域有了一个专门的名字：三体问题。
- en: '***The Three-Body Problem***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***三体问题***'
- en: The *three-body problem* is the challenge of predicting the behavior of three
    interacting bodies. Isaac Newton’s gravity equations work great for predicting
    the behavior of two orbiting bodies, such as the earth and the moon, but add one
    more body to the mix, whether a spacecraft, comet, moon, or so on, and things
    get complicated. Newton was never able to encapsulate the behavior of three or
    more bodies into a simple equation. For 275 years— even with kings offering prizes
    for a solution—the world’s greatest mathematicians worked the problem in vain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*三体问题*是预测三个相互作用的天体行为的挑战。艾萨克·牛顿的引力方程在预测两个天体（如地球和月球）之间的行为时非常有效，但如果再加上第三个天体，无论是航天器、彗星、月亮等，问题就变得复杂。牛顿从未能够将三体或更多天体的行为归纳成一个简单的方程式。275年来——即便有国王提供奖金奖励解决方案——世界上最伟大的数学家们也一直未能解开这个问题。'
- en: The issue is that the three-body problem can’t be solved using simple algebraic
    expressions or integrals. Calculating the impact of multiple gravitational fields
    requires numerical iteration on a scale that’s impractical without a high-speed
    computer, such as your laptop.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，三体问题不能通过简单的代数表达式或积分来解决。计算多个引力场的影响需要进行数值迭代，这样的计算规模没有高速计算机（如你的笔记本电脑）是无法实现的。
- en: In 1961, Michael Minovitch, a summer intern at the Jet Propulsion Laboratory,
    found the first numerical solution using an IBM 7090 mainframe, at the time the
    fastest computer in the world. He discovered that mathematicians could reduce
    the number of computations needed to solve a restricted three-body problem, like
    our earth-moon-CSM problem, by using a patched conic method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1961年，迈克尔·米诺维奇（Michael Minovitch），当时是喷气推进实验室的暑期实习生，使用当时世界上最快的计算机——IBM 7090主机，找到了第一个数值解。他发现，数学家可以通过使用修正圆锥法，减少解决一个限制性三体问题（如我们地球-月球-指令舱问题）所需的计算量。
- en: The *patched conic method* is an analytical approximation that assumes you’re
    working with a simple two-body problem while the spacecraft is in the earth’s
    gravitational sphere of influence and another when you’re within the moon’s sphere
    of influence. It’s a rough, “back-of-the-envelope” calculation that provides reasonable
    estimates of departure and arrival conditions, reducing the number of choices
    for initial velocity and position vectors. All that’s left is to refine the flight
    path with repeated computer simulations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Because researchers have already found and documented the Apollo 8 mission’s
    patched conic solution, you won’t need to calculate it. I’ve already adapted it
    to the 2D scenario you’ll be doing here. You can experiment with alternative solutions
    later, however, by varying parameters such as R[0] and V[0] and rerunning the
    simulation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #9: To the Moon with Apollo 8!**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a summer intern at NASA, you’ve been asked to create a simple simulation
    of the Apollo 8 free return trajectory for consumption by the press and general
    public. As NASA is always strapped for cash, you’ll need to use open source software
    and complete the project quickly and cheaply.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that graphically simulates the free return trajectory
    proposed for the Apollo 8 mission.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the turtle Module***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To simulate the flight of Apollo 8, you’ll need a way to draw and move images
    on the screen. There are a lot of third-party modules that can help you do this,
    but we’ll keep things simple by using the preinstalled turtle module. Although
    originally invented to help kids learn programming, turtle can easily be adapted
    to more sophisticated uses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module lets you use Python commands to move a small image, called
    a *turtle*, around a screen. The image can be invisible, an actual image, a custom
    shape, or one of the predefined shapes shown in [Figure 6-4](ch06.xhtml#ch06fig4).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Standard turtle shapes provided with the turtle module'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: As the turtle moves, you can choose to draw a line behind it to trace its movement
    ([Figure 6-5](ch06.xhtml#ch06fig5)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_05.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Moving the turtle around the Turtle Graphics window'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple drawing was made with the following script:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use Python functionality with turtle to write more concise code. For
    example, you can use a for loop to create the same pattern.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, steve moves forward 50 pixels and then turns to the left at a right angle.
    These steps are repeated three times by the for loop.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Other turtle methods let you change the shape of the turtle, change its color,
    lift the pen so no path is drawn, “stamp” its current position on the screen,
    set the heading of the turtle, and get its position on the screen. [Figure 6-6](ch06.xhtml#ch06fig6)
    shows this functionality, which is described in the script that follows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: More examples of turtle behaviors. Numbers refer to script annotations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After importing the turtle module and instantiating a turtle object named steve,
    leave behind an image of steve using the stamp() method ➊. Then use the position()
    method ➋ to get the turtle’s current (*x*, *y*) coordinates as a tuple ➌. This
    will come in handy when calculating the distance between objects for the gravity
    equation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Move the turtle forward 150 spaces and change its color to gray ➍. Then leave
    a stamp behind, rotate the turtle 45 degrees, and move it backward 75 spaces using
    the bk() (backward) method ➎.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Leave another stamp and then stop drawing the turtle’s path by using the penup()
    method ➏. Move steve backward another 75 spaces and color him black. Now use an
    alternative to rotate(), which is to directly set the heading of the turtle ➐.
    The heading is simply the direction the turtle is traveling. Note that the default
    “standard mode” directions are referenced to the east, not the north ([Table 6-1](ch06.xhtml#ch06table1)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Common Directions in Degrees for the turtle Module in Standard
    Mode'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '| Degrees | Direction |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| 0 | East |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| 90 | North |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| 180 | West |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| 270 | South |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: Leave another stamp and then put the pen down to once more draw a path behind
    the turtle ➑. Move steve forward 50 spaces and then change his shape to a triangle
    ➒. That completes the drawing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be fooled by the simplicity of what we’ve done so far. With the right
    commands, you can draw intricate designs, such as the Penrose tiling in [Figure
    6-7](ch06.xhtml#ch06fig7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: A Penrose tiling produced by the turtle module demo, penrose.py'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module is part of the Python Standard Library, and you can find the
    official documentation at *[https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/](https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/)*.
    For a quick tutorial, do an online search for Al Sweigart’s *Simple Turtle Tutorial
    for Python*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve now made a strategic decision to use turtle to draw the simulation, but
    how should the simulation look? For convenience, I’d suggest basing it on [Figure
    6-3](ch06.xhtml#ch06fig3). You’ll start with the CSM in the same parking orbit
    position around the earth (R[0]) and the moon at the same approximate phase angle
    (γ[0]). You can use images to represent the earth and the moon and custom turtle
    shapes to build the CSM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Another big decision at this point is whether to use procedural or object-oriented
    programming (OOP). When you plan to generate multiple objects that behave similarly
    and interact with each other, OOP is a good choice. You can use an OOP class as
    a blueprint for the earth, the moon, and the CSM objects and automatically update
    the object attributes as the simulation runs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: You can run the simulation using *time steps*. Basically, each program loop
    will represent one unit of dimensionless time. With each loop, you’ll need to
    calculate each object’s position and update (redraw) it on the screen. This requires
    solving the three-body problem. Fortunately, not only has someone done this already,
    they’ve done it using turtle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Python modules often include example scripts to show you how to use the product.
    For instance, the matplotlib gallery includes code snippets and tutorials for
    making a huge number of charts and plots. Likewise, the turtle module comes with
    *turtle-example-suite*, which includes demonstrations of turtle applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: One of the demos, *planet_and_moon.py*, provides a nice “recipe” for handling
    a three-body problem in turtle ([Figure 6-8](ch06.xhtml#ch06fig8)). To see the
    demos, open a PowerShell or terminal window and enter python –m turtledemo. Depending
    on your platform and how many versions of Python you have installed, you may need
    to use python3 -m turtledemo.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-8: Screen capture of the planet_and_moon.py turtle demo'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This demo addresses the sun-earth-moon three-body problem, but it can be easily
    adapted to handle an earth-moon-CSM problem. Again, for the specific Apollo 8
    situation, you’ll use [Figure 6-3](ch06.xhtml#ch06fig3) to guide development of
    the program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '***The Apollo 8 Free Return Code***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *apollo_8_free_return.py* program uses turtle graphics to generate a top-down
    view of the Apollo 8 CSM leaving the earth’s orbit, circling the moon, and returning
    to the earth. The core of the program is based on the *planet_and_moon.py* demo
    discussed in the previous section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: You can find the program in the *Chapter_6* folder, downloadable from the book’s
    website at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
    You’ll also need the earth and moon images found there ([Figure 6-9](ch06.xhtml#ch06fig9)).
    Be sure to keep them in the same folder as the code and don’t rename them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: earth_100x100.gif and moon_27x27.gif images used in the simulation'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing turtle and Assigning Constants**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-1](ch06.xhtml#ch06list1) imports the turtle module and assigns constants
    that represent key parameters: the gravitational constant, the number of times
    to run the main loop, and the *x* and *y* values for R[0] and V[0] (see [Figure
    6-3](ch06.xhtml#ch06fig3)). Listing these values near the top of the program makes
    them easy to find and alter later.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-1: Importing turtle and assigning constants'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to import four helper classes from turtle. You’ll use the Shape
    class to make a custom turtle that looks like the CSM. The Screen subclass makes
    the screen, called a *drawing board* in turtle parlance. The Turtle subclass creates
    the turtle objects. The Vec2D import is a two-dimensional vector class. It will
    help you define velocity as a vector of magnitude and direction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign some variables that the user may want to tweak later. Start with
    the gravitational constant, used in Newton’s gravity equations to ensure the units
    come out right. Assign it 8, the value used in the turtle demo. Think of this
    as a *scaled* gravitational constant. You can’t use the true constant, as the
    simulation doesn’t use real-world units.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配一些变量，用户以后可能希望调整它们。首先是引力常数，它用于牛顿引力方程中，以确保单位的正确性。将其设置为 8，这是 turtle 演示中使用的值。可以将其视为一个
    *缩放过* 的引力常数。你不能使用真实的常数，因为模拟并不使用现实世界的单位。
- en: You’ll run the simulation in a loop, and each iteration will represent a time
    step. With each step, the program will recalculate the position of the CSM as
    it moves through the gravity fields of the earth and the moon. The value of 4100,
    arrived at by trial and error, will stop the simulation just after the spacecraft
    arrives back on the earth.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在一个循环中运行模拟，每次迭代代表一个时间步长。每个步骤，程序都会重新计算 CSM 的位置，随着它穿越地球和月球的引力场。通过反复试验得出的 4100
    的值，将在宇宙飞船返回地球后停止模拟。
- en: In 1968, a round-trip to the moon took about six days. Since you’re incrementing
    the time unit by 0.001 with each loop and running 4,100 loops, this means a time
    step in the simulation represents about two minutes of time in the real world.
    The longer the time step, the faster the simulation but the less accurate the
    results, as small errors compound over time. In actual fight path simulations,
    you can optimize the time step by first running a small step, for maximum accuracy,
    and then using the results to find the largest time step that yields a similar
    result.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 1968 年，往返月球大约需要六天。由于你每次循环增加 0.001 的时间单位，并运行 4,100 次循环，这意味着模拟中的一个时间步长大约代表现实世界中的两分钟。时间步长越长，模拟运行得越快，但结果的准确性越差，因为小错误会随着时间的推移积累。在实际的飞行路径模拟中，你可以通过先运行一个小的时间步长（以获得最大的准确性），然后使用结果来找到一个能产生相似结果的最大时间步长，从而优化时间步长。
- en: The next two variables, Ro_X and Ro_Y, represent the (*x*, *y*) coordinates
    of the CSM at the time of the translunar injection (see [Figure 6-3](ch06.xhtml#ch06fig3)).
    Likewise, Vo_X and Vo_Y represent the *x*- and *y*-direction components of the
    translunar injection velocity, which is applied by the third stage of the *Saturn
    V* rocket. These values started out as best guesses and were refined with repeated
    simulations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个变量 Ro_X 和 Ro_Y 表示 CSM 在月球转移注入（translunar injection）时的（*x*，*y*）坐标（见[图 6-3](ch06.xhtml#ch06fig3)）。同样，Vo_X
    和 Vo_Y 表示月球转移注入速度的 *x* 和 *y* 分量，这个速度由土星五号火箭的第三阶段提供。这些值最初是通过猜测得出的，然后通过反复模拟进行优化。
- en: '**Creating a Gravity System**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建引力系统**'
- en: Because the earth, the moon, and CSM form a continuously interacting gravity
    system, you’ll want a convenient way to represent them and their respective forces.
    For this, you’ll need two classes, one to create a gravity system and one to create
    the bodies within it. [Listing 6-2](ch06.xhtml#ch06list2) defines the GravSys
    class that helps you create a mini solar system. This class will use a list to
    keep track of all the bodies in motion and loop them through a series of time
    steps. It’s based on the *planet_and_moon.py* demo in the turtle library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地球、月球和 CSM 形成了一个持续互动的引力系统，你需要一种方便的方式来表示它们及其相应的力。为此，你需要两个类，一个用于创建引力系统，另一个用于创建其中的天体。[清单
    6-2](ch06.xhtml#ch06list2)定义了 GravSys 类，帮助你创建一个迷你太阳系。这个类将使用一个列表来跟踪所有在运动中的天体，并将它们通过一系列时间步长循环。它基于
    turtle 库中的 *planet_and_moon.py* 演示。
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-2: Defining a class to manage the bodies in the gravity system'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：定义一个类来管理引力系统中的天体
- en: The GravSys class defines how long the simulation will run, how much time will
    pass between time steps (loops), and what bodies will be involved. It also calls
    the step() method of the Body class you’ll define in [Listing 6-3](ch06.xhtml#ch06list3).
    This method will update each body’s position as a result of gravitational acceleration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GravSys 类定义了模拟运行的时间、时间步长（循环之间的时间间隔）以及参与的天体。它还调用了你将在[清单 6-3](ch06.xhtml#ch06list3)中定义的
    Body 类的 step() 方法。这个方法将根据引力加速度更新每个天体的位置。
- en: Define the initialization method and, as per convention, pass it self as a parameter.
    The self parameter represents the GravSys object you’ll create later in the main()
    function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 定义初始化方法，并按照惯例将 self 作为参数传递。self 参数表示你将在 main() 函数中创建的 GravSys 对象。
- en: Create an empty list named bodies to hold the earth, the moon, and the CSM objects.
    Then assign attributes for when the simulation starts and the amount to increment
    time with each loop, known as *delta time* or dt. Set the starting time to 0 and
    set the dt time step to 0.001. As discussed in the previous section, this time
    step will correspond to about two minutes in the real world and will produce a
    smooth, accurate, and fast simulation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The last method controls the time steps in the simulation ➊. It uses a for loop
    with the range set to the NUM_LOOPS variable. Use a single underscore (_) rather
    than i to indicate the use of an insignificant variable (see [Listing 5-3](ch05.xhtml#ch05list3)
    in [Chapter 5](ch05.xhtml) for details).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: With each loop, increment the gravity system’s time variable by dt. Then, apply
    the time shift to each body by looping through the list of bodies and calling
    the body.step() method, which you’ll define later within the Body class. This
    method updates the position and velocity of the bodies due to gravitational attraction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Celestial Bodies**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-3](ch06.xhtml#ch06list3) defines the Body class used to build the
    earth, the moon, and the CSM Body objects. Although no one would ever mistake
    a planet for a small spacecraft, they’re not that different from a gravitational
    standpoint, and you can stamp them both out of the same mold.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-3: Defining a class to create objects for the earth, the moon, and
    the CSM'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Define a new class by using the Turtle class as its *ancestor*. This means the
    Body class will conveniently inherit all the Turtle class’s methods and attributes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Next, define an initializer method for the body object. You’ll use this to create
    new Body objects in the simulation, a process called *instantiation* in OOP. As
    parameters, the initialize method takes itself, a mass attribute, a starting location,
    a starting velocity, the gravity system object, and a shape.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The super() function lets you invoke the method of a superclass to gain access
    to inherited methods from the ancestor class. This allows your Body objects to
    use attributes from the prebuilt Turtle class. Pass it the shape attribute, which
    will allow you to pass a custom shape or image to your bodies when you build them
    in the main() function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign an instance attribute for the gravsys object. This will allow the
    gravity system and body to interact. Note that it’s best to initialize attributes
    through the __init__() method, as we do in this case, since it’s the first method
    called after the object is created. This way, these attributes will be immediately
    available to any other methods in the class, and other developers can see a list
    of all the attributes in one place.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The following penup() method of the Turtle class will remove the drawing pen
    so the object doesn’t leave a path behind it as it moves. This gives you the option
    of running the simulation with and without visible orbital paths.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a mass attribute for the body. You’ll need this to calculate the
    force of gravity. Next, assign the body’s starting position using the setpos()
    method of the Turtle class. The starting position of each body will be an (*x*,
    *y*) tuple. The origin point (0, 0) will be at the center of the screen. The *x*-coordinate
    increases to the right, and the *y*-coordinate increases upward.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为物体初始化一个质量属性。你需要这个属性来计算重力。接下来，使用Turtle类的setpos()方法为物体分配起始位置。每个物体的起始位置将是一个(*x*,
    *y*)元组。原点(0, 0)将在屏幕中央，*x*坐标向右增加，*y*坐标向上增加。
- en: Assign an initialization attribute for velocity. This will hold the starting
    velocity for each object. For the CSM, this value will change throughout the simulation
    as the ship moves through the gravity fields of the earth and the moon.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为速度分配一个初始化属性。它将保存每个物体的起始速度。对于CSM，这个值将在模拟过程中随着飞船穿越地球和月球的引力场而变化。
- en: As each body is instantiated, use dot notation to append it to the list of bodies
    in the gravity system. You’ll create the gravsys object from the GravSys() class
    in the main() function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个物体实例化时，使用点符号将其附加到重力系统中的物体列表中。你将在main()函数中从GravSys()类创建gravsys对象。
- en: The final two lines, commented out, allow the user to change the simulation
    window size and choose to draw a path behind each object. Start out with a full-screen
    display and keep the pen in the up position to let the simulation run quickly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两行，已注释掉，允许用户更改模拟窗口的大小，并选择在每个物体后面绘制路径。先从全屏显示开始，并保持笔的位置在上方，以便快速运行模拟。
- en: '**Calculating Acceleration Due to Gravity**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算重力加速度**'
- en: The Apollo 8 simulation will begin immediately after the translunar injection.
    At this point, the third stage of the *Saturn V* has fired and fallen away, and
    the CSM is beginning its coast to the moon. All changes in velocity or direction
    will be entirely due to changes in gravitational force.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗8号模拟将在月际注入后立即开始。此时，*土星V*的第三级已经点燃并脱落，CSM开始向月球行进。所有的速度或方向变化将完全由于重力变化。
- en: The method in [Listing 6-4](ch06.xhtml#ch06list4) loops through the bodies in
    the bodies list, calculates acceleration due to gravity for each body, and returns
    a vector representing the body’s acceleration in the *x* and *y* directions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-4](ch06.xhtml#ch06list4)中的方法遍历物体列表中的物体，计算每个物体的重力加速度，并返回一个表示物体在*x*和*y*方向上的加速度的向量。'
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-4: Calculating acceleration due to gravity'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-4：计算重力加速度
- en: 'Still within the Body class, define the acceleration method, called acc(),
    and pass it self. Within the method, name a local variable a, again for acceleration,
    and assign it to a vector tuple using the Vec2D helper class. A 2D vector is a
    pair of real numbers (*a*, *b*), which in this case represent *x* and *y* components,
    respectively. The Vec2D helper class enforces rules that permit easy mathematical
    operations using vectors, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在Body类内，定义加速度方法，命名为acc()，并传入self。在方法内，定义一个局部变量a，再次代表加速度，并将其赋值为一个使用Vec2D辅助类的向量元组。2D向量是一个由实数（*a*,
    *b*）组成的对，这里分别表示*x*和*y*分量。Vec2D辅助类强制执行规则，允许使用向量进行简便的数学运算，如下所示：
- en: (*a*, *b*) + (*c*, *d*) = (*a* + *c*, *b* + *d*)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*a*, *b*) + (*c*, *d*) = (*a* + *c*, *b* + *d*)
- en: (*a*, *b*) – (*c*, *d*) = (*a* – *c*, *b* – *d*)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*a*, *b*) – (*c*, *d*) = (*a* – *c*, *b* – *d*)
- en: (*a*, *b*) × (*c*, *d*) = *ac* + *bd*
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*a*, *b*) × (*c*, *d*) = *ac* + *bd*
- en: Next, start looping through the items in the bodies list, which contains the
    earth, the moon, and the CSM. You’ll use the gravitational force of each body
    to determine the acceleration of the object for which you’re calling the acc()
    method. It doesn’t make sense for a body to accelerate itself, so exclude the
    body if it’s the same as self.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开始遍历物体列表中的项，该列表包含地球、月球和指令服务舱（CSM）。你将使用每个物体的重力来确定你正在调用acc()方法的物体的加速度。物体不应自我加速，因此如果物体与自身相同，则排除它。
- en: 'To calculate gravitational acceleration (stored in the g variable) at a point
    in space, you’ll use the following formula:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算空间中某一点的重力加速度（存储在g变量中），你需要使用以下公式：
- en: '![Image](../images/equ_page_136_01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_136_01.jpg)'
- en: 'where *M* is the mass of the attracting body, *r* is the distance (radius)
    between bodies, *G* is the gravitational constant you defined earlier, and *r*
    is the unit vector from the center of mass of the attracting body to the center
    of mass of the body being accelerated. The *unit vector*, also known as the *direction
    vector* or *normalized vector*, can be described as *r/|r|*, or:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_136_02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: The unit vector allows you to capture the direction of acceleration, which will
    be either positive or negative. To calculate the unit vector, you’ll have to calculate
    the distance between bodies by using the turtle pos() method to get each body’s
    current position as a Vec2D vector. As described previously, this is a tuple of
    the (*x*, *y*) coordinates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: You’ll then input that tuple into the acceleration equation. Each time you loop
    through a new body, you’ll change the a variable based on the gravitational pull
    of the body being examined. For example, while the earth’s gravity may slow the
    CSM, the moon’s gravity may pull in the opposite direction and cause it to speed
    up. The a variable will capture the net effect at the end of the loop. Complete
    the method by returning a.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Stepping Through the Simulation**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-5](ch06.xhtml#ch06list5), still in the Body class, defines a method
    to solve the three-body problem. It updates the position, orientation, and velocity
    of bodies in the gravity system with each time step. The shorter the time steps,
    the more accurate the solution, though at the cost of computational efficiency.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-5: Applying the time step and rotating the CSM'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Define a step() method to calculate position, orientation, and velocity of a
    body. Assign it self as an argument.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Within the method definition, set a local variable, dt, to the gravsys object
    of the same name. This variable has no link to any real-time system; it’s just
    a floating-point number that you’ll use to increment velocity with each time step.
    The larger the dt variable is, the faster the simulation will run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Now call the self.acc() method to calculate the acceleration that the current
    body experiences due to the combined gravitational fields of the other bodies.
    This method returns a vector tuple of (*x*, *y*) coordinates. Multiply it by dt
    and add the results to self.vel(), which is also a vector, to update the body’s
    velocity for the current time step. Recall that, behind the scenes, the Vec2D
    class will manage the vector arithmetic.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To update the body’s position in the turtle graphics window, multiply the body’s
    velocity by the time step and add the result to the body’s position attribute.
    Now each body will move according to the gravitational pull of the other bodies.
    You just solved the three-body problem!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Next, add some code to refine the CSM’s behavior. Thrust comes out of the back
    of the CSM, so in real missions, the rear of the spacecraft is oriented toward
    its target. This way, the engine can fire and slow the ship enough to enter lunar
    orbit or the earth’s atmosphere. Orienting the ship this way isn’t necessary with
    a free return trajectory, but since Apollo 8 planned to fire its engines and enter
    lunar orbit (and did), you should orient the ship properly throughout its journey.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Start by selecting the CSM from the list of bodies ➊. In the main() function,
    you’ll create the bodies in order of size, so the CSM will be the third item in
    the list, at index 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To get the CSM to rotate as it coasts through space, assign a small number to
    a local variable named rotate_factor. I arrived at this number through trial and
    error. Next, set the heading of the CSM turtle object using its selfheading attribute.
    Instead of passing it (*x*, *y*) coordinates, call the self.heading() method,
    which returns the object’s current heading in degrees, and subtract from it the
    rotate_factor variable multiplied by the body’s current *x* location, obtained
    by calling the self.xcor() method. This will cause the CSM to rotate faster as
    it approaches the moon to keep its tail pointed in the direction of travel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to eject the service module before the spacecraft enters the earth’s
    atmosphere. To do this at a position similar to that in real Apollo missions,
    use another conditional to check the spacecraft’s *x*-coordinate ➋. The simulation
    expects the earth to be near the center of the screen, at coordinates (0, 0).
    In turtle, the *x*-coordinate will decrease as you move left of the center and
    increase as you move to the right. If the CSM’s *x*-coordinate is less than –20
    pixels, you can assume that it’s returning home and that it’s time to part company
    with the service module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: You’ll model this event by changing the shape of the turtle representing the
    CSM. Since turtle includes a standard shape—called arrow—that looks similar to
    the command module, all you need to do now is call the self.shape() method and
    pass it the name of the shape. Then call the self.shapesize() method and halve
    the size of the arrow to make it match the command module in the CSM custom shape,
    which you’ll make later. When the CSM passes the –20 *x*-position, the service
    module will magically disappear, leaving the command module to complete the voyage
    home.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll want to orient the base of the command module, with its heat-resistant
    shielding, toward the earth. Do this by setting the arrow shape’s heading to 105
    degrees.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining main(), Setting Up the Screen, and Instantiating the Gravity System**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You used object-oriented programming to build the gravity system and the bodies
    within it. To run the simulation, you’ll return to procedural programming and
    use a main() function. This function sets up the turtle graphics screen, instantiates
    objects for the gravity system and the three bodies, builds a custom shape for
    the CSM, and calls the gravity system’s sim_loop() method to walk through the
    time steps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-6](ch06.xhtml#ch06list6) defines main() and sets up the screen.
    It also creates a gravity system object to manage your mini solar system.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-6: Setting up the screen and making a gravsys object in main()'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Define main() and then instantiate a screen object (a drawing window) based
    on the TurtleScreen subclass. Then invoke the screen object’s setup() method to
    set the size of screen to full. Do this by passing width and height arguments
    of 1.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want the drawing window to take up the full screen, pass setup()
    the pixel arguments shown in the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that a negative startx value uses right justification, a negative starty
    uses bottom alignment, and the default settings create a centered window. Feel
    free to experiment with these parameters to get the best fit to your monitor.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Complete setting up the screen by setting its background color to black and
    giving it a title. Next, instantiate a gravity system object, gravsys, using the
    GravSys class. This object will give you access to the attributes and methods
    in the GravSys class. You’ll pass it to each body when you instantiate them shortly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Earth and Moon**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-7](ch06.xhtml#ch06list7), still in the main() function, creates
    turtle objects for the earth and the moon using the Body class you defined earlier.
    The earth will remain stationary at the center of the screen, while the moon will
    revolve around the earth.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When you create these objects, you’ll set their starting coordinates. The starting
    position of the earth is near the center of the screen, biased downward a bit
    to give the moon and CSM room to interact near the top of the window.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The starting position of the moon and CSM should reflect what you see in [Figure
    6-3](ch06.xhtml#ch06fig3), with the CSM vertically beneath the center of the earth.
    This way, you only need to thrust in the *x* direction, rather than calculate
    a vector component velocity that includes some movement in the *x* direction and
    some in the *y* direction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-7: Instantiating turtles for the earth and moon'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Start by assigning the image of the earth, which is included in the folder for
    this project, to a variable. Note that images should be *gif* files and cannot
    be rotated to show the turtle’s heading. So that turtle recognizes the new shape,
    add it to the TurtleScreen shapelist using the screen.register_shape() method.
    Pass it the variable that references the earth image.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to instantiate the turtle object for the earth. You call the Body
    class and pass it the arguments for mass, starting position, starting velocity,
    gravity system, and turtle shape—in this case, the image. Let’s talk about each
    of these arguments in more detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You’re not using real-world units here, so mass is an arbitrary number. I started
    with the value used for the sun in the turtle demo *planet_and_moon.py*, on which
    this program is based.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The starting position is an (*x*, *y*) tuple that places the earth near the
    center of the screen. It’s biased downward 25 pixels, however, as most of the
    action will take place in the upper quadrant of the screen. This placement will
    provide a little more room in that region.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The starting velocity is a simple (*x*, *y*) tuple provided as an argument to
    the Vec2D helper class. As discussed previously, this will allow later methods
    to alter the velocity attribute using vector arithmetic. Note that the earth’s
    velocity is not (0, 0), but (0, -2.5). In real life and in the simulation, the
    moon is massive enough to affect the earth so that the center of gravity between
    the two is not at the center of the earth, but farther out. This will cause the
    earth turtle to wobble and shift positions in a distracting manner during the
    simulation. Because the moon will be in the upper part of the screen during simulation,
    shifting the earth downward a small amount each time step will dampen the wobbling.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The last two arguments are the gravsys object you instantiated in the previous
    listing and the image variable for the earth. Passing gravsys means the earth
    turtle will be added to the list of bodies and included in the sim_loop() class
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you don’t want to use a lot of arguments when instantiating an
    object, you can change an object’s attributes after it’s created. For example,
    when defining the Body class, you could’ve set self.mass = 0, rather than using
    an argument for mass. Then, after instantiating the earth body, you could reset
    the mass value using earth.mass = 1000000.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Because the earth wobbles a little, its orbital path will form a tight circle
    at the top of the planet. To hide it in the polar cap, use the turtle pencolor()
    method and set the line color to white.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Finish the earth turtle with code that delays the start of the simulation and
    prevents the various turtles from flashing on the screen as the program first
    draws and resizes them. The getscreen() method returns the TurtleScreen object
    the turtle is drawing on. TurtleScreen methods can then be called for that object.
    In the same line, call the tracer() method that turns the turtle animation on
    or off and sets a delay for drawing updates. The *n* parameter determines the
    number of times the screen updates. A value of 0 means the screen updates with
    every loop; larger values progressively repress the updates. This can be used
    to accelerate the drawing of complex graphics, but at the cost of image quality.
    The second argument sets a delay value, in milliseconds, between screen updates.
    Increasing the delay slows the animation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: You’ll build the moon turtle in a similar fashion to the one for the earth.
    Start by assigning a new variable to hold the moon image ➊. The moon’s mass is
    only a few percent of the earth’s mass, so use a much smaller value for the moon.
    I started out with a mass of around 16,000 and tweaked the value until the CSM’s
    flight path produced a visually pleasing loop around the moon.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The moon’s starting position is controlled by the phase angle shown in [Figure
    6-3](ch06.xhtml#ch06fig3). Like this figure, the simulation you’re creating here
    is not to scale. Although the earth and moon images will have the correct relative
    sizes, the distance between the two is smaller than the actual distance, so the
    phase angle will need to be adjusted accordingly. I’ve reduced the distance in
    the model because space is big. Really big. If you want to show the simulation
    to scale and fit it all on your computer monitor, then you must settle for a ridiculously
    tiny earth and moon ([Figure 6-10](ch06.xhtml#ch06fig10)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: Earth and moon system at closest approach, or perigee, shown to
    scale'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: To keep the two bodies recognizable, you’ll instead use larger, properly scaled
    images but reduce the distance between them ([Figure 6-11](ch06.xhtml#ch06fig11)).
    This configuration will be more relatable to the viewer and still allow you to
    replicate the free return trajectory.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Because the earth and the moon are closer together in the simulation, the moon’s
    orbital velocity will be faster than in real life, as per Kepler’s second law
    of planetary motion. To compensate for this, the moon’s starting position is designed
    to reduce the phase angle compared to that shown in [Figure 6-3](ch06.xhtml#ch06fig3).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_11.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: The earth and moon system in the simulation, with only the body
    sizes at the correct scale'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll want the option to draw a line behind the moon to trace its
    orbit. Use the turtle pencolor() method and set the line color to gray.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters such as mass, initial position, and initial velocity are good candidates
    for global constants. Despite this, I chose to enter them as method arguments
    to avoid overloading the user with too many input variables at the start of the
    program.*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Custom Shape for the CSM**'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now it’s time to instantiate a turtle object to represent the CSM. This requires
    a little more work than the last two objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: First, there’s no way to show the CSM at the same scale as the earth and the
    moon. To do that, you’d need *less than* a pixel, which is impossible. Plus, where’s
    the fun in that? So, once again, you’ll take liberties with scale and make the
    CSM large enough to be recognizable as an Apollo spacecraft.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Second, you won’t use an image for the CSM, as you did with the other two bodies.
    Because image shapes don’t automatically rotate when a turtle turns and you want
    to orient the CSM tail-first through most of its journey, you must instead customize
    your own shape.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-8](ch06.xhtml#ch06list8), still in main(), builds a representation
    of the CSM by drawing basic shapes, such as rectangles and triangles. You then
    combine these individual primitives into a final compound shape.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-8: Building a custom shape for the CSM turtle'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Name a variable csm and call the turtle Shape class. Pass it 'compound', indicating
    you want to build the shape using multiple components.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The first component will be the command module. Name a variable cm and assign
    it to a tuple of coordinate pairs, known as a *polygon type* in turtle. These
    coordinates build a triangle, as shown in [Figure 6-12](ch06.xhtml#ch06fig12).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_12.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: CSM compound shape with coordinates for nozzle, service module,
    and command module'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Add this triangle component to the csm shape using the addcomponent() method,
    called with dot notation. Pass it the cm variable, a fill color, and an outline
    color. Good fill colors are white, silver, gray, or red.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this general process for the service module rectangle. Set the outline
    color to black when you add the component to delineate the service and command
    modules (see [Figure 6-12](ch06.xhtml#ch06fig12)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Use another triangle for the nozzle, also called the *engine bell*. Add the
    component and then register the new csm compound shape to the screen. Pass the
    method a name for the shape and then the variable referencing the shape.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the CSM, Starting the Simulation, and Calling main()**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch06list9) completes the main() function by instantiating
    a turtle for the CSM and calling the simulation loop that runs the time steps.
    It then calls main() if the program is run in stand-alone mode.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-9: Instantiating a CSM turtle, calling the simulation loop and main()'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Create a turtle named ship to represent the CSM. The starting position is an
    (*x*, *y*) tuple that places the CSM in a parking orbit directly below the earth
    on the screen. I first approximated the proper height for the parking orbit (R[0]
    in [Figure 6-3](ch06.xhtml#ch06fig3)) and then fine-tuned it by repeatedly running
    the simulation. Note that you use the constants assigned at the start of the program,
    rather than actual values. This is to make it easier for you to experiment with
    these values later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The velocity argument (Vo_X, Vo_Y) represents the speed of the CSM at the moment
    the Saturn third stage stops firing during translunar injection. All the thrust
    is in the *x* direction, but the earth’s gravity will cause the flight path to
    immediately curve upward. Like the R[0] parameter, a best-guess velocity was input
    and refined through simulation. Note that the velocity is a tuple input using
    the Vec2D helper class, which allows later methods to alter the velocity using
    vector arithmetic.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the size of the ship turtle using the shapesize() method. Then set
    its path color to white so it will match the ship color. Other attractive colors
    are silver, gray, and red.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Control the screen updates with the getscreen() and tracer() methods, described
    in [Listing 6-7](ch06.xhtml#ch06list7), and then set the ship’s heading to 90
    degrees, which will point it due east on the screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: That completes the body objects. Now all that’s left is to launch the simulation
    loop, using the gravsys object’s sim_loop() method. Back in the global space,
    finish the program with the code to run the program as an imported module or in
    stand-alone mode.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'As the program is currently written, you’ll have to manually close the Turtle
    Graphics window. If you want the window to close automatically, add the following
    command as the last line in main():'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***Running the Simulation***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you first run the simulation, the pen will be up, and none of the bodies
    will draw their orbital path ([Figure 6-13](ch06.xhtml#ch06fig13)). The CSM will
    smoothly rotate and reorient itself as it approaches the moon and then the earth.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_13.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: The simulation run with the pen up and the CSM approaching the
    moon'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To trace the journey of the CSM, go to the definition of the Body class and
    uncomment this line:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should now see the figure-eight shape of the free return trajectory ([Figure
    6-14](ch06.xhtml#ch06fig14)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_14.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: The simulation run with the pen down and the CM at splashdown
    in the Pacific'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: You can also simulate *gravity propulsion*—otherwise known as a *slingshot maneuver*—by
    setting the Vo_X velocity variable to a value between 520 and 540 and rerunning
    the simulation. This will cause the CSM to pass behind the moon and steal some
    of its momentum, increasing the ship’s velocity and deflecting its flight path
    ([Figure 6-15](ch06.xhtml#ch06fig15)). Bye-bye Apollo 8!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The gravitational slingshot maneuver achieved with Vo_X = 520'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This project should teach you that space travel is a game of seconds and centimeters.
    If you continue to experiment with value of the Vo_X variable, you’ll find that
    even small changes can doom the mission. If you don’t crash into the moon, you’ll
    reenter the earth’s atmosphere too steeply or miss it entirely!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about simulations is that, if you fail, you can live to try again.
    NASA runs countless simulations for all its proposed missions. The results help
    NASA choose between competing flight plans, find the most efficient routes, decide
    what to do if things go wrong, and much more.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Simulations are especially important for outer solar system exploration, where
    great distances make real-time communications impossible. The timing of key events,
    such as firing thrusters, taking photographs, or dropping probes, are all preprogrammed
    based on meticulous simulations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the turtle drawing program, including
    how to make customized turtle shapes. You also learned how to use Python to simulate
    gravity and solve the famous three-body problem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Apollo 8: The Thrilling Story of the First Mission to the Moon* (Henry Holt
    and Co., 2017), by Jeffrey Kluger, covers the historic Apollo 8 mission from its
    unlikely beginning to its “unimaginable triumph.”'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: An online search for *PBS Nova How Apollo 8 Left Earth Orbit* should return
    a short video clip on the Apollo 8 translunar injection maneuver, marking the
    first time humans left the earth’s orbit and traveled to another celestial body.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*NASA Voyager 1 & 2 Owner’s Workshop Manual* (Haynes, 2015), by Christopher
    Riley, Richard Corfield, and Philip Dolling, provides interesting background on
    the three-body problem and Michael Minovitch’s many contributions to space travel.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The Wikipedia *Gravity assist* page contains lots of interesting animations
    of various gravity-assist maneuvers and historic planetary flybys that you can
    reproduce with your Apollo 8 simulation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*Chasing New Horizons: Inside the Epic First Mission to Pluto* (Picador, 2018),
    by Alan Stern and David Grinspoon, documents the importance—and ubiquity—of simulations
    in NASA missions.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Simulating a Search Pattern**'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), you used Bayes’ rule to help the Coast Guard search
    for a sailor lost at sea. Now, use turtle to design a helicopter search pattern
    to find the missing sailor. Assume the spotters can see for 20 pixels and make
    the spacing between long tracks 40 pixels (see [Figure 6-16](ch06.xhtml#ch06fig16)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-16: Two screenshots from practice_search_pattern.py'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: For fun, add a helicopter turtle and orient it properly for each pass. Also
    add a randomly positioned sailor turtle, stop the simulation when the sailor is
    found, and post the joyous news to the screen ([Figure 6-17](ch06.xhtml#ch06fig17)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_17.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-17: The sailor is spotted in practice_search_pattern.py.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_search_pattern.py*, in the appendix. I’ve
    included a digital version, along with helicopter and sailor images, in the *Chapter_6*
    folder, downloadable from the book’s website.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Start Me Up!**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that a moving moon approaches a stationary
    CSM, causes the CSM to start moving, and then swings it up and away. For fun,
    orient the CSM turtle so that it always points in the direction of travel, as
    if under its own propulsion (see [Figure 6-18](ch06.xhtml#ch06fig18)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-18: The moon approaches a stationary CSM (left) and then flings it
    to the stars (right).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: For a solution, see *practice_grav_assist_stationary.py* in the appendix or
    download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Shut Me Down!**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that the CSM and moon have crossing orbits,
    the CSM passes before the moon, and the moon’s gravity slows the CSM’s progress
    to a crawl while changing its direction by about 90 degrees. As in the previous
    practice project, have the CSM point in the direction of travel (see [Figure 6-19](ch06.xhtml#ch06fig19)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig06_19.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-19: The moon and CSM cross orbits, and the moon slows and turns the
    CSM.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: For a solution, see *practice_grav_assist_intersecting.py* in the appendix or
    download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: True-Scale Simulation**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that the earth, the moon, and the distance
    between them are all accurately scaled, as shown in [Figure 6-10](ch06.xhtml#ch06fig10).
    Use colored circles, rather than images, for the earth and the moon and make the
    CSM invisible (just draw a line behind it). Use [Table 6-2](ch06.xhtml#ch06table2)
    to help determine the relative sizes and distances to use.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** Length Parameters for the Earth-Moon System'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '| Earth radius | 6,371 km |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| Moon radius | 1,737 km |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| Earth-moon distance | 356,700 km* |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '*Closest approach during Apollo 8 mission in December 1968'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: The Real Apollo 8**'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *apollo_8_free_return.py* so that it simulates the entire Apollo 8 mission,
    not just the free return component. The CSM should orbit the moon 10 times before
    returning to the earth.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
