- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: ALGORITHMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法**'
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/comm-1.jpg)'
- en: 'Algorithms are ancient concepts. An *algorithm* is nothing more than a set
    of instructions, much like a cooking recipe. However, the *role* algorithms play
    in society is increasing drastically in importance: algorithms and algorithmic
    decision-making are ubiquitous as computers become a larger and larger part of
    our lives.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是古老的概念。一个*算法*不过是一组指令，就像一份烹饪食谱。然而，*算法*在社会中所扮演的角色正在急剧增加：随着计算机在我们生活中的作用越来越大，算法和算法决策在各个领域无处不在。
- en: A 2018 study highlights that “Data, in the form of observations about our world,
    permeate modern society. . . . This information can in turn be used to make informed—and
    in some cases even fully automated—decisions. . . . It seems likely that such
    algorithms will interface with human decision-making, a development necessary
    to gain societal acceptance and thus wide-scale use.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年的一项研究强调了“数据以我们对世界的观察的形式渗透到现代社会中……这些信息反过来可以用来做出有根据的——在某些情况下甚至完全自动化的——决策……看起来这样的算法可能会与人类决策相结合，这是获得社会接受并因此广泛使用的必要发展。”
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more information on this study, see “The Growing Ubiquity of Algorithms
    in Society: Implications, Impacts, and Innovations” by S. C. Olhede and P. J.
    Wolfe at* [https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1](https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解更多关于这项研究的信息，请参阅S. C. Olhede和P. J. Wolfe的《算法在社会中的日益普及：影响、冲击与创新》一书，网址为* [https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1](https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1)。'
- en: As society undergoes major trends in automation, artificial intelligence, and
    ubiquitous computing, the societal gap between those who understand algorithms
    and those who don’t grows rapidly. For example, the logistics sector undergoes
    a major trend toward automation—with self-driving cars and trucks on the rise—and
    professional drivers face the fact that algorithms take over their jobs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着社会在自动化、人工智能和无处不在的计算的重大趋势下发展，理解算法与不了解算法的人之间的社会差距正在迅速扩大。例如，物流行业正在朝着自动化的方向发展——自动驾驶汽车和卡车的崛起——而专业司机面临着算法接管他们工作的事实。
- en: The constantly shifting landscape of sought-after skills and jobs in the 21st
    century makes it imperative for young people to understand, control, and manipulate
    basic algorithms. While the only constant is change, the concepts and basics of
    algorithms and algorithmic theory form the basis upon which much of the upcoming
    changes are built. Roughly speaking, understand algorithms and you’ll be well
    equipped to thrive in the upcoming decades.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 21世纪不断变化的热门技能和工作岗位使得年轻人必须理解、掌握并操作基本的算法。虽然唯一不变的就是变化，但算法和算法理论的概念与基础构成了即将到来的变化的基础。粗略地说，理解算法，你就能为未来几十年的发展做好充分准备。
- en: This chapter aims to improve your understanding of algorithms, focusing more
    on your intuition and a well-rounded understanding of concepts and practical implementations
    than on theory. While algorithmic theory is as important as practical implementations
    and conceptual understanding, many great books focus on the theory part. After
    reading this chapter, you will intuitively understand some of the most popular
    algorithms in computer science—and improve your practical Python implementation
    skills. This may provide you a strong foundation for the upcoming technological
    breakthroughs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在提高你对算法的理解，更侧重于直觉和全面理解概念及实际应用，而非理论。虽然算法理论与实际应用和概念理解同样重要，但许多优秀的书籍都专注于理论部分。阅读本章后，你将直观地理解一些计算机科学中最受欢迎的算法——并提高你的Python实际编程技能。这为即将到来的技术突破提供了坚实的基础。
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The book* Introduction to Algorithms *by Thomas Cormen et al. (MIT Press,
    2009) is an excellent follow-up resource on algorithmic theory.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*《算法导论》*（作者：Thomas Cormen等，MIT出版社，2009年）是一本关于算法理论的极好参考书。'
- en: Let’s start with a small algorithm to solve a simple problem that is relevant
    for programmers who want to find good jobs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小算法开始，解决一个对想要找到好工作的程序员来说相关的简单问题。
- en: '**Finding Anagrams with Lambda Functions and Sorting**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Lambda函数和排序查找字谜**'
- en: Anagrams are a popular topic in programming interviews to test your computer
    science vocabulary and how good you are at developing your own simple algorithms.
    In this section, you’ll learn about a simple algorithm to find anagrams in Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 变位词是编程面试中常见的题目，用来测试你的计算机科学词汇和编写简单算法的能力。在本节中，你将学习如何在 Python 中使用简单算法查找变位词。
- en: '***The Basics***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'Two words are *anagrams* if they consist of the same characters and if every
    character of the first word appears in the second word exactly once. This is illustrated
    in [Figure 6-1](#ch06fig01) and in the following examples:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个词由相同的字符组成，并且第一个词中的每个字符在第二个词中恰好出现一次，那么这两个词是*变位词*。这一点在[图 6-1](#ch06fig01)以及以下示例中有说明：
- en: “listen” → “silent”
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “listen” → “silent”
- en: “funeral ” → “real fun”
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “funeral ” → “real fun”
- en: “elvis” → “lives”
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “elvis” → “lives”
- en: '![images](Images/fig6-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-1.jpg)'
- en: '*Figure 6-1: The word* elvis *is an anagram of the word* lives.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：单词* elvis *是单词* lives *的变位词。*'
- en: We’ll now work on this problem and arrive at a concise Pythonic solution to
    figuring out whether two words are anagrams. Let’s start coding.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将着手解决这个问题，并得出一个简洁的 Pythonic 解决方案来判断两个单词是否是变位词。让我们开始编写代码吧。
- en: '***The Code***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to write a function `is_anagram()` that takes two strings `x1` and
    `x2` and returns `True` if those are anagrams! Before you read on, pause for a
    moment and think about the problem. How would you approach it in Python? [Listing
    6-1](#list6-1) shows one solution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个函数 `is_anagram()`，该函数接收两个字符串 `x1` 和 `x2`，并在它们是变位词时返回 `True`！在继续阅读之前，请暂停片刻思考一下这个问题。你会如何在
    Python 中处理这个问题呢？[清单 6-1](#list6-1)展示了一个解决方案。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: One-liner solution to check whether two strings are anagrams*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-1：检查两个字符串是否是变位词的一行代码解决方案*'
- en: This code prints three lines. What are they?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印了三行。它们分别是什么？
- en: '***How It Works***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'Two strings are anagrams if they have the same sorted character sequence, so
    our method is to sort both strings and then make an element-wise comparison. It’s
    that easy. There is no need for external dependencies. You simply create a function
    `is_anagram()` ➊ by using the lambda function definition (see [Chapter 1](ch01.xhtml#ch01))
    with two arguments `x1` and `x2`. The function returns the result of the expression
    `sorted(x1) == sorted(x2)`, which is `True` if the sorted character sequences
    consist of the same characters. Here’s the output of the two sorted character
    sequences:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字符串具有相同的排序字符序列，那么它们就是变位词，因此我们的方法是对两个字符串进行排序，然后进行逐元素比较。就是这么简单。无需外部依赖。你只需通过使用
    Lambda 函数定义（参见[第 1 章](ch01.xhtml#ch01)）并传入两个参数 `x1` 和 `x2` 来创建一个 `is_anagram()`
    函数 ➊。该函数返回表达式 `sorted(x1) == sorted(x2)` 的结果，如果排序后的字符序列由相同的字符组成，则返回 `True`。以下是两个排序后字符序列的输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both strings `''elvis''` and `''lives''` consist of the same characters, so
    the sorted list representation is the same. The result of the three print statements
    is the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串 `'elvis'` 和 `'lives'` 由相同的字符组成，因此它们的排序列表表示是相同的。三条打印语句的结果如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a small side note for advanced coders: the runtime complexity of sorting
    a sequence of *n* elements in Python grows asymptotically like the function *n
    log(n)*. That means our one-liner algorithm is more efficient than the naive solution
    of checking whether every character exists in both strings and removing the character
    if this is the case. The naive algorithm grows asymptotically like the quadratic
    function *n**2*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 给高级程序员的小提示：在 Python 中对 *n* 个元素进行排序的运行时间复杂度是随着 *n log(n)* 函数渐近增长的。这意味着我们的这一行代码算法比那种检查每个字符是否都出现在两个字符串中并在相同字符存在时删除它们的天真算法更高效。天真算法的渐近增长复杂度是
    *n**2*。
- en: However, there’s another efficient way, called *histogramming*, whereby you
    create a histogram for both strings that counts the number of occurrences of all
    characters in that string, and then compare the two histograms. Assuming a constant-sized
    alphabet, the runtime complexity of histogramming is linear; it grows asymptotically
    like the function *n*. Feel free to implement this algorithm as a small exercise!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种高效的方法，叫做 *直方图法*，即为两个字符串创建一个直方图，统计该字符串中所有字符的出现次数，然后比较两个直方图。假设字母表大小是常数，直方图法的运行时复杂度是线性的；它的渐近增长复杂度是
    *n*。不妨把这个算法当作一个小练习来实现！
- en: '**Finding Palindromes with Lambda Functions and Negative Slicing**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Lambda 函数和负切片查找回文**'
- en: 'This section introduces another computer science term that’s popular in interview
    questions: palindromes. You’ll use a one-liner to check whether two words are
    palindromes of each other.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了另一个在面试问题中流行的计算机科学术语：回文。你将使用一个单行代码来检查两个单词是否是彼此的回文。
- en: '***The Basics***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'First things first: what is a palindrome? A *palindrome* can be defined as
    a sequence of elements (for example, a string or a list) that reads the same backward
    as it does forward. Here are a few fun examples that are palindromes if you take
    out the whitespace:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要弄清楚的是：什么是回文？*回文*可以定义为一种元素序列（例如字符串或列表），它从前向后和从后向前读取都是一样的。以下是一些有趣的例子，如果你去掉空格，它们就是回文：
- en: “Mr Owl ate my metal worm”
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Mr Owl ate my metal worm”
- en: “Was it a car or a cat I saw?”
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Was it a car or a cat I saw?”
- en: “Go hang a salami, I’m a lasagna hog”
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Go hang a salami, I’m a lasagna hog”
- en: “Rats live on no evil star”
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “老鼠生活在没有邪恶之星上”
- en: “Hannah”
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Hannah”
- en: “Anna”
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Anna”
- en: “Bob”
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Bob”
- en: Our one-liner solution will require your basic understanding of slicing. As
    you know from [Chapter 2](ch02.xhtml#ch02), slicing is a Python-specific concept
    for carving out a range of values from sequence types such as lists or strings.
    Slicing uses the concise notation `[start:stop:step]` to slice a sequence starting
    at index `start` (inclusive) and ending at index `stop` (exclusive). The third
    parameter `step` allows you to define the *step size*, which is how many characters
    from the original sequence your slice will skip before taking the next character
    (for example, `step=2` means that your slice will consist of only every other
    character). When using a negative step size, the string is traversed in reverse
    order.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单行解决方案将需要你对切片有基本的理解。正如你在[第2章](ch02.xhtml#ch02)中所学，切片是 Python 特有的概念，用于从序列类型（如列表或字符串）中截取一段范围的值。切片使用简洁的表示法`[start:stop:step]`来截取一个从索引`start`（包含）开始并在索引`stop`（不包含）结束的序列。第三个参数`step`允许你定义*步长*，即在截取下一个字符之前，原始序列中跳过多少个字符（例如，`step=2`意味着你的切片将只包含每隔一个字符的元素）。当使用负的步长时，字符串会反向遍历。
- en: This is everything you need to know to come up with a short and concise one-liner
    solution in Python.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要知道的所有内容，以便用 Python 提出一个简短而简洁的单行解决方案。
- en: '***The Code***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: When given a string, you want your code to check whether the reverse sequence
    of characters equals the original sequence, to determine whether the string is
    a palindrome. [Listing 6-2](#list6-2) shows the solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串时，你希望你的代码检查反转后的字符序列是否等于原始序列，以确定该字符串是否是回文。[列表6-2](#list6-2)展示了解决方案。
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-2: One-liner solution to check whether a phrase is a palindrome*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-2：检查一个短语是否是回文的单行解决方案*'
- en: '***How It Works***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The simple one-liner solution does not depend on any external library. You define
    a lambda function that takes a single argument `phrase`—the string to be tested—and
    returns a Boolean value that says whether the sequence of characters remains unchanged
    when reversed. To reverse the string, you use slicing (see [Chapter 2](ch02.xhtml#ch02)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的单行解决方案不依赖于任何外部库。你定义了一个 lambda 函数，它接受一个参数`phrase`——即需要测试的字符串——并返回一个布尔值，表示当字符串反转时，字符序列是否保持不变。为了反转字符串，你使用切片（请参见[第2章](ch02.xhtml#ch02)）。
- en: 'The result of the one-liner code snippet is the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码片段的结果如下：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first and third strings are palindromes, but the second isn’t. Next let’s
    dive into another popular computer science concept: permutations.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第三个字符串是回文，而第二个不是。接下来，让我们深入探讨另一个流行的计算机科学概念：排列。
- en: '**Counting Permutations with Recursive Factorial Functions**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过递归阶乘函数计数排列数**'
- en: This section explains a simple and effective way of computing the factorial
    in a single line of code to figure out the maximum number of possible permutations
    in a data set.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一种简单而有效的方法，通过一行代码计算阶乘，以便找出数据集中可能的最大排列数。
- en: '***The Basics***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'Consider the following problem: England’s Premier League has 20 soccer teams,
    each of which can reach any of the 20 ranks at the end of the season. Given 20
    fixed teams, you can calculate how many possible versions of these rankings exist.
    Note that the question is not how many rankings a single team can achieve (the
    answer would be 20) but how many total rankings of all teams exist. [Figure 6-2](#ch06fig02)
    shows just three possible rankings.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：英格兰超级联赛有20支足球队，每支队伍在赛季结束时都可以达到20个排名中的任何一个。给定20支固定的队伍，您可以计算这些排名的所有可能版本的数量。注意，这个问题不是问单个队伍可以达到多少个排名（答案是20），而是问所有队伍的排名总数有多少种。[图6-2](#ch06fig02)展示了仅仅三种可能的排名。
- en: '![images](Images/fig6-2.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-2.jpg)'
- en: '*Figure 6-2: Three possible rankings of the soccer teams in England’s Premier
    League*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：英格兰超级联赛足球队的三种可能排名*'
- en: In computer science terminology, you would denote each ranking as a *permutation*,
    defined as a specific order of set elements. Our goal is to find the number of
    possible permutations of a given set. The number of those permutations has important
    implications for programs involved in betting applications, match prediction,
    and game analysis. For example, if each of 100 different rankings has the same
    initial probability, the probability of a specific ranking is 1/100 = 1 percent.
    This can be used as a base probability (*a priori probability*) for game-prediction
    algorithms. Under these assumptions, a randomly guessed ranking has a 1 percent
    probability of being the correct outcome after one season.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学术语中，您会将每个排名表示为一个*排列*，它被定义为一组元素的特定顺序。我们的目标是找出给定集合的所有可能排列的数量。这些排列的数量对涉及投注应用程序、比赛预测和游戏分析的程序具有重要意义。例如，如果100个不同的排名每个都有相同的初始概率，那么某个特定排名的概率是1/100
    = 1%。这可以作为游戏预测算法的基础概率（*先验概率*）。在这些假设下，随机猜测的排名在一个赛季结束后有1%的概率是正确的结果。
- en: 'To calculate the number of permutations of a given set of *n* elements, you
    can use the factorial function *n!*. In the next few paragraphs, you’ll learn
    why this is the case. The factorial is defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算给定*n*个元素的排列数量，您可以使用阶乘函数*n!*。在接下来的几段中，您将了解为什么是这样的。阶乘的定义如下：
- en: '*n! = n × (n – 1) × (n – 2) × . . . × 1*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*n! = n × (n – 1) × (n – 2) × . . . × 1*'
- en: 'For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '*1! = 1*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*1! = 1*'
- en: '*3! = 3 × 2 × 1 = 6*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*3! = 3 × 2 × 1 = 6*'
- en: '*10! = 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 3,628,800*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*10! = 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 3,628,800*'
- en: '*20! = 20 × 19 × 18 × . . . × 3 × 2 × 1 = 2,432,902,008,176,640,000*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*20! = 20 × 19 × 18 × . . . × 3 × 2 × 1 = 2,432,902,008,176,640,000*'
- en: Let’s take a look at how this works. Say you have a set of 10 elements *S* = {*s*0,
    *s*1, *s*2, . . . , *s*9} and 10 buckets *B* = {*b*0, *b*1, *b*2, . . . , *b*9}.
    You want to place exactly one element from *S* into each bucket. In the soccer
    example, the 20 teams are the elements, and the 20 table ranks are the buckets.
    To get one specific permutation of *S*, you simply place all elements into all
    buckets. The number of different ways of assigning elements to buckets is the
    total number of permutations of elements in *S*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个是如何工作的。假设您有一个包含10个元素的集合*S* = {*s*0, *s*1, *s*2, . . . , *s*9} 和10个桶*B*
    = {*b*0, *b*1, *b*2, . . . , *b*9}。您希望将集合*S*中的每个元素放入一个桶中。在足球的例子中，20支队伍就是元素，20个排名就是桶。为了得到*S*的一个特定排列，您只需要将所有元素放入所有桶中。将元素分配给桶的不同方式数量即为*S*中元素的排列总数。
- en: 'The following algorithm determines the number of permutations for a set with
    10 elements (which need to be placed into 10 buckets):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法确定了一个包含10个元素的集合的排列数量（这些元素需要放入10个桶中）：
- en: Take the first element from the set *S*. There are *10 empty buckets* so you
    have *10 options* for where you can place the element. You place one element in
    a bucket.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从集合*S*中取出第一个元素。现在有*10个空桶*，所以你有*10个选择*来放置元素。你将一个元素放入一个桶中。
- en: Now one bucket is occupied. Take the second element from the set. There now
    remain *9 empty buckets* so you have *9 options*.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一个桶已经被占用了。取出集合中的第二个元素。现在剩下*9个空桶*，因此你有*9个选择*。
- en: Finally, take the 10th (last) element from the set. Nine buckets are now occupied.
    There is only *one empty bucket*, so you have *one option*.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从集合中取出第10个（最后一个）元素。现在有九个桶已经占用。只剩下*一个空桶*，因此你有*一个选择*。
- en: In total, you have 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 10! options. Each
    potential placement of an element in a bucket represents one permutation of the
    set elements. The number of permutations of a set with *n* elements is therefore
    *n!*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总共，你有 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 10! 种选项。每一个元素在桶中的潜在放置方式代表着集合元素的一种排列。因此，具有
    *n* 个元素的集合的排列数就是 *n!*。
- en: 'Recursively, the factorial function can also be defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地，阶乘函数也可以这样定义：
- en: '*n! = n × (n – 1)!*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*n! = n × (n – 1)!*'
- en: 'The recursion base cases are defined as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的基本情况如下所示：
- en: '*1! = 0! = 1*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*1! = 0! = 1*'
- en: The intuition behind these base cases is that a set with one element has one
    permutation, and a set with zero elements has one permutation (there is one way
    of assigning zero elements to zero buckets).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本情况背后的直觉是，具有一个元素的集合有一种排列，具有零个元素的集合也有一种排列（将零个元素分配到零个桶中只有一种方式）。
- en: '***The Code***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: The one-liner in [Listing 6-3](#list6-3) will compute the number of permutations
    *n!* of a set with *n* elements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](#list6-3) 中的单行代码将计算具有 *n* 个元素的集合的排列数 *n!*。'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-3: One-liner solution defining the factorial function recursively*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：定义阶乘函数的单行递归解法*'
- en: Try figuring out what the output of this code would be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试弄清楚这段代码的输出结果是什么。
- en: '***How It Works***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'In the code, you use the recursive definition of the factorial. Let’s quickly
    improve our intuitive understanding of recursion. Stephen Hawking came up with
    a concise way to explain recursion: “To understand recursion, one must first understand
    recursion.”'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你使用了阶乘的递归定义。让我们快速提升对递归的直观理解。斯蒂芬·霍金提出了一种简明的方式来解释递归：“要理解递归，必须首先理解递归。”
- en: The Merriam-Webster dictionary defines recursion as “a computer programming
    technique involving the use of a . . . function . . . that calls itself one or
    more times until a specified condition is met, at which time the rest of each
    repetition is processed from the last one called to the first.” At the heart of
    this definition is the *recursive function*, which is simply a function that calls
    itself. But if the function keeps calling itself, it would never stop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 《梅里亚姆-韦伯斯特词典》将递归定义为“计算机编程技术，涉及使用一个……函数……多次调用自身，直到满足指定条件，此时每次重复的其余部分会从最后一次调用处理到第一次。”该定义的核心是*递归函数*，即一个调用自身的函数。但是，如果函数一直调用自身，它将永远不会停止。
- en: 'For this reason, we set a certain base case. When the base case is met, the
    last function call terminates and returns a solution to the second-to-last function
    call. The second-to-last function call also returns the solution to the third-to-last
    function call. This causes a chain reaction of propagating the results to the
    higher recursion level until the first function call returns the final result.
    This may feel difficult to grasp in a few lines of English text, but stay with
    me: we will discuss this with the aid of the given one-liner example next.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个原因，我们设置了一个特定的基本情况。当满足基本情况时，最后一次函数调用终止并返回给倒数第二次函数调用一个解答。倒数第二次函数调用也会将解答返回给倒数第三次函数调用。这引发了一个链式反应，将结果传递到更高的递归层级，直到第一次函数调用返回最终结果。几行英文文本可能让人难以理解这一点，但请跟着我走：我们将在接下来的单行示例中讨论这一点。
- en: 'In general, you create a recursive function *f* in four steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以通过四个步骤创建一个递归函数*f*：
- en: Break the original problem into smaller problem instances.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原问题拆解成更小的问题实例。
- en: Take the smaller problem instances as the input of function *f* (which will
    then break the smaller input into even smaller problem instances and so on).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将较小的问题实例作为函数*f*的输入（该函数随后将较小的输入拆解成更小的问题实例，以此类推）。
- en: Define a *base case*, which is the smallest possible input that can be solved
    directly without any further call of the function *f*.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个*基本情况*，即可以直接解决的最小输入，无需再调用函数*f*。
- en: Specify how you can recombine the obtained smaller solutions into the larger
    solution.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定如何将获得的较小解重新组合成较大的解。
- en: You create a lambda function with one argument `n` and assign the lambda function
    to the name `factorial`. Finally, you call the named function `factorial(n-1)`
    to calculate the result of the function call `factorial(n)`. The value `n` could
    be the number of soccer teams in the Premier League (`n=20`) or any other value
    such as the one in [Listing 6-3](#list6-3) (`n=5`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个带有一个参数 `n` 的 lambda 函数，并将这个 lambda 函数赋值给名称 `factorial`。最后，你调用命名函数 `factorial(n-1)`
    来计算函数调用 `factorial(n)` 的结果。值 `n` 可以是英超联赛的球队数量（`n=20`），或者是其他值，如[清单 6-3](#list6-3)中的值（`n=5`）。
- en: Roughly speaking, you can use the simpler solution for `factorial(n-1)` to construct
    the solution of the harder problem `factorial(n)` by multiplying the former with
    the input argument `n`. As soon as you reach the recursion base case `n <= 1`,
    you simply return the hardcoded solution `factorial(1) =` `factorial(0) = 1`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，你可以使用 `factorial(n-1)` 的简化解决方案，通过将前者与输入参数 `n` 相乘，来构建更难问题 `factorial(n)`
    的解决方案。只要你达到递归的基本情况 `n <= 1`，你只需返回硬编码的解决方案 `factorial(1) =` `factorial(0) = 1`。
- en: This algorithm shows how you can often find a simple, concise, and efficient
    way of solving problems by thoroughly understanding the problem first. Choosing
    the simplest solution idea is one of the most important things you can do when
    creating your own algorithms. Beginners often find they write cluttered and unnecessarily
    complicated code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法展示了如何通过彻底理解问题，通常能够找到解决问题的简单、简洁和高效的方法。在创建自己的算法时，选择最简单的解决方案是你可以做的最重要的事情之一。初学者通常发现自己编写的代码混乱且不必要地复杂。
- en: In this case, the recursive (one-liner) definition of the factorial is shorter
    than an iterative (one-liner) definition without recursion. As an exercise, try
    rewriting this one-liner without using a recursive definition and without external
    libraries—it’s not trivial and certainly not that concise!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，阶乘的递归（单行）定义比没有递归的迭代（单行）定义要简短。作为一个练习，试着重写这个单行代码，不使用递归定义，也不使用外部库——这并不简单，当然也没有那么简洁！
- en: '**Finding the Levenshtein Distance**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算 Levenshtein 距离**'
- en: In this section, you’ll learn about an important practical algorithm to calculate
    the Levenshtein distance. Understanding this algorithm is more complicated than
    previous algorithms, so you’ll also train yourself to think through a problem
    clearly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一种重要的实际算法，用于计算 Levenshtein 距离。理解这个算法比之前的算法要复杂，所以你也将训练自己清晰地思考问题。
- en: '***The Basics***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'The *Levenshtein distance* is a metric to calculate the distance between two
    strings; in other words, it’s used to quantify the similarity of two strings.
    Its alternate name, the *edit distance*, describes precisely what it measures:
    the number of character edits (insertions, removals, or substitutions) needed
    to transform one string into another. The smaller the Levenshtein distance, the
    more similar the strings.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*Levenshtein 距离* 是一种计算两个字符串之间距离的度量；换句话说，它用于量化两个字符串的相似性。它的另一个名称 *编辑距离* 精确地描述了它所测量的内容：将一个字符串转换为另一个字符串所需的字符编辑次数（插入、删除或替换）。Levenshtein
    距离越小，字符串越相似。'
- en: The Levenshtein distance has important applications in things like the autocorrection
    functionality on your smartphone. If you type *helo* in your WhatsApp messenger,
    your smartphone detects a word outside its library and selects several high-probability
    words as potential replacements, and then sorts them by Levenshtein distance.
    For example, the word with minimal Levenshtein distance and, hence, maximal similarity
    is the string `'hello'`, so your phone may automatically correct *helo* to *hello*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein 距离在许多领域中有着重要的应用，比如智能手机上的自动纠正功能。如果你在 WhatsApp 消息中输入 *helo*，你的手机会检测到该单词不在其词库中，并选择几个高概率的单词作为潜在替换项，然后按
    Levenshtein 距离对它们进行排序。例如，Levenshtein 距离最小的单词，因而最大相似度的单词是字符串 `'hello'`，因此你的手机可能会自动将
    *helo* 修正为 *hello*。
- en: Let’s consider an example with the two less similar strings `'cat'` and `'chello'`.
    Knowing that the Levenshtein distance computes the minimal number of edits required
    to reach the second string starting from the first string, [Table 6-1](#ch06tab01)
    shows the minimal sequence.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中有两个不太相似的字符串 `'cat'` 和 `'chello'`。知道 Levenshtein 距离计算从第一个字符串到达第二个字符串所需的最小编辑次数，[表
    6-1](#ch06tab01) 显示了最小的序列。
- en: '**Table 6-1:** The Minimal Sequence Needed to Change `''cat''` to `''chello''`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** 将 `''cat''` 转换为 `''chello''` 所需的最小序列'
- en: '| **Current word** | **Edit made** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **当前单词** | **所做编辑** |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **cat** | **—** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **cat** | **—** |'
- en: '| cht | Replace *a* with *h* |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| cht | 用 *h* 替换 *a* |'
- en: '| che | Replace *t* with *e* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| che | 用 *e* 替换 *t* |'
- en: '| chel | Insert *l* at position 3 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| chel | 在位置 3 插入 *l* |'
- en: '| chell | Insert *l* at position 4 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| chell | 在位置 4 插入 *l* |'
- en: '| chello | Insert *o* at position 5 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| chello | 在位置 5 插入 *o* |'
- en: '[Table 6-1](#ch06tab01) transforms the string `''cat''` to the string `''chello''`
    in five editing steps, meaning the Levenshtein distance is 5.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](#ch06tab01) 将字符串 `''cat''` 转换为字符串 `''chello''`，需要五步编辑，这意味着 Levenshtein
    距离是 5。'
- en: '***The Code***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Now let’s write a Python one-liner that calculates the Levenshtein distance
    of strings `a` and `b`, `a` and `c`, and `b` and `c` (see [Listing 6-4](#list6-4)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个 Python 单行代码来计算字符串 `a` 和 `b`，`a` 和 `c`，以及 `b` 和 `c` 的 Levenshtein 距离（见
    [清单 6-4](#list6-4)）。
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-4: Calculating the Levenshtein distance of two strings in one line*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：用一行代码计算两个字符串的 Levenshtein 距离*'
- en: Based on what you know so far, try to calculate the output before running the
    program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你目前所知道的，尝试在运行程序之前计算输出结果。
- en: '***How It Works***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: 'Before diving into the code, let’s quickly explore an important Python trick
    heavily used in this one-liner. In Python, *every* object has a truth value and
    is either `True` or `False`. Most objects are in fact `True` and, intuitively,
    you can probably guess the few objects that are `False`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，让我们快速探索一下一个在这个单行代码中大量使用的 Python 技巧。在 Python 中，*每个*对象都有一个布尔值，并且是 `True`
    或 `False`。大多数对象实际上是 `True`，直观上，你可能能猜到一些是 `False` 的对象：
- en: The numerical value `0` is `False`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值 `0` 为 `False`。
- en: The empty string `''` is `False`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串 `''` 为 `False`。
- en: The empty list `[]` is `False`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表 `[]` 为 `False`。
- en: The empty set `set()` is `False`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空集合 `set()` 为 `False`。
- en: The empty dictionary `{}` is `False`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字典 `{}` 为 `False`。
- en: 'As a rule of thumb, Python objects are considered `False` if they are empty
    or zero. Equipped with this information, let’s look at the first part of the Levenshtein
    function: you create a lambda function that takes two strings `a` and `b` and
    returns the number of edits required to transform string `a` into string `b` ➊.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果 Python 对象是空的或零，它们被认为是 `False`。掌握了这一点后，让我们来看 Levenshtein 函数的第一部分：你创建了一个
    lambda 函数，接受两个字符串 `a` 和 `b`，并返回将字符串 `a` 转换为字符串 `b` 所需的编辑次数 ➊。
- en: 'There are two trivial cases: if string `a` is empty, the minimal edit distance
    is `len(b)`, since you would just need to insert each character of string `b`.
    Similarly, if string `b` is empty, the minimal edit distance is `len(a)`. That
    means if either string is empty, you can directly return the correct edit distance.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个简单的情况：如果字符串 `a` 为空，最小的编辑距离是 `len(b)`，因为你只需要插入字符串 `b` 中的每个字符。同样，如果字符串 `b`
    为空，最小的编辑距离是 `len(a)`。也就是说，如果其中一个字符串为空，你可以直接返回正确的编辑距离。
- en: Let’s say both strings are non-empty. You can simplify the problem by calculating
    the Levenshtein distance of smaller suffixes of the original strings `a` and `b`,
    as shown in [Figure 6-3](#ch06fig03).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设两个字符串都非空。你可以通过计算原始字符串 `a` 和 `b` 的较小后缀的 Levenshtein 距离来简化问题，如 [图 6-3](#ch06fig03)
    所示。
- en: '![images](Images/fig6-3.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-3.jpg)'
- en: '*Figure 6-3: Calculating the Levenshtein distance of the words `''cat''` and
    `''chello''` recursively by solving the smaller problem instances first*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：通过递归解决较小的问题实例，计算单词 `''cat''` 和 `''chello''` 的 Levenshtein 距离*'
- en: 'To compute the Levenshtein distance between the strings `''cat''` and `''chello''`
    in a recursive manner, you solve the easier problems first (recursively):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要以递归方式计算字符串 `'cat'` 和 `'chello'` 之间的 Levenshtein 距离，你首先解决较容易的问题（递归地）：
- en: You calculate the distance between the suffixes `at` and `hello` because if
    you know how to transform `at` into `hello`, you can easily transform `cat` into
    `chello` by modifying the first character (or by keeping the first character if
    both strings start with the same character). Assuming this distance is 5, you
    can now conclude that the distance between `cat` and `chello` is also at most
    5 because you can reuse the exact same sequence of edits (both words begin with
    the character `c` and you don’t have to edit this character).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算后缀 `at` 和 `hello` 之间的距离，因为如果你知道如何将 `at` 转换为 `hello`，那么你可以通过修改第一个字符（或者如果两个字符串都以相同的字符开头，则保持第一个字符不变）轻松地将
    `cat` 转换为 `chello`。假设这个距离是 5，你现在可以得出结论，`cat` 和 `chello` 之间的距离也最多是 5，因为你可以重用完全相同的编辑序列（两个词都以字符
    `c` 开头，且你不需要编辑这个字符）。
- en: You calculate the distance between `at` and `chello`. Assuming this distance
    is 6, you can now conclude that the distance between `cat` and `chello` is at
    most 6 + 1 = 7 because you can simply remove the character `c` at the beginning
    of the first word (one additional operation). From there, you can reuse the exact
    same solution to come from `at` to `chello`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算`at`和`chello`之间的距离。假设这个距离是6，那么你现在可以得出结论：`cat`和`chello`之间的距离至多是6 + 1 = 7，因为你只需删除第一个单词的字符`c`（一个额外操作）。从此，你可以重用相同的解法从`at`变换到`chello`。
- en: You calculate the distance between `cat` and `hello`. Assuming this distance
    is 5, you can now conclude that the distance between `cat` and `chello` is at
    most 5 + 1 because you need to insert the character `c` at the beginning of the
    second word (one additional operation).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算`cat`和`hello`之间的距离。假设这个距离是5，那么你现在可以得出结论：`cat`和`chello`之间的距离至多是5 + 1，因为你需要在第二个单词的开头插入字符`c`（一个额外操作）。
- en: As these are all possible cases of what you can do with the first character
    (substitution, removal, insertion), the Levenshtein distance between `cat` and
    `chello` is the minimum of the three cases 1, 2, and 3\. Let’s now further examine
    the three cases in [Listing 6-4](#list6-4).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是你可以对首字符所做的所有可能操作（替换、删除、插入），`cat`和`chello`之间的Levenshtein距离是三种情况1、2和3中的最小值。现在让我们进一步分析[列表6-4](#list6-4)中的三种情况。
- en: First, you calculate the edit distance from `a[1:]` to `b[1:]` in a recursive
    manner ➋. If the leading characters `a[0]` and `b[0]` are different, you have
    to fix it by *replacing* `a[0]` by `b[0]`, so you increment the edit distance
    by one. If the leading characters are the same, the solution of the simpler problem
    `ls(a[1:], b[1:])` is also a solution to the more complex problem `ls(a, b)`,
    as you’ve seen in [Figure 6-3](#ch06fig03).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你以递归方式计算从`a[1:]`到`b[1:]`的编辑距离 ➋。如果首字符`a[0]`和`b[0]`不同，你必须通过*替换*`a[0]`为`b[0]`来修正，因此你将编辑距离加一。如果首字符相同，较简单问题`ls(a[1:],
    b[1:])`的解也就是较复杂问题`ls(a, b)`的解，正如你在[图6-3](#ch06fig03)中所见。
- en: Second, you calculate the distance from `a[1:]` to `b` in a recursive manner
    ➌. Say you know the result of this distance (going from `a[1:]` to `b`)—how can
    you calculate the distance one step further from `a` to `b`? The answer is to
    simply *remove* the first character `a[0]` from the beginning of `a`, which is
    one additional operation. With this, you have reduced the more complicated problem
    to the easier one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你以递归方式计算从`a[1:]`到`b`的距离 ➌。假设你已经知道这个距离的结果（从`a[1:]`到`b`）——那么如何计算从`a`到`b`的距离呢？答案是，只需*删除*`a`开头的第一个字符`a[0]`，这就是一个额外的操作。这样，你就将更复杂的问题简化为更简单的问题。
- en: Third, you calculate the distance from `a` to `b[1:]` in a recursive manner
    ➍. Say you know the result of this distance (going from `a` to `b[1:]`). How can
    you calculate the distance from `a` to `b`? In this case, you can simply go one
    step further (from `a` to `b[1:]` to `b`) by *inserting* the character `b[0]`
    at the beginning of the word `b[1:]`, which would increment the distance by one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你以递归方式计算从`a`到`b[1:]`的距离 ➍。假设你已经知道这个距离的结果（从`a`到`b[1:]`）。那么你如何计算从`a`到`b`的距离呢？在这种情况下，你只需再走一步（从`a`到`b[1:]`再到`b`），通过*插入*字符`b[0]`到单词`b[1:]`的开头，这样距离就增加了一。
- en: Finally, you simply take the minimum edit distance of all three results (replace
    the first character, remove the first character, insert the first character).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需选择所有三种结果的最小编辑距离（替换第一个字符、删除第一个字符、插入第一个字符）。
- en: This one-liner solution demonstrates once again the importance of training your
    recursion skills. Recursion may not come naturally to you, but rest assured that
    it will after studying many recursive problems like this one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简洁的一行代码再次证明了训练递归技能的重要性。递归可能对你来说并不自然，但请放心，在像这样的递归问题学习之后，它会变得更加顺手。
- en: '**Calculating the Powerset by Using Functional Programming**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用函数式编程计算幂集**'
- en: 'In this section, you’ll learn about an important mathematical concept known
    as the powerset: the set of all subsets. You’ll need powersets in statistics,
    set theory, functional programming, probability theory, and algorithmic analysis.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习一个重要的数学概念——幂集：所有子集的集合。你将在统计学、集合论、函数式编程、概率论和算法分析中用到幂集。
- en: '***The Basics***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: The *powerset* is the set of all subsets of the given set `s`. It includes the
    empty set `{}`, the original set `s`, and all other possible subsets of the original
    set. Here are a few examples.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Given set: `s = {1}`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Powerset: `P = {{},{1}}`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 2:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Given set: `s = {1, 2}`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Powerset: `P = {{},{1},{2},{1,2}}`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 3:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Given set: `s = {1, 2, 3}`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Powerset: `P = {{},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To calculate a powerset *P**[n]* of a set *s* with *n* elements, you use the
    smaller powerset *P**[n]*[–1] of a subset of *s* with (*n* – 1) elements. Say
    you want to calculate the powerset of set *s* = {1, 2, 3}.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the powerset *P*[0] with zero elements as *P*[0] = {{}}. In other
    words, this is the powerset of the empty set. It contains only the empty set itself.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create the powerset *P**[n]* with *n* elements from the powerset *P**[n]*[–1]
    with (*n* – 1) elements, you take one (arbitrary) element *x* from the set *s*
    and incorporate all arising subsets into the larger powerset *P**[n]* by using
    the following procedure:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go over all sets *p* in *P**[n]*[–1] and create a new subset that consists of
    the union of *x* and *p*. This results in a new temporary set of sets *T*. For
    example, if *P*[2] = {{}, {1}, {2}, {1,2}}, you’ll create the temporary set of
    sets *T* = {{3}, {1,3}, {2,3}, {1,2,3}} by adding the element *x* = 3 to all sets
    in *P*[2].
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Merge the new set of sets *T* with the powerset *P**[n]*[–1] to obtain powerset
    *P**[n]*. For example, you obtain powerset *P*[3] by merging the temporary set
    *T* with the powerset *P*[2] as follows: *P*[3] = *T union P*[2].'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to 2 until original set *s* is empty.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I’ll explain this strategy in more detail in the following section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**The reduce() Function**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'But first, you need to properly understand an important Python function that
    you’ll use in the one-liner: the `reduce()` function. The `reduce()` function
    is built into Python 2, but the developers decided it was used little enough that
    they didn’t include it in Python 3, so you’ll need to import it first from the
    functools library.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reduce()` function takes three arguments: `reduce(function, iterable,
    initializer)`. The `function` arguments define how two values `x` and `y` are
    reduced to a single value (for example, `lambda x, y: x + y`). This way, you can
    iteratively reduce two values of an `iterable` (the second argument) to a single
    value—until only a single value is left in the `iterable`. The `initializer` argument
    is optional—if you don’t set it, Python assumes the first value of the `iterable`
    as a default.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, calling `reduce(lambda x, y: x + y, [0, 1, 2, 3])` performs the
    following computation: `(((0 + 1)+ 2)+ 3) = 6`. In other words, you first reduce
    the two values `x=0` and `y=1` to the sum `x + y = 0 + 1 = 1`. Then, you use this
    result of the first call of the lambda function as input to the second call of
    the lambda function: `x=1` and `y=2`. The result is the sum `x + y = 1 + 2 = 3`.
    Finally, we use the result of this second call of the lambda `function` as input
    to the third call of the lambda `function` by setting `x=3` and `y=3`. The result
    is the sum `x + y = 3 + 3 = 6`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, you have seen that the value `x` always carries the result
    of the previous (lambda) `function`. The argument `x` serves as the accumulated
    value, while the argument `y` serves as the *update* value from the `iterable`.
    This is the intended behavior to iteratively “reduce” all values in the `iterable`
    argument to a single one. The optional third parameter `initializer` specifies
    the initial input for `x`. This allows you to define a *sequence aggregator* as
    shown in [Listing 6-5](#list6-5).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**List Arithmetic**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before diving into the one-liner, you need to understand two more list operators.
    The first is the list concatenation operator `+`, which glues together two lists.
    For example, the result of the expression `[1, 2] + [3, 4]` is the new list `[1,
    2, 3, 4]`. The second is the union operator `|`, which performs a simple union
    operation on two sets. For example, the result of the expression `{1, 2} | {3,
    4}` is the new set `{1, 2, 3, 4}`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 6-5](#list6-5) provides a one-liner solution that calculates the powerset
    of a given set *s*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-5: One-liner solution to calculate the powerset of a given set*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Guess the output of this code snippet!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The idea of this one-liner is to start the powerset as an empty set ➋ and repeatedly
    add subsets to it ➊ until no more subsets can be found.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the powerset contains only the empty set. In each step, you take
    one element `x` out of the data set `s` and create new subsets that naturally
    emerge by adding `x` to all subsets that are already in the powerset ➋. As you’ve
    seen in the introduction of this section, the size of the powerset therefore doubles
    each time you consider an additional element `x` from the data set `s`. In this
    way, you can grow the powerset with *n* subsets one data set element at a time
    (but by *n* subsets at a time). Note that the powerset grows exponentially: for
    any new data set element *x*, you double the size of the powerset. This is an
    inherent property of powersets: they quickly overwhelm any storage capacity—even
    for relatively small data sets with only a few dozen of elements.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `reduce()` function to maintain the current powerset in the variable
    `P` (which initially contains only the empty set). Using list comprehension, the
    `reduce``()` function creates new subsets—one for each existing subset—and adds
    them to the powerset `P`. In particular, it adds the value `x` from the data set
    to each subset and thus doubles the size of the powerset (containing the subsets
    *with* and *without* the data set element `x`). In this way, the `reduce()` function
    repeatedly “merges” two elements: the powerset `P` and an element `x` from the
    data set.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the result of the one-liner is the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This one-liner nicely demonstrates how important it is that you have a thorough
    understanding of lambda functions, list comprehension, and set operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Caesar’s Cipher Encryption Using Advanced Indexing and List Comprehension**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll learn about an ancient encryption technique called *Caesar’s
    cipher*, used by Julius Caesar himself to obfuscate his private conversations.
    Unfortunately, Caesar’s cipher is extremely simple to crack and offers no real
    protection, but it’s still used for fun and obfuscation of forum content that
    should be protected from naive readers’ eyes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Caesar’s cipher is based on the idea of shifting characters to be encrypted
    by a fixed number of positions in the alphabet. We’ll look at a particular case
    of Caesar’s cipher called the ROT13 algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The *ROT13* algorithm is a simple encryption algorithm used in many forums
    (for example, Reddit) to prevent spoilers or hide the semantics of a conversation
    from newbies. The ROT13 algorithm is easy to decrypt—an attacker can crack your
    code by running a probabilistic analysis on the distribution of the letters in
    your encrypted text—even if the attacker doesn’t know by how many positions you
    shifted each character. You should never rely on this algorithm to actually encrypt
    your messages! Still, there are many light applications of the ROT13 algorithm:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Obscure the result of puzzles in online forums.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obscure possible spoilers for movies or books.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make fun of other weak encryption algorithms: “56-bit DES is at least stronger
    than ROT13.”'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obscure email addresses on websites against 99.999 percent of email spam bots.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So ROT13 is more of a popular running gag in internet culture and an educational
    tool than a serious cipher.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm can be explained in one sentence: *ROT13 = Rotate the string
    to be encrypted by 13 positions (modulo 26) in the alphabet of 26 characters*
    (see [Figure 6-4](#ch06fig04)).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-4.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: The table shows how each character in the alphabet is encrypted
    and decrypted under the ROT13 algorithm.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In other words, you shift each character by 13 positions in the alphabet. When
    shifting over the last character, *z*, you start over at the first position in
    the alphabet, *a*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 6-6](#list6-6) creates a one-liner to encrypt the string `s` by using
    the ROT13 algorithm!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-6: One-liner solution encrypting string `s` with the ROT13 algorithm*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Use [Figure 6-4](#ch06fig04) to crack this code: what’s the output of this
    code snippet?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The one-liner solution encrypts each character separately by moving it 13 positions
    to the right in the alphabet stored in `abc`, and then creates a list of these
    encrypted characters and joins the elements in this list to get the encrypted
    phrase `x`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how to encrypt each character. You use list comprehension
    (see [Chapter 2](ch02.xhtml#ch02)) to create the list of encrypted characters
    by replacing each character `c` with the character 13 positions to the right in
    the alphabet. It’s crucial to prevent overshooting for all characters in the alphabet
    with *index >= 13*. For instance, when shifting character `z` with index 25 by
    13 positions, you obtain index 25 + 13 = 38, which is not a valid index of the
    alphabet. To fix this, you use the modulo operator to ensure that when shifting
    a character beyond the maximum index 25 for character `z`, you restart our calculation
    of the final position of the character to be encrypted with *index == 0* (character
    `a`). Then, you proceed shifting to the right for the remaining of the 13 positions
    that have not already been applied before the restart (see [Figure 6-5](#ch06fig05)).
    For example, character `z` is shifted by 13 positions to index 38 modulo 26 (in
    Python code: `38%26`), which is index 12 or character `m`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-5.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: Preventing overshooting by restarting the shift operation at index
    0, which results in the following shift sequence: 25 > 0 > 1 > . . . > 12*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the critical part of the code that shows exactly how each character
    `c` is shifted by 13 positions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, you find character `c`’s index in the alphabet `abc`. Second, you shift
    the index by adding the integer 13 to character `c`’s index in the alphabet `abc`
    considering our modulo 26 trick (as explained in the previous paragraphs).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the one-liner code snippet is the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To summarize, you’ve learned the special variant of Caesar’s cipher, the ROT13
    algorithm, which shifts each character in a string by 13 positions in the alphabet.
    Shifting it twice by 13 + 13 = 26 index positions results in the original character,
    meaning encryption and decryption use the same algorithm.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Prime Numbers with the Sieve of Eratosthenes**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finding prime numbers is of critical importance for practical applications such
    as cryptography. Many public-key methods are safe (from a cryptographic point
    of view) only because computation of prime factors of large numbers is generally
    inefficient and slow. We’ll make a one-liner that uses an ancient algorithm to
    root out all prime numbers from a range of numbers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A prime number *n* is an integer that’s not divisible without a remainder by
    any other integer, except for *i* and *n*. In other words, for a prime number,
    there are no two integers *a>1* and *b>1* whose product equals the prime number:
    *a**^b**=n*.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to check whether your given number *n* is a prime number. Let’s
    start with a naive algorithm to determine prime numbers (see [Listing 6-7](#list6-7)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-7: Naive implementation to check whether a given number `n` is prime*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm checks all numbers between `2` and `n-1` ➊ to see whether the
    number `n` will divide evenly into it with no remainders ➋. For example, when
    determining whether number `n = 10` is a prime number, the algorithm quickly realizes
    that the expression `n % i == 0` evaluates to `True` for `i = 2`. It has found
    a number `i` that is a divisor of `n`, so `n` cannot be a prime number. In this
    case, the algorithm aborts any further computation and returns `False`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The time complexity for checking a single number is the same as the input `n`:
    in the worst case, the algorithm needs `n` loop iterations to check whether number
    `n` is a prime number.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to calculate all prime numbers from `2` to a certain maximal number
    `m`. You could simply repeat the prime test from [Listing 6-7](#list6-7) `m-1`
    times (see [Listing 6-8](#list6-8)). However, this comes at huge processing cost.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-8: Finding all prime numbers up to a maximal number `m`*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Here we use list comprehension (see [Chapter 2](ch02.xhtml#ch02)) to create
    a list with all prime numbers smaller than `m`. We introduce a `for` loop, meaning
    the algorithm requires `m` function calls of `is_prime(n)` and so the time complexity
    is bounded by `m**2`. The number of operations grows quadratically with the input
    `m`. To find all prime numbers smaller than `m = 100` takes up to `m**2 = 10000`
    operations!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build a one-liner to drastically reduce this time cost.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With this one-liner, we’ll write an algorithm to find all prime numbers up to
    a maximal integer number `m` that is more time efficient than our naive implementation.
    The one-liner in [Listing 6-9](#list6-9) is inspired by an ancient algorithm called
    the Sieve of Eratosthenes, which I’ll explain in this section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-9: One-liner solution implementing the Sieve of Eratosthenes*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: You’ll likely need some additional background knowledge to understand what happens
    here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be frank, I was hesitant to include this one-liner in the book. It’s confusing,
    complex, and unreadable. Still, this is the type of code you face in practice,
    and with this book, I want to ensure you’re able to understand every single line
    of code—even if it takes some time. I stumbled upon a version of this one-liner
    at StackOverflow. It is loosely based on an ancient algorithm called the *Sieve
    of Eratosthenes* that was designed to calculate prime numbers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '*I modified the original StackOverflow one-liner for clarity. The original
    one-liner can be found at* [https://stackoverflow.com/questions/10639861/python-prime-generator-in-one-line/](https://stackoverflow.com/questions/10639861/python-prime-generator-in-one-line/)
    *at the time of this writing.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sieve of Eratosthenes Algorithm**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The algorithm creates (conceptually) a huge array of numbers from `2` to `m`,
    the maximal integer number. All the numbers in the array are *prime candidates*,
    which means that the algorithm considers them to be prime numbers *potentially*
    (but not *necessarily*). During the algorithm, you sieve out the candidates that
    cannot be prime. Only the ones that remain after this filtering process are the
    final prime numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, the algorithm calculates and marks the numbers in this array
    that are not prime numbers. At the end, all unmarked numbers are prime numbers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm repeats the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Start with the first number 2 and increment it in every step of the process
    until you find a prime number *x*. You know that *x* is prime if it is unmarked
    because the fact that *x* is unmarked means that no smaller number than *x* is
    a divisor of *x*—the definition of a prime number.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mark all multiples of number *x* because they are also not prime: number *x*
    is a divisor of all those numbers.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform simple optimization: start marking multiples from number *x × x* instead
    of *2x* because all numbers between *2x* and *x × x* are already marked. There
    is a simple mathematical argument for this that I will describe later. For now,
    know that you can start marking from *x × x*.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figures 6-6](#ch06fig06) to [6-11](#ch06fig11) explain this algorithm step-by-step.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-6.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Initializing the Sieve of Eratosthenes algorithm*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Initially, all numbers between 2 and *m* = 100 are unmarked (white cells). The
    first unmarked number 2 is a prime number.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-7.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: Mark all multiples of 2 because they are not prime. Ignore the
    marked numbers for the rest of the algorithm.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-8.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Mark multiples of 3 as “non-prime.”*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Increment to the next unmarked number, 3\. Because it is unmarked at this point,
    it is a prime number. Because you have marked all multiples of numbers smaller
    than the current number 3, no smaller number is a divisor of 3\. By definition,
    number 3 must be prime. Mark all multiples of 3 because they are not prime. Start
    marking from number 3 × 3 because all multiples of 3 between 3 and 3 × 3 = 9 are
    already marked.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-9.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: Mark multiples of 5 as “non-prime.”*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Go to the next unmarked number, 5 (which is a prime number). Mark all multiples
    of 5\. Start marking from number 5 × 5 because all multiples of 5 between 5 and
    5 × 5 = 25 are already marked.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-10.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Mark multiples of 7 as “non-prime.”*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Increment to the next unmarked number, 7 (which is a prime number). Mark all
    multiples of 7\. Start marking from number 7 × 7 because all multiples of 7 between
    7 and 7 × 7 = 49 are already marked.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: Mark multiples of 11 as “non-prime.”*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Increment to the next unmarked number, 11 (which is a prime number). Mark all
    multiples of 11\. Because you would start marking from number 11 × 11=121, you
    realize that this is already larger than our maximal number *m* = 100\. This causes
    the algorithm to terminate. All remaining unmarked numbers are not divisible by
    any number and are, therefore, prime numbers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sieve of Eratosthenes is much more efficient than the naive algorithm because
    the naive algorithm checks each number *independently*, ignoring all previous
    computations. The Sieve of Eratosthenes, on the other hand, *reuses* results from
    previous computational steps—a common idea in many areas of algorithmic optimization.
    Each time we cross out multiples of a prime number, we essentially save ourselves
    the tedious work of checking whether this multiple is a prime number: we already
    know that it isn’t.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder why we start marking from the squared prime number instead of
    the prime number itself. For example, in the algorithm in [Figure 6-10](#ch06fig10),
    you just found prime number 7 and start marking from number 7 × 7 = 49\. The reason
    is that you already marked all other multiples in previous iterations 7 × 2, 7
    × 3, 7 × 4, 7 × 5, 7 × 6 because you marked all multiples of numbers smaller than
    the current prime number 7: 2, 3, 4, 5, 6.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**One-Liner Explained**'
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Equipped with a thorough conceptual understanding of the algorithm, you can
    now start investigating the one-liner solution:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This one-liner uses the `reduce()` function to remove, one step at a time,
    all marked numbers from the initial set of all numbers between `2` and `n` (in
    the one-liner: `set(range(2, n))`).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'You take this set as the initial value for the set of unmarked values `r` because,
    initially, all values are unmarked. Now the one-liner goes over all numbers `x`
    between `2` and the square root of `n` (in the one-liner: `range(2, int(n**0.5)
    + 1)`) and removes the multiples of `x` from the set `r` (starting at `x**2`)—but
    only if the number `x` is a prime number, known because it is not removed from
    the set `r` at the current time.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Spend 5–15 minutes rereading this explanation and study the different parts
    of the one-liner carefully. I promise you’ll find this exercise worthwhile, as
    it will significantly improve your Python code understanding skills.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating the Fibonacci Series with the reduce() Function**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The popular Italian mathematician Fibonacci (original name: Leonardo of Pisa)
    introduced the Fibonacci numbers in the year 1202 with the surprising observation
    that these numbers have significance in fields as various as math, art, and biology.
    This section will show you how to compute the Fibonacci numbers in a single line
    of code.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Fibonacci series starts with the numbers 0 and 1, and then, each element
    that follows is the sum of the two previous series elements. The Fibonacci series
    has the algorithm built in!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 6-10](#list6-10) calculates a list of the *n* first Fibonacci numbers
    starting with the numbers 0 and 1.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-10: Calculating the Fibonacci series in one line of Python code*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Study this code and take a guess at the output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll again use the powerful `reduce()` function. In general, this function
    is useful if you want to aggregate state information that’s computed on the fly;
    for example, when you use the previous two Fibonacci numbers just computed to
    compute the next Fibonacci number. This is difficult to achieve with list comprehension
    (see [Chapter 2](ch02.xhtml#ch02)), which can’t generally access the values that
    have been newly created from the list comprehension.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: You use the `reduce()` function with three arguments that correspond to `reduce(function,
    iterable, initializer)` to consecutively add the new Fibonacci number to an aggregator
    object that incorporates one value at a time from the `iterable` object as specified
    by the `function`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Here, you use a simple list as the aggregator object with the two initial Fibonacci
    numbers `[0, 1]`. Remember that the aggregator object is handed as the first argument
    to the `function` (in our example, `x`).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is the next element from the `iterable`. However, you initialized
    the `iterable` with `(n-2)` dummy values in order to force the `reduce()` function
    to execute `function` `(n-2)` times (the goal is to find the first `n` Fibonacci
    numbers—but you already have the first two, 0 and 1) You use the throwaway parameter
    `_` to indicate that you are not interested in the dummy values of the `iterable`.
    Instead, you simply append the new Fibonacci number to the aggregator list `x`,
    calculated as the sum of the previous two Fibonacci numbers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**AN ALTERNATIVE MULTILINE SOLUTION**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Repeatedly summing two Fibonacci numbers was already the simple idea of the
    one-liner in [Listing 6-10](#list6-10). [Listing 6-11](#list6-11) gives a beautiful
    alternative solution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-11: One-liner solution to find the Fibonacci numbers in an iterative
    manner*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet was submitted by one of my email subscribers (feel free to
    join us at [https://blog.finxter.com/subscribe/](https://blog.finxter.com/subscribe/))
    and uses list comprehension with side effects: the variable x is updated `n-2`
    times with the new Fibonacci series element. Note that the `append()` function
    has no return value, but returns None, which evaluates to `False`. Thus, the list
    comprehension statement generates a list of integers using the following idea:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It doesn’t seem correct to perform the `or` operation on two integers, but remember
    that the Boolean type is based on the integer type. Every integer value other
    than 0 is interpreted as True. Thus, the `or` operation simply uses the second
    integer value as a return value instead of converting it to an explicit Boolean
    value of True. A fine piece of Python code!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, you’ve improved your understanding of another important pattern
    for Python one-liners: using the `reduce()` function to create a list that dynamically
    uses the freshly updated or added list elements to compute new list elements.
    You will find this useful pattern quite often in practice.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**A Recursive Binary Search Algorithm**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you’ll learn about a basic algorithm every computer scientist
    must know: the binary search algorithm. Binary search has important practical
    applications in many implementations of basic data structures such as sets, trees,
    dictionaries, hash sets, hash tables, maps, and arrays. You use these data structures
    in every single nontrivial program.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In brief, the *binary search algorithm* searches a sorted sequence of values
    `l` for a particular value `x` by repeatedly reducing the size of the sequence
    by half until only a single value is left: either it’s the searched value or it
    doesn’t exist in the sequence. In the following, you will examine this general
    idea in detail.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to search a sorted list for value 56\. A naive algorithm
    would start with the first list element, check whether it’s equal to the value
    56, and move on to the next list element until it has checked all elements or
    found its value. In the worst case, the algorithm goes over every list element.
    A sorted list with 10,000 elements would take approximately 10,000 operations
    to check each list element for equality with the searched value. In algorithmic
    theory language, we say that the runtime complexity is *linear* in the number
    of list elements. The algorithm does not leverage all the available information
    to achieve the greatest efficiency.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The first piece of useful information is that the list is sorted! Using this
    fact, you can create an algorithm that touches only a few elements in the list
    and still knows with absolute certainty whether an element exists in the list.
    The binary search algorithm traverses only *log2(n)* elements (logarithm of base
    2). You can search the same list of 10,000 elements by using only *log2*(10,000)
    < 14 operations!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: For a binary search, you assume the list is sorted in an ascending manner. The
    algorithm starts by checking the middle element. If the middle value is bigger
    than the value you want, you know that all elements between the middle and the
    last list elements are larger than the value you want. The value you want won’t
    exist in this half of the list, so you can immediately reject half of the list
    elements with a single operation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the searched value is larger than the middle element, you can
    reject the first half of the list elements. You then simply repeat the procedure
    of halving the effective list size of elements to be checked in each step of the
    algorithm. [Figure 6-12](#ch06fig12) shows a visual example.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-12.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: Example run of the binary search algorithm*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: If the sublist contains an even number of elements, there’s no obvious middle
    element. In this case, you round down the index of the middle element.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to find the value 56 in the sorted list of eight integer values while
    touching as few elements as possible. The binary search algorithm checks middle
    element *x* (rounding down), then discards the half of the list that 56 cannot
    possibly be in. There are three general results of this check:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Element *x* is larger than 56\. The algorithm ignores the right part of the
    list.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element *x* is smaller than value 56\. The algorithm ignores the left part of
    the list.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element *x* is equal to value 56, as in the last line in [Figure 6-12](#ch06fig12).
    Congratulations—you have just found desired value!
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 6-12](#list6-12) shows a practical implementation of the binary search
    algorithm.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-12: The binary search algorithm*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm takes as arguments a list and a value to search for. It then
    repeatedly halves the search space by using the two variables `lo` and `hi`, which
    define the interval of possible list elements in which the desired value could
    exist: `lo` defines the start index, and `hi` defines the end index of the interval.
    You check which of the cases the mid element falls in and adapt the interval of
    potential elements accordingly by modifying the `lo` and `hi` values as described.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: While this is a perfectly valid, readable, and efficient implementation of the
    binary search algorithm, it’s not a one-liner solution, yet!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll implement the binary search algorithm in a single line of code (see
    [Listing 6-13](#list6-13))!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-13: One-liner solution to implement binary search*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Guess the output of this code snippet!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because binary search lends itself naturally to a recursive approach, studying
    this one-liner will strengthen your intuitive understanding of this important
    computer science concept. Note that I’ve broken this one-liner solution into four
    lines for readability, though you can, of course, write it in a single line of
    code. In this one-liner, I’ve used a recursive way of defining the binary search
    algorithm.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a new function `bs` by using the `lambda` operator with four arguments:
    `l`, `x`, `lo`, and `hi` ➊. The first two arguments `l` and `x` are variables
    with the sorted list and the value to search for. The `lo` and `hi` arguments
    define the minimal and the maximal index of the current sublist to be searched
    for the value `x`. At each recursion level, the code checks a sublist specified
    by the indices `hi` and `lo`, which becomes smaller and smaller by increasing
    the index `lo` and decreasing the index `hi`. After a finite number of steps,
    the condition `lo>hi` holds `True`. The searched sublist is empty—and you haven’t
    found the value `x`. This is the base case of our recursion. Because you haven’t
    found element `x`, you return `-1`, indicating that no such element exists.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: You use the calculation `(lo+hi)//2` to find the middle element of the sublist.
    If this happens to be your desired value, you return the index of that mid element
    ➋. Note that you use integer division to round down to the next integer value
    that can be used as a list index.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: If the mid element is larger than the desired value, it means the elements on
    the right are also larger, so you call the function recursively but adapt the
    `hi` index to consider only list elements on the left of the mid element ➌.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the mid element is smaller than the desired value, there is no
    need to search all elements on the left of the mid element, so you call the function
    recursively but adapt the `lo` index to consider only list elements on the right
    of the mid element ➍.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: When searching for the value `33` in the list `[3, 6, 14, 16, 33, 55, 56, 89]`,
    the result is the index `4`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: This one-liner section has strengthened your general code understanding regarding
    features such as conditional execution, basic keywords, and arithmetic operations,
    as well as the important topic of programmatic sequence indexing. More important,
    you’ve learned how to use recursion to make complex problems easier.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**A Recursive Quicksort Algorithm**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll build a one-liner to use the popular algorithm *Quicksort*, a sorting
    algorithm that, as the name suggests, quickly sorts the data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Quicksort is both a popular question in many code interviews (asked by Google,
    Facebook, and Amazon) and a practical sorting algorithm that’s fast, concise,
    and readable. Because of its elegance, most introductory algorithm classes cover
    Quicksort.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort sorts a list by recursively dividing the big problem into smaller
    problems and combining the solutions from the smaller problems in a way that it
    solves the big problem.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve each smaller problem, the same strategy is used recursively: the smaller
    problems are divided into even smaller subproblems, solved separately, and combined,
    placing Quicksort in the class of *Divide and Conquer* algorithms.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort selects a *pivot* element and then places all elements that are larger
    than the pivot to the right, and all elements that are smaller than or equal to
    the pivot to the left. This divides the big problem of sorting the list into two
    smaller subproblems: sorting two smaller lists. You then repeat this procedure
    recursively until you obtain a list with zero elements that, being sorted, causes
    the recursion to terminate.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-13](#ch06fig13) shows the Quicksort algorithm in action.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig6-13.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: Example run of the Quicksort algorithm*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-13](#ch06fig13) shows the Quicksort algorithm on a list of unsorted
    integers [4, 1, 8, 9, 3, 8, 1, 9, 4]. First, it selects 4 as the pivot element,
    splits up the list into an unsorted sublist [1, 3, 1, 4] with all elements that
    are smaller than or equal to the pivot, and an unsorted sublist [8, 9, 8, 9] with
    all elements that are larger than the pivot.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Quicksort algorithm is called recursively on the two unsorted sublists
    to sort them. As soon as the sublists contain maximally one element, they are
    sorted by definition, and the recursion ends.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: At every recursion level, the three sublists (left, pivot, right) are concatenated
    before the resulting list is handed to the higher recursion level.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll create a function `q` that implements the Quicksort algorithm in a single
    line of Python and sorts any argument given as a list of integers (see [Listing
    6-14](#list6-14)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-14: One-liner solution for the Quicksort algorithm using recursion*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Now, can you guess—one last time—the output of the code?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The one-liner directly resembles the algorithm we just discussed. First, you
    create a new lambda function `q` that takes one list argument `l` to sort. From
    a high-level perspective, the lambda function has the following basic structure:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the recursion base case—that is, the case that the list is empty and, therefore,
    trivially sorted—the lambda function returns the empty list `[]`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'In any other case, the function selects the pivot element as the first element
    of list `l`, and divides all elements into two sublists (`left` and `right`) based
    on whether they are smaller or larger than the pivot. To achieve this, you use
    simple list comprehension (see [Chapter 2](ch02.xhtml#ch02)). As the two sublists
    are not necessarily sorted, you recursively execute the Quicksort algorithm on
    them too. Finally, you combine all three lists and return the sorted list. Therefore,
    the result is as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Summary**'
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned important algorithms in computer science addressing
    a wide range of topics including anagrams, palindromes, powersets, permutations,
    factorials, prime numbers, Fibonacci numbers, obfuscation, searching, and sorting.
    Many of these form the basis of more advanced algorithms and contain the seeds
    of a thorough algorithmic education. Advancing your knowledge of algorithms and
    algorithmic theory is one of the most effective ways to improve as a coder. I
    would even say that the lack of algorithmic understanding is the number one reason
    most intermediate coders feel stuck in their learning progress.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: To help you get unstuck, I regularly explain new algorithms in my “Coffee Break
    Python” email series for continuous improvement (visit [*https://blog.finxter.com/subscribe/*](https://blog.finxter.com/subscribe/)).
    I appreciate you spending your valuable time and effort studying all the one-liner
    code snippets and explanations, and I hope you can already see how your skills
    have improved. Based on my experience teaching thousands of Python learners, more
    than half the intermediate coders struggle with understanding basic Python one-liners.
    With commitment and persistence, you have a good chance of leaving the intermediate
    coders behind and becoming a Python master (or at least a top 10 percent coder).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
