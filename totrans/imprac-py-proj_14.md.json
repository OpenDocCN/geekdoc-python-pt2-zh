["```py\n➊ import os\n   import math\n   import random\n   import pygame as pg\n\n➋ WHITE = (255, 255, 255)\n   BLACK = (0, 0, 0)\n   RED = (255, 0, 0)\n   GREEN = (0, 255, 0)\n   LT_BLUE = (173, 216, 230)\n```", "```py\n➊ class Satellite(pg.sprite.Sprite):\n       \"\"\"Satellite object that rotates to face planet & crashes & burns.\"\"\"\n\n    ➋ def __init__(self, background):\n        ➌ super().__init__()\n        ➍ self.background = background\n        ➎ self.image_sat = pg.image.load(\"satellite.png\").convert()\n           self.image_crash = pg.image.load(\"satellite_crash_40x33.png\").convert()\n        ➏ self.image = self.image_sat\n        ➐ self.rect = self.image.get_rect()\n        ➑ self.image.set_colorkey(BLACK)  # sets transparent color\n```", "```py\n        ➊ self.x = random.randrange(315, 425)\n           self.y = random.randrange(70, 180)\n        ➋ self.dx = random.choice([-3, 3])\n        ➌ self.dy = 0\n        ➍ self.heading = 0  # initializes dish orientation\n        ➎ self.fuel = 100\n           self.mass = 1\n           self.distance = 0  # initializes distance between satellite & planet\n        ➏ self.thrust = pg.mixer.Sound('thrust_audio.ogg')\n        ➐ self.thrust.set_volume(0.07)  # valid values are 0-1\n```", "```py\n    ➊ def thruster(self, dx, dy):\n           \"\"\"Execute actions associated with firing thrusters.\"\"\"\n        ➋ self.dx += dx\n           self.dy += dy\n        ➌ self.fuel -= 2\n        ➍ self.thrust.play()\n\n    ➎ def check_keys(self):\n           \"\"\"Check if user presses arrow keys & call thruster() method.\"\"\"\n        ➏ keys = pg.key.get_pressed()\n           # fire thrusters\n        ➐ if keys[pg.K_RIGHT]:\n            ➑ self.thruster(dx=0.05, dy=0)\n           elif keys[pg.K_LEFT]:\n               self.thruster(dx=-0.05, dy=0)\n           elif keys[pg.K_UP]:\n               self.thruster(dx=0, dy=-0.05)\n           elif keys[pg.K_DOWN]:\n               self.thruster(dx=0, dy=0.05)\n```", "```py\n    ➊ def locate(self, planet):\n           \"\"\"Calculate distance & heading to planet.\"\"\"\n        ➋ px, py = planet.x, planet.y\n        ➌ dist_x = self.x - px\n           dist_y = self.y - py\n           # get direction to planet to point dish\n        ➍ planet_dir_radians = math.atan2(dist_x, dist_y)\n        ➎ self.heading = planet_dir_radians * 180 / math.pi\n        ➏ self.heading -= 90  # sprite is traveling tail-first\n        ➐ self.distance = math.hypot(dist_x, dist_y)\n```", "```py\n    ➊ def rotate(self):\n           \"\"\"Rotate satellite using degrees so dish faces planet.\"\"\"\n        ➋ self.image = pg.transform.rotate(self.image_sat, self.heading)\n        ➌ self.rect = self.image.get_rect()\n\n    ➍ def path(self):\n           \"\"\"Update satellite’s position & draw line to trace orbital path.\"\"\"\n        ➎ last_center = (self.x, self.y)\n        ➏ self.x += self.dx\n           self.y += self.dy\n        ➐ pg.draw.line(self.background, WHITE, last_center, (self.x, self.y))\n```", "```py\n    ➊ def update(self):\n           \"\"\"Update satellite object during game.\"\"\"\n        ➋ self.check_keys()\n        ➌ self.rotate()\n        ➍ self.path()\n        ➎ self.rect.center = (self.x, self.y)\n           # change image to fiery red if in atmosphere\n        ➏ if self.dx == 0 and self.dy == 0:\n               self.image = self.image_crash\n               self.image.set_colorkey(BLACK)\n```", "```py\n➊ class Planet(pg.sprite.Sprite):\n       \"\"\"Planet object that rotates & projects gravity field.\"\"\"\n\n    ➋ def __init__(self):\n           super().__init__()\n        ➌ self.image_mars = pg.image.load(\"mars.png\").convert()\n           self.image_water = pg.image.load(\"mars_water.png\").convert()\n        ➍ self.image_copy = pg.transform.scale(self.image_mars, (100, 100))\n        ➎ self.image_copy.set_colorkey(BLACK)\n        ➏ self.rect = self.image_copy.get_rect()\n           self.image = self.image_copy\n        ➐ self.mass = 2000\n        ➑ self.x = 400\n           self.y = 320\n           self.rect.center = (self.x, self.y)\n        ➒ self.angle = math.degrees(0)\n           self.rotate_by = math.degrees(0.01)\n```", "```py\n    ➊ def rotate(self):\n           \"\"\"Rotate the planet image with each game loop.\"\"\"\n        ➋ last_center = self.rect.center\n        ➌ self.image = pg.transform.rotate(self.image_copy, self.angle)\n           self.rect = self.image.get_rect()\n        ➍ self.rect.center = last_center\n        ➎ self.angle += self.rotate_by\n```", "```py\n    ➊ def gravity(self, satellite):\n\n           \"\"\"Calculate impact of gravity on satellite.\"\"\"\n\n        ➋ G = 1.0  # gravitational constant for game\n\n        ➌ dist_x = self.x - satellite.x\n\n           dist_y = self.y - satellite.y\n\n           distance = math.hypot(dist_x, dist_y)\n\n           # normalize to a unit vector\n\n        ➍ dist_x /= distance\n\n           dist_y /= distance\n\n           # apply gravity (dx & dy represent pixels/frame)\n\n        ➎ force = G * (satellite.mass * self.mass) / (math.pow(distance, 2))\n\n        ➏ satellite.dx += (dist_x * force)\n\n           satellite.dy += (dist_y * force)\n\n    ➐ def update(self):\n\n           \"\"\"Call the rotate method.\"\"\"\n\n           self.rotate()\n```", "```py\n➊ def calc_eccentricity(dist_list):\n       \"\"\"Calculate & return eccentricity from list of radii.\"\"\"\n    ➋ apoapsis = max(dist_list)\n       periapsis = min(dist_list)\n    ➌ eccentricity = (apoapsis - periapsis) / (apoapsis + periapsis)\n       return eccentricity\n```", "```py\n➊ def instruct_label(screen, text, color, x, y):\n       \"\"\"Take screen, list of strings, color, & origin & render text to screen.\"\"\"\n    ➋ instruct_font = pg.font.SysFont(None, 25)\n    ➌ line_spacing = 22\n    ➍ for index, line in enumerate(text):\n           label = instruct_font.render(line, True, color, BLACK)\n           screen.blit(label, (x, y + index * line_spacing))\n\n➎ def box_label(screen, text, dimensions):\n       \"\"\"Make fixed-size label from screen, text & left, top, width, height.\"\"\"\n       readout_font = pg.font.SysFont(None, 27)\n    ➏ base = pg.Rect(dimensions)\n    ➐ pg.draw.rect(screen, WHITE, base, 0)\n    ➑ label = readout_font.render(text, True, BLACK)\n    ➒ label_rect = label.get_rect(center=base.center)\n    ➓ screen.blit(label, label_rect)\n```", "```py\n➊ def mapping_on(planet):\n       \"\"\"Show soil moisture image of planet.\"\"\"\n    ➋ last_center = planet.rect.center\n    ➌ planet.image_copy = pg.transform.scale(planet.image_water, (100, 100))\n    ➍ planet.image_copy.set_colorkey(BLACK)\n       planet.rect = planet.image_copy.get_rect()\n       planet.rect.center = last_center\n\n➎ def mapping_off(planet):\n       \"\"\"Restore normal planet image.\"\"\"\n    ➏ planet.image_copy = pg.transform.scale(planet.image_mars, (100, 100))\n       planet.image_copy.set_colorkey(BLACK)\n```", "```py\n➊ def cast_shadow(screen):\n       \"\"\"Add optional terminator & shadow behind planet to screen.\"\"\"\n    ➋ shadow = pg.Surface((400, 100), flags=pg.SRCALPHA)  # tuple is w,h\n    ➌ shadow.fill((0, 0, 0, 210))  # last number sets transparency\n       screen.blit(shadow, (0, 270))  # tuple is top left coordinates\n```", "```py\ndef main():\n       \"\"\"Set up labels & instructions, create objects & run the game loop.\"\"\"\n    ➊ pg.init()  # initialize pygame\n\n       # set up display:\n    ➋ os.environ['SDL_VIDEO_WINDOW_POS'] = '700, 100'  # set game window origin\n    ➌ screen = pg.display.set_mode((800, 645), pg.FULLSCREEN)\n    ➍ pg.display.set_caption(\"Mars Orbiter\")\n    ➎ background = pg.Surface(screen.get_size())\n\n    ➏ pg.mixer.init()  # for sound effects\n\n    ➐ intro_text = [\n           ' The Mars Orbiter experienced an error during Orbit insertion.',\n           ' Use thrusters to correct to a circular mapping orbit without',\n           ' running out of propellant or burning up in the atmosphere.'\n           ]\n\n       instruct_text1 = [\n           'Orbital altitude must be within 69-120 miles',\n           'Orbital Eccentricity must be < 0.05',\n           'Avoid top of atmosphere at 68 miles'\n           ]\n\n       instruct_text2 = [\n           'Left Arrow = Decrease Dx',\n           'Right Arrow = Increase Dx',\n           'Up Arrow = Decrease Dy',\n           'Down Arrow = Increase Dy',\n           'Space Bar = Clear Path',\n           'Escape = Exit Full Screen'\n           ]\n```", "```py\n       # instantiate planet and satellite objects\n    ➊ planet = Planet()\n    ➋ planet_sprite = pg.sprite.Group(planet)\n    ➌ sat = Satellite(background)\n    ➍ sat_sprite = pg.sprite.Group(sat)\n\n       # for circular orbit verification\n    ➎ dist_list = []\n    ➏ eccentricity = 1\n    ➐ eccentricity_calc_interval = 5  # optimized for 120 mile altitude\n\n       # time keeping\n    ➑ clock = pg.time.Clock()\n       fps = 30\n       tick_count = 0\n\n       # for soil moisture mapping functionality\n    ➒ mapping_enabled = False\n```", "```py\n    ➊ running = True\n       while running:\n        ➋ clock.tick(fps)\n           tick_count += 1\n        ➌ dist_list.append(sat.distance)\n\n           # get keyboard input\n        ➍ for event in pg.event.get():\n            ➎ if event.type == pg.QUIT:  # close window\n                   running = False\n            ➏ elif event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:\n                   screen = pg.display.set_mode((800, 645))  # exit full screen\n            ➐ elif event.type == pg.KEYDOWN and event.key == pg.K_SPACE:\n                   background.fill(BLACK)  # clear path\n            ➑ elif event.type == pg.KEYUP:\n                ➒ sat.thrust.stop()  # stop sound\n                   mapping_off(planet)  # turn off moisture map view\n            ➓ elif mapping_enabled:\n                   if event.type == pg.KEYDOWN and event.key == pg.K_m:\n                       mapping_on(planet)\n```", "```py\n           # get heading & distance to planet & apply gravity\n        ➊ sat.locate(planet)\n           planet.gravity(sat)\n\n           # calculate orbital eccentricity\n        ➋ if tick_count % (eccentricity_calc_interval * fps) == 0:\n               eccentricity = calc_eccentricity(dist_list)\n            ➌ dist_list = []\n\n           # re-blit background for drawing command - prevents clearing path\n        ➍ screen.blit(background, (0, 0))\n\n           # Fuel/Altitude fail conditions\n        ➎ if sat.fuel <= 0:\n            ➏ instruct_label(screen, ['Fuel Depleted!'], RED, 340, 195)\n               sat.fuel = 0\n               sat.dx = 2\n        ➐ elif sat.distance <= 68:\n               instruct_label(screen, ['Atmospheric Entry!'], RED, 320, 195)\n               sat.dx = 0\n               sat.dy = 0\n```", "```py\n           # enable mapping functionality\n        ➊ if eccentricity < 0.05 and sat.distance >= 69 and sat.distance <= 120:\n            ➋ map_instruct = ['Press & hold M to map soil moisture']\n               instruct_label(screen, map_instruct, LT_BLUE, 250, 175)\n            ➌ mapping_enabled = True\n           else:\n               mapping_enabled = False\n\n        ➍ planet_sprite.update()\n        ➎ planet_sprite.draw(screen)\n           sat_sprite.update()\n           sat_sprite.draw(screen)\n```", "```py\n           # display intro text for 15 seconds\n        ➊ if pg.time.get_ticks() <= 15000:  # time in milliseconds\n               instruct_label(screen, intro_text, GREEN, 145, 100)\n\n           # display telemetry and instructions\n        ➋ box_label(screen, 'Dx', (70, 20, 75, 20))\n           box_label(screen, 'Dy', (150, 20, 80, 20))\n           box_label(screen, 'Altitude', (240, 20, 160, 20))\n           box_label(screen, 'Fuel', (410, 20, 160, 20))\n           box_label(screen, 'Eccentricity', (580, 20, 150, 20))\n\n        ➌ box_label(screen, '{:.1f}'.format(sat.dx), (70, 50, 75, 20))\n           box_label(screen, '{:.1f}'.format(sat.dy), (150, 50, 80, 20))\n           box_label(screen, '{:.1f}'.format(sat.distance), (240, 50, 160, 20))\n           box_label(screen, '{}'.format(sat.fuel), (410, 50, 160, 20))\n           box_label(screen, '{:.8f}'.format(eccentricity), (580, 50, 150, 20))\n\n        ➍ instruct_label(screen, instruct_text1, WHITE, 10, 575)\n           instruct_label(screen, instruct_text2, WHITE, 570, 510)\n\n           # add terminator & border\n        ➎ cast_shadow(screen)\n        ➏ pg.draw.rect(screen, WHITE, (1, 1, 798, 643), 1)\n\n        ➐ pg.display.flip()\n\n➑ if __name__ == \"__main__\":\n       main()\n```"]