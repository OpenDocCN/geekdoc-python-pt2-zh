["```py\nexiftool -b -MPImage2 photo.jpg > depth.jpg\n\n```", "```py\ndef createRandomTile(dims):\n    # create image\n  ❶ img = Image.new('RGB', dims)\n  ❷ draw = ImageDraw.Draw(img)\n    # set the radius of a random circle to 1% of\n    # width or height, whichever is smaller\n  ❸ r = int(min(*dims)/100)\n    # number of circles\n  ❹ n = 1000\n    # draw random circles\n    for i in range(n):\n        # -r makes sure that the circles stay inside and aren't cut off\n        # at the edges of the image so that they'll look better when tiled\n      ❺ x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)\n      ❻ fill = (random.randint(0, 255), random.randint(0, 255),\n                random.randint(0, 255))\n      ❼ draw.ellipse((x-r, y-r, x+r, y+r), fill)\n    return img\n\n```", "```py\n>>> `import autos`\n>>> `img = autos.createRandomTile((256, 256))`\n>>> `img.save('out.png')`\n>>> `exit()`\n\n```", "```py\ndef createTiledImage(tile, dims):\n    # create the new image\n  ❶ img = Image.new('RGB', dims)\n    W, H = dims\n    w, h = tile.size\n    # calculate the number of tiles needed\n  ❷ cols = int(W/w) + 1\n  ❸ rows = int(H/h) + 1\n    # paste the tiles into the image\n    for i in range(rows):\n        for j in range(cols):\n          ❹ img.paste(tile, (j*w, i*h))\n    # output the image\n    return img\n\n```", "```py\ndef createAutostereogram(dmap, tile):\n    # convert the depth map to a single channel if needed\n  ❶ if dmap.mode != 'L':\n        dmap = dmap.convert('L')\n    # if no image is specified for a tile, create a random circles tile\n  ❷ if not tile:\n        tile = createRandomTile((100, 100))\n    # create an image by tiling\n  ❸ img = createTiledImage(tile, dmap.size)\n    # create a shifted image using depth map values\n  ❹ sImg = img.copy()\n    # get access to image pixels by loading the Image object first\n  ❺ pixD = dmap.load()\n    pixS = sImg.load()\n    # shift pixels horizontally based on depth map\n  ❻ cols, rows = sImg.size\n    for j in range(rows):\n        for i in range(cols):\n          ❼ xshift = pixD[i, j]/10\n          ❽ xpos = i - tile.size[0] + xshift\n          ❾ if xpos > 0 and xpos < cols:\n              ❿ pixS[i, j] = pixS[xpos, j]\n    # display the shifted image\n    return sImg\n\n```", "```py\ndef main():\n    # create a parser\n    parser = argparse.ArgumentParser(description=\"Autostereograms...\")\n    # add expected arguments\n  ❶ parser.add_argument('--depth', dest='dmFile', required=True)\n    parser.add_argument('--tile', dest='tileFile', required=False)\n    parser.add_argument('--out', dest='outFile', required=False)\n    # parse args\n    args = parser.parse_args()\n    # set the output file\n    outFile = 'as.png'\n    if args.outFile:\n        outFile = args.outFile\n    # set tile\n    tileFile = False\n    if args.tileFile:\n        tileFile = Image.open(args.tileFile)\n\n```", "```py\n$ `python autos.py --depth data/stool-depth.png`\n\n```", "```py\n$ `python autos.py --depth data/stool-depth.png –-tile data/escher-tile.jpg`\n\n```", "```py\n\"\"\"\nautos.py\nA program to create autostereograms.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport sys, random, argparse\nfrom PIL import Image, ImageDraw\n# create spacing/depth example\ndef createSpacingDepthExample():\n    tiles = [Image.open('test/a.png'), Image.open('test/b.png'),\n             Image.open('test/c.png')]\n    img = Image.new('RGB', (600, 400), (0, 0, 0))\n    spacing = [10, 20, 40]\n    for j, tile in enumerate(tiles):\n        for i in range(8):\n            img.paste(tile, (10 + i*(100 + j*10), 10 + j*100))\n    img.save('sdepth.png')\n# create image filled with random dots\ndef createRandomTile(dims):\n    # create image\n    img = Image.new('RGB', dims)\n    draw = ImageDraw.Draw(img)\n    # calculate radius - % of min dimension\n    r = int(min(*dims)/100)\n    # number of dots\n    n = 1000\n    # draw random circles\n    for i in range(n):\n        # -r is used so circle stays inside - cleaner for tiling\n        x, y = random.randint(r, dims[0]-r), random.randint(r, dims[1]-r)\n        fill = (random.randint(0, 255), random.randint(0, 255),\n                random.randint(0, 255))\n        draw.ellipse((x-r, y-r, x+r, y+r), fill)\n    # return image\n    return img\n# create a larger image of size dims by tiling the given image\ndef createTiledImage(tile, dims):\n    # create output image\n    img = Image.new('RGB', dims)\n    W, H = dims\n    w, h = tile.size\n    # calculate # of tiles needed\n    cols = int(W/w) + 1\n    rows = int(H/h) + 1\n    # paste tiles\n    for i in range(rows):\n        for j in range(cols):\n            img.paste(tile, (j*w, i*h))\n    # output image\n    return img\n# create a depth map for testing:\ndef createDepthMap(dims):\n    dmap = Image.new('L', dims)\n    dmap.paste(10, (200, 25, 300, 125))\n    dmap.paste(30, (200, 150, 300, 250))\n    dmap.paste(20, (200, 275, 300, 375))\n    return dmap\n# given a depth map (image) and an input image, create a new image\n# with pixels shifted according to depth\ndef createDepthShiftedImage(dmap, img):\n    # size check\n    assert dmap.size == img.size\n    # create shifted image\n    sImg = img.copy()\n    # get pixel access\n    pixD = dmap.load()\n    pixS = sImg.load()\n    # shift pixels output based on depth map\n    cols, rows = sImg.size\n    for j in range(rows):\n        for i in range(cols):\n            xshift = pixD[i, j]/10\n            xpos = i - 140 + xshift\n            if xpos > 0 and xpos < cols:\n                pixS[i, j] = pixS[xpos, j]\n    # return shifted image\n    return sImg\n# given a depth map (image) and an input image, create a new image\n# with pixels shifted according to depth\ndef createAutostereogram(dmap, tile):\n    # convert depth map to single channel if needed\n    if dmap.mode != 'L':\n        dmap = dmap.convert('L')\n    # if no tile specified, use random image\n    if not tile:\n        tile = createRandomTile((100, 100))\n    # create an image by tiling\n    img = createTiledImage(tile, dmap.size)\n    # create shifted image\n    sImg = img.copy()\n    # get pixel access\n    pixD = dmap.load()\n    pixS = sImg.load()\n    # shift pixels output based on depth map\n    cols, rows = sImg.size\n    for j in range(rows):\n        for i in range(cols):\n            xshift = pixD[i, j]/10\n            xpos = i - tile.size[0] + xshift\n            if xpos > 0 and xpos < cols:\n                pixS[i, j] = pixS[xpos, j]\n    # return shifted image\n    return sImg\n# main() function\ndef main():\n    # use sys.argv if needed\n    print('creating autostereogram...')\n    # create parser\n    parser = argparse.ArgumentParser(description=\"Autostereograms...\")\n    # add expected arguments\n    parser.add_argument('--depth', dest='dmFile', required=True)\n    parser.add_argument('--tile', dest='tileFile', required=False)\n    parser.add_argument('--out', dest='outFile', required=False)\n    # parse args\n    args = parser.parse_args()\n    # set output file\n    outFile = 'as.png'\n    if args.outFile:\n        outFile = args.outFile\n    # set tile\n    tileFile = False\n    if args.tileFile:\n        tileFile = Image.open(args.tileFile)\n    # open depth map\n    dmImg = Image.open(args.dmFile)\n    # create stereogram\n    asImg = createAutostereogram(dmImg, tileFile)\n    # write output\n    asImg.save(outFile)\n# call main\nif __name__ == '__main__':\n    main()\n\n```"]