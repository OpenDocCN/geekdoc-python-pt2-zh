- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FUNCTIONAL PROGRAMMING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'Many Python developers are unaware of the extent to which you can use functional
    programming in Python, which is a shame: with few exceptions, functional programming
    allows you to write more concise and efficient code. Moreover, Python’s support
    for functional programming is extensive.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover some of the functional programming aspects of Python,
    including creating and using generators. You’ll learn about the most useful functional
    packages and functions available and how to use them in combination to get the
    most efficient code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to get serious about functional programming, here’s my advice:
    take a break from Python and learn a hugely functional programming language, such
    as Lisp. I know it might sound strange to talk about Lisp in a Python book, but
    playing with Lisp for several years taught me how to “think functional.” You may
    not develop the thought processes necessary to make full use of functional programming
    if all your experience comes from imperative and object-oriented programming.
    Lisp isn’t purely functional itself, but it has more focus on functional programming
    than you’ll find in Python.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Pure Functions**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you write code using a functional style, your functions are designed to
    have no side effects: instead, they take an input and produce an output without
    keeping state or modifying anything not reflected in the return value. Functions
    that follow this ideal are referred to as *purely functional*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example of a regular, non-pure function that removes the
    last item in a list:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is a pure version of the same function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We define a `butlast()` function to work like `butlast` in Lisp, in that it
    returns the list without the last element *without* modifying the original list.
    Instead, it returns a copy of the list that has the modifications in place, allowing
    us to keep the original.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The practical advantages of functional programming include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** Writing with a functional style forces a certain degree of separation
    in solving your individual problems and makes sections of code easier to reuse
    in other contexts. Since the function does not depend on any external variable
    or state, calling it from a different piece of code is straightforward.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Brevity** Functional programming is often less verbose than other paradigms.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency** Purely functional functions are thread-safe and can run concurrently.
    Some functional languages do this automatically, which can be a big help if you
    ever need to scale your application, though this is not quite the case yet in
    Python.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Testability** Testing a functional program is incredibly easy: all you need
    is a set of inputs and an expected set of outputs. They are *idempotent*, meaning
    that calling the same function over and over with the same arguments will always
    return the same result.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Generators**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *generator* is an object that behaves like an iterator, in that it generates
    and returns a value on each call of its `next()` method until a `StopIteration`
    is raised. Generators, first introduced in PEP 255, offer an easy way to create
    objects that implement the *iterator protocol*. While writing generators in a
    functional style is not strictly necessary, doing so makes them easier to write
    and debug and is a common practice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a generator, just write a regular Python function that contains a
    `yield` statement. Python will detect the use of `yield` and tag the function
    as a generator. When execution reaches the `yield` statement, the function returns
    a value as with a `return` statement, but with one notable difference: the interpreter
    will save a stack reference, and this will be used to resume the function’s execution
    when the `next()` function is called again.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When functions are executed, the chaining of their execution produces a *stack*—function
    calls are said to be stacked on each other. When a function returns, it’s removed
    from the stack, and the value it returns is passed to the calling function. In
    the case of a generator, the function does not really return but *yields* instead.
    Python therefore saves the state of the function as a stack reference, resuming
    the execution of the generator at the point it saved when the next iteration of
    the generator is needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Generator***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned, you create a generator by writing a normal function and including
    `yield` in the function’s body. [Listing 8-1](ch08.xhtml#ch8list1) creates a generator
    called `mygenerator()` that includes three yields, meaning it will iterate with
    the next three calls to `next()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-1: Creating a generator with three iterations*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: When it runs out of `yield` statements, `StopIteration` is raised at the next
    call to `next()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: In Python, generators keep a reference to the stack when a function yields something,
    and they resume this stack when a call to `next()` is executed again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The naive approach when iterating over any data without using generators is
    to build the entire list first, which often consumes memory wastefully.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to find the first number between 1 and 10,000,000 that’s equal
    to 50,000\. Sounds easy, doesn’t it? Let’s make this a challenge. We’ll run Python
    with a memory constraint of 128MB and try the naive approach of first building
    the entire list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This naive method first tries to build the list, but if we run the program
    so far:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Uh-oh. Turns out we can’t build a list of 10 million items with only 128MB of
    memory!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '*In Python 3, range() returns a generator when iterated. To get a generator
    in Python 2, you have to use xrange() instead. This function doesn’t exist in
    Python 3 anymore, since it’s redundant.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try using a generator instead, with the same 128MB restriction:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, our program executes without issue. When it is iterated over, the
    `range()` class returns a generator that dynamically generates our list of integers.
    Better still, since we are only interested in the 50,000th number, instead of
    building the full list, the generator only had to generate 50,000 numbers before
    it stopped.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: By generating values on the fly, generators allow you to handle large data sets
    with minimal consumption of memory and processing cycles. Whenever you need to
    work with a huge number of values, generators can help you handle them efficiently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '***Returning and Passing Values with yield***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `yield` statement also has a less commonly used feature: it can return a
    value in the same way as a function call. This allows us to pass a value to a
    generator by calling its `send()` method. As an example of using `send()`, we’ll
    write a function called `shorten()` that takes a list of strings and returns a
    list consisting of those same strings, only truncated ([Listing 8-2](ch08.xhtml#ch8list2)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-2: Returning and using a value with send()*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve written a function called `shorten()` that takes a list
    of strings and returns a list consisting of those same strings, only truncated.
    The length of each truncated string is equal to the number of vowels in the previous
    string: *loremipsum* has four vowels, so the second value returned by the generator
    will be the first four letters of *dolorsit*; *dolo* has only two vowels, so *ametfoobar*
    will be truncated to its first two letters *am*. The generator then stops and
    raises `StopIteration`. Our generator thus returns:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using `yield` and `send()` in this fashion allows Python generators to function
    like *coroutines* seen in Lua and other languages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 289 introduced generator expressions, making it possible to build one-line
    generators using a syntax similar to list comprehension:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `gen` is a generator, just as if we had used the `yield` statement.
    The `yield` in this case is implicit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting Generators***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To determine whether a function is considered a generator, use `inspect.isgeneratorfunction()`.
    In [Listing 8-3](ch08.xhtml#ch8list3), we create a simple generator and inspect
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-3: Checking whether a function is a generator*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Import the `inspect` package to use `isgeneratorfunction()` and then just pass
    it the name of the function to inspect. Reading the source code of `inspect.isgeneratorfunction()`
    gives us some insight into how Python marks functions as being generators (see
    [Listing 8-4](ch08.xhtml#ch8list4)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-4: Source code of inspect.isgeneratorfunction()*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The `isgeneratorfunction()` function checks that the object is a function or
    a method and that its code has the `CO_GENERATOR` flag set. This example shows
    how easy it is to understand how Python works under the hood.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inspect` package provides the `inspect.getgeneratorstate()` function,
    which gives the current state of the generator. We’ll use it on `mygenerator()`
    here at different points of execution:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows us to determine whether the generator is waiting to be run for the
    first time (`GEN_CREATED`) ➊, waiting to be resumed by a call to `next()` (`GEN_SUSPENDED`)
    ➋, or finished running (`GEN_CLOSED`) ➌. This might come in handy to debug your
    generators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: List comprehension, or *listcomp* for short, allows you to define a list’s contents
    inline with its declaration. To make a list into a listcomp, you must wrap it
    in square brackets as usual, but also include an expression that will generate
    the items in the list and a `for` loop to loop through them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a list without using list comprehension:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And this next example uses list comprehension to make the same list with a
    single line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using a list comprehension presents two advantages: code written using listcomps
    is usually shorter and therefore compiles down to fewer operations for Python
    to perform. Rather than creating a list and calling `append` over and over, Python
    can just create the list of items and move them into a new list in a single operation.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use multiple `for` statements together and use `if` statements to filter
    out items. Here we create a list of words and use list comprehension to capitalize
    each item, split up items with multiple words into single words, and delete the
    extraneous *or* :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code has two `for` loops: the first iterates over the text lines, while
    the second iterates over words in each of those lines. The final `if` statement
    filters out words that start with *or* to exclude them from the final list.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Using list comprehension rather than `for` loops is a neat way to define lists
    quickly. Since we’re still talking about functional programming, it’s worth noting
    that lists built through list comprehension shouldn’t rely on changing the program’s
    state: you are not expected to modify any variable while building the list. This
    usually makes the lists more concise and easier to read than lists made without
    listcomp.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there’s also syntax for building dictionaries or sets in the same
    fashion, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Functional Functions Functioning**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might repeatedly encounter the same set of problems when manipulating data
    using functional programming. To help you deal with this situation efficiently,
    Python includes a number of functions for functional programming. This section
    will give you a quick overview of some of these built-in functions that allow
    you to build fully functional programs. Once you have an idea of what’s available,
    I encourage you to research further and try out functions where they might apply
    in your own code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '***Applying Functions to Items with map()***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `map()` function takes the form `map(function`, iterable) and applies `function`
    to each item in `iterable` to return a list in Python 2 or an iterable `map` object
    in Python 3, as shown in [Listing 8-5](ch08.xhtml#ch8list5).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数的形式为 `map(function, iterable)`，并将 `function` 应用到 `iterable` 中的每一项，返回
    Python 2 中的一个列表，或 Python 3 中的一个可迭代的 `map` 对象，如 [列表 8-5](ch08.xhtml#ch8list5) 所示。'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-5: Using map() in Python 3*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：在 Python 3 中使用 map()*'
- en: 'You could write an equivalent of `map()` using list comprehension, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表推导式编写一个等效的 `map()`，如下所示：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***Filtering Lists with filter()***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 filter() 过滤列表***'
- en: 'The `filter()` function takes the form `filter(function or None`, iterable)
    and filters the items in `iterable` based on the result returned by `function`.
    This will return a list in Python 2 or an iterable `filter` object in Python 3:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数的形式为 `filter(function or None, iterable)`，它根据 `function` 返回的结果过滤
    `iterable` 中的项。在 Python 2 中，这将返回一个列表，在 Python 3 中则返回一个可迭代的 `filter` 对象：'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You could also write an equivalent of `filter()` using list comprehension,
    like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用列表推导式编写一个等效的 `filter()`，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***Getting Indexes with enumerate()***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 enumerate() 获取索引***'
- en: 'The `enumerate()` function takes the form `enumerate(iterable`[, start]) and
    returns an iterable object that provides a sequence of tuples, each consisting
    of an integer index (starting with `start`, if provided) and the corresponding
    item in `iterable`. This function is useful when you need to write code that refers
    to array indexes. For example, instead of writing this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 函数的形式为 `enumerate(iterable [,start])`，并返回一个可迭代的对象，该对象提供一系列元组，每个元组包含一个整数索引（如果提供了
    `start`，则从 `start` 开始）和 `iterable` 中对应的项。当你需要编写引用数组索引的代码时，这个函数非常有用。例如，代替编写如下代码：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you could accomplish the same thing more efficiently with `enumerate()`, like
    so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更高效地使用 `enumerate()` 完成同样的事情，如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***Sorting a List with sorted()***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 sorted() 排序列表***'
- en: 'The `sorted()` function takes the form `sorted(iterable`, key=None, reverse=False)
    and returns a sorted version of `iterable`. The `key` argument allows you to provide
    a function that returns the value to sort on, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 函数的形式为 `sorted(iterable, key=None, reverse=False)`，并返回 `iterable`
    的排序版本。`key` 参数允许你提供一个返回排序值的函数，如下所示：'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***Finding Items That Satisfy Conditions with any() and all()***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 any() 和 all() 查找满足条件的项***'
- en: 'The `any(iterable`) and `all(iterable`) functions return a Boolean depending
    on the values returned by `iterable`. These simple functions are equivalent to
    the following full Python code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`any(iterable)` 和 `all(iterable)` 函数根据 `iterable` 返回的值返回布尔值。这些简单的函数等价于以下完整的
    Python 代码：'
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These functions are useful for checking whether any or all of the values in
    an iterable satisfy a given condition. For example, the following checks a list
    for two conditions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数对于检查可迭代对象中的任何值或所有值是否满足给定条件非常有用。例如，以下代码检查一个列表是否满足两个条件：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The difference here is that `any()` returns `True` when at least one element
    meets the condition, while `all()` returns `True` only if every element meets
    the condition. The `all()` function will also return `True` for an empty iterable,
    since none of the elements is `False`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别是，`any()` 在至少一个元素满足条件时返回 `True`，而 `all()` 只有在每个元素都满足条件时才返回 `True`。`all()`
    函数对于空的可迭代对象也会返回 `True`，因为没有元素为 `False`。
- en: '***Combining Lists with zip()***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 zip() 合并列表***'
- en: 'The `zip()` function takes the form `zip(iter1` [,iter2 [...]]). It takes multiple
    sequences and combines them into tuples. This is useful when you need to combine
    a list of keys and a list of values into a dict. As with the other functions described
    here, `zip()` returns a list in Python 2 and an iterable in Python 3\. Here we
    map a list of keys to a list of values to create a dictionary:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数的形式为 `zip(iter1 [,iter2 [...]])`。它接受多个序列并将它们合并成元组。当你需要将一组键和一组值合并成字典时，这非常有用。与此处描述的其他函数一样，`zip()`
    在 Python 2 中返回一个列表，在 Python 3 中返回一个可迭代的对象。这里我们将一组键映射到一组值以创建字典：'
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**FUNCTIONAL FUNCTIONS IN PYTHON 2 AND 3**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 2 和 3 中的函数式编程函数**'
- en: 'You might have noticed by now how the return types differ between Python 2
    and Python 3\. Most of Python’s purely functional built-in functions return a
    list rather than an iterable in Python 2, making them less memory efficient than
    their Python 3.*x* equivalents. If you’re planning to write code using these functions,
    keep in mind that you’ll get the most benefit out of them in Python 3\. If you’re
    stuck with Python 2, don’t despair: the `itertools` module from the Standard Library
    provides an iterator-based version of many of these functions (`itertools.izip()`,
    `itertools.imap()`, `itertools.ifilter()`, and so on).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '***A Common Problem Solved***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s one important tool still to cover. Often when working with lists we
    want to find the first item that satisfies a specific condition. We’ll look at
    the many ways to accomplish this and then see the most efficient way: the `first`
    package.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Item with Simple Code**'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We might be able to find the first item to satisfy a condition with a function
    like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could rewrite the `first_positive_number()` function in functional style
    like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By using a functional approach where the predicate is passed as argument, the
    function becomes easily reusable. We could even write it more concisely, like
    so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that this may raise an `IndexError` if no items satisfy the condition,
    causing `list(filter())` to return an empty list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple cases, you can rely on `next()` to prevent `IndexError` from occurring,
    like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Listing 8-6](ch08.xhtml#ch8list6) will raise `StopIteration` if a condition
    can never be satisfied. This too can be solved by adding a second argument of
    `next()`, like so.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-6: Returning a default value when the condition is not met*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This will return a default value rather than an error when a condition cannot
    be met. Lucky for us, Python provides a package to handle all of this for us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Item Using first()**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rather than writing out the function from [Listing 8-6](ch08.xhtml#ch8list6)
    in all of your programs, you can include the small Python package `first`. [Listing
    8-7](ch08.xhtml#ch8list7) shows how this package lets you find the first element
    of an iterable matching a condition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-7: Finding the first item in a list that satisfies a condition*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You see that the `first()` function returns the first valid, non-empty item
    in a list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Using lambda() with functools**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll notice that we’ve used `lambda()` in a good portion of the examples so
    far in this chapter. The `lambda()` function was added to Python to facilitate
    functional programming functions such as `map()` and `filter()`, which otherwise
    would have required writing an entirely new function every time you wanted to
    check a different condition. [Listing 8-8](ch08.xhtml#ch8list8) is equivalent
    to [Listing 8-7](ch08.xhtml#ch8list7) but is written without using `lambda()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 8-8: Finding the first item to meet the condition, without using lambda()*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works identically to that in [Listing 8-7](ch08.xhtml#ch8list7),
    returning the first non-empty value in a list to meet the condition, but it’s
    a good deal more cumbersome: if we wanted to get the first number in the sequence
    that’s longer than, say, 42 items, we’d need to define an appropriate function
    via `def` rather than defining it inline with our call to `first()`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'But despite its usefulness in helping us avoid situations like this, `lambda`
    still has its problems. The `first` module contains a `key` argument that can
    be used to provide a function that receives each item as an argument and returns
    a Boolean indicating whether it satisfies the condition. However, we can’t pass
    a `key` function, as it would require more than a single line of code: a `lambda`
    statement cannot be written on more than one line. That is a significant limitation
    of `lambda`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we would have to go back to the cumbersome pattern of writing new function
    definitions for each `key` we need. Or would we?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The `functools` package comes to the rescue with its `partial()` method, which
    provides us with a more flexible alternative to `lambda`. The `functools.partial()`
    method allows us to create a wrapper function with a twist: rather than changing
    the behavior of a function, it instead changes the *arguments* it receives, like
    so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here we create a new `greater_than()` function that works just like the old
    `greater_than_zero()` from [Listing 8-8](ch08.xhtml#ch8list8) by default, but
    this version allows us to specify the value we want to compare our numbers to,
    whereas before it was hardcoded. Here, we pass `functools.partial()` to our function
    and the value we want for `min` ➊, and we get back a new function that has `min`
    set to 42, just as we want ➋. In other words, we can write a function and use
    `functools.partial()` to customize the behavior of our new functions to suit our
    needs in any given situation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Even this version can be pared down. All we’re doing in this example is comparing
    two numbers, and as it turns out, the `operator` module has built-in functions
    for exactly that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a good example of `functools.partial()` working with positional arguments.
    In this case, the function `operator.le(a, b)`, which takes two numbers and returns
    a Boolean that tells us whether the first number is less than or equal to the
    second, is passed to `functools.partial()`. The 0 we pass to `functools.partial()`
    gets assigned to `a`, and the argument passed to the function returned by `functools.partial()`
    gets assigned to `b`. So this works identically to [Listing 8-8](ch08.xhtml#ch8list8)
    but without using `lambda` or defining any additional functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*The functools.partial() method is typically useful in place of lambda and
    should be considered a superior alternative. The lambda function is something
    of an anomaly in the Python language, and dropping it altogether was considered
    for Python 3 due to the function’s limited body size of a single line.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '***Useful itertools Functions***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we’ll look at some useful functions in the `itertools` module in the
    Python Standard Library that you should be aware of. Too many programmers end
    up writing their own versions of these functions simply because they aren’t aware
    that Python provides them out of the box. They are all designed to help you manipulate
    `iterator` (that’s why the module is called *iter-tools*) and therefore are all
    purely functional. Here I’ll list a few of them and give a brief overview of what
    they do, and I encourage you to look into them further if they seem of use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`accumulate(iterable`[, func]) returns a series of accumulated sums of items
    from iterables.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chain(*iterables`) iterates over multiple iterables, one after another, without
    building an intermediate list of all items.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combinations(iterable`, r) generates all combinations of length r from the
    given `iterable`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compress(data`, selectors) applies a Boolean mask from selectors to data and
    returns only the values from `data` where the corresponding element of selectors
    is `True`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count(start`, step) generates an endless sequence of values, starting with
    start and incrementing step at a time with each call.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cycle(iterable`) loops repeatedly over the values in iterable.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat(elem`[, n]) repeats an element n times.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dropwhile(predicate`, iterable) filters elements of an iterable starting from
    the beginning until predicate is `False`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupby(iterable`, keyfunc) creates an iterator that groups items by the result
    returned by the `keyfunc()` function.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permutations(iterable`[, r]) returns successive r-length permutations of the
    items in iterable.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product(*iterables`) returns an iterable of the Cartesian product of iterables
    without using a nested `for` loop.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takewhile(predicate`, iterable) returns elements of an iterable starting from
    the beginning until predicate is `False`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions are particularly useful in conjunction with the `operator`
    module. When used together, `itertools` and `operator` can handle most situations
    that programmers typically rely on `lambda` for. Here’s an example of using `operator.itemgetter()`
    instead of writing `lambda x: x[''foo'']`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this case, we could have also written `lambda x: x[''foo'']`, but using
    `operator` lets us avoid having to use `lambda` at all.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Python is often advertised as being object oriented, it can be used in
    a very functional manner. A lot of its built-in concepts, such as generators and
    list comprehension, are functionally oriented and don’t conflict with an object-oriented
    approach. They also limit the reliance on a program’s global state, for your own
    good.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Using functional programming as a paradigm in Python can help you make your
    program more reusable and easier to test and debug, supporting the Don’t Repeat
    Yourself (DRY) mantra. In this spirit, the standard Python modules `itertools`
    and `operator` are good tools to improve the readability of your functional code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
