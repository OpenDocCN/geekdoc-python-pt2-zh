- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FUNCTIONAL PROGRAMMING**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Many Python developers are unaware of the extent to which you can use functional
    programming in Python, which is a shame: with few exceptions, functional programming
    allows you to write more concise and efficient code. Moreover, Python’s support
    for functional programming is extensive.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover some of the functional programming aspects of Python,
    including creating and using generators. You’ll learn about the most useful functional
    packages and functions available and how to use them in combination to get the
    most efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to get serious about functional programming, here’s my advice:
    take a break from Python and learn a hugely functional programming language, such
    as Lisp. I know it might sound strange to talk about Lisp in a Python book, but
    playing with Lisp for several years taught me how to “think functional.” You may
    not develop the thought processes necessary to make full use of functional programming
    if all your experience comes from imperative and object-oriented programming.
    Lisp isn’t purely functional itself, but it has more focus on functional programming
    than you’ll find in Python.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Pure Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you write code using a functional style, your functions are designed to
    have no side effects: instead, they take an input and produce an output without
    keeping state or modifying anything not reflected in the return value. Functions
    that follow this ideal are referred to as *purely functional*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example of a regular, non-pure function that removes the
    last item in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a pure version of the same function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We define a `butlast()` function to work like `butlast` in Lisp, in that it
    returns the list without the last element *without* modifying the original list.
    Instead, it returns a copy of the list that has the modifications in place, allowing
    us to keep the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'The practical advantages of functional programming include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** Writing with a functional style forces a certain degree of separation
    in solving your individual problems and makes sections of code easier to reuse
    in other contexts. Since the function does not depend on any external variable
    or state, calling it from a different piece of code is straightforward.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Brevity** Functional programming is often less verbose than other paradigms.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency** Purely functional functions are thread-safe and can run concurrently.
    Some functional languages do this automatically, which can be a big help if you
    ever need to scale your application, though this is not quite the case yet in
    Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testability** Testing a functional program is incredibly easy: all you need
    is a set of inputs and an expected set of outputs. They are *idempotent*, meaning
    that calling the same function over and over with the same arguments will always
    return the same result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *generator* is an object that behaves like an iterator, in that it generates
    and returns a value on each call of its `next()` method until a `StopIteration`
    is raised. Generators, first introduced in PEP 255, offer an easy way to create
    objects that implement the *iterator protocol*. While writing generators in a
    functional style is not strictly necessary, doing so makes them easier to write
    and debug and is a common practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a generator, just write a regular Python function that contains a
    `yield` statement. Python will detect the use of `yield` and tag the function
    as a generator. When execution reaches the `yield` statement, the function returns
    a value as with a `return` statement, but with one notable difference: the interpreter
    will save a stack reference, and this will be used to resume the function’s execution
    when the `next()` function is called again.'
  prefs: []
  type: TYPE_NORMAL
- en: When functions are executed, the chaining of their execution produces a *stack*—function
    calls are said to be stacked on each other. When a function returns, it’s removed
    from the stack, and the value it returns is passed to the calling function. In
    the case of a generator, the function does not really return but *yields* instead.
    Python therefore saves the state of the function as a stack reference, resuming
    the execution of the generator at the point it saved when the next iteration of
    the generator is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Generator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned, you create a generator by writing a normal function and including
    `yield` in the function’s body. [Listing 8-1](ch08.xhtml#ch8list1) creates a generator
    called `mygenerator()` that includes three yields, meaning it will iterate with
    the next three calls to `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Creating a generator with three iterations*'
  prefs: []
  type: TYPE_NORMAL
- en: When it runs out of `yield` statements, `StopIteration` is raised at the next
    call to `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, generators keep a reference to the stack when a function yields something,
    and they resume this stack when a call to `next()` is executed again.
  prefs: []
  type: TYPE_NORMAL
- en: The naive approach when iterating over any data without using generators is
    to build the entire list first, which often consumes memory wastefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to find the first number between 1 and 10,000,000 that’s equal
    to 50,000\. Sounds easy, doesn’t it? Let’s make this a challenge. We’ll run Python
    with a memory constraint of 128MB and try the naive approach of first building
    the entire list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This naive method first tries to build the list, but if we run the program
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Uh-oh. Turns out we can’t build a list of 10 million items with only 128MB of
    memory!
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In Python 3, range() returns a generator when iterated. To get a generator
    in Python 2, you have to use xrange() instead. This function doesn’t exist in
    Python 3 anymore, since it’s redundant.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try using a generator instead, with the same 128MB restriction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This time, our program executes without issue. When it is iterated over, the
    `range()` class returns a generator that dynamically generates our list of integers.
    Better still, since we are only interested in the 50,000th number, instead of
    building the full list, the generator only had to generate 50,000 numbers before
    it stopped.
  prefs: []
  type: TYPE_NORMAL
- en: By generating values on the fly, generators allow you to handle large data sets
    with minimal consumption of memory and processing cycles. Whenever you need to
    work with a huge number of values, generators can help you handle them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '***Returning and Passing Values with yield***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `yield` statement also has a less commonly used feature: it can return a
    value in the same way as a function call. This allows us to pass a value to a
    generator by calling its `send()` method. As an example of using `send()`, we’ll
    write a function called `shorten()` that takes a list of strings and returns a
    list consisting of those same strings, only truncated ([Listing 8-2](ch08.xhtml#ch8list2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Returning and using a value with send()*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve written a function called `shorten()` that takes a list
    of strings and returns a list consisting of those same strings, only truncated.
    The length of each truncated string is equal to the number of vowels in the previous
    string: *loremipsum* has four vowels, so the second value returned by the generator
    will be the first four letters of *dolorsit*; *dolo* has only two vowels, so *ametfoobar*
    will be truncated to its first two letters *am*. The generator then stops and
    raises `StopIteration`. Our generator thus returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using `yield` and `send()` in this fashion allows Python generators to function
    like *coroutines* seen in Lua and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 289 introduced generator expressions, making it possible to build one-line
    generators using a syntax similar to list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `gen` is a generator, just as if we had used the `yield` statement.
    The `yield` in this case is implicit.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting Generators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To determine whether a function is considered a generator, use `inspect.isgeneratorfunction()`.
    In [Listing 8-3](ch08.xhtml#ch8list3), we create a simple generator and inspect
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Checking whether a function is a generator*'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `inspect` package to use `isgeneratorfunction()` and then just pass
    it the name of the function to inspect. Reading the source code of `inspect.isgeneratorfunction()`
    gives us some insight into how Python marks functions as being generators (see
    [Listing 8-4](ch08.xhtml#ch8list4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Source code of inspect.isgeneratorfunction()*'
  prefs: []
  type: TYPE_NORMAL
- en: The `isgeneratorfunction()` function checks that the object is a function or
    a method and that its code has the `CO_GENERATOR` flag set. This example shows
    how easy it is to understand how Python works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inspect` package provides the `inspect.getgeneratorstate()` function,
    which gives the current state of the generator. We’ll use it on `mygenerator()`
    here at different points of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to determine whether the generator is waiting to be run for the
    first time (`GEN_CREATED`) ➊, waiting to be resumed by a call to `next()` (`GEN_SUSPENDED`)
    ➋, or finished running (`GEN_CLOSED`) ➌. This might come in handy to debug your
    generators.
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: List comprehension, or *listcomp* for short, allows you to define a list’s contents
    inline with its declaration. To make a list into a listcomp, you must wrap it
    in square brackets as usual, but also include an expression that will generate
    the items in the list and a `for` loop to loop through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a list without using list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And this next example uses list comprehension to make the same list with a
    single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a list comprehension presents two advantages: code written using listcomps
    is usually shorter and therefore compiles down to fewer operations for Python
    to perform. Rather than creating a list and calling `append` over and over, Python
    can just create the list of items and move them into a new list in a single operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use multiple `for` statements together and use `if` statements to filter
    out items. Here we create a list of words and use list comprehension to capitalize
    each item, split up items with multiple words into single words, and delete the
    extraneous *or* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has two `for` loops: the first iterates over the text lines, while
    the second iterates over words in each of those lines. The final `if` statement
    filters out words that start with *or* to exclude them from the final list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using list comprehension rather than `for` loops is a neat way to define lists
    quickly. Since we’re still talking about functional programming, it’s worth noting
    that lists built through list comprehension shouldn’t rely on changing the program’s
    state: you are not expected to modify any variable while building the list. This
    usually makes the lists more concise and easier to read than lists made without
    listcomp.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there’s also syntax for building dictionaries or sets in the same
    fashion, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Functional Functions Functioning**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might repeatedly encounter the same set of problems when manipulating data
    using functional programming. To help you deal with this situation efficiently,
    Python includes a number of functions for functional programming. This section
    will give you a quick overview of some of these built-in functions that allow
    you to build fully functional programs. Once you have an idea of what’s available,
    I encourage you to research further and try out functions where they might apply
    in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Applying Functions to Items with map()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `map()` function takes the form `map(function`, iterable) and applies `function`
    to each item in `iterable` to return a list in Python 2 or an iterable `map` object
    in Python 3, as shown in [Listing 8-5](ch08.xhtml#ch8list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Using map() in Python 3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could write an equivalent of `map()` using list comprehension, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '***Filtering Lists with filter()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `filter()` function takes the form `filter(function or None`, iterable)
    and filters the items in `iterable` based on the result returned by `function`.
    This will return a list in Python 2 or an iterable `filter` object in Python 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also write an equivalent of `filter()` using list comprehension,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '***Getting Indexes with enumerate()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `enumerate()` function takes the form `enumerate(iterable`[, start]) and
    returns an iterable object that provides a sequence of tuples, each consisting
    of an integer index (starting with `start`, if provided) and the corresponding
    item in `iterable`. This function is useful when you need to write code that refers
    to array indexes. For example, instead of writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'you could accomplish the same thing more efficiently with `enumerate()`, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '***Sorting a List with sorted()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sorted()` function takes the form `sorted(iterable`, key=None, reverse=False)
    and returns a sorted version of `iterable`. The `key` argument allows you to provide
    a function that returns the value to sort on, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '***Finding Items That Satisfy Conditions with any() and all()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `any(iterable`) and `all(iterable`) functions return a Boolean depending
    on the values returned by `iterable`. These simple functions are equivalent to
    the following full Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are useful for checking whether any or all of the values in
    an iterable satisfy a given condition. For example, the following checks a list
    for two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that `any()` returns `True` when at least one element
    meets the condition, while `all()` returns `True` only if every element meets
    the condition. The `all()` function will also return `True` for an empty iterable,
    since none of the elements is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Combining Lists with zip()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `zip()` function takes the form `zip(iter1` [,iter2 [...]]). It takes multiple
    sequences and combines them into tuples. This is useful when you need to combine
    a list of keys and a list of values into a dict. As with the other functions described
    here, `zip()` returns a list in Python 2 and an iterable in Python 3\. Here we
    map a list of keys to a list of values to create a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**FUNCTIONAL FUNCTIONS IN PYTHON 2 AND 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed by now how the return types differ between Python 2
    and Python 3\. Most of Python’s purely functional built-in functions return a
    list rather than an iterable in Python 2, making them less memory efficient than
    their Python 3.*x* equivalents. If you’re planning to write code using these functions,
    keep in mind that you’ll get the most benefit out of them in Python 3\. If you’re
    stuck with Python 2, don’t despair: the `itertools` module from the Standard Library
    provides an iterator-based version of many of these functions (`itertools.izip()`,
    `itertools.imap()`, `itertools.ifilter()`, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: '***A Common Problem Solved***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s one important tool still to cover. Often when working with lists we
    want to find the first item that satisfies a specific condition. We’ll look at
    the many ways to accomplish this and then see the most efficient way: the `first`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Item with Simple Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We might be able to find the first item to satisfy a condition with a function
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We could rewrite the `first_positive_number()` function in functional style
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By using a functional approach where the predicate is passed as argument, the
    function becomes easily reusable. We could even write it more concisely, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that this may raise an `IndexError` if no items satisfy the condition,
    causing `list(filter())` to return an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple cases, you can rely on `next()` to prevent `IndexError` from occurring,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 8-6](ch08.xhtml#ch8list6) will raise `StopIteration` if a condition
    can never be satisfied. This too can be solved by adding a second argument of
    `next()`, like so.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Returning a default value when the condition is not met*'
  prefs: []
  type: TYPE_NORMAL
- en: This will return a default value rather than an error when a condition cannot
    be met. Lucky for us, Python provides a package to handle all of this for us.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Item Using first()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rather than writing out the function from [Listing 8-6](ch08.xhtml#ch8list6)
    in all of your programs, you can include the small Python package `first`. [Listing
    8-7](ch08.xhtml#ch8list7) shows how this package lets you find the first element
    of an iterable matching a condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: Finding the first item in a list that satisfies a condition*'
  prefs: []
  type: TYPE_NORMAL
- en: You see that the `first()` function returns the first valid, non-empty item
    in a list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using lambda() with functools**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll notice that we’ve used `lambda()` in a good portion of the examples so
    far in this chapter. The `lambda()` function was added to Python to facilitate
    functional programming functions such as `map()` and `filter()`, which otherwise
    would have required writing an entirely new function every time you wanted to
    check a different condition. [Listing 8-8](ch08.xhtml#ch8list8) is equivalent
    to [Listing 8-7](ch08.xhtml#ch8list7) but is written without using `lambda()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: Finding the first item to meet the condition, without using lambda()*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works identically to that in [Listing 8-7](ch08.xhtml#ch8list7),
    returning the first non-empty value in a list to meet the condition, but it’s
    a good deal more cumbersome: if we wanted to get the first number in the sequence
    that’s longer than, say, 42 items, we’d need to define an appropriate function
    via `def` rather than defining it inline with our call to `first()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But despite its usefulness in helping us avoid situations like this, `lambda`
    still has its problems. The `first` module contains a `key` argument that can
    be used to provide a function that receives each item as an argument and returns
    a Boolean indicating whether it satisfies the condition. However, we can’t pass
    a `key` function, as it would require more than a single line of code: a `lambda`
    statement cannot be written on more than one line. That is a significant limitation
    of `lambda`.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we would have to go back to the cumbersome pattern of writing new function
    definitions for each `key` we need. Or would we?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `functools` package comes to the rescue with its `partial()` method, which
    provides us with a more flexible alternative to `lambda`. The `functools.partial()`
    method allows us to create a wrapper function with a twist: rather than changing
    the behavior of a function, it instead changes the *arguments* it receives, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a new `greater_than()` function that works just like the old
    `greater_than_zero()` from [Listing 8-8](ch08.xhtml#ch8list8) by default, but
    this version allows us to specify the value we want to compare our numbers to,
    whereas before it was hardcoded. Here, we pass `functools.partial()` to our function
    and the value we want for `min` ➊, and we get back a new function that has `min`
    set to 42, just as we want ➋. In other words, we can write a function and use
    `functools.partial()` to customize the behavior of our new functions to suit our
    needs in any given situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even this version can be pared down. All we’re doing in this example is comparing
    two numbers, and as it turns out, the `operator` module has built-in functions
    for exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is a good example of `functools.partial()` working with positional arguments.
    In this case, the function `operator.le(a, b)`, which takes two numbers and returns
    a Boolean that tells us whether the first number is less than or equal to the
    second, is passed to `functools.partial()`. The 0 we pass to `functools.partial()`
    gets assigned to `a`, and the argument passed to the function returned by `functools.partial()`
    gets assigned to `b`. So this works identically to [Listing 8-8](ch08.xhtml#ch8list8)
    but without using `lambda` or defining any additional functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The functools.partial() method is typically useful in place of lambda and
    should be considered a superior alternative. The lambda function is something
    of an anomaly in the Python language, and dropping it altogether was considered
    for Python 3 due to the function’s limited body size of a single line.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Useful itertools Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we’ll look at some useful functions in the `itertools` module in the
    Python Standard Library that you should be aware of. Too many programmers end
    up writing their own versions of these functions simply because they aren’t aware
    that Python provides them out of the box. They are all designed to help you manipulate
    `iterator` (that’s why the module is called *iter-tools*) and therefore are all
    purely functional. Here I’ll list a few of them and give a brief overview of what
    they do, and I encourage you to look into them further if they seem of use.
  prefs: []
  type: TYPE_NORMAL
- en: '`accumulate(iterable`[, func]) returns a series of accumulated sums of items
    from iterables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chain(*iterables`) iterates over multiple iterables, one after another, without
    building an intermediate list of all items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combinations(iterable`, r) generates all combinations of length r from the
    given `iterable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compress(data`, selectors) applies a Boolean mask from selectors to data and
    returns only the values from `data` where the corresponding element of selectors
    is `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count(start`, step) generates an endless sequence of values, starting with
    start and incrementing step at a time with each call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cycle(iterable`) loops repeatedly over the values in iterable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat(elem`[, n]) repeats an element n times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dropwhile(predicate`, iterable) filters elements of an iterable starting from
    the beginning until predicate is `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupby(iterable`, keyfunc) creates an iterator that groups items by the result
    returned by the `keyfunc()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permutations(iterable`[, r]) returns successive r-length permutations of the
    items in iterable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product(*iterables`) returns an iterable of the Cartesian product of iterables
    without using a nested `for` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takewhile(predicate`, iterable) returns elements of an iterable starting from
    the beginning until predicate is `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions are particularly useful in conjunction with the `operator`
    module. When used together, `itertools` and `operator` can handle most situations
    that programmers typically rely on `lambda` for. Here’s an example of using `operator.itemgetter()`
    instead of writing `lambda x: x[''foo'']`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we could have also written `lambda x: x[''foo'']`, but using
    `operator` lets us avoid having to use `lambda` at all.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Python is often advertised as being object oriented, it can be used in
    a very functional manner. A lot of its built-in concepts, such as generators and
    list comprehension, are functionally oriented and don’t conflict with an object-oriented
    approach. They also limit the reliance on a program’s global state, for your own
    good.
  prefs: []
  type: TYPE_NORMAL
- en: Using functional programming as a paradigm in Python can help you make your
    program more reusable and easier to test and debug, supporting the Don’t Repeat
    Yourself (DRY) mantra. In this spirit, the standard Python modules `itertools`
    and `operator` are good tools to improve the readability of your functional code.
  prefs: []
  type: TYPE_NORMAL
