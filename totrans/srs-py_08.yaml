- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**FUNCTIONAL PROGRAMMING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Many Python developers are unaware of the extent to which you can use functional
    programming in Python, which is a shame: with few exceptions, functional programming
    allows you to write more concise and efficient code. Moreover, Python’s support
    for functional programming is extensive.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 开发者并不了解在 Python 中使用函数式编程的广泛性，这真是太可惜了：除了少数例外，函数式编程允许你编写更简洁和高效的代码。而且，Python
    对函数式编程的支持非常广泛。
- en: This chapter will cover some of the functional programming aspects of Python,
    including creating and using generators. You’ll learn about the most useful functional
    packages and functions available and how to use them in combination to get the
    most efficient code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Python 的一些函数式编程方面的内容，包括创建和使用生成器。你将了解最有用的函数式编程包和函数，以及如何将它们结合使用，以获得最高效的代码。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to get serious about functional programming, here’s my advice:
    take a break from Python and learn a hugely functional programming language, such
    as Lisp. I know it might sound strange to talk about Lisp in a Python book, but
    playing with Lisp for several years taught me how to “think functional.” You may
    not develop the thought processes necessary to make full use of functional programming
    if all your experience comes from imperative and object-oriented programming.
    Lisp isn’t purely functional itself, but it has more focus on functional programming
    than you’ll find in Python.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想认真学习函数式编程，以下是我的建议：休息一下，学习一种功能非常强大的函数式编程语言，比如 Lisp。我知道在 Python 书中谈论 Lisp
    可能听起来很奇怪，但我玩了几年的 Lisp，它教会了我如何“以函数式思维”思考。如果你所有的经验都来自命令式和面向对象编程，你可能不会培养出充分利用函数式编程的思维过程。Lisp
    本身并非纯粹函数式，但它比你在 Python 中看到的更注重函数式编程。*'
- en: '**Creating Pure Functions**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建纯函数**'
- en: 'When you write code using a functional style, your functions are designed to
    have no side effects: instead, they take an input and produce an output without
    keeping state or modifying anything not reflected in the return value. Functions
    that follow this ideal are referred to as *purely functional*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用函数式风格编写代码时，你的函数设计上不会有副作用：它们接受输入并产生输出，而不会保留状态或修改任何不反映在返回值中的内容。遵循这一理想的函数被称为*纯函数*。
- en: 'Let’s start with an example of a regular, non-pure function that removes the
    last item in a list:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个普通的、非纯函数的例子开始，它移除列表中的最后一个元素：
- en: 'def remove_last_item(mylist):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'def remove_last_item(mylist):'
- en: '"""Removes the last item from a list."""'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从列表中移除最后一个元素。"""'
- en: mylist.pop(-1)  # This modifies mylist
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 'mylist.pop(-1)  # 这会修改 mylist'
- en: 'The following is a pure version of the same function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同函数的纯函数版本：
- en: 'def butlast(mylist):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'def butlast(mylist):'
- en: return mylist[:-1]  # This returns a copy of mylist
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'return mylist[:-1]  # 这返回 mylist 的副本'
- en: We define a butlast() function to work like butlast in Lisp, in that it returns
    the list without the last element *without* modifying the original list. Instead,
    it returns a copy of the list that has the modifications in place, allowing us
    to keep the original.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `butlast()` 函数，它像 Lisp 中的 `butlast` 一样，返回一个去掉最后一个元素的列表，*而不会* 修改原始列表。相反，它返回一个包含修改的列表副本，从而让我们保持原始列表不变。
- en: 'The practical advantages of functional programming include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的实际优点包括：
- en: '**Modularity** Writing with a functional style forces a certain degree of separation
    in solving your individual problems and makes sections of code easier to reuse
    in other contexts. Since the function does not depend on any external variable
    or state, calling it from a different piece of code is straightforward.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化** 使用函数式编程风格强制在解决单独问题时进行一定程度的分离，使代码的各个部分在其他上下文中更易于重用。由于函数不依赖于任何外部变量或状态，从不同的代码片段调用它是非常直接的。'
- en: '**Brevity** Functional programming is often less verbose than other paradigms.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**简洁性** 函数式编程通常比其他编程范式更简洁。'
- en: '**Concurrency** Purely functional functions are thread-safe and can run concurrently.
    Some functional languages do this automatically, which can be a big help if you
    ever need to scale your application, though this is not quite the case yet in
    Python.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发性** 纯粹的函数式函数是线程安全的，并且可以并发运行。一些函数式语言会自动处理这一点，如果你需要扩展应用程序，这将是一个很大的帮助，尽管在
    Python 中情况还不是完全如此。'
- en: '**Testability** Testing a functional program is incredibly easy: all you need
    is a set of inputs and an expected set of outputs. They are *idempotent*, meaning
    that calling the same function over and over with the same arguments will always
    return the same result.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**可测试性** 测试一个功能性程序非常容易：你只需要一组输入和一组预期的输出。它们是*幂等的*，意味着在相同的参数下反复调用同一个函数将始终返回相同的结果。'
- en: '**Generators**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生成器**'
- en: A *generator* is an object that behaves like an iterator, in that it generates
    and returns a value on each call of its next() method until a StopIteration is
    raised. Generators, first introduced in PEP 255, offer an easy way to create objects
    that implement the *iterator protocol*. While writing generators in a functional
    style is not strictly necessary, doing so makes them easier to write and debug
    and is a common practice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*生成器*是一个像迭代器一样工作的对象，它在每次调用 next() 方法时生成并返回一个值，直到引发 StopIteration 为止。生成器最早在
    PEP 255 中介绍，它提供了一种创建实现*迭代器协议*的对象的简便方法。虽然以函数式风格编写生成器并不是绝对必要的，但这样做可以使生成器更容易编写和调试，这也是一种常见做法。
- en: 'To create a generator, just write a regular Python function that contains a
    yield statement. Python will detect the use of yield and tag the function as a
    generator. When execution reaches the yield statement, the function returns a
    value as with a return statement, but with one notable difference: the interpreter
    will save a stack reference, and this will be used to resume the function’s execution
    when the next() function is called again.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个生成器，只需编写一个包含 yield 语句的常规 Python 函数。Python 会检测到 yield 的使用并将该函数标记为生成器。当执行到
    yield 语句时，函数会像使用 return 语句一样返回一个值，但有一个显著的不同：解释器会保存堆栈引用，下一次调用 next() 函数时，将使用该引用恢复函数的执行。
- en: When functions are executed, the chaining of their execution produces a *stack*—function
    calls are said to be stacked on each other. When a function returns, it’s removed
    from the stack, and the value it returns is passed to the calling function. In
    the case of a generator, the function does not really return but *yields* instead.
    Python therefore saves the state of the function as a stack reference, resuming
    the execution of the generator at the point it saved when the next iteration of
    the generator is needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被执行时，它们的执行链会产生一个*堆栈*——函数调用被堆叠在一起。当一个函数返回时，它会从堆栈中移除，返回的值会传递给调用函数。对于生成器来说，函数并不会真正返回，而是*产生*（yield）。因此，Python
    会将函数的状态保存为堆栈引用，在需要生成器的下一次迭代时，恢复到保存的执行点。
- en: '***Creating a Generator***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建生成器***'
- en: As mentioned, you create a generator by writing a normal function and including
    yield in the function’s body. [Listing 8-1](ch08.xhtml#ch8list1) creates a generator
    called mygenerator() that includes three yields, meaning it will iterate with
    the next three calls to next().
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你通过编写一个普通函数并在函数体内包含 yield 来创建一个生成器。[Listing 8-1](ch08.xhtml#ch8list1) 创建了一个名为
    mygenerator() 的生成器，包含了三个 yield，这意味着它会在接下来的三次 next() 调用中进行迭代。
- en: '>> def mygenerator():'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '>> def mygenerator():'
- en: '...     yield 1'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '...      yield 1'
- en: '...     yield 2'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '...      yield 2'
- en: '...     yield ''a'''
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '...      yield ''a'''
- en: '...'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> mygenerator()'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> mygenerator()'
- en: <generator object mygenerator at 0x10d77fa50>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object mygenerator at 0x10d77fa50>
- en: '>>> g = mygenerator()'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> g = mygenerator()'
- en: '>>> next(g)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next(g)'
- en: '1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> next(g)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next(g)'
- en: '2'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> next(g)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next(g)'
- en: '''a'' >>> next(g)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '''a'' >>> next(g)'
- en: 'Traceback (most recent call last):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module>
- en: StopIteration
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: StopIteration
- en: '*Listing 8-1: Creating a generator with three iterations*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-1：创建一个包含三次迭代的生成器*'
- en: When it runs out of yield statements, StopIteration is raised at the next call
    to next().
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的 yield 语句时，下一次调用 next() 时会引发 StopIteration。
- en: In Python, generators keep a reference to the stack when a function yields something,
    and they resume this stack when a call to next() is executed again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，当一个生成器函数 yield 某个值时，生成器会保存对堆栈的引用，并且当再次执行 next() 调用时，生成器会恢复这个堆栈。
- en: The naive approach when iterating over any data without using generators is
    to build the entire list first, which often consumes memory wastefully.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有使用生成器的情况下迭代任何数据的幼稚方法是先构建整个列表，这通常会浪费内存。
- en: 'Say we want to find the first number between 1 and 10,000,000 that’s equal
    to 50,000\. Sounds easy, doesn’t it? Let’s make this a challenge. We’ll run Python
    with a memory constraint of 128MB and try the naive approach of first building
    the entire list:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找出 1 到 10,000,000 之间第一个等于 50,000 的数字。听起来很简单，不是吗？让我们把它变成一个挑战。我们将 Python
    运行在 128MB 的内存限制下，并尝试最初构建整个列表的幼稚方法：
- en: $ ulimit -v 131072
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: $ ulimit -v 131072
- en: $ python3
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3
- en: '>>> a = list(range(10000000))'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = list(range(10000000))'
- en: 'This naive method first tries to build the list, but if we run the program
    so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法首先尝试构建列表，但如果我们执行到目前为止的程序：
- en: 'Traceback (most recent call last): File "<stdin>", line 1, in <module>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last): File "<stdin>", line 1, in <module>'
- en: MemoryError
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MemoryError
- en: Uh-oh. Turns out we can’t build a list of 10 million items with only 128MB of
    memory!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，结果我们不能用仅有的128MB内存构建1000万个条目的列表！
- en: '**WARNING**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*In Python 3, range() returns a generator when iterated. To get a generator
    in Python 2, you have to use xrange() instead. This function doesn’t exist in
    Python 3 anymore, since it’s redundant.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Python 3中，range()在迭代时返回一个生成器。要在Python 2中获取生成器，你必须使用xrange()。此函数在Python 3中不再存在，因为它已不再需要。*'
- en: 'Let’s try using a generator instead, with the same 128MB restriction:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用生成器，仍然保持128MB的限制：
- en: $ ulimit -v 131072
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: $ ulimit -v 131072
- en: $ python3
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3
- en: '>>> for value in range(10000000):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for value in range(10000000):'
- en: '...     if value == 50000:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '...      if value == 50000:'
- en: '...             print("Found it")'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '...             print("找到了")'
- en: '...             break'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '...             break'
- en: '...'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Found it
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 找到了
- en: This time, our program executes without issue. When it is iterated over, the
    range() class returns a generator that dynamically generates our list of integers.
    Better still, since we are only interested in the 50,000th number, instead of
    building the full list, the generator only had to generate 50,000 numbers before
    it stopped.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的程序顺利执行。当它被迭代时，range()类返回一个生成器，该生成器动态生成我们的整数列表。更好的是，由于我们只对第50,000个数字感兴趣，因此生成器仅需要生成50,000个数字就停止了，而不是构建完整的列表。
- en: By generating values on the fly, generators allow you to handle large data sets
    with minimal consumption of memory and processing cycles. Whenever you need to
    work with a huge number of values, generators can help you handle them efficiently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态生成值，生成器允许你以最小的内存和处理周期消耗来处理大数据集。每当你需要处理大量值时，生成器可以帮助你高效地处理它们。
- en: '***Returning and Passing Values with yield***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用yield返回和传递值***'
- en: 'A yield statement also has a less commonly used feature: it can return a value
    in the same way as a function call. This allows us to pass a value to a generator
    by calling its send() method. As an example of using send(), we’ll write a function
    called shorten() that takes a list of strings and returns a list consisting of
    those same strings, only truncated ([Listing 8-2](ch08.xhtml#ch8list2)).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: yield语句还有一个较少使用的特性：它可以像函数调用一样返回一个值。这使我们能够通过调用生成器的send()方法将一个值传递给生成器。作为使用send()的示例，我们将编写一个名为shorten()的函数，它接受一个字符串列表并返回一个由这些相同字符串组成的列表，只不过是被截断的（[示例
    8-2](ch08.xhtml#ch8list2)）。
- en: 'def shorten(string_list):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'def shorten(string_list):'
- en: length = len(string_list[0])
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: length = len(string_list[0])
- en: 'for s in string_list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'for s in string_list:'
- en: length = yield s[:length]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: length = yield s[:length]
- en: mystringlist = ['loremipsum', 'dolorsit', 'ametfoobar']
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: mystringlist = ['loremipsum', 'dolorsit', 'ametfoobar']
- en: shortstringlist = shorten(mystringlist)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: shortstringlist = shorten(mystringlist)
- en: result = []
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: result = []
- en: 'try:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: s = next(shortstringlist)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: s = next(shortstringlist)
- en: result.append(s)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: result.append(s)
- en: 'while True:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'number_of_vowels = len(filter(lambda letter: letter in ''aeiou'', s))'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'number_of_vowels = len(filter(lambda letter: letter in ''aeiou'', s))'
- en: '# Truncate the next string depending'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据下一个字符串的长度截断'
- en: '# on the number of vowels in the previous one'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '# 基于前一个字符串中的元音字母数'
- en: s = shortstringlist.send(number_of_vowels)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: s = shortstringlist.send(number_of_vowels)
- en: result.append(s)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: result.append(s)
- en: 'except StopIteration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'except StopIteration:'
- en: pass
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '*Listing 8-2: Returning and using a value with send()*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-2：使用send()返回和使用值*'
- en: 'In this example, we’ve written a function called shorten() that takes a list
    of strings and returns a list consisting of those same strings, only truncated.
    The length of each truncated string is equal to the number of vowels in the previous
    string: *loremipsum* has four vowels, so the second value returned by the generator
    will be the first four letters of *dolorsit*; *dolo* has only two vowels, so *ametfoobar*
    will be truncated to its first two letters *am*. The generator then stops and
    raises StopIteration. Our generator thus returns:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们编写了一个名为shorten()的函数，它接受一个字符串列表，并返回一个由这些相同字符串组成的列表，只不过是被截断的。每个截断字符串的长度等于前一个字符串中的元音字母数：*loremipsum*包含四个元音字母，因此生成器返回的第二个值将是*dolorsit*的前四个字母；*dolo*只有两个元音字母，所以*ametfoobar*将被截断为前两个字母*am*。生成器然后停止并引发StopIteration。我们的生成器因此返回：
- en: '[''loremipsum'', ''dolo'', ''am'']'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[''loremipsum'', ''dolo'', ''am'']'
- en: Using yield and send() in this fashion allows Python generators to function
    like *coroutines* seen in Lua and other languages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 yield 和 send() 以这种方式让 Python 生成器像 Lua 和其他语言中的 *协程* 一样工作。
- en: 'PEP 289 introduced generator expressions, making it possible to build one-line
    generators using a syntax similar to list comprehension:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 289 引入了生成器表达式，使得可以使用类似于列表推导式的语法构建单行生成器：
- en: '>>> (x.upper() for x in [''hello'', ''world''])'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (x.upper() for x in [''hello'', ''world''])'
- en: <generator object <genexpr> at 0x7ffab3832fa0>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object <genexpr> at 0x7ffab3832fa0>
- en: '>>> gen = (x.upper() for x in [''hello'', ''world''])'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> gen = (x.upper() for x in [''hello'', ''world''])'
- en: '>>> list(gen)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(gen)'
- en: '[''HELLO'', ''WORLD'']'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[''HELLO'', ''WORLD'']'
- en: In this example, gen is a generator, just as if we had used the yield statement.
    The yield in this case is implicit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，gen 是一个生成器，就像我们使用了 yield 语句一样。这里的 yield 是隐式的。
- en: '***Inspecting Generators***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查生成器***'
- en: To determine whether a function is considered a generator, use inspect.isgeneratorfunction().
    In [Listing 8-3](ch08.xhtml#ch8list3), we create a simple generator and inspect
    it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个函数是否被视为生成器，可以使用 inspect.isgeneratorfunction()。在 [列出 8-3](ch08.xhtml#ch8list3)
    中，我们创建了一个简单的生成器并检查它。
- en: '>>> import inspect'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import inspect'
- en: '>>> def mygenerator():'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def mygenerator():'
- en: '...     yield 1'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '...     yield 1'
- en: '...'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> inspect.isgeneratorfunction(mygenerator)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> inspect.isgeneratorfunction(mygenerator)'
- en: 'True'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> inspect.isgeneratorfunction(sum)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> inspect.isgeneratorfunction(sum)'
- en: 'False'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '*Listing 8-3: Checking whether a function is a generator*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 8-3：检查一个函数是否是生成器*'
- en: Import the inspect package to use isgeneratorfunction() and then just pass it
    the name of the function to inspect. Reading the source code of inspect.isgeneratorfunction()
    gives us some insight into how Python marks functions as being generators (see
    [Listing 8-4](ch08.xhtml#ch8list4)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 inspect 包以使用 isgeneratorfunction()，然后传入要检查的函数名称。阅读 inspect.isgeneratorfunction()
    的源代码，可以帮助我们了解 Python 如何标记函数为生成器（见 [列出 8-4](ch08.xhtml#ch8list4)）。
- en: 'def isgeneratorfunction(object):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'def isgeneratorfunction(object):'
- en: '"""Return true if the object is a user-defined generator function.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '"""如果对象是用户定义的生成器函数，返回真。'
- en: Generator function objects provides same attributes as functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数对象提供与普通函数相同的属性。
- en: See help(isfunction) for attributes listing."""
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 查看帮助(isfunction)，了解属性列表。"""
- en: return bool((isfunction(object) or ismethod(object)) and
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: return bool((isfunction(object) or ismethod(object)) and
- en: object.func_code.co_flags & CO_GENERATOR)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: object.func_code.co_flags & CO_GENERATOR)
- en: '*Listing 8-4: Source code of inspect.isgeneratorfunction()*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 8-4：inspect.isgeneratorfunction() 的源代码*'
- en: The isgeneratorfunction() function checks that the object is a function or a
    method and that its code has the CO_GENERATOR flag set. This example shows how
    easy it is to understand how Python works under the hood.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: isgeneratorfunction() 函数检查对象是否是一个函数或方法，并且其代码中是否设置了 CO_GENERATOR 标志。这个例子展示了理解
    Python 内部工作原理是多么简单。
- en: 'The inspect package provides the inspect.getgeneratorstate() function, which
    gives the current state of the generator. We’ll use it on mygenerator() here at
    different points of execution:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: inspect 包提供了 inspect.getgeneratorstate() 函数，它返回生成器的当前状态。我们将在不同的执行点使用它来查看 mygenerator()
    的状态：
- en: '>>> import inspect'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import inspect'
- en: '>>> def mygenerator():'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def mygenerator():'
- en: '...     yield 1'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '...     yield 1'
- en: '...'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> gen = mygenerator()'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> gen = mygenerator()'
- en: '>>> gen'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> gen'
- en: <generator object mygenerator at 0x7f94b44fec30>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object mygenerator at 0x7f94b44fec30>
- en: '>>> inspect.getgeneratorstate(gen)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> inspect.getgeneratorstate(gen)'
- en: ➊ 'GEN_CREATED'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 'GEN_CREATED'
- en: '>>> next(gen)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next(gen)'
- en: '1'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> inspect.getgeneratorstate(gen)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> inspect.getgeneratorstate(gen)'
- en: ➋ 'GEN_SUSPENDED'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 'GEN_SUSPENDED'
- en: '>>> next(gen)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next(gen)'
- en: 'Traceback (most recent call last):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最先出现）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module>
- en: StopIteration
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: StopIteration
- en: '>>> inspect.getgeneratorstate(gen)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> inspect.getgeneratorstate(gen)'
- en: ➌ 'GEN_CLOSED'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 'GEN_CLOSED'
- en: This allows us to determine whether the generator is waiting to be run for the
    first time (GEN_CREATED) ➊, waiting to be resumed by a call to next() (GEN_SUSPENDED)
    ➋, or finished running (GEN_CLOSED) ➌. This might come in handy to debug your
    generators.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够判断生成器是否等待第一次运行（GEN_CREATED）➊，等待通过 next() 恢复执行（GEN_SUSPENDED）➋，或者已经完成执行（GEN_CLOSED）➌。这对于调试生成器可能会很有帮助。
- en: '**List Comprehensions**'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表推导式**'
- en: List comprehension, or *listcomp* for short, allows you to define a list’s contents
    inline with its declaration. To make a list into a listcomp, you must wrap it
    in square brackets as usual, but also include an expression that will generate
    the items in the list and a for loop to loop through them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式，简称*listcomp*，允许你在声明列表时直接定义其内容。要将列表转换为列表推导式，你必须像平常一样将其包裹在方括号中，但还需包含一个表达式，该表达式会生成列表中的项，并且需要一个for循环来遍历它们。
- en: 'The following example creates a list without using list comprehension:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在不使用列表推导式的情况下创建一个列表：
- en: '>>> x = []'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = []'
- en: '>>> for i in (1, 2, 3):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in (1, 2, 3):'
- en: '...     x.append(i)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '...     x.append(i)'
- en: '...'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> x'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[1, 2, 3]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: 'And this next example uses list comprehension to make the same list with a
    single line:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用列表推导式在一行代码中生成相同的列表：
- en: '>>> x = [i for i in (1, 2, 3)]'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [i for i in (1, 2, 3)]'
- en: '>>> x'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[1, 2, 3]'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: 'Using a list comprehension presents two advantages: code written using listcomps
    is usually shorter and therefore compiles down to fewer operations for Python
    to perform. Rather than creating a list and calling append over and over, Python
    can just create the list of items and move them into a new list in a single operation.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式有两个优势：使用列表推导式编写的代码通常更简短，因此Python需要执行的操作也更少。与其反复创建列表并调用append，不如让Python一次性创建出项的列表并将它们移动到一个新的列表中。
- en: 'You can use multiple for statements together and use if statements to filter
    out items. Here we create a list of words and use list comprehension to capitalize
    each item, split up items with multiple words into single words, and delete the
    extraneous *or* :'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个for语句组合在一起，并使用if语句过滤掉某些项。这里我们创建了一个单词列表，并使用列表推导式将每个项首字母大写，拆分多个单词的项为单个单词，并删除多余的*or*：
- en: x = [word.capitalize()
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: x = [word.capitalize()]
- en: for line in ("hello world?", "world!", "or not")
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: for line in ("hello world?", "world!", "or not")
- en: for word in line.split()
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: for word in line.split()
- en: if not word.startswith("or")]
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: if not word.startswith("or")]
- en: '>>> x'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[''Hello'', ''World?'', ''World!'', ''Not'']'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[''Hello'', ''World?'', ''World!'', ''Not'']'
- en: 'This code has two for loops: the first iterates over the text lines, while
    the second iterates over words in each of those lines. The final if statement
    filters out words that start with *or* to exclude them from the final list.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个for循环：第一个遍历文本行，第二个遍历每行中的单词。最后的if语句会过滤掉以*or*开头的单词，从最终列表中排除它们。
- en: 'Using list comprehension rather than for loops is a neat way to define lists
    quickly. Since we’re still talking about functional programming, it’s worth noting
    that lists built through list comprehension shouldn’t rely on changing the program’s
    state: you are not expected to modify any variable while building the list. This
    usually makes the lists more concise and easier to read than lists made without
    listcomp.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式而不是for循环是一种快速定义列表的简洁方法。由于我们仍在讨论函数式编程，值得注意的是，通过列表推导式构建的列表不应依赖于修改程序的状态：在构建列表时不应修改任何变量。这通常使得列表比没有使用列表推导式的列表更加简洁和易读。
- en: 'Note that there’s also syntax for building dictionaries or sets in the same
    fashion, like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，也有类似的语法可以以相同的方式构建字典或集合，如下所示：
- en: '>>> {x:x.upper() for x in [''hello'', ''world'']}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {x:x.upper() for x in [''hello'', ''world'']}'
- en: '{''world'': ''WORLD'', ''hello'': ''HELLO''}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '{''world'': ''WORLD'', ''hello'': ''HELLO''}'
- en: '>>> {x.upper() for x in [''hello'', ''world'']}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {x.upper() for x in [''hello'', ''world'']}'
- en: set(['WORLD', 'HELLO'])
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: set(['WORLD', 'HELLO'])
- en: '**Functional Functions Functioning**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数式编程中的函数**'
- en: You might repeatedly encounter the same set of problems when manipulating data
    using functional programming. To help you deal with this situation efficiently,
    Python includes a number of functions for functional programming. This section
    will give you a quick overview of some of these built-in functions that allow
    you to build fully functional programs. Once you have an idea of what’s available,
    I encourage you to research further and try out functions where they might apply
    in your own code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用函数式编程操作数据时，你可能会反复遇到相同的一组问题。为了帮助你高效地处理这种情况，Python包含了许多函数式编程的内置函数。本节将快速概述一些这些内置函数，它们可以帮助你构建完全函数化的程序。一旦你了解了这些函数的作用，我鼓励你进一步研究，并尝试在自己的代码中使用这些函数。
- en: '***Applying Functions to Items with map()***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用map()函数对项进行操作***'
- en: The map() function takes the form map(function, iterable) and applies function
    to each item in iterable to return a list in Python 2 or an iterable map object
    in Python 3, as shown in [Listing 8-5](ch08.xhtml#ch8list5).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: map()函数的形式为map(function, iterable)，并将function应用于iterable中的每一项，返回一个列表（Python
    2）或一个可迭代的map对象（Python 3），如[Listing 8-5](ch08.xhtml#ch8list5)所示。
- en: '>>> map(lambda x: x + "bzz!", ["I think", "I''m good"])'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> map(lambda x: x + "bzz!", ["我认为", "我很好"])'
- en: <map object at 0x7fe7101abdd0>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <map object at 0x7fe7101abdd0>
- en: '>>> list(map(lambda x: x + "bzz!", ["I think", "I''m good"]))'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(map(lambda x: x + "bzz!", ["我认为", "我很好"]))'
- en: '[''I thinkbzz!'', "I''m goodbzz!"]'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[''我认为bzz!'', "我很好bzz!"]'
- en: '*Listing 8-5: Using map() in Python 3*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-5: 在Python 3中使用map()*'
- en: 'You could write an equivalent of map() using list comprehension, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过列表推导式写出一个等效的map()，像这样：
- en: '>>> (x + "bzz!" for x in ["I think", "I''m good"])'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (x + "bzz!" for x in ["我认为", "我很好"])'
- en: <generator object <genexpr> at 0x7f9a0d697dc0>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object <genexpr> at 0x7f9a0d697dc0>
- en: '>>> [x + "bzz!" for x in ["I think", "I''m good"]]'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [x + "bzz!" for x in ["我认为", "我很好"]]'
- en: '[''I thinkbzz!'', "I''m goodbzz!"]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[''我认为bzz!'', "我很好bzz!"]'
- en: '***Filtering Lists with filter()***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用filter()过滤列表***'
- en: 'The filter() function takes the form filter(function or None, iterable) and
    filters the items in iterable based on the result returned by function. This will
    return a list in Python 2 or an iterable filter object in Python 3:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: filter()函数的形式为filter(function或None, iterable)，并根据function返回的结果过滤iterable中的项目。它将在Python
    2中返回一个列表，或在Python 3中返回一个可迭代的filter对象：
- en: '>>> filter(lambda x: x.startswith("I "), ["I think", "I''m good"])'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> filter(lambda x: x.startswith("我 "), ["我认为", "我很好"])'
- en: <filter object at 0x7f9a0d636dd0>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <filter object at 0x7f9a0d636dd0>
- en: '>>> list(filter(lambda x: x.startswith("I "), ["I think", "I''m good"]))'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(filter(lambda x: x.startswith("我 "), ["我认为", "我很好"]))'
- en: '[''I think'']'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[''我认为'']'
- en: 'You could also write an equivalent of filter() using list comprehension, like
    so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过列表推导式写出一个等效的filter()，像这样：
- en: '>>> (x for x in ["I think", "I''m good"] if x.startswith("I "))'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (x for x in ["我认为", "我很好"] if x.startswith("我 "))'
- en: <generator object <genexpr> at 0x7f9a0d697dc0>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object <genexpr> at 0x7f9a0d697dc0>
- en: '>>> [x for x in ["I think", "I''m good"] if x.startswith("I ")]'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [x for x in ["我认为", "我很好"] if x.startswith("我 ")]'
- en: '[''I think'']'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[''我认为'']'
- en: '***Getting Indexes with enumerate()***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用enumerate()获取索引***'
- en: 'The enumerate() function takes the form enumerate(iterable[, start]) and returns
    an iterable object that provides a sequence of tuples, each consisting of an integer
    index (starting with start, if provided) and the corresponding item in iterable.
    This function is useful when you need to write code that refers to array indexes.
    For example, instead of writing this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: enumerate()函数的形式为enumerate(iterable[, start])，返回一个可迭代的对象，提供一个元组序列，每个元组包含一个整数索引（如果提供了start，则从start开始）和对应的项。这个函数在你需要编写引用数组索引的代码时非常有用。例如，代替写出以下代码：
- en: i = 0
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: 'while i < len(mylist): print("Item %d: %s" % (i, mylist[i]))'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i < len(mylist): print("项目 %d: %s" % (i, mylist[i]))'
- en: i += 1
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'you could accomplish the same thing more efficiently with enumerate(), like
    so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用enumerate()更高效地完成相同的事情，如下所示：
- en: 'for i, item in enumerate(mylist):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i, item in enumerate(mylist):'
- en: 'print("Item %d: %s" % (i, item))'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("项目 %d: %s" % (i, item))'
- en: '***Sorting a List with sorted()***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用sorted()排序列表***'
- en: 'The sorted() function takes the form sorted(iterable, key=None, reverse=False)
    and returns a sorted version of iterable. The key argument allows you to provide
    a function that returns the value to sort on, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: sorted()函数的形式为sorted(iterable, key=None, reverse=False)，并返回iterable的排序版本。key参数允许你提供一个返回用于排序的值的函数，如下所示：
- en: '>>> sorted([("a", 2), ("c", 1), ("d", 4)])'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sorted([("a", 2), ("c", 1), ("d", 4)])'
- en: '[(''a'', 2), (''c'', 1), (''d'', 4)]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''a'', 2), (''c'', 1), (''d'', 4)]'
- en: '>>> sorted([("a", 2), ("c", 1), ("d", 4)], key=lambda x: x[1])'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sorted([("a", 2), ("c", 1), ("d", 4)], key=lambda x: x[1])'
- en: '[(''c'', 1), (''a'', 2), (''d'', 4)]'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''c'', 1), (''a'', 2), (''d'', 4)]'
- en: '***Finding Items That Satisfy Conditions with any() and all()***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用any()和all()找到满足条件的项***'
- en: 'The any(iterable) and all(iterable) functions return a Boolean depending on
    the values returned by iterable. These simple functions are equivalent to the
    following full Python code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: any(iterable)和all(iterable)函数返回一个布尔值，取决于iterable返回的值。这些简单的函数等价于以下完整的Python代码：
- en: 'def all(iterable):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def all(iterable):'
- en: 'for x in iterable:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in iterable:'
- en: 'if not x:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not x:'
- en: return False
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'def any(iterable):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def any(iterable):'
- en: 'for x in iterable:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in iterable:'
- en: 'if x:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x:'
- en: return True
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: return False
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'These functions are useful for checking whether any or all of the values in
    an iterable satisfy a given condition. For example, the following checks a list
    for two conditions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数用于检查可迭代对象中的任意或所有值是否满足给定的条件。例如，以下代码检查列表是否满足两个条件：
- en: mylist = [0, 1, 3, -1]
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: mylist = [0, 1, 3, -1]
- en: 'if all(map(lambda x: x > 0, mylist)):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'if all(map(lambda x: x > 0, mylist)):'
- en: print("All items are greater than 0")
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: print("所有项都大于 0")
- en: 'if any(map(lambda x: x > 0, mylist)):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'if any(map(lambda x: x > 0, mylist)):'
- en: print("At least one item is greater than 0")
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: print("至少有一项大于 0")
- en: The difference here is that any() returns True when at least one element meets
    the condition, while all() returns True only if every element meets the condition.
    The all() function will also return True for an empty iterable, since none of
    the elements is False.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于，any() 在至少一个元素满足条件时返回 True，而 all() 只有在每个元素都满足条件时才返回 True。对于空的可迭代对象，all()
    也会返回 True，因为其中没有元素是 False。
- en: '***Combining Lists with zip()***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 zip() 合并列表***'
- en: 'The zip() function takes the form zip(iter1 [,iter2 [...]]). It takes multiple
    sequences and combines them into tuples. This is useful when you need to combine
    a list of keys and a list of values into a dict. As with the other functions described
    here, zip() returns a list in Python 2 and an iterable in Python 3\. Here we map
    a list of keys to a list of values to create a dictionary:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: zip() 函数的形式为 zip(iter1 [,iter2 [...]]). 它接受多个序列并将它们组合成元组。当你需要将一组键与一组值组合成字典时，这非常有用。与这里描述的其他函数一样，zip()
    在 Python 2 中返回一个列表，而在 Python 3 中返回一个可迭代对象。这里我们将键列表映射到值列表，从而创建一个字典：
- en: '>>> keys = ["foobar", "barzz", "ba!"]'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> keys = ["foobar", "barzz", "ba!"]'
- en: '>>> map(len, keys)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> map(len, keys)'
- en: <map object at 0x7fc1686100d0>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <map object at 0x7fc1686100d0>
- en: '>>> zip(keys, map(len, keys))'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> zip(keys, map(len, keys))'
- en: <zip object at 0x7fc16860d440>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <zip object at 0x7fc16860d440>
- en: '>>> list(zip(keys, map(len, keys)))'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(zip(keys, map(len, keys)))'
- en: '[(''foobar'', 6), (''barzz'', 5), (''ba!'', 3)]'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''foobar'', 6), (''barzz'', 5), (''ba!'', 3)]'
- en: '>>> dict(zip(keys, map(len, keys)))'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dict(zip(keys, map(len, keys)))'
- en: '{''foobar'': 6, ''barzz'': 5, ''ba!'': 3}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '{''foobar'': 6, ''barzz'': 5, ''ba!'': 3}'
- en: '**FUNCTIONAL FUNCTIONS IN PYTHON 2 AND 3**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 2 和 3 中的函数式函数**'
- en: 'You might have noticed by now how the return types differ between Python 2
    and Python 3\. Most of Python’s purely functional built-in functions return a
    list rather than an iterable in Python 2, making them less memory efficient than
    their Python 3.*x* equivalents. If you’re planning to write code using these functions,
    keep in mind that you’ll get the most benefit out of them in Python 3\. If you’re
    stuck with Python 2, don’t despair: the itertools module from the Standard Library
    provides an iterator-based version of many of these functions (itertools.izip(),
    itertools.imap(), itertools.ifilter(), and so on).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Python 2 和 Python 3 中返回值的类型是不同的。Python 的纯函数式内建函数在 Python 2 中返回的是列表，而不是可迭代对象，这使得它们在内存效率上不如
    Python 3 的 *x* 等价物。如果你打算使用这些函数编写代码，请记住，它们在 Python 3 中能发挥最大的效益。如果你还在使用 Python 2，不用担心：标准库中的
    itertools 模块提供了这些函数的基于迭代器的版本（如 itertools.izip()、itertools.imap()、itertools.ifilter()
    等）。
- en: '***A Common Problem Solved***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解决常见问题***'
- en: 'There’s one important tool still to cover. Often when working with lists we
    want to find the first item that satisfies a specific condition. We’ll look at
    the many ways to accomplish this and then see the most efficient way: the first
    package.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的工具尚未介绍。我们在处理列表时，常常需要找到第一个满足特定条件的项。我们将研究多种实现方式，并最终看到最有效的方法：first 包。
- en: '**Finding the Item with Simple Code**'
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用简单代码查找项**'
- en: 'We might be able to find the first item to satisfy a condition with a function
    like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能能够通过像这样的函数找到第一个满足条件的项：
- en: 'def first_positive_number(numbers):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'def first_positive_number(numbers):'
- en: 'for n in numbers:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'for n in numbers:'
- en: 'if n > 0:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n > 0:'
- en: return n
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: return n
- en: 'We could rewrite the first_positive_number() function in functional style like
    this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样用函数式风格重写 first_positive_number() 函数：
- en: 'def first(predicate, items):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'def first(predicate, items):'
- en: 'for item in items:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in items:'
- en: 'if predicate(item):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'if predicate(item):'
- en: return item
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: return item
- en: 'first(lambda x: x > 0, [-1, 0, 1, 2])'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'first(lambda x: x > 0, [-1, 0, 1, 2])'
- en: 'By using a functional approach where the predicate is passed as argument, the
    function becomes easily reusable. We could even write it more concisely, like
    so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用函数式编程方法，将谓词作为参数传递，函数变得更容易重用。我们甚至可以将其写得更简洁，像这样：
- en: Less efficient
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低效
- en: 'list(filter(lambda x: x > 0, [-1, 0, 1, 2]))[0]'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'list(filter(lambda x: x > 0, [-1, 0, 1, 2]))[0]'
- en: Efficient
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效
- en: 'next(filter(lambda x: x > 0, [-1, 0, 1, 2]))'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'next(filter(lambda x: x > 0, [-1, 0, 1, 2]))'
- en: Note that this may raise an IndexError if no items satisfy the condition, causing
    list(filter()) to return an empty list.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有项目满足条件，这可能会引发IndexError，从而导致list(filter())返回一个空列表。
- en: 'For simple cases, you can rely on next() to prevent IndexError from occurring,
    like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的情况，你可以依靠next()来防止IndexError的发生，像这样：
- en: '>>> a = range(10)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = range(10)'
- en: '>>> next(x for x in a if x > 3)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next(x for x in a if x > 3)'
- en: '4'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '[Listing 8-6](ch08.xhtml#ch8list6) will raise StopIteration if a condition
    can never be satisfied. This too can be solved by adding a second argument of
    next(), like so.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-6](ch08.xhtml#ch8list6)将引发StopIteration错误，如果条件永远无法满足。这个问题也可以通过在next()中添加第二个参数来解决，像这样：'
- en: '>>> a = range(10)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = range(10)'
- en: '>>> next((x for x in a if x > 10), ''default'')'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> next((x for x in a if x > 10), ''默认值'')'
- en: '''default'''
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '''默认值'''
- en: '*Listing 8-6: Returning a default value when the condition is not met*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-6：在条件不满足时返回默认值*'
- en: This will return a default value rather than an error when a condition cannot
    be met. Lucky for us, Python provides a package to handle all of this for us.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件无法满足时，这将返回默认值，而不是错误。幸运的是，Python提供了一个包来处理这些问题。
- en: '**Finding the Item Using first()**'
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用first()查找项目**'
- en: Rather than writing out the function from [Listing 8-6](ch08.xhtml#ch8list6)
    in all of your programs, you can include the small Python package first. [Listing
    8-7](ch08.xhtml#ch8list7) shows how this package lets you find the first element
    of an iterable matching a condition.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在所有程序中都写出[示例 8-6](ch08.xhtml#ch8list6)中的函数，不如首先包含这个小的Python包。[示例 8-7](ch08.xhtml#ch8list7)展示了这个包如何让你找到符合条件的可迭代对象中的第一个元素。
- en: '>>> from first import first'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from first import first'
- en: '>>> first([0, False, None, [], (), 42])'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first([0, False, None, [], (), 42])'
- en: '42'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: '>>> first([-1, 0, 1, 2])'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first([-1, 0, 1, 2])'
- en: '-1'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '-1'
- en: '>>> first([-1, 0, 1, 2], key=lambda x: x > 0)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first([-1, 0, 1, 2], key=lambda x: x > 0)'
- en: '1'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '*Listing 8-7: Finding the first item in a list that satisfies a condition*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-7：查找列表中第一个满足条件的项目*'
- en: You see that the first() function returns the first valid, non-empty item in
    a list.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，first()函数返回列表中第一个有效的非空项目。
- en: '**Using lambda() with functools**'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用lambda()与functools**'
- en: You’ll notice that we’ve used lambda() in a good portion of the examples so
    far in this chapter. The lambda() function was added to Python to facilitate functional
    programming functions such as map() and filter(), which otherwise would have required
    writing an entirely new function every time you wanted to check a different condition.
    [Listing 8-8](ch08.xhtml#ch8list8) is equivalent to [Listing 8-7](ch08.xhtml#ch8list7)
    but is written without using lambda().
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们在本章的很多示例中都使用了lambda()。lambda()函数是Python为了方便函数式编程而加入的，用于像map()和filter()这样的函数，否则每次想要检查不同的条件时都需要编写一个全新的函数。[示例
    8-8](ch08.xhtml#ch8list8)等同于[示例 8-7](ch08.xhtml#ch8list7)，但没有使用lambda()。
- en: import operator
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: import operator
- en: from first import first
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: from first import first
- en: 'def greater_than_zero(number):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'def greater_than_zero(number):'
- en: return number > 0
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: return number > 0
- en: first([-1, 0, 1, 2], key=greater_than_zero)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: first([-1, 0, 1, 2], key=greater_than_zero)
- en: '*Listing 8-8: Finding the first item to meet the condition, without using lambda()*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-8：在不使用lambda()的情况下找到第一个满足条件的项目*'
- en: 'This code works identically to that in [Listing 8-7](ch08.xhtml#ch8list7),
    returning the first non-empty value in a list to meet the condition, but it’s
    a good deal more cumbersome: if we wanted to get the first number in the sequence
    that’s longer than, say, 42 items, we’d need to define an appropriate function
    via def rather than defining it inline with our call to first().'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[示例 8-7](ch08.xhtml#ch8list7)中的代码完全相同，返回满足条件的列表中第一个非空值，但它要繁琐得多：如果我们想要获取一个长度超过42项的序列中的第一个数字，我们就需要通过def定义一个合适的函数，而不是像调用first()时那样在线定义它。
- en: 'But despite its usefulness in helping us avoid situations like this, lambda
    still has its problems. The first module contains a key argument that can be used
    to provide a function that receives each item as an argument and returns a Boolean
    indicating whether it satisfies the condition. However, we can’t pass a key function,
    as it would require more than a single line of code: a lambda statement cannot
    be written on more than one line. That is a significant limitation of lambda.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管lambda在帮助我们避免类似问题时很有用，但它仍然存在一些问题。first模块包含一个key参数，可以用来提供一个接收每个项目并返回布尔值的函数，指示该项目是否满足条件。然而，我们无法传递key函数，因为它需要的代码超过了一行：lambda语句不能写在多于一行的地方。这是lambda的一个重大限制。
- en: Instead, we would have to go back to the cumbersome pattern of writing new function
    definitions for each key we need. Or would we?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将不得不回到繁琐的模式，为每个需要的键编写新的函数定义。但真的是这样吗？
- en: 'The functools package comes to the rescue with its partial() method, which
    provides us with a more flexible alternative to lambda. The functools.partial()
    method allows us to create a wrapper function with a twist: rather than changing
    the behavior of a function, it instead changes the *arguments* it receives, like
    so:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: functools 包通过它的 partial() 方法提供了解决方案，这给我们提供了一个比 lambda 更灵活的替代方式。functools.partial()
    方法允许我们创建一个包装函数，但有一个不同之处：它不会改变函数的行为，而是改变它接收的 *参数*，就像这样：
- en: from functools import partial
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从 functools 导入 partial
- en: from first import first
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从 first 导入 first
- en: '➊ def greater_than(number, min=0):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def greater_than(number, min=0):'
- en: return number > min
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: return number > min
- en: ➋ first([-1, 0, 1, 2], key=partial(greater_than, min=42))
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ first([-1, 0, 1, 2], key=partial(greater_than, min=42))
- en: Here we create a new greater_than() function that works just like the old greater_than_zero()
    from [Listing 8-8](ch08.xhtml#ch8list8) by default, but this version allows us
    to specify the value we want to compare our numbers to, whereas before it was
    hardcoded. Here, we pass functools.partial() to our function and the value we
    want for min ➊, and we get back a new function that has min set to 42, just as
    we want ➋. In other words, we can write a function and use functools.partial()
    to customize the behavior of our new functions to suit our needs in any given
    situation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的 greater_than() 函数，它的行为与[示例 8-8](ch08.xhtml#ch8list8)中的 greater_than_zero()
    函数相同，但这个版本允许我们指定我们希望与之比较的值，而以前是硬编码的。在这里，我们将 functools.partial() 传递给我们的函数和我们想要的
    min 值 ➊，然后我们得到一个新函数，它的 min 值设置为 42，正如我们希望的那样 ➋。换句话说，我们可以编写一个函数并使用 functools.partial()
    来定制我们新函数的行为，以适应任何特定情况。
- en: 'Even this version can be pared down. All we’re doing in this example is comparing
    two numbers, and as it turns out, the operator module has built-in functions for
    exactly that:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这个版本也可以进一步简化。在这个例子中，我们只是在比较两个数字，结果发现 operator 模块有内置的函数正是用于做这个的：
- en: import operator
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 operator
- en: from functools import partial
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从 functools 导入 partial
- en: from first import first
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从 first 导入 first
- en: first([-1, 0, 1, 2], key=partial(operator.le, 0))
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: first([-1, 0, 1, 2], key=partial(operator.le, 0))
- en: This is a good example of functools.partial() working with positional arguments.
    In this case, the function operator.le(a, b), which takes two numbers and returns
    a Boolean that tells us whether the first number is less than or equal to the
    second, is passed to functools.partial(). The 0 we pass to functools.partial()
    gets assigned to a, and the argument passed to the function returned by functools.partial()
    gets assigned to b. So this works identically to [Listing 8-8](ch08.xhtml#ch8list8)
    but without using lambda or defining any additional functions.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，展示了 functools.partial() 如何与位置参数配合使用。在这个例子中，函数 operator.le(a, b) 接受两个数字并返回一个布尔值，告诉我们第一个数字是否小于或等于第二个数字，它被传递给
    functools.partial()。我们传递给 functools.partial() 的 0 被赋值给 a，传递给 functools.partial()
    返回的函数的参数则赋值给 b。所以这个例子与[示例 8-8](ch08.xhtml#ch8list8)的实现方式相同，只不过没有使用 lambda 或定义额外的函数。
- en: '**NOTE**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The functools.partial() method is typically useful in place of lambda and
    should be considered a superior alternative. The lambda function is something
    of an anomaly in the Python language, and dropping it altogether was considered
    for Python 3 due to the function’s limited body size of a single line.*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*functools.partial() 方法通常用于替代 lambda，应该被视为一种更优的替代方案。lambda 函数在 Python 中有点像异类，由于该函数体的大小仅限于一行，Python
    3 曾考虑过完全去掉它。*'
- en: '***Useful itertools Functions***'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有用的 itertools 函数***'
- en: Finally, we’ll look at some useful functions in the itertools module in the
    Python Standard Library that you should be aware of. Too many programmers end
    up writing their own versions of these functions simply because they aren’t aware
    that Python provides them out of the box. They are all designed to help you manipulate
    iterator (that’s why the module is called *iter-tools*) and therefore are all
    purely functional. Here I’ll list a few of them and give a brief overview of what
    they do, and I encourage you to look into them further if they seem of use.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将了解一些 Python 标准库中 itertools 模块的有用函数，您应该知道它们。许多程序员因为不知道 Python 已经提供了这些功能，所以会自己编写这些函数。它们都是为帮助您操作迭代器而设计的（这就是该模块名为
    *iter-tools* 的原因），因此它们都是纯函数式的。这里我将列出其中一些，并简要介绍它们的功能，如果它们对您有用，我鼓励您进一步研究。
- en: accumulate(iterable[, func]) returns a series of accumulated sums of items from
    iterables.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: accumulate(iterable[, func])返回可迭代对象中项目的累积和系列。
- en: chain(*iterables) iterates over multiple iterables, one after another, without
    building an intermediate list of all items.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: chain(*iterables)依次迭代多个可迭代对象，而不构建所有项目的中间列表。
- en: combinations(iterable, r) generates all combinations of length r from the given
    iterable.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: combinations(iterable, r)从给定的可迭代对象生成长度为r的所有组合。
- en: compress(data, selectors) applies a Boolean mask from selectors to data and
    returns only the values from data where the corresponding element of selectors
    is True.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: compress(data, selectors)将从selectors中应用布尔掩码到data，并仅返回data中相应selectors元素为True的值。
- en: count(start, step) generates an endless sequence of values, starting with start
    and incrementing step at a time with each call.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: count(start, step)生成一个从start开始并且每次调用增加step的无限序列值。
- en: cycle(iterable) loops repeatedly over the values in iterable.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cycle(iterable)在可迭代对象中重复循环值。
- en: repeat(elem[, n]) repeats an element n times.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: repeat(elem[, n])重复元素n次。
- en: dropwhile(predicate, iterable) filters elements of an iterable starting from
    the beginning until predicate is False.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dropwhile(predicate, iterable)会从开始处过滤可迭代对象的元素，直到predicate为False。
- en: groupby(iterable, keyfunc) creates an iterator that groups items by the result
    returned by the keyfunc() function.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: groupby(iterable, keyfunc)创建一个迭代器，根据keyfunc()函数返回的结果对项目进行分组。
- en: permutations(iterable[, r]) returns successive r-length permutations of the
    items in iterable.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: permutations(iterable[, r])返回可迭代对象中项目的连续r长度排列。
- en: product(*iterables) returns an iterable of the Cartesian product of iterables
    without using a nested for loop.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: product(*iterables)返回iterables的笛卡尔积的可迭代对象，而不使用嵌套的for循环。
- en: takewhile(predicate, iterable) returns elements of an iterable starting from
    the beginning until predicate is False.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: takewhile(predicate, iterable)返回从开始处的可迭代对象的元素，直到predicate为False。
- en: 'These functions are particularly useful in conjunction with the operator module.
    When used together, itertools and operator can handle most situations that programmers
    typically rely on lambda for. Here’s an example of using operator.itemgetter()
    instead of writing lambda x: x[''foo'']:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '这些函数与操作符模块一起使用特别有用。当结合使用时，itertools和operator可以处理程序员通常依赖lambda处理的大多数情况。以下是使用operator.itemgetter()而不是编写lambda
    x: x[''foo'']的示例：'
- en: '>>> import itertools'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import itertools'
- en: '>>> a = [{''foo'': ''bar''}, {''foo'': ''bar'', ''x'': 42}, {''foo'': ''baz'',
    ''y'': 43}]'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [{''foo'': ''bar''}, {''foo'': ''bar'', ''x'': 42}, {''foo'': ''baz'',
    ''y'': 43}]'
- en: '>>> import operator'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import operator'
- en: '>>> list(itertools.groupby(a, operator.itemgetter(''foo'')))'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(itertools.groupby(a, operator.itemgetter(''foo'')))'
- en: '[(''bar'', <itertools._grouper object at 0xb000d0>), (''baz'', <itertools._grouper
    object at'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''bar'', <itertools._grouper object at 0xb000d0>), (''baz'', <itertools._grouper
    object at 0xb00110>)]'
- en: 0xb00110>)]
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 0xb00110>)]
- en: '>>> [(key, list(group)) for key, group in itertools.groupby(a, operator.itemgetter(''foo''))]'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [(key, list(group)) for key, group in itertools.groupby(a, operator.itemgetter(''foo''))]'
- en: '[(''bar'', [{''foo'': ''bar''}, {''x'': 42, ''foo'': ''bar''}]), (''baz'',
    [{''y'': 43, ''foo'': ''baz''}])]'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''bar'', [{''foo'': ''bar''}, {''x'': 42, ''foo'': ''bar''}]), (''baz'',
    [{''y'': 43, ''foo'': ''baz''}])]'
- en: 'In this case, we could have also written lambda x: x[''foo''], but using operator
    lets us avoid having to use lambda at all.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们也可以写lambda x: x[''foo'']，但使用操作符可以避免完全使用lambda。'
- en: '**Summary**'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: While Python is often advertised as being object oriented, it can be used in
    a very functional manner. A lot of its built-in concepts, such as generators and
    list comprehension, are functionally oriented and don’t conflict with an object-oriented
    approach. They also limit the reliance on a program’s global state, for your own
    good.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python经常被宣传为面向对象的，但它也可以以非常函数式的方式使用。它的许多内置概念，如生成器和列表推导式，是函数式的，并且不与面向对象的方法冲突。它们还限制了程序对全局状态的依赖，为了你自己的好处。
- en: Using functional programming as a paradigm in Python can help you make your
    program more reusable and easier to test and debug, supporting the Don’t Repeat
    Yourself (DRY) mantra. In this spirit, the standard Python modules itertools and
    operator are good tools to improve the readability of your functional code.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用函数式编程作为一种范式可以帮助你使程序更可重用、更易于测试和调试，支持“不重复自己”（DRY）的信条。在这种精神下，标准Python模块itertools和operator是改进你的函数式代码可读性的好工具。
