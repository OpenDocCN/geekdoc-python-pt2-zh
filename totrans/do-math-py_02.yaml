- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**Visualizing Data with Graphs**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用图形可视化数据**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: 'In this chapter, you’ll learn a powerful way to present numerical data: by
    drawing graphs with Python. We’ll start by discussing the number line and the
    Cartesian plane. Next, we’ll learn about the powerful plotting library *matplotlib*
    and how we can use it to create graphs. We’ll then explore how to make graphs
    that present data clearly and intuitively. Finally, we’ll use graphs to explore
    Newton’s law of universal gravitation and projectile motion. Let’s get started!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习一种强大的展示数值数据的方式：使用Python绘制图表。我们将从讨论数轴和笛卡尔平面开始。接下来，我们将了解强大的绘图库*matplotlib*以及如何使用它来创建图表。然后，我们将探索如何制作清晰且直观地展示数据的图表。最后，我们将使用图表来探索牛顿的万有引力定律和抛体运动。让我们开始吧！
- en: '**Understanding the Cartesian Coordinate Plane**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解笛卡尔坐标平面**'
- en: 'Consider a *number line*, like the one shown in [Figure 2-1](ch02.html#ch2fig1).
    Integers from –3 to 3 are marked on the line, but between any of these two numbers
    (say, 1 and 2) lie all possible numbers in between: 1.1, 1.2, 1.3, and so on.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下*数轴*，如[图 2-1](ch02.html#ch2fig1)所示。–3到3之间的整数标记在数轴上，但这两个数字之间的任何位置（比如1和2之间）都有所有可能的数字：1.1，1.2，1.3，依此类推。
- en: '![image](images/f02-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-01.jpg)'
- en: '*Figure 2-1: A number line*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：数轴*'
- en: The number line makes certain properties visually intuitive. For example, all
    numbers on the right side of 0 are positive, and those on the left side are negative.
    When a number *a* lies on the right side of another number *b*, *a* is always
    greater than *b* and *b* is always less than *a*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数轴使得某些属性在视觉上变得直观。例如，0右侧的所有数字都是正数，左侧的则是负数。当一个数字*a*位于另一个数字*b*的右侧时，*a*总是大于*b*，而*b*总是小于*a*。
- en: The arrows at the ends of the number line indicate that the line extends infinitely,
    and any point on this line corresponds to some real number, however large it may
    be. A single number is sufficient to describe a point on the number line.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数轴两端的箭头表示这条线延伸到无限远，且这条线上的任何一点都对应一个实数，无论它有多大。一个数字足以描述数轴上的一点。
- en: Now consider two number lines arranged as shown in [Figure 2-2](ch02.html#ch2fig2).
    The number lines intersect at right angles to each other and cross at the 0 point
    of each line. This forms a *Cartesian coordinate plane*, or an *x*-*y* plane,
    with the horizontal number line called the *x*-axis and the vertical line called
    the *y*-axis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑如[图 2-2](ch02.html#ch2fig2)所示的两条数轴。这两条数轴相交成直角，并在每条轴的0点交叉。这形成了一个*笛卡尔坐标平面*，或称*x*-*y*平面，水平的数轴叫做*x*轴，垂直的数轴叫做*y*轴。
- en: '![image](images/f02-02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-02.jpg)'
- en: '*Figure 2-2: The Cartesian coordinate plane*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：笛卡尔坐标平面*'
- en: As with the number line, we can have infinitely many points on the plane. We
    describe a point with a pair of numbers instead of one number. For example, we
    describe the point *A* in the figure with two numbers, *x* and *y*, usually written
    as (*x*, *y*) and referred to as the *coordinates* of the point. As shown in [Figure
    2-2](ch02.html#ch2fig2), *x* is the distance of the point from the origin along
    the *x*-axis, and *y* is the distance along the *y*-axis. The point where the
    two axes intersect is called the *origin* and has the coordinates (0, 0).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与数轴一样，我们可以在平面上有无限多个点。我们用一对数字来描述一个点，而不是用一个数字。例如，我们用两个数字*x*和*y*来描述图中的点*A*，通常写作(*x*,
    *y*)，并称之为该点的*坐标*。如[图 2-2](ch02.html#ch2fig2)所示，*x*是该点沿*x*轴到原点的距离，*y*是该点沿*y*轴的距离。两条坐标轴的交点称为*原点*，坐标为(0,
    0)。
- en: The Cartesian coordinate plane allows us to visualize the relationship between
    two sets of numbers. Here, I use the term *set* loosely to mean a collection of
    numbers. (We’ll learn about mathematical sets and how to work with them in Python
    in [Chapter 5](ch05.html#ch05).) No matter what the two sets of numbers represent—temperature,
    baseball scores, or class test scores—all you need are the numbers themselves.
    Then, you can plot them—either on graph paper or on your computer with a program
    written in Python. For the rest of this book, I’ll use the term *plot* as a verb
    to describe the act of plotting two sets of numbers and the term *graph* to describe
    the result—a line, curve, or simply a set of points on the Cartesian plane.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔坐标平面使我们能够直观地展示两个数字集合之间的关系。在这里，我使用 *集合* 这个词来泛指一组数字。（我们将在 [第 5 章](ch05.html#ch05)
    学习数学集合及如何在 Python 中操作它们。）无论这两个数字集合代表什么——温度、棒球得分或班级测试分数——你只需要这些数字本身。然后，你可以将它们绘制出来——无论是在图表纸上，还是通过在
    Python 中编写程序在电脑上绘制。从本书的这一部分开始，我将使用 *绘制* 作为动词，描述绘制两个数字集合的行为，而使用 *图形* 来描述结果——一条线、一条曲线，或仅仅是笛卡尔平面上的一组点。
- en: '**Working with Lists and Tuples**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理列表和元组**'
- en: 'As we make graphs with Python, we’ll work with *lists* and *tuples*. In Python,
    these are two different ways to store groups of values. Tuples and lists are very
    similar for the most part, with one major difference: after you create a list,
    it’s possible to add values to it and to change the order of the values. The values
    in a tuple, on the other hand, are immediately fixed and can’t be changed. We’ll
    use lists to store *x*- and *y*-coordinates for the points we want to plot. Tuples
    will come up in “[Customizing Graphs](ch02.html#ch02lev2sec05)” on [page 41](ch02.html#page_41)
    when we learn to customize the range of our graphs. First, let’s go over some
    features of lists.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Python 绘制图形时，我们将使用 *列表* 和 *元组*。在 Python 中，这两者是存储一组值的两种不同方式。大部分情况下，元组和列表非常相似，唯一的主要区别是：创建列表后，可以向其中添加值并改变值的顺序。另一方面，元组中的值一旦确定，就无法更改。我们将使用列表来存储我们要绘制的点的
    *x* 和 *y* 坐标。元组将在 “[定制图形](ch02.html#ch02lev2sec05)” 中出现，出现在 [第 41 页](ch02.html#page_41)，当我们学习如何定制图形的范围时。首先，让我们回顾一下列表的一些特性。
- en: 'You can create a list by entering values, separated by commas, between square
    brackets. The following statement creates a list and uses the label simplelist
    to refer to it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方括号中输入用逗号分隔的值来创建一个列表。以下语句创建了一个列表，并使用标签 simplelist 来引用它：
- en: '>>> simplelist = [1, 2, 3]'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simplelist = [1, 2, 3]'
- en: 'Now you can refer to the individual numbers—1, 2, and 3—using the label and
    the position of the number in the list, which is called the *index*. So simplelist[0]
    refers to the first number, simplelist[1] refers to the second number, and simplelist[2]
    refers to the third number:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过标签和数字在列表中的位置来引用单个数字——1、2 和 3，这个位置叫做 *索引*。因此，simplelist[0] 指代第一个数字，simplelist[1]
    指代第二个数字，simplelist[2] 指代第三个数字：
- en: '>>> simplelist[0]'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simplelist[0]'
- en: '1'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> simplelist[1]'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simplelist[1]'
- en: '2'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> simplelist[2]'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simplelist[2]'
- en: '3'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: Notice that the first item of the list is at index 0, the second item is at
    index 1, and so on—that is, the positions in the list start counting from 0, not
    1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表的第一个项目位于索引 0，第二个项目位于索引 1，依此类推——也就是说，列表中的位置从 0 开始计数，而不是从 1 开始。
- en: 'Lists can store strings, too:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也可以存储字符串：
- en: '>>> stringlist = [''a string'',''b string'',''c string'']'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> stringlist = [''a string'', ''b string'', ''c string'']'
- en: '>>> stringlist[0]'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> stringlist[0]'
- en: '''a string'''
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '''a string'''
- en: '>>> stringlist[1]'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> stringlist[1]'
- en: '''b string'''
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '''b string'''
- en: '>>> stringlist[2]'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> stringlist[2]'
- en: '''c string'''
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '''c string'''
- en: One advantage of creating a list is that you don’t have to create a separate
    label for each value; you just create a label for the list and use the index position
    to refer to each item. Also, you can add to the list whenever you need to store
    new values, so a list is the best choice for storing data if you don’t know beforehand
    how many numbers or strings you may need to store.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的一个优点是你不需要为每个值创建一个单独的标签；你只需为列表创建一个标签，并使用索引位置来引用每个项目。此外，你可以在需要时将新值添加到列表中，因此，如果你无法预先知道需要存储多少数字或字符串，列表是存储数据的最佳选择。
- en: 'An *empty list* is just that—a list with no items or elements—and it can be
    created like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*空列表* 就是一个没有任何项目或元素的列表，它可以通过如下方式创建：'
- en: '>>> emptylist = []'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> emptylist = []'
- en: 'Empty lists are mainly useful when you don’t know any of the items that will
    be in your list beforehand but plan to fill in values during the execution of
    a program. In that case, you can create an empty list and then use the append()
    method to add items later:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表主要在你事先不知道列表中的任何元素，但计划在程序执行过程中添加值时很有用。在这种情况下，你可以创建一个空列表，然后使用 append() 方法稍后添加项：
- en: ➊ >>> emptylist
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> emptylist
- en: '[]'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[]'
- en: ➋ >>> emptylist.append(1)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> emptylist.append(1)
- en: '>>> emptylist'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> emptylist'
- en: '[1]'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[1]'
- en: ➌ >>> emptylist.append(2)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> emptylist.append(2)
- en: '>>> emptylist'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> emptylist'
- en: ➍ [1, 2]
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ [1, 2]
- en: At ➊, emptylist starts off empty. Next, we append the number 1 to the list at
    ➋ and then append 2 at ➌. By line ➍, the list is now [1, 2]. Note that when you
    use .append(), the value gets added to the end of the list. This is just one way
    of adding values to a list. There are others, but we won’t need them for this
    chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，emptylist 开始为空。接着，我们在 ➋ 处将数字 1 添加到列表中，在 ➌ 处添加 2。到 ➍ 行时，列表变为 [1, 2]。请注意，当你使用
    .append() 时，值会被添加到列表的末尾。这只是向列表添加值的一种方式，其他方法我们在本章中不需要介绍。
- en: 'Creating a tuple is similar to creating a list, but instead of square brackets,
    you use parentheses:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组与创建列表类似，不同的是你使用圆括号而不是方括号：
- en: '>>> simpletuple = (1, 2, 3)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simpletuple = (1, 2, 3)'
- en: 'You can refer to an individual number in simpletuple using the corresponding
    index in brackets, just as with lists:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像对待列表一样，使用相应的索引引用 simpletuple 中的单个元素：
- en: '>>> simpletuple[0]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simpletuple[0]'
- en: '1'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> simpletuple[1]'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simpletuple[1]'
- en: '2'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> simpletuple[2]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simpletuple[2]'
- en: '3'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: You can also use *negative indices* with both lists and tuples. For example,
    simplelist[-1] and simpletuple[-1] would refer to the last element of the list
    or the tuple, simplelist[-2] and simpletuple[-2] would refer to the second-to-last
    element, and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在列表和元组中使用*负索引*。例如，simplelist[-1] 和 simpletuple[-1] 会引用列表或元组中的最后一个元素，simplelist[-2]
    和 simpletuple[-2] 会引用倒数第二个元素，以此类推。
- en: Tuples, like lists, can have strings as values, and you can create an *empty
    tuple* with no elements as emptytuple=(). However, there’s no append() method
    to add a new value to an existing tuple, so you can’t add values to an empty tuple.
    Once you create a tuple, the contents of the tuple can’t be changed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 元组像列表一样，可以有字符串作为值，你也可以创建一个*空元组*，其没有任何元素，例如 emptytuple=()。然而，元组没有 append() 方法来添加新的值，所以你无法向空元组添加值。一旦创建了元组，元组的内容就不能改变。
- en: '***Iterating over a List or Tuple***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***遍历列表或元组***'
- en: 'We can go over a list or tuple using a for loop as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 for 循环来遍历列表或元组，如下所示：
- en: '>>> l = [1, 2, 3]'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l = [1, 2, 3]'
- en: '>>> for item in l:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for item in l:'
- en: print(item)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: print(item)
- en: 'This will print the items in the list:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印列表中的项：
- en: '1'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: The items in a tuple can be retrieved in the same way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中的项可以以相同的方式进行检索。
- en: 'Sometimes you might need to know the position or the index of an item in a
    list or tuple. You can use the enumerate() function to iterate over all the items
    of a list and return the index of an item as well as the item itself. We use the
    labels index and item to refer to them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要知道列表或元组中某个项的位置或索引。你可以使用 enumerate() 函数遍历列表中的所有项，并返回项的索引以及该项本身。我们使用标签
    index 和 item 来表示它们：
- en: '>>> l = [1, 2, 3]'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l = [1, 2, 3]'
- en: '>>> for index, item in enumerate(l):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for index, item in enumerate(l):'
- en: print(index, item)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: print(index, item)
- en: 'This will produce the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: 0 1
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 0 1
- en: 1 2
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2
- en: 2 3
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 2 3
- en: This also works for tuples.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于元组。
- en: '**Creating Graphs with Matplotlib**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Matplotlib 创建图表**'
- en: We’ll be using matplotlib to make graphs with Python. Matplotlib is a Python
    *package*, which means that it’s a collection of modules with related functionality.
    In this case, the modules are useful for plotting numbers and making graphs. Matplotlib
    doesn’t come built in with Python’s standard library, so you’ll have to install
    it. The installation instructions are covered in [Appendix A](app01.html#app01).
    Once you have it installed, start a Python shell. As explained in the installation
    instructions, you can either continue using IDLE shell or use Python’s built-in
    shell.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 matplotlib 来使用 Python 绘制图表。Matplotlib 是一个 Python *包*，意味着它是一个包含相关功能模块的集合。在本例中，这些模块用于绘制数字和生成图表。Matplotlib
    并没有与 Python 的标准库一起内置，因此你需要安装它。安装说明可以在 [附录 A](app01.html#app01) 中找到。安装完成后，启动一个
    Python shell。按照安装说明，你可以继续使用 IDLE shell 或使用 Python 的内建 shell。
- en: 'Now we’re ready to create our first graph. We’ll start with a simple graph
    with just three points: (1, 2), (2, 4), and (3, 6). To create this graph, we’ll
    first make two lists of numbers—one storing the values of the *x*-coordinates
    of these points and another storing the *y*-coordinates. The following two statements
    do exactly that, creating the two lists x_numbers and y_numbers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建第一个图表。我们将从一个简单的图表开始，只包含三个点：(1, 2)、(2, 4) 和 (3, 6)。为了创建这个图表，我们首先创建两个数字列表——一个存储这些点的
    *x*-坐标，另一个存储 *y*-坐标。以下两个语句正是执行此操作，创建了两个列表 x_numbers 和 y_numbers：
- en: '>>> x_numbers = [1, 2, 3]'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_numbers = [1, 2, 3]'
- en: '>>> y_numbers = [2, 4, 6]'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y_numbers = [2, 4, 6]'
- en: 'From here, we can create the plot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以创建图表：
- en: '>>> from pylab import plot, show'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from pylab import plot, show'
- en: '>>> plot(x_numbers, y_numbers)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(x_numbers, y_numbers)'
- en: '[<matplotlib.lines.Line2D object at 0x7f83ac60df10>]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f83ac60df10>]'
- en: In the first line, we import the plot() and show() functions from the pylab
    module, which is part of the matplotlib package. Next, we call the plot() function
    in the second line. The first argument to the plot() function is the list of numbers
    we want to plot on the *x*-axis, and the second argument is the corresponding
    list of numbers we want to plot on the *y*-axis. The plot() function returns an
    object—or more precisely, a list containing an object. This object contains the
    information about the graph that we asked Python to create. At this stage, you
    can add more information, such as a title, to the graph, or you can just display
    the graph as it is. For now we’ll just display the graph.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们从 pylab 模块中导入了 plot() 和 show() 函数，这两个函数是 matplotlib 包的一部分。接下来，我们在第二行调用
    plot() 函数。plot() 函数的第一个参数是我们想要绘制在 *x*-轴上的数字列表，第二个参数是我们想要绘制在 *y*-轴上的对应数字列表。plot()
    函数返回一个对象——或者更准确地说，是一个包含该对象的列表。这个对象包含了我们要求 Python 创建的图表信息。在此阶段，你可以为图表添加更多信息，如标题，或者你也可以仅显示当前的图表。现在我们只显示图表。
- en: 'The plot() function only creates the graph. To actually display it, we have
    to call the show() function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: plot() 函数只会创建图表。要实际显示图表，我们必须调用 show() 函数：
- en: '>>> show()'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> show()'
- en: You should see the graph in a matplotlib window as shown in [Figure 2-3](ch02.html#ch2fig3).
    (The display window may look different depending on your operating system, but
    the graph should be the same.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在一个 matplotlib 窗口中看到图表，如[图 2-3](ch02.html#ch2fig3)所示。（显示窗口可能会因操作系统的不同而有所变化，但图表应该是相同的。）
- en: '![image](images/f02-03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-03.jpg)'
- en: '*Figure 2-3: A graph showing a line passing through the points (1, 2), (2,
    4), and (3, 6)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：一个通过点 (1, 2)、(2, 4) 和 (3, 6) 的线的图表*'
- en: Notice that instead of starting from the origin (0, 0), the *x*-axis starts
    from the number 1 and the *y*-axis starts from the number 2\. These are the lowest
    numbers from each of the two lists. Also, you can see increments marked on each
    of the axes (such as 2.5, 3.0, 3.5, etc., on the *y*-axis). In “[Customizing Graphs](ch02.html#ch02lev2sec05)”
    on [page 41](ch02.html#page_41), we’ll learn how to control those aspects of the
    graph, along with how to add axes labels and a graph title.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图表的 *x*-轴不是从原点 (0, 0) 开始，而是从数字 1 开始，*y*-轴从数字 2 开始。这是两个列表中最小的数字。此外，你可以看到每个轴上标出了增量（例如
    *y*-轴上标出了 2.5、3.0、3.5 等）。在[《自定义图表》](ch02.html#ch02lev2sec05)（第 41 页）中，我们将学习如何控制这些图表的方面，以及如何添加坐标轴标签和图表标题。
- en: You’ll notice in the interactive shell that you can’t enter any further statements
    until you close the matplotlib window. Close the graph window so that you can
    continue programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在交互式 shell 中，直到你关闭 matplotlib 窗口，才能输入更多语句。关闭图表窗口后，你就可以继续编程了。
- en: '***Marking Points on Your Graph***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在图表上标记点***'
- en: 'If you want the graph to mark the points that you supplied for plotting, you
    can use an additional keyword argument while calling the plot() function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望图表标出你提供的绘制点，可以在调用 plot() 函数时使用一个额外的关键字参数：
- en: '>>> plot(x_numbers, y_numbers, marker=''o'')'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(x_numbers, y_numbers, marker=''o'')'
- en: By entering marker='o', we tell Python to mark each point from our lists with
    a small dot that looks like an *o*. Once you enter show() again, you’ll see that
    each point is marked with a dot (see [Figure 2-4](ch02.html#ch2fig4)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 marker='o'，我们告诉 Python 用一个像 *o* 一样的小点来标记列表中的每个点。再次输入 show() 后，你将看到每个点都被一个小点标记出来（见[图
    2-4](ch02.html#ch2fig4)）。
- en: '![image](images/f02-04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-04.jpg)'
- en: '*Figure 2-4: A graph showing a line passing through the points (1, 2), (2,
    4), and (3, 6) with the points marked by a dot*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：显示通过点(1, 2)、(2, 4)和(3, 6)的线，并用点标记这些点的图表*'
- en: 'The marker at (2, 4) is easily visible, while the others are hidden in the
    very corners of the graph. You can choose from several marker options, including
    ''o'', ''*'', ''x'', and ''+''. Using marker= includes a line connecting the points
    (this is the default). You can also make a graph that marks only the points that
    you specified, without any line connecting them, by omitting marker=:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 位于(2, 4)的标记很容易看到，而其他标记则隐藏在图表的角落中。你可以从几种标记选项中选择，包括'o'、'*'、'x'和'+'。使用`marker=`会在点之间连接一条线（这是默认设置）。你也可以通过省略`marker=`来创建只标记你指定的点，而不连接它们的图形：
- en: '>>> plot(x_numbers, y_numbers, ''o'')'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(x_numbers, y_numbers, ''o'')'
- en: '[<matplotlib.lines.Line2D object at 0x7f2549bc0bd0>]'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f2549bc0bd0>]'
- en: Here, 'o' indicates that each point should be marked with a dot, but there should
    be no line connecting the points. Call the function show() to display the graph,
    which should look like the one shown in [Figure 2-5](ch02.html#ch2fig5).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，'o'表示每个点应该用圆点标记，但点之间不应连接线条。调用show()函数来显示图表，图表应与[图 2-5](ch02.html#ch2fig5)中的图表类似。
- en: '![image](images/f02-05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-05.jpg)'
- en: '*Figure 2-5: A graph showing the points (1, 2), (2, 4), and (3, 6)*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：显示点(1, 2)、(2, 4)和(3, 6)的图表*'
- en: As you can see, only the points are now shown on the graph, with no line connecting
    them. As in the previous graph, the first and the last points are barely visible,
    but we’ll soon see how to change that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在图表上仅显示了点，没有连接它们的线条。与之前的图表一样，第一个和最后一个点几乎不可见，但我们很快就会看到如何改变这一点。
- en: '***Graphing the Average Annual Temperature in New York City***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制纽约市年平均气温图***'
- en: 'Let’s take a look at a slightly larger set of data so we can explore more features
    of matplotlib. The average annual temperatures for New York City— measured at
    Central Park, specifically—during the years 2000 to 2012 are as follows: 53.9,
    56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, and 57.3 degrees
    Fahrenheit. Right now, that just looks like a random jumble of numbers, but we
    can plot this set of temperatures on a graph to make the rise and fall in the
    average temperature from year to year much clearer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一组稍大的数据集，这样我们可以探索matplotlib的更多功能。2000到2012年期间，纽约市中央公园测得的年平均气温如下：53.9、56.3、56.4、53.4、54.5、55.8、56.8、55.0、55.3、54.0、56.7、56.4和57.3华氏度。目前，这看起来像是一堆随机的数字，但我们可以将这些气温数据绘制成图表，以便更清楚地看到每年气温的变化：
- en: '>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0,
    56.7, 56.4, 57.3]'
- en: '>>> plot(nyc_temp, marker=''o'')'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(nyc_temp, marker=''o'')'
- en: '[<matplotlib.lines.Line2D object at 0x7f2549d52f90>]'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f2549d52f90>]'
- en: We store the average temperatures in a list, nyc_temp. Then, we call the function
    plot() passing only this list (and the marker string). When you use plot() on
    a single list, those numbers are automatically plotted on the *y*-axis. The corresponding
    values on the *x*-axis are filled in as the positions of each value in the list.
    That is, the first temperature value, 53.9, gets a corresponding *x*-axis value
    of 0 because it’s in position 0 of the list (remember, the list position starts
    counting from 0, not 1). As a result, the numbers plotted on the *x*-axis are
    the integers from 0 to 12, which we can think of as corresponding to the 13 years
    for which we have temperature data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将平均气温存储在列表`nyc_temp`中。然后，调用`plot()`函数，只传入这个列表（和标记字符串）。当你对单个列表使用`plot()`时，这些数字会自动绘制在*y*轴上。对应的*x*轴值则填充为列表中每个值的位置。也就是说，第一个温度值53.9的对应*x*轴值是0，因为它位于列表的第0个位置（记住，列表的位置从0开始计数，而不是从1）。因此，绘制在*x*轴上的数字是从0到12的整数，我们可以把它们看作是对应我们有气温数据的13年。
- en: Enter show() to display the graph, which is shown in [Figure 2-6](ch02.html#ch2fig6).
    The graph shows that the average temperature has risen and fallen from year to
    year. If you glance at the numbers we plotted, they really aren’t very far apart
    from each other. However, the graph makes the variations seem rather dramatic.
    So, what’s going on? The reason is that matplotlib chooses the range of the *y*-axis
    so that it’s just enough to enclose the data supplied for plotting. So in this
    graph, the *y*-axis starts at 53.0 and its highest value is 57.5\. This makes
    even small differences look magnified because the range of the *y*-axis is so
    small. We’ll learn how to control the range of each axis in “[Customizing Graphs](ch02.html#ch02lev2sec05)”
    on [page 41](ch02.html#page_41).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输入show()以显示图表，该图表显示在[图 2-6](ch02.html#ch2fig6)中。图表显示了平均温度逐年上下波动。如果您快速浏览我们绘制的数字，您会发现它们之间的差距并不大。然而，图表让这些变化看起来相当戏剧化。那么，发生了什么呢？原因是matplotlib选择了一个*
    y *轴的范围，使其恰好足以包含所提供的数据。因此，在这个图表中，* y *轴的起点是53.0，最高值是57.5。这使得即使是微小的差异也显得被放大了，因为*
    y *轴的范围非常小。我们将在“[自定义图表](ch02.html#ch02lev2sec05)”中学习如何控制每个轴的范围，详见[第 41 页](ch02.html#page_41)。
- en: '![image](images/f02-06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-06.jpg)'
- en: '*Figure 2-6: A graph showing the average annual temperature of New York City
    during the years 2000–2012*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：显示纽约市2000年至2012年平均年温度的图表*'
- en: You can also see that numbers on the *y*-axis are floating point numbers (because
    that’s what we asked to be plotted) and those on the *x*-axis are integers. Matplotlib
    can handle either.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到，* y *轴上的数字是浮动的小数（因为我们要求绘制这些），而* x *轴上的数字是整数。Matplotlib可以处理这两种情况。
- en: 'Plotting the temperature without showing the corresponding years is a quick
    and easy way to visualize the variations between the years. If you were planning
    to present this graph to someone, however, you’d want to make it clearer by showing
    which year each temperature corresponds to. We can easily do this by creating
    another list with the years in it and then calling the plot() function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制温度数据而不显示相应的年份是一个快速且简便的方法来可视化各年之间的变化。然而，如果你打算向别人展示这个图表，你会希望通过显示每个温度对应的年份来使其更清晰。我们可以通过创建另一个包含年份的列表，并调用plot()函数来轻松做到这一点：
- en: '>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0,
    56.7, 56.4, 57.3]'
- en: '>>> years = range(2000, 2013)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> years = range(2000, 2013)'
- en: '>>> plot(years, nyc_temp, marker=''o'')'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(years, nyc_temp, marker=''o'')'
- en: '[<matplotlib.lines.Line2D object at 0x7f2549a616d0>]'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f2549a616d0>]'
- en: '>>> show()'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> show()'
- en: We use the range() function we learned about in [Chapter 1](ch01.html#ch01)
    to specify the years 2000 to 2012\. Now you’ll see the years displayed on the
    *x*-axis (see [Figure 2-7](ch02.html#ch2fig7)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在[第 1 章](ch01.html#ch01)中学到的range()函数来指定2000到2012年。现在，您将看到年份显示在* x *轴上（见[图
    2-7](ch02.html#ch2fig7)）。
- en: '![image](images/f02-07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-07.jpg)'
- en: '*Figure 2-7: A graph showing the average annual temperature of New York City,
    displaying the years on the* x-*axis*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：显示纽约市平均年温度的图表，年份显示在* x *轴上*'
- en: '***Comparing the Monthly Temperature Trends of New York City***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比较纽约市每月温度趋势***'
- en: 'While still looking at New York City, let’s see how the average monthly temperature
    has varied over the years. This will give us a chance to understand how to plot
    multiple lines on a single graph. We’ll choose three years: 2000, 2006, and 2012\.
    For each of these years, we’ll plot the average temperature for all 12 months.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 继续关注纽约市，让我们看看多年来每个月的平均温度是如何变化的。这将为我们提供一个机会，了解如何在单一图表上绘制多条线。我们将选择三个年份：2000年、2006年和2012年。对于这三个年份，我们将绘制每个月的平均温度。
- en: 'First, we need to create three lists to store the temperature (in Fahrenheit).
    Each list will consist of 12 numbers corresponding to the average temperature
    from January to December each year:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建三个列表来存储温度（单位：华氏度）。每个列表将包含12个数字，对应每年1月到12月的平均温度：
- en: '>>> nyc_temp_2000 = [31.3, 37.3, 47.2, 51.0, 63.5, 71.3, 72.3, 72.7, 66.0, 57.0, 45.3, 31.1]'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> nyc_temp_2000 = [31.3, 37.3, 47.2, 51.0, 63.5, 71.3, 72.3, 72.7, 66.0,
    57.0, 45.3, 31.1]'
- en: '>>> nyc_temp_2006 = [40.9, 35.7, 43.1, 55.7, 63.1, 71.0, 77.9, 75.8, 66.6, 56.2, 51.9, 43.6]'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> nyc_temp_2006 = [40.9, 35.7, 43.1, 55.7, 63.1, 71.0, 77.9, 75.8, 66.6,
    56.2, 51.9, 43.6]'
- en: '>>> nyc_temp_2012 = [37.3, 40.9, 50.9, 54.8, 65.1, 71.0, 78.8, 76.7, 68.8, 58.0, 43.9, 41.5]'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> nyc_temp_2012 = [37.3, 40.9, 50.9, 54.8, 65.1, 71.0, 78.8, 76.7, 68.8,
    58.0, 43.9, 41.5]'
- en: The first list corresponds to the year 2000, and the next two lists correspond
    to the years 2006 and 2012, respectively. We could plot the three sets of data
    on three different graphs, but that wouldn’t make it very easy to see how each
    year compares to the others. Try doing it!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组列表对应 2000 年，接下来的两组列表分别对应 2006 年和 2012 年。我们本可以将这三组数据绘制在三个不同的图表上，但那样就不容易看出每一年的数据是如何比较的。试试看吧！
- en: 'The clearest way to compare all of these temperatures is to plot all three
    data sets on a *single* graph, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 比较所有这些温度最清晰的方法是将三组数据绘制在 *同一个* 图表上，像这样：
- en: '>>> months = range(1, 13)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> months = range(1, 13)'
- en: '>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)'
- en: '[<matplotlib.lines.Line2D object at 0x7f2549c1f0d0>, <matplotlib.lines.Line2D'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f2549c1f0d0>, <matplotlib.lines.Line2D'
- en: object at 0x7f2549a61150>, <matplotlib.lines.Line2D object at 0x7f2549c1b550>]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: object at 0x7f2549a61150>, <matplotlib.lines.Line2D object at 0x7f2549c1b550>]
- en: First, we create a list (months) where we store the numbers 1, 2, 3, and so
    on up to 12 using the range() function. Next, we call the plot() function with
    three pairs of lists. Each pair consists of a list of months to be plotted on
    the *x*-axis and a list of average monthly temperatures (for 2000, 2006, and 2012,
    respectively) to be plotted on the *y*-axis. So far, we’ve used plot() on only
    one pair of lists at a time, but you can actually enter multiple pairs of lists
    into the plot() function. With each list separated by a comma, the plot() function
    will automatically plot a different line for each pair.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个列表（months），使用 `range()` 函数存储数字 1、2、3，直到 12。接着，我们调用 `plot()` 函数，传入三对列表。每一对包含一个用于绘制
    *x* 轴的月份列表，以及一个用于绘制 *y* 轴的每月平均温度列表（分别对应 2000、2006 和 2012 年）。到目前为止，我们只使用 `plot()`
    绘制了一对列表，但你实际上可以在 `plot()` 函数中输入多个列表对。只要每对列表之间用逗号分隔，`plot()` 函数会自动为每对数据绘制不同的线条。
- en: The plot() function returns a list of three objects instead of one. Matplotlib
    considers the three curves as distinct from each other, and it knows to draw them
    on top of each other when you call show(). Let’s call show() to display the graph,
    as shown in [Figure 2-8](ch02.html#ch2fig8).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()` 函数返回一个包含三项的列表，而不是一项。Matplotlib 将这三条曲线视为独立的，并且知道在你调用 `show()` 时将它们绘制在一起。让我们调用
    `show()` 来显示图表，如[图 2-8](ch02.html#ch2fig8)所示。'
- en: '![image](images/f02-08.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-08.jpg)'
- en: '*Figure 2-8: A graph showing the average monthly temperature of New York City
    during the years 2000, 2006, and 2012*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：显示纽约市 2000 年、2006 年和 2012 年每月平均温度的图表*'
- en: Now we have three plots all on one graph. Python automatically chooses a different
    color for each line to indicate that the lines have been plotted from different
    data sets.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将三条图形绘制在同一个图表上。Python 会自动为每条线选择不同的颜色，以表明这些线条来自不同的数据集。
- en: 'Instead of calling the plot function with all three pairs at once, we could
    also call the plot function three separate times, once for each pair:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以不一次性将所有三对数据传入 `plot()` 函数，而是将 `plot()` 函数分别调用三次，每次传入一对数据：
- en: '>>> plot(months, nyc_temp_2000)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(months, nyc_temp_2000)'
- en: '[<matplotlib.lines.Line2D object at 0x7f1e51351810>]'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f1e51351810>]'
- en: '>>> plot(months, nyc_temp_2006)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(months, nyc_temp_2006)'
- en: '[<matplotlib.lines.Line2D object at 0x7f1e5ae8e390>]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f1e5ae8e390>]'
- en: '>>> plot(months, nyc_temp_2012)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(months, nyc_temp_2012)'
- en: '[<matplotlib.lines.Line2D object at 0x7f1e5136ccd0>]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f1e5136ccd0>]'
- en: '>>> show()'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> show()'
- en: Matplotlib keeps track of what plots haven’t been displayed yet. So as long
    as we wait to call show() until after we call plot() all three times, the plots
    will all get displayed on the same graph.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 会跟踪哪些图形还未显示。因此，只要我们在调用 `show()` 之前，先调用 `plot()` 三次，所有图形都会在同一个图表上显示。
- en: 'We have a problem, however, because we don’t have any clue as to which color
    corresponds to which year. To fix this, we can use the function legend(), which
    lets us add a legend to the graph. A *legend* is a small display box that identifies
    what different parts of the graph mean. Here, we’ll use a legend to indicate which
    year each colored line stands for. To add the legend, first call the plot() function
    as earlier:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了一个问题，因为我们无法知道哪种颜色对应哪个年份。为了解决这个问题，我们可以使用 `legend()` 函数，它允许我们在图表中添加一个图例。*图例*
    是一个小的显示框，用于标识图表中不同部分的含义。在这里，我们将使用图例来标明每种颜色代表的年份。要添加图例，首先像之前一样调用 `plot()` 函数：
- en: '>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)'
- en: '[<matplotlib.lines.Line2D object at 0x7f2549d6c410>, <matplotlib.lines.Line2D'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f2549d6c410>, <matplotlib.lines.Line2D'
- en: object at 0x7f2549d6c9d0>, <matplotlib.lines.Line2D object at 0x7f2549a86850>]
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: object at 0x7f2549d6c9d0>, <matplotlib.lines.Line2D object at 0x7f2549a86850>]
- en: 'Then, import the legend() function from the pylab module and call it as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从 pylab 模块导入 legend() 函数并按如下方式调用：
- en: '>>> from pylab import legend'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from pylab import legend'
- en: '>>> legend([2000, 2006, 2012])'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> legend([2000, 2006, 2012])'
- en: <matplotlib.legend.Legend object at 0x7f2549d79410>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <matplotlib.legend.Legend object at 0x7f2549d79410>
- en: We call the legend() function with a list of the labels we want to use to identify
    each plot on the graph. These labels are entered in this order to match the order
    of the pairs of lists that were entered in the plot() function. That is, 2000
    will be the label for the plot of the first pair we entered in the plot() function;
    2006, for the second pair; and 2012, for the third. You can also specify a second
    argument to the function that will specify the position of the legend. By default,
    it’s always positioned at the top right of the graph. However, you can specify
    a particular position, such as 'lower center', 'center left', and 'upper left'.
    Or you can set the position to 'best', and the legend will be positioned so as
    not to interfere with the graph.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 legend() 函数并传入一组标签，用来标识图表中的每条曲线。标签的顺序与 plot() 函数中输入的数值对的顺序相对应。也就是说，2000将作为
    plot() 函数中第一个数值对的标签；2006作为第二个数值对的标签；2012作为第三个数值对的标签。你还可以指定第二个参数来设置图例的位置。默认情况下，图例总是位于图表的右上角。不过，你可以指定一个特定的位置，比如“lower
    center”（下居中）、“center left”（左居中）或“upper left”（左上）。或者你可以将位置设置为“best”，这样图例会自动调整位置，以避免遮挡图表内容。
- en: 'Finally, we call show() to display the graph:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 show() 来显示图表：
- en: '>>> show()'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> show()'
- en: As you can see in the graph (see [Figure 2-9](ch02.html#ch2fig9)), there’s now
    a legend box in the top-right corner. It tells us which line represents the average
    monthly temperature for the year 2000, which line represents the year 2006, and
    which line represents the year 2012.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示（见[图 2-9](ch02.html#ch2fig9)），现在右上角有一个图例框。它告诉我们哪条线代表2000年的月平均温度，哪条线代表2006年，哪条线代表2012年。
- en: 'Looking at the graph, you can conclude two interesting facts: the highest temperature
    for all three years was in and around July (corresponding to 7 on the *x*-axis),
    and it has been increasing from 2000 with a more dramatic rise between 2000 and
    2006\. Having all three lines plotted together in one graph makes it a lot easier
    to see these kinds of relationships. It’s certainly clearer than just looking
    at a few long lists of numbers or even looking at three lines plotted on three
    separate graphs.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看图表，你可以得出两个有趣的结论：三个年份的最高温度都出现在大约七月（对应 *x* 轴上的 7），而且温度自2000年以来一直在上升，特别是在2000到2006年之间，温度的上升更为剧烈。将三条线绘制在同一图表中，使得观察这些关系更加容易。与仅仅查看一些长长的数字列表或分别查看三张图表相比，这显然更加清晰。
- en: '![image](images/f02-09.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-09.jpg)'
- en: '*Figure 2-9: A graph showing the average monthly temperature of New York City,
    with a legend to show the year each color corresponds to*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-9：显示纽约市月平均温度的图表，图例显示每种颜色对应的年份*'
- en: '***Customizing Graphs***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义图表***'
- en: We already learned about one way to customize a graph—by adding a legend. Now,
    we’ll learn about other ways to customize a graph and to make it clearer by adding
    labels to the *x*- and *y*-axes, adding a title to the graph, and controlling
    the range and steps of the axes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了自定义图表的一种方法——通过添加图例。现在，我们将学习通过添加标签到 *x* 轴和 *y* 轴、为图表添加标题，以及控制坐标轴的范围和步长，来进一步自定义图表并使其更清晰。
- en: '**Adding a Title and Labels**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加标题和标签**'
- en: 'We can add a title to our graph using the title() function and add labels for
    the *x*- and *y*-axes using the xlabel() and ylabel() functions. Let’s re-create
    the last plot and add all this additional information:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 title() 函数为图表添加标题，使用 xlabel() 和 ylabel() 函数为 *x* 轴和 *y* 轴添加标签。让我们重新绘制上一个图表，并添加所有这些额外的信息：
- en: '>>> from pylab import plot, show, title, xlabel, ylabel, legend'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from pylab import plot, show, title, xlabel, ylabel, legend'
- en: '>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)'
- en: '[<matplotlib.lines.Line2D object at 0x7f2549a9e210>, <matplotlib.lines.Line2D'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f2549a9e210>, <matplotlib.lines.Line2D'
- en: object at 0x7f2549a4be90>, <matplotlib.lines.Line2D object at 0x7f2549a82090>]
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: object at 0x7f2549a4be90>, <matplotlib.lines.Line2D object at 0x7f2549a82090>]
- en: '>>> title(''Average monthly temperature in NYC'')'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> title(''纽约市月平均温度'')'
- en: <matplotlib.text.Text object at 0x7f25499f7150>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <matplotlib.text.Text object at 0x7f25499f7150>
- en: '>>> xlabel(''Month'')'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> xlabel(''月份'')'
- en: <matplotlib.text.Text object at 0x7f2549d79210>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <matplotlib.text.Text object at 0x7f2549d79210>
- en: '>>> ylabel(''Temperature'')'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ylabel(''温度'')'
- en: <matplotlib.text.Text object at 0x7f2549b8b2d0>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <matplotlib.text.Text object at 0x7f2549b8b2d0>
- en: '>>> legend([2000, 2006, 2012])'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> legend([2000, 2006, 2012])'
- en: <matplotlib.legend.Legend object at 0x7f2549a82910>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <matplotlib.legend.Legend object at 0x7f2549a82910>
- en: All three functions—title(), xlabel(), and ylabel()—are called with the corresponding
    text that we want to appear on the graph entered as strings. Calling the show()
    function will display the graph with all this newly added information (see [Figure
    2-10](ch02.html#ch2fig10)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个函数—title()、xlabel()和ylabel()—都被调用，并输入了我们希望显示在图表上的相应文本。调用show()函数将显示带有所有新增信息的图表（见[图
    2-10](ch02.html#ch2fig10)）。
- en: '![image](images/f02-10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-10.jpg)'
- en: '*Figure 2-10: Axes labels and a title have been added to the graph.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：图表上已添加坐标轴标签和标题。*'
- en: With the three new pieces of information added, the graph is easier to understand.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 加入了这三项新信息后，图表更易于理解。
- en: '**Customizing the Axes**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自定义坐标轴**'
- en: So far, we’ve allowed the numbers on both axes to be automatically determined
    by Python based on the data supplied to the plot() function. This may be fine
    for most cases, but sometimes this automatic range isn’t the clearest way to present
    the data, as we saw in the graph where we plotted the average annual temperature
    of New York City (see [Figure 2-7](ch02.html#ch2fig7)). There, even small changes
    in the temperature seemed large because the automatically chosen *y*-axis range
    was very narrow. We can adjust the range of the axes using the axis() function.
    This function can be used both to retrieve the current range and to set a new
    range for the axes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们让Python根据传给plot()函数的数据自动确定两个坐标轴的数字范围。对于大多数情况，这可能是可以接受的，但有时这种自动范围并不是呈现数据的最清晰方式，就像我们在绘制纽约市年平均温度的图表时所看到的那样（见[图
    2-7](ch02.html#ch2fig7)）。在那里，即使温度变化很小，似乎也很大，因为自动选择的*y*-轴范围非常狭窄。我们可以使用axis()函数来调整坐标轴的范围。这个函数可以用来获取当前的范围，也可以设置坐标轴的新范围。
- en: Consider, once again, the average annual temperature of New York City during
    the years 2000 to 2012 and create a plot as we did earlier.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑2000到2012年间纽约市的年平均温度，并创建一个图表，就像我们之前做的那样。
- en: '>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0,
    56.7, 56.4, 57.3]'
- en: '>>> plot(nyc_temp, marker=''o'')'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(nyc_temp, marker=''o'')'
- en: '[<matplotlib.lines.Line2D object at 0x7f3ae5b767d0>]'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f3ae5b767d0>]'
- en: 'Now, import the axis() function and call it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导入axis()函数并调用它：
- en: '>>> from pylab import axis'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from pylab import axis'
- en: '>>> axis()'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> axis()'
- en: (0.0, 12.0, 53.0, 57.5)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: (0.0, 12.0, 53.0, 57.5)
- en: 'The function returned a tuple with four numbers corresponding to the range
    for the *x*-axis (0.0, 12.0) and the *y*-axis (53.0, 57.5). These are the same
    range values from the graph that we made earlier. Now, let’s change the *y*-axis
    to start from 0 instead of 53.0:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回了一个包含四个数字的元组，分别对应于*x*-轴（0.0, 12.0）和*y*-轴（53.0, 57.5）的范围。这些是我们之前制作的图表中的相同范围值。现在，让我们将*y*-轴的起始值改为0，而不是53.0：
- en: '>>> axis(ymin=0)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> axis(ymin=0)'
- en: (0.0, 12.0, 0, 57.5)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (0.0, 12.0, 0, 57.5)
- en: Calling the axis() function with the new starting value for the *y*-axis (specified
    by ymin=0) changes the range, and the returned tuple confirms it. If you display
    the graph by calling the show() function, the *y*-axis starts at 0, and the differences
    between the values of the consecutive years look less drastic (see [Figure 2-11](ch02.html#ch2fig11)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 调用axis()函数并设置新的*y*-轴起始值（通过ymin=0指定）后，坐标轴范围发生了变化，返回的元组也确认了这一点。如果通过调用show()函数显示图表，*y*-轴将从0开始，连续年份之间的差异看起来不那么剧烈（见[图
    2-11](ch02.html#ch2fig11)）。
- en: '![image](images/f02-11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-11.jpg)'
- en: '*Figure 2-11: A graph showing the average annual temperature of New York City
    during the years 2000–2012\. The* y-*axis has been customized to start from 0.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-11：展示了2000到2012年间纽约市年平均温度的图表。*y-*轴已被自定义，从0开始。*'
- en: Similarly, you can use xmin, xmax, and ymax to set the minimum and maximum values
    for the *x*-axis and the maximum value for the *y*-axis, respectively. If you’re
    changing all four values, you may find it easier to call the axis() function with
    all four range values entered as a list, such as axis([0, 10, 0, 20]). This would
    set the range of the *x*-axis to (0, 10) and that of the *y*-axis to (0, 20).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用xmin、xmax和ymax分别设置*X*-轴的最小值和最大值，以及*Y*-轴的最大值。如果你要改变这四个值，可能会发现通过axis()函数一次性输入这四个范围值会更方便，例如`axis([0,
    10, 0, 20])`。这会将*X*-轴的范围设置为(0, 10)，*Y*-轴的范围设置为(0, 20)。
- en: '**Plotting Using pyplot**'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用pyplot绘图**'
- en: The pylab module is useful for creating plots in an interactive shell, such
    as the IDLE shell, as we’ve been doing so far. However, when using matplotlib
    outside of the IDLE shell—for example, as part of a larger program—the pyplot
    module is more efficient. Don’t worry—all the methods that you learned about when
    using pylab will work the same way with pyplot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: pylab模块适用于在交互式Shell（例如IDLE Shell）中创建图形，就像我们到目前为止所做的那样。然而，当在IDLE Shell之外使用matplotlib时——例如作为大型程序的一部分——pyplot模块更为高效。别担心，所有你在使用pylab时学到的方法，在使用pyplot时也能正常工作。
- en: 'The following program recreates the first plot in this chapter using the pyplot
    module:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用pyplot模块重现了本章中的第一个图形：
- en: ''''''''
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Simple plot using pyplot
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pyplot绘制简单图形
- en: ''''''''
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: ➊ import matplotlib.pyplot
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import matplotlib.pyplot
- en: '➋ def create_graph():'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def create_graph():'
- en: x_numbers = [1, 2, 3]
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: x_numbers = [1, 2, 3]
- en: y_numbers = [2, 4, 6]
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: y_numbers = [2, 4, 6]
- en: matplotlib.pyplot.plot(x_numbers, y_numbers)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib.pyplot.plot(x_numbers, y_numbers)
- en: matplotlib.pyplot.show()
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib.pyplot.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: create_graph()
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: create_graph()
- en: First, we import the pyplot module using the statement import matplotlib .pyplot
    ➊. This means that we’re importing the entire pyplot module from the matplotlib
    package. To refer to any function or class definition defined in this module,
    you’ll have to use the syntax matplotlib.pyplot.item, where item is the function
    or class you want to use.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过语句`import matplotlib.pyplot`导入了pyplot模块 ➊。这意味着我们导入了matplotlib包中的整个pyplot模块。要引用该模块中定义的任何函数或类，你需要使用语法`matplotlib.pyplot.item`，其中item是你要使用的函数或类。
- en: This is different from importing a single function or class at a time, which
    is what we’ve been doing so far. For example, in the first chapter we imported
    the Fraction class as from fractions import Fraction. Importing an entire module
    is useful when you’re going to use a number of functions from that module. Instead
    of importing them individually, you can just import the whole module at once and
    refer to different functions when you need them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前逐个导入函数或类的方式不同。例如，在第一章中，我们通过`from fractions import Fraction`导入了Fraction类。导入整个模块在你需要使用模块中的多个函数时特别有用。你可以一次性导入整个模块，然后根据需要引用不同的函数，而不必逐个导入。
- en: In the create_graph() function at ➋, we create the two lists of numbers that
    we want to plot on the graph and then pass the two lists to the plot() function,
    the same way we did before with pylab. This time, however, we call the function
    as matplotlib.pyplot.plot(), which means that we’re calling the plot() function
    defined in the pyplot module of the matplotlib package. Then, we call the show()
    function to display the graph. The only difference between the way you plot the
    numbers here compared to what we did earlier is the mechanism of calling the functions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋的create_graph()函数中，我们创建了两个列表，这些数字将绘制在图形上，然后将这两个列表传递给plot()函数，就像我们之前使用pylab时做的一样。然而，这次我们调用的是matplotlib.pyplot.plot()，这意味着我们正在调用matplotlib包中的pyplot模块定义的plot()函数。接着，我们调用show()函数来显示图形。你绘制这些数字的方式与我们之前的做法不同，仅仅是调用函数的机制不同。
- en: 'To save us some typing, we can import the pyplot module by entering import
    matplotlib.pyplot as plt. Then, we can refer to pyplot with the label plt in our
    programs, instead of having to always type matplotlib.pyplot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少我们输入的内容，可以通过输入`import matplotlib.pyplot as plt`来导入pyplot模块。然后，我们可以在程序中使用标签plt来引用pyplot，而不需要每次都输入matplotlib.pyplot：
- en: ''''''''
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Simple plot using pyplot
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pyplot绘制简单图形
- en: ''''''''
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import matplotlib.pyplot as plt
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: 'def create_graph():'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_graph():'
- en: x_numbers = [1, 2, 3]
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: x_numbers = [1, 2, 3]
- en: y_numbers = [2, 4, 6]
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: y_numbers = [2, 4, 6]
- en: plt.plot(x_numbers, y_numbers)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: plt.plot(x_numbers, y_numbers)
- en: plt.show()
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: create_graph()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: create_graph()
- en: Now, we can call the functions by prefixing them with the shortened plt instead
    of matplotlib.pyplot.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在函数名前加上简写的plt来调用函数，而不必每次都使用matplotlib.pyplot。
- en: Going ahead, for the rest of this chapter and this book, we’ll use pylab in
    the interactive shell and pyplot otherwise.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在本章及本书的其他部分，我们将使用pylab在交互式命令行中，而在其他地方则使用pyplot。
- en: '***Saving the Plots***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保存图表***'
- en: If you need to save your graphs, you can do so using the savefig() function.
    This function saves the graph as an image file, which you can use in reports or
    presentations. You can choose among several image formats, including PNG, PDF,
    and SVG.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要保存图表，可以使用savefig()函数。这个函数将图表保存为图像文件，你可以在报告或演示文稿中使用。你可以选择多种图像格式，包括PNG、PDF和SVG。
- en: 'Here’s an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '>>> from pylab import plot, savefig'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from pylab import plot, savefig'
- en: '>>> x = [1, 2, 3]'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3]'
- en: '>>> y = [2, 4, 6]'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = [2, 4, 6]'
- en: '>>> plot(x, y)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(x, y)'
- en: '>>> savefig(''mygraph.png'')'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> savefig(''mygraph.png'')'
- en: 'This program will save the graph to an image file, *mygraph.png*, in your current
    directory. On Microsoft Windows, this is usually *C:\Python33* (where you installed
    Python). On Linux, the current directory is usually your home directory *(/home/<username>*),
    where *<username>* is the user you’re logged in as. On a Mac, IDLE saves files
    to *~/Documents* by default. If you wanted to save it in a different directory,
    specify the complete pathname. For example, to save the image under *C:\* on Windows
    as *mygraph.png*, you’d call the savefig() function as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序会将图表保存为图像文件*mygraph.png*，保存在你当前的目录中。在Microsoft Windows系统上，通常这个目录是*C:\Python33*（你安装Python的地方）。在Linux上，当前目录通常是你的主目录*（/home/<用户名>）*，其中*<用户名>*是你登录的用户名。在Mac上，IDLE默认将文件保存到*~/Documents*。如果你想将文件保存到其他目录，只需要指定完整的路径名。例如，如果你想在Windows的*C:\*下保存图像为*mygraph.png*，可以这样调用savefig()函数：
- en: '>>> savefig(''C:\mygraph.png'')'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> savefig(''C:\mygraph.png'')'
- en: If you open the image in an image-viewing program, you’ll see the same graph
    you’d see by calling the show() function. (You’ll notice that the image file contains
    only the graph—not the entire window that pops up with the show() function). To
    specify a different image format, simply name the file with the appropriate extension.
    For example, mygraph.svg will create an SVG image file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用图像查看程序打开图像，你会看到一个和调用show()函数时一样的图表。（你会注意到图像文件只包含图表，而不是调用show()时弹出的整个窗口）。如果要指定不同的图像格式，只需为文件命名时添加相应的扩展名。例如，mygraph.svg将创建一个SVG格式的图像文件。
- en: Another way to save a figure is to use the Save button in the window that pops
    up when you call show().
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种保存图形的方法是使用弹出窗口中显示的保存按钮，该窗口在调用show()时弹出。
- en: '**Plotting with Formulas**'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用公式绘图**'
- en: Until now, we’ve been plotting points on our graphs based on observed scientific
    measurements. In those graphs, we already had all our values for *x* and *y* laid
    out. For example, recorded temperatures and dates were already available to us
    at the time we wanted to create the New York City graph, showing how the temperature
    varied over months or years. In this section, we’re going to create graphs from
    mathematical formulas.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在根据观测到的科学测量数据绘制图表。在这些图表中，我们已经列出了所有的*x*和*y*值。例如，在我们想要创建纽约市的气温变化图时，记录的温度和日期数据已经为我们提供。接下来，我们将根据数学公式来创建图表。
- en: '***Newton’s Law of Universal Gravitation***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***牛顿万有引力定律***'
- en: According to Newton’s law of universal gravitation, a body of mass *m*[1] attracts
    another body of mass *m*[2] with an amount of force *F* according to the formula
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 根据牛顿万有引力定律，一个质量为*m*[1]的物体会根据公式吸引另一个质量为*m*[2]的物体，吸引力大小为*F*。
- en: '![image](images/e0046-01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0046-01.jpg)'
- en: where *r* is the distance between the two bodies and *G* is the gravitational
    constant. We want to see what happens to the force as the distance between the
    two bodies increases.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*r*是两个物体之间的距离，*G*是万有引力常数。我们想观察当两个物体之间的距离增大时，吸引力会发生什么变化。
- en: 'Let’s take the masses of two bodies: the mass of the first body (*m*[1]) is
    0.5 kg, and the mass of the second body (*m*[2]) is 1.5 kg. The value of the gravitational
    constant is 6.674 × 10^(–11) N m² kg^(–2). Now we’re ready to calculate the gravitational
    force between these two bodies at 19 different distances: 100 m, 150 m, 200 m,
    250 m, 300 m, and so on up through 1000 m. The following program performs these
    calculations and also draws the graph:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between gravitational force and
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: distance between two bodies
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: import matplotlib.pyplot as plt
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '# Draw the graph'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw_graph(x, y):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: plt.plot(x, y, marker='o')
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: plt.xlabel('Distance in meters')
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: plt.ylabel('Gravitational force in newtons')
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: plt.title('Gravitational force and distance')
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'def generate_F_r():'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '# Generate values for r'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: ➊     r = range(100, 1001, 50)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '# Empty list to store the calculated values of F'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: F = []
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '# Constant, G'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: G = 6.674*(10**-11)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '# Two masses'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: m1 = 0.5
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: m2 = 1.5
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '# Calculate force and add it to the list, F'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '➋     for dist in r:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: force = G*(m1*m2)/(dist**2)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: F.append(force)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '# Call the draw_graph function'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ➌     draw_graph(r, F)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__==''__main__'':'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: generate_F_r()
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The generate_F_r() function does most of the work in the program above. At ➊,
    we use the range() function to create a list labeled r with different values for
    distance, using a step value of 50\. The final value is specified as 1001 because
    we want 1000 to be included as well. We then create an empty list (F), where we’ll
    store the corresponding gravitational force at each of these distances. Next,
    we create labels referring to the gravitational constant (G) and the two masses
    (m1 and m2). Using a for loop ➋, we then calculate the force at each of the values
    in the list of distances (r). We use a label (force) to refer to the force calculated
    and to append it to the list (F). Finally, we call the function draw_graph() at
    ➌ with the list of distances and the list of the calculated forces. The *x*-axis
    of the graph displays the force, and the *y*-axis displays the distance. The graph
    is shown in [Figure 2-12](ch02.html#ch2fig12).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: As the distance (r) increases, the gravitational force decreases. With this
    kind of relationship, we say that the gravitational force is *inversely proportional*
    to the distance between the two bodies. Also, note that when the value of one
    of the two variables changes, the other variable won’t necessarily change by the
    same proportion. We refer to this as a *nonlinear relationship*. As a result,
    we end up with a curved line on the graph instead of a straight one.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f02-12.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: Visualization of the relationship between the gravitational force
    and the squared distance*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '***Projectile Motion***'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let’s graph something you’ll be familiar with from everyday life. If you
    throw a ball across a field, it follows a trajectory like the one shown in [Figure
    2-13](ch02.html#ch2fig13).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f02-13.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: Motion of a ball that’s thrown at point* A*—at an angle (*θ*)
    with a velocity (*U*)—and that hits the ground at point* B'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-13：投掷在点* A*的球的运动——以一个角度（*θ*）和初速度（*U*）投掷，并在点* B*着陆。'
- en: In the figure, the ball is thrown from point *A* and lands at point *B*. This
    type of motion is referred to as *projectile* motion. Our aim here is to use the
    equations of projectile motion to graph the trajectory of a body, showing the
    position of the ball starting from the point it’s thrown until it hits the ground
    again.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，球从点* A*投掷，并在点* B*着陆。这种类型的运动被称为*抛体*运动。我们的目标是使用抛体运动的方程式绘制物体的轨迹，显示从投掷点到球再次着地的过程中球的位置。
- en: 'When you throw the ball, it has an initial velocity and the direction of that
    velocity creates a certain angle with the ground. Let’s call the initial velocity
    *u* and the angle that it makes with the ground *θ* (theta), as shown in [Figure
    2-13](ch02.html#ch2fig13). The ball has two velocity components: one along the
    *x* direction, calculated by *u[x]* = *u* cos*θ*, and the other along the *y*
    direction, where *u[y]* = *u* sin*θ*.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你投掷球时，它有一个初速度，并且该速度的方向与地面形成一定角度。我们称初速度为*u*，与地面形成的角度为*θ*（theta），如[图2-13](ch02.html#ch2fig13)所示。球有两个速度分量：一个沿*x*方向，计算公式为*u[x]*
    = *u* cos*θ*，另一个沿*y*方向，计算公式为*u[y]* = *u* sin*θ*。
- en: 'As the ball moves, its velocity changes, and we will represent that changed
    velocity using *v*: the horizontal component is *v[x]* and the vertical component
    is *v[y]*. For simplicity, assume the horizontal component (*v[x]*) doesn’t change
    during the motion of the body, whereas the vertical component (*v[y]*) decreases
    because of the force of gravity according to the equation *v[y]* = *u[y] – gt*.
    In this equation, *g* is the gravitational acceleration and *t* is the time at
    which the velocity is measured. Because *u[y]* = *u* sin*θ*, we can substitute
    to get'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当球运动时，它的速度发生变化，我们用*v*来表示改变后的速度：水平分量是*v[x]*，垂直分量是*v[y]*。为了简化，假设水平分量（*v[x]*）在运动过程中保持不变，而垂直分量（*v[y]*）由于重力作用而减小，根据公式*v[y]*
    = *u[y] – gt*。在这个公式中，*g*是重力加速度，*t*是测量速度时的时间。由于*u[y]* = *u* sin*θ*，我们可以代入计算得到：
- en: '*v[y]* = *u* sin*θ* – *gt*.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*v[y]* = *u* sin*θ* – *gt*。'
- en: Because the horizontal component of the velocity remains constant, the horizontal
    distance traveled (*S[x]*) is given by *S[x]* = *u*(cos*θ*)*t*. The vertical component
    of the velocity changes, though, and the vertical distance traveled is given by
    the formula
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于速度的水平分量保持不变，水平位移（*S[x]*）由公式*S[x]* = *u*(cos*θ*)*t*给出。然而，垂直分量的速度会发生变化，垂直位移由公式给出：
- en: '![image](images/e0049-01.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0049-01.jpg)'
- en: In other words, *S[x]* and *S[y]* give us the *x*- and *y*-coordinates of the
    ball at any given point in time during its flight. We’ll use these equations when
    we write a program to draw the trajectory. As we use these equations, time (*t*)
    will be expressed in seconds, the velocity will be expressed in m/s, the angle
    of projection (*θ*) will be expressed in degrees, and the gravitational acceleration
    (*g*) will be expressed in m/s².
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*S[x]*和*S[y]*给出了球在飞行过程中任何时刻的*x*和*y*坐标。当我们编写程序绘制轨迹时，我们将使用这些方程。使用这些方程时，时间（*t*）以秒为单位，速度以米每秒（m/s）为单位，投射角度（*θ*）以度为单位，重力加速度（*g*）以米每秒平方（m/s²）为单位。
- en: Before we write our program, however, we’ll need to find out how long the ball
    will be in flight before it hits the ground so that we know when our program should
    stop plotting the trajectory of the ball. To do so, we’ll first find how long
    the ball takes to reach its highest point. The ball reaches its highest point
    when the vertical component of the velocity (*v[y]*) is 0, which is when *v[y]*
    = *u* sin *θ* – *gt* = 0\. So we’re looking for the value *t* using the formula
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们编写程序之前，我们需要先找出球在落地之前的飞行时间，这样我们才能知道程序应该在何时停止绘制球的轨迹。为此，我们首先找出球达到最高点所需的时间。球达到最高点时，垂直分量的速度（*v[y]*）为0，即*v[y]*
    = *u* sin *θ* – *gt* = 0。我们需要使用公式找出时间*t*的值：
- en: '![image](images/e0049-02.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0049-02.jpg)'
- en: We’ll call this time t_peak. After it reaches its highest point, the ball will
    hit the ground after being airborne for another t_peak seconds, so the total time
    of flight (t_flight) of the ball is
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个时间为t_peak。达到最高点后，球将继续飞行并在另一个t_peak秒后落地，因此球的总飞行时间（t_flight）为：
- en: '![image](images/e0050-01.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0050-01.jpg)'
- en: 'Let’s take a ball that’s thrown with an initial velocity (*u*) of 5 m/s at
    an angle (*θ*) of 45 degrees. To calculate the total time of flight, we substitute
    *u* = 5, *θ* = 45, and *g* = 9.8 into the equation we saw above:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个初速度(*u*)为5米/秒，投掷角度(*θ*)为45度的球。为了计算总飞行时间，我们将*u* = 5，*θ* = 45，*g* = 9.8代入我们之前看到的公式：
- en: '![image](images/e0050-02.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0050-02.jpg)'
- en: In this case, the time of flight for the ball turns out to be 0.72154 seconds
    (rounded to five decimal places). The ball will be in air for this period of time,
    so to draw the trajectory, we’ll calculate its *x*- and *y*-coordinates at regular
    intervals during this time period. How often should we calculate the coordinates?
    Ideally, as frequently as possible. In this chapter, we’ll calculate the coordinates
    every 0.001 seconds.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，球的飞行时间为0.72154秒（四舍五入到小数点后五位）。球将在空中停留这个时间段，因此为了绘制轨迹，我们将在这段时间内定期计算其*x*和*y*坐标。我们应该多久计算一次坐标？理想情况下，尽可能频繁。在本章中，我们将每0.001秒计算一次坐标。
- en: '**Generating Equally Spaced Floating Point Numbers**'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成等间距浮点数**'
- en: 'We’ve used the range() function to generate equally spaced integers— that is,
    if we wanted a list of integers between 1 and 10 with each integer separated by
    1, we would use range(1, 10). If we wanted a different step value, we could specify
    that to the range function as the third argument. Unfortunately, there’s no such
    built-in function for floating point numbers. So, for example, there’s no function
    that would allow us to create a list of the numbers from 0 to 0.72 with two consecutive
    numbers separated by 0.001\. We can use a while loop as follows to create our
    own function for this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了range()函数来生成等间距的整数——也就是说，如果我们想要生成1到10之间的整数，每个整数之间间隔为1，我们会使用range(1, 10)。如果我们想要不同的步长，可以在range函数中指定第三个参数。不幸的是，Python没有内建的函数来生成等间距的浮点数。例如，Python没有一个函数可以让我们生成从0到0.72的数字列表，并且每两个数字之间相差0.001。为了实现这一点，我们可以使用while循环来创建自己的函数，如下所示：
- en: ''''''''
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Generate equally spaced floating point
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 生成等间距浮点数
- en: numbers between two given values
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 两个给定值之间的数字
- en: ''''''''
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def frange(start, final, increment):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'def frange(start, final, increment):'
- en: numbers = []
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: '➊     while start < final:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     while start < final:'
- en: ➋         numbers.append(start)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ➋         numbers.append(start)
- en: start = start + increment
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: start = start + increment
- en: return numbers
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: 'We’ve defined a function frange() (“floating point” range) that receives three
    parameters: start and final refer to the starting and the final points of the
    range of numbers, and increment refers to the difference between two consecutive
    numbers. We initialize a while loop at ➊, which continues execution as long as
    the number referred to by start is less than the value for final. We store the
    number pointed to by start in the list numbers ➋ and then add the value we entered
    as an increment during every iteration of the loop. Finally, we return the list
    numbers.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数frange()（“浮点数”范围），该函数接受三个参数：start和final分别表示数值范围的起始和结束点，increment表示两个连续数字之间的差值。我们在➊处初始化一个while循环，只要start指向的数字小于final的值，循环就会继续执行。在每次迭代中，我们将start指向的数字存储到numbers列表中➋，然后将我们输入的增量值加到start上。最后，我们返回numbers列表。
- en: We’ll use this function to generate equally spaced time instants in the trajectory-drawing
    program described next.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的轨迹绘制程序中使用此函数来生成等间隔的时间点。
- en: '**Drawing the Trajectory**'
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制轨迹**'
- en: 'The following program draws the trajectory of a ball thrown with a certain
    velocity and angle—both of which are supplied as input to the program:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序绘制了一颗以一定速度和角度投掷的球的轨迹——这两个参数作为输入传递给程序：
- en: ''''''''
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Draw the trajectory of a body in projectile motion
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制物体的抛射运动轨迹
- en: ''''''''
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from matplotlib import pyplot as plt
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: from matplotlib import pyplot as plt
- en: import math
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: 'def draw_graph(x, y):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_graph(x, y):'
- en: plt.plot(x, y)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: plt.plot(x, y)
- en: plt.xlabel('x-coordinate')
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: plt.xlabel('x坐标')
- en: plt.ylabel('y-coordinate')
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: plt.ylabel('y坐标')
- en: plt.title('Projectile motion of a ball')
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: plt.title('球的抛射运动')
- en: 'def frange(start, final, interval):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'def frange(start, final, interval):'
- en: numbers = []
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: 'while start < final:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'while start < final:'
- en: numbers.append(start)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(start)
- en: start = start + interval
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: start = start + interval
- en: return numbers
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: 'def draw_trajectory(u, theta):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_trajectory(u, theta):'
- en: ➊     theta = math.radians(theta)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     theta = math.radians(theta)
- en: g = 9.8
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: g = 9.8
- en: '# Time of flight'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '# 飞行时间'
- en: ➋     t_flight = 2*u*math.sin(theta)/g
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     t_flight = 2*u*math.sin(theta)/g
- en: '# Find time intervals'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找时间间隔'
- en: intervals = frange(0, t_flight, 0.001)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: intervals = frange(0, t_flight, 0.001)
- en: '# List of x and y coordinates'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: x = []
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: y = []
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '➌     for t in intervals:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: x.append(u*math.cos(theta)*t)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: y.append(u*math.sin(theta)*t - 0.5*g*t*t)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: draw_graph(x, y)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '➍     try:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: u = float(input('Enter the initial velocity (m/s): '))
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: theta = float(input('Enter the angle of projection (degrees): '))
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: print('You entered an invalid input')
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: draw_trajectory(u, theta)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we use the functions radians(), cos(), and sin() defined in
    the standard library’s math module, so we import that module at the beginning.
    The draw_trajectory() function accepts two arguments, u and theta, corresponding
    to the velocity and the angle at which the ball is thrown. The math module’s sine
    and the cosine functions expect the angle to be supplied in radians, so at ➊,
    we convert the angle (theta) from degrees to radians using the math.radians()
    function. Next, we create a label (g) to refer to the value of acceleration due
    to gravity, 9.8 m/s². At ➋, we calculate the time of flight and then call the
    frange() function with the values for start, final, and increment set to 0, t_flight,
    and 0.001, respectively. We then calculate the *x*- and *y*-coordinates for the
    trajectory at each of the time instants and store them in two separate lists,
    x and y ➌. To calculate these coordinates, we use the formulas for the distances
    *S[x]* and *S[y]* that we discussed earlier.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the draw_graph() function with the *x*- and *y*-coordinates
    to draw the trajectory. Note that the draw_graph() function doesn’t call the show()
    function (we’ll see why in the next program). We use a try...except block ➍ to
    report an error message in case the user enters an invalid input. Valid input
    for this program is any integer or floating point number. When you run the program,
    it asks for these values as input and then draws the trajectory (see [Figure 2-14](ch02.html#ch2fig14)):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Enter the initial velocity (m/s): 25
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Enter the angle of projection (degrees): 60
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f02-14.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: The trajectory of a ball when thrown with a velocity of 25 m/s
    at an angle of 60 degrees*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparing the Trajectory at Different Initial Velocities**'
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The previous program allows you to perform interesting experiments. For example,
    what will the trajectory look like for three balls thrown at different velocities
    but with the same initial angle? To graph three trajectories at once, we can replace
    the main code block from our previous program with the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '# List of three different initial velocities'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: ➊     u_list = [20, 40, 60]
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: theta = 45
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'for u in u_list:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: draw_trajectory(u, theta)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '# Add a legend and show the graph'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ➋     plt.legend(['20', '40', '60'])
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Here, instead of asking the program’s user to enter the velocity and the angle
    of projection, we create a list (u_list) with the velocities 20, 40, and 60 at
    ➊ and set the angle of projection as 45 degrees (using the label theta). We then
    call the draw_trajectory() function with each of the three values in u_list using
    the same value for theta, which calculates the list of *x*- and *y*-coordinates
    and calls the draw_graph() function. When we call the show() function, all three
    plots are displayed on the same graph. Because we now have a graph with multiple
    plots, we add a legend to the graph at ➋ before calling show() to display the
    velocity for each line. When you run the above program, you’ll see the graph shown
    in [Figure 2-15](ch02.html#ch2fig15).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f02-15.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-15: The trajectory of a ball thrown at a 60-degree angle, with a
    velocity of 20, 40, and 60 m/s*'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '**What You Learned**'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of creating graphs with matplotlib.
    You saw how to plot a single set of values, how to create multiple plots on the
    same graph, and how to label various parts of a graph to make it more informative.
    You used graphs to analyze the temperature variation of a city, study Newton’s
    law of universal gravitation, and study the projectile motion of a body. In the
    next chapter, you’ll use Python to start exploring statistics, and you’ll see
    how drawing a graph can help make the relationships among sets of numbers easier
    to understand.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are a few challenges that build on what you’ve learned in this chapter.
    You can find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '***#1: How Does the Temperature Vary During the Day?***'
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you enter a search term like “New York weather” in Google’s search engine,
    you’ll see, among other things, a graph showing the temperature at different times
    of the present day. Your task here is to re-create such a graph.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Using a city of your choice, find the temperature at different points of the
    day. Use the data to create two lists in your program and to create a graph with
    the time of day on the *x*-axis and the corresponding temperature on the *y*-axis.
    The graph should tell you how the temperature varies with the time of day. Try
    a different city and see how the two cities compare by plotting both lines on
    the same graph.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The time of day may be indicated by strings such as '10:11 AM' or '09:21 PM'.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '***#2: Exploring a Quadratic Function Visually***'
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html#ch01), you learned how to find the roots of a quadratic
    equation, such as *x*² + 2*x* + 1 = 0\. We can turn this equation into a function
    by writing it as *y* = *x*² + 2*x* + 1\. For any value of *x*, the quadratic function
    produces *some* value for *y*. For example, when *x* = 1, *y* = 4\. Here’s a program
    that calculates the value of *y* for six different values of *x*:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic function calculator
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '# Assume values of x'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: ➊ x_values = [-1, 1, 2, 3, 4, 5]
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '➋ for x in x_values:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '# Calculate the value of the quadratic function'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: y = x**2 + 2*x + 1
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: print('x={0} y={1}'.format(x, y))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊, we create a list with six different values for x. The for loop starting
    at ➋ calculates the value of the function above for each of these values and uses
    the label y to refer to the list of results. Next, we print the value of x and
    the corresponding value of y. When you run the program, you should see the following
    output:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: x=-1 y=0
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: x=1 y=4
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: x=2 y=9
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: x=3 y=16
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: x=4 y=25
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: x=5 y=36
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the first line of the output is a root of the quadratic equation
    because it’s a value for x that makes the function equal to 0.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Your programming challenge is to enhance this program to create a graph of the
    function. Try using at least 10 values for x instead of the 6 above. Calculate
    the corresponding y values using the function and then create a graph using these
    two sets of values.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the graph, spend some time analyzing how the value of *y*
    varies with respect to *x*. Is the variation linear or nonlinear?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '***#3: Enhanced Projectile Trajectory Comparison Program***'
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your challenge here is to enhance the trajectory comparison program in a few
    ways. First, your program should print the time of flight, maximum horizontal
    distance, and maximum vertical distance traveled for each of the velocity and
    angle of projection combinations.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'The other enhancement is to make the program work with any number of initial
    velocity and angle of projection values, supplied by the user. For example, here’s
    how the program should ask the user for the inputs:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: How many trajectories? 3
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Enter the initial velocity for trajectory 1 (m/s): 45
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Enter the angle of projection for trajectory 1 (degrees): 45
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Enter the initial velocity for trajectory 2 (m/s): 60
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Enter the angle of projection for trajectory 2 (degrees): 45
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Enter the initial velocity for trajectory(m/s) 3: 45
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Enter the angle of projection for trajectory(degrees) 3: 90
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Your program should also ensure that erroneous input is properly handled using
    a try...except block, just as in the original program.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '***#4: Visualizing Your Expenses***'
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I always find myself asking at the end of the month, “Where did all that money
    go?” I’m sure this isn’t a problem I alone face.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: For this challenge, you’ll write a program that creates a bar chart for easy
    comparison of weekly expenditures. The program should first ask for the number
    of categories for the expenditures and the weekly total expenditure in each category,
    and then it should create the bar chart showing these expenditures.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run of how the program should work:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Enter the number of categories: 4
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Enter category: Food
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Expenditure: 70
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Enter category: Transportation
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Expenditure: 35
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Enter category: Entertainment
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Expenditure: 30
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Enter category: Phone/Internet
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Expenditure: 30
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-16](ch02.html#ch2fig16) shows the bar chart that will be created
    to compare the expenditures. If you save the bar chart for every week, at the
    end of the month, you’ll be able to see how the expenditures varied between the
    weeks for different categories.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-16](ch02.html#ch2fig16)展示了用于比较支出的条形图。如果你为每周保存条形图，那么到月底时，你将能够看到不同类别之间各周支出的变化。'
- en: '![image](images/f02-16.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-16.jpg)'
- en: '*Figure 2-16: A bar chart showing the expenditures per category during the
    week*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-16：展示每周按类别支出的条形图*'
- en: We haven’t discussed creating a bar chart using matplotlib, so let’s try an
    example.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论如何使用matplotlib创建条形图，所以让我们尝试一个示例。
- en: A bar chart can be created using matplotlib’s barh() function, which is also
    defined in the pyplot module. [Figure 2-17](ch02.html#ch2fig17) shows a bar chart
    that illustrates the number of steps I walked during the past week. The days of
    the week—Sunday, Monday, Tuesday, and so forth—are referred to as the *labels*.
    Each horizontal bar starts from the *y*-axis, and we have to specify the *y*-coordinate
    of the *center* of this position for each of the bars. The length of each bar
    corresponds to the number of steps specified.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用matplotlib的barh()函数来创建条形图，该函数也在pyplot模块中定义。[图 2-17](ch02.html#ch2fig17)展示了一个条形图，说明了我在过去一周内步行的步数。星期天、星期一、星期二等被称为*标签*。每个横向条形从*y*轴开始，我们需要为每个条形指定该位置的*y*坐标，作为*中心*。每个条形的长度对应于指定的步数。
- en: '![image](images/f02-17.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-17.jpg)'
- en: '*Figure 2-17: A bar chart showing the number of steps walked during a week*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-17：展示一周内步行步数的条形图*'
- en: 'The following program creates the bar chart:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序创建了条形图：
- en: ''''''''
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Example of drawing a horizontal bar chart
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制水平条形图的示例
- en: ''''''''
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import matplotlib.pyplot as plt
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: 'def create_bar_chart(data, labels):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_bar_chart(data, labels):'
- en: '# Number of bars'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '# 条形数量'
- en: num_bars = len(data)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: num_bars = len(data)
- en: '# This list is the point on the y-axis where each'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这个列表是每个条形对应的*y*轴位置'
- en: '# Bar is centered. Here it will be [1, 2, 3...]'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '# 条形居中。这里它将是[1, 2, 3...]'
- en: ➊     positions = range(1, num_bars+1)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     positions = range(1, num_bars+1)
- en: ➋     plt.barh(positions, data, align='center')
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     plt.barh(positions, data, align='center')
- en: '# Set the label of each bar'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置每个条形的标签'
- en: plt.yticks(positions, labels)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: plt.yticks(positions, labels)
- en: plt.xlabel('Steps')
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: plt.xlabel('步数')
- en: plt.ylabel('Day')
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: plt.ylabel('天')
- en: plt.title('Number of steps walked')
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: plt.title('步数')
- en: '# Turns on the grid which may assist in visual estimation'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用网格，这可能有助于视觉估算'
- en: plt.grid(
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: plt.grid(
- en: plt.show()
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: '# Number of steps I walked during the past week'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '# 我在过去一周步行的步数'
- en: steps = [6534, 7000, 8900, 10786, 3467, 11045, 5095]
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: steps = [6534, 7000, 8900, 10786, 3467, 11045, 5095]
- en: '# Corresponding days'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对应的天数'
- en: labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: labels = ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
- en: create_bar_chart(steps, labels)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: create_bar_chart(steps, labels)
- en: The create_bar_chart() function accepts two parameters—data, which is a list
    of numbers we want to represent using the bars and labels, and the corresponding
    labels list. The center of each bar has to be specified, and I’ve arbitrarily
    chosen the centers as 1, 2, 3, 4, and so on using the help of the range() function
    at ➊.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: create_bar_chart()函数接受两个参数——data，它是一个包含我们想要通过条形表示的数字的列表，labels，它是对应的标签列表。必须指定每个条形的中心，我已经通过在➊处使用range()函数任意选择了1、2、3、4等作为中心。
- en: We then call the barh() function, passing positions and data as the first two
    arguments and then the keyword argument, align='center', at ➋. The keyword argument
    specifies that the bars are centered at the positions on the *y*-axis specified
    by the list. We then set the labels for each bar, the axis labels, and the title
    using the yticks() function. We also call the grid() function to turn on the grid,
    which may be useful for a visual estimation of the number of steps. Finally, we
    call the show() function.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用barh()函数，将positions和data作为前两个参数传递，再在➋处传递关键字参数align='center'。关键字参数指定条形在*y*轴上居中显示，位置由列表指定。接着，我们使用yticks()函数设置每个条形的标签、轴标签和标题。我们还调用grid()函数启用网格，这可能对步数的视觉估算有帮助。最后，我们调用show()函数。
- en: '***#5: Exploring the Relationship Between the Fibonacci Sequence and the Golden
    Ratio***'
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5：探索斐波那契数列与黄金比例之间的关系***'
- en: The Fibonacci sequence (1, 1, 2, 3, 5, ...) is the series of numbers where the
    *i*th number in the series is the sum of the two previous numbers—that is, the
    numbers in the positions (*i* – 2) and (*i* – 1). The successive numbers in this
    series display an interesting relationship. As you increase the number of terms
    in the series, the ratios of consecutive pairs of numbers are nearly equal to
    each other. This value approaches a special number referred to as the *golden
    ratio*. Numerically, the golden ratio is the number 1.618033988 ..., and it’s
    been the subject of extensive study in music, architecture, and nature. For this
    challenge, write a program that will plot on a graph the ratio between consecutive
    Fibonacci numbers for, say, 100 numbers, which will demonstrate that the values
    approach the golden ratio.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find the following function, which returns a list of the first *n*
    Fibonacci numbers, useful in implementing your solution:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'def fibo(n):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'if n == 1:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: return [1]
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'if n == 2:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: return [1, 1]
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '# n > 2'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: a = 1
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: b = 1
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '# First two members of the series'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: series = [a, b]
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: c = a + b
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: series.append(c)
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: a = b
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: b = c
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: return series
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The output of your solution should be a graph, as shown in [Figure 2-18](ch02.html#ch2fig18).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f02-18.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-18: The ratio between the consecutive Fibonacci numbers approaches
    the golden ratio.*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
