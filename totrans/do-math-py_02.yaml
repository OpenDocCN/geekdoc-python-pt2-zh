- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**Visualizing Data with Graphs**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过图形可视化数据**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: 'In this chapter, you’ll learn a powerful way to present numerical data: by
    drawing graphs with Python. We’ll start by discussing the number line and the
    Cartesian plane. Next, we’ll learn about the powerful plotting library *matplotlib*
    and how we can use it to create graphs. We’ll then explore how to make graphs
    that present data clearly and intuitively. Finally, we’ll use graphs to explore
    Newton’s law of universal gravitation and projectile motion. Let’s get started!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍一种强大的数值数据呈现方式：通过 Python 绘制图形。我们将从数轴和笛卡尔平面开始讨论。接下来，我们将学习强大的绘图库 *matplotlib*
    以及如何使用它创建图形。然后，我们将探索如何制作能够清晰、直观地呈现数据的图形。最后，我们将使用图形探索牛顿的万有引力定律和抛体运动。让我们开始吧！
- en: '**Understanding the Cartesian Coordinate Plane**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解笛卡尔坐标平面**'
- en: 'Consider a *number line*, like the one shown in [Figure 2-1](ch02.html#ch2fig1).
    Integers from –3 to 3 are marked on the line, but between any of these two numbers
    (say, 1 and 2) lie all possible numbers in between: 1.1, 1.2, 1.3, and so on.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个*数轴*，如[图 2-1](ch02.html#ch2fig1)所示。数轴上标记了从 -3 到 3 的整数，但在这两个数字之间（例如，1 和 2）存在所有可能的数字：1.1、1.2、1.3
    等等。
- en: '![image](images/f02-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-01.jpg)'
- en: '*Figure 2-1: A number line*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：数轴*'
- en: The number line makes certain properties visually intuitive. For example, all
    numbers on the right side of 0 are positive, and those on the left side are negative.
    When a number *a* lies on the right side of another number *b*, *a* is always
    greater than *b* and *b* is always less than *a*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数轴使得某些属性变得直观。例如，0 右侧的所有数字是正数，左侧的则是负数。当一个数字 *a* 位于另一个数字 *b* 右侧时，*a* 总是大于 *b*，而
    *b* 总是小于 *a*。
- en: The arrows at the ends of the number line indicate that the line extends infinitely,
    and any point on this line corresponds to some real number, however large it may
    be. A single number is sufficient to describe a point on the number line.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数轴两端的箭头表示该数轴无限延伸，数轴上的每一个点都对应某个实数，无论这个数字多大。一个数字足以描述数轴上的一个点。
- en: Now consider two number lines arranged as shown in [Figure 2-2](ch02.html#ch2fig2).
    The number lines intersect at right angles to each other and cross at the 0 point
    of each line. This forms a *Cartesian coordinate plane*, or an *x*-*y* plane,
    with the horizontal number line called the *x*-axis and the vertical line called
    the *y*-axis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑两个数轴，如[图 2-2](ch02.html#ch2fig2)所示。两个数轴相交于直角，并且在各自的 0 点交叉。这形成了一个*笛卡尔坐标平面*，或称
    *x*-*y* 平面，其中水平数轴称为 *x* 轴，垂直数轴称为 *y* 轴。
- en: '![image](images/f02-02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-02.jpg)'
- en: '*Figure 2-2: The Cartesian coordinate plane*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：笛卡尔坐标平面*'
- en: As with the number line, we can have infinitely many points on the plane. We
    describe a point with a pair of numbers instead of one number. For example, we
    describe the point *A* in the figure with two numbers, *x* and *y*, usually written
    as (*x*, *y*) and referred to as the *coordinates* of the point. As shown in [Figure
    2-2](ch02.html#ch2fig2), *x* is the distance of the point from the origin along
    the *x*-axis, and *y* is the distance along the *y*-axis. The point where the
    two axes intersect is called the *origin* and has the coordinates (0, 0).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与数轴一样，我们可以在平面上有无数多个点。我们用一对数字来描述一个点，而不是一个数字。例如，我们用两个数字 *x* 和 *y* 来描述图中的点 *A*，通常写作
    (*x*, *y*)，这对数字被称为该点的 *坐标*。如[图 2-2](ch02.html#ch2fig2)所示，*x* 是该点沿 *x* 轴从原点起的距离，*y*
    是该点沿 *y* 轴的距离。两个坐标轴交叉的点称为 *原点*，其坐标为 (0, 0)。
- en: The Cartesian coordinate plane allows us to visualize the relationship between
    two sets of numbers. Here, I use the term *set* loosely to mean a collection of
    numbers. (We’ll learn about mathematical sets and how to work with them in Python
    in [Chapter 5](ch05.html#ch05).) No matter what the two sets of numbers represent—temperature,
    baseball scores, or class test scores—all you need are the numbers themselves.
    Then, you can plot them—either on graph paper or on your computer with a program
    written in Python. For the rest of this book, I’ll use the term *plot* as a verb
    to describe the act of plotting two sets of numbers and the term *graph* to describe
    the result—a line, curve, or simply a set of points on the Cartesian plane.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔坐标平面使我们能够可视化两组数字之间的关系。在这里，我用*集合*这个词泛指一组数字。（我们将在[第5章](ch05.html#ch05)学习数学集合以及如何在
    Python 中使用它们。）无论这两组数字代表什么——温度、棒球得分，还是班级测试分数——你所需要的只是这些数字本身。然后，你可以将它们绘制出来——无论是在图纸上，还是通过用
    Python 编写的程序在计算机上绘制。接下来，在本书中，我将用*绘制*这个动词来描述绘制两组数字的行为，而用*图形*来描述结果——一条线、一条曲线，或者仅仅是笛卡尔平面上的一组点。
- en: '**Working with Lists and Tuples**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理列表和元组**'
- en: 'As we make graphs with Python, we’ll work with *lists* and *tuples*. In Python,
    these are two different ways to store groups of values. Tuples and lists are very
    similar for the most part, with one major difference: after you create a list,
    it’s possible to add values to it and to change the order of the values. The values
    in a tuple, on the other hand, are immediately fixed and can’t be changed. We’ll
    use lists to store *x*- and *y*-coordinates for the points we want to plot. Tuples
    will come up in “[Customizing Graphs](ch02.html#ch02lev2sec05)” on [page 41](ch02.html#page_41)
    when we learn to customize the range of our graphs. First, let’s go over some
    features of lists.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 绘制图形时，我们将处理*列表*和*元组*。在 Python 中，这两者是存储一组值的两种不同方式。元组和列表在大多数情况下非常相似，主要的区别在于：创建列表后，你可以向其中添加值，并且可以改变值的顺序。另一方面，元组中的值一旦创建就固定了，不能更改。我们将使用列表来存储我们想要绘制的点的*x*和*y*坐标。元组将在[《自定义图形》](ch02.html#ch02lev2sec05)（第[41页](ch02.html#page_41)）中出现，届时我们将学习如何自定义图形的范围。首先，让我们回顾一下列表的一些特性。
- en: 'You can create a list by entering values, separated by commas, between square
    brackets. The following statement creates a list and uses the label `simplelist`
    to refer to it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方括号中输入用逗号分隔的值来创建一个列表。以下语句创建了一个列表，并使用标签`simplelist`来引用它：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you can refer to the individual numbers—1, 2, and 3—using the label and
    the position of the number in the list, which is called the *index*. So `simplelist[0]`
    refers to the first number, `simplelist[1]` refers to the second number, and `simplelist[2]`
    refers to the third number:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过标签和列表中数字的位置（即*索引*）来引用单个数字——1、2和3。因此，`simplelist[0]`指的是第一个数字，`simplelist[1]`指的是第二个数字，`simplelist[2]`指的是第三个数字：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the first item of the list is at index 0, the second item is at
    index 1, and so on—that is, the positions in the list start counting from 0, not
    1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表的第一个项目位于索引0，第二个项目位于索引1，依此类推——也就是说，列表中的位置从0开始计数，而不是从1开始。
- en: 'Lists can store strings, too:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也可以存储字符串：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One advantage of creating a list is that you don’t have to create a separate
    label for each value; you just create a label for the list and use the index position
    to refer to each item. Also, you can add to the list whenever you need to store
    new values, so a list is the best choice for storing data if you don’t know beforehand
    how many numbers or strings you may need to store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的一个优点是，你不必为每个值创建单独的标签；你只需为列表创建一个标签，并使用索引位置来引用每个项目。此外，当你需要存储新值时，可以随时向列表添加内容，因此如果你事先不知道需要存储多少数字或字符串，列表是存储数据的最佳选择。
- en: 'An *empty list* is just that—a list with no items or elements—and it can be
    created like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*空列表*就是一个没有任何项目或元素的列表，可以像这样创建：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Empty lists are mainly useful when you don’t know any of the items that will
    be in your list beforehand but plan to fill in values during the execution of
    a program. In that case, you can create an empty list and then use the `append()`
    method to add items later:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表主要在你事先不知道列表中会有哪些项目，但计划在程序执行过程中填充值时非常有用。在这种情况下，你可以创建一个空列表，然后使用`append()`方法稍后添加项目：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At ➊, `emptylist` starts off empty. Next, we append the number 1 to the list
    at ➋ and then append 2 at ➌. By line ➍, the list is now [1, 2]. Note that when
    you use `.append()`, the value gets added to the end of the list. This is just
    one way of adding values to a list. There are others, but we won’t need them for
    this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`emptylist` 初始为空。接下来，在 ➋ 处我们将数字 1 添加到列表中，然后在 ➌ 处添加 2。到 ➍ 这一行时，列表已经是 [1,
    2]。注意，当你使用 `.append()` 时，值会被添加到列表的末尾。这只是一种向列表添加值的方式。还有其他方法，但在这一章中我们不需要它们。
- en: 'Creating a tuple is similar to creating a list, but instead of square brackets,
    you use parentheses:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组与创建列表类似，不过是使用圆括号而不是方括号：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can refer to an individual number in `simpletuple` using the corresponding
    index in brackets, just as with lists:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像对待列表一样，通过对应的索引来引用 `simpletuple` 中的单个数字：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also use *negative indices* with both lists and tuples. For example,
    `simplelist[-1]` and `simpletuple[-1]` would refer to the last element of the
    list or the tuple, `simplelist[-2]` and `simpletuple[-2]` would refer to the second-to-last
    element, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对列表和元组使用 *负索引*。例如，`simplelist[-1]` 和 `simpletuple[-1]` 将引用列表或元组中的最后一个元素，`simplelist[-2]`
    和 `simpletuple[-2]` 将引用倒数第二个元素，依此类推。
- en: Tuples, like lists, can have strings as values, and you can create an *empty
    tuple* with no elements as `emptytuple=()`. However, there’s no `append()` method
    to add a new value to an existing tuple, so you can’t add values to an empty tuple.
    Once you create a tuple, the contents of the tuple can’t be changed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表一样，也可以包含字符串作为值，你可以创建一个没有元素的 *空元组*，表示为 `emptytuple=()`。然而，元组没有 `append()`
    方法来向现有元组添加新值，因此你不能向空元组中添加值。一旦创建了元组，元组的内容就无法更改。
- en: '***Iterating over a List or Tuple***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***迭代遍历列表或元组***'
- en: 'We can go over a list or tuple using a `for` loop as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for` 循环遍历列表或元组，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will print the items in the list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印列表中的元素：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The items in a tuple can be retrieved in the same way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中的元素可以以相同的方式进行检索。
- en: 'Sometimes you might need to know the position or the index of an item in a
    list or tuple. You can use the `enumerate()` function to iterate over all the
    items of a list and return the index of an item as well as the item itself. We
    use the labels `index` and `item` to refer to them:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要知道列表或元组中某个元素的位置或索引。你可以使用 `enumerate()` 函数遍历列表中的所有元素，并返回元素的索引以及元素本身。我们用
    `index` 和 `item` 标签来引用它们：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will produce the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This also works for tuples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这对元组也适用。
- en: '**Creating Graphs with Matplotlib**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Matplotlib 创建图表**'
- en: We’ll be using matplotlib to make graphs with Python. Matplotlib is a Python
    *package*, which means that it’s a collection of modules with related functionality.
    In this case, the modules are useful for plotting numbers and making graphs. Matplotlib
    doesn’t come built in with Python’s standard library, so you’ll have to install
    it. The installation instructions are covered in [Appendix A](app01.html#app01).
    Once you have it installed, start a Python shell. As explained in the installation
    instructions, you can either continue using IDLE shell or use Python’s built-in
    shell.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 matplotlib 来绘制 Python 图表。Matplotlib 是一个 Python *包*，意味着它是一个包含相关功能模块的集合。在这个案例中，这些模块用于绘制数字和生成图表。Matplotlib
    并不包含在 Python 的标准库中，因此你需要安装它。安装说明请参见 [附录 A](app01.html#app01)。安装完成后，启动 Python shell。正如安装说明中所述，你可以继续使用
    IDLE shell，或者使用 Python 自带的 shell。
- en: 'Now we’re ready to create our first graph. We’ll start with a simple graph
    with just three points: (1, 2), (2, 4), and (3, 6). To create this graph, we’ll
    first make two lists of numbers—one storing the values of the *x*-coordinates
    of these points and another storing the *y*-coordinates. The following two statements
    do exactly that, creating the two lists `x_numbers` and `y_numbers`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好创建我们的第一个图表。我们将从一个简单的图表开始，只有三个点：(1, 2)、(2, 4) 和 (3, 6)。为了创建这个图表，我们首先将创建两个数字列表，一个存储这些点的
    *x* 坐标，另一个存储 *y* 坐标。下面的两个语句正是做了这件事，创建了两个列表 `x_numbers` 和 `y_numbers`：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From here, we can create the plot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以创建图表：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first line, we import the `plot()` and `show()` functions from the `pylab`
    module, which is part of the matplotlib package. Next, we call the `plot()` function
    in the second line. The first argument to the `plot()` function is the list of
    numbers we want to plot on the *x*-axis, and the second argument is the corresponding
    list of numbers we want to plot on the *y*-axis. The `plot()` function returns
    an object—or more precisely, a list containing an object. This object contains
    the information about the graph that we asked Python to create. At this stage,
    you can add more information, such as a title, to the graph, or you can just display
    the graph as it is. For now we’ll just display the graph.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们从 `pylab` 模块导入了 `plot()` 和 `show()` 函数，这个模块是 matplotlib 包的一部分。接下来，我们在第二行调用了
    `plot()` 函数。`plot()` 函数的第一个参数是我们想要在 *x* 轴上绘制的数字列表，第二个参数是我们想要在 *y* 轴上绘制的对应数字列表。`plot()`
    函数返回一个对象——更准确地说，是一个包含对象的列表。这个对象包含了我们请求 Python 创建的图形信息。在这个阶段，你可以向图形添加更多信息，比如标题，或者你也可以直接显示图形。现在我们先只显示图形。
- en: 'The `plot()` function only creates the graph. To actually display it, we have
    to call the `show()` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()` 函数仅创建图形。为了实际显示图形，我们还需要调用 `show()` 函数：'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should see the graph in a matplotlib window as shown in [Figure 2-3](ch02.html#ch2fig3).
    (The display window may look different depending on your operating system, but
    the graph should be the same.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在 matplotlib 窗口中看到图形，如 [图 2-3](ch02.html#ch2fig3) 所示。（显示窗口可能会因操作系统的不同而有所不同，但图形应该是一样的。）
- en: '![image](images/f02-03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-03.jpg)'
- en: '*Figure 2-3: A graph showing a line passing through the points (1, 2), (2,
    4), and (3, 6)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：一条经过点 (1, 2)、(2, 4) 和 (3, 6) 的线图*'
- en: Notice that instead of starting from the origin (0, 0), the *x*-axis starts
    from the number 1 and the *y*-axis starts from the number 2\. These are the lowest
    numbers from each of the two lists. Also, you can see increments marked on each
    of the axes (such as 2.5, 3.0, 3.5, etc., on the *y*-axis). In “[Customizing Graphs](ch02.html#ch02lev2sec05)”
    on [page 41](ch02.html#page_41), we’ll learn how to control those aspects of the
    graph, along with how to add axes labels and a graph title.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*x* 轴不是从原点 (0, 0) 开始，而是从数字 1 开始，*y* 轴从数字 2 开始。这是两个列表中的最小值。同时，你还可以看到每个坐标轴上标有增量（例如
    *y* 轴上有 2.5、3.0、3.5 等）。在 “[自定义图形](ch02.html#ch02lev2sec05)” 章节的 [第 41 页](ch02.html#page_41)，我们将学习如何控制这些图形的各个方面，包括如何添加坐标轴标签和图形标题。
- en: You’ll notice in the interactive shell that you can’t enter any further statements
    until you close the matplotlib window. Close the graph window so that you can
    continue programming.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在交互式命令行中，直到你关闭 matplotlib 窗口之前，你无法输入更多的语句。关闭图形窗口后，你就可以继续编程了。
- en: '***Marking Points on Your Graph***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在图形上标记点***'
- en: 'If you want the graph to mark the points that you supplied for plotting, you
    can use an additional keyword argument while calling the `plot()` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望图形标记出你提供的绘制点，可以在调用 `plot()` 函数时使用额外的关键字参数：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By entering `marker='o'`, we tell Python to mark each point from our lists with
    a small dot that looks like an *o*. Once you enter `show()` again, you’ll see
    that each point is marked with a dot (see [Figure 2-4](ch02.html#ch2fig4)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 `marker='o'`，我们告诉 Python 用一个看起来像 *o* 的小圆点来标记列表中的每个点。再次输入 `show()` 后，你会看到每个点都被一个圆点标记（参见
    [图 2-4](ch02.html#ch2fig4)）。
- en: '![image](images/f02-04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-04.jpg)'
- en: '*Figure 2-4: A graph showing a line passing through the points (1, 2), (2,
    4), and (3, 6) with the points marked by a dot*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：一条经过点 (1, 2)、(2, 4) 和 (3, 6) 的线图，并且各点由小圆点标记*'
- en: 'The marker at (2, 4) is easily visible, while the others are hidden in the
    very corners of the graph. You can choose from several `marker` options, including
    `''o''`, `''*''`, `''x''`, and `''+''`. Using `marker=` includes a line connecting
    the points (this is the default). You can also make a graph that marks only the
    points that you specified, without any line connecting them, by omitting `marker=`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 (2, 4) 的标记非常明显，而其他标记则隐藏在图形的角落里。你可以从多个 `marker` 选项中进行选择，包括 `'o'`、`'*'`、`'x'`
    和 `'+'`。使用 `marker=` 会在各点之间连接一条线（这是默认设置）。你还可以绘制仅标记指定点的图形，不连接它们的线，只需省略 `marker=`
    参数即可：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `'o'` indicates that each point should be marked with a dot, but there
    should be no line connecting the points. Call the function `show()` to display
    the graph, which should look like the one shown in [Figure 2-5](ch02.html#ch2fig5).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`'o'` 表示每个点应当用一个点标记，但点与点之间不应有连接线。调用 `show()` 函数以显示图表，图表应该和 [图 2-5](ch02.html#ch2fig5)
    中显示的一样。
- en: '![image](images/f02-05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-05.jpg)'
- en: '*Figure 2-5: A graph showing the points (1, 2), (2, 4), and (3, 6)*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：显示点 (1, 2)、(2, 4) 和 (3, 6) 的图表*'
- en: As you can see, only the points are now shown on the graph, with no line connecting
    them. As in the previous graph, the first and the last points are barely visible,
    but we’ll soon see how to change that.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在图表上只显示了点，没有连接这些点的线条。和之前的图表一样，第一个和最后一个点几乎不可见，但我们很快就会看到如何改变这一点。
- en: '***Graphing the Average Annual Temperature in New York City***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制纽约市的平均年温度***'
- en: 'Let’s take a look at a slightly larger set of data so we can explore more features
    of matplotlib. The average annual temperatures for New York City— measured at
    Central Park, specifically—during the years 2000 to 2012 are as follows: 53.9,
    56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, and 57.3 degrees
    Fahrenheit. Right now, that just looks like a random jumble of numbers, but we
    can plot this set of temperatures on a graph to make the rise and fall in the
    average temperature from year to year much clearer:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下一个稍大的数据集，以便探索 matplotlib 的更多功能。2000 年到 2012 年间，纽约市——具体来说是中央公园——的年平均气温如下：53.9、56.3、56.4、53.4、54.5、55.8、56.8、55.0、55.3、54.0、56.7、56.4
    和 57.3 华氏度。现在，这看起来像是随机的数字杂乱无章，但我们可以将这些温度数据绘制在图表上，以便更清晰地展示每年温度的升降：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We store the average temperatures in a list, `nyc_temp`. Then, we call the function
    `plot()` passing only this list (and the marker string). When you use `plot()`
    on a single list, those numbers are automatically plotted on the *y*-axis. The
    corresponding values on the *x*-axis are filled in as the positions of each value
    in the list. That is, the first temperature value, 53.9, gets a corresponding
    *x*-axis value of 0 because it’s in position 0 of the list (remember, the list
    position starts counting from 0, not 1). As a result, the numbers plotted on the
    *x*-axis are the integers from 0 to 12, which we can think of as corresponding
    to the 13 years for which we have temperature data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将平均温度存储在一个列表 `nyc_temp` 中。然后，我们调用 `plot()` 函数，只传入这个列表（以及标记字符串）。当你在单个列表上使用
    `plot()` 时，这些数字会自动绘制在 *y* 轴上。*x* 轴上对应的值是每个值在列表中的位置。也就是说，第一个温度值 53.9 对应的 *x* 轴值是
    0，因为它在列表的位置是 0（记住，列表的位置是从 0 开始计数的，不是从 1 开始）。因此，绘制在 *x* 轴上的数字是从 0 到 12 的整数，我们可以认为它们对应于我们拥有温度数据的
    13 年。
- en: Enter `show()` to display the graph, which is shown in [Figure 2-6](ch02.html#ch2fig6).
    The graph shows that the average temperature has risen and fallen from year to
    year. If you glance at the numbers we plotted, they really aren’t very far apart
    from each other. However, the graph makes the variations seem rather dramatic.
    So, what’s going on? The reason is that matplotlib chooses the range of the *y*-axis
    so that it’s just enough to enclose the data supplied for plotting. So in this
    graph, the *y*-axis starts at 53.0 and its highest value is 57.5\. This makes
    even small differences look magnified because the range of the *y*-axis is so
    small. We’ll learn how to control the range of each axis in “[Customizing Graphs](ch02.html#ch02lev2sec05)”
    on [page 41](ch02.html#page_41).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `show()` 来显示图表，图表显示在 [图 2-6](ch02.html#ch2fig6) 中。图表显示了平均温度年年波动。如果你看看我们绘制的数字，它们实际上并不相距太远。然而，图表使得这些变化看起来相当剧烈。那么，发生了什么呢？原因在于
    matplotlib 会选择 *y* 轴的范围，使其恰好足够包含提供的绘图数据。所以在这张图表中，*y* 轴从 53.0 开始，最高值为 57.5。这使得即使是小的差异也显得被放大了，因为
    *y* 轴的范围非常小。我们将在 “[自定义图表](ch02.html#ch02lev2sec05)” 中学习如何控制每个轴的范围，[第 41 页](ch02.html#page_41)。
- en: '![image](images/f02-06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-06.jpg)'
- en: '*Figure 2-6: A graph showing the average annual temperature of New York City
    during the years 2000–2012*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：显示纽约市 2000-2012 年间的年平均气温的图表*'
- en: You can also see that numbers on the *y*-axis are floating point numbers (because
    that’s what we asked to be plotted) and those on the *x*-axis are integers. Matplotlib
    can handle either.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到，*y* 轴上的数字是浮点数（因为我们要求绘制的是浮动的数字），而 *x* 轴上的数字是整数。Matplotlib 可以处理这两者。
- en: 'Plotting the temperature without showing the corresponding years is a quick
    and easy way to visualize the variations between the years. If you were planning
    to present this graph to someone, however, you’d want to make it clearer by showing
    which year each temperature corresponds to. We can easily do this by creating
    another list with the years in it and then calling the `plot()` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不显示对应年份的温度变化图是快速且简便的方式来观察不同年份之间的差异。然而，如果你打算向别人展示这张图表，你可能会希望通过标明每个温度对应的年份来使图表更加清晰。我们可以通过创建一个包含年份的列表，并调用
    `plot()` 函数来轻松实现这一点：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `range()` function we learned about in [Chapter 1](ch01.html#ch01)
    to specify the years 2000 to 2012\. Now you’ll see the years displayed on the
    *x*-axis (see [Figure 2-7](ch02.html#ch2fig7)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在[第 1 章](ch01.html#ch01)中学到的 `range()` 函数来指定从 2000 年到 2012 年的年份。现在你会看到这些年份显示在
    *x* 轴上（参见[图 2-7](ch02.html#ch2fig7)）。
- en: '![image](images/f02-07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-07.jpg)'
- en: '*Figure 2-7: A graph showing the average annual temperature of New York City,
    displaying the years on the* x-*axis*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：显示纽约市的平均年度温度，年份显示在 *x* 轴上*'
- en: '***Comparing the Monthly Temperature Trends of New York City***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比较纽约市的月度温度趋势***'
- en: 'While still looking at New York City, let’s see how the average monthly temperature
    has varied over the years. This will give us a chance to understand how to plot
    multiple lines on a single graph. We’ll choose three years: 2000, 2006, and 2012\.
    For each of these years, we’ll plot the average temperature for all 12 months.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 继续观察纽约市的情况，我们来看看平均月温度在这些年份中的变化。这将帮助我们了解如何在一张图上绘制多条线。我们选择 2000 年、2006 年和 2012
    年这三年，分别绘制这三年的 12 个月的平均温度。
- en: 'First, we need to create three lists to store the temperature (in Fahrenheit).
    Each list will consist of 12 numbers corresponding to the average temperature
    from January to December each year:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建三个列表来存储温度（单位为华氏度）。每个列表将包含 12 个数字，分别对应每年从一月到十二月的平均温度：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first list corresponds to the year 2000, and the next two lists correspond
    to the years 2006 and 2012, respectively. We could plot the three sets of data
    on three different graphs, but that wouldn’t make it very easy to see how each
    year compares to the others. Try doing it!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表对应于 2000 年，接下来的两个列表分别对应 2006 年和 2012 年。我们可以将这三组数据绘制在三个不同的图表上，但那样就不容易比较每一年之间的差异了。试试看吧！
- en: 'The clearest way to compare all of these temperatures is to plot all three
    data sets on a *single* graph, like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这些温度的最清晰方式是将这三组数据绘制在 *同一* 图表上，就像这样：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we create a list (`months`) where we store the numbers 1, 2, 3, and so
    on up to 12 using the `range()` function. Next, we call the `plot()` function
    with three pairs of lists. Each pair consists of a list of months to be plotted
    on the *x*-axis and a list of average monthly temperatures (for 2000, 2006, and
    2012, respectively) to be plotted on the *y*-axis. So far, we’ve used `plot()`
    on only one pair of lists at a time, but you can actually enter multiple pairs
    of lists into the `plot()` function. With each list separated by a comma, the
    `plot()` function will automatically plot a different line for each pair.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个列表（`months`），使用 `range()` 函数将数字 1、2、3 等依次存储到 12。接着，我们用三对列表调用 `plot()`
    函数。每对列表包含一个表示月份的 *x* 轴列表和一个表示每年（2000、2006 和 2012 年）平均月温度的 *y* 轴列表。到目前为止，我们每次只使用
    `plot()` 函数绘制一对列表，但实际上你可以将多个列表对传递给 `plot()` 函数。每对列表之间用逗号分隔，`plot()` 函数会自动为每对列表绘制不同的线条。
- en: The `plot()` function returns a list of three objects instead of one. Matplotlib
    considers the three curves as distinct from each other, and it knows to draw them
    on top of each other when you call `show()`. Let’s call `show()` to display the
    graph, as shown in [Figure 2-8](ch02.html#ch2fig8).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()` 函数返回的是三个对象的列表，而不是一个。Matplotlib 将这三条曲线视为相互独立的，当你调用 `show()` 时，它会知道将它们绘制在同一张图上。我们可以调用
    `show()` 来显示图表，如[图 2-8](ch02.html#ch2fig8)所示。'
- en: '![image](images/f02-08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-08.jpg)'
- en: '*Figure 2-8: A graph showing the average monthly temperature of New York City
    during the years 2000, 2006, and 2012*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：显示纽约市在 2000、2006 和 2012 年的平均月温度的图表*'
- en: Now we have three plots all on one graph. Python automatically chooses a different
    color for each line to indicate that the lines have been plotted from different
    data sets.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将三条图线绘制在同一张图表上。Python 会自动为每条线选择不同的颜色，以表明这些线条来源于不同的数据集。
- en: 'Instead of calling the plot function with all three pairs at once, we could
    also call the plot function three separate times, once for each pair:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择分别调用三次`plot`函数，而不是一次性将所有三个数据对传入，分别为每个数据对调用一次：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Matplotlib keeps track of what plots haven’t been displayed yet. So as long
    as we wait to call `show()` until after we call `plot()` all three times, the
    plots will all get displayed on the same graph.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib会记录哪些图形尚未显示。因此，只要在调用`plot()`三次之后再调用`show()`，这些图形都会在同一张图表上显示。
- en: 'We have a problem, however, because we don’t have any clue as to which color
    corresponds to which year. To fix this, we can use the function `legend()`, which
    lets us add a legend to the graph. A *legend* is a small display box that identifies
    what different parts of the graph mean. Here, we’ll use a legend to indicate which
    year each colored line stands for. To add the legend, first call the `plot()`
    function as earlier:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了一个问题，因为我们不知道哪种颜色代表哪一年。为了解决这个问题，我们可以使用`legend()`函数来为图表添加图例。图例是一个小的显示框，用来标识图表中不同部分的含义。在这里，我们将使用图例来标明每条彩色线条对应的年份。要添加图例，首先像之前一样调用`plot()`函数：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, import the `legend()` function from the `pylab` module and call it as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从`pylab`模块导入`legend()`函数，并按如下方式调用：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We call the `legend()` function with a list of the labels we want to use to
    identify each plot on the graph. These labels are entered in this order to match
    the order of the pairs of lists that were entered in the `plot()` function. That
    is, `2000` will be the label for the plot of the first pair we entered in the
    `plot()` function; `2006`, for the second pair; and `2012`, for the third. You
    can also specify a second argument to the function that will specify the position
    of the legend. By default, it’s always positioned at the top right of the graph.
    However, you can specify a particular position, such as `'lower center'`, `'center
    left'`, and `'upper left'`. Or you can set the position to `'best'`, and the legend
    will be positioned so as not to interfere with the graph.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`legend()`函数传入一个标签列表，用来标识图表中每一条线的含义。这些标签的顺序与`plot()`函数中输入的列表数据对顺序相匹配。也就是说，`2000`将作为我们在`plot()`函数中输入的第一对数据的标签；`2006`作为第二对数据的标签；`2012`作为第三对数据的标签。你还可以为该函数指定第二个参数，来设置图例的位置。默认情况下，图例总是位于图表的右上角。但是，你可以指定一个特定的位置，比如`'lower
    center'`、`'center left'`和`'upper left'`。或者，你可以将位置设置为`'best'`，这样图例将自动放置在不会干扰图表的地方。
- en: 'Finally, we call `show()` to display the graph:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`show()`来显示图表：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see in the graph (see [Figure 2-9](ch02.html#ch2fig9)), there’s now
    a legend box in the top-right corner. It tells us which line represents the average
    monthly temperature for the year 2000, which line represents the year 2006, and
    which line represents the year 2012.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图表中看到的（参见[图2-9](ch02.html#ch2fig9)），现在右上角有了一个图例框。它告诉我们哪条线表示2000年的月平均气温，哪条线表示2006年，哪条线表示2012年。
- en: 'Looking at the graph, you can conclude two interesting facts: the highest temperature
    for all three years was in and around July (corresponding to 7 on the *x*-axis),
    and it has been increasing from 2000 with a more dramatic rise between 2000 and
    2006\. Having all three lines plotted together in one graph makes it a lot easier
    to see these kinds of relationships. It’s certainly clearer than just looking
    at a few long lists of numbers or even looking at three lines plotted on three
    separate graphs.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中可以得出两个有趣的结论：三个年份的最高气温都出现在7月左右（对应于*X*轴的7），而且从2000年到2012年之间，气温逐年升高，尤其是2000年到2006年之间的升幅最为显著。将三条线绘制在同一个图表中，能够更容易地看出这些关系。这比单纯查看一长串的数字或是将三条线分别绘制在三个不同图表中要清晰得多。
- en: '![image](images/f02-09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-09.jpg)'
- en: '*Figure 2-9: A graph showing the average monthly temperature of New York City,
    with a legend to show the year each color corresponds to*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：展示纽约市平均月气温的图表，并有图例标明每条颜色对应的年份*'
- en: '***Customizing Graphs***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义图形***'
- en: We already learned about one way to customize a graph—by adding a legend. Now,
    we’ll learn about other ways to customize a graph and to make it clearer by adding
    labels to the *x*- and *y*-axes, adding a title to the graph, and controlling
    the range and steps of the axes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了一种自定义图形的方法——通过添加图例。接下来，我们将学习更多自定义图形的方法，通过给*X*轴和*Y*轴添加标签、给图表添加标题，并控制坐标轴的范围和步长，来使图表更加清晰。
- en: '**Adding a Title and Labels**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加标题和标签**'
- en: 'We can add a title to our graph using the `title()` function and add labels
    for the *x*- and *y*-axes using the `xlabel()` and `ylabel()` functions. Let’s
    re-create the last plot and add all this additional information:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`title()`函数为图表添加标题，并使用`xlabel()`和`ylabel()`函数分别为* x *轴和* y *轴添加标签。让我们重新创建上一个图表，并添加所有这些附加信息：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All three functions—`title()`, `xlabel()`, and `ylabel()`—are called with the
    corresponding text that we want to appear on the graph entered as strings. Calling
    the `show()` function will display the graph with all this newly added information
    (see [Figure 2-10](ch02.html#ch2fig10)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个函数——`title()`、`xlabel()`和`ylabel()`——都通过字符串传入我们希望显示在图表上的对应文本。调用`show()`函数将显示带有所有新增信息的图表（参见[图
    2-10](ch02.html#ch2fig10)）。
- en: '![image](images/f02-10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-10.jpg)'
- en: '*Figure 2-10: Axes labels and a title have been added to the graph.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：图表中已添加坐标轴标签和标题。*'
- en: With the three new pieces of information added, the graph is easier to understand.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这三项新信息后，图表变得更容易理解。
- en: '**Customizing the Axes**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自定义坐标轴**'
- en: So far, we’ve allowed the numbers on both axes to be automatically determined
    by Python based on the data supplied to the `plot()` function. This may be fine
    for most cases, but sometimes this automatic range isn’t the clearest way to present
    the data, as we saw in the graph where we plotted the average annual temperature
    of New York City (see [Figure 2-7](ch02.html#ch2fig7)). There, even small changes
    in the temperature seemed large because the automatically chosen *y*-axis range
    was very narrow. We can adjust the range of the axes using the `axis()` function.
    This function can be used both to retrieve the current range and to set a new
    range for the axes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们让Python根据传递给`plot()`函数的数据自动确定了两个坐标轴上的数字范围。对于大多数情况，这样做是可以的，但有时这种自动范围的方式并不是最清晰的数据呈现方式，就像我们在绘制纽约市年平均温度的图表时所看到的那样（参见[图
    2-7](ch02.html#ch2fig7)）。在那里，即使温度的变化很小，由于自动选择的* y *轴范围非常狭窄，看起来变化也很大。我们可以通过`axis()`函数来调整坐标轴的范围。这个函数既可以用来获取当前的范围，也可以用来设置坐标轴的新范围。
- en: Consider, once again, the average annual temperature of New York City during
    the years 2000 to 2012 and create a plot as we did earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑2000到2012年间纽约市的年平均温度，并像之前一样创建图表。
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, import the `axis()` function and call it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导入`axis()`函数并调用它：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The function returned a tuple with four numbers corresponding to the range
    for the *x*-axis (0.0, 12.0) and the *y*-axis (53.0, 57.5). These are the same
    range values from the graph that we made earlier. Now, let’s change the *y*-axis
    to start from 0 instead of 53.0:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回了一个包含四个数字的元组，这些数字对应于* x *轴的范围（0.0, 12.0）和* y *轴的范围（53.0, 57.5）。这些值与我们之前绘制的图形中的范围值相同。现在，让我们将*
    y *轴的起始值从53.0改为0：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Calling the `axis()` function with the new starting value for the *y*-axis (specified
    by `ymin=0`) changes the range, and the returned tuple confirms it. If you display
    the graph by calling the `show()` function, the *y*-axis starts at 0, and the
    differences between the values of the consecutive years look less drastic (see
    [Figure 2-11](ch02.html#ch2fig11)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`axis()`函数并设置新的* y *轴起始值（由`ymin=0`指定）会改变范围，返回的元组也会确认这一点。如果通过调用`show()`函数显示图表，*
    y *轴将从0开始，连续年份之间的差异看起来就不那么剧烈了（参见[图 2-11](ch02.html#ch2fig11)）。
- en: '![image](images/f02-11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-11.jpg)'
- en: '*Figure 2-11: A graph showing the average annual temperature of New York City
    during the years 2000–2012\. The* y-*axis has been customized to start from 0.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-11：显示2000到2012年间纽约市年平均温度的图表。* y *轴已被自定义为从0开始。*'
- en: Similarly, you can use `xmin`, `xmax`, and `ymax` to set the minimum and maximum
    values for the *x*-axis and the maximum value for the *y*-axis, respectively.
    If you’re changing all four values, you may find it easier to call the `axis()`
    function with all four range values entered as a list, such as `axis([0, 10, 0,
    20])`. This would set the range of the *x*-axis to (0, 10) and that of the *y*-axis
    to (0, 20).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用`xmin`、`xmax`和`ymax`分别设置* x *轴的最小值和最大值，以及* y *轴的最大值。如果你要更改所有四个值，可能会觉得调用`axis()`函数，并将所有四个范围值作为列表传入（例如`axis([0,
    10, 0, 20])`）更为方便。这样将会把* x *轴的范围设置为（0, 10），而* y *轴的范围设置为（0, 20）。
- en: '**Plotting Using pyplot**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 pyplot 绘图**'
- en: The `pylab` module is useful for creating plots in an interactive shell, such
    as the IDLE shell, as we’ve been doing so far. However, when using matplotlib
    outside of the IDLE shell—for example, as part of a larger program—the `pyplot`
    module is more efficient. Don’t worry—all the methods that you learned about when
    using `pylab` will work the same way with `pyplot`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`pylab`模块适用于在交互式 shell 中创建图表，例如我们一直在使用的 IDLE shell。然而，在IDLE shell之外使用matplotlib时——例如作为更大程序的一部分——`pyplot`模块更加高效。别担心——你在使用`pylab`时学到的所有方法，在使用`pyplot`时也会以相同的方式工作。'
- en: 'The following program recreates the first plot in this chapter using the `pyplot`
    module:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用`pyplot`模块重新创建了本章中的第一个图表：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we import the `pyplot` module using the statement import matplotlib .pyplot
    ➊. This means that we’re importing the entire `pyplot` module from the matplotlib
    package. To refer to any function or class definition defined in this module,
    you’ll have to use the syntax `matplotlib.pyplot.item`, where `item` is the function
    or class you want to use.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过语句`import matplotlib.pyplot`导入`pyplot`模块 ➊。这意味着我们正在从matplotlib包中导入整个`pyplot`模块。为了引用该模块中定义的任何函数或类定义，你必须使用语法`matplotlib.pyplot.item`，其中`item`是你要使用的函数或类。
- en: This is different from importing a single function or class at a time, which
    is what we’ve been doing so far. For example, in the first chapter we imported
    the `Fraction` class as `from fractions import Fraction`. Importing an entire
    module is useful when you’re going to use a number of functions from that module.
    Instead of importing them individually, you can just import the whole module at
    once and refer to different functions when you need them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前按需导入单个函数或类有所不同。例如，在第一章中，我们通过`from fractions import Fraction`导入了`Fraction`类。导入整个模块在你打算使用该模块中的多个函数时非常有用。你可以一次性导入整个模块，然后在需要时引用不同的函数，而不必单独导入它们。
- en: In the `create_graph()` function at ➋, we create the two lists of numbers that
    we want to plot on the graph and then pass the two lists to the `plot()` function,
    the same way we did before with `pylab`. This time, however, we call the function
    as `matplotlib.pyplot.plot()`, which means that we’re calling the `plot()` function
    defined in the `pyplot` module of the matplotlib package. Then, we call the `show()`
    function to display the graph. The only difference between the way you plot the
    numbers here compared to what we did earlier is the mechanism of calling the functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create_graph()`函数中（见➋），我们创建了要绘制在图表上的两个数字列表，然后将这两个列表传递给`plot()`函数，方式与我们之前使用`pylab`时相同。然而，这一次，我们调用函数为`matplotlib.pyplot.plot()`，这意味着我们正在调用在matplotlib包的`pyplot`模块中定义的`plot()`函数。然后，我们调用`show()`函数来显示图表。与之前绘制数字的方式相比，唯一的不同之处是调用函数的机制。
- en: 'To save us some typing, we can import the `pyplot` module by entering `import
    matplotlib.pyplot as plt`. Then, we can refer to `pyplot` with the label `plt`
    in our programs, instead of having to always type `matplotlib.pyplot`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输入量，我们可以通过输入`import matplotlib.pyplot as plt`来导入`pyplot`模块。然后，在程序中，我们可以使用标签`plt`来引用`pyplot`，而不必每次都输入`matplotlib.pyplot`：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we can call the functions by prefixing them with the shortened `plt` instead
    of `matplotlib.pyplot`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在函数前添加简写`plt`来调用这些函数，而不是使用`matplotlib.pyplot`。
- en: Going ahead, for the rest of this chapter and this book, we’ll use `pylab` in
    the interactive shell and `pyplot` otherwise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在本章和本书的其余部分，我们将使用`pylab`在交互式shell中，而在其他情况下使用`pyplot`。
- en: '***Saving the Plots***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保存图表***'
- en: If you need to save your graphs, you can do so using the `savefig()` function.
    This function saves the graph as an image file, which you can use in reports or
    presentations. You can choose among several image formats, including PNG, PDF,
    and SVG.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要保存你的图表，可以使用`savefig()`函数。此函数将图表保存为图像文件，你可以在报告或演示文稿中使用。你可以选择多种图像格式，包括PNG、PDF和SVG。
- en: 'Here’s an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This program will save the graph to an image file, *mygraph.png*, in your current
    directory. On Microsoft Windows, this is usually *C:\Python33* (where you installed
    Python). On Linux, the current directory is usually your home directory *(/home/<username>*),
    where *<username>* is the user you’re logged in as. On a Mac, IDLE saves files
    to *~/Documents* by default. If you wanted to save it in a different directory,
    specify the complete pathname. For example, to save the image under *C:\* on Windows
    as *mygraph.png*, you’d call the `savefig()` function as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序将把图形保存为图像文件 *mygraph.png*，并保存在当前目录中。在 Microsoft Windows 上，当前目录通常是 *C:\Python33*（即你安装
    Python 的目录）。在 Linux 上，当前目录通常是你的主目录 *(/home/<username>*)，其中 *<username>* 是你登录的用户名。在
    Mac 上，IDLE 默认将文件保存到 *~/Documents*。如果你想将其保存到不同的目录中，可以指定完整的路径。例如，要将图像保存在 Windows
    的 *C:\* 目录下并命名为 *mygraph.png*，你可以按照如下方式调用 `savefig()` 函数：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you open the image in an image-viewing program, you’ll see the same graph
    you’d see by calling the `show()` function. (You’ll notice that the image file
    contains only the graph—not the entire window that pops up with the `show()` function).
    To specify a different image format, simply name the file with the appropriate
    extension. For example, `mygraph.svg` will create an SVG image file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在图像查看程序中打开该图像，你会看到与调用 `show()` 函数时相同的图形。（你会注意到，图像文件只包含图形——而不是包含 `show()`
    函数弹出窗口的整个内容）。要指定不同的图像格式，只需使用适当的扩展名命名文件。例如，`mygraph.svg` 会创建一个 SVG 图像文件。
- en: Another way to save a figure is to use the Save button in the window that pops
    up when you call `show()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种保存图形的方法是使用弹出窗口中的“保存”按钮，该窗口在调用 `show()` 时会显示。
- en: '**Plotting with Formulas**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用公式绘图**'
- en: Until now, we’ve been plotting points on our graphs based on observed scientific
    measurements. In those graphs, we already had all our values for *x* and *y* laid
    out. For example, recorded temperatures and dates were already available to us
    at the time we wanted to create the New York City graph, showing how the temperature
    varied over months or years. In this section, we’re going to create graphs from
    mathematical formulas.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在根据观测到的科学数据在图表上绘制点。在这些图表中，我们已经预先拥有了 *x* 和 *y* 的所有数值。例如，在我们想要创建纽约市的温度变化图时，记录的温度和日期已经可以使用了。在本节中，我们将基于数学公式创建图表。
- en: '***Newton’s Law of Universal Gravitation***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***牛顿万有引力定律***'
- en: According to Newton’s law of universal gravitation, a body of mass *m*[1] attracts
    another body of mass *m*[2] with an amount of force *F* according to the formula
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据牛顿的万有引力定律，一个质量为 *m*[1] 的物体会根据公式与另一个质量为 *m*[2] 的物体相互吸引，产生的力为 *F*。
- en: '![image](images/e0046-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0046-01.jpg)'
- en: where *r* is the distance between the two bodies and *G* is the gravitational
    constant. We want to see what happens to the force as the distance between the
    two bodies increases.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *r* 是两个物体之间的距离，*G* 是引力常数。我们想观察随着两个物体之间的距离增加，引力如何变化。
- en: 'Let’s take the masses of two bodies: the mass of the first body (*m*[1]) is
    0.5 kg, and the mass of the second body (*m*[2]) is 1.5 kg. The value of the gravitational
    constant is 6.674 × 10^(–11) N m² kg^(–2). Now we’re ready to calculate the gravitational
    force between these two bodies at 19 different distances: 100 m, 150 m, 200 m,
    250 m, 300 m, and so on up through 1000 m. The following program performs these
    calculations and also draws the graph:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个物体的质量：第一个物体的质量（*m*[1]）为 0.5 kg，第二个物体的质量（*m*[2]）为 1.5 kg。引力常数的值为 6.674 ×
    10^(–11) N m² kg^(–2)。现在我们准备计算这两个物体在 19 个不同距离下的引力：100 m、150 m、200 m、250 m、300
    m，一直到 1000 m。以下程序执行这些计算，并绘制图形：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `generate_F_r()` function does most of the work in the program above. At
    ➊, we use the `range()` function to create a list labeled `r` with different values
    for distance, using a step value of 50\. The final value is specified as 1001
    because we want 1000 to be included as well. We then create an empty list (`F`),
    where we’ll store the corresponding gravitational force at each of these distances.
    Next, we create labels referring to the gravitational constant (`G`) and the two
    masses (`m1` and `m2`). Using a `for` loop ➋, we then calculate the force at each
    of the values in the list of distances (`r`). We use a label (`force`) to refer
    to the force calculated and to append it to the list (`F`). Finally, we call the
    function `draw_graph()` at ➌ with the list of distances and the list of the calculated
    forces. The *x*-axis of the graph displays the force, and the *y*-axis displays
    the distance. The graph is shown in [Figure 2-12](ch02.html#ch2fig12).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_F_r()`函数在上面的程序中完成了大部分工作。在➊处，我们使用`range()`函数创建一个名为`r`的列表，列出不同距离的数值，步长为50\。最终值设置为1001，因为我们希望包含1000。然后我们创建一个空列表（`F`），在其中存储这些距离对应的重力值。接下来，我们创建了表示重力常数（`G`）和两个质量（`m1`和`m2`）的标签。然后使用`for`循环
    ➋，对距离列表（`r`）中的每一个值计算重力。在计算过程中，我们使用`force`作为标签来表示计算出的力，并将其添加到列表（`F`）中。最后，在➌处，我们调用`draw_graph()`函数，传入距离列表和计算出的力列表。图表的*x*轴表示力，*y*轴表示距离。该图在[图
    2-12](ch02.html#ch2fig12)中展示。'
- en: As the distance (`r`) increases, the gravitational force decreases. With this
    kind of relationship, we say that the gravitational force is *inversely proportional*
    to the distance between the two bodies. Also, note that when the value of one
    of the two variables changes, the other variable won’t necessarily change by the
    same proportion. We refer to this as a *nonlinear relationship*. As a result,
    we end up with a curved line on the graph instead of a straight one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着距离（`r`）的增加，重力逐渐减小。根据这种关系，我们可以说重力与两个物体之间的距离成*反比*。另外，请注意，当两个变量中的一个发生变化时，另一个变量的变化不一定是成比例的。这种关系被称为*非线性关系*。因此，我们在图表上得到的是一条曲线，而不是直线。
- en: '![image](images/f02-12.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-12.jpg)'
- en: '*Figure 2-12: Visualization of the relationship between the gravitational force
    and the squared distance*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-12：重力与平方距离之间关系的可视化*'
- en: '***Projectile Motion***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***抛体运动***'
- en: Now, let’s graph something you’ll be familiar with from everyday life. If you
    throw a ball across a field, it follows a trajectory like the one shown in [Figure
    2-13](ch02.html#ch2fig13).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制一个你日常生活中熟悉的图形。如果你把球扔过一个田野，它会沿着类似于[图 2-13](ch02.html#ch2fig13)中所示的轨迹运动。
- en: '![image](images/f02-13.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-13.jpg)'
- en: '*Figure 2-13: Motion of a ball that’s thrown at point* A*—at an angle (*θ*)
    with a velocity (*U*)—and that hits the ground at point* B'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-13：从点* A*以一定角度（*θ*）和初速度（*U*）投掷的球体运动，最终在点* B*落地*'
- en: In the figure, the ball is thrown from point *A* and lands at point *B*. This
    type of motion is referred to as *projectile* motion. Our aim here is to use the
    equations of projectile motion to graph the trajectory of a body, showing the
    position of the ball starting from the point it’s thrown until it hits the ground
    again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，球体从点*A*被投掷，最终落在点*B*。这种运动称为*抛体*运动。我们的目标是利用抛体运动的方程，绘制一个物体的轨迹图，展示从球体投掷的起点到它再次落地的整个过程。
- en: 'When you throw the ball, it has an initial velocity and the direction of that
    velocity creates a certain angle with the ground. Let’s call the initial velocity
    *u* and the angle that it makes with the ground *θ* (theta), as shown in [Figure
    2-13](ch02.html#ch2fig13). The ball has two velocity components: one along the
    *x* direction, calculated by *u[x]* = *u* cos*θ*, and the other along the *y*
    direction, where *u[y]* = *u* sin*θ*.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你投掷球体时，它具有一个初速度，并且该速度的方向与地面之间形成一定的角度。我们将初速度称为*u*，与地面形成的角度称为*θ*（theta），如[图 2-13](ch02.html#ch2fig13)所示。球体具有两个速度分量：一个沿着*x*方向，由*u[x]*
    = *u* cos*θ*计算，另一个沿着*y*方向，其中*u[y]* = *u* sin*θ*。
- en: 'As the ball moves, its velocity changes, and we will represent that changed
    velocity using *v*: the horizontal component is *v[x]* and the vertical component
    is *v[y]*. For simplicity, assume the horizontal component (*v[x]*) doesn’t change
    during the motion of the body, whereas the vertical component (*v[y]*) decreases
    because of the force of gravity according to the equation *v[y]* = *u[y] – gt*.
    In this equation, *g* is the gravitational acceleration and *t* is the time at
    which the velocity is measured. Because *u[y]* = *u* sin*θ*, we can substitute
    to get'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 随着球的运动，速度发生变化，我们将用*v*来表示这种变化的速度：水平分量是*v[x]*，竖直分量是*v[y]*。为简化起见，假设水平分量（*v[x]*）在物体运动过程中保持不变，而竖直分量（*v[y]*）因重力作用而减小，按照方程*v[y]*
    = *u[y] – gt*来表示。在这个方程中，*g*是重力加速度，*t*是测量速度的时间。因为*u[y]* = *u* sin*θ*，我们可以代入得到
- en: '*v[y]* = *u* sin*θ* – *gt*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*v[y]* = *u* sin*θ* – *gt*。'
- en: Because the horizontal component of the velocity remains constant, the horizontal
    distance traveled (*S[x]*) is given by *S[x]* = *u*(cos*θ*)*t*. The vertical component
    of the velocity changes, though, and the vertical distance traveled is given by
    the formula
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于水平速度分量保持不变，水平位移（*S[x]*）由公式*S[x]* = *u*(cos*θ*)*t*给出。不过，竖直分量的速度发生变化，竖直位移由下列公式给出：
- en: '![image](images/e0049-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0049-01.jpg)'
- en: In other words, *S[x]* and *S[y]* give us the *x*- and *y*-coordinates of the
    ball at any given point in time during its flight. We’ll use these equations when
    we write a program to draw the trajectory. As we use these equations, time (*t*)
    will be expressed in seconds, the velocity will be expressed in m/s, the angle
    of projection (*θ*) will be expressed in degrees, and the gravitational acceleration
    (*g*) will be expressed in m/s².
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*S[x]* 和 *S[y]* 给出了球在飞行过程中任意时刻的 *x* 和 *y* 坐标。我们将在编写程序绘制轨迹时使用这些方程。使用这些方程时，时间（*t*）以秒为单位，速度以米每秒（m/s）为单位，投射角度（*θ*）以度为单位，重力加速度（*g*）以米每秒平方（m/s²）为单位。
- en: Before we write our program, however, we’ll need to find out how long the ball
    will be in flight before it hits the ground so that we know when our program should
    stop plotting the trajectory of the ball. To do so, we’ll first find how long
    the ball takes to reach its highest point. The ball reaches its highest point
    when the vertical component of the velocity (*v[y]*) is 0, which is when *v[y]*
    = *u* sin *θ* – *gt* = 0\. So we’re looking for the value *t* using the formula
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编写程序之前，我们需要先计算出球体飞行多长时间才会撞击地面，以便知道程序何时停止绘制球的轨迹。为此，我们首先需要找出球体达到最高点所需的时间。当竖直速度分量（*v[y]*）为0时，球体达到最高点，即*v[y]*
    = *u* sin *θ* – *gt* = 0。因此，我们要利用以下公式求解时间*t*：
- en: '![image](images/e0049-02.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0049-02.jpg)'
- en: We’ll call this time `t_peak`. After it reaches its highest point, the ball
    will hit the ground after being airborne for another `t_peak` seconds, so the
    total time of flight (`t_flight`) of the ball is
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个时间称为`t_peak`。当球达到最高点后，它将在空中再停留`t_peak`秒，然后撞击地面，因此球的总飞行时间（`t_flight`）为
- en: '![image](images/e0050-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0050-01.jpg)'
- en: 'Let’s take a ball that’s thrown with an initial velocity (*u*) of 5 m/s at
    an angle (*θ*) of 45 degrees. To calculate the total time of flight, we substitute
    *u* = 5, *θ* = 45, and *g* = 9.8 into the equation we saw above:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们投掷一个初速度（*u*）为 5 m/s，投射角度（*θ*）为 45 度的球体。为了计算总飞行时间，我们将 *u* = 5，*θ* = 45，*g*
    = 9.8 代入我们上面看到的方程中：
- en: '![image](images/e0050-02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0050-02.jpg)'
- en: In this case, the time of flight for the ball turns out to be 0.72154 seconds
    (rounded to five decimal places). The ball will be in air for this period of time,
    so to draw the trajectory, we’ll calculate its *x*- and *y*-coordinates at regular
    intervals during this time period. How often should we calculate the coordinates?
    Ideally, as frequently as possible. In this chapter, we’ll calculate the coordinates
    every 0.001 seconds.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，球体的飞行时间为 0.72154 秒（四舍五入到小数点后五位）。球体将在空中停留这段时间，因此为了绘制轨迹，我们将在这段时间内定期计算其
    *x* 和 *y* 坐标。我们应该多频繁地计算坐标呢？理想情况下，越频繁越好。在本章中，我们将在每 0.001 秒计算一次坐标。
- en: '**Generating Equally Spaced Floating Point Numbers**'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成等间隔的浮点数**'
- en: 'We’ve used the `range()` function to generate equally spaced integers— that
    is, if we wanted a list of integers between 1 and 10 with each integer separated
    by 1, we would use range(1, 10). If we wanted a different step value, we could
    specify that to the range function as the third argument. Unfortunately, there’s
    no such built-in function for floating point numbers. So, for example, there’s
    no function that would allow us to create a list of the numbers from 0 to 0.72
    with two consecutive numbers separated by 0.001\. We can use a `while` loop as
    follows to create our own function for this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`range()`函数来生成等间隔的整数——也就是说，如果我们想要一个从1到10的整数列表，每个整数之间相隔1，我们将使用range(1, 10)。如果我们想要不同的步长值，可以将其作为第三个参数传递给range函数。不幸的是，对于浮点数并没有类似的内建函数。例如，并没有一个函数可以帮助我们创建从0到0.72的数字列表，其中每两个连续数字之间相隔0.001。我们可以通过如下的`while`循环来创建自己的函数：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ve defined a function `frange()` (“floating point” range) that receives
    three parameters: `start` and `final` refer to the starting and the final points
    of the range of numbers, and `increment` refers to the difference between two
    consecutive numbers. We initialize a `while` loop at ➊, which continues execution
    as long as the number referred to by `start` is less than the value for `final`.
    We store the number pointed to by `start` in the list `numbers` ➋ and then add
    the value we entered as an `increment` during every iteration of the loop. Finally,
    we return the list `numbers`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数`frange()`（“浮点数”范围），它接收三个参数：`start`和`final`分别表示数值范围的起始点和终点，`increment`表示两个连续数字之间的差值。在➊处，我们初始化了一个`while`循环，只要`start`所指的数字小于`final`，循环就会继续执行。在➋处，我们将`start`所指的数字存储到列表`numbers`中，然后在每次循环迭代中将我们输入的`increment`值加到`start`上。最后，我们返回列表`numbers`。
- en: We’ll use this function to generate equally spaced time instants in the trajectory-drawing
    program described next.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的轨迹绘制程序中使用这个函数来生成等间隔的时间点。
- en: '**Drawing the Trajectory**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制轨迹**'
- en: 'The following program draws the trajectory of a ball thrown with a certain
    velocity and angle—both of which are supplied as input to the program:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序绘制了一个以特定速度和角度投掷的球的轨迹——这两个值作为输入传递给程序：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this program, we use the functions `radians()`, `cos()`, and `sin()` defined
    in the standard library’s `math` module, so we import that module at the beginning.
    The `draw_trajectory()` function accepts two arguments, `u` and `theta`, corresponding
    to the velocity and the angle at which the ball is thrown. The `math` module’s
    sine and the cosine functions expect the angle to be supplied in radians, so at
    ➊, we convert the angle (`theta`) from degrees to radians using the `math.radians()`
    function. Next, we create a label (`g`) to refer to the value of acceleration
    due to gravity, 9.8 m/s². At ➋, we calculate the time of flight and then call
    the `frange()` function with the values for `start`, `final`, and `increment`
    set to 0, `t_flight`, and 0.001, respectively. We then calculate the *x*- and
    *y*-coordinates for the trajectory at each of the time instants and store them
    in two separate lists, `x` and `y` ➌. To calculate these coordinates, we use the
    formulas for the distances *S[x]* and *S[y]* that we discussed earlier.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了标准库`math`模块中的`radians()`、`cos()`和`sin()`函数，所以我们在一开始就导入了这个模块。`draw_trajectory()`函数接受两个参数，`u`和`theta`，分别对应投掷球的速度和角度。`math`模块中的正弦和余弦函数要求输入角度为弧度制，因此在➊处，我们使用`math.radians()`函数将角度（`theta`）从度数转换为弧度。接着，我们创建了一个标签（`g`）来表示重力加速度的值，即9.8米/秒²。在➋处，我们计算了飞行时间，并调用了`frange()`函数，传入了`start`、`final`和`increment`的值，分别为0、`t_flight`和0.001。然后，我们在每个时间点计算*
    x *和* y *坐标，并将它们分别存储在两个列表中，`x`和`y` ➌。为了计算这些坐标，我们使用了之前讨论过的* S[x]*和* S[y]*的距离公式。
- en: 'Finally, we call the `draw_graph()` function with the *x*- and *y*-coordinates
    to draw the trajectory. Note that the `draw_graph()` function doesn’t call the
    `show()` function (we’ll see why in the next program). We use a `try...except`
    block ➍ to report an error message in case the user enters an invalid input. Valid
    input for this program is any integer or floating point number. When you run the
    program, it asks for these values as input and then draws the trajectory (see
    [Figure 2-14](ch02.html#ch2fig14)):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`draw_graph()`函数并传入*x*和*y*坐标来绘制轨迹。请注意，`draw_graph()`函数没有调用`show()`函数（我们将在下一个程序中看到原因）。我们使用`try...except`块➍来报告错误信息，以防用户输入无效数据。此程序的有效输入为任何整数或浮动点数。当你运行程序时，它会要求输入这些值，然后绘制轨迹（见[图2-14](ch02.html#ch2fig14)）：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![image](images/f02-14.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-14.jpg)'
- en: '*Figure 2-14: The trajectory of a ball when thrown with a velocity of 25 m/s
    at an angle of 60 degrees*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-14：以25 m/s的速度，角度为60度时，投掷球体的轨迹*'
- en: '**Comparing the Trajectory at Different Initial Velocities**'
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比较不同初速度下的轨迹**'
- en: 'The previous program allows you to perform interesting experiments. For example,
    what will the trajectory look like for three balls thrown at different velocities
    but with the same initial angle? To graph three trajectories at once, we can replace
    the `main` code block from our previous program with the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序让你能够进行有趣的实验。例如，对于三个以不同速度投掷但初始角度相同的球体，轨迹会是什么样的？为了同时绘制三条轨迹，我们可以用以下代码替换之前程序中的`main`代码块：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, instead of asking the program’s user to enter the velocity and the angle
    of projection, we create a list (`u_list`) with the velocities 20, 40, and 60
    at ➊ and set the angle of projection as 45 degrees (using the label `theta`).
    We then call the `draw_trajectory()` function with each of the three values in
    `u_list` using the same value for `theta`, which calculates the list of *x*- and
    *y*-coordinates and calls the `draw_graph()` function. When we call the `show()`
    function, all three plots are displayed on the same graph. Because we now have
    a graph with multiple plots, we add a legend to the graph at ➋ before calling
    `show()` to display the velocity for each line. When you run the above program,
    you’ll see the graph shown in [Figure 2-15](ch02.html#ch2fig15).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不再要求程序的用户输入速度和投射角度，而是在➊处创建一个包含20、40和60的速度列表(`u_list`)，并将投射角度设置为45度（使用标签`theta`）。然后，我们使用`u_list`中的每个值调用`draw_trajectory()`函数，并使用相同的`theta`值，计算*x*和*y*坐标列表并调用`draw_graph()`函数。当我们调用`show()`函数时，所有三条轨迹将在同一图表上显示。由于现在我们有一个包含多个图表的图表，在➋处我们为图表添加一个图例，然后调用`show()`以显示每条线的速度。当你运行上述程序时，你将看到[图2-15](ch02.html#ch2fig15)所示的图表。
- en: '![image](images/f02-15.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-15.jpg)'
- en: '*Figure 2-15: The trajectory of a ball thrown at a 60-degree angle, with a
    velocity of 20, 40, and 60 m/s*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-15：以60度角、速度分别为20、40和60 m/s的投掷球体轨迹*'
- en: '**What You Learned**'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned the basics of creating graphs with matplotlib.
    You saw how to plot a single set of values, how to create multiple plots on the
    same graph, and how to label various parts of a graph to make it more informative.
    You used graphs to analyze the temperature variation of a city, study Newton’s
    law of universal gravitation, and study the projectile motion of a body. In the
    next chapter, you’ll use Python to start exploring statistics, and you’ll see
    how drawing a graph can help make the relationships among sets of numbers easier
    to understand.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用matplotlib创建图表的基础知识。你了解了如何绘制一组值的图表，如何在同一图表上创建多个图表，以及如何标注图表的不同部分使其更加信息化。你使用图表分析了一个城市的温度变化，研究了牛顿的万有引力定律，并研究了物体的抛体运动。在下一章中，你将使用Python开始探索统计学，并了解如何通过绘制图表帮助更容易理解一组数字之间的关系。
- en: '**Programming Challenges**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Here are a few challenges that build on what you’ve learned in this chapter.
    You can find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些挑战，基于你在本章中所学的内容。你可以在 *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*
    找到示例解决方案。
- en: '***#1: How Does the Temperature Vary During the Day?***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1：白天气温是如何变化的？***'
- en: If you enter a search term like “New York weather” in Google’s search engine,
    you’ll see, among other things, a graph showing the temperature at different times
    of the present day. Your task here is to re-create such a graph.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在谷歌搜索引擎中输入类似“纽约天气”这样的搜索词，你会看到其中包括一个图表，展示当天不同时间的温度。你的任务是重新创建这样一个图表。
- en: Using a city of your choice, find the temperature at different points of the
    day. Use the data to create two lists in your program and to create a graph with
    the time of day on the *x*-axis and the corresponding temperature on the *y*-axis.
    The graph should tell you how the temperature varies with the time of day. Try
    a different city and see how the two cities compare by plotting both lines on
    the same graph.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你喜欢的城市，找到不同时间点的温度数据。使用这些数据在你的程序中创建两个列表，并绘制一个图表，图表的横坐标是一天中的时间，纵坐标是对应的温度。这个图表应该展示温度如何随一天中的时间变化。尝试使用另一个城市，并通过将两座城市的曲线绘制在同一张图表上，看看它们的比较结果。
- en: The time of day may be indicated by strings such as `'10:11 AM'` or `'09:21
    PM'`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一天中的时间可以通过类似`'10:11 AM'`或`'09:21 PM'`这样的字符串表示。
- en: '***#2: Exploring a Quadratic Function Visually***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 直观展示二次函数***'
- en: 'In [Chapter 1](ch01.html#ch01), you learned how to find the roots of a quadratic
    equation, such as *x*² + 2*x* + 1 = 0\. We can turn this equation into a function
    by writing it as *y* = *x*² + 2*x* + 1\. For any value of *x*, the quadratic function
    produces *some* value for *y*. For example, when *x* = 1, *y* = 4\. Here’s a program
    that calculates the value of *y* for six different values of *x*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)中，你学会了如何求解二次方程的根，比如*x*² + 2*x* + 1 = 0。我们可以通过将其写为*y* =
    *x*² + 2*x* + 1，将此方程转化为一个函数。对于任何值的*x*，二次函数都会产生一个对应的*y*值。例如，当*x* = 1时，*y* = 4。以下是一个计算六个不同*x*值对应*y*值的程序：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At ➊, we create a list with six different values for `x`. The `for` loop starting
    at ➋ calculates the value of the function above for each of these values and uses
    the label `y` to refer to the list of results. Next, we print the value of `x`
    and the corresponding value of `y`. When you run the program, you should see the
    following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们创建一个包含六个不同`x`值的列表。➋处开始的`for`循环为这些值计算上述函数的值，并使用标签`y`表示结果列表。接下来，我们打印出`x`值和对应的`y`值。当你运行程序时，你应该看到如下输出：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that the first line of the output is a root of the quadratic equation
    because it’s a value for `x` that makes the function equal to 0.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出的第一行是二次方程的一个根，因为它是一个使得函数值为0的`x`值。
- en: Your programming challenge is to enhance this program to create a graph of the
    function. Try using at least 10 values for `x` instead of the 6 above. Calculate
    the corresponding `y` values using the function and then create a graph using
    these two sets of values.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编程挑战是增强这个程序，创建该函数的图表。尝试使用至少10个`x`值，而不是上面提到的6个。使用该函数计算对应的`y`值，然后使用这两个值集创建图表。
- en: Once you’ve created the graph, spend some time analyzing how the value of *y*
    varies with respect to *x*. Is the variation linear or nonlinear?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了图表，花一些时间分析*y*值是如何随*x*值变化的。变化是线性的吗？还是非线性？
- en: '***#3: Enhanced Projectile Trajectory Comparison Program***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 增强型抛射轨迹比较程序***'
- en: Your challenge here is to enhance the trajectory comparison program in a few
    ways. First, your program should print the time of flight, maximum horizontal
    distance, and maximum vertical distance traveled for each of the velocity and
    angle of projection combinations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里的挑战是以几种方式增强轨迹比较程序。首先，程序应打印出每种速度和抛射角度组合的飞行时间、最大水平距离和最大垂直距离。
- en: 'The other enhancement is to make the program work with any number of initial
    velocity and angle of projection values, supplied by the user. For example, here’s
    how the program should ask the user for the inputs:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个增强功能是让程序能够接受任意数量的初速度和抛射角度值，由用户提供。例如，程序应该这样询问用户输入：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Your program should also ensure that erroneous input is properly handled using
    a `try...except` block, just as in the original program.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序还应确保通过使用`try...except`块来正确处理错误输入，就像原始程序一样。
- en: '***#4: Visualizing Your Expenses***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 可视化你的支出***'
- en: I always find myself asking at the end of the month, “Where did all that money
    go?” I’m sure this isn’t a problem I alone face.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是在月末问自己：“那笔钱都去哪了？”我相信这不仅是我个人的困扰。
- en: For this challenge, you’ll write a program that creates a bar chart for easy
    comparison of weekly expenditures. The program should first ask for the number
    of categories for the expenditures and the weekly total expenditure in each category,
    and then it should create the bar chart showing these expenditures.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，你将编写一个程序，用于轻松比较每周的支出。程序首先会询问支出的类别数量以及每个类别的每周总支出，然后它将创建显示这些支出的柱状图。
- en: 'Here’s a sample run of how the program should work:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序运行的示例：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Figure 2-16](ch02.html#ch2fig16) shows the bar chart that will be created
    to compare the expenditures. If you save the bar chart for every week, at the
    end of the month, you’ll be able to see how the expenditures varied between the
    weeks for different categories.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-16](ch02.html#ch2fig16)展示了将要创建的柱状图，用于比较支出。如果你每周都保存柱状图，到月底时，你就能看到不同类别的支出在各周之间的变化。'
- en: '![image](images/f02-16.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-16.jpg)'
- en: '*Figure 2-16: A bar chart showing the expenditures per category during the
    week*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-16：显示一周内各类别支出的柱状图*'
- en: We haven’t discussed creating a bar chart using matplotlib, so let’s try an
    example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论如何使用 matplotlib 创建柱状图，所以让我们尝试一个示例。
- en: A bar chart can be created using matplotlib’s `barh()` function, which is also
    defined in the `pyplot` module. [Figure 2-17](ch02.html#ch2fig17) shows a bar
    chart that illustrates the number of steps I walked during the past week. The
    days of the week—Sunday, Monday, Tuesday, and so forth—are referred to as the
    *labels*. Each horizontal bar starts from the *y*-axis, and we have to specify
    the *y*-coordinate of the *center* of this position for each of the bars. The
    length of each bar corresponds to the number of steps specified.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 matplotlib 的 `barh()` 函数来创建柱状图，该函数也定义在 `pyplot` 模块中。[图 2-17](ch02.html#ch2fig17)显示了一张柱状图，展示了我过去一周走的步数。星期天、星期一、星期二等被称为*标签*。每个水平条形图都从
    *y* 轴开始，我们需要为每个条形图指定该位置的 *y* 坐标的 *中心*。每个条形图的长度与步数相对应。
- en: '![image](images/f02-17.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-17.jpg)'
- en: '*Figure 2-17: A bar chart showing the number of steps walked during a week*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-17：显示一周内步数的柱状图*'
- en: 'The following program creates the bar chart:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将创建柱状图：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `create_bar_chart()` function accepts two parameters—`data`, which is a
    list of numbers we want to represent using the bars and labels, and the corresponding
    `labels` list. The center of each bar has to be specified, and I’ve arbitrarily
    chosen the centers as 1, 2, 3, 4, and so on using the help of the `range()` function
    at ➊.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_bar_chart()` 函数接受两个参数——`data`，这是一个我们想用条形图表示的数字列表，和相应的 `labels` 列表。每个条形图的中心必须指定，我在
    ➊ 处使用 `range()` 函数随意选择了中心点，分别为 1、2、3、4 等等。'
- en: We then call the `barh()` function, passing `positions` and `data` as the first
    two arguments and then the keyword argument, `align='center'`, at ➋. The keyword
    argument specifies that the bars are centered at the positions on the *y*-axis
    specified by the list. We then set the labels for each bar, the axis labels, and
    the title using the `yticks()` function. We also call the `grid()` function to
    turn on the grid, which may be useful for a visual estimation of the number of
    steps. Finally, we call the `show()` function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `barh()` 函数，传入 `positions` 和 `data` 作为前两个参数，然后在 ➋ 处传入关键字参数 `align='center'`。该关键字参数指定了条形图在
    *y* 轴上的位置居中。接着，我们使用 `yticks()` 函数设置每个条形图的标签、坐标轴标签和标题。我们还调用 `grid()` 函数来打开网格，这对于大致估算步数可能有帮助。最后，我们调用
    `show()` 函数。
- en: '***#5: Exploring the Relationship Between the Fibonacci Sequence and the Golden
    Ratio***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5: 探索斐波那契数列与黄金比例之间的关系***'
- en: The Fibonacci sequence (1, 1, 2, 3, 5, ...) is the series of numbers where the
    *i*th number in the series is the sum of the two previous numbers—that is, the
    numbers in the positions (*i* – 2) and (*i* – 1). The successive numbers in this
    series display an interesting relationship. As you increase the number of terms
    in the series, the ratios of consecutive pairs of numbers are nearly equal to
    each other. This value approaches a special number referred to as the *golden
    ratio*. Numerically, the golden ratio is the number 1.618033988 ..., and it’s
    been the subject of extensive study in music, architecture, and nature. For this
    challenge, write a program that will plot on a graph the ratio between consecutive
    Fibonacci numbers for, say, 100 numbers, which will demonstrate that the values
    approach the golden ratio.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列（1, 1, 2, 3, 5, ...）是一个数列，其中第 *i* 个数是前两个数的和——即位置在 (*i* – 2) 和 (*i* – 1)
    的数。这个数列中的连续数字展示了一个有趣的关系。当你增加数列中的项数时，连续数字对的比率几乎相等。这个值趋近于一个特殊的数字，称为 *黄金比*。从数字上看，黄金比是
    1.618033988 ...，它已经成为音乐、建筑和自然界广泛研究的对象。对于这个挑战，编写一个程序，在图表上绘制前 100 个斐波那契数之间的比率，这将展示这些值趋近于黄金比。
- en: 'You may find the following function, which returns a list of the first *n*
    Fibonacci numbers, useful in implementing your solution:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现以下函数有用，它返回前 *n* 个斐波那契数的列表，这对实现你的解决方案有帮助：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output of your solution should be a graph, as shown in [Figure 2-18](ch02.html#ch2fig18).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你解决方案的输出应该是一个图表，如[图 2-18](ch02.html#ch2fig18)所示。
- en: '![image](images/f02-18.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f02-18.jpg)'
- en: '*Figure 2-18: The ratio between the consecutive Fibonacci numbers approaches
    the golden ratio.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-18：连续斐波那契数列之间的比率接近黄金比。*'
