<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_63"/><strong><span class="big">4</span><br/>DECODING AMERICAN CIVIL WAR CIPHERS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Cryptography is the science of secure communication through the use of <em>codes</em> and <em>ciphers</em>. A code replaces whole words with other words; a cipher scrambles or replaces the letters in words (so technically, Morse code is really Morse cipher). One goal of cryptography is to use a <em>key</em> to both <em>encrypt</em> readable <em>plaintext</em> into unreadable <em>ciphertext</em> and then <em>decrypt</em> it back to plaintext. The goal of <em>cryptanalysis</em> is to decode ciphers and codes without knowing their key or encryption algorithm.</p>
<p class="indent">In this chapter, we’ll investigate two ciphers used in the American Civil War: the route cipher, used by the North, and the rail fence cipher, used by both sides. We’ll also look at what made one so successful and how we can use lessons learned from its application to better write programs for inexperienced users and those unfamiliar with your Python code.</p>
<h3 class="h3a" id="lev84"><span epub:type="pagebreak" id="page_64"/><strong>Project #8: The Route Cipher</strong></h3>
<p class="noindent">In the American Civil War, the Union had just about every advantage over the Confederacy, including the field of cryptography. The Union had better codes, better ciphers, and better-trained personnel. But perhaps its biggest advantage was in leadership and organization.</p>
<p class="indent">The head of the US Military Telegraph Department was Anson Stager (<a href="ch04.xhtml#ch04fig1">Figure 4-1</a>). As the cofounder of Western Union, Stager knew from experience that telegraph operators made fewer mistakes when sending whole words, as opposed to the strings of random letters and numbers common to most ciphertext. He also knew that military dispatches only needed to stay secret long enough for orders to be carried out. His secure solution was a hybrid cryptosystem called the <em>route transposition cipher</em>, a combination of transposed real words and code words that became one of the most successful military ciphers of all time.</p>
<div class="image"><a id="ch04fig1"/><img src="../images/f0064-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-1: General Anson Stager, US Telegraph Corps, 1865</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_65"/>Transposition ciphers <em>scramble</em> the arrangement of letters or words, unlike substitution ciphers, which <em>replace</em> the letters in the plaintext with different characters or symbols. <a href="ch04.xhtml#ch04fig2">Figure 4-2</a> shows an example of a route transposition cipher. The message is written left to right over a number of predetermined columns and rows, important plaintext words are replaced by code words, and the last row is filled with dummy placeholder words. The reader determines the order of the rearranged words by traversing up and down these columns, as shown. The starting word is <em>REST</em>, and then the encryption route is shown with arrows.</p>
<div class="image"><a id="ch04fig2"/><img src="../images/f0065-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-2: A route cipher using actual Union code words</em></p>
<p class="indent">To fully decode this message, you need to know both the starting point and route used to traverse the message and create the final ciphertext <em>and</em> the meaning of the code words.</p>
<p class="indent">In the early 20th century, the distinguished military cryptanalyst William Friedman disparaged Stager’s route cipher. He considered it too unsophisticated and found it highly improbable that the Confederates never cracked it. But the fact remains that hundreds of thousands of route ciphers sent during the war were apparently never decoded, and not from lack of trying. In an early example of crowdsourcing, the Confederates <span epub:type="pagebreak" id="page_66"/>published the coded messages in newspapers, hoping for some help with the decryption, but to no avail. While some historians speculate that this cipher was broken at times, Stager’s design teaches several important lessons:</p>
<p class="hang"><strong>Design for human error.</strong> Military ciphers have to be simple, as hundreds might be sent in a day. The real words used in the route cipher made it much less likely to be garbled by telegraph operators. Stager knew his customer and designed for them. He recognized the limitations of his workforce and tailored his product accordingly. The Confederates, by contrast, had great difficulty deciphering their own complex messages, sometimes giving up and riding around enemy lines to talk face-to-face!</p>
<p class="hang"><strong>Innovation trumps invention.</strong> Sometimes you don’t need to invent something new; you just need to rediscover something old. The short word-transposition ciphers suitable for telegraph transmission were too weak to use on their own, but combined with code names and disruptive dummy words, they confounded the Confederates.</p>
<p class="hang"><strong>Share learning.</strong> Because everyone in the Telegraph Corps used the same methodology, it was easy to build on existing techniques and share lessons learned. This allowed the route cipher to evolve over time with the introduction of slang and intentional misspellings, as well as a growing number of code words for places, people, and dates.</p>
<p class="indentt">Stager’s practical cipher may not have pleased later “purists,” but it was the perfect design for the time. The concepts behind it are timeless and easily transferable to modern-day applications.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">In Harry Turtledove’s award-winning 1992 novel <em>Guns of the South</em>, time travelers provide Confederate armies with modern weaponry, changing the course of history. Instead of AK-47s, let’s pretend you’ve traveled back to 1864 with your laptop, a few extra batteries, and Python to design an algorithm that will decrypt a route cipher based on an assumed encryption matrix and path. In the spirit of Stager, you’ll write a user-friendly program that will reduce human error.</p>
</div>
<h4 class="h4" id="lev85"><strong><em>The Strategy</em></strong></h4>
<p class="noindent">When it comes to solving ciphers, it’s a lot easier if you know what type you’re dealing with. In this case, you know it’s a transposition cipher, because it’s composed of real words that are jumbled. You also know there are code words and null words present. Your job is to figure out ways to decrypt the <em>transposition</em> part of the route cipher and let someone else worry about code words while you go have a well-deserved mint julep.</p>
<h5 class="h5" id="lev86"><span epub:type="pagebreak" id="page_67"/><strong>Creating a Control Message</strong></h5>
<p class="noindent">To understand how to do this, create your own message and route cipher. Call this your <em>control message</em>:</p>
<ul>
<li class="noindent">Number of columns = 4</li>
<li class="noindent">Number of rows = 5</li>
<li class="noindent">Start position = Bottom left</li>
<li class="noindent">Route = Alternating up and down columns</li>
<li class="noindent">Plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</li>
<li class="noindent">Ciphertext = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19</li>
<li class="noindent">Key = –1 2 –3 4</li>
</ul>
<p class="indent">Using a numeric progression for the plaintext allows you to instantly tell whether you’ve gotten all or part of the decryption correct, at any place within the message.</p>
<p class="indent">The transposition matrix is shown in <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>. The gray arrows indicate the encryption route.</p>
<div class="image"><a id="ch04fig3"/><img src="../images/f0067-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-3: The transposition matrix for the control message with the route cipher path and resulting ciphertext</em></p>
<p class="indent">The key keeps track of both the <em>order</em> and <em>direction</em> of the route through the columns. The route doesn’t have to move through the columns in order. For instance, it can move down the first column, up the third, down the fourth, and finally up the second. Negative numbers mean you start at the bottom and read up a column; positive numbers mean the reverse. For the control message, the final key used in the program will be a list: [–1, 2, –3, 4]. This list will instruct the program to start reading up from the bottom of column 1, move to the top of column 2 and read down, move to the bottom of column 3 and read up, and move to the top of column 4 and read down.</p>
<p class="indent">Note that you shouldn’t use 0 in keys because the users, being human, prefer to start counting at 1. Of course, Python prefers to start counting at 0, so you’ll need to subtract 1 from the key values behind the scenes. Everybody wins!</p>
<p class="indent"><span epub:type="pagebreak" id="page_68"/>Later, in “<a href="ch04.xhtml#lev111">Route Transposition Cipher: Brute-Force Attack</a>” on <a href="ch04.xhtml#page_88">page 88</a>, you can use this compact key structure to brute-force your way through a route cipher, automatically trying hundreds of keys until the plaintext is restored.</p>
<h5 class="h5" id="lev87"><strong>Designing, Populating, and Depopulating the Matrix</strong></h5>
<p class="noindent">You’ll input the ciphertext as a continuous string. For your program to unravel the route through this string, you’ll first need to build and populate a translation matrix. The ciphertext string is just the columns in the transposition matrix in <a href="ch04.xhtml#ch04fig3">Figure 4-3</a> laid end to end, in the order they were read. And as there are five rows in the transposition matrix, every group of five elements in the ciphertext represents a separate column. You can represent this matrix with a list of lists:</p>
<pre>&gt;&gt;&gt; <span class="codestrong1">list_of_lists = [['16', '12', '8', '4', '0'], ['1', '5', '9', '13', '17'],<br/>['18', '14', '10', '6', '2'], ['3', '7', '11', '15', '19']]</span></pre>
<p class="indent">The items in this new list now represent lists—with each list representing a column—and the five elements in each list represent the rows that comprise that column. This is a little hard to see, so let’s print each of these nested lists on a separate line:</p>
<pre>&gt;&gt;&gt; <span class="codestrong1">for nested_list in list_of_lists</span><br/><span class="codestrong1">        print(nested_list)</span><br/>[16, 12, 8, 4, 0]<br/>[1, 5, 9, 13, 17]<br/>[18, 14, 10, 6, 2]<br/>[3, 7, 11, 15, 19]</pre>
<p class="indent">If you read each list left to right, starting at the top, you follow the transposition route, which was up and down alternate columns (see <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>). From Python’s point of view, the first column read is <code>list-of-lists[0]</code>, and the starting point is <code>list-of-lists[0][0]</code>.</p>
<p class="indent">Now, normalize the route by reading all columns in the same direction as the starting column (up). This requires reversing the order of elements in every other list, as shown in bold here:</p>
<pre>[16, 12, 8, 4, 0]<br/><span class="codestrong1">[17, 13, 9, 5, 1]</span><br/>[18, 14, 10, 6, 2]<br/><span class="codestrong1">[19, 15, 11, 7, 3]</span></pre>
<p class="indent">A pattern emerges. If you start at the upper right and read down each column, ending at the lower left, the numbers are in numerical order; you’ve restored the plaintext!</p>
<p class="indent">To replicate this, your script can loop through every nested list, removing the last item in that list and adding the item to a new string, until the <span epub:type="pagebreak" id="page_69"/>translation matrix has been emptied. The script will know from the key which nested lists it needs to reverse and the order in which to depopulate the matrix. The output will be a string of the restored plaintext:</p>
<pre>'0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19'</pre>
<p class="indent">You should now have a very general view of the strategy. Let’s get more descriptive and write the pseudocode next.</p>
<h4 class="h4" id="lev88"><strong><em>The Pseudocode</em></strong></h4>
<p class="noindent">The script can be broken up into three major parts: user input, translation matrix population, and decryption to plaintext. You should be able to see these parts in the following pseudocode:</p>
<pre>Load the ciphertext string.<br/>Convert ciphertext into a cipher<span class="codeitalic1">list</span> to split out individual words.<br/>Get input for the number of columns and rows.<br/>Get input for the key.<br/>Convert key into a list to split out individual numbers.<br/>Create a new list for the translation matrix.<br/>For every number in the key:<br/>    Create a new list and append every <span class="codeitalic1">n</span> items (<span class="codeitalic1">n</span> = # of rows) from the cipherlist.<br/>    Use the sign of key number to decide whether to read the row forward or backward.<br/>    Using the chosen direction, add the new list to the matrix. The index of each<br/>    new list is based on the column number used in the key.<br/>Create a new string to hold translation results.<br/>For range of rows:<br/>    For the nested list in translation matrix:<br/>          Remove the last word in nested list<br/>          Add the word to the translation string.<br/>Print the translation string.</pre>
<p class="indent">Everything before the first loop is essentially just collecting and reformatting the cipher data. The first loop is responsible for building and populating the matrix, and the second loop creates a translation string from that matrix. Finally, the translation string is printed.</p>
<h4 class="h4" id="lev89"><strong><em>The Route Cipher Decryption Code</em></strong></h4>
<p class="noindent"><a href="ch04.xhtml#ch04list1">Listing 4-1</a> takes a message encrypted with the route cipher, the number of columns and rows in the transposition matrix, and a key and then displays the translated plaintext. It will decrypt all “common” route ciphers, where the route starts at the top or bottom of a column and continues up and/or down columns.</p>
<p class="indent">This is the prototype version; once you’re sure it’s working, you’ll package it for others to use. You can download this code at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<p class="margin"><em>route_cipher_decrypt_prototype.py</em></p>
<pre><span class="ent">➊</span> ciphertext = "16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19"<br/>
<br/>
   # split elements into words, not letters<br/>
<br/>
<span epub:type="pagebreak" id="page_70"/><span class="ent">➋</span> cipherlist = list(ciphertext.split())<br/>
<br/>
<span class="ent">➌</span> # initialize variables<br/>
   COLS = 4<br/>
   ROWS = 5<br/>
   key = '-1 2 -3 4'  # neg number means read UP column vs. DOWN<br/>
   translation_matrix = [None] * COLS<br/>
   plaintext = ''<br/>
   start = 0<br/>
   stop = ROWS<br/>
<br/>
   # turn key_int into list of integers:<br/>
<span class="ent">➍</span> key_int = [int(i) for i in key.split()]<br/>
<br/>
   # turn columns into items in list of lists:<br/>
<span class="ent">➎</span> for k in key_int:<br/>
    <span class="ent">➏</span> if k &lt; 0:  # reading bottom-to-top of column<br/>
           col_items = cipherlist[start:stop]<br/>
       elif k &gt; 0:  # reading top-to-bottom of columnn<br/>
           col_items = list((reversed(cipherlist[start:stop])))<br/>
       translation_matrix[abs(k) - 1] = col_items<br/>
       start += ROWS<br/>
       stop += ROWS<br/>
<br/>
   print("\nciphertext = {}".format(ciphertext))<br/>
   print("\ntranslation matrix =", *translation_matrix, sep="\n")<br/>
   print("\nkey length = {}".format(len(key_int)))<br/>
<br/>
   # loop through nested lists popping off last item to new list:<br/>
<span class="ent">➐</span> for i in range(ROWS):<br/>
       for col_items in translation_matrix:<br/>
        <span class="ent">➑</span> word = str(col_items.pop())<br/>
        <span class="ent">➒</span> plaintext += word + ' '<br/>
<br/>
   print("\nplaintext = {}".format(plaintext))</pre>
<p class="listing" id="ch04list1"><em>Listing 4-1: Code for</em> route_cipher_decrypt_prototype.py</p>
<p class="indent">Start by loading the ciphertext <span class="ent">➊</span> as a string. You want to deal with words, not letters, so split the string apart based on empty spaces using the <code>split()</code> string method to create a new list named <code>cipherlist</code> <span class="ent">➋</span>. The <code>split()</code> method is the inverse of the <code>join()</code> method, which you’ve seen before. You can split on any string; the method just defaults to runs of consecutive whitespace, deleting each whitespace before it moves to the next.</p>
<p class="indent">Now it’s time to input what you know about the cipher <span class="ent">➌</span>: the columns and rows, which form the matrix, and the key, which contains the route. Initialize the column and row numbers as constants. Then make an empty list named <code>translation_matrix</code> to hold the contents of each column as a (nested) list. Assign placeholders by multiplying the value <code>None</code> by the number of columns. You can use the indexes of these empty items to put columns back in their correct order for keys that are not in numerical order.</p>
<p class="indent"><span epub:type="pagebreak" id="page_71"/>An empty string named <code>plaintext</code> will hold the decrypted message. Next are some slicing parameters. Note that some of these are derived from the number of rows, which equates to the number of items in each column.</p>
<p class="indent">Now, convert the key variable, which is a string, into a list of integers using <em>list comprehension</em>—a shorthand way of performing operations on lists <span class="ent">➍</span>. You’ll use the numbers in the key as indexes later, so they need to be integers.</p>
<p class="indent">The next block of code is a <code>for</code> loop that populates the <code>translation_matrix</code>, which is just a list of lists <span class="ent">➎</span>. Since each column becomes a nested list and the length of the <code>key_int</code> list is equal to the number of columns, the range for the loop is the key, which also describes the route.</p>
<p class="indent">Inside the loop, use a conditional to check whether the key is positive or negative <span class="ent">➏</span>; if the key is positive, then the direction of the slice is reversed. Assign the slice to the correct position in <code>translation_matrix</code> based on the absolute key value and subtract 1 (since the keys don’t include 0, but the list indexes do). Finish the loop by advancing the slice endpoints by the number of rows and printing some useful information.</p>
<p class="indent">The final block <span class="ent">➐</span> loops through the number of rows—which is equivalent to the number of words in one of the nested lists—and through each nested list. The first two of these loops are shown in <a href="ch04.xhtml#ch04fig4">Figure 4-4</a>. As you stop in each nested list, you get to employ one of my favorite Python functions, the list <code>pop()</code> method <span class="ent">➑</span>. The <code>pop()</code> method removes and returns the last item from a list, unless a specific index is provided. It destroys the nested list, but you’re done with it anyway.</p>
<div class="image"><a id="ch04fig4"/><img src="../images/f0071-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-4: First and second loop through the nested lists, removing and appending each end item to the translation string</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_72"/>As soon as you pop off a word, concatenate it to the <code>plaintext</code> string and add a space <span class="ent">➒</span>. All that’s left to do is display the decrypted ciphertext. The output for the numeric test set looks like this:</p>
<pre>plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</pre>
<p class="indent">That looks like success!</p>
<h4 class="h4" id="lev90"><strong><em>Hacking the Route Cipher</em></strong></h4>
<p class="noindent">The preceding code assumes you know the route through the encryption matrix or have correctly guessed the key. If those assumptions aren’t true, your only recourse is to try every possible key and matrix arrangement. You’ll get a chance to automate the key selection process—for a given number of columns—in “<a href="ch04.xhtml#lev111">Route Transposition Cipher: Brute-Force Attack</a>” on <a href="ch04.xhtml#page_88">page 88</a>. But, as you’ll see, the Union route cipher is well fortified against brute-force attacks. You can crack it, but you’ll end up with so much data, you’ll feel like the dog that chased a car and caught it.</p>
<p class="indent">As messages get longer, the number of possible encryption paths in a transposition cipher becomes too large for a brute-force solution, even using modern computers. For example, if there are eight columns, and you allow the route to skip to any column, the number of ways to combine the columns is the factorial of eight: 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40,320. That’s 40,320 paths <em>before</em> you start choosing alternative routes through the columns. If the route can change direction up or down a column, the number of combinations increases to 10,321,920. And if you consider starting <em>anywhere</em> in a column—instead of at the very top or bottom—and allow <em>any</em> route through the matrix (such as spiraling), things will really start to get out of hand!</p>
<p class="indent">For this reason, even short transposition ciphers can have thousands to millions of possible paths. Even if the number of paths is manageable for a computer and a brute-force attack may prevail, you’ll still need a way to sift through the myriad outcomes and either choose a winner computationally or select a small subset of candidates to visually examine.</p>
<p class="indent">For the more common <em>letter</em>-transposition ciphers, it’s easy to write a function that detects English by comparing each decryption attempt to a dictionary file. If the number of decrypted words belonging to a dictionary is greater than a certain threshold percentage, you’ve probably cracked the cipher. Likewise, if there’s a high frequency of common letter pairs (<em>digrams</em>)—like <em>er</em>, <em>th</em>, <em>on</em>, or <em>an</em>—you may have found the solution. Unfortunately, this approach won’t work for a <em>word</em>-transposition cipher like the one you’re using here.</p>
<p class="indent">Dictionaries can’t help you figure out whether words have been arranged correctly. For word arrangement, you could try using approaches like grammatical rules and probabilistic language models, such as <em>n</em>-grams, combing through thousands of decryptions and picking candidate outcomes programmatically, but Stager’s wise use of code names and dummy words in his route cipher will greatly complicate the process.</p>
<p class="indent"><span epub:type="pagebreak" id="page_73"/>Cryptanalysts consider short, straight-up transposition ciphers to be fairly easy to crack without a computer, despite the issues just described. They look for common word or letter pairs that make sense, and use those to guess the number of rows in the transposition matrix.</p>
<p class="indent">To illustrate, let’s use our control message composed of numbers. In <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>, you can see the ciphertext outcomes for a 4×5 matrix, each produced by starting at one of the four corners of the grid, and following an alternating, sequential route. All cases include repetition of adjacent numbers (shaded in <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>). These indicate where you’re moving laterally through the grid, and they provide clues to the design of the matrix and the route taken through it. You can immediately see that there were five rows, because the first of each common pair is a fifth word. Moreover, knowing there are 20 words in the message, you learn the number of columns was four (20 / 5 = 4). Using the reasonable assumption that the plaintext message was written left to right, you can even guess the route. For example, if you start in the lower right, you go up to 3, then left to 2, then down to 18, then left to 17, then up to 1 and left to 0. Of course, this would be more difficult with words, since the connection between words isn’t as explicit, but using numbers really makes the point.</p>
<div class="image"><a id="ch04fig5"/><img src="../images/f0073-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-5: Characters or words in logical order (shaded) can be used to guess an encryption route.</em></p>
<p class="indent">Look at <a href="ch04.xhtml#ch04fig6">Figure 4-6</a>, based on the message in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a>. End words and possible linked words, like “is just” or “heading to,” are shaded.</p>
<div class="image"><a id="ch04fig6"/><img src="../images/f0073-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-6: Human hacking of the route cipher in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a>. A five-row matrix is indicated.</em></p>
<p class="indent">There are 20 total words, for which there could be 4, 5, or 10 rows. It’s doubtful that a two-column matrix would be used, so we are realistically dealing with a 4×5 or a 5×4 arrangement. If the route cipher path is like that in <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>, then we’d expect to see two nonshaded words between shaded words for a four-row matrix and three nonshaded words for a five-row matrix. It’s harder to come up with sensical word pairs that honor the <span epub:type="pagebreak" id="page_74"/>four-column pattern, regardless of which direction you read the ciphertext. So, we’re probably dealing with a five-column solution that starts on the left side of the matrix—since the linked words make sense read left to right.</p>
<p class="indent">Note how the shaded words in <a href="ch04.xhtml#ch04fig6">Figure 4-6</a> fill out the top and bottom rows in the transposition matrix in <a href="ch04.xhtml#ch04fig7">Figure 4-7</a>. This is what we would expect, as the path is “turning around” at the top and bottom of every column. Graphical solutions: God’s gift to the innumerate!</p>
<div class="image"><a id="ch04fig7"/><img src="../images/f0074-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-7: Shaded words in <a href="ch04.xhtml#ch04fig6">Figure 4-6</a> placed in the transposition matrix</em></p>
<p class="indent">This seemed easy, but then again, we know how a route cipher works. Confederate code breakers eventually discovered it too, but the use of code words denied them full entry into the system. To hack the codes, they needed a captured codebook or a large organization capable of acquiring and analyzing big data, which was beyond the reach of the Confederacy in the 19th century.</p>
<h4 class="h4" id="lev91"><strong><em>Adding a User Interface</em></strong></h4>
<p class="noindent">The second goal of this project is to write the code in such a way as to reduce human error, especially from those with less experience (including technicians, interns, peers, and telegraph clerks in 1864). Of course, the best way to make a program user-friendly is to include a <em>graphical user interface (GUI)</em>, but at times, this isn’t practical or possible. For example, code-cracking programs automatically loop through thousands of possible keys, and autogenerating these keys is easier than getting them directly from a user.</p>
<p class="indent">In this example, you’ll proceed with the assumption that the user will crack open the program file and enter some input or even make minor code changes. Here are some guidelines to follow:</p>
<ol>
<li class="noindent">Start with a useful docstring (see <a href="ch01.xhtml#ch01">Chapter 1</a>).</li>
<li class="noindent">Place all required user input at the top.</li>
<li class="noindent">Use comments to clarify input requirements.</li>
<li class="noindent">Clearly separate user input from the remaining code.</li>
<li class="noindent">Encapsulate most processes in functions.</li>
<li class="noindent">Include functions to catch predictable user errors.</li></ol>
<p class="indent">The nice thing about this approach is that no one’s intelligence gets insulted. If a user <em>wants</em> to scroll down and look at the code, or even change it, there’s nothing stopping them. If all they want to do is enter some values <span epub:type="pagebreak" id="page_75"/>and get a black box solution, then they’re happy, too. And we’ve honored the spirit of Anson Stager by making things simple and reducing the chance for error.</p>
<h5 class="h5" id="lev92"><strong>Instructing the User and Getting Input</strong></h5>
<p class="noindent"><a href="ch04.xhtml#ch04list2">Listing 4-2</a> shows the prototype code repackaged for sharing with others. You can find this code at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<p class="margin"><em>route_cipher_decrypt.py,</em> part 1</p>
<pre><span class="ent">➊</span> """Decrypt a path through a Union Route Cipher.<br/><br/><span class="ent">➋</span> Designed for whole-word transposition ciphers with variable rows &amp; columns.<br/>   Assumes encryption began at either top or bottom of a column.<br/>   Key indicates the order to read columns and the direction to traverse.<br/>   Negative column numbers mean start at bottom and read up.<br/>   Positive column numbers mean start at top &amp; read down.<br/><br/>   Example below is for 4x4 matrix with key -1 2 -3 4.<br/>   Note "0" is not allowed.<br/>   Arrows show encryption route; for negative key values read UP.<br/><br/>     1   2   3   4<br/><br/>    ___ ___ ___ ___<br/>   | ^ | | | ^ | | | MESSAGE IS WRITTEN<br/>   |_|_|_v_|_|_|_v_|<br/>   | ^ | | | ^ | | | ACROSS EACH ROW<br/>   |_|_|_v_|_|_|_v_|<br/>   | ^ | | | ^ | | | IN THIS MANNER<br/>   |_|_|_v_|_|_|_v_|<br/>   | ^ | | | ^ | | | LAST ROW IS FILLED WITH DUMMY WORDS<br/>   |_|_|_v_|_|_|_v_|<br/>   START        END<br/><br/>   Required inputs - a text message, # of columns, # of rows, key string<br/><br/>   Prints translated plaintext<br/>   """<br/><span class="ent">➌</span> import sys<br/><br/>   #==============================================================================<br/><span class="ent">➍</span> # USER INPUT:<br/><br/><span class="ent">➎</span> # the string to be decrypted (type or paste between triple-quotes):<br/>   ciphertext = """16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19<br/>   """<br/><br/><span class="ent">➏</span> # number of columns in the transposition matrix:<br/>   COLS = 4<br/><br/>   # number of rows in the transposition matrix:<br/>   ROWS = 5<br/><br/><span class="ent">➐</span> # key with spaces between numbers; negative to read UP column (ex = -1 2 -3 4):<br/>   key = """ -1 2 -3 4 """<br/><br/><span epub:type="pagebreak" id="page_76"/><span class="ent">➑</span> # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!<br/>   #==============================================================================<br/><br/><span class="ent">➒</span> ________________________________________________________________________________</pre>
<p class="listing" id="ch04list2"><em>Listing 4-2: Docstring, imports, and user input for</em> route_cipher_decrypt.py</p>
<p class="indent">Start with a multiline docstring in triple quotes <span class="ent">➊</span>. The docstring informs the user that the program only decrypts a typical route cipher—one that starts at either the top or bottom of a column—and how to enter the key information <span class="ent">➋</span>. A diagram is included to help make the point.</p>
<p class="indent">Next, import <code>sys</code> for access to system fonts and functions <span class="ent">➌</span>. You’re going to check the user’s input for acceptance criteria, so you need to display messages in the shell in eye-catching red. Putting this <code>import</code> statement here is a catch-22. Since the strategic goal is to hide the working code from the user, you really should apply this later in the program. But the Python convention of putting all <code>import</code> statements at the top is too strong to ignore.</p>
<p class="indent">Now for the input section. How often have you seen or dealt with code where inputs or changes have to be made <em>throughout</em> the program? This can be confusing for the author and even worse for another user. So, move all these important variables to the top for convenience, common courtesy, and error prevention.</p>
<p class="indent">First, separate the input section with a line and then let the user know that they’re on deck with an all-caps comment <span class="ent">➍</span>. The required inputs are clearly defined with comments. You can use triple quotes for the text input to better accommodate long snippets of text. Note that I’ve entered the string of numbers from <a href="ch04.xhtml#ch04fig3">Figure 4-3</a> <span class="ent">➎</span>. Next, the user needs to add the number of columns and rows for the transposition matrix <span class="ent">➏</span>, followed by the proposed (or known) key <span class="ent">➐</span>.</p>
<p class="indent">End the user input section with a declaration comment to that effect and a caution to not edit anything below the following line <span class="ent">➑</span>. Then add some extra spaces to more clearly separate the input section from the rest of the program <span class="ent">➒</span>.</p>
<h5 class="h5" id="lev93"><strong>Defining the main() Function</strong></h5>
<p class="noindent"><a href="ch04.xhtml#ch04list3">Listing 4-3</a> defines the <code>main()</code> function, which runs the program and prints out the plaintext after the cipher is decoded. The <code>main()</code> function can be defined before or after the functions it calls, as long as it is the last function called.</p>
<p class="margin"><em>route_cipher_decrypt.py,</em> part 2</p>
<pre>def main():<br/>    """Run program and print decrypted plaintext."""<br/> <span class="ent">➊</span> print("\nCiphertext = {}".format(ciphertext))<br/>    print("Trying {} columns".format(COLS))<br/>    print("Trying {} rows".format(ROWS))<br/>    print("Trying key = {}".format(key))<br/><br/>    # split elements into words, not letters<br/> <span class="ent">➋</span> cipherlist = list(ciphertext.split())<br/><span epub:type="pagebreak" id="page_77"/> <span class="ent">➌</span> validate_col_row(cipherlist)<br/> <span class="ent">➍</span> key_int = key_to_int(key)<br/> <span class="ent">➎</span> translation_matrix = build_matrix(key_int, cipherlist)<br/> <span class="ent">➏</span> plaintext = decrypt(translation_matrix)<br/><br/> <span class="ent">➐</span> print("Plaintext = {}".format(plaintext))</pre>
<p class="listing" id="ch04list3"><em>Listing 4-3: Defines the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">Start the <code>main()</code> function by printing the user input to the shell <span class="ent">➊</span>. Then turn the ciphertext into a list by splitting on whitespace, as you did in the prototype code <span class="ent">➋</span>.</p>
<p class="indent">The next series of statements call functions you will define shortly. The first checks whether the input rows and columns are valid for the message length <span class="ent">➌</span>. The second converts the <code>key</code> variable from a string to a list of integers <span class="ent">➍</span>. The third builds the translation matrix <span class="ent">➎</span>, and the fourth runs the decryption algorithm on the matrix and returns a plaintext string <span class="ent">➏</span>. Finish <code>main()</code> by printing the plaintext <span class="ent">➐</span>.</p>
<h5 class="h5" id="lev94"><strong>Verifying Data</strong></h5>
<p class="noindent">As you continue to package <em>route_cipher_decrypt.py</em> for the end user, you need to verify that the input is valid. <a href="ch04.xhtml#ch04list4">Listing 4-4</a> anticipates common user errors and provides the user with helpful feedback and guidance.</p>
<p class="margin"><em>route_cipher_decrypt.py,</em> part 3</p>
<pre><span class="ent">➊</span> def validate_col_row(cipherlist):<br/>       """Check that input columns &amp; rows are valid vs. message length."""<br/>       factors = []<br/>       len_cipher = len(cipherlist)<br/>    <span class="ent">➋</span> for i in range(2, len_cipher):  # range excludes 1-column ciphers<br/>           if len_cipher % i == 0:<br/>               factors.append(i)<br/>    <span class="ent">➌</span> print("\nLength of cipher = {}".format(len_cipher))<br/>       print("Acceptable column/row values include: {}".format(factors))<br/>       print()<br/>    <span class="ent">➍</span> if ROWS * COLS != len_cipher:<br/>           print("\nError - Input columns &amp; rows not factors of length "<br/>                 "of cipher. Terminating program.", file=sys.stderr)<br/>           sys.exit(1)<br/><br/><span class="ent">➎</span> def key_to_int(key):<br/>       """Turn key into list of integers &amp; check validity."""<br/>    <span class="ent">➏</span> key_int = [int(i) for i in key.split()]<br/>       key_int_lo = min(key_int)<br/>       key_int_hi = max(key_int)<br/>    <span class="ent">➐</span> if len(key_int) != COLS or key_int_lo &lt; -COLS or key_int_hi &gt; COLS \<br/>           or 0 in key_int:<br/>        <span class="ent">➑</span> print("\nError - Problem with key. Terminating.", file=sys.stderr)<br/>           sys.exit(1)<br/>       else:<br/>        <span class="ent">➒</span> return key_int</pre>
<p class="listing" id="ch04list4"><em>Listing 4-4: Defines functions for checking and prepping user input</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_78"/>The <code>validate_col_row()</code> function checks that the input column and row numbers are appropriate for the length of the <code>cipherlist</code>, which you pass as an argument <span class="ent">➊</span>. The transposition matrix is always the same size as the number of words in the message, so the number of columns and the number of rows have to be a factor of the message size. To determine all the permissible factors, first make an empty list to hold the factors and then get the length of the cipherlist. Use the <em>cipherlist</em>, rather than the input <em>ciphertext</em>, as the elements in the ciphertext are <em>letters</em>, not words.</p>
<p class="indent">Normally, to get the factors of a number, you would use a range of (<code>1,</code> <span class="codeitalic">number</span> <code>+</code> <code>1</code>), but you don’t want these endpoints in the <code>factors</code> list, because a translation matrix with these dimensions would just be the plaintext. So exclude these values from the range <span class="ent">➋</span>. Since a factor of a number divides evenly into that number, use the modulo operator (<code>%</code>) to find the factors and then append them to the <code>factors</code> list.</p>
<p class="indent">Next, display some useful information for the user: the length of the cipherlist and the acceptable choices for rows and columns <span class="ent">➌</span>. Finally, multiply the user’s two choices together and compare the product to the length of the cipherlist. If they don’t match, print a red warning message in the shell (using our old <code>file=sys.stderr</code> trick) and terminate the program <span class="ent">➍</span>. Use <code>sys.exit(1)</code>, as the <code>1</code> indicates an abnormal exit.</p>
<p class="indent">Now define a function to check the key and convert it from a string to a list <span class="ent">➎</span>. Pass it the <code>key</code> variable as an argument. Split out each item in <code>key</code> and convert it to an integer; name the list <code>key_int</code> to distinguish it from the user-entered <code>key</code> variable <span class="ent">➏</span>. Next, determine the minimum and maximum values in the <code>key_int</code> list. Then use an <code>if</code> statement to make sure the list contains the same number of items as there are columns and none of the items in <code>key</code> is too large, too small, or equal to <code>0</code> <span class="ent">➐</span>. Terminate the program with an error message if any of those criteria fail to pass <span class="ent">➑</span>. Otherwise, return the <code>key_int</code> list <span class="ent">➒</span>.</p>
<h5 class="h5" id="lev95"><strong>Building and Decoding the Translation Matrix</strong></h5>
<p class="noindent"><a href="ch04.xhtml#ch04list5">Listing 4-5</a> defines two functions, one to build the translation matrix and one to decode it, and calls the <code>main()</code> function as a module or in stand-alone mode.</p>
<p class="margin"><em>route_cipher_decrypt.py,</em> part 4</p>
<pre><span class="ent">➊</span> def build_matrix(key_int, cipherlist):<br/>       """Turn every n items in a list into a new item in a list of lists."""<br/>       translation_matrix = [None] * COLS<br/>       start = 0<br/>       stop = ROWS<br/>       for k in key_int:<br/>           if k &lt; 0:  # read bottom-to-top of column<br/>               col_items = cipherlist[start:stop]<br/>           elif k &gt; 0:  # read top-to-bottom of columnn<br/>               col_items = list((reversed(cipherlist[start:stop])))<br/>           translation_matrix[abs(k) - 1] = col_items<br/>           start += ROWS<br/>           stop += ROWS<br/>       return translation_matrix<br/><br/><span epub:type="pagebreak" id="page_79"/><span class="ent">➋</span> def decrypt(translation_matrix):<br/>       """Loop through nested lists popping off last item to a string."""<br/>       plaintext = ''<br/>       for i in range(ROWS):<br/>           for matrix_col in translation_matrix:<br/>               word = str(matrix_col.pop())<br/>               plaintext += word + ' '<br/>       return plaintext<br/><br/><span class="ent">➌</span> if __name__ == '__main__':<br/>       main()</pre>
<p class="listing" id="ch04list5"><em>Listing 4-5: Defines the functions for building and decoding the translation matrix</em></p>
<p class="indent">These two functions represent encapsulation of code in the <em>route_cipher_decrypt_prototype.py</em> program. See <a href="ch04.xhtml#ch04list1">Listing 4-1</a> for a detailed description.</p>
<p class="indent">First, define a function to build the translation matrix; pass it the <code>key_int</code> and <code>cipherlist</code> variables as arguments <span class="ent">➊</span>. Have the function return the list of lists.</p>
<p class="indent">Next, bundle the decryption code, where you pop off the end of each nested list, as a function that uses the <code>translation_matrix</code> list as an argument <span class="ent">➋</span>. Return the plaintext, which will be printed by the <code>main()</code> function.</p>
<p class="indent">End with the conditional statement that lets the program run as a module or in stand-alone mode <span class="ent">➌</span>.</p>
<p class="indent">If you’re an occasional or one-time user of this code, you’ll appreciate how straightforward and approachable it is. If you plan to alter the code for your own purposes, you’ll also appreciate that the key variables are accessible and the major tasks are modularized. You won’t have to dig through the program to tease out what matters or understand the difference between arcane variables like <code>list1</code> and <code>list2</code>.</p>
<p class="indent">Here’s the output of the program, using the ciphertext from <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>:</p>
<pre>Ciphertext = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19<br/><br/>Trying 4 columns<br/>Trying 5 rows<br/>Trying key = -1 2 -3 4<br/><br/>Length of cipher = 20<br/>Acceptable column/row values include: [2, 4, 5, 10]<br/><br/>Plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</pre>
<p class="indent">You should now be able to easily decrypt a route transposition cipher with a known key or test suspected routes by using the script’s clear and accessible interface to adjust the key. You’ll get a chance to truly crack one of these ciphers, by automatically trying every possible key, in “<a href="ch04.xhtml#lev111">Route Transposition Cipher: Brute-Force Attack</a>” on <a href="ch04.xhtml#page_88">page 88</a>.</p>
<h3 class="h3a" id="lev96"><span epub:type="pagebreak" id="page_80"/><strong>Project #9: The Rail Fence Cipher</strong></h3>
<p class="noindent">Confederate officers and spies were pretty much on their own when it came to cryptography. This led to unsophisticated solutions, one of the favorites being the rail fence cipher, so named due to its resemblance to the zigzag pattern of a split-rail fence (shown in <a href="ch04.xhtml#ch04fig8">Figure 4-8</a>).</p>
<div class="image"><a id="ch04fig8"/><img src="../images/f0080-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-8: A rail fence</em></p>
<p class="indent">The rail fence is a simple-to-use transposition cipher, like the Union’s route cipher, but differs from the route cipher in that it transposes letters rather than words, making it more error-prone. And since the number of possible keys is much more restrictive than the number of paths through a route cipher, the rail fence cipher is much easier to “tear down.”</p>
<p class="indent">Both the Union and Confederates used the rail fence as a field cipher, and the spies probably didn’t use code words very often. Codebooks needed to be tightly controlled, for obvious reasons, and were more likely to be secured in a military telegraph office than carried around by easily compromised undercover agents.</p>
<p class="indent">Sometimes the Confederates used the more complex Vigenère cipher (see “<a href="ch06.xhtml#lev130">Project #12: Hiding a Vigenère Cipher</a>” on <a href="ch06.xhtml#page_106">page 106</a>) for important messages—and some unimportant ones to mislead enemies—but it was tedious work to decipher and equally laborious to encrypt and not suitable for fast field communications.</p>
<p class="indent">Despite their lack of training in the mechanics of cryptography, the Confederacy, and Southerners in general, were clever and innovative. Among their more impressive accomplishments in the art of secret messages was the use of microphotography, 100 years before it was widely adopted during the Cold War.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_81"/><strong>THE OBJECTIVE</strong></p>
<p class="spara">Write Python programs that will help a spy encrypt and decrypt a “two-rail” (two-row) rail fence cipher. You should write the programs in a way that will reduce potential errors by inexperienced users.</p>
</div>
<h4 class="h4" id="lev97"><strong><em>The Strategy</em></strong></h4>
<p class="noindent">To encrypt a message with the rail fence cipher, follow the steps in <a href="ch04.xhtml#ch04fig9">Figure 4-9</a>.</p>
<div class="image"><a id="ch04fig9"/><img src="../images/f0081-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-9: Encryption process for a “two-rail” rail fence cipher</em></p>
<p class="indent">After the plaintext is written, the spaces are removed, and all the letters are converted to uppercase (Step 2). Using uppercase is common convention in cryptography, as it obfuscates the presence of proper names and the beginning of sentences, giving a cryptanalyst fewer clues for deciphering the message.</p>
<p class="indent">The message is then written in stacked fashion, with every other letter below the previous letter and shifted over one space (Step 3). This is where the “rail fence” analogy becomes apparent.</p>
<p class="indent">The first row is then written, followed immediately by the second row on the same line (Step 4), and then the letters are broken into groups of five to create the illusion of distinct words and to further confuse the cryptanalyst (Step 5).</p>
<p class="indent">To decrypt a rail fence cipher, reverse the process. Just remove the spaces, divide the message in half, stack the second half below the first, offset by one letter, and read the message using the zigzag pattern. If the ciphertext has an odd number of letters, put the extra letter in the first (upper) half.</p>
<p class="indent">To make things easy for people who want to use a rail fence cipher, follow the preceding steps to write two programs, one to encrypt and another to decrypt. <a href="ch04.xhtml#ch04fig9">Figure 4-9</a> is essentially your pseudocode, so let’s get to it. And since you now know how to package the code for inexperienced users, take that approach from the start.</p>
<h4 class="h4" id="lev98"><span epub:type="pagebreak" id="page_82"/><strong><em>The Rail Fence Cipher Encryption Code</em></strong></h4>
<p class="noindent">The code in this section allows a user to enter a plaintext message and have the encrypted results print in the interpreter window. This code is available for download with the book’s resources at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h5 class="h5" id="lev99"><strong>Instructing the User and Getting Input</strong></h5>
<p class="noindent"><a href="ch04.xhtml#ch04list6">Listing 4-6</a>, at the top of <em>rail_fence_cipher_encrypt.py</em>, provides the program’s instructions and assigns the plaintext to a variable.</p>
<p class="margin"><em>rail_fence_cipher_encrypt.py,</em> part 1</p>
<pre><span class="ent">➊</span> r"""Encrypt a Civil War 'rail fence' type cipher.<br/><br/>   This is for a "2-rail" fence cipher for short messages.<br/><br/>   Example text to encrypt:  'Buy more Maine potatoes'<br/><br/>   Rail fence style:  B Y O E A N P T T E<br/>                       U M R M I E O A O S<br/><br/>   Read zigzag:       \/\/\/\/\/\/\/\/\/\/<br/><br/>   Encrypted:  BYOEA NPTTE UMRMI EOSOS<br/><br/>   """<br/>   #------------------------------------------------------------------------------<br/><span class="ent">➋</span> # USER INPUT:<br/><br/>   # the string to be encrypted (paste between quotes):<br/><span class="ent">➌</span> plaintext = """Let us cross over the river and rest under the shade of the trees<br/>   """<br/><br/><span class="ent">➍</span> # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!<br/>   #------------------------------------------------------------------------------</pre>
<p class="listing" id="ch04list6"><em>Listing 4-6: Docstring and user input section for</em> rail_fence_cipher_encrypt.py</p>
<p class="indent">Start with a multiline docstring, placing an <code>r</code> (which stands for “raw”) prefix before the first set of triple quotes <span class="ent">➊</span>. Without this prefix, Pylint will complain bitterly about the <code>\/\</code> slashes used further down. Fortunately, pydocstyle points this out so you can fix it (read <a href="ch01.xhtml#ch01">Chapter 1</a> to learn all about Pylint and pydocstyle). If you want to know more about <em>raw strings</em>, see Section 2.4.1 in the Python docs (<em><a href="https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals">https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals</a></em>).</p>
<p class="indent">Next, separate the program’s docstring and <code>import</code> statements from the input section with a line and let the user know they’re on deck with an all-caps comment <span class="ent">➋</span>. Clearly define the input requirement with comments and place the plaintext inside triple quotes to better accommodate long text strings <span class="ent">➌</span>.</p>
<p class="indent">Finally, end the user input section with a declaration to that effect and caution to not edit anything below the following line <span class="ent">➍</span>.</p>
<h5 class="h5" id="lev100"><span epub:type="pagebreak" id="page_83"/><strong>Encrypting a Message</strong></h5>
<p class="noindent">Add <a href="ch04.xhtml#ch04list7">Listing 4-7</a> to <em>rail_fence_cipher_encrypt.py</em> in order to handle the encryption processes.</p>
<p class="margin"><em>rail_fence_cipher_encrypt.py,</em> part 2</p>
<pre><span class="ent">➊</span> def main():<br/>       """Run program to encrypt message using 2-rail rail fence cipher."""<br/>       message = prep_plaintext(plaintext)<br/>       rails = build_rails(message)<br/>       encrypt(rails)<br/><br/><span class="ent">➋</span> def prep_plaintext(plaintext):<br/>       """Remove spaces &amp; leading/trailing whitespace."""<br/>    <span class="ent">➌</span> message = "".join(plaintext.split())<br/>    <span class="ent">➍</span> message = message.upper()  # convention for ciphertext is uppercase<br/>       print("\nplaintext = {}".format(plaintext))<br/>       return message<br/><br/><span class="ent">➎</span> def build_rails(message):<br/>       """Build strings with every other letter in a message."""<br/>       evens = message[::2]<br/>       odds = message[1::2]<br/>    <span class="ent">➏</span> rails = evens + odds<br/>       return rails<br/><br/><span class="ent">➐</span> def encrypt(rails):<br/>       """Split letters in ciphertext into chunks of 5 &amp; join to make string."""<br/>    <span class="ent">➑</span> ciphertext = ' '.join([rails[i:i+5] for i in range(0, len(rails), 5)])<br/>       print("ciphertext = {}".format(ciphertext))<br/><br/><span class="ent">➒</span> if __name__ == '__main__':<br/>       main()</pre>
<p class="listing" id="ch04list7"><em>Listing 4-7: Defines functions to encrypt the plaintext message</em></p>
<p class="indent">To start, define a <code>main()</code> function to run the program <span class="ent">➊</span>. Having a <code>main()</code> function gives you the flexibility to use this program as a module in another program later, should the need arise. This function calls three other functions: one to prepare the input plaintext, one to build the “rails” used by the cipher, and one to break the encrypted text into five-letter chunks.</p>
<p class="indent">Next, define a function to take the input string and prepare it for encryption <span class="ent">➋</span>. This involves removing spaces <span class="ent">➌</span> and converting letters to uppercase (as in Step 2 in <a href="ch04.xhtml#ch04fig9">Figure 4-9</a>) <span class="ent">➍</span>. Then, after a newline, print the plaintext to the screen and return it.</p>
<p class="indent">Now, define a function to build two strings, as in Step 3 of <a href="ch04.xhtml#ch04fig9">Figure 4-9</a>, by slicing <code>message</code> for evens (starting at 0 and stepping by 2) and for odds (starting at 1 and stepping by 2) <span class="ent">➎</span>. The two strings are then concatenated in a new string, named <code>rails</code> <span class="ent">➏</span>, and returned.</p>
<p class="indent">Define an encryption function that takes the <code>rails</code> string as an argument <span class="ent">➐</span>. Use list comprehension to split the ciphertext into chunks of five (as in Step 5 of <a href="ch04.xhtml#ch04fig9">Figure 4-9</a>) <span class="ent">➑</span>. The encrypted text is then printed to the screen. Finish with the code to run the program as a module or in stand-alone mode <span class="ent">➒</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_84"/>Here is the output from this program:</p>
<pre>plaintext = Let us cross over the river and rest under the shade of the trees<br/>ciphertext = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES</pre>
<h4 class="h4" id="lev101"><strong><em>The Rail Fence Cipher Decryption Code</em></strong></h4>
<p class="noindent">The code in this section allows a user to enter a message encrypted with the rail fence cipher and have the plaintext printed in the interpreter window. This code is available for download along with the rest of the book’s resources at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h5 class="h5" id="lev102"><strong>Importing Modules, Instructing the User, and Getting Input</strong></h5>
<p class="noindent"><a href="ch04.xhtml#ch04list8">Listing 4-8</a> starts with instructions similar to those in the <em>rail_fence_cipher_encrypt.py</em> program (<a href="ch04.xhtml#ch04list6">Listing 4-6</a>), imports two modules, and gets the user input.</p>
<p class="margin"><em>rail_fence_cipher_decrypt.py,</em> part 1</p>
<pre>   r"""Decrypt a Civil War 'rail fence' type cipher.<br/><br/>   This is for a 2-rail fence cipher for short messages.<br/><br/>   Example plaintext:  'Buy more Maine potatoes'<br/><br/>   Rail fence style:  B Y O E A N P T T E<br/>                       U M R M I E O A O S<br/><br/>   Read zigzag:       \/\/\/\/\/\/\/\/\/\/<br/><br/>   Ciphertext:  BYOEA NPTTE UMRMI EOSOS<br/><br/>   """<br/><span class="ent">➊</span> import math<br/>   import itertools<br/><br/>   #------------------------------------------------------------------------------<br/>   # USER INPUT:<br/><br/>   # the string to be decrypted (paste between quotes):<br/><span class="ent">➋</span> ciphertext = """LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES<br/><br/>   """<br/><br/>   # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!<br/>   #------------------------------------------------------------------------------</pre>
<p class="listing" id="ch04list8"><em>Listing 4-8: Imports modules, instructs the user, and gets user input</em></p>
<p class="indent">One difference here is that you need to import the <code>math</code> and <code>itertools</code> modules <span class="ent">➊</span>. You’ll use <code>math</code> for rounding. The <code>itertools</code> module is a group of <span epub:type="pagebreak" id="page_85"/>functions in the Python Standard Library that create iterators for efficient looping. You’ll use <code>itertool</code>’s <code>zip_longest()</code> function during the decryption process.</p>
<p class="indent">The only other change is that the user should enter ciphertext, rather than plaintext <span class="ent">➋</span>.</p>
<h5 class="h5" id="lev103"><strong>Decrypting a Message</strong></h5>
<p class="noindent"><a href="ch04.xhtml#ch04list9">Listing 4-9</a> defines the functions for preparing and decoding the ciphertext and finishes off <em>rail_fence_cipher_decrypt.py</em>.</p>
<p class="margin"><em>rail_fence_cipher_decrypt.py,</em> part 2</p>
<pre><span class="ent">➊</span> def main():<br/>
       """Run program to decrypt 2-rail rail fence cipher."""<br/>
       message = prep_ciphertext(ciphertext)<br/>
       row1, row2 = split_rails(message)<br/>
       decrypt(row1, row2)<br/>
<br/>
<span class="ent">➋</span> def prep_ciphertext(ciphertext):<br/>
       """Remove whitespace."""<br/>
       message = "".join(ciphertext.split())<br/>
       print("\nciphertext = {}".format(ciphertext))<br/>
       return message<br/>
<br/>
<span class="ent">➌</span> def split_rails(message):<br/>
       """Split message in two, always rounding UP for 1st row."""<br/>
    <span class="ent">➍</span> row_1_len = math.ceil(len(message)/2)<br/>
    <span class="ent">➎</span> row1 = (message[:row_1_len]).lower()<br/>
       row2 = (message[row_1_len:]).lower()<br/>
       return row1, row2<br/>
<br/>
<span class="ent">➏</span> def decrypt(row1, row2):<br/>
       """Build list with every other letter in 2 strings &amp; print."""<br/>
    <span class="ent">➐</span> plaintext = []<br/>
    <span class="ent">➑</span> for r1, r2 in itertools.zip_longest(row1, row2):<br/>
           plaintext.append(r1)<br/>
           plaintext.append(r2)<br/>
    <span class="ent">➒</span> if None in plaintext:<br/>
           plaintext.pop()<br/>
       print("rail 1 = {}".format(row1))<br/>
       print("rail 2 = {}".format(row2))<br/>
       print("\nplaintext = {}".format(''.join(plaintext)))<br/>
<br/>
<span class="ent">➓</span> if __name__ == '__main__':<br/>
       main()</pre>
<p class="listing" id="ch04list9"><em>Listing 4-9: Prepares, decodes, and prints the message</em></p>
<p class="indent">The <code>main()</code> function here <span class="ent">➊</span> is similar to the one used in the encryption program in <a href="ch04.xhtml#ch04list7">Listing 4-7</a>. Three functions are called: one to prepare the input string, one to “split the rails” in the rail fence cipher, and one to stitch the two rails back together into readable plaintext.</p>
<p class="indent"><span epub:type="pagebreak" id="page_86"/>Start with a function that repeats the preprocessing steps used during encryption <span class="ent">➋</span>. Remove the spaces between the five-letter chunks, as well as any other whitespace created during the pasting of the ciphertext, and print and return the ciphertext.</p>
<p class="indent">Next, you need to split the message back into two halves to reverse the encryption process <span class="ent">➌</span>. As I mentioned in “<a href="ch04.xhtml#lev97">The Strategy</a>” on <a href="ch04.xhtml#page_81">page 81</a>, the extra letter in a message with an odd number of characters is assigned to the top row. To address the odd-numbered case, use the <code>math.ceil()</code> method <span class="ent">➍</span>. “Ceil” stands for “ceiling,” so when you divide by 2, the answer is always rounded up to the nearest integer. Assign this number to the <code>row_1_len</code> variable. Once you know the length of the first row, use that value and slicing to divide the <code>message</code> variable into two strings representing the rows <span class="ent">➎</span>. End the function by returning the row variables.</p>
<p class="indent">Now it’s just a matter of choosing and joining every other letter from the rows to stitch the plaintext back together. Define a <code>decrypt()</code> function and pass it the strings for <code>row1</code> and <code>row2</code> <span class="ent">➏</span>. Start the translation process by making an empty list to hold the results <span class="ent">➐</span>. Next, you need an easy way to deal with cases where the ciphertext has an odd number of letters—resulting in two rows of different lengths—because Python prevents you from looping through two uneven sequences by raising an index-out-of-range error. This is why we’ve imported the <code>itertools</code> module—its functions help with looping to circumvent this problem.</p>
<p class="indent">The <code>itertools.zip_longest()</code> function accepts two strings as arguments and loops through them without complaint, appending a null value (<code>None</code>) to the <code>plaintext</code> list when it gets to the end of the shorter string <span class="ent">➑</span>. You don’t want to print this null value, so if it’s there, remove it using the <code>pop()</code> method you applied in the route cipher code <span class="ent">➒</span>. Complete the decryption process by printing the two rows (rails) to the screen, followed by the decrypted ciphertext.</p>
<p class="indent">End with the standard code for running the program as a module or in stand-alone mode <span class="ent">➓</span>. The output from the program is as follows:</p>
<pre>ciphertext = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES<br/><br/>rail 1 = LTSRSOETEIEADETNETEHDOTERE<br/>rail 2 = EUCOSVRHRVRNRSUDRHSAEFHTES<br/><br/>plaintext = letuscrossovertheriverandrestundertheshadeofthetrees</pre>
<p class="indent">Note that there will be no spaces between words, but that’s okay—you don’t want to leave the cryptanalyst feeling completely useless!</p>
<h3 class="h3" id="lev104"><strong>Summary</strong></h3>
<p class="noindent">That completes our foray into Civil War ciphers. You wrote a program that helps a user decrypt a route cipher, and you gained valuable insights into how it works and how to hack it. You can implement an automated attack on <span epub:type="pagebreak" id="page_87"/>the cipher in the following practice projects, but remember, with its many possible paths and use of code words, the Union route cipher is a tough nut to fully crack.</p>
<p class="indent">Next, you wrote programs to encrypt and decrypt two-rail fence ciphers. Given how tedious and error-prone the manual encryption and decryption processes are, having an automated way to do most of the work would have been valuable to both sides in the war. And to further address these types of issues, you wrote your code to be user-friendly to the inexperienced cryptanalyst or spy.</p>
<h3 class="h3" id="lev105"><strong>Further Reading</strong></h3>
<p class="noindent">More beginner-level Python programs for working with transposition ciphers are available in <em>Cracking Codes with Python</em> (No Starch Press, 2018) by Al Sweigart.</p>
<p class="indent">Excellent and well-illustrated overviews of cryptography can be found in <em>Mysterious Messages: A History of Codes and Ciphers</em> (The Penguin Group, 2009) by Gary Blackwood and <em>The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography</em> (Anchor, 2000) by Simon Singh.</p>
<p class="indent">The sites <em><a href="http://www.civilwarsignals.org/pages/crypto/crypto.html">http://www.civilwarsignals.org/pages/crypto/crypto.html</a></em> and <em><a href="http://www.mathaware.org/mam/06/Sauerberg_route-essay.html">http://www.mathaware.org/mam/06/Sauerberg_route-essay.html</a></em> include descriptions of Edward Porter Alexander’s attempt to solve a route cipher. Alexander was the father of the Confederate Army Signal Corps and a brilliant military innovator with many impressive accomplishments.</p>
<h3 class="h3" id="lev106"><strong>Practice Projects</strong></h3>
<p class="noindent">Hone your cryptography skills with these projects. Solutions are available in the appendix and online.</p>
<h4 class="h4" id="lev107"><strong><em>Hacking Lincoln</em></strong></h4>
<p class="noindent">In his book, <em>Mysterious Messages: A History of Codes and Ciphers</em>, Gary Blackwood reproduces an actual message sent by Abraham Lincoln and encrypted with a route cipher:</p>
<p class="noindentc"><strong>THIS OFF DETAINED ASCERTAIN WAYLAND CORRESPONDENTS OF AT WHY AND IF FILLS IT YOU GET THEY NEPTUNE THE TRIBUNE PLEASE ARE THEM CAN UP</strong></p>
<p class="indent">Use the <em>route_cipher_decrypt.py</em> program to solve this cryptogram. The number of columns and rows must be factors of the message length, and the route starts in one of the corners, doesn’t skip columns, and alternates direction with every column change. The code word definitions and plaintext solution can be found in the appendix.</p>
<h4 class="h4" id="lev108"><span epub:type="pagebreak" id="page_88"/><strong><em>Identifying Cipher Types</em></strong></h4>
<p class="noindent">The sooner you know what type of cipher you’re dealing with, the sooner you can break it. Word-transposition ciphers are easy to spot, but letter-transposition ciphers can look like letter-<em>substitution</em> ciphers. Fortunately, you can distinguish between the two by using the frequency of occurrence of letters in the ciphertext. Since the letters are just scrambled and not replaced in transposition ciphers, their frequency distribution will be the same as for the language in which the plaintext was written. An exception, however, is military messages, which use jargon and omit many common words. For these, you need a frequency table built from other military messages.</p>
<p class="indent">Write a Python program that takes a string of ciphertext as input and determines whether it is more likely to be a transposition cipher or a substitution cipher. Test it with the files <em>cipher_a.txt</em> and <em>cipher_b.txt</em>, downloadable from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. A solution can be found in the appendix and online at the book’s website in <em>identify_cipher_type_practice.py</em>.</p>
<h4 class="h4" id="lev109"><strong><em>Storing a Key as a Dictionary</em></strong></h4>
<p class="noindent">Write a short script to break a route cipher key into two parts: one to record the column order and one to record the direction to read through the rows in the column (up or down). Store the column number as a dictionary key and the reading direction as the dictionary value. Have the program interactively request the key value for each column from the user. A solution can be found in the appendix and online in the file <em>key_dictionary_practice.py.</em></p>
<h4 class="h4" id="lev110"><strong><em>Automating Possible Keys</em></strong></h4>
<p class="noindent">To attempt to decipher a route cipher using any combination of columns in its path, you need to know what those combinations are, so you can enter them as arguments in a decryption function. Write a Python program that accepts an integer (such as the number of columns) and returns a collection of tuples. Each tuple should contain a unique ordering of column numbers, like <code>(1, 2, 3, 4)</code>. Include negative values—for example, <code>(2, -3, 4, -1</code><code>)</code>—to capture encryption routes that go up columns versus down. A solution is provided in the appendix, with a downloadable version on the book’s website in <em>permutations_practice.py</em>.</p>
<h4 class="h4" id="lev111"><strong><em>Route Transposition Cipher: Brute-Force Attack</em></strong></h4>
<p class="noindent">Copy and modify the <em>route_cipher_decrypt.py</em> program to hack the route cipher in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a>. Rather than inputting a single key, loop through all possible keys—for an assumed number of columns—and print the results (use the earlier permutations code to generate the keys for this four-column cipher). The impact of switching the order of columns and allowing up-and-down paths through the transposition matrix is clearly illustrated in <a href="ch04.xhtml#ch04fig10">Figure 4-10</a>. The dashed line is the factorial of the number of columns; the solid line captures the effect of reading up columns as well as down (captured by the <span epub:type="pagebreak" id="page_89"/>inclusion of negative values in the key). If you only needed to deal with the factorial of 4, your job as a cryptanalyst would be easy. But as the cipher gets longer, the number of possible keys explodes. And some actual Union route ciphers had 10 or more columns!</p>
<div class="image"><a id="ch04fig10"/><img src="../images/f0089-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 4-10: Number of possible keys versus number of columns for a route cipher</em></p>
<p class="indent">Here are four translations out of the 384 produced for the ciphertext in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a>:</p>
<pre>using key = [-4, -1, -2, -3]<br/>translated = IS HEADING FILLER VILLAGE YOUR SNOW SOUTH GODWIN ARE FREE TO YOU<br/>WITH SUPPLIES GONE TRANSPORT ROANOKE JUST TO REST<br/><br/>using key = [1, 2, -3, 4]<br/>translated = REST ROANOKE HEADING TO TRANSPORT WITH SNOW GONE YOU ARE FREE TO<br/>GODWIN YOUR SUPPLIES SOUTH VILLAGE IS JUST FILLER<br/><br/>using key = [-1, 2, -3, 4]<br/>translated = VILLAGE ROANOKE HEADING TO GODWIN WITH SNOW GONE YOU ARE FREE TO<br/>TRANSPORT YOUR SUPPLIES SOUTH REST IS JUST FILLER<br/><br/>using key = [4, -1, 2, -3]<br/>translated = IS JUST FILLER REST YOUR SUPPLIES SOUTH TRANSPORT ARE FREE TO YOU<br/>WITH SNOW GONE GODWIN ROANOKE HEADING TO VILLAGE</pre>
<p class="indent">The correct answer is present, but you can appreciate how hard it would be to pick it out quickly, given the use of code words and dummy words. Still, you did your job. Go have that mint julep or some sweet tea.</p>
<p class="indent">A solution to this project is provided in the appendix and at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> in <em>route_cipher_hacker.py</em>. You will also need the <em>perms.py</em> program, which is based on the previous practice project.</p>
<h3 class="h3" id="lev112"><span epub:type="pagebreak" id="page_90"/><strong>Challenge Projects</strong></h3>
<p class="noindent">No solutions are provided for challenge projects.</p>
<h4 class="h4" id="lev113"><strong><em>Route Cipher Encoder</em></strong></h4>
<p class="noindent">A greenhorn Union telegraph clerk needs to encrypt the following message, complete with code words (<a href="ch04.xhtml#ch04tab1">Table 4-1</a>). Help them out by writing a program that takes the message as input and automatically substitutes the code words, fills the bottom row with dummy words, and transposes the words using the key <code>[-1, 3, -2, 6, 5, -4]</code>. Use a 6×7 matrix and make up your own dummy words.</p>
<p class="bq">We will run the batteries at Vicksburg the night of April 16 and proceed to Grand Gulf where we will reduce the forts. Be prepared to cross the river on April 25 or 29. Admiral Porter.</p>
<p class="tabcap" id="ch04tab1"><strong>Table 4-1:</strong> Code Words</p>
<table class="topbot-d">
<tbody>
<tr>
<td style="vertical-align: top;" class="table-ca"><p class="taba">Batteries</p></td>
<td style="vertical-align: top;" class="table-ca"><p class="taba">HOUNDS</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">Vicksburg</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">ODOR</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">April</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">CLAYTON</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">16</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">SWEET</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">Grand</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">TREE</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">Gulf</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">OWL</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">Forts</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">BAILEY</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">River</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">HICKORY</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">25</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">MULTIPLY</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">29</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">ADD</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">Admiral</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">HERMES</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-c"><p class="taba">Porter</p></td>
<td style="vertical-align: top;" class="table-c"><p class="taba">LANGFORD</p></td>
</tr>
</tbody>
</table>
<p class="indent">Consider using a Python dictionary for the lexicon of code words in this table.</p>
<h4 class="h4" id="lev114"><strong><em>Three-Rail Fence Cipher</em></strong></h4>
<p class="noindent">Write a version of the rail fence cipher that uses three rails (rows) instead of two. You can find a hint at <em><a href="https://en.wikipedia.org/wiki/Rail_fence_cipher">https://en.wikipedia.org/wiki/Rail_fence_cipher</a></em>.</p>
</body></html>