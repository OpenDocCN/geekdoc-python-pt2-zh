- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Sorting and Searching
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和查找
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/circleart.png)'
- en: There are a few workhorse algorithms we use in nearly every kind of program.
    Sometimes these algorithms are so fundamental that we take them for granted or
    don’t even realize our code is relying on them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有类型的程序中，我们都会使用一些基础的算法。有时这些算法是如此基本，以至于我们把它们视为理所当然，甚至没有意识到我们的代码依赖于它们。
- en: Several methods for sorting and searching are among these fundamental algorithms.
    They’re worth knowing because they’re commonly used and beloved by algorithm enthusiasts
    (and the sadists who give coding interviews). The implementation of these algorithms
    can be short and simple, but every character matters, and since they are so commonly
    needed, computer scientists have striven to enable them to sort and search with
    mind-melting speed. So we’ll also use this chapter to discuss algorithm speed
    and the special notation we use to compare algorithms’ efficiencies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和查找的几种方法属于这些基础算法之一。它们值得了解，因为它们被广泛使用，并且深受算法爱好者（以及那些让人痛苦的面试官）的喜爱。这些算法的实现可以非常简短和简单，但每个字符都至关重要，由于它们需求如此广泛，计算机科学家们一直致力于使它们能够以惊人的速度进行排序和查找。因此，我们还将在本章讨论算法速度和比较算法效率时使用的特殊符号。
- en: We start by introducing insertion sort, a simple and intuitive sorting algorithm.
    We discuss the speed and efficiency of insertion sort and how to measure algorithm
    efficiency in general. Next, we look at merge sort, a faster algorithm that is
    the current state of the art for searching. We also explore sleep sort, a strange
    algorithm that isn’t used much in practice but is interesting as a curiosity.
    Finally, we discuss binary search and show some interesting applications of searching,
    including inverting mathematical functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍插入排序，这是一种简单直观的排序算法。我们将讨论插入排序的速度和效率，并了解如何衡量算法的效率。接下来，我们将介绍归并排序，这是一种更快速的算法，目前是搜索算法中的先进技术。我们还会探讨睡眠排序，这是一种奇怪的算法，虽然在实践中不常用，但作为一种好奇心的产物还是值得关注。最后，我们将讨论二分查找，并展示一些有趣的查找应用，包括反转数学函数。
- en: Insertion Sort
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入排序
- en: Imagine that you’ve been asked to sort all the files in a filing cabinet. Each
    file has a number assigned to it, and you need to rearrange the files so that
    the file with the lowest number is first in the cabinet, the file with the highest
    number is last, and the files’ numbers proceed in order in between.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被要求整理文件柜中的所有文件。每个文件都有一个编号，你需要将这些文件重新排序，使得编号最小的文件排在最前面，编号最大的文件排在最后，其他文件的编号按顺序排列。
- en: Whatever method you follow as you sort the filing cabinet, we can describe it
    as a “sorting algorithm.” But before you even think of opening Python to code
    an algorithm for this, take a moment to pause and consider how you would sort
    such a filing cabinet in real life. This may seem like a mundane task, but allow
    the adventurer within you to creatively consider a broad range of possibilities.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你采用什么方法来整理文件柜，我们都可以将其描述为一种“排序算法”。但在你打开 Python 编程来实现该算法之前，先停下来想一想，如何在现实生活中整理这个文件柜。这个任务看似普通，但请让你内心的冒险者发挥创造力，考虑一系列广泛的可能性。
- en: 'In this section, we present a very simple sorting algorithm called *insertion
    sort*. This method relies on looking at each item in a list one at a time and
    inserting it into a new list that ends up being correctly sorted. Our algorithm’s
    code will have two sections: an insertion section, which performs the humble task
    of inserting a file into a list, and a sorting section, which performs insertion
    repeatedly until we have completed our sorting task.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍一种非常简单的排序算法，叫做*插入排序*。该方法依赖于逐个查看列表中的每个项目，并将其插入到一个新的列表中，最终该列表是按正确顺序排序的。我们算法的代码将分为两个部分：插入部分，它执行将文件插入列表的简单任务；以及排序部分，它重复执行插入操作，直到完成排序任务。
- en: Putting the Insertion in Insertion Sort
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将“插入”放入插入排序
- en: First, consider the task of insertion itself. Imagine that you have a filing
    cabinet whose files are already perfectly sorted. If someone hands you one new
    file and asks you to insert it into the right (sorted) position in the filing
    cabinet, how do you accomplish that? The task may seem so simple that it doesn’t
    warrant an explanation, or even the possibility of one (*just do it!* you might
    think). But in the world of algorithms, every task, however humble, must be explained
    completely.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑插入任务本身。假设你有一个文件柜，里面的文件已经排序好。如果有人递给你一个新文件，让你将它插入到文件柜中合适的（已排序的）位置，你该如何完成这个任务？这项任务可能看起来如此简单，以至于不需要解释，甚至不需要考虑任何可能性（*直接做就行！*你可能会这样想）。但是在算法的世界里，每个任务，不论多么简单，都必须完全解释清楚。
- en: The following method describes a reasonable algorithm for inserting one file
    into a sorted filing cabinet. We’ll call the file we need to insert the “file
    to insert.” We’ll say that we can compare two files and call one file “higher
    than” the other one. This could mean that one file’s assigned number is higher
    than the other’s assigned number, or it could mean that it’s higher in an alphabetical
    or other ordering.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法描述了一种合理的算法，用于将一个文件插入到已排序的文件柜中。我们将要插入的文件称为“要插入的文件”。我们假设我们可以比较两个文件，并称一个文件“高于”另一个文件。这可能意味着一个文件的编号比另一个文件的编号高，或者它可能在字母顺序或其他排序中排得更靠前。
- en: Select the highest file in the filing cabinet. (We’ll start at the back of the
    cabinet and work our way to the front.)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件柜中最高的文件。（我们将从文件柜的底部开始，逐步向前移动。）
- en: Compare the file you have selected with the file to insert.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你选择的文件与要插入的文件进行比较。
- en: If the file you have selected is lower than the file to insert, place the file
    to insert one position behind that file.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你选择的文件比要插入的文件低，就将要插入的文件放在该文件后面一个位置。
- en: If the file you have selected is higher than the file to insert, select the
    next highest file in the filing cabinet.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你选择的文件比要插入的文件高，选择文件柜中下一个较高的文件。
- en: Repeat steps 2 to 4 until you have inserted your file or compared it with every
    existing file. If you have not yet inserted your file after comparing it with
    every existing file, insert it at the beginning of the filing cabinet.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到4，直到你插入了文件，或者与每个现有文件进行了比较。如果在与每个现有文件比较后你还没有插入文件，则将其插入到文件柜的最前面。
- en: That method should more or less match the intuition you have for how to insert
    a record into a sorted list. If you prefer, you could also start at the beginning
    of the list, instead of the end, and follow an analogous process with the same
    results. Notice that we haven’t just inserted a record; we’ve inserted a record
    *in the correct position*, so after insertion, we’ll still have a sorted list.
    We can write a script in Python that executes this insertion algorithm. First,
    we can define our sorted filing cabinet. In this case, our filing cabinet will
    be a Python list, and our files will simply be numbers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法应该或多或少与你插入记录到已排序列表中的直觉相匹配。如果你愿意，也可以从列表的开头开始，而不是从末尾开始，并按照类似的过程进行，结果也是一样的。注意，我们不仅仅是插入了一个记录；我们是将记录插入了*正确的位置*，所以插入后，我们仍然会得到一个已排序的列表。我们可以编写一个Python脚本来执行这个插入算法。首先，我们可以定义我们的排序文件柜。在这个例子中，我们的文件柜将是一个Python列表，而我们的文件将仅仅是数字。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, we can define the “file” (in this case, just a number) that we want to
    insert into our cabinet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义我们想要插入到文件柜中的“文件”（在这个例子中只是一个数字）。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We proceed one at a time through every number in the list (every file in the
    cabinet). We’ll define a variable called `check_location`. As advertised, it will
    store the location in the cabinet that we want to check. We start at the back
    of the cabinet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按顺序逐一处理列表中的每个数字（文件柜中的每个文件）。我们将定义一个变量叫做`check_location`。如广告所示，它将存储我们想要检查的文件柜位置。我们从文件柜的最底部开始：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ll also define a variable called `insert_location`. The goal of our algorithm
    is to determine the proper value of `insert_location`, and then it’s a simple
    matter of inserting the file at the `insert_location`. We’ll start out by assuming
    the `insert_location` is 0:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个变量叫做`insert_location`。我们算法的目标是确定`insert_location`的正确值，然后只需将文件插入到`insert_location`即可。我们将假设`insert_location`的初始值为0：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we can use a simple `if` statement to check whether the file to insert
    is higher than the file at the `check_location`. As soon as we encounter a number
    that’s lower than the number to insert, we use its location to decide where to
    insert our new number. We add 1 because our insertion takes place just behind
    the lower number we found:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用一个简单的`if`语句检查要插入的文件是否大于位于`check_location`的文件。一旦我们遇到一个比要插入的数字小的数字，就可以使用其位置来决定新数字的插入位置。我们加1是因为插入的位置就在我们找到的较小数字之后：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we know the right `insert_location`, we can use a built-in Python method
    for list manipulation called `insert` to put the file into the cabinet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确定了正确的`insert_location`之后，可以使用Python内置的列表操作方法`insert`将文件插入到文件柜中：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running this code will not work to insert our file properly yet, however. We
    need to put these steps together in one coherent insertion function. This function
    combines all of the previous code and also adds a `while` loop. The `while` loop
    is used to iterate over the files in the cabinet, starting with the last file
    and proceeding until either we find the right `insert_location` or we have examined
    every file. The final code for our cabinet insertion is in [Listing 4-1](#listing4-1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行这段代码仍然不能正确插入文件。我们需要将这些步骤整合到一个连贯的插入函数中。这个函数将所有之前的代码合并在一起，并且还添加了一个`while`循环。`while`循环用于遍历文件柜中的文件，从最后一个文件开始，直到我们找到合适的`insert_location`，或者检查完所有文件。文件柜插入的最终代码在[示例
    4-1](#listing4-1)中。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Listing 4-1:](#listinganchor4-1) Inserting a numbered file into our cabinet'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-1：](#listinganchor4-1) 将一个编号文件插入到我们的文件柜中'
- en: When you run the code in [Listing 4-1](#listing4-1), it will print out `newcabinet`,
    which you can see includes our new “file,” 5, inserted into our cabinet at the
    correct location (between 4 and 6).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[示例 4-1](#listing4-1)中的代码时，它会输出`newcabinet`，你可以看到，5这个新“文件”已经按正确的位置（4和6之间）插入到文件柜中了。
- en: 'It’s worthwhile to think for a moment about one edge case of insertion: inserting
    into an empty list. Our insertion algorithm mentioned “proceeding sequentially
    through every file in the filing cabinet.” If there are no files in the filing
    cabinet, then there is nothing to proceed through sequentially. In this case,
    we need to heed only the last sentence, which tells us to insert our new file
    at the beginning of the cabinet. Of course, this is easier done than said, because
    the beginning of an empty cabinet is also the end and the middle of the cabinet.
    So all we need to do in this case is insert the file into the cabinet without
    regard to position. We can do this by using the `insert()` function in Python
    and inserting at location 0.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在值得花一点时间思考插入的一个极端情况：插入到一个空列表中。我们的插入算法提到过“依次处理文件柜中的每个文件”。如果文件柜中没有文件，那么就没有什么可以依次处理的了。在这种情况下，我们只需要关注最后一句话，它告诉我们将新文件插入到柜子的开头。当然，这比说起来容易，因为空文件柜的开头也是文件柜的结尾和中间。因此，在这种情况下，我们所需要做的就是把文件插入到柜子里，而不必考虑位置。我们可以通过使用Python中的`insert()`函数，并在位置0插入文件来做到这一点。
- en: Sorting via Insertion
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过插入排序
- en: 'Now that we’ve rigorously defined insertion and know how to perform it, we’re
    almost at the point where we can perform an insertion sort. Insertion sort is
    simple: it takes each element of an unsorted list one at a time and uses our insertion
    algorithm to insert it correctly into a new, sorted list. In filing cabinet terms,
    we start with an unsorted filing cabinet, which we’ll call “old cabinet,” and
    an empty cabinet, which we’ll call “new cabinet.” We remove the first element
    of our old unsorted cabinet and add it to our new empty cabinet, using the insertion
    algorithm. We do the same with the second element of the old cabinet, then the
    third, and so on until we have inserted every element of the old cabinet into
    the new cabinet. Then, we forget about the old cabinet and use only our new, sorted
    cabinet. Since we’ve been inserting using our insertion algorithm, and it always
    returns a sorted list, we know that our new cabinet will be sorted at the end
    of the process.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经严格定义了插入操作并知道如何执行它，我们几乎可以开始执行插入排序了。插入排序很简单：它一次处理未排序列表中的每个元素，并使用我们的插入算法将其正确地插入到一个新的已排序列表中。在文件柜的术语中，我们从一个未排序的文件柜开始，称之为“旧文件柜”，以及一个空的文件柜，称之为“新文件柜”。我们移除旧文件柜中的第一个元素，并使用插入算法将其添加到新的空文件柜中。我们对旧文件柜中的第二个元素执行相同操作，然后是第三个，以此类推，直到将所有旧文件柜中的元素都插入到新文件柜中。然后，我们忘记旧文件柜，只使用新的已排序文件柜。由于我们一直在使用插入算法进行插入，而且该算法总是返回一个排序好的列表，因此我们知道在过程结束时，我们的新文件柜将是已排序的。
- en: 'In Python, we start with an unsorted cabinet and an empty `newcabinet`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们从一个未排序的文件柜和一个空的`newcabinet`开始：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We implement insertion sort by repeatedly calling our `insert_cabinet()` function
    from [Listing 4-1](#listing4-1). In order to call it, we’ll need to have a file
    in our “hand,” which we accomplish by popping it out of the unsorted cabinet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过反复调用我们的`insert_cabinet()`函数来实现插入排序，这个函数来自于[列表 4-1](#listing4-1)。为了调用它，我们需要手中有一个文件，这通过从未排序的文件柜中弹出文件来实现：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this snippet, we used a method called `pop()`. This method removes a list
    element at a specified index. In this case, we removed the element of `cabinet`
    at index 0\. After we use `pop()`, `cabinet` no longer contains that element,
    and we store it in the variable `to_insert` so that we can put it into the `newcabinet`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用了一种名为`pop()`的方法。这个方法会移除指定索引位置的列表元素。在本例中，我们移除了`cabinet`中索引为0的元素。使用`pop()`后，`cabinet`不再包含该元素，我们将它存储在变量`to_insert`中，以便将其放入`newcabinet`。
- en: We’ll put all of this together in [Listing 4-2](#listing4-2), where we define
    an `insertion_sort()` function that loops through every element of our unsorted
    cabinet, inserting the elements one by one into `newcabinet`. Finally, at the
    end, we print out the result, a sorted cabinet called `sortedcabinet`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[列表 4-2](#listing4-2)中把这一切结合起来，在那里我们定义了一个`insertion_sort()`函数，它循环遍历未排序的文件柜中的每个元素，将元素一个一个地插入到`newcabinet`中。最后，在过程的末尾，我们打印出结果，即一个名为`sortedcabinet`的已排序文件柜。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Listing 4-2:](#listinganchor4-2) An implementation of insertion sort'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-2:](#listinganchor4-2) 插入排序的实现'
- en: Now that we can do insertion sort, we can sort any list we encounter. We may
    be tempted to think that this means we have all the sorting knowledge we’ll ever
    need. However, sorting is so fundamental and important that we want to be able
    to do it in the best possible way. Before we discuss alternatives to insertion
    sort, let’s look at what it means for one algorithm to be better than another
    and, on an even more basic level, what it means for an algorithm to be good.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经能够实现插入排序，那么我们就可以对任何遇到的列表进行排序了。我们可能会倾向于认为这意味着我们已经掌握了所有需要的排序知识。然而，排序是如此基础和重要，我们希望能够以最佳的方式来完成它。在讨论插入排序的替代方法之前，让我们先看看什么意味着一个算法比另一个更好，并且更基本地，什么才算是一个好的算法。
- en: Measuring Algorithm Efficiency
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量算法效率
- en: Is insertion sort a good algorithm? This question is hard to answer unless we’re
    sure about what we mean by “good.” Insertion sort works—it sorts lists—so it’s
    good in the sense that it accomplishes its purpose. Another point in its favor
    is that it’s easy to understand and explain with reference to physical tasks that
    many people are familiar with. Yet another feather in its cap is that it doesn’t
    take too many lines of code to express. So far, insertion sort seems like a good
    algorithm.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序是一个好的算法吗？这个问题很难回答，除非我们明确知道“好”是什么意思。插入排序有效——它能够排序列表——所以从它完成目标的意义上来说，它是好的。另一个优点是，它很容易理解，并且可以通过许多人熟悉的物理任务来解释。它的又一个优势是，表达它所需的代码行数不多。到目前为止，插入排序看起来是一个好的算法。
- en: 'However, insertion sort has one crucial failing: it takes a long time to perform.
    The code in [Listing 4-2](#listing4-2) almost certainly ran in less than one second
    on your computer, so the “long time” that insertion sort takes is not the long
    time that it takes for a tiny seed to become a mighty redwood or even the long
    time that it takes to wait in line at the DMV. It’s more like a long time in comparison
    to how long it takes a gnat to flap its wings once.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，插入排序有一个关键的缺陷：它需要很长时间来执行。[示例 4-2](#listing4-2)中的代码几乎肯定在你的计算机上运行不到一秒钟，因此插入排序所需的“长时间”并不是指像小种子成长为参天红木那样的漫长时光，也不是指在车管所排队等待的长时间。它更像是与一只蚊子拍一次翅膀所需的时间相比的“长时间”。
- en: To fret about a gnat’s wing flap as a “long time” may seem a little extreme.
    But there are several good reasons to push algorithms as close as possible to
    zero-second running times.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 担心一只小蚊子拍翅膀所需要的“长时间”似乎有些极端。但推向零秒运行时间是有几个合理的原因的。
- en: Why Aim for Efficiency?
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么追求效率？
- en: The first reason to relentlessly pursue algorithm efficiency is that it can
    increase our raw capabilities. If your inefficient algorithm takes one minute
    to sort an eight-item list, that may not seem like a problem. But consider that
    such an inefficient algorithm might take an hour to sort a thousand-item list,
    and a week to sort a million-item list. It may take a year or a century to sort
    a billion-item list, or it may not be able to sort it at all. If we make the algorithm
    better able to sort an eight-item list (something that seems trivial since it
    saves us only a minute), it may make the difference between being able to sort
    a billion-item list in an hour rather than a century, which can open up many possibilities.
    Advanced machine-learning methods like k-means clustering and k-NN supervised
    learning rely on ordering long lists, and improving the performance of a fundamental
    algorithm like sorting can enable us to perform these methods on big datasets
    that would otherwise be beyond our grasp.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不断追求算法效率的第一个原因是它能提升我们的基础能力。如果你的低效算法排序一个八项列表需要一分钟，可能看起来不成问题。但假设这种低效算法排序一个千项列表需要一小时，排序一个百万项列表需要一周，排序一个十亿项列表可能需要一年甚至一个世纪，或者根本无法完成排序。如果我们能够改善这个算法，让它能更有效地排序一个八项列表（虽然它只节省了一分钟，但似乎是微不足道的），那可能就能在一小时内排序一个十亿项的列表，而不是一个世纪，这能开启许多可能性。像k均值聚类和k-NN监督学习这样的高级机器学习方法依赖于对长列表的排序，而改进排序等基础算法的性能可以使我们在处理庞大的数据集时，能够执行这些方法，否则这些数据集可能会超出我们的掌控。
- en: Even sorting short lists is important to do quickly if it’s something that we
    have to do many times. The world’s search engines, for example, collectively receive
    a trillion searches every few months and have to order each set of results from
    most to least relevant before delivering them to users. If they can cut the time
    required for one simple sort from one second to half a second, they cut their
    required processing time from a trillion seconds to half a trillion seconds. This
    saves time for users (saving a thousand seconds for half a billion people really
    adds up!) and reduces data processing costs, and by consuming less energy, efficient
    algorithms are even environmentally friendly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是对短列表的排序，如果是我们需要多次执行的任务，也应该尽量快速完成。例如，全球的搜索引擎每几个月就会收到万亿次搜索，并且必须按相关性从高到低对每一组结果进行排序，然后再呈现给用户。如果它们能将一次简单排序所需的时间从一秒钟减少到半秒钟，它们就能将所需的处理时间从万亿秒减少到半万亿秒。这为用户节省了时间（为五亿人节省一千秒真的是个大数！），同时降低了数据处理成本，而通过减少能量消耗，高效的算法也更环保。
- en: 'The final reason to create faster algorithms is the same reason that people
    try to do better in any pursuit. Even though there is no obvious need for it,
    people try to run the 100-meter dash faster, play chess better, and cook a tastier
    pizza than anyone ever has before. They do these things for the same reason George
    Mallory said he wanted to climb Mount Everest: “because it’s there.” It’s human
    nature to push the boundaries of the possible and strive to be better, faster,
    stronger, and more intelligent than anyone else. Algorithm researchers are trying
    to do better because, among other reasons, they wish to do something remarkable,
    whether or not it is practically useful.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更快算法的最终原因与人们在任何追求中试图做得更好的原因相同。即使没有明显的需求，人们也会试图跑得更快，棋下得更好，做出比以往任何人更美味的披萨。他们这样做的原因正如乔治·马洛里所说的，他想攀登珠穆朗玛峰：“因为它在那里。”人类天生就有推动可能性边界的欲望，努力变得更好、更快、更强大、更聪明。算法研究人员之所以想做得更好，部分原因是他们希望做出一些令人瞩目的事情，无论它是否在实际中有用。
- en: Measuring Time Precisely
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精确测量时间
- en: Since the time required for an algorithm to run is so important, we should be
    more precise than saying that insertion sort takes a “long time” or “less than
    a second.” How long, exactly, does it take? For a literal answer, we can use the
    `timeit` module in Python. With `timeit`, we can create a timer that we start
    just before running our sorting code and end just afterward. When we check the
    difference between the starting time and the ending time, we find how long it
    took to run our code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法运行所需的时间非常重要，我们应该比说插入排序“很长时间”或“不到一秒”更精确。究竟需要多长时间？为了得到确切的答案，我们可以使用 Python
    中的 `timeit` 模块。通过 `timeit`，我们可以创建一个计时器，在运行排序代码前启动，并在运行之后结束。当我们检查开始时间和结束时间的差异时，就能得出代码运行所需的时间。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When I ran this code on my consumer-grade laptop, it ran in about 0.0017 seconds.
    This is a reasonable way to express how good insertion sort is—it can fully sort
    a list with eight items in 0.0017 seconds. If we want to compare insertion sort
    with any other sorting algorithm, we can compare the results of this `timeit`
    timing to see which is faster, and say the faster one is better.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在我的消费级笔记本电脑上运行这段代码时，它大约花了 0.0017 秒。这是表达插入排序好坏的一种合理方式——它可以在 0.0017 秒内完全排序一个包含八个项目的列表。如果我们想将插入排序与其他排序算法进行比较，我们可以通过比较这个
    `timeit` 定时的结果来看哪个更快，并认为更快的那个更好。
- en: However, using these timings to compare algorithm performance has some problems.
    For example, when I ran the timing code a second time on my laptop, I found that
    it ran in 0.0008 seconds. A third time, I found that it ran on another computer
    in 0.03 seconds. The precise timing you get depends on the speed and architecture
    of your hardware, the current load on your operating system (OS), the version
    of Python you’re running, the OS’s internal task schedulers, the efficiency of
    your code, and probably other chaotic vagaries of randomness and electron motion
    and the phases of the moon. Since we can get very different results in each timing
    attempt, it’s hard to rely on timings to communicate about algorithms’ comparative
    efficiency. One programmer may brag that they can sort a list in *Y* seconds,
    while another programmer laughs and says that their algorithm gets better performance
    in *Z* seconds. We might find out they are running exactly the same code, but
    on different hardware at different times, so their comparison is not of algorithm
    efficiency but rather of hardware speed and luck.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这些定时来比较算法性能存在一些问题。例如，当我第二次在笔记本电脑上运行定时代码时，我发现它只用了 0.0008 秒。第三次，我发现它在另一台电脑上运行用了
    0.03 秒。你得到的精确时长取决于你的硬件的速度和架构、操作系统（OS）的当前负载、你运行的 Python 版本、操作系统内部的任务调度器、代码的效率，可能还有其他随机性的混乱因素、电子运动以及月相等。由于每次定时尝试可能会得到非常不同的结果，因此很难仅依赖定时来比较算法的效率。一位程序员可能吹嘘说他们能在
    *Y* 秒内排序一个列表，而另一位程序员则笑着说他们的算法在 *Z* 秒内得到更好的性能。我们可能会发现他们运行的其实是完全相同的代码，但在不同的硬件上、不同的时间运行，因此他们的比较并不是算法效率的比较，而是硬件速度和运气的比较。
- en: Counting Steps
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算步骤
- en: Instead of using timings in seconds, a more reliable measure of algorithm performance
    is the number of steps required to execute the algorithm. The number of steps
    an algorithm takes is a feature of the algorithm itself and isn’t dependent on
    the hardware architecture or even necessarily on the programming language. [Listing
    4-3](#listing4-3) is our insertion sort code from Listings 4-1 and 4-2 with several
    lines added where we have specified `stepcounter+=1`. We increase our step counter
    every time we pick up a new file to insert from the old cabinet, every time we
    compare that file to another file in the new cabinet, and every time we insert
    the file into the new cabinet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用秒数作为时间度量，更可靠的算法性能衡量标准是执行算法所需的步骤数。算法所需的步骤数是算法本身的特性，它不依赖于硬件架构，甚至不一定依赖于编程语言。[清单
    4-3](#listing4-3) 是我们在清单 4-1 和 4-2 中的插入排序代码，增加了几行代码，其中我们指定了 `stepcounter+=1`。每次我们从旧列表中取出一个新元素插入时，每次我们将该元素与新列表中的其他元素进行比较时，以及每次我们将该元素插入新列表时，都会增加我们的步骤计数器。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Listing 4-3:](#listinganchor4-3) Our insertion sort code with a step counter'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3:](#listinganchor4-3) 我们带有步骤计数器的插入排序代码'
- en: In this case, we can run this code and see that it performs 36 steps in order
    to accomplish the insertion sort for a list of length 8\. Let’s try to perform
    insertion sort for lists of other lengths and see how many steps we take.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以运行这段代码，看到它需要执行 36 步才能完成一个长度为 8 的列表的插入排序。让我们尝试对其他长度的列表进行插入排序，看看需要多少步骤。
- en: 'To do so, let’s write a function that can check the number of steps required
    for insertion sort for unsorted lists of different lengths. Instead of manually
    writing out each unsorted list, we can use a simple list comprehension in Python
    to generate a random list of any specified length. We can import Python’s `random`
    module to make the random creation of lists easier. Here’s how we can create a
    random unsorted cabinet of length 10:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，让我们编写一个函数，检查不同长度的未排序列表进行插入排序所需的步骤数。我们可以使用 Python 中的简单列表推导式生成任意指定长度的随机列表，而不是手动编写每个未排序的列表。我们可以导入
    Python 的 `random` 模块，使得随机生成列表变得更加容易。以下是如何生成一个长度为 10 的随机未排序列表：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our function will simply generate a list of some given length, run our insertion
    sort code, and return the final value it finds for `stepcounter`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数将简单地生成一个给定长度的列表，运行我们的插入排序代码，并返回它找到的 `stepcounter` 最终值。
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s create a list of all numbers between 1 and 100 and check the number of
    steps required to sort lists of each length.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含 1 到 100 之间所有数字的列表，并检查对每个长度的列表进行排序所需的步骤数。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we start by calling the `random.seed()` function. This is not
    necessary but will ensure that you see the same results as those printed here
    if you run the same code. You can see that we define sets of values for *x*, stored
    in `xs`, and a set of values for *y*, stored in `ys`. The *x* values are simply
    the numbers between 1 and 100, and the *y* values are the number of steps required
    to sort randomly generated lists of each size corresponding to each *x*. If you
    look at the output, you can see how many steps insertion sort took to sort randomly
    generated lists of lengths 1, 2, 3 . . . , all the way to 99\. We can plot the
    relationship between list length and sorting steps as follows. We’ll import `matplotlib.pyplot`
    in order to accomplish the plotting.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先调用 `random.seed()` 函数。这不是必需的，但如果你运行相同的代码，它将确保你看到的结果与这里打印的一致。你可以看到，我们定义了
    *x* 的值集，存储在 `xs` 中，以及 *y* 的值集，存储在 `ys` 中。*x* 值只是 1 到 100 之间的数字，*y* 值是对应每个 *x*
    的随机生成的列表所需的排序步骤数。如果你查看输出，你可以看到插入排序对长度从 1 到 99 的随机生成列表所需的步骤数。我们可以绘制列表长度和排序步骤之间的关系，如下所示。我们将导入
    `matplotlib.pyplot` 来完成绘图。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 4-1](#figure4-1) shows the output. You can see that the output curve
    is a little jagged—sometimes a longer list will be sorted in fewer steps than
    will a shorter list. The reason for this is that we generated every list randomly.
    Occasionally our random list generation code will create a list that’s easy for
    insertion sort to deal with quickly (because it’s already partially sorted), and
    occasionally it will create a list that is harder to deal with quickly, strictly
    through random chance. For this same reason, you may find that the output on your
    screen doesn’t look exactly like the output printed here if you don’t use the
    same random seed, but the general shape should be the same.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1](#figure4-1)展示了输出结果。你可以看到输出曲线有些锯齿状——有时较长的列表会比较短的列表排序所需的步骤更少。之所以会这样，是因为我们每次都随机生成列表。偶尔，我们的随机列表生成代码会创建一个插入排序可以快速处理的列表（因为它已经部分排序），而偶尔它会创建一个通过纯随机方式难以快速处理的列表。由于这个原因，如果你没有使用相同的随机种子，你可能会发现屏幕上的输出与这里打印的结果不完全一样，但整体形状应该是相同的。'
- en: '![figure_4-1](Images/figure_4-1.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![figure_4-1](Images/figure_4-1.png)'
- en: '[Figure 4-1:](#figureanchor4-1) Insertion sort steps'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1:](#figureanchor4-1) 插入排序步骤'
- en: Comparing to Well-Known Functions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与著名函数的比较
- en: Looking beyond the superficial jaggedness of [Figure 4-1](#figure4-1), we can
    examine the general shape of the curve and try to reason about its growth rate.
    The number of steps required appears to grow quite slowly between *x* = 1 and
    about *x* = 10\. After that, it seems to slowly get steeper (and more jagged).
    Between about *x* = 90 and *x* = 100, the growth rate appears very steep indeed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 超越[图4-1](#figure4-1)表面上的锯齿状，我们可以检查曲线的一般形状，并尝试推测其增长速率。从*x* = 1到大约*x* = 10之间，所需的步骤数增长得相当缓慢。之后，它似乎开始逐渐变陡（而且更加锯齿状）。在大约*x*
    = 90到*x* = 100之间，增长速率确实变得非常陡峭。
- en: Saying that the plot gets gradually steeper as the list length increases is
    still not as precise as we want to be. Sometimes we talk colloquially about this
    kind of accelerating growth as “exponential.” Are we dealing with exponential
    growth here? Strictly speaking, there is a function called the *exponential function*
    defined by *e*^(*x*), where *e* is Euler’s number, or about 2.71828\. So does
    the number of steps required for insertion sort follow this exponential function
    that we could say fits the narrowest possible definition of exponential growth?
    We can get a clue about the answer by plotting our step curve together with an
    exponential growth curve, as follows. We will also import the `numpy` module in
    order to take the maximum and minimum of our step values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 说随着列表长度的增加，图表逐渐变陡，这样的说法仍然不够精确。我们有时口语中会把这种加速增长称为“指数型”。我们这里是在处理指数增长吗？严格来说，有一个叫做*指数函数*的函数，它由*e*^(*x*)定义，其中*e*是欧拉数，约等于2.71828。那么，插入排序所需的步骤数是否遵循这个指数函数，从而可以说它符合最狭义的指数增长定义呢？我们可以通过将我们的步骤曲线与指数增长曲线一起绘制来获取答案的线索，方法如下。我们还将导入`numpy`模块，以便获取步骤值的最大值和最小值。
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Just like before, we define `xs` to be all the numbers between 1 and 100, and
    `ys` to be the number of steps required to sort randomly generated lists of each
    size corresponding to each *x*. We also define a variable called `ys_exp`, which
    is *e*^(*x*) for each of the values stored in `xs`. We then plot both `ys` and
    `ys_exp` on the same plot. The result enables us to see how the growth of the
    number of steps required to sort a list relates to true exponential growth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们定义`xs`为1到100之间的所有数字，`ys`为排序每个大小对应的随机生成列表所需的步骤数。我们还定义了一个变量`ys_exp`，它是每个存储在`xs`中的值对应的*e*^(*x*)。然后，我们将`ys`和`ys_exp`都绘制在同一个图表上。这个结果让我们能够看到排序一个列表所需步骤的增长与真正的指数增长之间的关系。
- en: Running this code creates the plot shown in [Figure 4-2](#figure4-2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会生成[图4-2](#figure4-2)所示的图表。
- en: '![figure_4-2](Images/figure_4-2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![figure_4-2](Images/figure_4-2.png)'
- en: '[Figure 4-2:](#figureanchor4-2) Insertion sort steps compared to the exponential
    function'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-2:](#figureanchor4-2) 插入排序步骤与指数函数的比较'
- en: We can see the true exponential growth curve shooting up toward infinity on
    the left side of the plot. Though the insertion sort step curve grows at an accelerating
    rate, its acceleration does not seem to get close to matching true exponential
    growth. If you plot other curves whose growth rate could also be called exponential,
    2^(*×*) or 10^(*×*), you’ll see that all of these types of curves also grow much
    faster than our insertion sort step counter curve does. So if the insertion sort
    step curve doesn’t match exponential growth, what kind of growth might it match?
    Let’s try to plot a few more functions on the same plot. Here, we’ll plot *y*
    = *x*, *y* = *x*^(1.5), *y* = *x*², and *y* = *x*³ along with the insertion sort
    step curve.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This results in [Figure 4-3](#figure4-3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_4-3](Images/figure_4-3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-3:](#figureanchor4-3) Insertion sort steps compared to other growth
    rates'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There are five growth rates plotted in [Figure 4-3](#figure4-3), in addition
    to the jagged curve counting the steps required for insertion sort. You can see
    that the exponential curve grows the fastest, and next to it the cubic curve scarcely
    even makes an appearance on the plot because it also grows so fast. The *y* =
    *x* curve grows extremely slowly compared to the other curves; you can see it
    at the very bottom of the plot.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The curves that are the closest to the insertion sort curve are *y* = *x*² and
    *y* = *x*^(1.5). It isn’t obvious which curve is most comparable to the insertion
    sort curve, so we cannot speak with certainty about the exact growth rate of insertion
    sort. But after plotting, we’re able to make a statement like “if we are sorting
    a list with *n* elements, insertion sort will take somewhere between *n*^(1.5)
    and *n*² steps.” This is a more precise and robust statement than “as long as
    a gnat’s wing flap” or “.002-ish seconds on my unique laptop this morning.”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Adding Even More Theoretical Precision
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get even more precise, we should try to reason carefully about the steps
    required for insertion sort. Let’s imagine, once again, that we have a new unsorted
    list with *n* elements. In [Table 4-2](#table4-2), we proceed through each step
    of insertion sort individually and count the steps.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**[Table 4-2:](#tableanchor4-2)** Counting the Steps in Insertion Sort'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description of actions** | **Number of steps required for pulling the file
    from the old cabinet** | **Maximum number of steps required for comparing to other
    files** | **Number of steps required for inserting the file into the new cabinet**
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| Take the first file from the old cabinet and insert it into the (empty) new
    cabinet. | 1 | 0\. (There are no files to compare to.) | 1 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| Take the second file from the old cabinet and insert it into the new cabinet
    (that now contains one file). | 1 | 1\. (There’s one file to compare to and we
    have to compare it.) | 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| Take the third file from the old cabinet and insert it into the new cabinet
    (that now contains two files). | 1 | 2 or fewer. (There are two files and we have
    to compare between 1 of them and all of them.) | 1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 从旧柜子中取出第三个文件，并将其插入到新柜子中（新柜子现在包含两个文件）。 | 1 | 2个或更少。（有两个文件，我们需要在其中一个文件和所有文件之间进行比较。）
    | 1 |'
- en: '| Take the fourth file from the old cabinet and insert it into the new cabinet
    (that now contains three files). | 1 | 3 or fewer. (There are three files and
    we have to compare between 1 of them and all of them.) | 1 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 从旧柜子中取出第四个文件，并将其插入到新柜子中（新柜子现在包含三个文件）。 | 1 | 3个或更少。（有三个文件，我们需要在其中一个文件和所有文件之间进行比较。）
    | 1 |'
- en: '| . . . | . . . | . . . | . . . |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| . . . | . . . | . . . | . . . |'
- en: '| Take the *n*th file from the old cabinet and insert it into the new cabinet
    (that contains *n*   – 1 files). | 1 | *n*   – 1 or fewer. (There are *n*   – 1
    files and we have to compare between one of them and all of them.) | 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 从旧柜子中取出第*n*个文件，并将其插入到新柜子中（新柜子包含*n*   – 1个文件）。 | 1 | *n*   – 1个或更少。（有*n*   – 1个文件，我们需要在其中一个文件和所有文件之间进行比较。）
    | 1 |'
- en: 'If we add up all the steps described in this table, we get the following maximum
    total steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将表中描述的所有步骤加起来，我们得到以下的最大总步骤数：
- en: 'Steps required for pulling files: *n* (1 step for pulling each of *n* files)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取文件所需的步骤：*n*（每个*n*文件拉取需要1步）
- en: 'Steps required for comparison: up to 1 + 2 + . . . + (*n* – 1)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较所需的步骤：最多 1 + 2 + . . . + (*n* – 1)
- en: 'Steps required for inserting files: *n* (1 step for inserting each of *n* files)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入文件所需的步骤：*n*（每个*n*文件插入需要1步）
- en: 'If we add these up, we get an expression like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些加起来，我们得到如下的表达式：
- en: '![c04eq001](Images/c04eq001.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![c04eq001](Images/c04eq001.png)'
- en: 'We can simplify this expression using a handy identity:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个便捷的恒等式来简化这个表达式：
- en: '![c04eq002](Images/c04eq002.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![c04eq002](Images/c04eq002.png)'
- en: If we use this identity and then add everything together and simplify, we find
    that the total number of steps required is
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个恒等式并将所有内容加起来并简化，我们会发现所需的总步骤数是
- en: '![c04eq003](Images/c04eq003.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![c04eq003](Images/c04eq003.png)'
- en: We finally have a very precise expression for the maximum total steps that could
    be required to perform insertion sort. But believe it or not, this expression
    may even be too precise, for several reasons. One is that it’s the maximum number
    of steps required, but the minimum and the average could be much lower, and almost
    every conceivable list that we might want to sort would require fewer steps. Remember
    the jaggedness in the curve we plotted in [Figure 4-1](#figure4-1)—there’s always
    variation in how long it takes to perform an algorithm, depending on our choice
    of input.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到了一个非常精确的表达式，表示执行插入排序所需的最大总步骤数。但信不信由你，这个表达式甚至可能过于精确，原因有几个。其一是它表示的是所需的最大步骤数，而最小值和平均值可能要低得多，几乎每一个我们可能想要排序的列表所需的步骤都要少得多。记住我们在[图
    4-1](#figure4-1)中绘制的曲线的锯齿状——执行算法所需的时间总是会有所变化，这取决于我们选择的输入。
- en: Another reason that our expression for the maximum steps could be called too
    precise is that knowing the number of steps for an algorithm is most important
    for large values of *n*, but as *n* gets very large, a small part of the expression
    starts to dominate the rest in importance because of the sharply diverging growth
    rates of different functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最大步骤数的表达式可能被认为过于精确的另一个原因是，算法的步骤数对大*n*值最为重要，但随着*n*的增大，表达式中的小部分开始主导其余部分，因为不同函数的增长速率差异非常大。
- en: 'Consider the expression *n*² + *n*. It is a sum of two terms: an *n*² term,
    and an *n* term. When *n* = 10, *n*² + *n* is 110, which is 10% higher than *n*².
    When *n* = 100, *n*² + *n* is 10,100, which is only 1% higher than *n*². As *n*
    grows, the *n*² term in the expression becomes more important than the *n* term
    because quadratic functions grow so much faster than linear ones. So if we have
    one algorithm that takes *n*²+ *n* steps to perform and another algorithm that
    takes *n*² steps to perform, as *n* grows very large, the difference between them
    will matter less and less. Both of them run in more or less *n*² steps.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式*n*² + *n*。它是两个项的和：一个*n*²项和一个*n*项。当*n* = 10时，*n*² + *n*是110，比*n*²高10%。当*n*
    = 100时，*n*² + *n*是10,100，比*n*²高1%。随着*n*的增加，表达式中的*n*²项变得比*n*项更重要，因为二次函数增长速度远快于线性函数。所以，如果我们有一个算法需要*n*²
    + *n*步来执行，另一个算法需要*n*²步来执行，当*n*非常大时，它们之间的差异会越来越不重要。它们两个差不多都在*n*²步内运行。
- en: Using Big O Notation
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用大O符号表示法
- en: To say that an algorithm runs in more or less *n*² steps is a reasonable balance
    between the precision we want and the conciseness we want (and the randomness
    we have). The way we express this type of “more or less” relationship formally
    is by using *big O* notation(the *O* is short for *order*). We might say that
    a particular algorithm is “big O of *n*²,” or *O*(*n*²), if, in the worst case,
    it runs in more or less *n*² steps for large *n*. The technical definition states
    that the function *f*(*x*) is big- O of the function *g*(*x*) if there’s some
    constant number *M* such that the absolute value of *f*(*x*) is always less than
    *M* times *g*(*x*) for all sufficiently large values of *x*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个算法大致运行 *n*² 步是我们在精确度和简洁度之间的一种合理平衡（以及我们拥有的随机性）。我们以正式的方式表达这种“或多或少”关系是通过使用 *大O*
    表示法（*O* 是 *order* 的缩写）。我们可以说某个特定的算法是“*n*² 的大O”，即 *O*(*n*²)，如果在最坏情况下，它对于大 *n* 来说大致运行
    *n*² 步。技术定义表明，如果存在某个常数 *M*，使得对于所有足够大的 *x*，函数 *f*(*x*) 的绝对值始终小于 *M* 倍的 *g*(*x*)，那么函数
    *f*(*x*) 是函数 *g*(*x*) 的大O。
- en: 'In the case of insertion sort, when we look at our expression for the maximum
    number of steps required to perform the algorithm, we find that it’s a sum of
    two terms: one is a multiple of *n*², and the other is a multiple of *n*. As we
    just discussed, the term that is a multiple of *n* will matter less and less as
    *n* grows, and the *n*² term will come to be the only one that we are concerned
    with. So the worst case of insertion sort is that it is a *O*(*n*²) (“big O of
    *n*²”) algorithm.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以插入排序为例，当我们查看执行该算法所需的最大步骤数时，我们发现它是两个项的和：一个是 *n*² 的倍数，另一个是 *n* 的倍数。正如我们刚才讨论的那样，随着
    *n* 的增加， *n* 的倍数项变得越来越不重要，而 *n*² 项将成为我们唯一关心的。因此，插入排序的最坏情况是它是一个 *O*(*n*²)（“大O的
    *n*²”）算法。
- en: The quest for algorithm efficiency consists of seeking algorithms whose runtimes
    are big O of smaller and smaller functions. If we could find a way to alter insertion
    sort so that it is *O*(*n*^(1.5)) instead of *O*(*n*²), that would be a major
    breakthrough that would make a huge difference in runtimes for large values of
    *n*. We can use big O notation to talk not only about time but also about space.
    Some algorithms can gain speed by storing big datasets in memory. They might be
    big O of a small function for runtime but big O of a larger function for memory
    requirements. Depending on the circumstances, it may be wise to gain speed by
    eating up memory, or to free up memory by sacrificing speed. In this chapter,
    we’ll focus on gaining speed and designing algorithms to have runtimes that are
    big O of the smallest possible functions, without regard to memory requirements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 算法效率的追求在于寻找运行时间为更小函数的大O的算法。如果我们能找到一种方法来改变插入排序，使其为 *O*(*n*^(1.5)) 而不是 *O*(*n*²)，那将是一个重大突破，并能在
    *n* 较大的情况下显著提高运行时间。我们可以使用大O表示法不仅来讨论时间，也可以讨论空间。一些算法通过将大数据集存储在内存中来提高速度。它们的运行时间可能是小函数的大O，但在内存需求方面却是较大函数的大O。根据具体情况，我们可能需要通过消耗内存来提高速度，或者通过牺牲速度来释放内存。在本章中，我们将专注于提高速度，并设计运行时间为最小函数的大O的算法，而不考虑内存需求。
- en: After learning insertion sort and seeing that its runtime performance is *O*(*n*²),
    it’s natural to wonder what level of improvement we can reasonably hope for. Could
    we find some holy grail algorithm that could sort any possible list in fewer than
    10 steps? No. Every sorting algorithm will require at least *n* steps, because
    it will be necessary to consider each element of the list in turn, for each of
    the *n* elements. So any sorting algorithm will be at least *O*(*n*). We cannot
    do better than *O*(*n*), but can we do better than insertion sort’s *O*(*n*²)?
    We can. Next, we’ll consider an algorithm that’s known to be *O*(*n*log(*n*)),
    a significant improvement over insertion sort.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了插入排序并看到其运行时间为 *O*(*n*²) 后，我们自然会想知道可以合理地期望多少改进。我们能否找到一种“圣杯”算法，可以在不到10步的时间内排序任何可能的列表？不能。每个排序算法至少需要
    *n* 步，因为必须依次考虑列表中的每个元素。因此，任何排序算法的最少步骤数都将是 *O*(*n*)。我们无法做到比 *O*(*n*) 更好，但我们能否做得比插入排序的
    *O*(*n*²) 更好？可以。接下来，我们将考虑一种已知是 *O*(*n*log(*n*)) 的算法，它比插入排序有了显著改进。
- en: Merge Sort
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序
- en: '*Merge sort* is an algorithm that’s much quicker than insertion sort. Just
    like insertion sort, merge sort contains two parts: a part that merges two lists
    and a part that repeatedly uses merging to accomplish the actual sorting. Let’s
    consider the merging itself before we consider the sorting.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*归并排序* 是比插入排序更快的一种算法。和插入排序一样，归并排序包含两个部分：一部分用于合并两个列表，另一部分则通过反复合并来实现实际的排序。让我们在考虑排序之前，先来考虑合并的过程。'
- en: Suppose we have two filing cabinets that are both sorted individually but have
    never been compared to each other. We want to combine their contents into one
    final filing cabinet that is also completely sorted. We will call this task a
    *merge* of the two sorted filing cabinets. How should we approach this problem?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个文件柜，这两个文件柜各自已经排序，但从未进行过比较。我们想要将它们的内容合并到一个最终的文件柜中，这个文件柜也要完全排序。我们将这一任务称为两个已排序文件柜的
    *合并*。我们该如何处理这个问题？
- en: 'Once again, it’s worthwhile to consider how we would do this with real filing
    cabinets before we open Python and start writing code. In this case, we can imagine
    having three filing cabinets in front of us: the two full, sorted filing cabinets
    whose files we want to merge, and a third, empty filing cabinet that we will insert
    files into and that will eventually contain all of the files from the original
    two cabinets. We can call our two original cabinets the “left” and “right” cabinets,
    imagining that they are placed on our left and right.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，值得在打开 Python 开始编写代码之前，先考虑一下如果我们面对真实的文件柜会如何操作。在这种情况下，我们可以想象面前有三个文件柜：两个已经排序好的文件柜，我们需要将它们的文件合并在一起；还有一个第三个空文件柜，我们将把文件插入其中，最终这个文件柜将包含来自原始两个文件柜的所有文件。我们可以将这两个原始的文件柜称为“左边”文件柜和“右边”文件柜，假设它们分别放置在我们的左右两边。
- en: Merging
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并
- en: 'To merge, we can take the first file in both of the original cabinets simultaneously:
    the first left file with our left hand and the first right file with our right
    hand. Whichever file is lower is inserted into the new cabinet as its first file.
    To find the second file for the new cabinet, once again take the first file in
    the left and right cabinets, compare them, and insert whichever is lower into
    the last position in the new cabinet. When either the left cabinet or the right
    cabinet is empty, take the remaining files in the non-empty cabinet and place
    them all together at the end of the new cabinet. After this, your new cabinet
    will contain all the files from the left and right cabinets, sorted in order.
    We have successfully merged our original two cabinets.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 合并时，我们可以同时拿起两个原始柜子的第一个文件：用左手拿起左边柜子的第一个文件，用右手拿起右边柜子的第一个文件。无论哪个文件较小，就将其插入到新柜子的第一个位置。要找到新柜子的第二个文件，再次拿起左边和右边柜子的第一个文件进行比较，插入较小的文件到新柜子的最后一个位置。当左边柜子或右边柜子为空时，将非空柜子中的剩余文件一起取出并放到新柜子的末尾。完成后，你的新柜子将包含来自左边和右边柜子的所有文件，并且按照顺序排序。我们成功地合并了原来的两个柜子。
- en: In Python, we’ll use the variables `left` and `right` to refer to our original
    sorted cabinets, and we’ll define a `newcabinet` list, which will start empty
    and eventually contain all elements of both `left` and `right`, in order.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们将使用 `left` 和 `right` 变量来表示我们原始的已排序柜子，并且我们将定义一个 `newcabinet` 列表，它开始时为空，最终将按顺序包含
    `left` 和 `right` 中的所有元素。
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll define example cabinets that we’ll call `left` and `right`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义两个示例柜子，分别称为 `left` 和 `right`：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To compare the respective first elements of our left and right cabinets, we’ll
    use the following `if` statements (which won’t be ready to run until we fill in
    the `--snip--` sections):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较左边和右边柜子中的第一个元素，我们将使用以下的 `if` 语句（在我们填充 `--snip--` 部分之前，这些语句无法执行）：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember that if the first element of the left cabinet is lower than the first
    element of the right cabinet, we want to pop that element out of the left cabinet
    and insert it into the `newcabinet`, and vice versa. We can accomplish that by
    using Python’s built-in `pop()` function, inserting it into our `if` statements
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果左边柜子的第一个元素小于右边柜子的第一个元素，我们需要将左边柜子的该元素弹出并插入到`newcabinet`中，反之亦然。我们可以通过使用
    Python 内置的 `pop()` 函数来完成这一操作，并将其插入到我们的 `if` 语句中，代码如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This process—checking the first elements of the left and right cabinets and
    popping the appropriate one into the new cabinet—needs to continue as long as
    both of the cabinets still have at least one file. That’s why we will nest these
    `if` statements inside a `while` loop that checks the minimum length of `left`
    and `right`. As long as both `left` and `right` contain at least one file, it
    will continue its process:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程——检查左柜子和右柜子的第一个元素，并将适当的元素弹出到新柜子中——需要继续进行，直到这两个柜子中至少有一个没有文件。正因如此，我们会将这些`if`语句嵌套在一个`while`循环中，循环检查`left`和`right`的最小长度。只要`left`和`right`都包含至少一个文件，过程就会继续：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our `while` loop will stop executing as soon as either `left` or `right` runs
    out of files to insert. At that point, if `left` is empty, we’ll insert all the
    files in `right` at the end of the new cabinet in their current order, and vice
    versa. We can accomplish that final insertion as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`while`循环将在`left`或`right`中的任意一个文件插入完毕后停止执行。此时，如果`left`为空，我们将把`right`中所有剩余的文件按照当前顺序插入到新柜子的末尾，反之亦然。我们可以通过以下方式实现最后的插入：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we combine all of those snippets into our final merging algorithm in
    Python as shown in [Listing 4-4](#listing4-4).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些代码片段合并成最终的归并算法，如[Listing 4-4](#listing4-4)所示。
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Listing 4-4:](#listinganchor4-4) An algorithm to merge two sorted lists'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-4:](#listinganchor4-4) 合并两个已排序列表的算法'
- en: The code in [Listing 4-4](#listing4-4) creates `newcab`, a single list that
    contains all elements of `left` and `right`, merged and in order. You can run
    `print(newcab)` to see that our merging function worked.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-4](#listing4-4)中的代码创建了`newcab`，一个包含`left`和`right`中所有元素的列表，且这些元素已经合并并按顺序排列。你可以运行`print(newcab)`来验证我们的合并函数是否有效。'
- en: From Merging to Sorting
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从合并到排序
- en: 'Once we know how to merge, merge sort is within our grasp. Let’s start by creating
    a simple merge sort function that works only on lists that have two or fewer elements.
    A one-element list is already sorted, so if we pass that as the input to our merge
    sort function, we should just return it unaltered. If we pass a two-element list
    to our merge sort function, we can split that list into two one-element lists
    (that are therefore already sorted) and call our merging function on those one-element
    lists to get a final, sorted two-element list. The following Python function accomplishes
    what we need:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解如何进行合并，归并排序就易如反掌。让我们从创建一个简单的归并排序函数开始，它只处理包含两个或更少元素的列表。一个包含一个元素的列表本身已经是排序好的，所以如果我们将它作为输入传递给归并排序函数，我们应该直接返回它而不做修改。如果我们将一个包含两个元素的列表传递给归并排序函数，我们可以将这个列表拆分成两个包含一个元素的列表（这些列表已经排序），然后对这两个列表调用合并函数，得到最终的排序结果。下面的
    Python 函数实现了我们所需的功能：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code relies on Python’s list indexing syntax to split whatever cabinet
    we want to sort into a left cabinet and a right cabinet. You can see in the lines
    that define `left` and `right` that we’re using `:math.floor(len(cabinet)/2)`
    and `math.floor(len(cabinet)/2):` to refer to the entire first half or the entire
    second half of the original cabinet, respectively. You can call this function
    with any one- or two-element cabinet—for example, `mergesort_two_elements([3,1])`—and
    see that it successfully returns a sorted cabinet.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码依赖于 Python 的列表索引语法，将我们想要排序的任何柜子分成左柜子和右柜子。你可以看到在定义`left`和`right`的代码行中，我们使用了`:math.floor(len(cabinet)/2)`和`math.floor(len(cabinet)/2):`分别表示原柜子的前半部分和后半部分。你可以使用任何包含一个或两个元素的柜子来调用此函数，例如，`mergesort_two_elements([3,1])`，并看到它成功返回一个已排序的柜子。
- en: 'Next, let’s write a function that can sort a list that has four elements. If
    we split a four-element list into two sublists, each sublist will have two elements.
    We could follow our merging algorithm to combine these lists. However, recall
    that our merging algorithm is designed to combine two already sorted lists. These
    two lists may not be sorted, so using our merging algorithm will not successfully
    sort them. However, each of our sublists has only two elements, and we just wrote
    a function that can perform merge sort on lists with two elements. So we can split
    our four-element list into two sublists, call our merge sort function that works
    on two-element lists on each of those sublists, and then merge the two sorted
    lists together to get a sorted result with four elements. This Python function
    accomplishes that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个可以排序包含四个元素的列表的函数。如果我们将一个四元素的列表拆分为两个子列表，每个子列表将包含两个元素。我们可以按照合并算法将这些列表合并。然而，回想一下，我们的合并算法是设计用来合并两个已经排好序的列表的。而这两个列表可能并没有排好序，因此使用我们的合并算法并不能成功排序它们。然而，每个子列表只有两个元素，而且我们刚刚编写了一个可以对两个元素的列表执行归并排序的函数。所以我们可以将四元素列表拆分为两个子列表，然后对每个子列表调用我们处理两个元素列表的归并排序函数，最后将这两个已排序的子列表合并起来，得到一个包含四个元素的排序结果。这个Python函数实现了这一过程：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We could continue writing these functions to work on successively larger lists.
    But the breakthrough comes when we realize that we can collapse that whole process
    by using recursion. Consider the function in [Listing 4-5](#listing4-5), and compare
    it to the preceding `mergesort_four_elements()` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写这些函数来处理越来越大的列表。但突破性进展出现在我们意识到可以通过递归来简化整个过程。考虑[清单 4-5](#listing4-5)中的函数，并将其与前面的`mergesort_four_elements()`函数进行比较。
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Listing 4-5:](#listinganchor4-5) Implementing merge sort with recursion'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-5:](#listinganchor4-5) 使用递归实现归并排序'
- en: 'You can see that this function is nearly identical to our `mergesort_four_elements()`
    to function. The crucial difference is that to create the sorted left and right
    cabinets, it doesn’t call another function that works on smaller lists. Rather,
    it calls itself on the smaller list 12. Merge sort is a *divide and conquer* algorithm.
    We start with a large, unsorted list. Then we split that list repeatedly into
    smaller and smaller chunks (the dividing) until we end up with sorted (conquered)
    one-item lists, and then we simply merge them back together successively until
    we have built back up to one big sorted list. We can call this merge sort function
    on a list of any size and check that it works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个函数几乎与我们的`mergesort_four_elements()`函数完全相同。关键的区别在于，创建已排序的左边和右边子列表时，它并没有调用另一个处理更小列表的函数。而是它自己递归调用了较小的列表。归并排序是一种*分治法*算法。我们从一个大的未排序列表开始。然后我们反复将这个列表拆分成越来越小的部分（分治），直到我们得到每个只包含一个元素的已排序列表，接着我们只需依次将这些列表合并起来，直到最终得到一个大的已排序列表。我们可以将这个归并排序函数应用于任何大小的列表，并检查它是否有效：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we put all of our merge sort code together, we get [Listing 4-6](#listing4-6).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有的归并排序代码组合在一起时，我们得到了[清单 4-6](#listing4-6)。
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Listing 4-6:](#listinganchor4-6) Our complete merge sort code'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6:](#listinganchor4-6) 我们的完整归并排序代码'
- en: 'You could add a step counter to your merge sort code to check how many steps
    it takes to run and how it compares to insertion sort. The merge sort process
    consists of successively splitting the initial cabinet into sublists and then
    merging those sublists back together, preserving the sorting order. Every time
    we split a list, we’re cutting it in half. The number of times a list of length
    *n* can be split in half before each sublist has only one element is about log(*n*)
    (where the log is to base 2), and the number of comparisons we have to make at
    each merge is at most *n*. So *n* or fewer comparisons for each of log(*n*) comparisons
    means that merge sort is O(n×log(n)), which may not seem impressive but actually
    makes it the state of the art for sorting. In fact, when we call Python’s built-in
    sorting function `sorted` as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在归并排序代码中添加一个步骤计数器，来检查运行所需的步骤数，并将其与插入排序进行比较。归并排序的过程包括将初始列表反复拆分成子列表，然后将这些子列表合并回去，同时保持排序顺序。每次我们拆分列表时，都会将其对半切割。一个长度为*n*的列表能够被拆分为子列表的次数大约是log(*n*)（这里的log是以2为底的对数），而在每次合并时我们需要进行的比较次数最多是*n*。因此，每次log(*n*)次比较最多进行*n*次比较，这意味着归并排序的时间复杂度是O(n×log(n))，这可能看起来不那么惊人，但实际上它使得归并排序成为排序领域的先进技术。事实上，当我们调用Python内置的排序函数`sorted`时：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Python is using a hybrid version of merge sort and insertion sort behind the
    scenes to accomplish this sorting task. By learning merge sort and insertion sort,
    you’ve gotten up to speed with the quickest sorting algorithm computer scientists
    have been able to create, something that is used millions of times every day in
    every imaginable kind of application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在背后使用了一种混合版的归并排序和插入排序来完成这个排序任务。通过学习归并排序和插入排序，你已经跟上了计算机科学家们所能创造的最快排序算法，这是每天在每种可能的应用中使用数百万次的算法。
- en: Sleep Sort
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 睡眠排序
- en: The enormous negative influence that the internet has had on humanity is occasionally
    counterbalanced by a small, shining treasure that it provides. Occasionally, the
    bowels of the internet even produce a scientific discovery that creeps into the
    world outside the purview of scientific journals or the “establishment.” In 2011,
    an anonymous poster on the online image board 4chan proposed and provided code
    for a sorting algorithm that had never been published before and has since come
    to be called *sleep sort*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网对人类的巨大负面影响偶尔会被它提供的一个小而闪亮的宝藏所抵消。偶尔，互联网的深处甚至会产生一种科学发现，这些发现会悄然进入科学期刊或“主流”之外的世界。2011年，匿名用户在在线图片论坛4chan上提出并提供了一种以前从未发表过的排序算法的代码，这种算法后来被称为*睡眠排序*。
- en: Sleep sort wasn’t designed to resemble any real-world situation, like inserting
    files into a filing cabinet. If we’re seeking an analogy, we might consider the
    task of allocating lifeboat spots on the *Titanic* as it began to sink. We might
    want to allow children and younger people the first chance to get on the lifeboats,
    and then allow older people to try to get one of the remaining spots. If we make
    an announcement like “younger people get on the boats before older people,” we’d
    face chaos as everyone would have to compare their ages—they would face a difficult
    sorting problem amidst the chaos of the sinking ship.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠排序并不是为了模拟现实世界的任何情境，比如将文件插入文件柜。如果我们要找一个类比，或许可以考虑在*Titanic*号开始下沉时，分配救生艇位置的任务。我们可能希望先让孩子和年轻人有机会上救生艇，然后让年长者尝试获得剩余的席位。如果我们宣布“年轻人在年长者之前上船”，那么我们会面临混乱，因为每个人都得比较自己的年龄——在沉船的混乱中，他们将面临一个艰难的排序问题。
- en: 'A sleep-sort approach to the *Titanic* lifeboats would be the following. We
    would announce, “Everyone please stand still and count to your age: 1, 2, 3, .
    . . . As soon as you have counted up to your current age, step forward to get
    on a lifeboat.” We can imagine that 8-year-olds would finish their counting about
    one second before the 9-year-olds, and so would have a one-second head start and
    be able to get a spot on the boats before those who were 9\. The 8- and 9-year-olds
    would similarly be able to get on the boats before the 10-year-olds, and so on.
    Without doing any comparisons at all, we’d rely on individuals’ ability to pause
    for a length of time proportional to the metric we want to sort on and then insert
    themselves, and the sorting would happen effortlessly after that—with no direct
    inter-person comparisons.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*Titanic*号救生艇的睡眠排序方法如下。我们会宣布：“大家请站稳，按自己的年龄数：1，2，3，...。当你数到自己的年龄时，走到前面去上救生艇。”我们可以想象，8岁的小孩会比9岁的小孩早大约一秒钟完成数数，因此他们会提前一秒钟，并且能够在9岁的人之前得到救生艇的名额。8岁和9岁的小孩也会比10岁的小孩先上船，依此类推。我们无需做任何比较，只需依靠每个人根据我们要排序的度量暂停相应的时间，并随后插入自己，排序就会轻松完成——没有直接的人与人之间的比较。
- en: 'This *Titanic* lifeboat process shows the idea of sleep sort: allow each element
    to insert itself directly, but only after a pause in proportion to the metric
    it’s being sorted on. From a programming perspective, these pauses are called
    *sleeps* and can be implemented in most languages.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*Titanic*救生艇过程展示了睡眠排序的思想：允许每个元素直接插入，但必须先暂停一段时间，暂停的时长与其排序依据的度量成正比。从编程的角度来看，这些暂停被称为*sleeps*，并且可以在大多数编程语言中实现。
- en: In Python, we can implement sleep sort as follows. We will import the `threading`
    module, which will enable us to create different computer processes for each element
    of our list to sleep and then insert itself. We’ll also import the `time.sleep`
    module, which will enable us to put our different “threads” to sleep for the appropriate
    length of time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以这样实现睡眠排序。我们将导入`threading`模块，这样可以为列表中的每个元素创建不同的计算机进程来进行睡眠，然后再让它插入自己。我们还将导入`time.sleep`模块，这样可以使不同的“线程”根据适当的时间间隔休眠。
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The sorted list will be stored in the `sortedlist` variable, and you can ignore
    the list we create called `ignore_result`. You can see that one advantage of sleep
    sort is that it can be written concisely in Python. It’s also fun to print the
    `sortedlist` variable before the sorting is done (in this case, within about 7
    seconds) because depending on exactly when you execute the `print` command, you’ll
    see a different list. However, sleep sort also has some major disadvantages. One
    of these is that because it’s not possible to sleep for a negative length of time,
    sleep sort cannot sort lists with negative numbers. Another disadvantage is that
    sleep sort’s execution is highly dependent on outliers—if you append 1,000 to
    the list, you’ll have to wait at least 1,000 seconds for the algorithm to finish
    executing. Yet another disadvantage is that numbers that are close to each other
    may be inserted in the wrong order if the threads are not executed perfectly concurrently.
    Finally, since sleep sort uses threading, it will not be able to execute (well)
    on hardware or software that does not enable threading (well).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后的列表将存储在`sortedlist`变量中，你可以忽略我们创建的名为`ignore_result`的列表。你可以看到，睡眠排序的一个优点是它可以用简洁的Python代码编写。还有一个有趣的地方是，在排序完成之前（在这个例子中，大约7秒内），打印`sortedlist`变量也很有趣，因为根据你执行`print`命令的具体时间，你会看到不同的列表。然而，睡眠排序也有一些主要的缺点。其中之一是，由于不可能以负时间长度进行睡眠，睡眠排序无法对包含负数的列表进行排序。另一个缺点是，睡眠排序的执行高度依赖于异常值——如果你向列表中添加1000，你必须至少等待1000秒才能完成算法的执行。还有一个缺点是，如果线程没有完全并发执行，彼此接近的数字可能会被错误地插入。最后，由于睡眠排序使用了线程，它无法在不支持（或支持不好）线程的硬件或软件上良好执行。
- en: If we had to express sleep sort’s runtime in big O notation, we might say that
    it is *O*(*max*(*list*)). Unlike the runtime of every other well-known sorting
    algorithm, its runtime depends not on the size of the list but on the size of
    the elements of the list. This makes sleep sort hard to rely on, because we can
    only be confident about its performance with certain lists—even a short list may
    take far too long to sort if any of its elements are too large.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须用大O符号表示睡眠排序的运行时间，我们可能会说它是*O*(*max*(*list*))。与其他所有著名排序算法的运行时间不同，它的运行时间不仅取决于列表的大小，还取决于列表中元素的大小。这使得睡眠排序难以依赖，因为我们只能对某些列表的性能有信心——即使是一个短列表，如果其中的元素过大，也可能需要花费太长时间来排序。
- en: There may never be a practical use for sleep sort, even on a sinking ship. I
    include it here for a few reasons. First, because it is so different from all
    other extant sorting algorithms, it reminds us that even the most stale and static
    fields of research have room for creativity and innovation, and it provides a
    refreshingly new perspective on what may seem like a narrow field. Second, because
    it was designed and published anonymously and probably by someone outside the
    mainstream of research and practice, it reminds us that great thoughts and geniuses
    are found not only in fancy universities, established journals, and top firms,
    but also among the uncredentialed and unrecognized. Third, it represents a fascinating
    new generation of algorithms that are “native to computers,” meaning that they
    are not a translation of something that can be done with a cabinet and two hands
    like many old algorithms, but are fundamentally based on capabilities that are
    unique to computers (in this case, sleeping and threading). Fourth, the computer-native
    ideas it relies on (sleeping and threading) are very useful and worth putting
    in any algorithmicist’s toolbox for use in designing other algorithms. And fifth,
    I have an idiosyncratic affection for it, maybe just because it is a strange,
    creative misfit or maybe because I like its method of self-organizing order and
    the fact that I can use it if I’m ever in charge of saving a sinking ship.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在一艘沉船上，睡眠排序也可能永远没有实际应用。我在这里提它有几个原因。首先，因为它与所有其他现存的排序算法都截然不同，它提醒我们，即使是最陈旧、最静态的研究领域，也有创造力和创新的空间，并为看似狭窄的领域提供了耳目一新的视角。其次，因为它是匿名设计并发布的，可能是由研究和实践主流之外的人创作的，它提醒我们，伟大的思想和天才不仅出现在名校、权威期刊和顶级公司，也出现在没有学历和未被认可的人中。第三，它代表了新一代有趣的算法，这些算法是“计算机本土化”的，意味着它们不是可以用柜子和两只手做的类似许多旧算法的翻译，而是基于计算机独有的能力（在这种情况下，是睡眠和线程）。第四，它所依赖的计算机本土化的思想（睡眠和线程）非常有用，值得放进任何算法工程师的工具箱中，以便在设计其他算法时使用。第五，我对它有一种特别的喜爱，可能只是因为它是一个奇特、创造性的“不合群者”，或者因为我喜欢它自组织排序的方法，并且如果我负责拯救沉船，我也可以使用它。
- en: From Sorting to Searching
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从排序到搜索
- en: Searching, like sorting, is fundamental to a variety of tasks in computer science
    (and in the rest of life). We may want to search for a name in a phone book, or
    (since we’re living after the year 2000) we may need to access a database and
    find a relevant record.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和排序一样，是计算机科学中各种任务的基础（在生活中的其他领域也是如此）。我们可能想要在电话簿中查找一个名字，或者（因为我们生活在2000年以后）可能需要访问一个数据库并找到相关的记录。
- en: Searching is often merely a corollary of sorting. In other words, once we have
    sorted a list, searching is very straightforward—the sorting is often the hard
    part.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索通常只是排序的一个附带结果。换句话说，一旦我们对列表进行了排序，搜索就变得非常直接——排序通常是最困难的部分。
- en: Binary Search
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二分查找
- en: '*Binary search* is a quick and effective method for searching for an element
    in a sorted list. It works a little like a guessing game. Suppose that someone
    is thinking of a number from 1 to 100 and you are trying to guess it. You may
    guess 50 as your first guess. Your friend says that 50 is incorrect but allows
    you to guess again and gives you a hint: 50 is too high. Since 50 is too high,
    you guess 49\. Again, you are incorrect, and your friend tells you that 49 is
    too high and gives you another chance to guess. You could guess 48, then 47, and
    so on until you get the right answer. But that could take a long time—if the correct
    number is 1, it will take you 50 guesses to get it, which seems like too many
    guesses considering there were only 100 total possibilities to begin with.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分查找*是一种快速有效的在排序列表中查找元素的方法。它有点像猜数字游戏。假设有人想到了一个从1到100之间的数字，你要猜它。你可能会猜50作为第一次尝试。你的朋友说50不对，但允许你再次猜，并给出提示：50太大了。既然50太大，你就猜49。你还是错了，你的朋友告诉你49也太大，再给你一次机会。你可以猜48，然后是47，依此类推，直到你猜对为止。但这可能会花费很长时间——如果正确的数字是1，你需要猜50次才能猜到，这看起来有点太多了，因为一开始只有100种可能性。'
- en: A better approach is to take larger jumps after you find out whether your guess
    is too high or too low. If 50 is too high, consider what we could learn from guessing
    40 next instead of 49\. If 40 is too low, we have eliminated 39 possibilities
    (1–39) and we’ll definitely be able to guess in at most 9 more guesses (41–49).
    If 40 is too high, we’ve at least eliminated 9 possibilities (41–49) and we’ll
    definitely be able to guess in at most 39 more guesses (1–39). So in the worst
    case, guessing 40 narrows down the possibilities from 49 (1–49) to 39 (1–39).
    By contrast, guessing 49 narrows down the possibilities from 49 (1–49) to 48 (1–48)
    in the worst case. Clearly, guessing 40 is a better searching strategy than guessing
    49.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the best searching strategy is to guess exactly the midpoint
    of the remaining possibilities. If you do that and then check whether your guess
    was too high or too low, you can always eliminate half of the remaining possibilities.
    If you eliminate half of the possibilities in each round of guessing, you can
    actually find the right value quite quickly (*O*(log(*n*)) for those keeping score
    at home). For example, a list with 1,000 items will require only 10 guesses to
    find any element with a binary search strategy. If we’re allowed to have only
    20 guesses, we can correctly find the position of an element in a list with more
    than a million items. Incidentally, this is why we can write guessing-game apps
    that can correctly “read your mind” by asking only about 20 questions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this in Python, we will start by defining upper and lower bounds
    for what location a file can occupy in a filing cabinet. The lower bound will
    be 0, and the upper bound will be the length of the cabinet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To start, we will guess that the file is in the middle of the cabinet. We’ll
    import Python’s *math* library to use the `floor()` function, which can convert
    decimals to integers. Remember that guessing the halfway point gives us the maximum
    possible amount of information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will check whether our guess is too low or too high. We’ll take a
    different action depending on what we find. We use the `looking_for` variable
    for the value we are searching for:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the file in the cabinet is too high, then we’ll make our guess the new upper
    bound, since there is no use looking any higher in the cabinet. Then our new guess
    will be lower—to be precise, it will be halfway between the current guess and
    the lower bound:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We follow an analogous process if the file in the cabinet is too low:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, we can put all of these pieces together into a `binarysearch()` function.
    The function contains a *while* loop that will run for as long as it takes until
    we find the part of the cabinet we’ve been looking for ([Listing 4-7](#listing4-7)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Listing 4-7:](#listinganchor4-7) An implementation of binary search'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The final output of this code tells us that the number 8 is at position 7 in
    our `sorted_cabinet`. This is correct (remember that the index of Python lists
    starts at 0). This strategy of guessing in a way that eliminates half of the remaining
    possibilities is useful in many domains. For example, it’s the basis for the most
    efficient strategy on average in the formerly popular board game *Guess Who*.
    It’s also the best way (in theory) to look words up in a large, unfamiliar dictionary.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Applications of Binary Search
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides guessing games and word lookups, binary search is used in a few other
    domains. For example, we can use the idea of binary search when debugging code.
    Suppose that we have written some code that doesn’t work, but we aren’t sure which
    part is faulty. We can use a binary search strategy to find the problem. We split
    the code in half and run both halves separately. Whichever half doesn’t run properly
    is the half where the problem lies. Again, we split the problematic part in half,
    and test each half to further narrow down the possibilities until we find the
    offending line of code. A similar idea is implemented in the popular code version-control
    software Git as `git bisect` (although `git``bisect` iterates through temporally
    separated versions of the code rather than through lines in one version).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Another application of binary search is inverting a mathematical function.
    For example, imagine that we have to write a function that can calculate the arcsin,
    or inverse sine, of a given number. In only a few lines, we can write a function
    that will call our `binarysearch()` function to get the right answer. To start,
    we need to define a domain; these are the values that we will search through to
    find a particular arcsin value. The `sine` function is periodic and takes on all
    of its possible values between –pi/2 and pi/2, so numbers in between those extremes
    will constitute our domain. Next, we calculate sine values for each value in the
    domain. We call `binarysearch()` to find the position of the number whose sine
    is the number we’re looking for, and return the domain value with the corresponding
    index, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can run `inverse_sin(0.9)` and see that this function returns the correct
    answer: about 1.12.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way to invert a function. Some functions can be inverted
    through algebraic manipulation. However, algebraic function inversion can be difficult
    or even impossible for many functions. The binary search method presented here,
    by contrast, can work for any function, and with its *O*(log(*n*)) runtime, it’s
    also lightning fast.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting and searching may feel mundane to you, as if you’ve taken a break from
    an adventure around the world to attend a seminar on folding laundry. Maybe so,
    but remember that if you can fold clothes efficiently, you can pack more gear
    for your trek up Kilimanjaro. Sorting and searching algorithms can be enablers,
    helping you build newer and greater things on their shoulders. Besides that, it’s
    worth studying sorting and searching algorithms closely because they are fundamental
    and common, and the ideas you see in them can be useful for the rest of your intellectual
    life. In this chapter, we discussed some fundamental and interesting sorting algorithms,
    plus binary search. We also discussed how to compare algorithms and use big O
    notation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和查找可能对你来说显得平凡，就像你从环游世界的冒险中抽空去参加一个关于叠衣服的研讨会。也许是这样，但请记住，如果你能高效地叠衣服，就可以为登上基里曼扎罗峰准备更多的装备。排序和查找算法可以成为推动者，帮助你在它们的基础上构建更新、更伟大的事物。除此之外，深入研究排序和查找算法是值得的，因为它们是基础且常见的，而你在其中看到的思想对于你今后的智力生涯都是有益的。在这一章中，我们讨论了一些基础且有趣的排序算法，以及二分查找。我们还讨论了如何比较算法并使用大
    O 标记法。
- en: In the next chapter, we’ll turn to a few applications of pure math. We’ll see
    how we can use algorithms to explore the mathematical world, and how the mathematical
    world can help us understand our own.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将转向纯数学的一些应用。我们将看看如何利用算法探索数学世界，以及数学世界如何帮助我们理解自己。
