<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0201" class="chapter" epub:type="chapter" id="ch02" role="doc-chapter">
<header id="header0201">
<h1 class="cn"><span aria-label=" Page 18. " class="page" epub:type="pagebreak" id="p18" role="doc-pagebreak"/><span aria-label=" Page 19. " class="page" epub:type="pagebreak" id="p19" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch02">2</a></h1>
<h1 class="ct">Spirographs</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">You can use a Spirograph toy (shown in <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-1">Figure 2-1</a>) to draw mathematical curves. The toy consists of two different-sized rings with plastic gear teeth, one large and one small. The small one has several holes. You put a pen or pencil through one of the holes and then rotate the smaller wheel inside the larger one (which has gear teeth on its inside), keeping the wheels in contact with each other, to draw an endless number of complex and wonderfully symmetric patterns.</p>
<p>In this project, you’ll use Python to create an animation of Spirograph-like curves. The program will use parametric equations to describe the motion of a Spirograph’s rings and draw the curves (which I call <i>spiros</i>). You’ll save the completed drawings as PNG image files. Either the program will draw random spiros or you can use command line options to draw a spiro with specific parameters.</p>
<figure class="figure" id="fig2-1">
<p class="fig"><span aria-label=" Page 20. " class="page" epub:type="pagebreak" id="p20" role="doc-pagebreak"/><img alt="" height="850" src="images/nsp-venkitachalam503045-f02001.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 2-1:</span> A Spirograph toy</p>
</figcaption>
</figure>
<p>In this project, you’ll learn how to draw spiros on your computer. You’ll also learn how to do the following:</p>
<ul style="list-style-type:none">
<li class="blf">• Use parametric equations to generate curves.</li>
<li class="bl">• Draw a curve as a series of straight lines using the <code>turtle</code> module.</li>
<li class="bl">• Use a timer to animate graphics.</li>
<li class="bll">• Save graphics to image files.</li>
</ul>
<p>A word of caution: I’ve chosen to use the <code>turtle</code> module to draw spiros mainly for illustrative purposes and because it’s fun, but <code>turtle</code> is slow and not ideal for creating graphics when performance is critical. (What do you expect from turtles?) If you want to draw something quickly, there are better ways to do so, and you’ll explore some of these options in upcoming projects.</p>
<section>
<h2 class="ah" id="ah0401"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0401">How It Works</a></h2>
<p class="paft">This project hinges around using <span class="idx" data-term="parametric equations"/><i>parametric equations</i>, equations that express the coordinates of the points on a curve as functions of one or more variables, called <i>parameters</i>. You’ll plug values for the parameters into equations to calculate points that form a spiro pattern. Then you’ll feed those points to the <code>turtle</code> module to draw the curves.</p>
<section>
<h3 class="bh" id="bh0401"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0401">Understanding Parametric Equations</a></h3>
<p class="paft">To understand how parametric equations work, we’ll begin with a simple example: a circle. Consider a circle with radius <i>r</i>, centered at the origin of a two-dimensional plane. That circle consists of all the points whose x- and <span aria-label=" Page 21. " class="page" epub:type="pagebreak" id="p21" role="doc-pagebreak"/>y-coordinates satisfy the equation <i>x</i><sup>2</sup> + <i>y</i><sup>2</sup> = <i>r</i><sup>2</sup>. This isn’t a parametric equation, however. A parametric equation would give us all possible values of <i>x</i> and <i>y</i>, based on changes in some other variable (the parameter).</p>
<p>Now, consider the following equations:</p>
<div class="equation">
<p class="eq"><i>x</i> = <i>r</i> cos(<span class="dcrit-i">θ</span>)</p>
<p class="eq"><i>y</i> = <i>r</i> sin(<span class="dcrit-i">θ</span>)</p>
</div>
<p>Together, these equations are a <i>parametric</i> representation of our circle, where the parameter is <span class="dcrit-i">θ</span>, the angle of point (<i>x</i>, <i>y</i>) relative to the positive x-axis. Any value of (<i>x</i>, <i>y</i>) in these equations will satisfy the original <i>x</i><sup>2</sup> + <i>y</i><sup>2</sup> = <i>r</i><sup>2</sup> equation. As you vary <span class="dcrit-i">θ</span> from 0 to 2π, the x- and y-coordinates generated by these equations will form the circle. <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-2">Figure 2-2</a> shows this scheme.</p>
<figure class="figure" id="fig2-2">
<p class="fig"><img alt="" height="902" src="images/nsp-venkitachalam503045-f02002.jpg" style="width:95%; height:auto;" width="917"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 2-2:</span> Describing a circle with a parametric equation</p>
</figcaption>
</figure>
<p>Remember, these two equations apply to a circle centered at the origin of the coordinate system. You can put a circle at any point in the XY plane by translating the center of the circle from the point (0, 0) to the point (<i>a</i>, <i>b</i>). The more general parametric equations then become <i>x</i> = <i>a</i> + <i>r</i> cos(<span class="dcrit-i">θ</span>) and <i>y</i> = <i>b</i> + <i>r</i> sin(<span class="dcrit-i">θ</span>).</p>
<p>Developing parametric equations that model a Spirograph toy isn’t that much different from developing parametric equations for a circle, since at heart a Spirograph simply draws two interlocking circles. <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-3">Figure 2-3</a> shows a mathematical model of Spirograph-like motion. The model has no gear teeth; they’re used in Spirograph toys only to prevent slippage, and in the ideal world of mathematical modeling, you don’t have to worry about anything slipping.</p>
<figure class="figure" id="fig2-3">
<p class="fig"><span aria-label=" Page 22. " class="page" epub:type="pagebreak" id="p22" role="doc-pagebreak"/><img alt="" height="905" src="images/nsp-venkitachalam503045-f02003.jpg" style="width:95%; height:auto;" width="902"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 2-3:</span> A mathematical model of a Spirograph toy</p>
</figcaption>
</figure>
<p>In <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-3">Figure 2-3</a>, <i>C</i> is the center of the smaller circle, <i>P</i> is the pen’s tip, and <i>q</i> is the angle of <i>C</i> relative to the positive x-axis. The radius of the bigger circle is <i>R</i> and that of the smaller circle is <i>r</i>. You express the ratio of the radii as variable <i>k</i>, as follows:</p>
<div class="equation">
<p class="eq"><img alt="" height="43" src="images/nsp-venkitachalam503045-m02001.jpg" width="80"/></p>
</div>
<p>Line segment <img alt="" height="25" src="images/nsp-venkitachalam503045-m02002.jpg" width="39"/> tells you how far the pen tip is from the center of the smaller circle. You express the ratio of <img alt="" height="25" src="images/nsp-venkitachalam503045-m02002.jpg" width="39"/> to the smaller circle’s radius <i>r</i> as the variable <i>l</i>, like so:</p>
<div class="equation">
<p class="eq"><img alt="" height="59" src="images/nsp-venkitachalam503045-m02003.jpg" width="99"/></p>
</div>
<p>You can now combine these variables into the following parametric equations that represent the x- and y-coordinates of point <i>P</i> (the pen) as the smaller circle rotates inside the larger one:</p>
<div class="equation">
<p class="eq"><img alt="" height="69" src="images/nsp-venkitachalam503045-m02004.jpg" width="489"/></p>
<p class="eq"><img alt="" height="69" src="images/nsp-venkitachalam503045-m02005.jpg" width="477"/></p>
</div>
<p class="pcust1"><span class="ccust3">NOTE</span> These curves are called <span class="idx" data-term="hypotrochoid"/><i>hypotrochoids</i>. Although the equations may look a bit scary, the derivation is pretty straightforward. See the Wikipedia page on Spirographs if you’d like to explore the math: <a class="url-i" href="http://en.wikipedia.org/wiki/Spirograph">http://en.wikipedia.org/wiki/Spirograph</a>.</p>
<p><span aria-label=" Page 23. " class="page" epub:type="pagebreak" id="p23" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-4">Figure 2-4</a> shows an example curve drawn with these equations. For this curve, I set <i>R</i> to 220, <i>r</i> to 65, and <i>l</i> to 0.8. By choosing different values for these three parameters and then incrementing angle <span class="dcrit-i">θ</span>, you can produce an endless variety of fascinating curves.</p>
<figure class="figure" id="fig2-4">
<p class="fig"><img alt="" height="999" src="images/nsp-venkitachalam503045-f02004.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 2-4:</span> A sample curve</p>
</figcaption>
</figure>
<p>The only task left is to determine when to stop drawing, since Spirographs can require many revolutions of the smaller circle around the larger circle to form a complete pattern. You can calculate the <span class="idx" data-level1="periodicity" data-term="Spirograph equations"/><i>periodicity</i> of the Spirograph (how long before the Spirograph starts repeating itself) by looking at the ratio of the radii of the inner and outer circles:</p>
<div class="equation">
<p class="eq"><img alt="" height="53" src="images/nsp-venkitachalam503045-m02006.jpg" width="23"/></p>
</div>
<p>Reduce this fraction by dividing the numerator and denominator by the <i>greatest common divisor (</i><span class="idx" data-term="greatest common divisor (GCD)"/><i>GCD)</i>. Then the numerator tells you how many periods the curve needs to complete itself. For example, in <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-4">Figure 2-4</a>, the GCD of (<i>r</i>, <i>R</i>) is 5:</p>
<div class="equation">
<p class="eq"><img alt="" height="66" src="images/nsp-venkitachalam503045-m02007.jpg" width="320"/></p>
</div>
<p>This tells you that the curve will start repeating itself after 13 revolutions of the smaller circle around the larger circle. The 44 in the denominator tells you the number of times the smaller circle revolves around its own center, which gives you a hint as to the shape of the curve. If you count the petals (or lobes) in the drawing in <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-4">Figure 2-4</a>, you’ll see there are exactly 44!</p>
<p>Once you express the radii ratio in the reduced form <i>r</i>/<i>R</i>, the range for the parameter <span class="dcrit-i">θ</span> to draw the spiro is [0, 2π<i>r</i>]. This tells you when to <span aria-label=" Page 24. " class="page" epub:type="pagebreak" id="p24" role="doc-pagebreak"/>stop drawing a particular spiro. In the case of <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-4">Figure 2-4</a>, you’d stop when <span class="dcrit-i">θ</span> reaches 26π (that is, 2π × 13). Without knowing the ending range of the angle, you’d end up looping around, repeating the curve unnecessarily.<span class="idx" data-term="Spirograph equations (end)"/><span class="idx" data-level1="for a Spirograph (end)" data-term="parametric equations"/></p>
</section>
<section>
<h3 class="bh" id="bh0402"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0402"><span class="idx" data-term="turtle module"/>Drawing Curves with turtle Graphics</a></h3>
<p class="paft">Python’s <code>turtle</code> module doesn’t have a method for drawing curved lines. Instead, you’ll draw a spiro as a collection of straight lines between different points calculated with the parametric equations discussed in the previous section. As long as the change in angle <span class="dcrit-i">θ</span> from one point to the next is relatively small, the result will appear curved.</p>
<p>To demonstrate, the following program <span class="idx" data-level1="drawing a circle" data-term="turtle module"/>draws a circle with <code>turtle</code>. It uses our basic parametric equations for a circle, <i>x</i> = <i>a</i> + <i>r</i> cos(<span class="dcrit-i">θ</span>) and <i>y</i> = <i>b</i> + <i>r</i> sin(<span class="dcrit-i">θ</span>), to calculate points along the circle, and it connects those points with straight lines. Technically, the program actually produces an <i>N</i>-sided polygon, but because the angle parameter will change in small increments, <i>N</i> will be very large, and the polygon will look like a circle. Enter the following code, save it as <i>drawcircle.py</i>, and run it in Python:</p>
<div class="codeline">
<p class="clf">import math</p>
<p class="cl">import turtle</p>
<p class="clf"># draw the circle using turtle</p>
<p class="cl">def drawCircleTurtle(x, y, r):</p>
<p class="cl">    # move to the start of circle</p>
<p class="cl">    turtle.<span class="idx" data-level1="up" data-term="turtle module"/>up()</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ turtle.<span class="idx" data-level1="setpos" data-term="turtle module"/>setpos(x + r, y)</p>
<p class="cl">    turtle.<span class="idx" data-level1="down" data-term="turtle module"/>down()</p>
<p class="clf">    # draw the circle</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ for i in range(0, 365, 5):</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ a = math.radians(i)</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ turtle.setpos(x + r*math.cos(a), y + r*math.sin(a))</p>
<p class="cl2f"><!--<ccust1>5</ccust1>-->❺ drawCircleTurtle(100, 100, 50)</p>
<p class="cll">turtle.<span class="idx" data-level1="mainloop" data-term="turtle module"/>mainloop()</p>
</div>
<p>Here you define the <code>drawCircleTurtle()</code> function, whose parameters are the center of the circle to be drawn, (<i>x</i>, <i>y</i>), and the circle’s radius, <i>r</i>. The function starts by moving the turtle into position at the first point on the circle’s horizontal axis: (<i>x</i> + <i>r</i>, <i>y</i>) <!--<ccust1>1</ccust1>-->❶. The calls to <code>up()</code> and <code>down()</code> prevent the turtle from drawing while it’s getting into position. Next, you start a loop using <span class="idx" data-term="range() method"/><code>range(0, 365, 5)</code>, which increments the variable <code>i</code> in steps of 5 from 0 to 360 <!--<ccust1>2</ccust1>-->❷. The <code>i</code> variable is the angle parameter you’ll pass into the parametric circle equations, but first you convert it from degrees to radians <!--<ccust1>3</ccust1>-->❸. (Most computer programs require radians for angle-based calculations.)</p>
<p>Compute the next set of circle coordinates using the two parametric equations, and you set the turtle’s position accordingly <!--<ccust1>4</ccust1>-->❹. This draws a straight line from the last turtle position to the newly calculated one. Since you’re changing the angle parameter by just 5 degrees at a time, the straight lines will create the appearance of a round circle.</p>
<p><span aria-label=" Page 25. " class="page" epub:type="pagebreak" id="p25" role="doc-pagebreak"/>Now that you have your function, you call it to draw a circle <!--<ccust1>5</ccust1>-->❺. Calling <code>turtle.mainloop()</code> keeps the <code>tkinter</code> window open so that you can admire your work. (<span class="idx" data-term="tkinter module"/><code>tkinter</code> is the default GUI library used by Python.)</p>
<p>You’re now ready to draw some spiros! You’ll use the same <code>turtle</code> approach illustrated earlier. All that has to change are the details of the parametric equations used to calculate the points.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0402"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0402">Requirements</a></h2>
<p class="paft">You’ll use the following to create your spiros:</p>
<ul style="list-style-type:none">
<li class="blf">• The <code>turtle</code> module for drawing</li>
<li class="bl">• <span class="idx" data-term="Pillow module"/><code>Pillow</code>, a fork of the <span class="idx" data-term="Python Imaging Library (PIL)"/><i>Python Imaging Library (</i><span class="idx" data-term="PIL (Python Imaging Library)"/><i>PIL)</i>, to save the spiro images</li>
</ul>
</section>
<section>
<h2 class="ah" id="ah0403"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0403">The Code</a></h2>
<p class="paft">First you’ll define a class <code>Spiro</code> to draw the curves. You can use this class either to draw a single curve with customizable parameters or as part of an animation that draws several random spiros concurrently. To coordinate the animation, you’ll define another class called <code>SpiroAnimator</code>. At the top level of the program, you’ll write a function to save your drawings as image files, and you’ll use the <code>main()</code> function to take in user input and set the drawing in motion.</p>
<p>To see the full project code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#ah0407">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#p36">page 36</a>. You can also download the code for this project from <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/spirograph/spiro.py">https://github.com/mkvenkit/pp2e/blob/main/spirograph/spiro.py</a>.</p>
<section>
<h3 class="bh" id="bh0403"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0403">Drawing the Spiros</a></h3>
<p class="paft">The <code>Spiro</code> class features methods for drawing an individual spiro pattern. Here’s the <code>Spiro</code> class’s constructor:</p>
<div class="codeline">
<p class="clf">class Spiro:</p>
<p class="cl">    # constructor</p>
<p class="cl">    def __init__(self, xc, yc, col, R, r, l):</p>
<p class="clf">        # create the turtle object</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.t = turtle.Turtle()</p>
<p class="cl">        # set the cursor shape</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.t.shape(<span class="idx" data-level1="setting the cursor (begin)" data-term="turtle module"/>'turtle')</p>
<p class="cl">        # set the step in degrees</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.step = 5</p>
<p class="cl">        # set the drawing complete flag</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.drawingComplete = False</p>
<p class="clf">        # set the parameters</p>
<p class="cl">        self.setparams(xc, yc, col, R, r, l)</p>
<p class="clf">        # initialize the drawing</p>
<p class="cll">        self.restart()</p>
</div>
<p><span aria-label=" Page 26. " class="page" epub:type="pagebreak" id="p26" role="doc-pagebreak"/>The <code>Spiro</code> constructor creates a new <code>turtle</code> object <!--<ccust1>1</ccust1>-->❶. This way, each individual <code>Spiro</code> object will have its own <code>turtle</code> object associated with it, meaning you can create multiple <code>Spiro</code> objects to draw a bunch of spiros simultaneously. You set the shape of the turtle <span class="idx" data-level1="setting the cursor (end)" data-term="turtle module"/>cursor to a turtle <!--<ccust1>2</ccust1>-->❷. (You’ll find other choices in the <code>turtle</code> documentation at <a class="url-i" href="https://docs.python.org/3/library/turtle.xhtml">https://docs.python.org/3/library/turtle.xhtml</a>.) You set the angle increment for the parametric drawing to 5 degrees <!--<ccust1>3</ccust1>-->❸ and create a Boolean <code>drawingComplete</code> flag for indicating when the spiro is done <!--<ccust1>4</ccust1>-->❹. This flag will be useful when multiple <code>Spiro</code> objects are drawing in tandem; it allows you to keep track of whether a particular spiro is complete. You finish the constructor by calling two setup methods, as discussed next.</p>
<section>
<h4 class="ch" id="ch0401">The Setup Methods</h4>
<p class="paft">The <code>Spiro</code> class’s <code>setparams()</code> and <code>restart()</code> methods both help with some setup that needs to be done before a spiro pattern can be drawn. Let’s look at the <code>setparams()</code> method first:</p>
<div class="codeline">
<p class="clf">def setparams(self, xc, yc, col, R, r, l):</p>
<p class="cl">    # the Spirograph parameters</p>
<p class="cl">    self.xc = xc</p>
<p class="cl">    self.yc = yc</p>
<p class="cl">    self.R = int(R)</p>
<p class="cl">    self.r = int(r)</p>
<p class="cl">    self.l = l</p>
<p class="cl">    self.col = col</p>
<p class="cl">    # reduce r/R to its smallest form by dividing with the GCD</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ gcdVal = math.gcd(self.r, self.R)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.nRot = self.r//gcdVal</p>
<p class="cl">    # get ratio of radii</p>
<p class="cl">    self.k = r/float(R)</p>
<p class="cl">    # set the color</p>
<p class="cl">    self.t.color(*col)</p>
<p class="cl">    # store the current angle</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ self.a = 0</p>
</div>
<p>First you store the coordinates of the center of the spiro (<code>xc</code> and <code>yc</code>). Then you convert the radius of each circle (<code>R</code> and <code>r</code>) to an integer and store the values. You also store <code>l</code>, which defines the position of the pen, and <code>col</code>, which determines the spiro’s color. Next, you use the <code>gcd()</code> method from Python’s built-in <code>math</code> module to compute the GCD of the radii <!--<ccust1>1</ccust1>-->❶. You use this information to determine the periodicity of the curve, which you save as <code>self.nRot</code> <!--<ccust1>2</ccust1>-->❷. Finally, you set the starting value of the angle parameter, <code>a</code>, to <code>0</code> <!--<ccust1>3</ccust1>-->❸.</p>
<p>The <code>restart()</code> method continues with the setup by resetting the drawing parameters for the <code>Spiro</code> object and getting it into position to draw a spiro. This method makes it possible to reuse the same <code>Spiro</code> object to draw multiple spiros, one after the other, as part of the program’s animation. The program will call <code>restart()</code> each time the object is ready to draw a new spiro. Here’s the method:</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 27. " class="page" epub:type="pagebreak" id="p27" role="doc-pagebreak"/>def restart(self):</p>
<p class="cl">    # set the flag</p>
<p class="cl">    self.drawingComplete = False</p>
<p class="cl">    # show the turtle</p>
<p class="cl">    self.t.showturtle()</p>
<p class="cl">    # go to the first point</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ self.t.up()</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ R, k, l = self.R, self.k, self.l</p>
<p class="cl">    a = 0.0</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))</p>
<p class="cl">    y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ self.t.setpos(self.xc + x, self.yc + y)</p>
<p class="cll">  <!--<ccust1>5</ccust1>-->❺ self.t.down()</p>
</div>
<p>You reset the <code>drawingComplete</code> flag to <code>False</code>, indicating the object is ready to draw a new spiro. Then you show the turtle cursor, in case it was hidden. Next lift up the pen <!--<ccust1>1</ccust1>-->❶ so you can move to the first position at <!--<ccust1>4</ccust1>-->❹ without drawing a line. At <!--<ccust1>2</ccust1>-->❷, you’re just using some local variables to keep the code compact. Then you feed those variables to the spiro parametric equations to compute the x- and y-coordinates of the curve’s starting point, using <code>0</code> as an initial value for angle <code>a</code> <!--<ccust1>3</ccust1>-->❸. Finally, once the turtle is in place, you set the pen down so the turtle can start drawing the spiro <!--<ccust1>5</ccust1>-->❺.</p>
</section>
<section>
<h4 class="ch" id="ch0402">The draw() Method</h4>
<p class="paft">If you use command line options to set the parameters of a spiro, the program will draw just that one spiro, using the <code>Spiro</code> class’s <span class="idx" data-level1="drawing a spirograph" data-term="turtle module"/><code>draw()</code> method. This method draws the entire spiro all in one go, as a continuous sequence of straight-line segments:</p>
<div class="codeline">
<p class="clf">def draw(self):</p>
<p class="cl">    # draw the rest of the points</p>
<p class="cl">    R, k, l = self.R, self.k, self.l</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ for i in range(0, 360*self.nRot + 1, self.step):</p>
<p class="cl">        a = math.radians(i)</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))</p>
<p class="cl">        y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))</p>
<p class="clf">        try:</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ self.t.setpos(self.xc + x, self.yc + y)</p>
<p class="cl">        except:</p>
<p class="cl">            print("Exception, exiting.")</p>
<p class="cl">            exit(0)</p>
<p class="cl">    # drawing is now done so hide the turtle cursor</p>
<p class="cll">  <!--<ccust1>4</ccust1>-->❹ self.t.hideturtle()</p>
</div>
<p>Here you iterate through the complete range of the parameter <code>i</code>, which is expressed in degrees as 360 times <code>nRot</code> <!--<ccust1>1</ccust1>-->❶. You use the parametric equations to compute the x- and y-coordinates for each value of the <code>i</code> parameter <!--<ccust1>2</ccust1>-->❷, calling the turtle’s <code>setpos()</code> method <!--<ccust1>3</ccust1>-->❸ to draw the line from one point to the next. This method is enclosed in a <code>try</code> block so that if an <span aria-label=" Page 28. " class="page" epub:type="pagebreak" id="p28" role="doc-pagebreak"/>exception arises—such as the user closing the window in the middle of the drawing process—you can catch it and exit gracefully. Finally, you hide the cursor because you’ve finished drawing <!--<ccust1>4</ccust1>-->❹.</p>
</section>
<section>
<h4 class="ch" id="ch0403">The update() Method</h4>
<p class="paft">If you don’t use any command line options, the program will draw multiple random spiros as an animation. This approach requires some restructuring of the drawing code we just looked at. Instead of drawing an entire spiro in one go, you need a method that draws just a single-line segment of the spiro. Then you’ll call that method at every time step in the animation. This <code>update()</code> method of the <code>Spiro</code> class fits the bill:</p>
<div class="codeline">
<p class="clf">def update(self):</p>
<p class="cl">    # skip the rest of the steps if done</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if self.drawingComplete:</p>
<p class="cl">        return</p>
<p class="cl">    # increment the angle</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.a += self.step</p>
<p class="cl">    # draw a step</p>
<p class="cl">    R, k, l = self.R, self.k, self.l</p>
<p class="cl">    # set the angle</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ a = math.radians(self.a)</p>
<p class="cl">    x = self.R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))</p>
<p class="cl">    y = self.R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))</p>
<p class="clf">    try:</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.t.setpos(self.xc + x, self.yc + y)</p>
<p class="cl">    except:</p>
<p class="cl">        print("Exception, exiting.")</p>
<p class="cl">        exit(0)</p>
<p class="cl">    # if drawing is complete, set the flag</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ if self.a &gt;= 360*self.nRot:</p>
<p class="cl">        self.drawingComplete = True</p>
<p class="cl">        # drawing is now done so hide the turtle cursor</p>
<p class="cll">        self.t.hideturtle()</p>
</div>
<p>You first check to see whether the <code>drawingComplete</code> flag is set <!--<ccust1>1</ccust1>-->❶; if not, you continue through the rest of the code. You increment the current angle <!--<ccust1>2</ccust1>-->❷, calculate the (<i>x</i>, <i>y</i>) position corresponding to the current angle <!--<ccust1>3</ccust1>-->❸, and move the turtle there, drawing the line segment in the process <!--<ccust1>4</ccust1>-->❹. This is just like the code inside the <code>for()</code> loop in the <code>draw()</code> method, except it happens only once.</p>
<p>When I discussed the Spirograph parametric equations, I talked about the periodicity of the curve. A Spirograph starts repeating itself after a certain angle. You finish the <code>update()</code> function by checking whether the angle has reached the full range computed for this particular curve <!--<ccust1>5</ccust1>-->❺. If so, you set the <code>drawingComplete</code> flag because the spiro is finished. Finally, you hide the turtle cursor so you can see your beautiful creation.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh0404"><span aria-label=" Page 29. " class="page" epub:type="pagebreak" id="p29" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0404">Coordinating the Animation</a></h3>
<p class="paft">The <code>SpiroAnimator</code> class will let you draw several random spiros simultaneously as an animation. This class coordinates the activity of multiple <code>Spiro</code> objects with randomly assigned parameters, using a timer to regularly call each <code>Spiro</code> object’s <code>update()</code> method. This technique updates the graphics periodically and lets the program process events such as button presses, mouse clicks, and so on.</p>
<p>Let’s look at the <code>SpiroAnimator</code> class’s constructor first:</p>
<div class="codeline">
<p class="clf">class SpiroAnimator:</p>
<p class="cl">    # constructor</p>
<p class="cl">    def __init__(self, N):</p>
<p class="cl">        # set the timer value in milliseconds</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.deltaT = 10</p>
<p class="cl">        # get the window dimensions</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.width = turtle.<span class="idx" data-level1="window_width" data-term="turtle module"/>window_width()</p>
<p class="cl">        self.height = turtle.<span class="idx" data-level1="window_height" data-term="turtle module"/>window_height()</p>
<p class="cl">        # restarting</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.restarting = False</p>
<p class="cl">        # create the Spiro objects</p>
<p class="cl">        self.spiros = []</p>
<p class="cl">        for i in range(N):</p>
<p class="cl">            # generate random parameters</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ rparams = self.genRandomParams()</p>
<p class="cl">            # set the spiro parameters</p>
<p class="cl">          <!--<ccust1>5</ccust1>-->❺ spiro = Spiro(*rparams)</p>
<p class="cl">            self.spiros.append(spiro)</p>
<p class="cl">        # call timer</p>
<p class="cll">      <!--<ccust1>6</ccust1>-->❻ turtle.<span class="idx" data-level1="ontimer" data-term="turtle module"/>ontimer(self.update, self.deltaT)</p>
</div>
<p>The <code>SpiroAnimator</code> constructor sets <code>deltaT</code> to <code>10</code>, which is the time interval in milliseconds you’ll use for the timer <!--<ccust1>1</ccust1>-->❶. You then store the dimensions of the turtle window <!--<ccust1>2</ccust1>-->❷ and initialize a flag that will be used to indicate that a restart is in progress <!--<ccust1>3</ccust1>-->❸. In a loop that repeats <i>N</i> times (<code>N</code> is passed into <code>SpiroAnimator</code> in the constructor), you create new <code>Spiro</code> objects <!--<ccust1>5</ccust1>-->❺ and add them to a <code>spiros</code> list. Before creating each <code>Spiro</code> object, you call the <code>genRandomParams()</code> helper method <!--<ccust1>4</ccust1>-->❹ to randomly assign the spiro’s parameters (we’ll look at this method next). The <code>rparams</code> here is a tuple that you need to pass into the <code>Spiro</code> constructor. However, the constructor expects multiple arguments, so you use the Python <code>*</code> operator to unpack the tuple into a series of arguments. Finally, you set the <code>turtle.ontimer()</code> method to call <code>update()</code> after <code>deltaT</code> milliseconds <!--<ccust1>6</ccust1>-->❻, which sets the animation in motion.</p>
<section>
<h4 class="ch" id="ch0404"><span aria-label=" Page 30. " class="page" epub:type="pagebreak" id="p30" role="doc-pagebreak"/>Generating Random Parameters</h4>
<p class="paft">You’ll use the <code>genRandomParams()</code> method to generate random parameters to send to each <code>Spiro</code> object as it’s created to produce a wide variety of curves. You’ll also call this method each time a <code>Spiro</code> object finishes drawing a spiro and is ready to start drawing a new one:</p>
<div class="codeline">
<p class="clf">def genRandomParams(self):</p>
<p class="cl">    width, height = self.width, self.height</p>
<p class="cl">    R = random.randint(50, min(width, height)//2)</p>
<p class="cl">    r = random.randint(10, 9*R//10)</p>
<p class="cl">    l = random.uniform(0.1, 0.9)</p>
<p class="cl">    xc = random.randint(-width//2, width//2)</p>
<p class="cl">    yc = random.randint(-height//2, height//2)</p>
<p class="cl">    col = (random.random(),</p>
<p class="cl">           random.random(),</p>
<p class="cl">           random.random())</p>
<p class="cll">  <!--<ccust1>1</ccust1>-->❶ return (xc, yc, col, R, r, l)</p>
</div>
<p>To generate random numbers, you use three methods from Python’s <code>random</code> module: <code>randint()</code>, which returns random integers in the specified range; <code>uniform()</code>, which does the same for floating-point numbers; and <code>random()</code>, which returns a float between 0 and 1. You set <code>R</code> to a random integer between 50 and the value of half the smallest dimension of your window, and you set <code>r</code> to between 10 percent and 90 percent of <code>R</code>. Then you set <code>l</code> to a random fraction between 0.1 and 0.9.</p>
<p>You next select a random point on the screen to place the center of the spiro by selecting random x- and y-coordinates (<code>xc</code> and <code>yc</code>) from within the screen boundaries. You assign a random color <code>col</code> to the curve by setting random values for the red, green, and blue color components (these are defined on a scale from 0 to 1). Finally, all of your calculated parameters are returned as a tuple <!--<ccust1>1</ccust1>-->❶.</p>
</section>
<section>
<h4 class="ch" id="ch0405">Restarting the Animation</h4>
<p class="paft">The <code>SpiroAnimator</code> class has its own <code>restart()</code> method for restarting the animation to draw a new set of spiros:</p>
<div class="codeline">
<p class="clf">def restart(self):</p>
<p class="cl">    # ignore restart if already in the middle of restarting</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if self.restarting:</p>
<p class="cl">        return</p>
<p class="cl">    else:</p>
<p class="cl">        self.restarting = True</p>
<p class="cl">    for spiro in self.spiros:</p>
<p class="cl">        # clear</p>
<p class="cl">        spiro.clear()</p>
<p class="cl">        # generate random parameters</p>
<p class="cl">        rparams = self.genRandomParams()</p>
<p class="cl">        # set the spiro parameters</p>
<p class="cl">        spiro.setparams(*rparams)</p>
<p class="cl">        # restart drawing</p>
<p class="cl"><span aria-label=" Page 31. " class="page" epub:type="pagebreak" id="p31" role="doc-pagebreak"/>        spiro.restart()</p>
<p class="cl">    # done restarting</p>
<p class="cll">  <!--<ccust1>2</ccust1>-->❷ self.restarting = False</p>
</div>
<p>This method loops through all the <code>Spiro</code> objects. For each one, you clear the previous drawing and randomly generate a new set of spiro parameters. Then you use the <code>Spiro</code> object’s setup methods, <code>setparams()</code> and <code>restart()</code>, to assign the new parameters and get the object ready to draw the next spiro. The <code>self.restarting</code> flag <!--<ccust1>1</ccust1>-->❶ prevents this method from being called before it’s had a chance to complete, which could happen if the user repeatedly hits the spacebar. The flag is reset at the end of the method so that the next restart won’t be ignored <!--<ccust1>2</ccust1>-->❷.</p>
</section>
<section>
<h4 class="ch" id="ch0406">Updating the Animation</h4>
<p class="paft">The following code shows the <code>update()</code> method in <code>SpiroAnimator</code>, which is called by the timer every 10 milliseconds to update all the <code>Spiro</code> objects used in the animation:</p>
<div class="codeline">
<p class="clf">def update(self):</p>
<p class="cl">    # update all spiros</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ nComplete = 0</p>
<p class="cl">    for spiro in self.spiros:</p>
<p class="cl">        # update</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ spiro.update()</p>
<p class="cl">        # count completed spiros</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ if spiro.drawingComplete:</p>
<p class="cl">            nComplete += 1</p>
<p class="cl">    # restart if all spiros are complete</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ if nComplete == len(self.spiros):</p>
<p class="cl">        self.restart()</p>
<p class="cl">    # call the timer</p>
<p class="cl">    try:</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ turtle.ontimer(self.update, self.deltaT)</p>
<p class="cl">    except:</p>
<p class="cl">        print("Exception, exiting.")</p>
<p class="cll">        exit(0)</p>
</div>
<p>The <code>update()</code> method uses a counter <code>nComplete</code> to track the number of <code>Spiro</code> objects that have finished drawing <!--<ccust1>1</ccust1>-->❶. The method loops through the list of <code>Spiro</code> objects and updates them <!--<ccust1>2</ccust1>-->❷, which draws one more line segment in each spiro. You increment the counter if a <code>Spiro</code> is done <!--<ccust1>3</ccust1>-->❸.</p>
<p>Outside the loop, you check the counter to determine whether all the objects have finished drawing <!--<ccust1>4</ccust1>-->❹. If so, you restart the animation with fresh spiros by calling the <code>restart()</code> method. The <code>update()</code> method ends with a call to the <code>turtle</code> module’s <code>ontimer()</code> method <!--<ccust1>5</ccust1>-->❺, which calls <code>update()</code> again after <code>deltaT</code> milliseconds. This is what keeps the animation going.</p>
</section>
<section>
<h4 class="ch" id="ch0407"><span class="idx" data-level1="hiding the cursor (begin)" data-term="turtle module"/><span class="idx" data-level1="hideturtle (begin)" data-term="random module"/>Showing or Hiding the Cursor</h4>
<p class="paft">You use the following method of the <code>SpiroAnimator</code> class to toggle the turtle cursors on and off. Turning them off makes the drawing go more quickly.</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 32. " class="page" epub:type="pagebreak" id="p32" role="doc-pagebreak"/>def toggleTurtles(self):</p>
<p class="cl">    for spiro in self.spiros:</p>
<p class="cl">        if spiro.t.isvisible():</p>
<p class="cl">            spiro.t.<span class="idx" data-level1="hideturtle (end)" data-term="random module"/>hideturtle()</p>
<p class="cl">        else:</p>
<p class="cll">            spiro.t.<span class="idx" data-level1="showturtle" data-term="turtle module"/>showturtle()<span class="idx" data-level1="hiding the cursor (end)" data-term="turtle module"/></p>
</div>
<p>This method uses built-in <code>turtle</code> methods to hide the cursor if it’s visible or to show the cursor if it isn’t. Later, you’ll see how this <code>toggleTurtles()</code> method is triggered by keypresses while the animation is running.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh0405"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0405">Saving the Curves</a></h3>
<p class="paft">After all your hard work generating spiros, it would be nice to have a way to save the results. The stand-alone <code>saveDrawing()</code> function saves the contents of the drawing window as a PNG image file:</p>
<div class="codeline">
<p class="clf">def saveDrawing():</p>
<p class="cl">    # hide the turtle cursor</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ turtle.hideturtle()</p>
<p class="cl">        # generate unique filenames</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ dateStr = (datetime.now()).strftime("%d%b%Y-%H%M%S")</p>
<p class="cl">        fileName = 'spiro-' + dateStr</p>
<p class="cl">        print('saving drawing to {}.eps/png'.format(fileName))</p>
<p class="cl">        # get the tkinter canvas</p>
<p class="cl">        canvas = turtle.getcanvas()</p>
<p class="cl">        # save the drawing as a postscript image</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ canvas.<span class="idx" data-level1="canvas" data-term="tkinter module"/>postscript(file = fileName + '.eps')</p>
<p class="cl">        # use the Pillow module to convert the postscript image file to PNG</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ img = <span class="idx" data-level1="Image" data-term="Python Imaging Library (PIL)"/>Image.open(fileName + '.eps')</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ img.save(fileName + '.png', 'png')</p>
<p class="cl">        # show the turtle cursor</p>
<p class="cll">        turtle.showturtle()</p>
</div>
<p>You hide the turtle cursors so that you won’t see them in the final drawing <!--<ccust1>1</ccust1>-->❶. Then you use <code>datetime()</code> to generate unique, timestamp-based names for the image files (in the <i>day-month-year-hour-minute-second</i> format) <!--<ccust1>2</ccust1>-->❷. You append this string to <i>spiro-</i> to generate the filename.</p>
<p>The <code>turtle</code> program uses user interface (UI) windows created by <code>tkinter</code>, and you use the <code>canvas</code> object of <code>tkinter</code> to save the window in the <span class="idx" data-term="Embedded PostScript (EPS)"/>Embedded PostScript (<span class="idx" data-term="EPS (Embedded PostScript)"/>EPS) file format <!--<ccust1>3</ccust1>-->❸. Because EPS is vector based, you can use it to print your images at high resolution, but the PNG format is more versatile, so you use <code>Pillow</code> to open the EPS file <!--<ccust1>4</ccust1>-->❹ and save it as a PNG file <!--<ccust1>5</ccust1>-->❺. Finally, you unhide the turtle cursors.</p>
</section>
<section>
<h3 class="bh" id="bh0406"><span aria-label=" Page 33. " class="page" epub:type="pagebreak" id="p33" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0406">Parsing Command Line Arguments and Initialization</a></h3>
<p class="paft">Most projects in this book have command line arguments for customizing the code. Rather than trying to parse them by hand and creating a mess, delegate this mundane task to Python’s <span class="idx" data-level1="argparse" data-term="argparse module"/><code>argparse</code> module. That’s what you do in the first part of the spiro program’s <code>main()</code> function:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse module"/>ArgumentParser(description=descStr)</p>
<p class="clf">    # add expected arguments</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ parser.<span class="idx" data-level1="add_argument" data-term="argparse module"/>add_argument('--sparams', nargs=3, dest='sparams', required=False,</p>
<p class="cl">                        help="The three arguments in sparams: R, r, l.")</p>
<p class="clf">    # parse args</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ args = parser.<span class="idx" data-level1="parse_args" data-term="argparse module"/>parse_args()</p>
</div>
<p>You create an <code>ArgumentParser</code> object to manage the command line arguments <!--<ccust1>1</ccust1>-->❶. Then you add the <code>--sparams</code> argument to the parser <!--<ccust1>2</ccust1>-->❷. It consists of three components, for the <i>R</i>, <i>r</i>, and <i>l</i> parameters of a spiro. You use the <code>dest</code> option to specify the variable name the values should be stored under once the arguments are parsed, and <code>required=False</code> means this argument is optional. You call the <code>parse_args()</code> method <!--<ccust1>3</ccust1>-->❸ to actually parse the arguments. This makes the arguments available as properties of the <code>args</code> object. In this case, the values of the <code>--sparams</code> argument will be available through <code>args.sparams</code>.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> You’ll follow the same basic pattern described here throughout the book to create and parse each project’s command line arguments.</p>
<p>The <code>main()</code> function continues by setting up some <code>turtle</code> parameters:</p>
<div class="codeline">
<p class="clf">    # set the width of the drawing window to 80 percent of the screen width</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ turtle.<span class="idx" data-level1="setup" data-term="turtle module"/>setup(width=0.8)</p>
<p class="clf">    # set the cursor shape to turtle</p>
<p class="cl">    turtle.shape('turtle')</p>
<p class="clf">    # set the title to Spirographs!</p>
<p class="cl">    turtle.<span class="idx" data-level1="title" data-term="turtle module"/>title("Spirographs!")</p>
<p class="cl">    # add the key handler to save our drawings</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ turtle.<span class="idx" data-level1="onkey" data-term="turtle module"/>onkey(saveDrawing, "s")</p>
<p class="cl">    # start listening</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ turtle.<span class="idx" data-level1="listen" data-term="turtle module"/>listen()</p>
<p class="clf">    # hide the main turtle cursor</p>
<p class="cll">  <!--<ccust1>4</ccust1>-->❹ turtle.hideturtle()</p>
</div>
<p><span aria-label=" Page 34. " class="page" epub:type="pagebreak" id="p34" role="doc-pagebreak"/>You use <code>setup()</code> to set the width of the drawing window to 80 percent of the screen width <!--<ccust1>1</ccust1>-->❶. (You could also give <code>setup()</code> specific height and origin parameters.) Then you set the cursor shape to a turtle and set the title of the program window to <i>Spirographs!</i> Next, you use <code>onkey()</code> with your <code>saveDrawing()</code> function to instruct the program to save the drawing when you press the S key on your keyboard <!--<ccust1>2</ccust1>-->❷. Calling <code>listen()</code> makes the drawing window listen for user events (like keypresses) <!--<ccust1>3</ccust1>-->❸. Finally, you hide the turtle cursor <!--<ccust1>4</ccust1>-->❹.</p>
<p>The rest of the <code>main()</code> function proceeds as follows:</p>
<div class="codeline">
<p class="clf">    # check for any arguments sent to --sparams and draw the Spirograph</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if args.sparams:</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ params = [float(x) for x in args.sparams]</p>
<p class="cl">        # draw the Spirograph with the given parameters</p>
<p class="cl">        col = (0.0, 0.0, 0.0)</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ spiro = Spiro(0, 0, col, *params)</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ spiro.draw()</p>
<p class="cl">    else:</p>
<p class="cl">        # create the animator object</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ spiroAnim = SpiroAnimator(4)</p>
<p class="cl">        # add a key handler to toggle the turtle cursor</p>
<p class="cl">        turtle.onkey(spiroAnim.toggleTurtles, "t")</p>
<p class="cl">        # add a key handler to restart the animation</p>
<p class="cl">        turtle.onkey(spiroAnim.restart, "space")</p>
<p class="clf">    # start the turtle main loop</p>
<p class="cll">  <!--<ccust1>6</ccust1>-->❻ turtle.mainloop()</p>
</div>
<p>You first check whether any arguments were given to <code>--sparams</code> <!--<ccust1>1</ccust1>-->❶; if so, the program will just draw the one spiro defined by those arguments. The arguments currently exist as strings, but you need them to be interpreted as numbers. You use a <span class="idx" data-term="list comprehension"/>list comprehension to convert them into a list of floats <!--<ccust1>2</ccust1>-->❷. (A <i>list comprehension</i> is a Python construct that lets you create a list in a compact and powerful way. For example, <code>a = [2*x for x in range(1, 5)]</code> creates a list of the first four even numbers.) Then you use the parameters to construct a <code>Spiro</code> object <!--<ccust1>3</ccust1>-->❸ (with the help of the Python <code>*</code> operator, which unpacks the list into a series of arguments) and call <code>draw()</code> to draw the spiro <!--<ccust1>4</ccust1>-->❹.</p>
<p>If no arguments were specified at the command line, you enter random animation mode. For this, you create a <code>SpiroAnimator</code> object <!--<ccust1>5</ccust1>-->❺, passing it the argument <code>4</code>, which tells it to draw four spiros at once. Then you use two <code>onkey</code> calls to capture additional keypresses. Pressing the T key will show or hide the turtle cursors with the <code>toggleTurtles()</code> method, while pressing the spacebar (<code>space</code>) will call <code>restart()</code> to interrupt the animation at any point and start drawing four different random spiros. Finally, you call <code>mainloop()</code> to tell the <code>tkinter</code> window to stay open, listening for events <!--<ccust1>6</ccust1>-->❻.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0404"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0404">Running the Spirograph Animation</a></h2>
<p class="paft">Now it’s time to run your program:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python spiro.py</code></p>
</div>
<p><span aria-label=" Page 35. " class="page" epub:type="pagebreak" id="p35" role="doc-pagebreak"/>By default, the <i>spiro.py</i> program draws four random spiros simultaneously, as shown in <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-5">Figure 2-5</a>. Pressing S saves the drawing, pressing T toggles the cursors, and pressing the spacebar restarts the animation.</p>
<figure class="figure" id="fig2-5">
<p class="fig"><img alt="" height="1026" src="images/nsp-venkitachalam503045-f02005.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 2-5:</span> A sample run of <i>spiro.py</i></p>
</figcaption>
</figure>
<p>Now run the program again, this time passing in parameters at the command line to draw a particular spiro:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python spiro.py --sparams 300 100 0.9</code></p>
</div>
<p><a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-6">Figure 2-6</a> shows the output. As you can see, this code draws a single spiro with the parameters specified by the user, in contrast to <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#fig2-5">Figure 2-5</a>, which displays an animation of several random spiros.</p>
<figure class="figure" id="fig2-6">
<p class="fig"><img alt="" height="610" src="images/nsp-venkitachalam503045-f02006.jpg" style="width:95%; height:auto;" width="529"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 2-6:</span> A sample run of <i>spiro.py</i> with specific parameters</p>
</figcaption>
</figure>
<p><span aria-label=" Page 36. " class="page" epub:type="pagebreak" id="p36" role="doc-pagebreak"/>Have fun experimenting with different parameters to see how they influence the resulting curves.</p>
</section>
<section>
<h2 class="ah" id="ah0405"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0405">Summary</a></h2>
<p class="paft">In this project, you learned how to create Spirograph-like curves. You also learned how to adjust the input parameters to generate a variety of different curves and to animate them on the screen. I hope you enjoy creating these spiros. (You’ll find a surprise in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#ch13">Chapter 13</a>, where you’ll learn how to project spiros onto a wall!)</p>
</section>
<section>
<h2 class="ah" id="ah0406"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0406">Experiments!</a></h2>
<p class="paft">Here are some ways to experiment further with spiros:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Now that you know how to draw circles, write a program to draw random <i>spirals</i>. Find the equation for a <span class="idx" data-term="spiral"/><i>logarithmic spiral</i> in parametric form and then use it to draw the spirals.</li>
<li class="nl">2. You might have noticed that the turtle cursor is always oriented to the right as the curves are drawn, but that’s not how turtles move! Orient the turtle so that, as the curve is being drawn, it faces in the direction of drawing. (Hint: calculate the direction vector between successive points for every step and reorient the turtle using the <code>turtle</code><span class="idx" data-level1="setheading" data-term="turtle module"/>.<code>setheading()</code> method.)</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0407"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0407">The Complete Code</a></h2>
<p class="paft">Here’s the complete Spirograph program:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">spiro.py</p>
<p class="clf">A Python program that simulates a Spirograph.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import random, argparse</p>
<p class="cl">import numpy as np</p>
<p class="cl">import math</p>
<p class="cl">import turtle</p>
<p class="cl">import random</p>
<p class="cl">from PIL import Image</p>
<p class="cl">from datetime import datetime</p>
<p class="clf"># a class that draws a spiro</p>
<p class="cl">class Spiro:</p>
<p class="cl">    # constructor</p>
<p class="cl">    def __init__(self, xc, yc, col, R, r, l):</p>
<p class="clf"><span aria-label=" Page 37. " class="page" epub:type="pagebreak" id="p37" role="doc-pagebreak"/>        # create own turtle</p>
<p class="cl">        self.t = turtle.Turtle()</p>
<p class="cl">        # set cursor shape</p>
<p class="cl">        self.t.shape('turtle')</p>
<p class="cl">        # set step in degrees</p>
<p class="cl">        self.step = 5</p>
<p class="cl">        # set drawing complete flag</p>
<p class="cl">        self.drawingComplete = False</p>
<p class="clf">        # set parameters</p>
<p class="cl">        self.setparams(xc, yc, col, R, r, l)</p>
<p class="clf">        # initialize drawing</p>
<p class="cl">        self.restart()</p>
<p class="clf">    # set parameters</p>
<p class="cl">    def setparams(self, xc, yc, col, R, r, l):</p>
<p class="cl">        # spirograph parameters</p>
<p class="cl">        self.xc = xc</p>
<p class="cl">        self.yc = yc</p>
<p class="cl">        self.R = int(R)</p>
<p class="cl">        self.r = int(r)</p>
<p class="cl">        self.l = l</p>
<p class="cl">        self.col = col</p>
<p class="cl">        # reduce r/R to smallest form by dividing with GCD</p>
<p class="cl">        gcdVal = math.gcd(self.r, self.R)</p>
<p class="cl">        self.nRot = self.r//gcdVal</p>
<p class="cl">        # get ratio of radii</p>
<p class="cl">        self.k = r/float(R)</p>
<p class="cl">        # set color</p>
<p class="cl">        self.t.color(*col)</p>
<p class="cl">        # current angle</p>
<p class="cl">        self.a = 0</p>
<p class="clf">    # restart drawing</p>
<p class="cl">    def restart(self):</p>
<p class="cl">        # set flag</p>
<p class="cl">        self.drawingComplete = False</p>
<p class="cl">        # show turtle</p>
<p class="cl">        self.t.showturtle()</p>
<p class="cl">        # go to first point</p>
<p class="cl">        self.t.up()</p>
<p class="cl">        R, k, l = self.R, self.k, self.l</p>
<p class="cl">        a = 0.0</p>
<p class="cl">        x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))</p>
<p class="cl">        y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))</p>
<p class="cl">        try:</p>
<p class="cl">            self.t.setpos(self.xc + x, self.yc + y)</p>
<p class="cl">        except:</p>
<p class="cl">            print("Exception, exiting.")</p>
<p class="cl">            exit(0)</p>
<p class="cl">        self.t.down()</p>
<p class="clf">    # draw the whole thing</p>
<p class="cl">    def draw(self):</p>
<p class="cl"><span aria-label=" Page 38. " class="page" epub:type="pagebreak" id="p38" role="doc-pagebreak"/>        # draw rest of points</p>
<p class="cl">        R, k, l = self.R, self.k, self.l</p>
<p class="cl">        for i in range(0, 360*self.nRot + 1, self.step):</p>
<p class="cl">            a = math.radians(i)</p>
<p class="cl">            x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))</p>
<p class="cl">            y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))</p>
<p class="cl">            try:</p>
<p class="cl">                self.t.setpos(self.xc + x, self.yc + y)</p>
<p class="cl">            except:</p>
<p class="cl">                print("Exception, exiting.")</p>
<p class="cl">                exit(0)</p>
<p class="cl">        # done - hide turtle</p>
<p class="cl">        self.t.hideturtle()</p>
<p class="clf">    # update by one step</p>
<p class="cl">    def update(self):</p>
<p class="cl">        # skip if done</p>
<p class="cl">        if self.drawingComplete:</p>
<p class="cl">            return</p>
<p class="cl">        # increment angle</p>
<p class="cl">        self.a += self.step</p>
<p class="cl">        # draw step</p>
<p class="cl">        R, k, l = self.R, self.k, self.l</p>
<p class="cl">        # set angle</p>
<p class="cl">        a = math.radians(self.a)</p>
<p class="cl">        x = self.R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))</p>
<p class="cl">        y = self.R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))</p>
<p class="cl">        try:</p>
<p class="cl">            self.t.setpos(self.xc + x, self.yc + y)</p>
<p class="cl">        except:</p>
<p class="cl">            print("Exception, exiting.")</p>
<p class="cl">            exit(0)</p>
<p class="cl">        # check if drawing is complete and set flag</p>
<p class="cl">        if self.a &gt;= 360*self.nRot:</p>
<p class="cl">            self.drawingComplete = True</p>
<p class="cl">            # done - hide turtle</p>
<p class="cl">            self.t.hideturtle()</p>
<p class="clf">    # clear everything</p>
<p class="cl">    def clear(self):</p>
<p class="cl">        # pen up</p>
<p class="cl">        self.t.up()</p>
<p class="cl">        # clear turtle</p>
<p class="cl">        self.t.clear()</p>
<p class="clf"># a class for animating spiros</p>
<p class="cl">class SpiroAnimator:</p>
<p class="cl">    # constructor</p>
<p class="cl">    def __init__(self, N):</p>
<p class="cl">        # timer value in milliseconds</p>
<p class="cl">        self.deltaT = 10</p>
<p class="cl">        # get window dimensions</p>
<p class="cl">        self.width = turtle.window_width()</p>
<p class="cl">        self.height = turtle.window_height()</p>
<p class="cl">        # restarting</p>
<p class="cl"><span aria-label=" Page 39. " class="page" epub:type="pagebreak" id="p39" role="doc-pagebreak"/>        self.restarting = False</p>
<p class="cl">        # create spiro objects</p>
<p class="cl">        self.spiros = []</p>
<p class="cl">        for i in range(N):</p>
<p class="cl">            # generate random parameters</p>
<p class="cl">            rparams = self.genRandomParams()</p>
<p class="cl">            # set spiro params</p>
<p class="cl">            spiro = Spiro(*rparams)</p>
<p class="cl">            self.spiros.append(spiro)</p>
<p class="cl">        # call timer</p>
<p class="cl">        turtle.ontimer(self.update, self.deltaT)</p>
<p class="clf">    # restart spiro drawing</p>
<p class="cl">    def restart(self):</p>
<p class="cl">        # ignore restart if already in the middle of restarting</p>
<p class="cl">        if self.restarting:</p>
<p class="cl">            return</p>
<p class="cl">        else:</p>
<p class="cl">            self.restarting = True</p>
<p class="cl">        # restart</p>
<p class="cl">        for spiro in self.spiros:</p>
<p class="cl">            # clear</p>
<p class="cl">            spiro.clear()</p>
<p class="cl">            # generate random parameters</p>
<p class="cl">            rparams = self.genRandomParams()</p>
<p class="cl">            # set spiro params</p>
<p class="cl">            spiro.setparams(*rparams)</p>
<p class="cl">            # restart drawing</p>
<p class="cl">            spiro.restart()</p>
<p class="cl">        # done restarting</p>
<p class="cl">        self.restarting = False</p>
<p class="clf">    # generate random parameters</p>
<p class="cl">    def genRandomParams(self):</p>
<p class="cl">        width, height = self.width, self.height</p>
<p class="cl">        R = random.randint(50, min(width, height)//2)</p>
<p class="cl">        r = random.randint(10, 9*R//10)</p>
<p class="cl">        l = random.uniform(0.1, 0.9)</p>
<p class="cl">        xc = random.randint(-width//2, width//2)</p>
<p class="cl">        yc = random.randint(-height//2, height//2)</p>
<p class="cl">        col = (random.random(),</p>
<p class="cl">               random.random(),</p>
<p class="cl">               random.random())</p>
<p class="cl">        return (xc, yc, col, R, r, l)</p>
<p class="clf">    def update(self):</p>
<p class="cl">        # update all spiros</p>
<p class="cl">        nComplete = 0</p>
<p class="cl">        for spiro in self.spiros:</p>
<p class="cl">            # update</p>
<p class="cl">            spiro.update()</p>
<p class="cl">            # count completed ones</p>
<p class="cl">            if spiro.drawingComplete:</p>
<p class="cl">                nComplete+= 1</p>
<p class="cl">        # if all spiros are complete, restart</p>
<p class="cl"><span aria-label=" Page 40. " class="page" epub:type="pagebreak" id="p40" role="doc-pagebreak"/>        if nComplete == len(self.spiros):</p>
<p class="cl">            self.restart()</p>
<p class="cl">        # call timer</p>
<p class="cl">        try:</p>
<p class="cl">            turtle.ontimer(self.update, self.deltaT)</p>
<p class="cl">        except:</p>
<p class="cl">            print("Exception, exiting.")</p>
<p class="cl">            exit(0)</p>
<p class="clf">    # toggle turtle on/off</p>
<p class="cl">    def toggleTurtles(self):</p>
<p class="cl">        for spiro in self.spiros:</p>
<p class="cl">            if spiro.t.isvisible():</p>
<p class="cl">                spiro.t.hideturtle()</p>
<p class="cl">            else:</p>
<p class="cl">                spiro.t.showturtle()</p>
<p class="clf"># save spiros to image</p>
<p class="cl">def saveDrawing():</p>
<p class="cl">    # hide turtle</p>
<p class="cl">    turtle.hideturtle()</p>
<p class="cl">    # generate unique filename</p>
<p class="cl">    dateStr = (datetime.now()).strftime("%d%b%Y-%H%M%S")</p>
<p class="cl">    fileName = 'spiro-' + dateStr</p>
<p class="cl">    print('saving drawing to {}.eps/png'.format(fileName))</p>
<p class="cl">    # get tkinter canvas</p>
<p class="cl">    canvas = turtle.getcanvas()</p>
<p class="cl">    # save postscript image</p>
<p class="cl">    canvas.postscript(file = fileName + '.eps')</p>
<p class="cl">    # use PIL to convert to PNG</p>
<p class="cl">    img = Image.open(fileName + '.eps')</p>
<p class="cl">    img.save(fileName + '.png', 'png')</p>
<p class="cl">    # show turtle</p>
<p class="cl">    turtle.showturtle()</p>
<p class="clf"># main() function</p>
<p class="cl">def main():</p>
<p class="cl">    # use sys.argv if needed</p>
<p class="cl">    print('generating spirograph...')</p>
<p class="cl">    # create parser</p>
<p class="cl">    descStr = """This program draws spirographs using the Turtle module.</p>
<p class="cl">    When run with no arguments, this program draws random spirographs.</p>
<p class="clf">    Terminology:</p>
<p class="cl">    R: radius of outer circle.</p>
<p class="cl">    r: radius of inner circle.</p>
<p class="cl">    l: ratio of hole distance to r.</p>
<p class="cl">    """</p>
<p class="cl">    parser = argparse.ArgumentParser(description=descStr)</p>
<p class="clf">    # add expected arguments</p>
<p class="cl">    parser.add_argument('--sparams', nargs=3, dest='sparams', required=False,</p>
<p class="cl">                        help="The three arguments in sparams: R, r, l.")</p>
<p class="clf"><span aria-label=" Page 41. " class="page" epub:type="pagebreak" id="p41" role="doc-pagebreak"/>    # parse args</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # set to 80% screen width</p>
<p class="cl">    turtle.setup(width=0.8)</p>
<p class="clf">    # set cursor shape</p>
<p class="cl">    turtle.shape('turtle')</p>
<p class="clf">    # set title</p>
<p class="cl">    turtle.title("Spirographs!")</p>
<p class="cl">    # add key handler for saving images</p>
<p class="cl">    turtle.onkey(saveDrawing, "s")</p>
<p class="cl">    # start listening</p>
<p class="cl">    turtle.listen()</p>
<p class="clf">    # hide main turtle cursor</p>
<p class="cl">    turtle.hideturtle()</p>
<p class="clf">    # check args and draw</p>
<p class="cl">    if args.sparams:</p>
<p class="cl">        params = [float(x) for x in args.sparams]</p>
<p class="cl">        # draw spirograph with given parameters</p>
<p class="cl">        # black by default</p>
<p class="cl">        col = (0.0, 0.0, 0.0)</p>
<p class="cl">        spiro = Spiro(0, 0, col, *params)</p>
<p class="cl">        spiro.draw()</p>
<p class="cl">    else:</p>
<p class="cl">        # create animator object</p>
<p class="cl">        spiroAnim = SpiroAnimator(4)</p>
<p class="cl">        # add key handler to toggle turtle cursor</p>
<p class="cl">        turtle.onkey(spiroAnim.toggleTurtles, "t")</p>
<p class="cl">        # add key handler to restart animation</p>
<p class="cl">        turtle.onkey(spiroAnim.restart, "space")</p>
<p class="clf">    # start turtle main loop</p>
<p class="cl">    turtle.mainloop()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>