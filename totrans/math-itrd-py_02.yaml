- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DRAWING POLYGONS WITH THE TURTLE MODULE
  prefs: []
  type: TYPE_NORMAL
- en: '*Centuries ago a Westerner heard a Hindu say the Earth rested on the back of
    a turtle. When asked what the turtle was standing on, the Hindu explained, “It’s
    turtles all the way down.”*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before you can start using math to build all the cool things you see in this
    book, you’ll need to learn how to give instructions to your computer using a programming
    language called Python. In this chapter you’ll get familiar with some basic programming
    concepts like loops, variables, and functions by using Python’s built-in turtle
    tool to draw different shapes. As you’ll see, the turtle module is a fun way to
    learn about Python’s basic features and get a taste of what you’ll be able to
    create with programming.
  prefs: []
  type: TYPE_NORMAL
- en: PYTHON’S TURTLE MODULE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python turtle tool is based on the original “turtle” agent from the Logo
    programming language, which was invented in the 1960s to make computer programming
    more accessible to everyone. Logo’s graphical environment made interacting with
    the computer visual and engaging. (Check out Seymour Papert’s brilliant book *Mindstorms*
    for more great ideas for learning math using Logo’s virtual turtles.) The creators
    of the Python programming language liked the Logo turtles so much that they wrote
    a module called *turtle* in Python to copy the Logo turtle functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s turtle module lets you control a small image shaped like a turtle,
    just like a video game character. You need to give precise instructions to direct
    the turtle around the screen. Because the turtle leaves a trail wherever it goes,
    we can use it to write a program that draws different shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by importing the turtle module!
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTING THE TURTLE MODULE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open a new Python file in IDLE and save it as *myturtle.py* in the Python folder.
    You should see a blank page. To use turtles in Python, you have to import the
    functions from the turtle module first.
  prefs: []
  type: TYPE_NORMAL
- en: A *function* is a set of reusable code for performing a specific action in a
    program. There are many built-in functions you can use in Python, but you can
    also write your own functions (you’ll learn how to write your own functions later
    in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: A *module* in Python is a file that contains predefined functions and statements
    that you can use in another program. For example, the turtle module contains a
    lot of useful code that was automatically downloaded when you installed Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although functions can be imported from a module in many ways, we’ll use a
    simple one here. In the *myturtle.py* file you just created, enter the following
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `from` command indicates that we’re importing something from outside our
    file. We then give the name of the module we want to import from, which is `turtle`
    in this case. We use the `import` keyword to get the useful code we want *from*
    the turtle module. We use the asterisk (`*`) here as a *wildcard command* that
    means “import everything from that module.” Make sure to put a space between `import`
    and the asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and make sure it’s in the Python folder; otherwise, the program
    will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not save the file as* turtle.py. *This filename already exists and will
    cause a conflict with the import from the turtle module! Anything else will work:*
    myturtle.py, turtle2.py, mondayturtle.py, *and so on*.'
  prefs: []
  type: TYPE_NORMAL
- en: MOVING YOUR TURTLE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you’ve imported the turtle module, you’re ready to enter instructions
    to move the turtle. We’ll use the `forward()` function (abbreviated as `fd`) to
    move the turtle forward a certain number of steps while leaving a trail behind
    it. Note that `forward()` is one of the functions we just imported from the turtle
    module. Enter the following to make the turtle go forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `forward()` function with the number 100 inside parentheses
    to indicate how many steps the turtle should move. In this case, 100 is the *argument*
    we pass to the `forward()` function. All functions take one or more arguments.
    Feel free to pass other numbers to this function. When you press F5 to run the
    program, a new window should open with an arrow in the center, as shown in [Figure
    1-1](ch01.xhtml#ch01fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f005-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Running your first line of code!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the turtle started in the middle of the screen and walked forward
    100 steps (it’s actually 100 pixels). Notice that the default shape is an arrow,
    not a turtle, and the default direction the arrow is facing is to the right. To
    change the arrow into a turtle, update your code so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably tell, `shape()` is another function defined in the turtle
    module. It lets you change the shape of the default arrow into other shapes, like
    a circle, a square, or an arrow. Here, the `shape()` function takes the string
    value `'turtle'` as its argument, not a number. (You’ll learn more about strings
    and different data types in the next chapter.) Save and run the *myturtle.py*
    file again. You should see something like [Figure 1-2](ch01.xhtml#ch01fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f006-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Changing the arrow into a turtle!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now your arrow should look like a tiny turtle!
  prefs: []
  type: TYPE_NORMAL
- en: CHANGING DIRECTIONS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The turtle can go only in the direction it’s facing. To change the turtle’s
    direction, you must first make the turtle turn a specified number of degrees using
    the `right()` or `left()` function and then go forward. Update your *myturtle.py*
    program by adding the last two lines of code shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ll use the `right()` function (or `rt()` for short) to make the turtle
    turn right 45 degrees before moving forward by 150 steps. When you run this code,
    the output should look like [Figure 1-3](ch01.xhtml#ch01fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f006-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: Changing turtle’s direction*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the turtle started in the middle of the screen, went forward
    100 steps, turned right 45 degrees, and then went forward another 150 steps. Notice
    that Python runs each line of code in order, from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 1-1: SQUARE DANCE'
  prefs: []
  type: TYPE_NORMAL
- en: Return to the *myturtle.py* program. Your first challenge is to modify the code
    in the program using only the `forward` and `right` functions so that the turtle
    draws a square.
  prefs: []
  type: TYPE_NORMAL
- en: REPEATING CODE WITH LOOPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every programming language has a way to automatically repeat commands a given
    number of times. This is useful because it saves you from having to type out the
    same code over and over and cluttering your program. It also helps you avoid typos
    that can prevent your program from running properly.
  prefs: []
  type: TYPE_NORMAL
- en: USING THE FOR LOOP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Python we use the `for` loop to repeat code. We also use the `range` keyword
    to specify the number of times we go through the loop. Open a new program file
    in IDLE, save it as *for_loop.py*, and then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `range()` function creates `i`, or an *iterator*, for each for loop.
    The iterator is a value that increases each time it’s used. The number 2 in parentheses
    is the argument we pass to the function to control its behavior. This is similar
    to the way we passed different values to the `forward()` and `right()` functions
    in previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `range(2)` creates a sequence of two numbers, 0 and 1\. For each
    of these two numbers, the `for` command performs the action specified after the
    colon, which is to print the word *hello*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to indent all the lines of the code you want to repeat by pressing
    TAB (one tab is four spaces). Indentation tells Python which lines are inside
    the loop so `for` knows exactly what code to repeat. And don’t forget the colon
    at the end; it tells the computer what’s coming up after it is in the loop. When
    you run the program, you should see the following printed in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the program prints `hello` twice because `range(2)` creates
    a sequence containing two numbers, 0 and 1\. This means that the `for` command
    loops over the two items in the sequence, printing “hello” each time. Let’s update
    the number in the parentheses, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this program, you should get `hello` ten times, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try another example since you’ll be writing a lot of `for` loops in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because counting begins at 0 rather than 1 in Python, `for i in range(10)`
    gives us the numbers 0 through 9\. This sample code is saying “for each value
    in the range 0 to 9, display the current number.” The `for` loop then repeats
    the code until it runs out of numbers in the range. When you run this code, you
    should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the future you’ll have to remember that `i` starts at 0 and ends before
    the last number in a loop using `range`, but for now, if you want something repeated
    four times, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s as simple as that! Let’s see how we can put this to use.
  prefs: []
  type: TYPE_NORMAL
- en: USING A FOR LOOP TO DRAW A SQUARE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Exercise 1-1 your challenge was to make a square using only the `forward()`
    and `right()` functions. To do this, you had to repeat `forward(100)` and `right(90)`
    four times. But this required entering the same code multiple times, which is
    time-consuming and can lead to mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a `for` loop to avoid repeating the same code. Here’s the *myturtle.py*
    program, which uses a `for` loop instead of repeating the `forward()` and `right()`
    functions four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that `shape('turtle')` should come right after you import the turtle module
    and before you start drawing. The two lines of code inside this `for` loop tell
    the turtle to go forward 100 steps and then turn 90 degrees to the right. (You
    might have to face the same way as the turtle to know which way “right” is!) Because
    a square has four sides, we use `range(4)` to repeat these two lines of code four
    times. Run the program, and you should see something like [Figure 1-4](ch01.xhtml#ch01fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f009-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: A square made with a `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: You should see that the turtle moves forward and turns to the right a total
    of four times, finally returning to its original position. You successfully drew
    a square using a `for` loop!
  prefs: []
  type: TYPE_NORMAL
- en: CREATING SHORTCUTS WITH FUNCTIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve written code to draw a square, we can save all that code to a
    magic keyword that we can call any time we want to use that square code again.
    Every programming language has a way to do this, and in Python it’s called a *function*,
    which is the most important feature of computer programming. Functions make code
    compact and easier to maintain, and dividing a problem up into functions often
    allows you to see the best way of solving it. Earlier you used some built-in functions
    that come with the turtle module. In this section you learn how to define your
    own function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a function you start by giving it a name. This name can be anything
    you want, as long as it’s not already a Python keyword, like `list`, `range`,
    and so on. When you’re naming functions, it’s better to be descriptive so you
    can remember what they’re for when you use them again. Let’s call our function
    `square()` because we’ll be using it to make a square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `def` command tells Python we’re defining a function, and the word we list
    afterward will become the function name; here, it’s `square()`. Don’t forget the
    parentheses after `square`! They’re a sign in Python that you’re dealing with
    a function. Later we’ll put values inside them, but even without any values inside,
    the parentheses need to be included to let Python know you are defining a function.
    Also, don’t forget the colon at the end of the function definition. Note that
    we indent all the code inside the function to let Python know which code goes
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this program now, nothing will happen. You’ve defined a function,
    but you didn’t tell the program to run it yet. To do this, you need to *call*
    the function at the end of the *myturtle.py* file after the function definition.
    Enter the code shown in [Listing 1-1](ch01.xhtml#ch01list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: The `square()` function is called at the end of the file*.'
  prefs: []
  type: TYPE_NORMAL
- en: When you call `square()` at the end like this, the program should run properly.
    Now you can use the `square()` function at any point later in the program to quickly
    draw another square.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use this function in a loop to build something more complicated.
    For example, to draw a square, turn right a little, make another square, turn
    right a little, and repeat those steps multiple times, putting the function inside
    a loop makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: The next exercise shows an interesting-looking shape that’s made of squares!
    It might take your turtle a while to create this shape, so you can speed it up
    by adding the `speed()` function to *myturtle.py* after `shape('turtle')`. Using
    `speed(0)` makes the turtle move the fastest, whereas `speed(1)` is the slowest.
    Try different speeds, like `speed(5)` and `speed(10)`, if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 1-2: A CIRCLE OF SQUARES'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write and run a function that draws 60 squares, turning right 5 degrees after
    each square. Use a loop! Your result should end up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f011-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: USING VARIABLES TO DRAW SHAPES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far all our squares are the same size. To make squares of different sizes,
    we’ll need to vary the distance the turtle walks forward for each side. Instead
    of changing the definition for the `square()` function every time we want a different
    size, we can use a *variable*, which in Python is a word that represents a value
    you can change. This is similar to the way *x* in algebra can represent a value
    that can change in an equation.
  prefs: []
  type: TYPE_NORMAL
- en: In math class, variables are single letters, but in programming you can give
    a variable any name you want! Like with functions, I suggest naming variables
    something descriptive to make reading and understanding your code easier.
  prefs: []
  type: TYPE_NORMAL
- en: USING VARIABLES IN FUNCTIONS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you define a function, you can use variables as the function’s parameters
    inside the parentheses. For example, you can change your `square()` function definition
    in the *myturtle.py* program to the following to create squares of any size rather
    than a fixed size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `sidelength` to define the `square()` function. Now when you call
    this function, you have to place a value, which we call an *argument*, inside
    the parentheses, and whatever number is inside the parentheses will be used in
    place of `sidelength`. For example, calling `square(50)` and `square(80)` would
    look like [Figure 1-5](ch01.xhtml#ch01fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f012-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: A square of size 50 and a square of size 80*'
  prefs: []
  type: TYPE_NORMAL
- en: When you use a variable to define a function, you can simply call the `square()`
    function by entering different numbers without having to update the function definition
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: VARIABLE ERRORS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the moment, if we forget to put a value in the parentheses for the function,
    we’ll get this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This error tells us that we’re missing a value for `sidelength`, so Python
    doesn’t know how big to make the square. To avoid this, we can give a default
    value for the length in the first line of the function definition, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we place a default value of 100 in `sidelength`. Now if we put a value
    in the parentheses after `square`, it’ll make a square of that length, but if
    we leave the parentheses empty, it’ll default to a square of `sidelength` 100
    and won’t give us an error. The updated code should produce the drawing shown
    in [Figure 1-6](ch01.xhtml#ch01fig6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f012-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: A default square of size 100, a square of size 50, and a square
    of size 30*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a default value like this makes it easier to use our function without
    having to worry about getting errors if we do something wrong. In programming
    this is called making the program more *robust*.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 1-3: TRI AND TRI AGAIN'
  prefs: []
  type: TYPE_NORMAL
- en: Write `a triangle()` function that will draw a triangle of a given “side length.”
  prefs: []
  type: TYPE_NORMAL
- en: EQUILATERAL TRIANGLES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *polygon* is a many-sided figure. An *equilateral triangle* is a special type
    of polygon that has three equal sides. [Figure 1-7](ch01.xhtml#ch01fig7) shows
    what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f013-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: The angles in an equilateral triangle, including one external
    angle*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An equilateral triangle has three equal internal angles of 60 degrees. Here’s
    a rule you might remember from geometry class: all three angles of an equilateral
    triangle add up to 180 degrees. In fact, this is true for all triangles, not just
    equilateral triangles.'
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE TRIANGLE() FUNCTION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use what you’ve learned so far to write a function that makes the turtle walk
    in a triangular path. Because each angle in an equilateral triangle is 60 degrees,
    you can update the `right()` movement in your `square()` function to `60`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But when you save and run this program, you won’t get a triangle. Instead, you'll
    see something like [Figure 1-8](ch01.xhtml#ch01fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f014-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-8: A first attempt at drawing a triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That looks like we’re starting to draw a hexagon (a six-sided polygon), not
    a triangle. We get a hexagon instead of a triangle because we entered 60 degrees,
    which is the *internal* angle of an equilateral triangle. We need to enter the
    *external* angle to the `right()` function instead, because the turtle *turns*
    the external angle, not the internal angle. This wasn’t a problem with the square
    because it just so happens the internal angle of a square and the external angle
    are the same: 90 degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: To find the external angle for a triangle, simply subtract the internal angle
    from 180\. This means the external angle of an equilateral triangle is 120 degrees.
    Update 60 in the code to 120, and you should get a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 1-4: POLYGON FUNCTIONS'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `polygon` that takes an integer as an argument and makes
    the turtle draw a polygon with that integer’s number of sides.
  prefs: []
  type: TYPE_NORMAL
- en: MAKING VARIABLES VARY
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s more we can do with variables: we can automatically increase the variable
    by a certain amount so that each time we run the function, the square is bigger
    than the last. For example, using a `length` variable, we can make a square, then
    increase the `length` variable a little before making the next square by incrementing
    the variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As a math guy, this line of code didn’t make sense to me when I first saw it!
    How can “length equal length + 5”? It’s not possible! But code isn’t an equation,
    and an equal sign (`=`) in this case doesn’t mean “this side equals that side.”
    *The equal sign in programming means we’re assigning a value*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example. Open the Python shell and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we’re creating a variable called `radius` (if there isn’t one already)
    and assigning it the value 10\. You can always assign a different value to it
    later, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Press ENTER and your code will be executed. This means the value 20 will be
    assigned to the `radius` variable. To check whether a variable is equal to something,
    use double equal signs (`==`). For example, to check whether the value of the
    `radius` variable is 20, you can enter this into the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Press ENTER and it should print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the value of the `radius` variable is 20\. It’s often useful to increment
    variables rather than assign them number values manually. You can use a variable
    called `count` to count how many times something happens in a program. It should
    start at 0 and go up by one after every occurrence. To make a variable go up by
    one in value, you add 1 to its value and then assign the new value to the variable,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also write this as follows to make the code more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This means “add 1 to my count variable.” You can use addition, subtraction,
    multiplication, and division in this notation. Let’s see it in action by running
    this code in the Python shell. We’ll assign `x` the value 12 and `y` the value
    3, and then make `x` go up by `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice `y` didn’t change. We can increment `x` using addition, subtraction,
    multiplication, and division with similar notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll set `x` to one less than its current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that `x` is 16\. Now let’s set `x` to two times its current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can set `x` to a quarter of its value by dividing it by 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to increment a variable using arithmetic operators followed
    by an equal sign. In sum, `x += 3` will make `x` go up by 3, whereas `x -= 1`
    will make it go down by 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following line of code to make the length increment by 5 every
    loop, which will come in handy in the next exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this notation, every time the `length` variable is used, 5 is added to
    the value and saved into the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 1-5: TURTLE SP IRAL'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a function to draw 60 squares, turning 5 degrees after each square and
    making each successive square bigger. Start at a `length` of 5 and increment 5
    units every square. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f016-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SUMMARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to use Python’s turtle module and its built-in
    functions like `forward()` and `right()` to draw different shapes. You also saw
    that the turtle can perform many more functions than those we covered here. There
    are dozens more that I encourage you to experiment with before moving on to the
    next chapter. If you do a web search for “python turtle,” the first result will
    probably be the turtle module documentation on the official Python website (*[https://python.org/](https://python.org/)*)
    website. You’ll find all the turtle methods on that page, some of which is shown
    in [Figure 1-9](ch01.xhtml#ch01fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f017-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-9: You can find many more turtle functions and methods on the Python
    website!*'
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to define your own functions, thus saving valuable code that
    can be reused at any time. You also learned how to run code multiple times using
    `for` loops without having to rewrite the code. Knowing how to save time and avoid
    mistakes using functions and loops will be useful when you build more complicated
    math tools later on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we’ll build on the basic arithmetic operators you used to
    increment variables. You’ll learn more about the basic operators and data types
    in Python and how to use them to build simple computation tools. We’ll also explore
    how to store items in lists and use indices to access list items.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 1-6: A STAR IS BORN'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, write a “star” function that will draw a five-pointed star, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f018-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, write a function called `starSpiral()` that will draw a spiral of stars,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f018-02.jpg)'
  prefs: []
  type: TYPE_IMG
