- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Variables and Types
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和类型
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 的一些最具误导性的误解围绕其在变量和数据类型方面的细微差别展开。与这个*单一*话题相关的误解导致了无数令人沮丧的错误，这真令人遗憾。Python
    处理变量的方式是其强大和多功能的核心。如果你理解了这一点，其他的都会迎刃而解。
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个话题的理解是在 Ned Batchelder 于 PyCon 2015 上发表的那场现在已成传奇的演讲《Python 名称与值的事实与误区》中巩固的。我推荐你在阅读本章后，观看演讲视频：[https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns)。
- en: 'Variables According to Python: Names and Values'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据 Python 的变量：名称和值
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 变量的许多误解源于人们试图用*其他语言*的术语来描述 Python。对 Python 专家来说，最令人烦恼的莫过于那句误导性的格言：“Python
    没有变量”，这实际上只是某些人对 Python 语言使用*名称*和*值*而非*变量*这一事实过度聪明的产物。
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者仍然会定期使用*变量*一词，它甚至出现在文档中，因为它是理解整体系统的一部分。然而，为了清晰起见，接下来我将全书中仅使用官方的 Python
    术语。
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用*名称*一词来表示传统上称为变量的东西。一个名称指向一个值或对象，就像你的名字指向你自己，但并不包含你。甚至同一事物可能有多个名称，就像你可能有名字和昵称一样。*值*是内存中数据的特定实例。*变量*一词指的是这两者的结合：一个指向值的名称。从现在开始，我将仅在与这个精确定义相关时使用*变量*一词。
- en: Assignment
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我根据上述定义定义变量时，底层发生了什么：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: *simple_assignment.py:1*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-1: *simple_assignment.py:1*'
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`answer`被*绑定*到值`42`，意味着该名称现在可以用于引用内存中的该值。这个绑定操作称为*赋值*。
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将变量`answer`赋值给新变量`insight`时，看看幕后发生了什么：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: *simple_assignment.py:2*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-2: *simple_assignment.py:2*'
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`insight`并不指向值`42`的副本，而是指向相同的、原始的值。这一点在[图 5-1](#figure5-1)中得到了说明。
- en: '![](image_fi/500920c05/f05001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/500920c05/f05001.png)'
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5-1: 多个名称可以绑定到内存中的同一个值。'
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，`insight` 这个名称被绑定到值 `42`，而该值已经绑定到了另一个名称 `answer`。两个名称仍然可以作为变量使用。更重要的是，`insight`
    不是绑定到 `answer`，而是绑定到 `answer` 已经绑定的那个值。一个名称总是指向一个值。
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章，我介绍了 `is` 操作符，它比较的是 *标识*——即名称所绑定的内存位置。这意味着 `is` 不检查名称是否指向等价的值，而是检查它是否指向内存中的
    *相同* 值。
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行赋值时，Python 会在幕后做出决定，决定是创建一个新的内存值，还是绑定到现有的值。程序员通常对这个决策几乎没有控制权。
- en: 'To see this, run this example in an interactive session instead of a file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证这一点，请在交互式会话中运行这个示例，而不是在文件中运行：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: (Interactive session):1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-3: （交互式会话）：1'
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我将相同的值赋给了 `spam` 和 `eggs`。我还将 `maps` 绑定到与 `spam` 相同的值。（如果你没注意到的话，“maps”是“spam”倒过来的，难怪
    GPS 有时让人烦恼。）
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用比较操作符（`==`）比较名称，检查它们的值是否等价时，两者的表达式都返回 `True`，这也是预期的结果：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: (Interactive session):2'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-4: （交互式会话）：2'
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我将名称的标识与`is`进行比较时，发生了一些令人惊讶的事情：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: (Interactive session):3'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-5: （交互式会话）：3'
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam` 和 `maps` 这两个名称都绑定到内存中相同的值，但 `eggs` 可能绑定到一个不同但等价的值。因此，`spam` 和 `eggs`
    并不共享标识。这在 [图 5-2](#figure5-2) 中有所说明。'
- en: '![](image_fi/500920c05/f05002.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/500920c05/f05002.png)'
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：`spam` 和 `maps` 共享相同的标识；`eggs` 被绑定到一个等价的值，但它不共享标识。
- en: It just goes to show, spam by any other name is still spam.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这恰恰证明了，垃圾邮件无论叫什么名字，仍然是垃圾邮件。
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不保证完全按这种方式运行，它可能决定重用一个现有的值。例如：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: (Interactive session)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-6: （交互式会话）'
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将值 `42` 赋给 `insight` 时，Python 决定将该名称绑定到现有的值。现在，`answer` 和 `insight` 恰好都绑定到内存中的同一值，因此它们共享一个标识。
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么标识符操作符（`is`）可能会显得有点“狡猾”。在许多情况下，`is` 看起来就像比较操作符（`==`）一样工作。
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的说明，内建函数 `id()` 返回一个整数，表示传递给它的对象的标识。这些整数是 `is` 操作符比较的值。如果你对 Python 如何处理名称和值感到好奇，可以尝试使用
    `id()`。
- en: Data Types
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Python 不要求你作为程序员声明变量的类型。早在我第一次接触 Python 时，我加入了 IRC 上的 `#python`
    频道，直接开始了编程。
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “你如何在 Python 中声明变量的数据类型？”我问道，带着一个初学者的天真。
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，我收到了我认为是自己第一次真正进入编程奇妙世界的回答：“你是一个数据类型。”
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 常客们继续解释，Python 是一种动态类型语言，这意味着我不需要告诉语言变量应该存储什么类型的信息。相反，Python 会为我决定类型。我甚至不需要使用特殊的“变量声明”关键字。我只需要像这样赋值：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: *types.py:1*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-7: *types.py:1*'
- en: At that precise moment, Python became my all-time favorite language.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一刻，Python 成为了我最喜欢的编程语言。
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Python 仍然是一个强类型语言。我在第三章中提到过这个概念，连同动态类型一起。Ned Batchelder 在他之前提到的 2015
    年 PyCon 演讲中精彩地总结了 Python 的类型系统，内容关于名字和值：
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名字有作用域——它们随着函数的创建与消失而变化——但它们没有类型。值有类型……但它们没有作用域。
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我还没有涉及作用域，但这一点应该已经能理解了。名字与值是绑定的，这些值存在于内存中，只要有一些*引用*指向它们。你可以将名字绑定到任何你想要的值，但你在操作特定值时是有局限的。
- en: The type() Function
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: type() 函数
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道一个值的数据类型，可以使用内置的`type()`函数。回想一下，Python 中的一切都是对象，因此这个函数实际上只是返回该值所属的类：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-8: *types.py:2*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-8: *types.py:2*'
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到赋给 `answer` 的值是一个整数（`int`）。在少数情况下，你可能想在对一个值进行操作之前检查它的数据类型。为此，你可以将 `type()`
    函数与 `is` 操作符结合使用，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-9: *types.py:3a*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-9: *types.py:3a*'
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多需要这种自省的情况下，使用 `isinstance()` 而非 `type()` 可能更好，因为它考虑了子类和继承（见第13章）。该函数本身返回
    `True` 或 `False`，所以我可以将其用作 `if` 语句中的条件：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-10: *types.py:3b*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-10: *types.py:3b*'
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，实际上很少有必要使用这两者。相反，Python 开发者更倾向于采用更动态的方法。
- en: Duck Typing
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用一种被称为（非正式地）*鸭子类型*的方法。这根本不是一个技术术语，它来自一句古老的谚语：
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它看起来像鸭子、走起来像鸭子、叫声像鸭子，那么它可能*就是*鸭子。
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对值的数据类型并不关心，更多地关注值的数据类型的*功能性*。例如，如果一个对象支持所有数学运算符和函数，并且它接受浮动数和整数作为二元运算符的操作数，那么
    Python 会认为该对象是一个数值类型。
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python 不关心它到底是一个机器人鸭子，还是穿着鸭子服装的驼鹿。如果它具备所需的特征，其他细节通常是无关紧要的。
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象编程，特别是继承如何快速变得复杂，那么鸭子类型的概念可能会给你带来一股清新的空气。如果你的类按预期行为工作，通常并不关心它继承自什么。
- en: Scope and Garbage Collection
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域与垃圾回收
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域*是决定一个变量可以从哪里访问的概念。它可能对整个模块可用，或者仅限于一个函数的代码块（主体）。'
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，名称有*作用域*，而值没有。一个名称可以是*全局的*，意味着它在模块中独立定义，或者它可以是*局部的*，意味着它仅在特定的函数或推导式中存在。
- en: Local Scope and the Reference-Counting Garbage Collector
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部作用域与引用计数垃圾回收器
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（包括 lambda 表达式）和推导式定义了它们自己的作用域；它们是语言中唯一具有此特性的结构。模块和类并没有严格意义上的作用域；它们仅仅有自己的命名空间。当作用域结束时，作用域内定义的所有名称会被自动删除。
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何特定的值，Python 会保持一个*引用计数*，它简单地统计有多少引用指向该值。每次一个值绑定到一个名称时，就会创建一个引用（尽管语言也可能通过其他方式创建引用）。当没有更多引用时，该值会被删除。这就是*引用计数垃圾回收器*，它有效地处理大多数垃圾回收场景。
- en: 'You can see how this works with a typical function, like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个典型的函数来看这个是如何工作的，例如：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-11: *local_scope.py:1*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-11: *local_scope.py:1*'
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个`spam()`函数，在其中定义了`message`、`word`和`separator`这几个名称。我可以在函数内部访问这些名称；这就是它们的局部作用域。即使`separator`是在`for`循环内定义的也没关系，因为循环本身没有独立的作用域。我仍然可以在循环外部访问它。
- en: 'However, I cannot access any of these names outside of the function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不能在函数外部访问任何这些名称：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-12: *local_scope.py:2*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-12: *local_scope.py:2*'
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`spam()`函数外部访问`message`，会引发`NameError`。在这个例子中，`message`在外部作用域中不存在。更重要的是，一旦`spam()`函数退出，`message`、`word`和`separator`这几个名称就会被删除。由于`word`和`separator`各自的引用计数为1（意味着每个值只被一个名称引用），因此这些值也会被删除。
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`message`的值并不会在函数退出时被删除，因为函数结尾处的返回语句（参见[列表 5-11](#listing5-11)）以及我在这里对该值的操作：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-13: *local_scope.py:3*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-13: *local_scope.py:3*'
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`spam()`返回的值绑定给外部作用域中的`output`，这意味着该值仍然存在于内存中，并且可以在函数外部访问。将值赋给`output`会增加该值的引用计数，因此即使名称`message`在`spam()`退出时被删除，值本身依然存在。
- en: Interpreter Shutdown
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器关闭
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 解释器被请求关闭时，比如 Python 程序终止时，它进入*解释器关闭*阶段。在这个阶段，解释器会执行释放所有分配资源、调用垃圾回收器多次、以及触发对象的析构函数的过程。
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准库中的`atexit`模块将函数添加到这个解释器关闭过程当中。在一些高度技术化的项目中可能需要这么做，尽管一般情况下你不需要这样做。通过`atexit.register()`添加的函数会按后进先出（LIFO）顺序调用。不过，要注意，在解释器关闭过程中，处理模块（包括标准库）会变得困难，就像试图在一座正在拆除的建筑物里工作：清洁工的储物间随时可能消失，没有任何预警。
- en: Global Scope
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个名称在模块中定义，但不在任何函数、类或推导式内时，它被认为是在*全局* *作用域*内。虽然拥有一些全局作用域名称是可以的，但通常拥有过多的全局作用域名称会导致代码难以调试和维护。因此，你应该谨慎使用全局作用域名称来定义变量。通常会有更干净的解决方案，比如使用类（见第7章）。
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在更局部的作用域（如函数）中正确使用全局作用域名称，需要你提前进行一些思考。假设我想要一个能够修改存储高分的全局变量的函数，首先，我定义全局变量：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-14: *global**_scope.py:1*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-14: *global**_scope.py:1*'
- en: 'I’ll write this function the wrong way first:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我先写这个函数的错误写法：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-15: *global**_scope.py:2*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-15: *global**_scope.py:2*'
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，Python 报告我在赋值之前使用了一个局部变量❶。问题在于，我在函数`score()`的作用域内给名称`high_score`赋值❷，这会*遮蔽*（shadow）或者隐藏全局`high_score`名称，并用新的局部`high_score`名称替代它。我在函数*的任何地方*创建了一个局部`high_score`名称，这使得函数无法“看到”全局的`high_score`名称。
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，我需要声明我将在局部作用域中使用全局名称，而不是定义一个新的局部名称。我可以通过`global`关键字来实现：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-16: *global**_scope.py:3*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-16: *global**_scope.py:3*'
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的函数中做任何其他操作之前，我必须指定我正在使用全局变量`high_score`。这意味着在`score()`函数中，任何给`high_score`赋值的地方，都将使用全局变量，而不是尝试创建一个新的局部变量。现在代码按预期工作了。
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你希望在局部作用域内重新绑定全局变量时，必须首先使用`global`关键字。如果你只是访问全局变量当前绑定的值，那么不需要使用`global`关键字。培养这个习惯非常重要，因为如果作用域处理不当，Python
    不会总是抛出错误。看看这个例子：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-17: *global**_scope_gotcha.py:1a*'
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有抛出任何错误，但输出结果是错误的。一个新名字`current_score`在函数`score()`的局部作用域中被创建，并且它绑定了值`465`。这会遮蔽全局变量`current_score`。当函数结束时，`new_score`和局部的`current_score`都被删除了。整个过程中，全局的`current_score`保持不变，仍然绑定着`0`，这就是输出的内容。
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，要解决这个问题，我只需要使用`global`关键字：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-18: *global**_scope_gotcha.py:1b*'
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我指定了在这个函数中使用全局的`current_name`，所以代码现在按预期执行，输出值为`465`。
- en: The Dangers of Global Scope
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域的危险
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的注意事项需要考虑全局作用域。修改全局变量，如在函数外部重新绑定或改变一个名字，可能导致混淆的行为和意外的错误，尤其是当你开始处理多个模块时。你可以在全局作用域中初步“声明”一个名字，但所有进一步的重新绑定和修改应该在局部作用域内进行。
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这 *不* 适用于类，因为类实际上并没有定义自己的作用域。我将在本章稍后部分回到这个话题。
- en: The nonlocal Keyword
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**nonlocal** 关键字'
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你在函数内部定义函数。关于这个功能的实际应用，我会推迟到第六章讨论。在这里，我主要想探讨它对作用域的影响。看看下面的例子：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-19: *nonlocal**.py*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-19: *nonlocal**.py*'
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`order()`包含另一个函数：`cook()`。每个函数都有自己的作用域。
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只要一个函数只是访问像`spam`这样的全局名称，你不需要做任何特殊处理。然而，尝试对一个全局名称进行*赋值*实际上会定义一个新的局部名称，遮蔽了全局名称。内层函数使用外层函数中定义的名称时也会出现相同的行为，这种情况被称为*嵌套作用域*或*封闭作用域*。为了避免这种情况，我指定`eggs`为`nonlocal`，意味着它可以在封闭作用域中找到，而不是在局部作用域中
    ❶。内层函数`cook()`能够正常访问全局名称`spam`。
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonlocal`关键字开始在最内层的嵌套作用域中查找指定的名称，如果没找到，它会向上查找下一个封闭作用域。它会重复这一过程，直到找到名称或确定名称在非全局封闭作用域中不存在为止。'
- en: Scope Resolution
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域解析
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python关于在何种作用域以及按照什么顺序查找名称的规则被称为*作用域解析顺序*。记住作用域解析顺序的最简单方法是使用首字母缩略词*LEGB*——我的同事Ryan给我提供了一个方便的助记法：“Lincoln
    Eats Grant’s Breakfast”：
- en: Local
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封闭函数局部（即通过`nonlocal`找到的任何内容）
- en: Global
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局
- en: Built-in
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内建
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python会按照这些作用域的顺序查找，直到找到匹配项或达到最后。如果`nonlocal`和`global`关键字会调整作用域解析顺序的行为。
- en: The Curious Case of the Class
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的奇怪案例
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类有自己处理作用域的方式。从技术上讲，类并不会直接影响作用域解析顺序。每个直接在类内声明的名称都被称为*属性*，并通过类（或对象）名称上的点（`.`）操作符来访问。
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将定义一个包含单个属性的类：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-20: *class_attributes**.py*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-20: *class_attributes**.py*'
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那三个打印语句输出的结果是一样的。运行这段代码给我输出如下：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`output`是一个*类属性* ❶，属于`Nutrimatic`类。即使在这个类内部，我也无法仅仅通过`output`来引用它。我必须通过`self.output`来访问它
    ❷，因为`self`指的是调用函数（实例方法）`request()`的类实例。我还可以通过`machine.output` ❸或`Nutrimatic.output`
    ❹来访问它，只要`machine`对象或`Nutrimatic`类在作用域内。所有这些名称指向的是完全相同的属性：`output`。特别是在这种情况下，它们之间没有实际区别。
- en: Generational Garbage Collector
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代际垃圾回收器
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Python还具有一个更强大的*代际垃圾回收器*，它处理所有引用计数垃圾回收器无法处理的奇怪情况，比如引用循环（当两个值相互引用时）。所有这些情况以及垃圾回收器如何处理它们远远超出了本书的范围。
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.xhtml](https://docs.python.org/library/weakref.xhtml).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 向前看，最重要的要点是要记住，代代垃圾回收器会带来一些性能开销。因此，有时避免引用循环是值得的。一种方法是使用`weakref`，它创建对一个值的引用，而不会增加该值的引用计数。这个特性在PEP
    205中定义，相关文档可以在[https://docs.python.org/library/weakref.xhtml](https://docs.python.org/library/weakref.xhtml)找到。
- en: The Immutable Truth
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变的真相
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的值可以是*不可变*的，也可以是*可变*的。它们的区别在于值是否可以*原地修改*，即它们是否可以在内存中直接改变。
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变*类型不能原地修改。例如，整数（`int`）、浮点数（`float`）、字符串（`str`）和元组（`tuple`）都是不可变的。如果你尝试改变一个不可变值，你最终会得到一个完全不同的值：'
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-21: *immutable_types.py*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-21: *immutable_types.py*'
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`eggs`和`carton`都绑定到同一个值，因此它们共享同一个标识。当我修改`eggs`时，它会被重新绑定到一个新值，因此它不再与`carton`共享标识。你可以看到这两个名称现在指向不同的值。
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变*类型则可以原地修改。列表就是一种可变类型的例子：'
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-22: *mutable_types.py*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-22: *mutable_types.py*'
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表同时作为`temps`和`highs`的别名，所以对列表值❶的任何修改都能通过这两个名称看到。两个名称都绑定到原始值，正如`is`比较所示。即使该值被修改后，这种情况依然成立。
- en: Passing by Assignment
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过赋值传递
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个初学者常问的问题是：“Python是按值传递还是按引用传递？”
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：“实际上，两者都不是。”更准确地说，正如Ned Batchelder所描述的那样，Python是*按赋值传递*的。
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既不是值，也不是绑定到它们的名称会被移动。相反，每个值通过赋值绑定到参数。考虑一个简单的函数：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存中有一个字符串值`"Jason"`的副本，并且它被绑定到名称`my_name`。当我将`my_name`传递给`greet()`函数——具体来说，是传递给`person`参数——这就等同于我说（`person
    = my_name`）。
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，赋值从不创建值的副本。现在，名称`person`被绑定到值`"Jason"`。
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理可变值时（如列表），赋值传递的概念变得棘手。为了展示这种常常出人意料的行为，我编写了一个函数，来找出传递给它的列表中的最低温度：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-23: *lowest_temp.py:1a*'
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你可能会认为将一个列表传递给`temperatures`参数会创建一个副本，所以如果你修改绑定到参数的值也不应该有问题。然而，列表是可变的，这意味着*值本身*可以被修改：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-24: *lowest_temp.py:2*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-24: *lowest_temp.py:2*'
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将 `temps` 传递给函数的 `temperatures` 参数时，我只是*引用*了该列表，因此在 `temperatures` 上做出的任何改变都会从所有绑定到该列表值的其他名称中显现出来——即从
    `temps`。
- en: 'You can see this in action when I run this code and get the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码并得到以下输出时，你可以看到这一点的实际表现：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `find_lowest()` 对传递给 `temperatures` 的列表进行排序时，实际上它对 `temps` 和 `temperatures`
    引用的那个可变列表进行了排序。这是函数有 *副作用* 的明显例子，副作用指的是在函数调用之前已经存在的值的变化。
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题源自无数令人惊叹的错误。一般来说，函数不应该有副作用，这意味着传递给函数的任何值作为参数不应该*直接*被改变。为了避免修改原始值，我必须明确地复制它。以下是我在
    `find_lowest()` 函数中如何做到这一点的方式：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-25: *lowest_temp.py:1b*'
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 函数没有副作用；它使用传给它的列表中的项目创建一个新列表❶。然后它对这个新列表进行排序并返回。 我将这个新列表绑定到 `sorted_temps`。因此，原始列表（绑定到
    `temps` 和 `temperatures`）未被修改。'
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 C 或 C++，记住与指针传递或引用传递相关的潜在问题可能会有所帮助。尽管从技术上讲，Python 的赋值操作几乎没有类似之处，但副作用和意外变异的风险是相同的。
- en: Collections and References
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合与引用
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合，包括列表，都采用了一个巧妙的小语义细节，如果你不知道预期它，可能会变成一个麻烦：***每个项都是引用。*** 就像一个名称与一个值绑定一样，集合中的每个项也与一个值绑定，以相同的方式。这种绑定叫做
    *引用*。
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是试图创建一个井字棋棋盘。这个版本的实现不会像你期望的那样工作。
- en: 'I’ll start by creating the game board:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建游戏棋盘开始：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-26: *tic_tac_toe**.py:1a*'
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在尝试创建一个二维棋盘。你可以使用乘法运算符❶将多个项填充到一个集合中，比如列表，所有项具有相同的重复值，正如我在这里做的那样。我将重复的值放在方括号中，并将其乘以我希望重复的次数。我的棋盘的单行定义为
    `["-"] * 3`，它生成一个包含三个 `"-"` 字符串的列表。
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不会按照你期望的方式工作。问题出现在我试图通过乘法定义数组的第二维——三个 `[["-"] * 3]` 列表的副本时。你可以在我尝试进行一次操作时看到这个问题的表现：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-27: *tic_tac_toe**.py:2*'
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在棋盘上标记一次操作时❷，我只想在棋盘上的一个位置看到这个变化，如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead, I get this nasty surprise:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我遇到了这个令人讨厌的意外：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是哭泣和牙齿咬合。出乎意料的是，那一个改变竟然影响了 *所有三个* *行*。为什么？
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我创建了一个包含三个 `"-"` 值的列表作为项 ❶。因为字符串是不可变的，不能就地修改，因此这按预期工作。将列表中的第一个项重新绑定为 `"X"`
    不会影响其他两个项。
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的外部维度由三个列表项组成。因为我定义了*一个*列表并将其*三*次使用，所以我现在有三个*别名*指向一个可变的值！通过改变这个列表的其中一个引用（第二行），我就在改变那个共享的值
    ❷，所以所有三个引用都能看到这个变化。
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以修复这个问题，但所有的方法都是通过确保每一行引用一个单独的值来实现的，如下所示：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-28: *tic_tac_toe**.py:1b*'
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要更改最初定义游戏板的方式。现在，我使用*列表推导*来创建行。简而言之，这个列表推导将三次分别定义一个不同的列表值 `["-"] * 3`。（列表推导会变得复杂；它们将在第10章中深入讲解。）现在运行代码会得到预期的行为：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，每当你处理集合时，记住一个项和任何其他名字没有区别。这里有一个例子来加深这个概念：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-29: *team_scores**.py:1*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-29: *team_scores**.py:1*'
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了三个列表，将每个列表赋值给一个名字。然后，我把这三个列表打包进元组 `scores` 中。你可能记得之前提到过，元组本身不能直接修改，因为它们是不可变的。但这个规则不一定适用于元组的项。你不能改变元组本身，但你可以（间接地）修改它的项所引用的值：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-30: *team_scores**.py:2*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-30: *team_scores**.py:2*'
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我修改列表 `scores_team_1` 时，这个变化会出现在元组的第一个项中，因为该项只不过是指向一个可变值的别名。
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以通过二维下标直接修改 `scores` 元组中的可变列表，如下所示：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 5-31: *team_scores**.py:3*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-31: *team_scores**.py:3*'
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 元组不会提供任何关于数据被修改的安全性。不可变性主要是为了提高效率，而不是为了保护数据。可变值*始终*是可变的，无论它们在哪里或如何被引用。
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上面两个例子中的问题看起来可能相对容易发现，但当相关代码分布在一个大文件或多个文件中时，问题就会变得麻烦。一个模块中修改一个名字可能会意外地改变另一个完全不同模块中集合的某个项，而你可能根本没有预料到。
- en: Shallow Copy
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以确保你将一个名字绑定到一个可变值的*副本*上，而不是别名化原始值；其中最明确的方法是使用 `copy()` 函数。这也被称为*浅拷贝*，与我稍后会讲解的*深拷贝*相对。
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个 `Taco` 类（有关类的更多信息，请参见第 7 章），该类允许你定义带有各种配料的塔科，并且在之后可以添加酱料。这个版本有一个
    bug：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-32: *mutable_**tacos.py:1a*'
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Taco` 类中，初始化器 `__init__()` 接受一个配料列表，并将其存储为 `ingredients` 列表。`add_sauce()`
    方法将指定的 `sauce` 字符串添加到 `ingredients` 列表中。
- en: (Can you anticipate the problem?)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: （你能预见到问题吗？）
- en: 'I use the class as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我按如下方式使用该类：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-33: *mutable_**tacos.py:2a*'
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个所有塔科都想加的配料列表，然后我定义了两个塔科：`hot_taco` 和 `mild_taco`。我将 `default_toppings`
    列表传递给每个塔科的初始化器。然后我将 `"Salsa"` 加入到 `hot_taco` 的配料列表中，但不希望在 `mild_taco` 上加任何 `"Salsa"`。
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它正常工作，我打印出两个塔科的 `ingredients` 列表，以及我最初使用的 `default_toppings` 列表：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-34: *mutable_**tacos.py:3*'
- en: 'That outputs the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出以下内容：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Waiter, there’s a bug in my taco!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 服务员，我的塔科里有个 bug！
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，当我通过将 `default_toppings` 传递给 `Taco` 初始化器来创建我的 `hot_taco` 和 `mild_taco` 对象时，我将
    `hot_taco.ingredients` 和 `mild_taco.ingredients` 都绑定到了与 `default_toppings` 相同的列表值。这些现在是内存中同一值的所有别名。然后，当我调用
    `hot_taco.add_sauce()` 函数时，我改变了该列表的值。添加 `"Salsa"` 的效果不仅在 `hot_taco.ingredients`
    中可见，而且（意外地）在 `mild_taco.ingredients` 和 `default_toppings` 列表中也可见。这显然不是期望的行为；将
    `"Salsa"` 添加到一个塔科中应该只影响该塔科。
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是确保我分配的是可变值的副本。在我的 `Taco` 类中，我将重写初始化器，使它将指定列表的副本分配给 `self.ingredients`，而不是创建别名：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-35: *mutable_**tacos.py:1b*'
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `copy.copy()` 函数 ❶ 来创建一个副本，该函数从 `copy` 模块导入。
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `Taco.__init__()` 中创建一个传递给 `toppings` 的列表的副本，并将该副本分配给 `self.ingredients`。对
    `self.ingredients` 所做的任何更改都不会影响其他列表；将 `"Salsa"` 加入 `hot_taco` 不会改变 `mild_taco.ingredients`，也不会改变
    `default_toppings`：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deep Copy
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深拷贝
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝对不可变值的列表是有效的，但如前所述，当一个可变值包含其他可变值时，对这些值的修改可能会以奇怪的方式在其他地方反映出来。
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下当我尝试在改变两个塔科其中一个之前，复制一个 `Taco` 对象时会发生什么。我的第一次尝试导致了一些不期望的行为。基于之前相同的 `Taco`
    类（见 [列表 5-35](#listing5-35)），我将使用一个塔科的副本来定义另一个：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-36: *mutable_**tacos.py:2b*'
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我想创建一个新的taco（`hot_taco`），它最初与`mild_taco`完全相同，但加入了“`Salsa`”。我通过将`mild_taco` ❶的副本绑定到`hot_taco`上来尝试这一操作。
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的代码（包括[列表 5-34](#listing5-34)）会产生以下结果：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能没有预料到对`hot_taco`所做的任何更改会反映到`mild_taco`上，但显然出现了意外的更改。
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我复制`Taco`对象本身时，并没有复制对象内部的`self.ingredients`列表。两个`Taco`对象都包含对同一个列表值的引用。
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我可以使用*深拷贝*来确保对象内部的可变值也能被复制。在这种情况下，`Taco`对象的深拷贝将创建一个`Taco`值的副本，以及`Taco`所引用的任何可变值的副本——即列表`self.ingredients`。[列表
    5-37](#listing5-37)展示了同样的程序，使用深拷贝：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-37: *mutable_**tacos.py:2c*'
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是，我使用了`copy.deepcopy()`，而不是`copy.copy()` ❶。现在，当我修改`hot_taco`中的列表时，它不会影响到`mild_taco`：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I don’t know about you, but I’m getting hungry for tacos.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不知道你怎么样，但我现在肚子有点饿了，想吃taco。
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是解决传递可变对象问题的最通用方法。然而，根据你所做的事情，可能有更适合你使用的特定集合的方式。例如，许多集合（如列表）都有返回带有某些特定修改的集合副本的函数。当你在处理这些可变性问题时，可以首先使用复制和深拷贝。然后，你可以根据需要换用更具领域特定的解决方案。
- en: Coercion and Conversion
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制转换与转换
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 名称没有类型。因此，Python不需要类型转换，至少在术语的典型意义上是如此。
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Python自行处理转换，例如将一个整数（`int`）与一个`float`相加，称为*强制转换*。这里有一些例子：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-38: *coercion.py*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-38: *coercion.py*'
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，在某些情况下，你可能需要使用一个值来创建不同类型的值，比如将一个整数转换为字符串。*转换*是将一个类型的值显式地转换为另一种类型的过程。
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的每种类型都是一个类的实例。因此，你想创建的类型的类只需要有一个能够处理你要转换的值的数据类型的初始化方法。（这通常通过鸭子类型来完成。）
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的情况之一是将包含数字的字符串转换为数值类型，例如`float`：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 5-39: *conversion.py:1*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-39: *conversion.py:1*'
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我从一个字符串值开始，它被绑定到名称`life_universe_everything`。假设我想对这些数据进行复杂的数学分析；为了做到这一点，我必须首先将数据转换为浮动点数。所需的类型应该是`float`类的一个实例。这个类有一个初始化函数（`__init__()`），它接受一个字符串作为参数，这是我从文档中了解到的。
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我初始化了一个`float()`对象，将`life_universe_everything`传递给初始化函数，并将生成的对象绑定到名称`answer`。
- en: 'I’ll print out the `type` and value of `answer`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我将打印出`answer`的`type`和它的值：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 5-40: *conversion.py:2*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-40: *conversion.py:2*'
- en: 'That outputs the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有出现错误，可以看到结果是一个值为`42.0`的`float`，并绑定到`answer`。
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都会定义自己的初始化函数。以`float()`为例，如果传递给它的字符串不能被解释为浮动点数，它将抛出`ValueError`异常。初始化对象时，始终查看相关文档。
- en: A Note About Systems Hungarian Notation
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于系统匈牙利命名法的说明
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自静态类型语言，如 C++ 或 Java，你可能习惯了使用数据类型。因此，当你开始使用像 Python 这样的动态类型语言时，可能会想通过某种方式“记住”每个名称所绑定的值的类型。***不要这样做！***
    只有学会充分利用动态类型、弱绑定和鸭子类型，你才能在 Python 中获得最大的成功。
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须坦白：我第一次使用 Python 的时候，使用了*系统匈牙利命名法*——一种将表示数据类型的前缀附加到每个变量名的约定——来尝试“战胜”语言的动态类型系统。我的代码中充斥着像`intScore`、`floatAverage`和`boolGameOver`这样的命名。我从使用
    Visual Basic .NET 时养成了这个习惯，认为自己很聪明。事实上，我剥夺了自己许多重构的机会。
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 系统匈牙利命名法会迅速使代码变得晦涩。例如：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-41: *evils_of_systems_hungarian.py*'
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸赘言，这段代码读起来相当痛苦。另一方面，如果你充分利用 Python 的类型系统（并且抵制将每个中间步骤都存储下来的冲动），代码会显得更加简洁：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-42: *duck_typing_feels_better.py*'
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我停止把 Python 当作静态类型语言来对待，我的代码变得更加简洁。Python 的类型系统是它成为如此易读且简洁的语言的一个重要原因。
- en: Terminology Review
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语回顾
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我介绍了许多重要的新词汇。由于我将在本书的后续章节中频繁使用这些词汇，在这里快速回顾一遍是明智的。
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 别名（v.）将一个可变值绑定到多个名称。对绑定到某个名称的值进行的修改将在所有绑定到该可变值的名称中可见。
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: assignment (n.) 将一个值绑定到一个名称的行为。赋值从不复制数据。
- en: bind (v.) To create a reference between a name and a value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: bind (v.) 创建名称和值之间的引用。
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: coercion (n.) 将一个值从一种类型隐式转换为另一种类型的行为。
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: conversion (n.) 明确将一个值从一种类型转换为另一种类型的行为。
- en: copy (v.) To create a new value in memory from the same data as another value.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: copy (v.) 从另一个值的相同数据创建一个新的内存值。
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: data (n.) 存储在值中的信息。任何给定的数据都可以在其他值中有副本。
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: deep copy (v.) 将一个对象复制到一个新值，并将该对象引用的所有值的数据复制到新值。
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: identity (n.) 名称绑定到的内存中特定的位置。当两个名称共享一个身份时，它们绑定到内存中的同一个值。
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: immutable (adj.) 指的是*无法*在原地修改的值。
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: mutable (adj.) 指的是*可以*在原地修改的值。
- en: mutate (v.) To change a value in place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: mutate (v.) 在原地修改一个值。
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: name (n.) 一个指向内存中值的引用，通常在 Python 中被认为是“变量”。一个名称必须始终绑定到一个值。***名称有作用域，但没有类型。***
- en: rebind (v.) To bind an existing name to a different value.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: rebind (v.) 将一个已有名称绑定到另一个值。
- en: reference (n.) The association between a name and a value.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: reference (n.) 名称与值之间的关联。
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: scope (n.) 定义名称可以从哪里访问的代码部分的属性，例如从函数内部或模块内部。
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: shallow copy (v.) 将一个对象复制到一个新值，但*不*将该对象引用的值的数据复制到新值。
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: type (n.) 定义如何解释原始值的属性，例如作为整数或布尔值。
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: value (n.) 内存中数据的唯一副本。必须有一个对值的引用，否则该值会被删除。***值有类型，但没有作用域。***
- en: variable (n.) A combination of a name and the value the name refers to.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: variable (n.) 名称与该名称所引用值的组合。
- en: weakref (n.) A reference that does not increase the reference count on the value.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: weakref (n.) 一种不会增加值引用计数的引用。
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们更好地理解这些概念，我们通常使用*名称*而不是*变量*这个术语。我们并不是*改变*某个东西，而是*(重新)绑定名称*或者*改变值*。赋值从不复制——它实际上总是将一个名称与一个值绑定在一起。传递给一个函数实际上就是赋值。
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你在理解这些概念以及它们在代码中的应用上有困难，可以试试[http://pythontutor.com/](http://pythontutor.com/)的可视化工具。
- en: Wrapping Up
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们容易把像变量这样的东西视为理所当然，但通过理解 Python 独特的处理方式，你可以更好地利用动态类型所带来的强大功能。我必须承认，Python 让我有点“宠坏”了。当我在静态类型语言中工作时，我发现自己常常渴望鸭子类型的表达力。
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有其他编程语言的背景，使用 Python 风格的动态类型可能需要一些适应。这就像学习说一种新的语言：只有通过时间和练习，你才能开始用这种新语言思考。
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些让你头晕，让我重申最重要的单一原则。名称有作用域，但没有类型。值有类型，但没有作用域。名称可以绑定到任何值，而值可以绑定到任意数量的名称。实际上就是这么简单！如果你记住了这一点，你会走得很远。
