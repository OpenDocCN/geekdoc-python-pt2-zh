- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables and Types
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  prefs: []
  type: TYPE_NORMAL
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables According to Python: Names and Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  prefs: []
  type: TYPE_NORMAL
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: *simple_assignment.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: *simple_assignment.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/500920c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  prefs: []
  type: TYPE_NORMAL
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, run this example in an interactive session instead of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: (Interactive session):1'
  prefs: []
  type: TYPE_NORMAL
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: (Interactive session):2'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: (Interactive session):3'
  prefs: []
  type: TYPE_NORMAL
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/500920c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  prefs: []
  type: TYPE_NORMAL
- en: It just goes to show, spam by any other name is still spam.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: (Interactive session)'
  prefs: []
  type: TYPE_NORMAL
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: *types.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: At that precise moment, Python became my all-time favorite language.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  prefs: []
  type: TYPE_NORMAL
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  prefs: []
  type: TYPE_NORMAL
- en: The type() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: *types.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: *types.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: *types.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Duck Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  prefs: []
  type: TYPE_NORMAL
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and Garbage Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Local Scope and the Reference-Counting Garbage Collector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  prefs: []
  type: TYPE_NORMAL
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how this works with a typical function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: *local_scope.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I cannot access any of these names outside of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: *local_scope.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: *local_scope.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter Shutdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  prefs: []
  type: TYPE_NORMAL
- en: Global Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: *global**_scope.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll write this function the wrong way first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-15: *global**_scope.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-16: *global**_scope.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  prefs: []
  type: TYPE_NORMAL
- en: The Dangers of Global Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The nonlocal Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-19: *nonlocal**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  prefs: []
  type: TYPE_NORMAL
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  prefs: []
  type: TYPE_NORMAL
- en: Scope Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  prefs: []
  type: TYPE_NORMAL
- en: Local
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Built-in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  prefs: []
  type: TYPE_NORMAL
- en: The Curious Case of the Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-20: *class_attributes**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  prefs: []
  type: TYPE_NORMAL
- en: Generational Garbage Collector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.xhtml](https://docs.python.org/library/weakref.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The Immutable Truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-21: *immutable_types.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-22: *mutable_types.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  prefs: []
  type: TYPE_NORMAL
- en: Passing by Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  prefs: []
  type: TYPE_NORMAL
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-24: *lowest_temp.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action when I run this code and get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Collections and References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by creating the game board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, I get this nasty surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  prefs: []
  type: TYPE_NORMAL
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-29: *team_scores**.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-30: *team_scores**.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-31: *team_scores**.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  prefs: []
  type: TYPE_NORMAL
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow Copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  prefs: []
  type: TYPE_NORMAL
- en: (Can you anticipate the problem?)
  prefs: []
  type: TYPE_NORMAL
- en: 'I use the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Waiter, there’s a bug in my taco!
  prefs: []
  type: TYPE_NORMAL
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Deep Copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: I don’t know about you, but I’m getting hungry for tacos.
  prefs: []
  type: TYPE_NORMAL
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  prefs: []
  type: TYPE_NORMAL
- en: Coercion and Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-38: *coercion.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  prefs: []
  type: TYPE_NORMAL
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-39: *conversion.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll print out the `type` and value of `answer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-40: *conversion.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  prefs: []
  type: TYPE_NORMAL
- en: A Note About Systems Hungarian Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  prefs: []
  type: TYPE_NORMAL
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology Review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  prefs: []
  type: TYPE_NORMAL
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  prefs: []
  type: TYPE_NORMAL
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  prefs: []
  type: TYPE_NORMAL
- en: bind (v.) To create a reference between a name and a value.
  prefs: []
  type: TYPE_NORMAL
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: copy (v.) To create a new value in memory from the same data as another value.
  prefs: []
  type: TYPE_NORMAL
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  prefs: []
  type: TYPE_NORMAL
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  prefs: []
  type: TYPE_NORMAL
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  prefs: []
  type: TYPE_NORMAL
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  prefs: []
  type: TYPE_NORMAL
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  prefs: []
  type: TYPE_NORMAL
- en: mutate (v.) To change a value in place.
  prefs: []
  type: TYPE_NORMAL
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  prefs: []
  type: TYPE_NORMAL
- en: rebind (v.) To bind an existing name to a different value.
  prefs: []
  type: TYPE_NORMAL
- en: reference (n.) The association between a name and a value.
  prefs: []
  type: TYPE_NORMAL
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  prefs: []
  type: TYPE_NORMAL
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  prefs: []
  type: TYPE_NORMAL
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  prefs: []
  type: TYPE_NORMAL
- en: variable (n.) A combination of a name and the value the name refers to.
  prefs: []
  type: TYPE_NORMAL
- en: weakref (n.) A reference that does not increase the reference count on the value.
  prefs: []
  type: TYPE_NORMAL
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  prefs: []
  type: TYPE_NORMAL
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  prefs: []
  type: TYPE_NORMAL
