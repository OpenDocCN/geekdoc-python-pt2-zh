<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_3"/><span class="big">1</span><br/>A SHORT PYTHON PRIMER</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this first chapter, we’ll take a look at some of the Python features we’ll use throughout the book. This is not meant to be an introduction to Python; I’m assuming you have a basic understanding of the language. If you don’t, there are plenty of good books and online tutorials that’ll get you started.</p>&#13;
<p class="indent">We’ll first explore how Python code can be split into packages and how to import these packages into our programs. We’ll learn how to document Python code and how to consult this documentation using Python. Then, we’ll review tuples, lists, sets, and dictionaries, which are the most popular Python collections.</p>&#13;
<h3 class="h3" id="ch00lev1sec10"><strong>Python Packages and Modules</strong></h3>&#13;
<p class="noindent">Software projects of a reasonable size usually consist of lots of source files, also called <em>modules</em>. A coherent bundle of Python modules is referred to as a <em>package</em>. Let’s start our discussion on Python by taking a look at these two concepts: modules and packages.</p>&#13;
<h4 class="h4" id="ch00lev2sec10"><span epub:type="pagebreak" id="page_4"/><strong><em>Modules</em></strong></h4>&#13;
<p class="noindent">A Python <em>module</em> is a file that contains Python code that’s meant to be imported by other Python modules or scripts. A <em>script</em>, on the other hand, is a Python file that’s meant to be run.</p>&#13;
<p class="indent">Python modules allow us to share code between files, which spares us from having to write the same code over and over again.</p>&#13;
<p class="indent">Every Python file has access to a global variable named <span class="literal">__name__</span>. This variable can have two possible values:</p>&#13;
<ul>&#13;
<li class="noindent">The name of the module, that is, the name of the file without the <em>.py</em> extension</li>&#13;
<li class="noindent">The string ’<span class="literal">__main__</span>’</li>&#13;
</ul>&#13;
<p class="indent">Python determines the value of <span class="literal">__name__</span> based on whether the file is imported by some other module or run as a script. When the module is imported inside another module or script, <span class="literal">__name__</span> is set to the name of the module. If we run the module as a script, for example,</p>&#13;
<pre>$ <span class="codestrong1">python3 my_module.py</span></pre>&#13;
<p class="noindent">then the value of <span class="literal">__name__</span> is set to ’<span class="literal">__main__</span>’. This may seem a bit abstract at the moment, but we’ll explain why we care about the <span class="literal">__name__</span> global variable later in the chapter. As we’ll see, knowing if a given module is being imported or run as a script is an important piece of information we’ll want to consider.</p>&#13;
<p class="indent">As we write more and more Python modules for our project, it makes sense to separate them into groups according to functionality. These groups of modules are called <em>packages</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec11"><strong><em>Packages</em></strong></h4>&#13;
<p class="noindent">A <em>package</em> is a directory containing Python modules and a special file whose name is required to be <em>__init__.py</em>. Python’s interpreter will understand any folder containing an <em>__init__.py</em> file as a package.</p>&#13;
<p class="indent">For instance, a folder structure like:</p>&#13;
<p class="pre2">    geom2d<br/>      |- __init__.py<br/>      |- point.py<br/>      |- vector.py</p>&#13;
<p class="noindent">is a Python package called <em>geom2d</em> containing two files, or modules: <em>point.py</em> and <em>vector.py</em>.</p>&#13;
<p class="indent">The <em>__init__.py</em> file is executed whenever something is imported from the package. This means that the <em>__init__.py</em> file can contain Python code, usually initialization code. Most of the time, however, this <em>__init__.py</em> file remains empty.</p>&#13;
<h3 class="h3" id="ch00lev1sec11"><span epub:type="pagebreak" id="page_5"/><strong>Running Files</strong></h3>&#13;
<p class="noindent">When Python imports a file, it reads its contents. If this file contains only functions and data, Python loads these definitions, but no code is actually executed. However, if there are top-level instructions or function calls, Python will execute them as part of the import process—something we usually don’t want.</p>&#13;
<p class="indent">Earlier, we saw how when a file is run (as opposed to imported), Python sets the <span class="literal">__name__</span> global variable to be the string ’<span class="literal">__main__</span>’. We can use this fact to execute the main logic only when the file is being run, and not when the file is imported:</p>&#13;
<pre>if __name__ == '__main__':&#13;
    # only executes if file is run, not imported</pre>&#13;
<p class="noindent">We’ll refer to this pattern as the “if name is main” pattern, and we’ll use it in the applications we’ll write in this book.</p>&#13;
<p class="indent">Remember that when a file is imported, Python sets the <span class="literal">__name__</span> variable to the name of that module.</p>&#13;
<h3 class="h3" id="ch00lev1sec12"><strong>Importing Code</strong></h3>&#13;
<p class="noindent">Let’s say you had some Python code you wanted to use in multiple files. One way to do that would be to copy and paste the code every time you wanted to use it. Not only would this be tedious and boring, but imagine what would happen if you changed your mind about how that code works: you’d need to open every single file where you pasted the code and modify it in the same way. As you can imagine, this is not a productive way of writing software.</p>&#13;
<p class="indent">Fortunately, Python provides a powerful system to share code: importing modules. When <em>module_b</em> imports <em>module_a</em>, <em>module_b</em> gains access to the code written in <em>module_a</em>. This lets us write algorithms in a single place and then share that code across files. Let’s look at an example using two modules we’ll write in the next part of the book.</p>&#13;
<p class="indent">Say we have two modules: <em>point.py</em> and <em>vector.py</em>. Both modules are inside the package we saw earlier:</p>&#13;
<p class="pre2">    geom2d<br/>      |- __init__.py<br/>      |- point.py<br/>      |- vector.py</p>&#13;
<p class="noindent">The first module, named <em>point.py</em>, defines the geometric primitive <span class="literal">Point</span>, and the second one, <em>vector.py</em>, defines the <span class="literal">Vector</span>, another geometric primitive. <a href="ch01.xhtml#ch1fig1">Figure 1-1</a> illustrates these two modules. Each module is divided into two sections: a section in gray, for the code in the module that has been imported from somewhere else, and a section in white, for the code defined by the module itself.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_6"/><img src="../images/01fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch1fig1"><em>Figure 1-1: Two Python modules</em></p>&#13;
<p class="indent">Now, say we need our <em>point.py</em> module to implement some functionality that uses a <span class="literal">Vector</span> (like, for example, displacing a point by a given vector). We can gain access to the <span class="literal">Vector</span> code in <em>vector.py</em> using Python’s <span class="literal">import</span> command. <a href="ch01.xhtml#ch1fig2">Figure 1-2</a> illustrates this process, which brings the <span class="literal">Vector</span> code to the “imported” section of the <em>point.py</em> module, making it available inside the entire module.</p>&#13;
<div class="image"><img src="../images/01fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch1fig2"><em>Figure 1-2: Importing the <span class="codeitalic">Vector</span> class from the</em> <span class="literal">vector.py</span></p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1fig2">Figure 1-2</a>, we use the following Python command:</p>&#13;
<pre>    from vector import Vector</pre>&#13;
<p class="indent">This command brings just the <span class="literal">Vector</span> class from <em>vector.py</em>. We’re not importing anything else defined in <em>vector.py</em>.</p>&#13;
<p class="indent">As you’ll see in the next section, there are a few ways to import from modules.</p>&#13;
<h4 class="h4" id="ch00lev2sec12"><strong><em>Different Import Forms</em></strong></h4>&#13;
<p class="noindent">To understand the different ways we can import modules and names inside a module, let’s use two packages from our <em>Mechanics</em> project.<span epub:type="pagebreak" id="page_7"/></p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- __init__.py<br/>      |    |- point.py<br/>      |    |- vector.py<br/>      |<br/>      |- eqs<br/>      |    |- __init__.py<br/>      |    |- matrix.py<br/>      |    |- vector.py</p>&#13;
<p class="noindent">For this example, we’ll use the <em>geom2d</em> and <em>eqs</em> packages, using two files, or modules, inside of each. Each of these modules defines a single class that has the same name as the module, only capitalized. For example, the module in <em>point.py</em> defines the <span class="literal">Point</span> class, <em>vector.py</em> defines the <span class="literal">Vector</span> class, and <em>matrix.py</em> defines the <span class="literal">Matrix</span> class. <a href="ch01.xhtml#ch1fig3">Figure 1-3</a> illustrates this package structure.</p>&#13;
<div class="image"><img src="../images/01fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch1fig3"><em>Figure 1-3: Two packages from our Mechanics project and some of their modules</em></p>&#13;
<p class="indent">With this directory set up in our minds, let’s analyze several scenarios.</p>&#13;
<h5 class="h5" id="ch00lev3sec6"><strong>Importing from a Module in the Same Package</strong></h5>&#13;
<p class="noindent">If we are in module <em>point.py</em> from the package <em>geom2d</em> and we want to import the entire <em>vector.py</em> module, we can use the following:</p>&#13;
<pre>import vector</pre>&#13;
<p class="noindent">Now we can use the <em>vector.py</em> module’s contents like so:</p>&#13;
<pre>v = vector.Vector(1, 2)</pre>&#13;
<p class="indent">It’s important to note that since we imported the entire module and not any of its individual entities, we have to refer to the module-defined entities using the module name. If we want to refer to the module using a different name, we can alias it:</p>&#13;
<pre>import vector as vec</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>Then we can use it like so:</p>&#13;
<pre>v = vec.Vector(1, 2)</pre>&#13;
<p class="indent">We can also import specific names from a module instead of importing the entire module. As you saw earlier, the syntax for this is as follows:</p>&#13;
<pre>from vector import Vector</pre>&#13;
<p class="indent">With this import, we can instead do the following:</p>&#13;
<pre>v = Vector(1, 2)</pre>&#13;
<p class="indent">In this case, we can also alias the imported name:</p>&#13;
<pre>from vector import Vector as Vec</pre>&#13;
<p class="indent">When we <em>alias</em> an imported name, we simply rename it to something else. In this case, we can now write it as follows:</p>&#13;
<pre>v = Vec(1, 2)</pre>&#13;
<h5 class="h5" id="ch00lev3sec7"><strong>Importing from a Module in a Different Package</strong></h5>&#13;
<p class="noindent">If we wanted to import the <em>point.py</em> module from inside the <em>matrix.py</em> module, which is in a different package, we could do the following:</p>&#13;
<pre>import geom.point</pre>&#13;
<p class="noindent">or equivalently</p>&#13;
<pre>from geom import point</pre>&#13;
<p class="indent">This lets us use the entire <em>point.py</em> module inside <em>matrix.py</em>:</p>&#13;
<pre>p = point.Point(1, 2)</pre>&#13;
<p class="indent">Once again, we can choose to alias the imported module:</p>&#13;
<pre>import geom.point as pt</pre>&#13;
<p class="noindent">or equivalently</p>&#13;
<pre>from geom import point as pt</pre>&#13;
<p class="indent">Either way, we can use <span class="literal">pt</span> as follows:</p>&#13;
<pre>p = pt.Point(1, 2)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>We can also import names from the module, instead of bringing the entire module, like so:</p>&#13;
<pre>from geom.point import Point&#13;
&#13;
p = Point(1, 2)</pre>&#13;
<p class="indent">As before, we can use an alias:</p>&#13;
<pre>from geom.point import Point as Pt&#13;
&#13;
p = Pt(1, 2)</pre>&#13;
<h5 class="h5" id="ch00lev3sec8"><strong>Relative Imports</strong></h5>&#13;
<p class="noindent">Finally, we have relative imports. A <em>relative import</em> is one that refers to a module using a route whose start point is the file’s current location.</p>&#13;
<p class="indent">We use one dot (<span class="literal">.</span>) to refer to modules or packages inside the same package and two dots (<span class="literal">..</span>) to refer to the parent directory.</p>&#13;
<p class="indent">Following our previous example, we could import the <em>point.py</em> module from within <em>matrix.py</em> using a relative import:</p>&#13;
<pre>from ..geom.point import Point&#13;
&#13;
p = Point(1, 2)</pre>&#13;
<p class="indent">In this case, the route <span class="literal">..geom.point</span> means this: from the current directory move to our parent’s directory and look for the <em>point.py</em> module.</p>&#13;
<h3 class="h3" id="ch00lev1sec13"><strong>Documenting the Code with Docstrings</strong></h3>&#13;
<p class="noindent">When we write code that other developers will use, it’s good practice to document it. This documentation should include information about how to use our code, what assumptions the code makes, and what each function does.</p>&#13;
<p class="indent">Python uses <em>docstrings</em> to document code. These docstrings are defined between triple quotes (<span class="literal">"""</span>) and appear as the first statement of the function, class, or module they document.</p>&#13;
<p class="indent">You may have noticed how the code for the <em>Mechanics</em> project you downloaded earlier uses these docstrings. For example, if you open the <em>matrix.py</em> file, the methods of the <span class="literal">Matrix</span> class are documented this way:</p>&#13;
<pre>def set_data(self, data: [float]):&#13;
    """&#13;
    Sets the given list of 'float' numbers as the values of&#13;
    the matrix.&#13;
&#13;
    The matrix is filled with the passed in numbers from left&#13;
    to right and from top to bottom.&#13;
    The length of the passed in list has to be equal to the&#13;
    <span epub:type="pagebreak" id="page_10"/>number of values in the matrix: rows x columns.&#13;
&#13;
    If the size of the list doesn't match the matrix number&#13;
    of elements, an error is raised.&#13;
&#13;
    :param data: <span class="codeitalic1">[float]</span> with the values&#13;
    :return: this <span class="codeitalic1">Matrix</span>&#13;
    """&#13;
    if len(data) != self.__cols_count * self.__rows_count:&#13;
        raise ValueError('Cannot set data: size mismatch')&#13;
&#13;
    for row in range(self.__rows_count):&#13;
        offset = self.__cols_count * row&#13;
        for col in range(self.__cols_count):&#13;
            self.__data[row][col] = data[offset + col]&#13;
&#13;
    return self</pre>&#13;
<p class="indent">If you ever find yourself using this code and can’t figure something out, Python has the <span class="literal">help</span> global function; if you give <span class="literal">help</span> a module, function, class, or method, it returns that code’s docstring. For example, we could get the documentation for this <span class="literal">set_data</span> method inside a Python interpreter console as follows:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from eqs.matrix import Matrix</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">help(Matrix.set_data)</span>&#13;
&#13;
Help on function set_data in module eqs.matrix:&#13;
set_data(self, data: [&lt;class 'float'&gt;])&#13;
    Sets the given list of 'float' numbers as the values of&#13;
    the matrix.&#13;
&#13;
    The matrix is filled with the passed in numbers from left&#13;
    to right and from top to bottom.&#13;
    The length of the passed in list has to be equal to the&#13;
    number of values in the matrix: rows x columns.&#13;
&#13;
    If the size of the list doesn't match the matrix number&#13;
    of elements, an error is raised.&#13;
&#13;
    :param data: <span class="codeitalic1">[float]</span> with the values&#13;
    :return: this <span class="codeitalic1">Matrix</span></pre>&#13;
<p class="indent">There are automated tools, like Sphinx (<a href="https://www.sphinx-doc.org/"><em>https://www.sphinx-doc.org/</em></a>), that generate documentation reports in HTML, PDF, or plaintext using the docstrings in a project. You can distribute this documentation along with your code so that other developers have a good place to start learning about the code you write.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_11"/>We won’t be writing the docstrings in this book as they take up considerable space. But they should all be in the code you downloaded, and you can look at them there.</p>&#13;
<h3 class="h3" id="ch00lev1sec14"><strong>Collections in Python</strong></h3>&#13;
<p class="noindent">Our programs often work with collections of items, sometimes very large ones. We want to store these items in a way that is convenient for our purposes. Sometimes we’ll be interested in knowing whether a collection includes a particular item, and other times we’ll need to know the order of our items; we may also want a fast way of finding a given item, maybe one that fulfills a particular condition.</p>&#13;
<p class="indent">As you can see, there are many ways to interact with a collection of items. As it turns out, choosing the right way to store data is crucial for our programs to perform well. There are different collection flavors, each good for certain cases; knowing which type of collection to use in each particular situation is an important skill every software developer should master.</p>&#13;
<p class="indent">Python offers us four main collections: the set, the tuple, the list, and the dictionary. Let’s explain how each of these collections stores elements and how to use them.</p>&#13;
<h4 class="h4" id="ch00lev2sec13"><strong><em>Sets</em></strong></h4>&#13;
<p class="noindent">The <em>set</em> is an unordered collection of unique elements. Sets are most useful when we need to quickly determine whether an element exists in a collection.</p>&#13;
<p class="indent">To create a set in Python, we can use the <span class="literal">set</span> function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1 = set([1, 2, 3])</span></pre>&#13;
<p class="noindent">We can also use the literal syntax:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1 = {1, 2, 3}</span></pre>&#13;
<p class="noindent">Notice that when using the literal syntax, we define the set using curly brackets (<span class="literal">{}</span>).</p>&#13;
<p class="indent">We can get the number of elements contained inside a set using the global <span class="literal">len</span> function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">len(s1)</span>&#13;
3</pre>&#13;
<p class="indent">Checking whether an element exists in the set is a fast operation and can be done using the <span class="literal">in</span> operator:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">2 in s1</span>&#13;
True&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">5 in s1</span>&#13;
False</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>We can add new elements to the set using the <span class="literal">add</span> method:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1.add(4)</span>&#13;
# the set is now {1, 2, 3, 4}</pre>&#13;
<p class="noindent">If we try to add an element that’s already present, nothing happens because a set doesn’t allow repeated elements:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1.add(3)</span>&#13;
# the set is still {1, 2, 3, 4}</pre>&#13;
<p class="indent">We can remove an element from a set using the <span class="literal">remove</span> method:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1.add(3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">s1.remove(1)</span>&#13;
# the set is now {2, 3, 4}</pre>&#13;
<p class="indent">We can operate with sets using the familiar mathematical operations for sets. For example, we can compute the difference between two sets, which is the set containing the elements of the first set that aren’t in the second set:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1 = set([1, 2, 3])</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">s2 = set([3, 4])</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">s1.difference(s2)</span>&#13;
{1, 2}</pre>&#13;
<p class="noindent">We can also compute the union of two sets, which is the set containing all the elements that appear in both sets:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">s1 = set([1, 2, 3])</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">s2 = set([3, 4])</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">s1.union(s2)</span>&#13;
{1, 2, 3, 4}</pre>&#13;
<p class="indent">We can iterate through sets, but the order of the iteration is not guaranteed:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for element in s1:</span>&#13;
...     <span class="codestrong1">print(element)</span>&#13;
...&#13;
3&#13;
1&#13;
2</pre>&#13;
<h4 class="h4" id="ch00lev2sec14"><strong><em>Tuples</em></strong></h4>&#13;
<p class="noindent"><em>Tuples</em> are immutable and ordered sequences of elements. <em>Immutable</em> means that, once created, the tuple cannot be changed in any way. Elements in a tuple are referred to with the index they occupy, starting with zero. Counting in Python always starts from zero.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_13"/>Tuples are a good option when we’re passing a collection of ordered data around our code but don’t want the collection to be mutated in any way. For example, in code like:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">names = ('Anne', 'Emma')</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">some_function(names)</span></pre>&#13;
<p class="noindent">you can be sure the <span class="literal">names</span> tuple won’t be changed by <span class="literal">some_function</span> in any way. By contrast, if you decided to use a set like:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">names = set('Anne', 'Emma')</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">some_function(names)</span></pre>&#13;
<p class="noindent">nothing would prevent <span class="literal">some_function</span> from adding or removing elements from the passed-in <span class="literal">names</span>, so you’d need to check the function’s code to understand whether the code alters the elements.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In any case, as we’ll see later, functions shouldn’t mutate their parameters, so the functions we’ll write in this book will never modify their input parameters in any way. You might, nevertheless, use functions written by other developers who didn’t follow the same rule, so you want to check whether those functions have these kinds of side effects.</em></p>&#13;
</div>&#13;
<p class="indent">Tuples are defined between parentheses, and the elements inside a tuple are comma-separated. Here’s a tuple, defined using literal syntax, containing my name and age:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">me = ('Angel', 31)</span></pre>&#13;
<p class="noindent">If we want to create a tuple with only one element, we need to write a comma after it:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">name = ('Angel',)</span></pre>&#13;
<p class="noindent">It can also be created using the <span class="literal">tuple</span> function, passing it a list of items:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">me = tuple(['Angel', 31])</span></pre>&#13;
<p class="indent">We can get the number of items in a tuple using the <span class="literal">len</span> global function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">len(count)</span>&#13;
2</pre>&#13;
<p class="noindent">We can also count how many times a given value appears inside a tuple using the tuple’s <span class="literal">count</span> method:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">me.count('Angel')</span>&#13;
1&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">me.count(50)</span>&#13;
0&#13;
&#13;
<span epub:type="pagebreak" id="page_14"/>&gt;&gt;&gt; <span class="codestrong1">('hey', 'hey', 'hey').count('hey')</span>&#13;
3</pre>&#13;
<p class="indent">We can get the index of the first occurrence of a given item using the <span class="literal">index</span> method:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">family = ('Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel', 'Alvaro')</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">family.index('Alvaro')</span>&#13;
1</pre>&#13;
<p class="noindent">In this example, we’re looking for the index of the string ’<span class="literal">Alvaro</span>’, which appears twice: at indices 1 and 5. The <span class="literal">index</span> method yields the first occurrence’s index, which is 1 in this case.</p>&#13;
<p class="indent">The <span class="literal">in</span> operator can be used to check whether an element exists inside a tuple:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'Isabel' in family</span>&#13;
True&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">'Elena' in family</span>&#13;
False</pre>&#13;
<p class="indent">Tuples can be multiplied by numbers, a peculiar operation that yields a new tuple with the original elements repeated as many times as the multiplier number:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">('ruby', 'ruby') * 4</span>&#13;
('ruby', 'ruby', 'ruby', 'ruby', 'ruby', 'ruby', 'ruby', 'ruby')&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">('we', 'found', 'love', 'in', 'a', 'hopeless', 'place') * 16</span>&#13;
('we', 'found', 'love', 'in', 'a', 'hopeless', 'place', 'we', 'found', ...</pre>&#13;
<p class="indent">We can iterate through tuple values using <span class="literal">for</span> loops:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for city in ('San Francisco', 'Barcelona', 'Pamplona'):</span>&#13;
...     <span class="codestrong1">print(f'{city} is a beautiful city')</span>&#13;
...&#13;
San Francisco is a beautiful city&#13;
Barcelona is a beautiful city&#13;
Pamplona is a beautiful city</pre>&#13;
<p class="noindent">Using Python’s built-in <span class="literal">enumerate</span> function, we can iterate through the items in the tuple with their indices:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">cities = ('Pamplona', 'San Francisco', 'Barcelona')</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">for index, city in enumerate(cities):</span>&#13;
...     <span class="codestrong1">print(f'{city} is #{index + 1} in my favorite cities list')</span>&#13;
...&#13;
Pamplona is #1 in my favorite cities list&#13;
<span epub:type="pagebreak" id="page_15"/>San Francisco is #2 in my favorite cities list&#13;
Barcelona is #3 in my favorite cities list</pre>&#13;
<h4 class="h4" id="ch00lev2sec15"><strong><em>Lists</em></strong></h4>&#13;
<p class="noindent">The <em>list</em> is an ordered collection of nonunique elements referenced by their index. Lists are well suited for cases where we need to keep elements in order and where we know the index at which they appear.</p>&#13;
<p class="indent">Lists and tuples are similar, with the tuple’s immutability being the only difference; items in a list move around, and items can be added and removed. If you are sure the items in a large collection won’t be modified, use a tuple instead of a list; tuple manipulations are faster than their list equivalents. Python can do some optimizations if it knows the items in the collection won’t change.</p>&#13;
<p class="indent">To create a list in Python, we can use the <span class="literal">list</span> function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1 = list(['a', 'b', 'c'])</span></pre>&#13;
<p class="noindent">Or we can use the literal syntax:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1 = ['a', 'b', 'c']</span></pre>&#13;
<p class="noindent">Note the usage of the square brackets (<span class="literal">[]</span>).</p>&#13;
<p class="indent">We can check the number of items in a list using the <span class="literal">len</span> function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">len(l1)</span>&#13;
3</pre>&#13;
<p class="indent">List elements can be accessed by index (the index of the first element is zero):</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1[1]</span>&#13;
'b'</pre>&#13;
<p class="noindent">We can also replace an existing element in the list:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1[1] = 'm'</span>&#13;
# the list is now ['a', 'm', 'c']</pre>&#13;
<p class="noindent">Be careful not to use an index that doesn’t exist in the list; it’ll raise an <span class="literal">IndexError</span>:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1[35] = 'x'</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;input&gt;", line 1, in &lt;module&gt;&#13;
IndexError: list assignment index out of range</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_16"/>Items can be appended to the end of the list using the <span class="literal">append</span> method:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1.append('d')</span>&#13;
# the list is now ['a', 'm', 'c', 'd']</pre>&#13;
<p class="indent">Lists can be iterated, and the order of iteration is guaranteed:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for element in l1:</span>&#13;
...     <span class="codestrong1">print(element)</span>&#13;
...&#13;
a&#13;
m&#13;
c&#13;
d</pre>&#13;
<p class="noindent">Often enough, we’re interested not only in the element itself but also in its index in the list. In those cases, we can use the <span class="literal">enumerate</span> function, which yields a tuple of the index and element:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for index, element in enumerate(l1):</span>&#13;
...     <span class="codestrong1">print(f'{index} -&gt; {element}')</span>&#13;
...&#13;
0 -&gt; a&#13;
1 -&gt; m&#13;
2 -&gt; c&#13;
3 -&gt; d</pre>&#13;
<p class="indent">A new list can be created by taking contiguous elements from another list. This process is called <em>slicing</em>. Slicing is a big topic that requires a section of its own.</p>&#13;
<h5 class="h5" id="ch00lev3sec9"><strong>Slicing Lists</strong></h5>&#13;
<p class="noindent">Slicing a list looks a bit like indexing into the list using square brackets, except we use two indices separated by a colon: <span class="literal">[</span><em>&lt;start&gt;</em> <span class="literal">:</span> <em>&lt;end&gt;</em><span class="literal">]</span>. Here’s an example:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = [1, 2, 3, 4]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = a[1:3]</span>&#13;
# list b is [2, 3]</pre>&#13;
<p class="indent">In the previous example, we have a list <span class="literal">a</span> with values <span class="literal">[1, 2, 3, 4]</span>. We create a new list, <span class="literal">b</span>, by slicing the original list and taking the items starting at index 1 (inclusive) and ending at index 3 (noninclusive).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Don’t forget that slices in Python always include the element in the start index and exclude the element in the end index.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch01.xhtml#ch1fig4">Figure 1-4</a> illustrates this process.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_17"/><img src="../images/01fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch1fig4"><em>Figure 1-4: Slicing a list</em></p>&#13;
<p class="indent">Both the start and end indices in the slice operator are optional because they have a default value. By default, the start index is assigned the first index in the list, which is always zero. The end index is assigned the last index in the list plus one, which is equal to <span class="literal">len(the_list)</span>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = [1, 2, 3, 4]</span>&#13;
&#13;
# these two are equivalent:&#13;
&gt;&gt;&gt; <span class="codestrong1">b_1 = a[0:4]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">b_2 = a[:]</span></pre>&#13;
<p class="indent">In this example, both <span class="literal">b_1</span> and <span class="literal">b_2</span> lists are a copy of the original <span class="literal">a</span> list. By copy we really mean they’re different lists; you can safely modify <span class="literal">b_1</span> or <span class="literal">b_2</span>, and list <span class="literal">a</span> remains unchanged. You can test this by doing the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = [1, 2, 3, 4]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = a[:]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">b[0] = 55</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">print('list a:', a)</span>&#13;
list a: [1, 2, 3, 4]&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">print('list b:', b)</span>&#13;
list b: [55, 2, 3, 4]</pre>&#13;
<p class="indent">Negative indices are another trick you can use. A negative index is an index that is counted starting from the end of the list and moving toward the beginning of the list. Negative indices can be used in slicing operations the same way as positive indices, with a small exception: negative indices start at –1, not at –0. We could, for instance, slice a list to get its two last values as follows:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">a = [1, 2, 3, 4]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = a[-2:]</span>&#13;
# list b is [3, 4]</pre>&#13;
<p class="noindent">Here we’re creating a new list starting at the second position from the end all the way to the last element of the list. <a href="ch01.xhtml#ch1fig5">Figure 1-5</a> illustrates this.</p>&#13;
<p class="indent">Slicing lists is a versatile operation in Python.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_18"/><img src="../images/01fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch1fig5"><em>Figure 1-5: Slicing a list using negative indices</em></p>&#13;
<h4 class="h4" id="ch00lev2sec16"><strong><em>Dictionaries</em></strong></h4>&#13;
<p class="noindent">A <em>dictionary</em> is a collection of key-value pairs. Values in a dictionary are mapped to their key; we retrieve elements from a dictionary using their key. Finding a value in a dictionary is fast.</p>&#13;
<p class="indent">Dictionaries are useful when we want to store elements referenced by some key. For example, if we wanted to store information about our siblings and wanted to be able to retrieve it by the name of the sibling, we could use a dictionary. We’ll take a look at this in the following code.</p>&#13;
<p class="indent">To create a dictionary in Python, you can either use the <span class="literal">dict</span> function,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">colors = dict([('stoke', 'red'), ('fill', 'orange')])</span></pre>&#13;
<p class="noindent">or use the literal syntax,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">colors = {'stoke': 'red', 'fill': 'orange'}</span></pre>&#13;
<p class="indent">The <span class="literal">dict</span> function expects a list of tuples. These tuples should contain two values: the first one is used as the key, and the second is used as the value. The literal version for creating dictionaries is much less verbose, and in both cases the resulting dictionary is the same.</p>&#13;
<p class="indent">As with a list, we access values in a dictionary using square brackets. However, this time we use the key of the value between the brackets, as opposed to the index:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">colors['stroke']</span>&#13;
red</pre>&#13;
<p class="indent">You can use anything that’s immutable as the key in a dictionary. Remember that tuples are immutable, whereas lists are not. Numbers, strings, and booleans are also immutable and thus can be used as dictionary keys.</p>&#13;
<p class="indent">Let’s create a dictionary where the keys are tuples:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">ages = {('Angel', 'Sola'): 31, ('Jen', 'Gil'): 30}</span></pre>&#13;
<p class="noindent">In this example, we map the age to a key composed of a name and a surname in a tuple. If we want to know Jen’s age, we can ask for the value in a dictionary by using its key:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">age = ages[('Jen', 'Gil')]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">print(f'she is {age} years old')</span>&#13;
she is 30 years old</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>What happens when we look for a key that’s not in the dictionary?</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">age = ages[('Steve', 'Perry')]</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;input&gt;", line 1, in &lt;module&gt;&#13;
KeyError: ('Steve', 'Perry')</pre>&#13;
<p class="indent">We get an error. We can check whether a key is in a dictionary before getting its value using the <span class="literal">in</span> operator:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">('Steve', 'Perry') in ages</span>&#13;
False</pre>&#13;
<p class="indent">We can also get a set-like view of all the keys in the dictionary:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">ages.keys()</span>&#13;
dict_keys([('Angel', 'Sola'), ('Jen', 'Gil')])</pre>&#13;
<p class="indent">We can do the same for the values:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">ages.values()</span>&#13;
dict_values([31, 30])</pre>&#13;
<p class="indent">We can use the <span class="literal">in</span> operator to check for the existence of a value in both the keys and values stored in Python dictionaries:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">('Jen', 'Gil') in ages.keys()</span>&#13;
True&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">45 in ages.values()</span>&#13;
False</pre>&#13;
<p class="indent">Dictionaries can be iterated in a few ways. Let’s imagine we have the following <span class="literal">ages</span> dictionary:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">ages = {'Angel': 31, 'Jen': 30}</span></pre>&#13;
<p class="indent">We can use <span class="literal">for</span> loops to iterate through the dictionary keys:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for name in ages.keys():</span>&#13;
...     <span class="codestrong1">print(f'we have the age for {name}')</span>&#13;
...&#13;
we have the age for Angel&#13;
we have the age for Jen</pre>&#13;
<p class="indent">We can do the same for the values:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for age in ages.values():</span>&#13;
...     <span class="codestrong1">print(f'someone is {age} years old')</span>&#13;
...&#13;
someone is 31 years old&#13;
someone is 30 years old</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_20"/>And we can do the same for the key-value tuples:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for name, age in ages.items():</span>&#13;
...     <span class="codestrong1">print(f'{name} is {age} years old')</span>&#13;
...&#13;
Angel is 31 years old&#13;
Jen is 30 years old</pre>&#13;
<p class="indent">That’s about all we need to know about Python’s collections for now. Let’s continue our Python tour by looking at destructuring collections.</p>&#13;
<h3 class="h3" id="ch00lev1sec15"><strong>Destructuring</strong></h3>&#13;
<p class="noindent"><em>Destructuring</em> or <em>unpacking</em> is a technique that allows us to assign values inside a collection to variables. Let’s look at some examples.</p>&#13;
<p class="indent">Imagine we have a tuple containing information about a person, including her name and favorite beverage:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">anne_info = ('Anne', 'grape juice')</span></pre>&#13;
<p class="indent">Say we want to have those two pieces of information in separate variables. We could separate them out like so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">name = anne_info[0]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">beverage = anne_info[1]</span></pre>&#13;
<p class="indent">This is perfectly fine, but we can do it in a more elegant way using destructuring syntax. To destructure the two strings inside the tuple into two variables, we have to use another tuple with the variable names on the left side of the assignment:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">(name, beverage) = anne_info</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">name</span>&#13;
'Anne'&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">beverage</span>&#13;
&gt;&gt;&gt; 'grape juice'</pre>&#13;
<p class="indent">We can also destructure lists. For example, if we had a list containing similar information about another person, like</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">emma_info = ['Emma', 'hot chocolate']</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_21"/>we could destructure the name and favorite beverage using a list on the left side of the assignment:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[name, beverage] = emma_info</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">name</span>&#13;
'Emma'&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">beverage</span>&#13;
'hot chocolate'</pre>&#13;
<p class="indent">The left-side tuple or list has to match the size of the one on the right side, but there might be cases where we’re not interested in all of the unpacked values. In such cases, you can use an underscore in those positions where you want to ignore the corresponding value. For example,</p>&#13;
<pre>[a, _, c] = [1, 2, 3]</pre>&#13;
<p class="noindent">assigns the value <span class="literal">1</span> to variable <span class="literal">a</span> and assigns <span class="literal">3</span> to variable <span class="literal">c</span>, but it discards the value <span class="literal">2</span>.</p>&#13;
<p class="indent">This is another technique that helps us write more concise code.</p>&#13;
<h3 class="h3" id="ch00lev1sec16"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter has been a tour of some intermediate and advanced Python techniques we’ll use throughout the book. We took a look at how Python programs are made of modules bundled into packages and how to import these modules from other parts of our code.</p>&#13;
<p class="indent">We also explained the “if name is main” pattern, which is used to avoid executing portions of the code when the file is imported.</p>&#13;
<p class="indent">Then, we briefly touched on the four basic Python collections: tuples, lists, sets, and dictionaries. We also looked at how to destructure, or unpack, these collections.</p>&#13;
<p class="indent">Now let’s shift gears and talk about a few programming paradigms.<span epub:type="pagebreak" id="page_22"/></p>&#13;
</body></html>