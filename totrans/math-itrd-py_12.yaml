- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: BUILDING OBJECTS WITH CLASSES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类构建对象
- en: '*Old teachers never die, they just lose their class.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*老教师永远不会死，他们只是失去了他们的班级。*'
- en: —Anonymous*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —匿名*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Now that you’ve created cool graphics using functions and other code in Processing,
    you can supercharge your creativity using classes. A *class* is a structure that
    lets you create new types of objects. The object types (usually just called *objects*)
    can have *properties*, which are variables, and *methods*, which are functions.
    There are times you want to draw multiple objects using Python, but drawing lots
    of them would be way too much work. Classes make drawing several objects with
    the same properties easy, but they require a specific syntax you’ll need to learn.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用函数和Processing中的其他代码，你已经创建了很酷的图形，你可以通过使用类来进一步激发你的创造力。*类*是一种结构，它让你可以创建新的对象类型。对象类型（通常称为*对象*）可以有*属性*，即变量，也可以有*方法*，即函数。有时你可能想要在Python中绘制多个对象，但绘制太多会非常麻烦。类让你能够轻松地绘制多个具有相同属性的对象，但它们需要特定的语法，你需要学习。
- en: The following example from the official Python website shows how to create a
    “Dog” object using a class. To code along, open a new file in IDLE, name it *dog.py*
    and enter the following code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自官方Python网站的示例，展示了如何使用类创建一个“狗”对象。要进行编码，可以在IDLE中打开一个新文件，将其命名为*dog.py*，并输入以下代码。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates a new object called `Dog` using `class Dog`. It’s customary in
    Python and many other languages to capitalize the name of a class, but it’ll still
    work if you don’t. To instantiate, or create, the class, we have to use Python’s
    `__init__` method, which has two underscores before and two after `init`, meaning
    it’s a special method to create (or *construct*) an object. The `__init__` line
    makes it possible to create instances of the class (in this case, dogs). In the
    `__init__` method, we can create any properties of the class we want. Since it’s
    a dog, it can have a name, and because every dog has its own name, we use the
    `self` syntax. We don’t need to use it when we call the objects, only when we’re
    defining them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过`class Dog`创建了一个新的对象，名为`Dog`。在Python以及许多其他语言中，类名通常是大写的，但即使你不这样做，它仍然能正常工作。为了实例化，或者说创建这个类，我们必须使用Python的`__init__`方法，`init`前后都有两个下划线，这意味着它是一个特殊的方法，用于创建（或*构造*）对象。`__init__`这一行使得我们可以创建类的实例（在这里就是狗）。在`__init__`方法中，我们可以创建类的任何属性。由于这是狗，它可以有一个名字，而且每只狗都有自己的名字，所以我们使用`self`语法。我们在调用对象时不需要使用它，只在定义时使用。
- en: 'We can then create a dog with a name using the following line of code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码行创建一个有名字的狗：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now `d` is a `Dog` and its name is Fido. You can confirm this by running the
    file and entering the following in the shell:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`d`是一个`Dog`，它的名字是Fido。你可以通过运行文件并在shell中输入以下内容来确认这一点：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now when we call `d.name`, we get Fido because that is the `name` property
    we just gave to it. We can create another `Dog` and give it the name Bettisa,
    like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们调用`d.name`时，我们会得到Fido，因为那是我们刚才赋予它的`name`属性。我们可以创建另一个`Dog`并给它命名为Bettisa，像这样：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see one dog’s name can be different from another’s, but the program
    remembers them perfectly! This will be crucial when we give locations and other
    properties to the objects we create.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一只狗的名字和另一只狗的名字是不同的，但程序能完美记住它们！当我们为我们创建的对象赋予位置和其他属性时，这将非常重要。
- en: Finally, we can give the dog something to do by putting a function in the class.
    But don’t call it a function! A function inside a class is called a *method*.
    Dogs bark, so we’ll add that method to the code in [Listing 9-1](ch09.xhtml#ch09list1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在类中放置一个函数来让狗做点事情。但别称它为函数！类中的函数叫做*方法*。狗会叫，所以我们将在[示例 9-1](ch09.xhtml#ch09list1)的代码中添加这个方法。
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-1: Creating a dog that barks!*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-1：创建一只会叫的狗！*'
- en: 'When we call the `bark()` method of the `d` dog, it barks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`d`狗的`bark()`方法时，它会叫：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It might not be clear why you’d need a `Dog` class from this simple example,
    but it’s good to know you can do literally anything you want with classes and
    be as creative as you want. In this chapter, we use classes to make lots of useful
    objects like bouncing balls and grazing sheep. Let’s start with the Bouncing Ball
    example to see how using classes lets us do something really cool while saving
    us a lot of work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的例子中，你可能不太明白为什么需要一个`Dog`类，但知道你可以用类做任何你想做的事情，发挥创意，真的是很重要的。在这一章，我们将使用类来创建许多有用的对象，比如弹跳的球和吃草的羊。让我们从弹跳球的例子开始，看看如何通过使用类来做一些很酷的事情，同时节省很多工作量。
- en: BOUNCING BALL PROGRAM
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹跳球程序
- en: Start a Processing sketch and save it as *BouncingBall.pyde*. We’ll draw a single
    circle on the screen, which we’ll make into a bouncing ball. [Listing 9-2](ch09.xhtml#ch09list2)
    shows the code for drawing one circle.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个Processing草图并将其保存为*BouncingBall.pyde*。我们将在屏幕上绘制一个圆形，并将其变成一个弹跳的小球。[清单 9-2](ch09.xhtml#ch09list2)展示了绘制一个圆形的代码。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-2: Drawing a circle*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：绘制一个圆形*'
- en: First, we set the size of the window to be 600 pixels wide and 600 pixels tall.
    Then we set the background to black and drew a circle using the `ellipse()` function.
    The first two numbers in the function describe how far the center of the circle
    is from the top-left corner of the window, and the last two numbers describe the
    width and height of the ellipse. In this case, `ellipse(300,300, 20,20)` creates
    a circle that is 20 pixels wide and 20 pixels high, located in the center of the
    display window, as shown in [Figure 9-1](ch09.xhtml#ch09fig1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将窗口的大小设置为600像素宽和600像素高。然后，我们将背景设置为黑色，并使用`ellipse()`函数绘制一个圆形。函数中的前两个数字表示圆心距离窗口左上角的水平和垂直距离，最后两个数字表示椭圆的宽度和高度。在这个例子中，`ellipse(300,300,
    20,20)`创建了一个20像素宽、20像素高的圆形，位于显示窗口的中心，如[图 9-1](ch09.xhtml#ch09fig1)所示。
- en: '![image](../images/f177-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f177-01.jpg)'
- en: '*Figure 9-1: Drawing one circle for the Bouncing Ball sketch*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：为弹跳小球草图绘制一个圆形*'
- en: Now that we have successfully created a circle located in the center of the
    display window, let’s try to make it move.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地创建了一个位于显示窗口中心的圆形，让我们尝试让它移动。
- en: '#### MAKING THE BALL MOVE'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 让小球移动'
- en: We’ll make the ball move by changing its position. To do this, let’s first create
    a variable for the x-value and a variable for the y-value and set them to 300,
    which is the middle of the screen. Go back to [Listing 9-2](ch09.xhtml#ch09list2)
    and insert the following two lines at the beginning of the code, like in [Listing
    9-3](ch09.xhtml#ch09list3).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过改变小球的位置来让它移动。为此，首先创建一个表示x值的变量和一个表示y值的变量，并将它们的值设置为300，这个值是屏幕的中间位置。回到[清单
    9-2](ch09.xhtml#ch09list2)，并在代码的开头插入以下两行，就像在[清单 9-3](ch09.xhtml#ch09list3)中一样。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-3: Setting variables for the x- and y-values*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：设置x值和y值的变量*'
- en: Here, we use the `xcor` variable to represent the x-value and the `ycor` variable
    to represent the y-value. Then we set both variables to 300.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`xcor`变量来表示x值，使用`ycor`变量来表示y值。然后，我们将这两个变量的值都设置为300。
- en: Now let’s change the x-value and y-value by a certain number in order to change
    the location of the ellipse. Make sure to use the variables to draw the ellipse,
    as shown in [Listing 9-4](ch09.xhtml#ch09list4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过改变x值和y值来改变椭圆的位置。确保使用这些变量来绘制椭圆，如[清单 9-4](ch09.xhtml#ch09list4)中所示。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-4: Incrementing `xcor` and `ycor` to change the location of the
    ellipse*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-4：递增`xcor`和`ycor`来改变椭圆的位置*'
- en: 'The important thing to notice in this example is `global xcor, ycor` ➊, which
    tells Python to use the variables we’ve already created and not to create new
    ones just for the `draw()` function. If you don’t include this line, you’ll get
    an error message, something like “local variable ‘xcor’ referenced before assignment.”
    Once Processing knows what value to assign to `xcor` and `ycor`, we increment
    them both by 1 and draw the ellipse with its center at the location specified
    using the global variables: `(xcor, ycor)`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，值得注意的关键点是`global xcor, ycor` ➊，它告诉Python使用我们已经创建的变量，而不是仅仅为了`draw()`函数而创建新的变量。如果你没有包含这行代码，你将会看到类似“在赋值之前引用了局部变量‘xcor’”这样的错误信息。一旦Processing知道了要为`xcor`和`ycor`分配什么值，我们就可以将它们都增加1，并使用全局变量`(xcor,
    ycor)`绘制椭圆。
- en: When you save and run [Listing 9-4](ch09.xhtml#ch09list4), you should see the
    ball move, like in [Figure 9-2](ch09.xhtml#ch09fig2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存并运行[清单 9-4](ch09.xhtml#ch09list4)时，你应该看到小球移动，就像在[图 9-2](ch09.xhtml#ch09fig2)中看到的那样。
- en: Now the ball moves down and to the right, because its x- and y-values are both
    increasing, but then it moves off the screen and we never see it again! The program
    keeps incrementing our variables obediently. It doesn’t know it’s drawing a ball
    or that we want the ball to bounce off the walls. Let’s explore how to keep the
    ball from disappearing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在小球开始向下和向右移动，因为它的x值和y值都在增加，但是接着它移出了屏幕，我们再也看不见它了！程序会继续顺从地递增我们的变量。它并不知道自己在绘制一个小球，或者我们希望小球能反弹回墙壁。让我们来探索如何避免小球消失。
- en: '![image](../images/f179-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f179-01.jpg)'
- en: '*Figure 9-2: The ball moves!*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：小球在移动！*'
- en: MAKING THE BALL BOUNCE OFF THE WALL
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让小球从墙壁反弹
- en: When we change the x-value and the y-value by adding 1, we’re changing the position
    of an object. In math, this change in position over time is called *velocity*.
    A positive change in x over time (positive x-velocity) will look like movement
    to the right (since x is getting bigger), whereas negative x-velocity will look
    like movement to the left. We can use this “positive-right, negative-left” concept
    to make the ball bounce off the wall. First, let’s create the x-velocity and y-velocity
    variables by adding the following lines to our existing code, as shown in [Listing
    9-5](ch09.xhtml#ch09list5).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过增加1来改变x值和y值时，我们在改变一个物体的位置。在数学中，这种随时间变化的位置变化被称为*速度*。x在时间上的正向变化（正x速度）看起来像是向右移动（因为x在增大），而负x速度则看起来像是向左移动。我们可以用这种“正向右，负向左”的概念让球弹跳出墙壁。首先，我们通过在现有代码中添加以下几行来创建x速度和y速度变量，具体代码见[Listing
    9-5](ch09.xhtml#ch09list5)。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-5: Adding code to make the ball bounce off the wall*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-5: 添加代码让球弹跳出墙壁*'
- en: First, we set `xvel = 1` and `yvel = 2` to specify how the ball will move. You
    can use other values and see how they change the movement. Then in the `draw()`
    function, we tell Python that `xvel` and `yvel` are global variables, and we change
    the x- and y-coordinates by incrementing using these variables. For example, when
    we set `xcor += xvel`, we’re updating the position by the velocity (the *change*
    in position).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置`xvel = 1`和`yvel = 2`来指定球的运动方式。你可以使用其他值，观察它们如何改变运动。然后在`draw()`函数中，我们告诉Python
    `xvel`和`yvel`是全局变量，并且通过使用这些变量来增量地改变x和y坐标。例如，当我们设置`xcor += xvel`时，我们通过速度（位置的*变化*）来更新位置。
- en: The two `if` statements tell the program that if the ball’s position goes outside
    the boundaries of the screen, it should change the ball’s velocity to its negative
    value. When we change the ball’s velocity to its negative value, we tell the program
    to move the ball in the opposite direction it was moving in, making it seem like
    the ball is bouncing off the wall.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`if`语句告诉程序，如果球的位置超出屏幕边界，它应该将球的速度改为其负值。当我们将球的速度改为负值时，我们告诉程序将球向它原本的相反方向移动，这样就看起来像球在弹跳。
- en: We need to be precise in telling at what point the ball should move in the opposite
    direction in terms of its coordinates. For example, `xcor > width` represents
    cases where `xcor` is larger than the width of the display window, which is when
    the ball touches the right edge of the screen. And `xcor < 0` represents instances
    where the `xcor` is less than 0 or when the ball touches the left edge of the
    screen. Similarly, `ycor > height` checks for instances where `ycor` is larger
    than the height of the window or when the ball reaches the bottom of the screen.
    Finally, `ycor < 0` checks for instances where the ball reaches the upper edge
    of the screen. Since moving to the right is positive x-velocity (positive change
    in x), the opposite direction is negative x-velocity. If the velocity is already
    negative (it’s moving to the left), then the negative of a negative is a positive,
    which means the ball will move to the right, just like we want it to.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要精确地告诉程序，在什么情况下球应该改变方向，具体是基于它的坐标。例如，`xcor > width`表示`xcor`大于显示窗口的宽度，这时球碰到了屏幕的右边缘。而`xcor
    < 0`表示`xcor`小于0，或者球碰到了屏幕的左边缘。同样，`ycor > height`检查`ycor`大于窗口的高度，或者球到达了屏幕的底部。最后，`ycor
    < 0`检查球是否到达屏幕的上边缘。由于向右移动是正的x速度（x的正向变化），相反方向就是负的x速度。如果速度已经是负值（即球向左移动），那么负的负值就是正值，这意味着球将向右移动，正如我们希望的那样。
- en: When you run [Listing 9-5](ch09.xhtml#ch09list5), you should see something like
    what’s shown in [Figure 9-3](ch09.xhtml#ch09fig3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[Listing 9-5](ch09.xhtml#ch09list5)时，你应该会看到类似于[Figure 9-3](ch09.xhtml#ch09fig3)中所示的效果。
- en: '![image](../images/f180-01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f180-01.jpg)'
- en: '*Figure 9-3: One bouncing ball!*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 9-3: 一个弹跳的球！*'
- en: The ball looks like it’s bouncing off the walls and therefore stays in view.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 球看起来像是在弹跳出墙壁，因此保持在视图中。
- en: '#### MAKING MULTIPLE BALLS WITHOUT CLASSES'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 没有类的情况下制作多个球'
- en: Now suppose we want to make another bouncing ball, or many other bouncing balls.
    How would we do that? We could make a new variable for the second ball’s x-value,
    another variable for the second ball’s y-value, a third variable for its x-velocity,
    and a fourth for its y-velocity. Then we’d have to increment its position by its
    velocity, check if it needs to bounce off a wall, and finally draw it. However,
    we’d end up with double the amount of code! Adding a third ball would triple our
    code! Twenty balls would simply be out of the question. You *don’t* want to have
    to keep track of all these variables for position and velocity. [Listing 9-6](ch09.xhtml#ch09list6)
    show what this would look like.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要制作另一个弹跳球，或者多个弹跳球。我们该怎么做呢？我们可以为第二个球的 x 值创建一个新变量，为第二个球的 y 值创建另一个变量，为其
    x 速度创建第三个变量，为其 y 速度创建第四个变量。然后，我们必须按其速度递增其位置，检查是否需要从墙壁上反弹，最后绘制它。然而，我们最终将得到双倍的代码量！再增加一个球就会使代码量增加三倍！二十个球体根本无法处理。你*不*想跟踪所有这些位置和速度的变量。[清单
    9-6](ch09.xhtml#ch09list6) 显示了这将是什么样子。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-6: Creating multiple balls without classes. Way too much code!*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：没有使用类创建多个球体。代码量太多了！*'
- en: This is the code for creating only three balls. As you can see, it’s very long,
    and this doesn’t even include the bouncing part! Let’s see how we can use classes
    to make this task easier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仅创建三个球体的代码。如你所见，它非常长，而且这还没有包括弹跳部分！让我们看看如何使用类来简化这个任务。
- en: '#### CREATING OBJECTS USING CLASSES'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用类创建对象'
- en: In programming, a class works like a recipe that details a way to create an
    object with its own specific properties. Using classes, we tell Python how to
    make a ball once. Then all we have to do is create a bunch of balls using a `for`
    loop and put them in a list. Lists are great for saving numerous things—strings,
    numbers, and objects!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，类就像一个食谱，详细说明了如何创建具有特定属性的对象。使用类，我们告诉 Python 如何创建一个球体一次。然后，我们所要做的就是使用 `for`
    循环创建多个球体，并将它们放入一个列表中。列表非常适合保存许多事物——字符串、数字和对象！
- en: 'Follow these three steps when using classes to create objects:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类创建对象时，请按照以下三个步骤操作：
- en: '*Write the class*. This is like a recipe for how to make balls, planets, rockets,
    and so on.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编写类*。这就像是制作球体、行星、火箭等的食谱。'
- en: '*Instantiate the object or objects*. You do this by calling the objects in
    the `setup()` function.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*实例化对象*。你可以通过在 `setup()` 函数中调用对象来做到这一点。'
- en: '*Update the object or objects*. Do this in the `draw()` function (the display
    loop).'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*更新对象*。在 `draw()` 函数（显示循环）中执行此操作。'
- en: Let’s use these steps to put the code we’ve already written into a class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些步骤将我们已经编写的代码放入类中。
- en: Writing the Class
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写类
- en: The first step in creating objects using classes is to write a class that tells
    the program how to make a ball. Let’s add the code in [Listing 9-7](ch09.xhtml#ch09list7)
    at the very beginning of our existing program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类创建对象的第一步是编写一个类，告诉程序如何制作一个球体。让我们将 [清单 9-7](ch09.xhtml#ch09list7) 中的代码添加到我们现有程序的最前面。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-7: Defining a class called `Ball`*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：定义一个名为 `Ball` 的类*'
- en: 'Note that because we’re putting the position and velocity variables into the
    `Ball` class as properties, you can delete the following lines from your existing
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们将位置和速度变量作为属性放入了 `Ball` 类中，你可以从现有代码中删除以下几行：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In [Listing 9-7](ch09.xhtml#ch09list7), we create an empty list we’ll use to
    save the balls in; then we start defining the recipe. The name of a class object,
    which is `Ball` in this case, is always capitalized. The `__init__` method is
    a requirement to create a class in Python that contains all the properties the
    object gets when it’s initialized. Otherwise, the class won’t work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9-7](ch09.xhtml#ch09list7) 中，我们创建了一个空列表，用于保存球体；然后我们开始定义这个食谱。类对象的名称（在本例中为
    `Ball`）总是以大写字母开头。`__init__` 方法是 Python 中创建类的必要条件，它包含了对象在初始化时获得的所有属性。否则，类将无法正常工作。
- en: 'The `self` syntax simply means every object has its own methods and properties,
    which are functions and variables that can’t be used except by a `Ball` object.
    This means that each `Ball` has its own `xcor`, its own `ycor`, and so on. Because
    we might have to create a `Ball` at a specific location at some point, we made
    `x` and `y` parameters of the `__init__` method. Adding these parameters allows
    us to tell Python the location of a `Ball` when we create it, like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`语法意味着每个对象都有自己的方法和属性，这些函数和变量只能被`Ball`对象使用。这意味着每个`Ball`都有自己的`xcor`，自己的`ycor`，等等。因为我们可能在某个时刻需要在特定位置创建一个`Ball`，我们将`x`和`y`设置为`__init__`方法的参数。添加这些参数可以让我们在创建`Ball`时告诉Python它的位置，如下所示：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the ball will be located at the coordinate (100,200).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，球将位于坐标(100, 200)。
- en: The last lines in [Listing 9-7](ch09.xhtml#ch09list7) tell Processing to assign
    a random number between –2 and 2 to be the x- and y-velocity of the new ball.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-7](ch09.xhtml#ch09list7)中的最后几行告诉Processing为新球的x速度和y速度分配一个介于-2和2之间的随机数。'
- en: Instantiating the Object
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实例化对象
- en: Now that we’ve created a class called `Ball`, we need to tell Processing how
    to update the ball every time the `draw()` function loops. We’ll call that the
    `update` method and nest it inside the `Ball` class, just like we did with `__init__`.
    You can simply cut and paste all the ball code into the `update()` method and
    then add `self.` to each of the object’s properties, as shown in [Listing 9-8](ch09.xhtml#ch09list8).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了一个名为`Ball`的类，我们需要告诉Processing每次`draw()`函数循环时如何更新球。我们将创建一个`update`方法，并将其嵌套在`Ball`类中，就像我们之前做的`__init__`方法一样。你可以简单地将所有球的代码剪切并粘贴到`update()`方法中，然后为每个对象的属性添加`self.`，如下所示在[示例
    9-8](ch09.xhtml#ch09list8)中展示。
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-8: Creating the `update()` method*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-8：创建`update()`方法*'
- en: Here, we placed all the code for moving and bouncing a ball into the `update()`
    method of the `Ball` class. The only new code is `self` in the velocity variables,
    making them velocity properties of the `Ball` object. Although it might seem like
    there are many instances of `self`, that’s how we tell Python that the x-coordinate,
    for example, belongs to that specific ball and not another. Very soon, Python
    is going to be updating a hundred balls, so we need `self` to keep track of each
    one’s location and velocity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将所有移动和弹跳球的代码都放入了`Ball`类的`update()`方法中。唯一的新代码是`self`出现在速度变量中，使它们成为`Ball`对象的速度属性。虽然看起来有很多`self`，但这就是我们告诉Python，举个例子，x坐标属于特定的那个球而不是其他球。很快，Python将要更新上百个球，所以我们需要`self`来追踪每个球的位置和速度。
- en: Now that the program knows how to create and update a ball, let’s update the
    `setup()` function to create three balls and put them into the ball list (`ballList`),
    as shown in [Listing 9-9](ch09.xhtml#ch09list9).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序知道如何创建和更新一个球，我们来更新`setup()`函数，创建三个球并将它们放入球列表（`ballList`）中，具体见[示例 9-9](ch09.xhtml#ch09list9)。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-9: Creating three balls in the `setup()` function*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-9：在`setup()`函数中创建三个球*'
- en: We created `ballList` in [Listing 9-7](ch09.xhtml#ch09list7) already, and here
    we’re appending to the list a `Ball` at a random location. When the program creates
    (instantiates) a new ball, it will now choose a random number between 0 and the
    width of the screen to be the x-coordinate and another random number between 0
    and the height of the screen to be the y-coordinate. Then it’ll put that new ball
    into the list. Because we used the loop `for i in range(3)`, the program will
    add three balls to the ball list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[示例 9-7](ch09.xhtml#ch09list7)中创建了`ballList`，现在我们在列表中随机位置添加一个`Ball`。当程序创建（实例化）一个新的球时，它会选择一个介于0和屏幕宽度之间的随机数作为x坐标，另一个介于0和屏幕高度之间的随机数作为y坐标。然后，它会将这个新的球添加到列表中。因为我们使用了`for
    i in range(3)`的循环，程序会向球列表中添加三个球。
- en: Updating the Object
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新对象
- en: 'Now let’s tell the program to go through `ballList` and update all the balls
    in the list (which means drawing them) every loop using the following `draw()`
    function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们告诉程序遍历`ballList`，并在每次循环中更新列表中的所有球（即绘制它们），使用以下`draw()`函数：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we still want the background to be black, and then we loop over the
    ball list and for every ball in the list we run its `update()` method. All the
    previous code in `draw()` went into the `Ball` class!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仍然希望背景是黑色的，然后我们遍历球列表，对于列表中的每个球，我们运行它的`update()`方法。`draw()`中之前的所有代码都被移到了`Ball`类中！
- en: '![image](../images/f184-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f184-01.jpg)'
- en: '*Figure 9-4: Creating as many bouncing balls as you want!*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：创建任意数量的弹跳球！*'
- en: 'When you run this sketch, you should see three balls moving around the screen
    and bouncing off the walls! The great thing about using classes is that it’s super
    easy to change the number of balls. All you have to do is change the *`number`*
    in `for i in range(*number*)`: in the `setup()` function to create even more bouncing
    balls. When you change this to 20, for example, you’ll see something like [Figure
    9-4](ch09.xhtml#ch09fig4).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个草图时，你应该能看到三个小球在屏幕上移动并撞击墙壁！使用类的一个好处是可以轻松更改小球的数量。你所要做的就是在`setup()`函数中的`for
    i in range(*number*)`里更改*`number`*，这样就能创建更多的小球。例如，将这个数字改为20，你就会看到类似[图9-4](ch09.xhtml#ch09fig4)的效果。
- en: What’s cool about using classes is that you can give an object any properties
    or methods you want. For example, we don’t have to make our balls all the same
    color. Add the three lines of code shown in [Listing 9-10](ch09.xhtml#ch09list10)
    to your existing `Ball` class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的一个酷点是，你可以为对象赋予任何你想要的属性或方法。例如，我们不必让所有的小球都使用相同的颜色。你可以将[Listing 9-10](ch09.xhtml#ch09list10)中的三行代码添加到你现有的`Ball`类中。
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-10: Updating the `Ball` class*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-10: 更新`Ball`类*'
- en: This code gives every ball its own color when it’s created. Processing’s `color()`
    function needs three numbers that represent red, green, and blue, respectively.
    RGB values go from 0 to 255\. Using `random(255)` lets the program choose the
    numbers randomly, resulting in a randomly chosen color. However, because the `__init__`
    method runs only one time, once the ball has a color, it keeps it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在创建每个小球时给它分配一个独立的颜色。Processing的`color()`函数需要三个数字，分别代表红色、绿色和蓝色。RGB值的范围是从0到255。使用`random(255)`让程序随机选择这三个数字，从而得到一个随机的颜色。然而，因为`__init__`方法只执行一次，所以一旦小球拥有了颜色，它就会保持这个颜色。
- en: 'Next, in the `update()` method, add the following line so the ellipse gets
    filled with its own randomly chosen color:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`update()`方法中，添加如下代码，使得椭圆被填充上自己随机选中的颜色：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before a shape or line gets drawn, you can declare its color using `fill` for
    shapes or `stroke` for lines. Here, we tell Processing to use the ball’s own color
    (using `self`) to fill in the following shape.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制形状或线条之前，你可以使用`fill`为形状声明颜色，或者使用`stroke`为线条声明颜色。在这里，我们告诉Processing使用小球自己的颜色（通过`self`）来填充下面的形状。
- en: Now when you run the program, each ball should have a random color, as shown
    in [Figure 9-5](ch09.xhtml#ch09fig5)!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行程序时，每个小球应该都有一个随机颜色，如[图9-5](ch09.xhtml#ch09fig5)所示！
- en: '![image](../images/f185-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f185-01.jpg)'
- en: '*Figure 9-5: Giving balls their own colors*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：给小球赋予不同的颜色*'
- en: 'EXERCISE 9-1: CREATING BALLS OF DIFFERENT SIZES'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9-1：创建不同大小的小球
- en: Give each ball its own size, between 5 and 50 units.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个小球一个自己的大小，大小范围为5到50单位。
- en: GRAZING SHEEP PROGRAM
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 放牧羊程序
- en: Now that you can create classes, let’s make something useful. We’ll code a Processing
    sketch of an ecosystem that simulates sheep walking around eating grass. In this
    sketch, the sheep have a certain level of energy that gets depleted as they walk
    around, and their energy gets replenished when they eat grass. If they get enough
    energy, they reproduce. If they don’t get enough energy, they die. We could potentially
    learn a lot about biology, ecology, and evolution by creating and tweaking this
    model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以创建类了，我们来做一些有用的事情。我们将编写一个Processing草图，模拟羊在草地上走动并吃草的生态系统。在这个草图中，羊有一定的能量，走动时能量会减少，而吃草时能量会恢复。如果它们获得足够的能量，它们就会繁殖。如果能量不足，它们就会死亡。通过创建和调整这个模型，我们可能会学到很多关于生物学、生态学和进化学的知识。
- en: In this program, the `Sheep` objects are kind of like the `Ball` objects you
    created earlier in this chapter; each has its own x- and y-position and size,
    and is represented by a circle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，`Sheep`对象有点像你在本章前面创建的`Ball`对象；每个对象都有自己的x和y坐标及大小，并且用圆形表示。
- en: WRITING THE CLASS FOR THE SHEEP
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写羊类代码
- en: Start a new Processing sketch and save it as *SheepAndGrass.pyde*. First, let’s
    create a class that makes a `Sheep` object with its own x- and y-position and
    its own size. Then we’ll create an `update` method that draws an ellipse representing
    the sheep’s size at the sheep’s location.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的Processing草图，并将其保存为*SheepAndGrass.pyde*。首先，我们创建一个类，使其能够生成一个具有自己x和y坐标及大小的`Sheep`对象。然后我们将创建一个`update`方法，在羊的位置画出一个椭圆，表示羊的大小。
- en: The class code is nearly identical to the `Ball` class, as you can see in [Listing
    9-11](ch09.xhtml#ch09list11).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类的代码几乎与`Ball`类相同，正如你在[Listing 9-11](ch09.xhtml#ch09list11)中所看到的那样。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 9-11: Creating a class for one sheep*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-11: 为一只羊创建类*'
- en: Because we know we’ll be making a bunch of sheep, we start off creating a `Sheep`
    class. In the required `__init__` method, we set the x- and y-coordinates of the
    sheep to the parameters we’ll declare when creating a sheep instance. I’ve set
    the size of the sheep (the diameter of the ellipse) to 10 pixels, but you can
    have bigger or smaller sheep if you like. The `update()` method simply draws an
    ellipse of the sheep’s size at the sheep’s location.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道将要创建一堆羊，所以我们从创建一个`Sheep`类开始。在必需的`__init__`方法中，我们将羊的x和y坐标设置为我们在创建羊实例时声明的参数。我将羊的大小（即椭圆的直径）设置为10像素，但如果你喜欢，也可以有更大或更小的羊。`update()`方法只是简单地在羊的位置绘制一个与羊大小相同的椭圆。
- en: Here’s the `setup()` and `draw()` code for a Processing sketch containing one
    `Sheep`, which I’ve named `shawn`. Add the code shown in [Listing 9-12](ch09.xhtml#ch09list12)
    right below the `update()` method you just wrote in [Listing 9-11](ch09.xhtml#ch09list11).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包含一个`Sheep`对象（我将其命名为`shawn`）的Processing草图中的`setup()`和`draw()`代码。将[清单9-12](ch09.xhtml#ch09list12)中的代码添加到你刚刚在[清单9-11](ch09.xhtml#ch09list11)中编写的`update()`方法下方。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 9-12: Creating a `Sheep` object named `shawn`*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-12：创建一个名为`shawn`的`Sheep`对象*'
- en: We first create `shawn`, an instance of a `Sheep` object, in the `setup()` function.
    Then we update it in the `draw()` function—but Python doesn’t know we mean the
    same `shawn` unless we tell it that `shawn` is a global variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`setup()`函数中创建了一个`shawn`，它是一个`Sheep`对象的实例。然后我们在`draw()`函数中更新它——但是Python并不知道我们指的是同一个`shawn`，除非我们告诉它`shawn`是一个全局变量。
- en: When you run this code, you should see something like what’s shown in [Figure
    9-6](ch09.xhtml#ch09fig6).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该看到类似[图9-6](ch09.xhtml#ch09fig6)中的效果。
- en: '![image](../images/f187-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f187-01.jpg)'
- en: '*Figure 9-6: One sheep*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：一只羊*'
- en: You get a white screen with a little circular sheep at the coordinate (300,200),
    which is 300 pixels to the right of the starting point and 200 pixels down.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个白色的屏幕，屏幕上有一个小圆形的羊，位于坐标（300，200）处，也就是从起点向右300像素，向下200像素。
- en: PROGRAMMING SHEEP TO MOVE AROUND
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程让羊四处移动
- en: 'Now let’s teach a `Sheep` how to move around. We’ll start by programming the
    `Sheep` to move around randomly. (You can always program it to move differently
    in the future if you want to.) [Listing 9-13](ch09.xhtml#ch09list13) changes the
    x- and y-coordinates of a `Sheep` by a random number between –10 and 10\. Return
    to your existing code and add the following lines above the `ellipse()` function
    within the `update()` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们教一个`Sheep`如何移动。我们将从编程让`Sheep`随机移动开始。（如果以后你想要让它以不同的方式移动，随时可以更改。）[清单9-13](ch09.xhtml#ch09list13)通过一个介于-10和10之间的随机数来改变`Sheep`的x和y坐标。返回到现有代码，在`update()`方法中的`ellipse()`函数上方添加以下几行代码：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 9-13: Making the sheep move randomly*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-13：让羊随机移动*'
- en: This code creates a variable called `move` to specify the maximum value or distance
    the sheep will be able to move on the screen. Then we set `move` to 10 and use
    it to update the sheep’s x- and y-coordinates by a random number between `-move`
    (–10) and `move` (10). Finally, we use `fill(255)` to set the sheep’s color to
    white for now.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`move`的变量，用来指定羊能够在屏幕上移动的最大值或距离。然后我们将`move`设置为10，并使用它通过一个介于`-move`（–10）和`move`（10）之间的随机数来更新羊的x和y坐标。最后，我们使用`fill(255)`将羊的颜色暂时设置为白色。
- en: When you run this code, you should see the sheep wandering around randomly—and
    it might wander off the screen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该看到羊随机地在四处游荡——它可能会游荡出屏幕之外。
- en: Let’s give the sheep some company. If we want to create and update more than
    one object, it’s a good idea to put them in a list. Then in the `draw()` function,
    we’ll go through the list and update each `Sheep`. Update your existing code to
    look like [Listing 9-14](ch09.xhtml#ch09list14).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给羊群增加一些伙伴。如果我们想创建和更新多个对象，把它们放进一个列表是个不错的主意。然后在`draw()`函数中，我们会遍历这个列表并更新每一个`Sheep`对象。更新你的现有代码，使其像[清单9-14](ch09.xhtml#ch09list14)一样。
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 9-14: Creating more sheep using a `for` loop*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-14：使用`for`循环创建更多的羊*'
- en: This code is similar to the code we wrote to put the bouncing balls in a list.
    First, we create a list to store the sheep. Then we create a `for` loop and put
    a `Sheep` in the sheep list. Then in the `draw()` function, we write another `for`
    loop to go through the sheep list and update each one according to the `update()`
    method we already defined. When you run this code, you should get three `Sheep`
    walking around randomly. Change the number `3` in `for i in range(3):` to a larger
    number to add even more sheep.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前写的将弹跳球放入列表的代码类似。首先，我们创建一个列表来存储羊。然后，我们创建一个`for`循环，将一只`Sheep`添加到羊的列表中。接着，在`draw()`函数中，我们再写一个`for`循环，遍历羊列表，并根据我们已经定义的`update()`方法更新每只羊。当你运行这段代码时，应该会看到三只`Sheep`在随机走动。你可以将`for
    i in range(3):`中的数字`3`改成更大的数字，以增加更多的羊。
- en: CREATING THE ENERGY PROPERTY
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建能量属性
- en: Walking takes up energy! Let’s give the sheep a certain level of energy when
    they’re created and take away their energy when they walk. Use the code in [Listing
    9-15](ch09.xhtml#ch09list15) to update your existing `__init__` and `update()`
    methods in the *SheepAndGrass.pyde*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 走路会消耗能量！让我们在羊创建时给予它一定的能量，并在它们走动时消耗掉能量。使用[清单 9-15](ch09.xhtml#ch09list15)中的代码来更新你现有的`__init__`和`update()`方法，在*SheepAndGrass.pyde*中完成。
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 9-15: Updating `__init__` and `update()` with the `energy` property*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-15：使用`energy`属性更新`__init__`和`update()`方法*'
- en: We do this by creating an `energy` property in the `__init__` method and set
    it to 20, the energy level every sheep starts with. Then `self.energy -= 1` in
    the `update()` method lowers the sheep’s energy level by 1 when it walks around.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`__init__`方法中创建一个`energy`属性并将其设置为20，表示每只羊的初始能量水平。然后，在`update()`方法中，`self.energy
    -= 1`会让羊在四处走动时减少1点能量。
- en: Then we check whether the sheep is out of energy, and if it is, we remove it
    from the `sheepList`. Here, we use a conditional statement to check whether `if
    sheep.energy <= 0` returns `True`. If so, we remove that sheep from the `sheepList`
    using the `remove()` function. Once that `Sheep` instance is gone from the list,
    it doesn’t exist anymore.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查羊是否能量耗尽，如果是，就将其从`sheepList`中移除。在这里，我们使用一个条件语句来检查`if sheep.energy <= 0`是否返回`True`。如果是，我们使用`remove()`函数从`sheepList`中移除那只羊。一旦那只`Sheep`实例被移除，它就不再存在。
- en: CREATING GRASS USING CLASSES
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用类创建草
- en: When you run the program, you should see the `Sheep` move around for a second
    and then disappear—walking around is costing the sheep energy, and once that energy
    is gone, the sheep dies. What we need to do is to give the sheep grass to eat.
    We’ll call each patch of grass `Grass` and make a new class for it. `Grass` will
    have its own x- and y-value, size, and energy content. We’ll also make it change
    color when it’s eaten.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该会看到`Sheep`走动一会儿然后消失——走动会消耗羊的能量，一旦能量用尽，羊就会死掉。我们需要做的是给羊提供草让它们吃。我们将每片草称为`Grass`并为其创建一个新类。`Grass`将具有自己的x、y坐标、大小和能量含量。我们还会让它在被吃掉时改变颜色。
- en: In fact, we’ll be using a bunch of different colors in this sketch for our sheep
    and our grass, so let’s add the code in [Listing 9-16](ch09.xhtml#ch09list16)
    to the very beginning of the program so we can just refer to the colors by their
    names. Feel free to add other colors too.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在这个草图中，我们将使用许多不同的颜色来表示羊和草，所以让我们将[清单 9-16](ch09.xhtml#ch09list16)中的代码添加到程序的最开始，这样我们就可以通过颜色名称来引用它们。如果你想，也可以添加其他颜色。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 9-16: Setting colors as constants*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-16：将颜色设置为常量*'
- en: 'Using all-caps for the color names indicates that they’re constants and won’t
    change in value, but that’s just for the programmer. There’s nothing inherently
    magical about the constants, and you can change these values if you want. Setting
    constants lets you just type the names of the colors instead of having to write
    the RGB values every time. We’ll do this when we make the grass green. Update
    your existing code by adding the code in [Listing 9-17](ch09.xhtml#ch09list17)
    right after the `Sheep` class in *SheepAndGrass.pyde*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全大写的颜色名称表示它们是常量，不会改变值，但这只是对程序员而言。常量本身并没有什么魔力，如果你愿意，可以更改这些值。设置常量的好处是你可以直接使用颜色名称，而不必每次都写RGB值。我们将在让草变绿时做这个更新。通过在*SheepAndGrass.pyde*中将[清单
    9-17](ch09.xhtml#ch09list17)中的代码添加到`Sheep`类之后来更新你现有的代码：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 9-17: Writing the `Grass` class*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-17：编写`Grass`类*'
- en: You’re probably starting to get used to the structure of the class notation.
    It conventionally starts with the `__init__` method, where you create its properties.
    In this case, you tell the program that `Grass` will have an x- and y-location,
    an energy level, a Boolean (`True`/`False`) variable that keeps track of whether
    the grass has been eaten or not, and a size. To update a patch of grass, we just
    create a green rectangle at the `Grass` object’s location.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经开始习惯类的结构了。它通常从`__init__`方法开始，在这个方法中你会创建它的属性。在这种情况下，你告诉程序`Grass`将有一个x和y位置，一个能量级别，一个布尔值（`True`/`False`）变量用于跟踪草地是否被吃掉了，还有一个大小。要更新一块草地，我们只需在`Grass`对象的位置创建一个绿色矩形。
- en: Now we have to initialize and update our grass, the same way we did for our
    sheep. Because there will be a lot of grass, let’s create a list for it. Before
    the `setup()` function, add the following code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要像处理羊一样初始化和更新草地。因为草地数量会很多，所以我们可以为草地创建一个列表。在`setup()`函数之前，添加以下代码。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We might want to vary the size of the patch of grass in the future, so let’s
    create a variable called `patchSize` so we’ll only have to change it in one place.
    In the `setup()` function, after creating the sheep, create the grass by adding
    the new code in [Listing 9-18](ch09.xhtml#ch09list18).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望将来改变草地的大小，因此我们创建一个名为`patchSize`的变量，这样我们只需在一个地方修改它即可。在`setup()`函数中，创建羊之后，添加新代码来创建草地，具体见[清单9-18](ch09.xhtml#ch09list18)。
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 9-18: Updating the `Grass` object using `patchSize` variable*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-18：使用`patchSize`变量更新`Grass`对象*'
- en: In this example, `global patchSize` tells Python that we’re using the same `patchSize`
    variable everywhere. Then we write two `for` loops (one for x and the other for
    y) to append `Grass` to the grass list so we can create a square grid of grass.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`global patchSize`告诉Python我们在所有地方使用相同的`patchSize`变量。然后我们写两个`for`循环（一个用于x，另一个用于y），将`Grass`添加到草地列表中，这样我们就可以创建一个方形的草地网格。
- en: Then we update everything in the `draw()` function, just like we did for the
    sheep. Whatever is drawn first will be drawn covered up by what’s drawn after,
    so we’ll update the grass first by changing the `draw()` function to the code
    in [Listing 9-19](ch09.xhtml#ch09list19).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像处理羊一样，在`draw()`函数中更新所有内容。无论先绘制什么，都会被后绘制的内容覆盖，因此我们会首先更新草地，通过将`draw()`函数改为[清单9-19](ch09.xhtml#ch09list19)中的代码。
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 9-19: Updating the grass before the sheep*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-19：在羊之前更新草地*'
- en: When you run this code, you should see a grid of green squares, like in [Figure
    9-7](ch09.xhtml#ch09fig7).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该能看到一个绿色方块的网格，就像在[图9-7](ch09.xhtml#ch09fig7)中一样。
- en: '![image](../images/f192-01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f192-01.jpg)'
- en: '*Figure 9-7: Grass with grid lines*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-7：带有网格线的草地*'
- en: 'Let’s shut off the black outline so it’ll look like a smooth field of grass.
    Add `noStroke()` to the `setup()` function to remove the outline of the green
    squares:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关闭黑色轮廓，这样看起来就像是一片平滑的草地。在`setup()`函数中添加`noStroke()`，以去掉绿色方块的轮廓：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we have our grass!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有草地了！
- en: MAKING THE GRASS BROWN WHEN EATEN
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让草地在被吃掉时变成棕色
- en: 'How do we make it so that when a sheep is on a patch of grass, the sheep gets
    the grass’s energy and the patch of grass turns brown to show that the sheep has
    eaten it? Change the `update()` method for `Grass` by adding the following lines
    of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何让羊在站在草地上时获取草地的能量，并且草地变成棕色，表示羊已经吃掉了它呢？通过添加以下代码行来修改`Grass`的`update()`方法：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code tells Processing that if the patch of grass is “eaten,” the rectangle
    should be filled with a brown color. Otherwise, the grass should be colored green.
    There’s more than one way for a sheep to “eat” grass. One way is to make each
    patch of grass check the entire `sheepList` for a sheep on its location, which
    could mean tens of thousands of patches are checking thousands of sheep. Those
    numbers could get big. However, because each patch of grass is in the `grassList`,
    an alternate way is that when a sheep changes its location, it could simply change
    the patch at that location to “eaten” (if it isn’t already) and get energy from
    eating it. That would mean a lot less checking.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉Processing，如果草地被“吃掉”，矩形应该填充为棕色。否则，草地应该是绿色的。羊吃草的方式有不止一种。 一种方法是让每块草地检查整个`sheepList`，看是否有羊在其位置上，这可能意味着成千上万块草地在检查成千上万只羊。这些数字可能会很大。然而，由于每块草地都在`grassList`中，另一种方法是，当羊改变位置时，它可以简单地将该位置的草地标记为“已吃”（如果它还没被吃过的话），并从吃草中获得能量。这意味着会少做很多检查。
- en: The problem is that the x- and y-coordinates of the sheep don’t exactly match
    up to where the patches of grass are in the `grassList`. For example, our `patchSize`
    is 10, meaning that if a sheep is at (92,35), it’ll be on the 10th patch to the
    right and the 4th patch down (because the “first” patch is from x = 0 to x = 9).
    We’re dividing by the `patchSize` to get the “scaled” x- and y-values, 9 and 3.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，羊的x、y坐标与草地区域在`grassList`中的位置并不完全匹配。例如，我们的`patchSize`是10，这意味着如果一只羊在(92,35)的位置，它会在右侧第10个草地区域和下方第4个草地区域（因为“第一个”区域是从x
    = 0到x = 9）。我们通过除以`patchSize`来获取“缩放后的”x、y值，即9和3。
- en: 'However, the `grassList` doesn’t have rows and columns. We do know that the
    x-value, 9, means it’s the 10th row (don’t forget row 0), so we’ll just have to
    add in nine rows of 60 (the height divided by the `patchSize`) and then add the
    y-value to get the index of the patch of grass the sheep is on. Therefore, we
    need a variable to tell us how many patches of grass there are in a row, which
    we’ll call `rows_of_grass`. Add `global rows_of_grass` to the beginning of the
    `setup()` function and then add this line to `setup()` after declaring the size:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`grassList`没有行和列。我们知道x值为9，意味着它是第10行（别忘了行0），所以我们只需要加上9行60（高度除以`patchSize`），然后再加上y值来获得羊所在草地区域的索引。因此，我们需要一个变量来告诉我们每行有多少个草地区域，我们将其命名为`rows_of_grass`。将`global
    rows_of_grass`添加到`setup()`函数的开头，然后在声明大小之后，将此行代码添加到`setup()`中：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This takes the width of the display window and divides it by the size of the
    patches of grass to tell us how many columns of grass there are. The code to add
    to the `Sheep` class is in [Listing 9-20](ch09.xhtml#ch09list20).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码计算显示窗口的宽度，并将其除以草地区域的大小，以告诉我们有多少列草地。添加到`Sheep`类中的代码见[清单9-20](ch09.xhtml#ch09list20)。
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 9-20: Updating the sheep’s energy level and turning the grass brown*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-20：更新羊的能量水平并将草地变成棕色*'
- en: After updating the sheep’s location, we “wrap” the coordinates ➊ so if the sheep
    walks off the screen in one direction, it shows up on the other side of the screen,
    like in the video game *Asteroids*. We calculate which patch the sheep is on according
    to the `patchSize` ➋. Then we use code to go from x- and y-values to the index
    of that patch in the `grassList` ➌. We now know the exact index of the patch of
    grass the sheep is on. If this patch of grass is not already eaten, the sheep
    eats it! It gets the energy from the grass, and the grass’s `eaten` property is
    set to `True`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更新羊的位置后，我们将坐标“包装” ➊，这样如果羊在某一方向走出屏幕，它会出现在屏幕的另一边，就像视频游戏《*小行星*》中那样。我们根据`patchSize`
    ➋计算羊所在的草地区域。然后，我们使用代码将x、y值转换为该区域在`grassList`中的索引 ➌。现在我们知道羊所处的草地区域的确切索引。如果这块草地还没有被吃掉，羊就会吃掉它！它从草地中获取能量，草地的`eaten`属性被设置为`True`。
- en: Run this code, and you’ll see the three sheep running around eating grass, which
    turns brown once it’s eaten. Slow the sheep down by changing the `move` variable
    to a lesser value, such as 5\. You can also scale down the patches by changing
    one number, the `patchSize` variable, to 5\. Try other values if you like.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你会看到三只羊四处奔跑，吃掉草地，而草地一旦被吃掉就会变成棕色。通过将`move`变量改为较小的值（比如5）来减慢羊的速度。你也可以通过修改`patchSize`变量将草地区域缩小到5。你可以尝试其他值。
- en: 'Now we can create more `Sheep`. Let’s change the number in the `for i in range
    line` to 20, like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建更多的`Sheep`了。让我们将`for i in range`行中的数字改为20，像这样：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you run this code, you should see something like [Figure 9-8](ch09.xhtml#ch09fig8).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该能看到类似[图9-8](ch09.xhtml#ch09fig8)的内容。
- en: '![image](../images/f194-01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f194-01.jpg)'
- en: '*Figure 9-8: A herd of sheep!*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-8：一群羊！*'
- en: Now there are 20 sheep walking around, leaving patches of brown grass.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有20只羊在四处走动，留下了棕色的草地。
- en: GIVING EACH SHEEP A RANDOM COLOR
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为每只羊指定一个随机颜色
- en: 'Let’s have the sheep choose a color when they’re “born.” After the code defining
    the color constants, let’s put some colors into a color list, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让羊在“出生”时选择一种颜色。在定义颜色常量的代码之后，我们将一些颜色放入一个颜色列表，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Make the following changes to the `Sheep` class to use different colors. First,
    you need to give `Sheep` a color property. Because `color` is already a keyword
    in Processing, `col` is used in [Listing 9-21](ch09.xhtml#ch09list21).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Sheep`类进行以下更改以使用不同的颜色。首先，你需要为`Sheep`添加一个颜色属性。由于`color`在Processing中已经是一个关键字，所以在[清单9-21](ch09.xhtml#ch09list21)中使用了`col`。
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 9-21: Adding a color property to the `Sheep` class*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-21：为`Sheep`类添加颜色属性*'
- en: 'Then in the `update()` method, replace the fill line with this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Before the ellipse is drawn, `fill(self.col)` tells Processing to fill the ellipse
    with the `Sheep`’s own randomly chosen color.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'When all the `Sheep` are instantiated in the `setup()` function, you need to
    give them a random color. That means at the top of the program you have to import
    the `choice()` function from the `random` module, like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Python’s `choice()` function allows you to have one item chosen at random from
    a list and then returned. We should be able to tell the program to do this as
    follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now the program will return a single value from the color list. Finally, when
    you’re creating the `Sheep`, add the random choice of color from the color list
    as one of the arguments you pass to the `Sheep` constructor, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now when you run this code, you should see a bunch of randomly colored sheep
    walking around the screen, as shown in [Figure 9-9](ch09.xhtml#ch09fig9).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f196-01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: Multicolored sheep*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Each new sheep gets assigned one of the four colors we defined in `colorList`:
    white, red, yellow, or purple.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: PROGRAMMING SHEEP TO REPRODUCE
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, in our current program the sheep eat the grass until they wander
    too far away from the grass, run out of energy, and die. To prevent this, let’s
    tell the sheep to use some of that energy to reproduce.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the code in [Listing 9-22](ch09.xhtml#ch09list22) to tell the sheep
    to reproduce if their energy level reaches 50.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 9-22: Adding a conditional for sheep to reproduce*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The conditional `if self.energy >= 50:` checks whether that sheep’s energy is
    greater than or equal to 50\. If it is, we decrement the energy level by 30 for
    birthing and add another sheep to the sheep list. Notice that the new sheep is
    at the same location and is the same color as its parent. Run this code, and you
    should see the sheep reproduce, like in [Figure 9-10](ch09.xhtml#ch09fig10).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f197-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: Sheep eating grass and reproducing*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Soon you should see what looks like tribes of similarly colored sheep.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: LETTING THE GRASS REGROW
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, the sheep soon eat up all the grass in their area and die (probably
    a lesson in there somewhere). We need to allow our grass to regrow. To do this,
    change the `Grass`’s `update()` method to this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Processing code `random(100)` generates a random number between 0 and 100\.
    If the number is less than 5, we regrow a patch of grass by setting its `eaten`
    property to `False`. We use the number 5 because this gives us a probability of
    5/100 that eaten grass will regrow during each frame. Otherwise, it stays brown.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Run the code, and you should see something like [Figure 9-11](ch09.xhtml#ch09fig11).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f198-01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: The grass regrows and the sheep populate the whole screen!*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might get so many sheep that the program starts to slow down! This
    could be because the sheep have too much energy. If so, try reducing the amount
    of energy each patch of grass contains from 5 to 2:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That seems to be a good balance that lets the sheep population grow at a reasonable
    pace. Play around with the numbers all you want—it’s your world!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: PROVIDING AN EVOLUTIONARY ADVANTAGE
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s give one of the sheep groups an advantage. You can choose any advantage
    you can think of (getting more energy from grass or producing more offspring at
    a time, for instance). For this example, we’re going to let the purple sheep walk
    a little further than the others. Will that make any difference? To find out,
    make the `Sheep`’s `update()` method match the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This conditional checks whether the `Sheep`’s color is purple. If so, it sets
    the `Sheep`’s `move` value to 7\. Otherwise, it leaves the value at 5\. This allows the
    purple sheep to travel further, and therefore more likely to find green patches,
    than the other sheep. Let’s run the code and check the outcome, which should look
    like [Figure 9-12](ch09.xhtml#ch09fig12).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f199-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-12: Giving purple sheep an advantage*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: After a little while it sure looks like that tiny advantage paid off for the
    purple sheep. They’re dominating the environment and pushing out all the other
    sheep just by competing for grass. This simulation could spark interesting discussions
    about ecology, invasive species, biodiversity, and evolution.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 9-2: SETTING SHEEP LIFESPAN'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Create an “age” property and decrease it every time the sheep update so they
    live for only a limited amount of time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 9-3: CHANGING SHEEP SIZE'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Vary the size of the sheep according to their energy level.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: SUMMARY
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make objects using classes, which involved
    defining the class using properties and then instantiating (“creating”) and updating
    the object. This let you create multiple similar-but-independent objects with
    the same properties more efficiently. The more you use classes, the more creative
    you can get by making autonomous objects walk, fly, or bounce around without your
    having to code every step!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use classes supercharges your coding abilities. Now you can create
    models of complicated situations easily, and once you tell the program what to
    do with one particle, or planet, or sheep, it’ll be able to make a dozen, a hundred,
    or even a million of them very easily!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You also got a taste of setting up models to explore physical, biological, chemical,
    or environmental situations with very few equations! A physicist once told me
    that’s often the most efficient method for solving problems involving many factors,
    or “agents.” You set up a computer model, let it run, and look at the results.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to create fractals using an almost-magical
    phenomenon called recursion.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
