- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BUILDING OBJECTS WITH CLASSES
  prefs: []
  type: TYPE_NORMAL
- en: '*Old teachers never die, they just lose their class.'
  prefs: []
  type: TYPE_NORMAL
- en: —Anonymous*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve created cool graphics using functions and other code in Processing,
    you can supercharge your creativity using classes. A *class* is a structure that
    lets you create new types of objects. The object types (usually just called *objects*)
    can have *properties*, which are variables, and *methods*, which are functions.
    There are times you want to draw multiple objects using Python, but drawing lots
    of them would be way too much work. Classes make drawing several objects with
    the same properties easy, but they require a specific syntax you’ll need to learn.
  prefs: []
  type: TYPE_NORMAL
- en: The following example from the official Python website shows how to create a
    “Dog” object using a class. To code along, open a new file in IDLE, name it *dog.py*
    and enter the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '*dog.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Dog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: This creates a new object called Dog using class Dog. It’s customary in Python
    and many other languages to capitalize the name of a class, but it’ll still work
    if you don’t. To instantiate, or create, the class, we have to use Python’s __init__
    method, which has two underscores before and two after init, meaning it’s a special
    method to create (or *construct*) an object. The __init__ line makes it possible
    to create instances of the class (in this case, dogs). In the __init__ method,
    we can create any properties of the class we want. Since it’s a dog, it can have
    a name, and because every dog has its own name, we use the self syntax. We don’t
    need to use it when we call the objects, only when we’re defining them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create a dog with a name using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: d = Dog('Fido')
  prefs: []
  type: TYPE_NORMAL
- en: 'Now d is a Dog and its name is Fido. You can confirm this by running the file
    and entering the following in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.name'
  prefs: []
  type: TYPE_NORMAL
- en: '''Fido'''
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we call d.name, we get Fido because that is the name property we just
    gave to it. We can create another Dog and give it the name Bettisa, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = Dog(''Bettisa'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b.name'
  prefs: []
  type: TYPE_NORMAL
- en: '''Bettisa'''
  prefs: []
  type: TYPE_NORMAL
- en: You can see one dog’s name can be different from another’s, but the program
    remembers them perfectly! This will be crucial when we give locations and other
    properties to the objects we create.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can give the dog something to do by putting a function in the class.
    But don’t call it a function! A function inside a class is called a *method*.
    Dogs bark, so we’ll add that method to the code in [Listing 9-1](ch09.xhtml#ch09list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*dog.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Dog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: 'def bark(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Woof!")
  prefs: []
  type: TYPE_NORMAL
- en: d = Dog('Fido')
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-1: Creating a dog that barks!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the bark() method of the d dog, it barks:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.bark()'
  prefs: []
  type: TYPE_NORMAL
- en: Woof!
  prefs: []
  type: TYPE_NORMAL
- en: It might not be clear why you’d need a Dog class from this simple example, but
    it’s good to know you can do literally anything you want with classes and be as
    creative as you want. In this chapter, we use classes to make lots of useful objects
    like bouncing balls and grazing sheep. Let’s start with the Bouncing Ball example
    to see how using classes lets us do something really cool while saving us a lot
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: BOUNCING BALL PROGRAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start a Processing sketch and save it as *BouncingBall.pyde*. We’ll draw a single
    circle on the screen, which we’ll make into a bouncing ball. [Listing 9-2](ch09.xhtml#ch09list2)
    shows the code for drawing one circle.
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: 'background(0) #black'
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(300,300,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-2: Drawing a circle*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set the size of the window to be 600 pixels wide and 600 pixels tall.
    Then we set the background to black and drew a circle using the ellipse() function.
    The first two numbers in the function describe how far the center of the circle
    is from the top-left corner of the window, and the last two numbers describe the
    width and height of the ellipse. In this case, ellipse(300,300, 20,20) creates
    a circle that is 20 pixels wide and 20 pixels high, located in the center of the
    display window, as shown in [Figure 9-1](ch09.xhtml#ch09fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f177-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Drawing one circle for the Bouncing Ball sketch*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully created a circle located in the center of the
    display window, let’s try to make it move.
  prefs: []
  type: TYPE_NORMAL
- en: '#### MAKING THE BALL MOVE'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make the ball move by changing its position. To do this, let’s first create
    a variable for the x-value and a variable for the y-value and set them to 300,
    which is the middle of the screen. Go back to [Listing 9-2](ch09.xhtml#ch09list2)
    and insert the following two lines at the beginning of the code, like in [Listing
    9-3](ch09.xhtml#ch09list3).
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: xcor = 300
  prefs: []
  type: TYPE_NORMAL
- en: ycor = 300
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-3: Setting variables for the x- and y-values*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use the xcor variable to represent the x-value and the ycor variable
    to represent the y-value. Then we set both variables to 300.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s change the x-value and y-value by a certain number in order to change
    the location of the ellipse. Make sure to use the variables to draw the ellipse,
    as shown in [Listing 9-4](ch09.xhtml#ch09list4).
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: xcor = 300
  prefs: []
  type: TYPE_NORMAL
- en: ycor = 300
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ global xcor, ycor
  prefs: []
  type: TYPE_NORMAL
- en: 'background(0) #black'
  prefs: []
  type: TYPE_NORMAL
- en: xcor += 1
  prefs: []
  type: TYPE_NORMAL
- en: ycor += 1
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(xcor,ycor,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-4: Incrementing xcor and ycor to change the location of the ellipse*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing to notice in this example is global xcor, ycor ➊, which
    tells Python to use the variables we’ve already created and not to create new
    ones just for the draw() function. If you don’t include this line, you’ll get
    an error message, something like “local variable ‘xcor’ referenced before assignment.”
    Once Processing knows what value to assign to xcor and ycor, we increment them
    both by 1 and draw the ellipse with its center at the location specified using
    the global variables: (xcor, ycor).'
  prefs: []
  type: TYPE_NORMAL
- en: When you save and run [Listing 9-4](ch09.xhtml#ch09list4), you should see the
    ball move, like in [Figure 9-2](ch09.xhtml#ch09fig2).
  prefs: []
  type: TYPE_NORMAL
- en: Now the ball moves down and to the right, because its x- and y-values are both
    increasing, but then it moves off the screen and we never see it again! The program
    keeps incrementing our variables obediently. It doesn’t know it’s drawing a ball
    or that we want the ball to bounce off the walls. Let’s explore how to keep the
    ball from disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f179-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: The ball moves!*'
  prefs: []
  type: TYPE_NORMAL
- en: MAKING THE BALL BOUNCE OFF THE WALL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we change the x-value and the y-value by adding 1, we’re changing the position
    of an object. In math, this change in position over time is called *velocity*.
    A positive change in x over time (positive x-velocity) will look like movement
    to the right (since x is getting bigger), whereas negative x-velocity will look
    like movement to the left. We can use this “positive-right, negative-left” concept
    to make the ball bounce off the wall. First, let’s create the x-velocity and y-velocity
    variables by adding the following lines to our existing code, as shown in [Listing
    9-5](ch09.xhtml#ch09list5).
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: xcor = 300
  prefs: []
  type: TYPE_NORMAL
- en: ycor = 300
  prefs: []
  type: TYPE_NORMAL
- en: xvel = 1
  prefs: []
  type: TYPE_NORMAL
- en: yvel = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: global xcor,ycor,xvel,yvel
  prefs: []
  type: TYPE_NORMAL
- en: 'background(0) #black'
  prefs: []
  type: TYPE_NORMAL
- en: xcor += xvel
  prefs: []
  type: TYPE_NORMAL
- en: ycor += yvel
  prefs: []
  type: TYPE_NORMAL
- en: '#if the ball reaches a wall, switch direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'if xcor > width or xcor < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: xvel = -xvel
  prefs: []
  type: TYPE_NORMAL
- en: 'if ycor > height or ycor < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: yvel = -yvel
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(xcor,ycor,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-5: Adding code to make the ball bounce off the wall*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set xvel = 1 and yvel = 2 to specify how the ball will move. You can
    use other values and see how they change the movement. Then in the draw() function,
    we tell Python that xvel and yvel are global variables, and we change the x- and
    y-coordinates by incrementing using these variables. For example, when we set
    xcor += xvel, we’re updating the position by the velocity (the *change* in position).
  prefs: []
  type: TYPE_NORMAL
- en: The two if statements tell the program that if the ball’s position goes outside
    the boundaries of the screen, it should change the ball’s velocity to its negative
    value. When we change the ball’s velocity to its negative value, we tell the program
    to move the ball in the opposite direction it was moving in, making it seem like
    the ball is bouncing off the wall.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be precise in telling at what point the ball should move in the opposite
    direction in terms of its coordinates. For example, xcor > width represents cases
    where xcor is larger than the width of the display window, which is when the ball
    touches the right edge of the screen. And xcor < 0 represents instances where
    the xcor is less than 0 or when the ball touches the left edge of the screen.
    Similarly, ycor > height checks for instances where ycor is larger than the height
    of the window or when the ball reaches the bottom of the screen. Finally, ycor
    < 0 checks for instances where the ball reaches the upper edge of the screen.
    Since moving to the right is positive x-velocity (positive change in x), the opposite
    direction is negative x-velocity. If the velocity is already negative (it’s moving
    to the left), then the negative of a negative is a positive, which means the ball
    will move to the right, just like we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: When you run [Listing 9-5](ch09.xhtml#ch09list5), you should see something like
    what’s shown in [Figure 9-3](ch09.xhtml#ch09fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f180-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: One bouncing ball!*'
  prefs: []
  type: TYPE_NORMAL
- en: The ball looks like it’s bouncing off the walls and therefore stays in view.
  prefs: []
  type: TYPE_NORMAL
- en: '#### MAKING MULTIPLE BALLS WITHOUT CLASSES'
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose we want to make another bouncing ball, or many other bouncing balls.
    How would we do that? We could make a new variable for the second ball’s x-value,
    another variable for the second ball’s y-value, a third variable for its x-velocity,
    and a fourth for its y-velocity. Then we’d have to increment its position by its
    velocity, check if it needs to bounce off a wall, and finally draw it. However,
    we’d end up with double the amount of code! Adding a third ball would triple our
    code! Twenty balls would simply be out of the question. You *don’t* want to have
    to keep track of all these variables for position and velocity. [Listing 9-6](ch09.xhtml#ch09list6)
    show what this would look like.
  prefs: []
  type: TYPE_NORMAL
- en: '#ball1:'
  prefs: []
  type: TYPE_NORMAL
- en: ball1x = random(width)
  prefs: []
  type: TYPE_NORMAL
- en: ball1y = random(height)
  prefs: []
  type: TYPE_NORMAL
- en: ball1xvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: ball1tvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: '#ball2:'
  prefs: []
  type: TYPE_NORMAL
- en: ball2x = random(width)
  prefs: []
  type: TYPE_NORMAL
- en: ball2y = random(height)
  prefs: []
  type: TYPE_NORMAL
- en: ball2xvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: ball2tvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: '#ball3:'
  prefs: []
  type: TYPE_NORMAL
- en: ball3x = random(width)
  prefs: []
  type: TYPE_NORMAL
- en: ball3y = random(height)
  prefs: []
  type: TYPE_NORMAL
- en: ball3xvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: ball3tvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: '#update ball1:'
  prefs: []
  type: TYPE_NORMAL
- en: ball1x += ball1xvel
  prefs: []
  type: TYPE_NORMAL
- en: ball1y += ball1yvel
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(ball1x,ball1y,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '#update ball2:'
  prefs: []
  type: TYPE_NORMAL
- en: ball2x += ball2xvel
  prefs: []
  type: TYPE_NORMAL
- en: ball2y += ball2yvel
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(ball2x,ball2y,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '#update ball3:'
  prefs: []
  type: TYPE_NORMAL
- en: ball3x += ball3xvel
  prefs: []
  type: TYPE_NORMAL
- en: ball3y += ball3yvel
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(ball3x,ball3y,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-6: Creating multiple balls without classes. Way too much code!*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the code for creating only three balls. As you can see, it’s very long,
    and this doesn’t even include the bouncing part! Let’s see how we can use classes
    to make this task easier.
  prefs: []
  type: TYPE_NORMAL
- en: '#### CREATING OBJECTS USING CLASSES'
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a class works like a recipe that details a way to create an
    object with its own specific properties. Using classes, we tell Python how to
    make a ball once. Then all we have to do is create a bunch of balls using a for
    loop and put them in a list. Lists are great for saving numerous things—strings,
    numbers, and objects!
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these three steps when using classes to create objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write the class*. This is like a recipe for how to make balls, planets, rockets,
    and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Instantiate the object or objects*. You do this by calling the objects in
    the setup() function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Update the object or objects*. Do this in the draw() function (the display
    loop).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s use these steps to put the code we’ve already written into a class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first step in creating objects using classes is to write a class that tells
    the program how to make a ball. Let’s add the code in [Listing 9-7](ch09.xhtml#ch09list7)
    at the very beginning of our existing program.
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'ballList=[] #empty list to put the balls in'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Ball:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''How to initialize a Ball'''''''
  prefs: []
  type: TYPE_NORMAL
- en: self.xcor = x
  prefs: []
  type: TYPE_NORMAL
- en: self.ycor = y
  prefs: []
  type: TYPE_NORMAL
- en: self.xvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: self.yvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-7: Defining a class called Ball*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that because we’re putting the position and velocity variables into the
    Ball class as properties, you can delete the following lines from your existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: xcor = 300
  prefs: []
  type: TYPE_NORMAL
- en: ycor = 300
  prefs: []
  type: TYPE_NORMAL
- en: xvel = 1
  prefs: []
  type: TYPE_NORMAL
- en: yvel = 2
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 9-7](ch09.xhtml#ch09list7), we create an empty list we’ll use to
    save the balls in; then we start defining the recipe. The name of a class object,
    which is Ball in this case, is always capitalized. The __init__ method is a requirement
    to create a class in Python that contains all the properties the object gets when
    it’s initialized. Otherwise, the class won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The self syntax simply means every object has its own methods and properties,
    which are functions and variables that can’t be used except by a Ball object.
    This means that each Ball has its own xcor, its own ycor, and so on. Because we
    might have to create a Ball at a specific location at some point, we made x and
    y parameters of the __init__ method. Adding these parameters allows us to tell
    Python the location of a Ball when we create it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ball(100,200)
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the ball will be located at the coordinate (100,200).
  prefs: []
  type: TYPE_NORMAL
- en: The last lines in [Listing 9-7](ch09.xhtml#ch09list7) tell Processing to assign
    a random number between –2 and 2 to be the x- and y-velocity of the new ball.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating the Object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve created a class called Ball, we need to tell Processing how to
    update the ball every time the draw() function loops. We’ll call that the update
    method and nest it inside the Ball class, just like we did with __init__. You
    can simply cut and paste all the ball code into the update() method and then add
    self. to each of the object’s properties, as shown in [Listing 9-8](ch09.xhtml#ch09list8).
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'ballList=[] #empty list to put the balls in'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Ball:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''How to initialize a Ball'''''''
  prefs: []
  type: TYPE_NORMAL
- en: self.xcor = x
  prefs: []
  type: TYPE_NORMAL
- en: self.ycor = y
  prefs: []
  type: TYPE_NORMAL
- en: self.xvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: self.yvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.xcor += self.xvel
  prefs: []
  type: TYPE_NORMAL
- en: self.ycor += self.yvel
  prefs: []
  type: TYPE_NORMAL
- en: '#if the ball reaches a wall, switch direction'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.xcor > width or self.xcor < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: self.xvel = -self.xvel
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.ycor > height or self.ycor < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: self.yvel = -self.yvel
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.xcor,self.ycor,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-8: Creating the update() method*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we placed all the code for moving and bouncing a ball into the update()
    method of the Ball class. The only new code is self in the velocity variables,
    making them velocity properties of the Ball object. Although it might seem like
    there are many instances of self, that’s how we tell Python that the x-coordinate,
    for example, belongs to that specific ball and not another. Very soon, Python
    is going to be updating a hundred balls, so we need self to keep track of each
    one’s location and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the program knows how to create and update a ball, let’s update the
    setup() function to create three balls and put them into the ball list (ballList),
    as shown in [Listing 9-9](ch09.xhtml#ch09list9).
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: ballList.append(Ball(random(width),
  prefs: []
  type: TYPE_NORMAL
- en: random(height)))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-9: Creating three balls in the setup() function*'
  prefs: []
  type: TYPE_NORMAL
- en: We created ballList in [Listing 9-7](ch09.xhtml#ch09list7) already, and here
    we’re appending to the list a Ball at a random location. When the program creates
    (instantiates) a new ball, it will now choose a random number between 0 and the
    width of the screen to be the x-coordinate and another random number between 0
    and the height of the screen to be the y-coordinate. Then it’ll put that new ball
    into the list. Because we used the loop for i in range(3), the program will add
    three balls to the ball list.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let’s tell the program to go through ballList and update all the balls
    in the list (which means drawing them) every loop using the following draw() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: 'background(0) #black'
  prefs: []
  type: TYPE_NORMAL
- en: 'for ball in ballList:'
  prefs: []
  type: TYPE_NORMAL
- en: ball.update()
  prefs: []
  type: TYPE_NORMAL
- en: Note that we still want the background to be black, and then we loop over the
    ball list and for every ball in the list we run its update() method. All the previous
    code in draw() went into the Ball class!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f184-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Creating as many bouncing balls as you want!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this sketch, you should see three balls moving around the screen
    and bouncing off the walls! The great thing about using classes is that it’s super
    easy to change the number of balls. All you have to do is change the *number*
    in for i in range(*number*): in the setup() function to create even more bouncing
    balls. When you change this to 20, for example, you’ll see something like [Figure
    9-4](ch09.xhtml#ch09fig4).'
  prefs: []
  type: TYPE_NORMAL
- en: What’s cool about using classes is that you can give an object any properties
    or methods you want. For example, we don’t have to make our balls all the same
    color. Add the three lines of code shown in [Listing 9-10](ch09.xhtml#ch09list10)
    to your existing Ball class.
  prefs: []
  type: TYPE_NORMAL
- en: '*BouncingBall.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Ball:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''How to initialize a Ball'''''''
  prefs: []
  type: TYPE_NORMAL
- en: self.xcor = x
  prefs: []
  type: TYPE_NORMAL
- en: self.ycor = y
  prefs: []
  type: TYPE_NORMAL
- en: self.xvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: self.yvel = random(-2,2)
  prefs: []
  type: TYPE_NORMAL
- en: self.col = color(random(255),
  prefs: []
  type: TYPE_NORMAL
- en: random(255),
  prefs: []
  type: TYPE_NORMAL
- en: random(255))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-10: Updating the Ball class*'
  prefs: []
  type: TYPE_NORMAL
- en: This code gives every ball its own color when it’s created. Processing’s color()
    function needs three numbers that represent red, green, and blue, respectively.
    RGB values go from 0 to 255\. Using random(255) lets the program choose the numbers
    randomly, resulting in a randomly chosen color. However, because the __init__
    method runs only one time, once the ball has a color, it keeps it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the update() method, add the following line so the ellipse gets filled
    with its own randomly chosen color:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(self.col)
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.xcor,self.ycor,20,20)
  prefs: []
  type: TYPE_NORMAL
- en: Before a shape or line gets drawn, you can declare its color using fill for
    shapes or stroke for lines. Here, we tell Processing to use the ball’s own color
    (using self) to fill in the following shape.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run the program, each ball should have a random color, as shown
    in [Figure 9-5](ch09.xhtml#ch09fig5)!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f185-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: Giving balls their own colors*'
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 9-1: CREATING BALLS OF DIFFERENT SIZES'
  prefs: []
  type: TYPE_NORMAL
- en: Give each ball its own size, between 5 and 50 units.
  prefs: []
  type: TYPE_NORMAL
- en: GRAZING SHEEP PROGRAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you can create classes, let’s make something useful. We’ll code a Processing
    sketch of an ecosystem that simulates sheep walking around eating grass. In this
    sketch, the sheep have a certain level of energy that gets depleted as they walk
    around, and their energy gets replenished when they eat grass. If they get enough
    energy, they reproduce. If they don’t get enough energy, they die. We could potentially
    learn a lot about biology, ecology, and evolution by creating and tweaking this
    model.
  prefs: []
  type: TYPE_NORMAL
- en: In this program, the Sheep objects are kind of like the Ball objects you created
    earlier in this chapter; each has its own x- and y-position and size, and is represented
    by a circle.
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE CLASS FOR THE SHEEP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start a new Processing sketch and save it as *SheepAndGrass.pyde*. First, let’s
    create a class that makes a Sheep object with its own x- and y-position and its
    own size. Then we’ll create an update method that draws an ellipse representing
    the sheep’s size at the sheep’s location.
  prefs: []
  type: TYPE_NORMAL
- en: The class code is nearly identical to the Ball class, as you can see in [Listing
    9-11](ch09.xhtml#ch09list11).
  prefs: []
  type: TYPE_NORMAL
- en: '*SheepAndGrass.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Sheep:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.x = x #x-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.y = y #y-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.sz = 10 #size'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-11: Creating a class for one sheep*'
  prefs: []
  type: TYPE_NORMAL
- en: Because we know we’ll be making a bunch of sheep, we start off creating a Sheep
    class. In the required __init__ method, we set the x- and y-coordinates of the
    sheep to the parameters we’ll declare when creating a sheep instance. I’ve set
    the size of the sheep (the diameter of the ellipse) to 10 pixels, but you can
    have bigger or smaller sheep if you like. The update() method simply draws an
    ellipse of the sheep’s size at the sheep’s location.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the setup() and draw() code for a Processing sketch containing one Sheep,
    which I’ve named shawn. Add the code shown in [Listing 9-12](ch09.xhtml#ch09list12)
    right below the update() method you just wrote in [Listing 9-11](ch09.xhtml#ch09list11).
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: global shawn
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: '#create a Sheep object called shawn at (300,200)'
  prefs: []
  type: TYPE_NORMAL
- en: shawn = Sheep(300,200)
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  prefs: []
  type: TYPE_NORMAL
- en: shawn.update()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-12: Creating a Sheep object named shawn*'
  prefs: []
  type: TYPE_NORMAL
- en: We first create shawn, an instance of a Sheep object, in the setup() function.
    Then we update it in the draw() function—but Python doesn’t know we mean the same
    shawn unless we tell it that shawn is a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you should see something like what’s shown in [Figure
    9-6](ch09.xhtml#ch09fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f187-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: One sheep*'
  prefs: []
  type: TYPE_NORMAL
- en: You get a white screen with a little circular sheep at the coordinate (300,200),
    which is 300 pixels to the right of the starting point and 200 pixels down.
  prefs: []
  type: TYPE_NORMAL
- en: PROGRAMMING SHEEP TO MOVE AROUND
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s teach a Sheep how to move around. We’ll start by programming the
    Sheep to move around randomly. (You can always program it to move differently
    in the future if you want to.) [Listing 9-13](ch09.xhtml#ch09list13) changes the
    x- and y-coordinates of a Sheep by a random number between –10 and 10\. Return
    to your existing code and add the following lines above the ellipse() function
    within the update() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SheepAndGrass.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '#make sheep walk randomly'
  prefs: []
  type: TYPE_NORMAL
- en: 'move = 10 #the maximum it can move in any direction'
  prefs: []
  type: TYPE_NORMAL
- en: self.x += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: self.y += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(255) #white'
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-13: Making the sheep move randomly*'
  prefs: []
  type: TYPE_NORMAL
- en: This code creates a variable called move to specify the maximum value or distance
    the sheep will be able to move on the screen. Then we set move to 10 and use it
    to update the sheep’s x- and y-coordinates by a random number between -move (–10)
    and move (10). Finally, we use fill(255) to set the sheep’s color to white for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you should see the sheep wandering around randomly—and
    it might wander off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s give the sheep some company. If we want to create and update more than
    one object, it’s a good idea to put them in a list. Then in the draw() function,
    we’ll go through the list and update each Sheep. Update your existing code to
    look like [Listing 9-14](ch09.xhtml#ch09list14).
  prefs: []
  type: TYPE_NORMAL
- en: '*SheepAndGrass.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Sheep:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.x = x #x-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.y = y #y-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.sz = 10 #size'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '#make sheep walk randomly'
  prefs: []
  type: TYPE_NORMAL
- en: 'move = 10 #the maximum it can move in any direction'
  prefs: []
  type: TYPE_NORMAL
- en: self.x += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: self.y += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(255) #white'
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: 'sheepList = [] #list to store sheep'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.append(Sheep(random(width),
  prefs: []
  type: TYPE_NORMAL
- en: random(height)))
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  prefs: []
  type: TYPE_NORMAL
- en: 'for sheep in sheepList:'
  prefs: []
  type: TYPE_NORMAL
- en: sheep.update()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-14: Creating more sheep using a for loop*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is similar to the code we wrote to put the bouncing balls in a list.
    First, we create a list to store the sheep. Then we create a for loop and put
    a Sheep in the sheep list. Then in the draw() function, we write another for loop
    to go through the sheep list and update each one according to the update() method
    we already defined. When you run this code, you should get three Sheep walking
    around randomly. Change the number 3 in for i in range(3): to a larger number
    to add even more sheep.'
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE ENERGY PROPERTY
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Walking takes up energy! Let’s give the sheep a certain level of energy when
    they’re created and take away their energy when they walk. Use the code in [Listing
    9-15](ch09.xhtml#ch09list15) to update your existing __init__ and update() methods
    in the *SheepAndGrass.pyde*.
  prefs: []
  type: TYPE_NORMAL
- en: 'class Sheep:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.x = x #x-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.y = y #y-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.sz = 10 #size'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.energy = 20 #energy level'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '#make sheep walk randomly'
  prefs: []
  type: TYPE_NORMAL
- en: move = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'self.energy -= 1 #walking costs energy'
  prefs: []
  type: TYPE_NORMAL
- en: 'if sheep.energy <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.remove(self)
  prefs: []
  type: TYPE_NORMAL
- en: self.x += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: self.y += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(255) #white'
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-15: Updating __init__ and update() with the energy property*'
  prefs: []
  type: TYPE_NORMAL
- en: We do this by creating an energy property in the __init__ method and set it
    to 20, the energy level every sheep starts with. Then self.energy -= 1 in the
    update() method lowers the sheep’s energy level by 1 when it walks around.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check whether the sheep is out of energy, and if it is, we remove it
    from the sheepList. Here, we use a conditional statement to check whether if sheep.energy
    <= 0 returns True. If so, we remove that sheep from the sheepList using the remove()
    function. Once that Sheep instance is gone from the list, it doesn’t exist anymore.
  prefs: []
  type: TYPE_NORMAL
- en: CREATING GRASS USING CLASSES
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you run the program, you should see the Sheep move around for a second
    and then disappear—walking around is costing the sheep energy, and once that energy
    is gone, the sheep dies. What we need to do is to give the sheep grass to eat.
    We’ll call each patch of grass Grass and make a new class for it. Grass will have
    its own x- and y-value, size, and energy content. We’ll also make it change color
    when it’s eaten.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we’ll be using a bunch of different colors in this sketch for our sheep
    and our grass, so let’s add the code in [Listing 9-16](ch09.xhtml#ch09list16)
    to the very beginning of the program so we can just refer to the colors by their
    names. Feel free to add other colors too.
  prefs: []
  type: TYPE_NORMAL
- en: WHITE = color(255)
  prefs: []
  type: TYPE_NORMAL
- en: BROWN = color(102,51,0)
  prefs: []
  type: TYPE_NORMAL
- en: RED = color(255,0,0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = color(0,102,0)
  prefs: []
  type: TYPE_NORMAL
- en: YELLOW = color(255,255,0)
  prefs: []
  type: TYPE_NORMAL
- en: PURPLE = color(102,0,204)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-16: Setting colors as constants*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using all-caps for the color names indicates that they’re constants and won’t
    change in value, but that’s just for the programmer. There’s nothing inherently
    magical about the constants, and you can change these values if you want. Setting
    constants lets you just type the names of the colors instead of having to write
    the RGB values every time. We’ll do this when we make the grass green. Update
    your existing code by adding the code in [Listing 9-17](ch09.xhtml#ch09list17)
    right after the Sheep class in *SheepAndGrass.pyde*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Grass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y,sz):'
  prefs: []
  type: TYPE_NORMAL
- en: self.x = x
  prefs: []
  type: TYPE_NORMAL
- en: self.y = y
  prefs: []
  type: TYPE_NORMAL
- en: 'self.energy = 5 #energy from eating this patch'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.eaten = False #hasn''t been eaten yet'
  prefs: []
  type: TYPE_NORMAL
- en: self.sz = sz
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: fill(GREEN)
  prefs: []
  type: TYPE_NORMAL
- en: rect(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-17: Writing the Grass class*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re probably starting to get used to the structure of the class notation.
    It conventionally starts with the __init__ method, where you create its properties.
    In this case, you tell the program that Grass will have an x- and y-location,
    an energy level, a Boolean (True/False) variable that keeps track of whether the
    grass has been eaten or not, and a size. To update a patch of grass, we just create
    a green rectangle at the Grass object’s location.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to initialize and update our grass, the same way we did for our
    sheep. Because there will be a lot of grass, let’s create a list for it. Before
    the setup() function, add the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'sheepList = [] #list to store sheep'
  prefs: []
  type: TYPE_NORMAL
- en: 'grassList = [] #list to store grass'
  prefs: []
  type: TYPE_NORMAL
- en: 'patchSize = 10 #size of each patch of grass'
  prefs: []
  type: TYPE_NORMAL
- en: We might want to vary the size of the patch of grass in the future, so let’s
    create a variable called patchSize so we’ll only have to change it in one place.
    In the setup() function, after creating the sheep, create the grass by adding
    the new code in [Listing 9-18](ch09.xhtml#ch09list18).
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: global patchSize
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: '#create the sheep'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.append(Sheep(random(width),
  prefs: []
  type: TYPE_NORMAL
- en: random(height)))
  prefs: []
  type: TYPE_NORMAL
- en: '#create the grass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in range(0,width,patchSize):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for y in range(0,height,patchSize):'
  prefs: []
  type: TYPE_NORMAL
- en: grassList.append(Grass(x,y,patchSize))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-18: Updating the Grass object using patchSize variable*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, global patchSize tells Python that we’re using the same patchSize
    variable everywhere. Then we write two for loops (one for x and the other for
    y) to append Grass to the grass list so we can create a square grid of grass.
  prefs: []
  type: TYPE_NORMAL
- en: Then we update everything in the draw() function, just like we did for the sheep.
    Whatever is drawn first will be drawn covered up by what’s drawn after, so we’ll
    update the grass first by changing the draw() function to the code in [Listing
    9-19](ch09.xhtml#ch09list19).
  prefs: []
  type: TYPE_NORMAL
- en: '*SheepAndGrass.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  prefs: []
  type: TYPE_NORMAL
- en: '#update the grass first'
  prefs: []
  type: TYPE_NORMAL
- en: 'for grass in grassList:'
  prefs: []
  type: TYPE_NORMAL
- en: grass.update()
  prefs: []
  type: TYPE_NORMAL
- en: '#then the sheep'
  prefs: []
  type: TYPE_NORMAL
- en: 'for sheep in sheepList:'
  prefs: []
  type: TYPE_NORMAL
- en: sheep.update()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-19: Updating the grass before the sheep*'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you should see a grid of green squares, like in [Figure
    9-7](ch09.xhtml#ch09fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f192-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: Grass with grid lines*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s shut off the black outline so it’ll look like a smooth field of grass.
    Add noStroke() to the setup() function to remove the outline of the green squares:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: global patchSize
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: noStroke()
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our grass!
  prefs: []
  type: TYPE_NORMAL
- en: MAKING THE GRASS BROWN WHEN EATEN
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How do we make it so that when a sheep is on a patch of grass, the sheep gets
    the grass’s energy and the patch of grass turns brown to show that the sheep has
    eaten it? Change the update() method for Grass by adding the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.eaten:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(BROWN)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(GREEN)
  prefs: []
  type: TYPE_NORMAL
- en: rect(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: This code tells Processing that if the patch of grass is “eaten,” the rectangle
    should be filled with a brown color. Otherwise, the grass should be colored green.
    There’s more than one way for a sheep to “eat” grass. One way is to make each
    patch of grass check the entire sheepList for a sheep on its location, which could
    mean tens of thousands of patches are checking thousands of sheep. Those numbers
    could get big. However, because each patch of grass is in the grassList, an alternate
    way is that when a sheep changes its location, it could simply change the patch
    at that location to “eaten” (if it isn’t already) and get energy from eating it.
    That would mean a lot less checking.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the x- and y-coordinates of the sheep don’t exactly match
    up to where the patches of grass are in the grassList. For example, our patchSize
    is 10, meaning that if a sheep is at (92,35), it’ll be on the 10th patch to the
    right and the 4th patch down (because the “first” patch is from x = 0 to x = 9).
    We’re dividing by the patchSize to get the “scaled” x- and y-values, 9 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the grassList doesn’t have rows and columns. We do know that the x-value,
    9, means it’s the 10th row (don’t forget row 0), so we’ll just have to add in
    nine rows of 60 (the height divided by the patchSize) and then add the y-value
    to get the index of the patch of grass the sheep is on. Therefore, we need a variable
    to tell us how many patches of grass there are in a row, which we’ll call rows_of_grass.
    Add global rows_of_grass to the beginning of the setup() function and then add
    this line to setup() after declaring the size:'
  prefs: []
  type: TYPE_NORMAL
- en: rows_of_grass = height/patchSize
  prefs: []
  type: TYPE_NORMAL
- en: This takes the width of the display window and divides it by the size of the
    patches of grass to tell us how many columns of grass there are. The code to add
    to the Sheep class is in [Listing 9-20](ch09.xhtml#ch09list20).
  prefs: []
  type: TYPE_NORMAL
- en: '*SheepAndGrass.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: self.x += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: self.y += random(-move, move)
  prefs: []
  type: TYPE_NORMAL
- en: '#"wrap" the world Asteroids-style'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ if self.x > width:'
  prefs: []
  type: TYPE_NORMAL
- en: self.x %= width
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.y > height:'
  prefs: []
  type: TYPE_NORMAL
- en: self.y %= height
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.x < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: self.x += width
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.y < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: self.y += height
  prefs: []
  type: TYPE_NORMAL
- en: '#find the patch of grass you''re on in the grassList:'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ xscl = int(self.x / patchSize)
  prefs: []
  type: TYPE_NORMAL
- en: yscl = int(self.y / patchSize)
  prefs: []
  type: TYPE_NORMAL
- en: ➌ grass = grassList[xscl * rows_of_grass + yscl]
  prefs: []
  type: TYPE_NORMAL
- en: 'if not grass.eaten:'
  prefs: []
  type: TYPE_NORMAL
- en: self.energy += grass.energy
  prefs: []
  type: TYPE_NORMAL
- en: grass.eaten = True
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-20: Updating the sheep’s energy level and turning the grass brown*'
  prefs: []
  type: TYPE_NORMAL
- en: After updating the sheep’s location, we “wrap” the coordinates ➊ so if the sheep
    walks off the screen in one direction, it shows up on the other side of the screen,
    like in the video game *Asteroids*. We calculate which patch the sheep is on according
    to the patchSize ➋. Then we use code to go from x- and y-values to the index of
    that patch in the grassList ➌. We now know the exact index of the patch of grass
    the sheep is on. If this patch of grass is not already eaten, the sheep eats it!
    It gets the energy from the grass, and the grass’s eaten property is set to True.
  prefs: []
  type: TYPE_NORMAL
- en: Run this code, and you’ll see the three sheep running around eating grass, which
    turns brown once it’s eaten. Slow the sheep down by changing the move variable
    to a lesser value, such as 5\. You can also scale down the patches by changing
    one number, the patchSize variable, to 5\. Try other values if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create more Sheep. Let’s change the number in the for i in range
    line to 20, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '#create the sheep'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.append(Sheep(random(width),
  prefs: []
  type: TYPE_NORMAL
- en: random(height)))
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you should see something like [Figure 9-8](ch09.xhtml#ch09fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f194-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: A herd of sheep!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now there are 20 sheep walking around, leaving patches of brown grass.
  prefs: []
  type: TYPE_NORMAL
- en: GIVING EACH SHEEP A RANDOM COLOR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s have the sheep choose a color when they’re “born.” After the code defining
    the color constants, let’s put some colors into a color list, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: YELLOW = color(255,255,0)
  prefs: []
  type: TYPE_NORMAL
- en: PURPLE = color(102,0,204)
  prefs: []
  type: TYPE_NORMAL
- en: colorList = [WHITE,RED,YELLOW,PURPLE]
  prefs: []
  type: TYPE_NORMAL
- en: Make the following changes to the Sheep class to use different colors. First,
    you need to give Sheep a color property. Because color is already a keyword in
    Processing, col is used in [Listing 9-21](ch09.xhtml#ch09list21).
  prefs: []
  type: TYPE_NORMAL
- en: 'class Sheep:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y,col):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.x = x #x-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.y = y #y-position'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.sz = 10 #size'
  prefs: []
  type: TYPE_NORMAL
- en: self.energy = 20
  prefs: []
  type: TYPE_NORMAL
- en: self.col = col
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-21: Adding a color property to the Sheep class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then in the update() method, replace the fill line with this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(self.col) #its own color'
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: Before the ellipse is drawn, fill(self.col) tells Processing to fill the ellipse
    with the Sheep’s own randomly chosen color.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all the Sheep are instantiated in the setup() function, you need to give
    them a random color. That means at the top of the program you have to import the
    choice() function from the random module, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: from random import choice
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s choice() function allows you to have one item chosen at random from
    a list and then returned. We should be able to tell the program to do this as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: choice(colorList)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the program will return a single value from the color list. Finally, when
    you’re creating the Sheep, add the random choice of color from the color list
    as one of the arguments you pass to the Sheep constructor, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: noStroke()
  prefs: []
  type: TYPE_NORMAL
- en: '#create the sheep'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.append(Sheep(random(width),
  prefs: []
  type: TYPE_NORMAL
- en: random(height),
  prefs: []
  type: TYPE_NORMAL
- en: choice(colorList)))
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run this code, you should see a bunch of randomly colored sheep
    walking around the screen, as shown in [Figure 9-9](ch09.xhtml#ch09fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f196-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: Multicolored sheep*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each new sheep gets assigned one of the four colors we defined in colorList:
    white, red, yellow, or purple.'
  prefs: []
  type: TYPE_NORMAL
- en: PROGRAMMING SHEEP TO REPRODUCE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, in our current program the sheep eat the grass until they wander
    too far away from the grass, run out of energy, and die. To prevent this, let’s
    tell the sheep to use some of that energy to reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the code in [Listing 9-22](ch09.xhtml#ch09list22) to tell the sheep
    to reproduce if their energy level reaches 50.
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.energy <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.remove(self)
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.energy >= 50:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.energy -= 30 #giving birth takes energy'
  prefs: []
  type: TYPE_NORMAL
- en: '#add another sheep to the list'
  prefs: []
  type: TYPE_NORMAL
- en: sheepList.append(Sheep(self.x,self.y,self.col))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-22: Adding a conditional for sheep to reproduce*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conditional if self.energy >= 50: checks whether that sheep’s energy is
    greater than or equal to 50\. If it is, we decrement the energy level by 30 for
    birthing and add another sheep to the sheep list. Notice that the new sheep is
    at the same location and is the same color as its parent. Run this code, and you
    should see the sheep reproduce, like in [Figure 9-10](ch09.xhtml#ch09fig10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f197-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: Sheep eating grass and reproducing*'
  prefs: []
  type: TYPE_NORMAL
- en: Soon you should see what looks like tribes of similarly colored sheep.
  prefs: []
  type: TYPE_NORMAL
- en: LETTING THE GRASS REGROW
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, the sheep soon eat up all the grass in their area and die (probably
    a lesson in there somewhere). We need to allow our grass to regrow. To do this,
    change the Grass’s update() method to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.eaten:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if random(100) < 5:'
  prefs: []
  type: TYPE_NORMAL
- en: self.eaten = False
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(BROWN)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(GREEN)
  prefs: []
  type: TYPE_NORMAL
- en: rect(self.x,self.y,self.sz,self.sz)
  prefs: []
  type: TYPE_NORMAL
- en: The Processing code random(100) generates a random number between 0 and 100\.
    If the number is less than 5, we regrow a patch of grass by setting its eaten
    property to False. We use the number 5 because this gives us a probability of
    5/100 that eaten grass will regrow during each frame. Otherwise, it stays brown.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code, and you should see something like [Figure 9-11](ch09.xhtml#ch09fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f198-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: The grass regrows and the sheep populate the whole screen!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might get so many sheep that the program starts to slow down! This
    could be because the sheep have too much energy. If so, try reducing the amount
    of energy each patch of grass contains from 5 to 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Grass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y,sz):'
  prefs: []
  type: TYPE_NORMAL
- en: self.x = x
  prefs: []
  type: TYPE_NORMAL
- en: self.y = y
  prefs: []
  type: TYPE_NORMAL
- en: 'self.energy = 2 #energy from eating this patch'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.eaten = False #hasn''t been eaten yet'
  prefs: []
  type: TYPE_NORMAL
- en: self.sz = sz
  prefs: []
  type: TYPE_NORMAL
- en: That seems to be a good balance that lets the sheep population grow at a reasonable
    pace. Play around with the numbers all you want—it’s your world!
  prefs: []
  type: TYPE_NORMAL
- en: PROVIDING AN EVOLUTIONARY ADVANTAGE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s give one of the sheep groups an advantage. You can choose any advantage
    you can think of (getting more energy from grass or producing more offspring at
    a time, for instance). For this example, we’re going to let the purple sheep walk
    a little further than the others. Will that make any difference? To find out,
    make the Sheep’s update() method match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '#make sheep walk randomly'
  prefs: []
  type: TYPE_NORMAL
- en: 'move = 5 #the maximum it can move in any direction'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.col == PURPLE:'
  prefs: []
  type: TYPE_NORMAL
- en: move = 7
  prefs: []
  type: TYPE_NORMAL
- en: self.energy -= 1
  prefs: []
  type: TYPE_NORMAL
- en: This conditional checks whether the Sheep’s color is purple. If so, it sets
    the Sheep’s move value to 7\. Otherwise, it leaves the value at 5\. This allows the
    purple sheep to travel further, and therefore more likely to find green patches,
    than the other sheep. Let’s run the code and check the outcome, which should look
    like [Figure 9-12](ch09.xhtml#ch09fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f199-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-12: Giving purple sheep an advantage*'
  prefs: []
  type: TYPE_NORMAL
- en: After a little while it sure looks like that tiny advantage paid off for the
    purple sheep. They’re dominating the environment and pushing out all the other
    sheep just by competing for grass. This simulation could spark interesting discussions
    about ecology, invasive species, biodiversity, and evolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 9-2: SETTING SHEEP LIFESPAN'
  prefs: []
  type: TYPE_NORMAL
- en: Create an “age” property and decrease it every time the sheep update so they
    live for only a limited amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 9-3: CHANGING SHEEP SIZE'
  prefs: []
  type: TYPE_NORMAL
- en: Vary the size of the sheep according to their energy level.
  prefs: []
  type: TYPE_NORMAL
- en: SUMMARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make objects using classes, which involved
    defining the class using properties and then instantiating (“creating”) and updating
    the object. This let you create multiple similar-but-independent objects with
    the same properties more efficiently. The more you use classes, the more creative
    you can get by making autonomous objects walk, fly, or bounce around without your
    having to code every step!
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use classes supercharges your coding abilities. Now you can create
    models of complicated situations easily, and once you tell the program what to
    do with one particle, or planet, or sheep, it’ll be able to make a dozen, a hundred,
    or even a million of them very easily!
  prefs: []
  type: TYPE_NORMAL
- en: You also got a taste of setting up models to explore physical, biological, chemical,
    or environmental situations with very few equations! A physicist once told me
    that’s often the most efficient method for solving problems involving many factors,
    or “agents.” You set up a computer model, let it run, and look at the results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to create fractals using an almost-magical
    phenomenon called recursion.
  prefs: []
  type: TYPE_NORMAL
