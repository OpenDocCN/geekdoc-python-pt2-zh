- en: method, passing in the new text to display. The setValue() method has an opti-
  prefs: []
  type: TYPE_NORMAL
- en: 'mization, too: it remembers the last text that it rendered, and before doing'
  prefs: []
  type: TYPE_NORMAL
- en: anything else, it checks if the new text is the same as the previous text. If
    the
  prefs: []
  type: TYPE_NORMAL
- en: text has not changed, there is nothing to do and the method just returns. If
  prefs: []
  type: TYPE_NORMAL
- en: there is new text, it renders the new text into a surface to be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method 5 draws the image contained in the self.textSurface
  prefs: []
  type: TYPE_NORMAL
- en: instance variable into the window at the given location. This method should
  prefs: []
  type: TYPE_NORMAL
- en: be called in every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple advantages to this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: • The class hides all the details of pygame’s rendering of text, so the user
  prefs: []
  type: TYPE_NORMAL
- en: of this class never needs to know what pygame-specific calls are needed
  prefs: []
  type: TYPE_NORMAL
- en: to show text.
  prefs: []
  type: TYPE_NORMAL
- en: '**134** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: • Each SimpleText object remembers the window that it draws into, the location
    where the text should be placed, and the text color. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: you only need to specify these values once, when you instantiate a
  prefs: []
  type: TYPE_NORMAL
- en: SimpleText object, typically before the main loop starts.
  prefs: []
  type: TYPE_NORMAL
- en: • Each SimpleText object is also optimized to remember both the text that
  prefs: []
  type: TYPE_NORMAL
- en: it was last told to draw and the image (self.textSurface) that it made
  prefs: []
  type: TYPE_NORMAL
- en: from the current text. It only needs to render a new surface when the
  prefs: []
  type: TYPE_NORMAL
- en: text changes.
  prefs: []
  type: TYPE_NORMAL
- en: • To show multiple pieces of text in a window, you only need to instanti-
  prefs: []
  type: TYPE_NORMAL
- en: ate multiple SimpleText objects. This is a key concept of object-oriented
  prefs: []
  type: TYPE_NORMAL
- en: programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Demo Ball with SimpleText and SimpleButton**'
  prefs: []
  type: TYPE_NORMAL
- en: To cap this off, we’ll modify Listing 6-2 to use the SimpleText and SimpleButton
  prefs: []
  type: TYPE_NORMAL
- en: classes. The updated program in Listing 6-7 keeps track of the number of
  prefs: []
  type: TYPE_NORMAL
- en: times it goes through the main loop and reports that information at the top
  prefs: []
  type: TYPE_NORMAL
- en: of the window. Clicking the Restart button resets the counter.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo8_SimpleTextDisplay/Main_Bal TextAndButton.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 8 - SimpleText, SimpleButton, and Ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: '1 from Ball import * # bring in the Ball class code'
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleText import *
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleButton import *
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WHITE = (255, 255, 255)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: oFrameCountLabel = SimpleText(window, (60, 20),
  prefs: []
  type: TYPE_NORMAL
- en: '''Program has run through this many loops: '', WHITE)'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **135**
  prefs: []
  type: TYPE_NORMAL
- en: oFrameCountDisplay = SimpleText(window, (500, 20), '', WHITE)
  prefs: []
  type: TYPE_NORMAL
- en: oRestartButton = SimpleButton(window, (280, 60),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/restartUp.png'', ''images/restartDown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: frameCounter = 0
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: '3 if oRestartButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: 'frameCounter = 0 # clicked button, reset counter'
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 oBall.update() # tell the ball to update itself'
  prefs: []
  type: TYPE_NORMAL
- en: 'frameCounter = frameCounter + 1 # increment each frame'
  prefs: []
  type: TYPE_NORMAL
- en: 5 oFrameCountDisplay.setValue(str(frameCounter))
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 oBall.draw() # tell the ball to draw itself'
  prefs: []
  type: TYPE_NORMAL
- en: oFrameCountLabel.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oFrameCountDisplay.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oRestartButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-7: An example main program to show Ball, SimpleText, and SimpleButton*
    At the top of the program, we import the code of the Ball, SimpleText,'
  prefs: []
  type: TYPE_NORMAL
- en: and SimpleButton classes 1\. Before our main loop starts, we create an instance
  prefs: []
  type: TYPE_NORMAL
- en: of the Ball 2, two instances of the SimpleText class (oFrameCountLabel for the
  prefs: []
  type: TYPE_NORMAL
- en: unchanging message label and oFrameCountDisplay for the changing dis-
  prefs: []
  type: TYPE_NORMAL
- en: play of frames), and an instance of the SimpleButton class that we store in
  prefs: []
  type: TYPE_NORMAL
- en: oRestartButton. We also initialize a variable frameCounter to zero, which we
    will
  prefs: []
  type: TYPE_NORMAL
- en: increment every time through the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we check if the user pressed the Restart button 3\. If
  prefs: []
  type: TYPE_NORMAL
- en: True, we reset the frame counter.
  prefs: []
  type: TYPE_NORMAL
- en: We tell the ball to update its position 4\. We increment the frame coun-
  prefs: []
  type: TYPE_NORMAL
- en: ter, then call the setValue() method of the text field to show the new count
  prefs: []
  type: TYPE_NORMAL
- en: of frames 5\. Finally, we tell the ball to draw itself tell the text fields
    to draw
  prefs: []
  type: TYPE_NORMAL
- en: themselves, and tell the Restart button to draw itself, by calling the draw()
  prefs: []
  type: TYPE_NORMAL
- en: method of each object 6\.
  prefs: []
  type: TYPE_NORMAL
- en: '**136** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: In the instantiation of the SimpleText objects, the last argument is a text
    color, and we specified that the objects should be rendered in WHITE so
  prefs: []
  type: TYPE_NORMAL
- en: they can be seen against a BLACK background. In the next chapter, I’ll show
  prefs: []
  type: TYPE_NORMAL
- en: how to expand the SimpleText class to incorporate more attributes, without
  prefs: []
  type: TYPE_NORMAL
- en: complicating the interface of the class. We’ll build a more full-featured text
  prefs: []
  type: TYPE_NORMAL
- en: object that has reasonable default values for each of these attributes, but
  prefs: []
  type: TYPE_NORMAL
- en: allows you to override those defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface vs. Implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: The SimpleButton and SimpleText examples bring up the important topic of
  prefs: []
  type: TYPE_NORMAL
- en: interface versus implementation. As mentioned i[n Chapter 4, t](index_split_001.html#p86)he
    interface refers to how something is used, while the implementation refers to
    how
  prefs: []
  type: TYPE_NORMAL
- en: something works (internally).
  prefs: []
  type: TYPE_NORMAL
- en: In an OOP environment, the interface is the set of methods in a class and
  prefs: []
  type: TYPE_NORMAL
- en: their related parameters—also known as the *application programming interface*
  prefs: []
  type: TYPE_NORMAL
- en: '*(API)*. The implementation is the actual code of all the methods in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: An external package such as pygame will most likely come with docu-
  prefs: []
  type: TYPE_NORMAL
- en: mentation of the API that explains the calls that are available and the
  prefs: []
  type: TYPE_NORMAL
- en: arguments you are expected to pass with each call. The full pygame API
  prefs: []
  type: TYPE_NORMAL
- en: documentation is available at [*https://www.pygame.org/docs/*](https://www.pygame.org/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: When you write code that makes calls to pygame, you don’t need to worry
  prefs: []
  type: TYPE_NORMAL
- en: about the implementation of the methods you are using. For example,
  prefs: []
  type: TYPE_NORMAL
- en: when you make a call to blit() to draw image, you really don’t care *how*
  prefs: []
  type: TYPE_NORMAL
- en: blit() does what it does; you just need to know *what* the call does and what
    arguments need to be passed in. On the other side, you can trust that the
  prefs: []
  type: TYPE_NORMAL
- en: implementer(s) who wrote the blit() method have thought extensively
  prefs: []
  type: TYPE_NORMAL
- en: about how to make blit() work most efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In the programming world, we often wear two hats as both the imple-
  prefs: []
  type: TYPE_NORMAL
- en: menter and the application developer, so we need to make an effort to design
  prefs: []
  type: TYPE_NORMAL
- en: APIs that not only make sense in the current situation, but also are general
  prefs: []
  type: TYPE_NORMAL
- en: enough to be used by future programs of our own and by programs written
  prefs: []
  type: TYPE_NORMAL
- en: by other people. Our SimpleButton and SimpleText classes are good examples,
  prefs: []
  type: TYPE_NORMAL
- en: as they are written in a general way so that they can be reused easily. I’ll
    talk
  prefs: []
  type: TYPE_NORMAL
- en: more about interface versus implementation i[n Chapter 8, w](#p192)hen we look
    at encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Callbacks**'
  prefs: []
  type: TYPE_NORMAL
- en: When using a SimpleButton object, we handle checking for and reacting to a
  prefs: []
  type: TYPE_NORMAL
- en: 'button click like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: print('The button was clicked')
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **137**
  prefs: []
  type: TYPE_NORMAL
- en: This approach to handling events works well with the SimpleButton class.
  prefs: []
  type: TYPE_NORMAL
- en: However, some other Python packages and many other programming lan-
  prefs: []
  type: TYPE_NORMAL
- en: 'guages handle events in a different way: with a *callback*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**'
  prefs: []
  type: TYPE_NORMAL
- en: A function or method of an object that is cal ed when a particular action, event,
    or condition happens .
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to understand this is to think about the 1984 hit movie
  prefs: []
  type: TYPE_NORMAL
- en: '*Ghostbusters*. The tagline for the movie is “Who you gonna call?” In the'
  prefs: []
  type: TYPE_NORMAL
- en: movie, the Ghostbusters ran an ad on TV that told people that if they saw
  prefs: []
  type: TYPE_NORMAL
- en: a ghost (that’s the event to look for), they should call the Ghostbusters (the
  prefs: []
  type: TYPE_NORMAL
- en: callback) to get rid of it. Upon receiving the call, the Ghostbusters take the
  prefs: []
  type: TYPE_NORMAL
- en: appropriate actions to eliminate the ghost.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a button object that is initialized to have a
  prefs: []
  type: TYPE_NORMAL
- en: callback. When the user clicks the button, the button will call the callback
  prefs: []
  type: TYPE_NORMAL
- en: function or method. That function or method executes whatever code is
  prefs: []
  type: TYPE_NORMAL
- en: needed to react to the button click.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Cal back***'
  prefs: []
  type: TYPE_NORMAL
- en: To set up a callback, when you create an object or call one of an object’s
  prefs: []
  type: TYPE_NORMAL
- en: methods, you pass the name of a function or a method of an object to be
  prefs: []
  type: TYPE_NORMAL
- en: called. As an example, there is a standard GUI package for Python called
  prefs: []
  type: TYPE_NORMAL
- en: tkinter. The code needed to create a button with this package is very differ-
  prefs: []
  type: TYPE_NORMAL
- en: 'ent from what I have shown—here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: import tkinter
  prefs: []
  type: TYPE_NORMAL
- en: 'def myFunction():'
  prefs: []
  type: TYPE_NORMAL
- en: print('myCallBackFunction was called')
  prefs: []
  type: TYPE_NORMAL
- en: oButton = tkinter.Button(text='Click me', command=myFunction)
  prefs: []
  type: TYPE_NORMAL
- en: When you create a button with tkinter, you must pass in a function (or
  prefs: []
  type: TYPE_NORMAL
- en: a method of an object), which will be called back when the user clicks the
  prefs: []
  type: TYPE_NORMAL
- en: button. Here, we are passing myFunction as the function to be called back.
  prefs: []
  type: TYPE_NORMAL
- en: (This call is using keyword parameters, which will be discussed at length
  prefs: []
  type: TYPE_NORMAL
- en: in [Chapter 7.) T](#p172)he tkinter button remembers that function as the callback,
    and when the user clicks the resulting button, it calls the function
  prefs: []
  type: TYPE_NORMAL
- en: myFunction().
  prefs: []
  type: TYPE_NORMAL
- en: You can also use a callback when you initiate some action that may
  prefs: []
  type: TYPE_NORMAL
- en: take some time. Instead of waiting for the action to finish and causing the
  prefs: []
  type: TYPE_NORMAL
- en: program appear to freeze for a period of time, you provide a callback to be
  prefs: []
  type: TYPE_NORMAL
- en: called when the action is completed. For example, imagine that you want to
  prefs: []
  type: TYPE_NORMAL
- en: make a request across the internet. Rather than making a call and waiting
  prefs: []
  type: TYPE_NORMAL
- en: for that call to return data, which may take a long time, there are packages
  prefs: []
  type: TYPE_NORMAL
- en: that allow you to use the approach of making the call and setting a callback.
  prefs: []
  type: TYPE_NORMAL
- en: That way, the program can continue running, and the user is not locked
  prefs: []
  type: TYPE_NORMAL
- en: '**138** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: out of it. This often involves multiple Python threads and is beyond the scope
    of this book, but the technique of using a callback is the general way
  prefs: []
  type: TYPE_NORMAL
- en: that it is done.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using a Cal back with SimpleButton***'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this concept, we’ll make a minor modification to the
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class to allow it to accept a callback. As an additional optional
  prefs: []
  type: TYPE_NORMAL
- en: parameter, the caller can provide a function or method of an object to be
  prefs: []
  type: TYPE_NORMAL
- en: called back when a click on a SimpleButton object happens. Each instance of
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton remembers the callback in an instance variable. When the user
  prefs: []
  type: TYPE_NORMAL
- en: completes a click, the instance of SimpleButton calls the callback.
  prefs: []
  type: TYPE_NORMAL
- en: The main program in Listing 6-8 creates three instances of the
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class, each of which handles the button click in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: The first button, oButtonA, provides no callback; oButtonB provides a callback
  prefs: []
  type: TYPE_NORMAL
- en: to a function; and oButtonC specifies a callback to a method of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo9_SimpleButtonWithCallback/Main_SimpleButtonCallback.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 9 - 3-button test with callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleButton import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: '#2 - Define constants'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GRAY = (200, 200, 200)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 400
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 100
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to be used as a "callback"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def myCallBackFunction(): 1'
  prefs: []
  type: TYPE_NORMAL
- en: print('User pressed Button B, called myCallBackFunction')
  prefs: []
  type: TYPE_NORMAL
- en: Define a class with a method to be used as a "callback"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class CallBackTest(): 2'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snipped any other methods in this class ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'def myMethod(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print('User pressed ButtonC, called myMethod of the CallBackTest object')
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **139**
  prefs: []
  type: TYPE_NORMAL
- en: oCallBackTest = CallBackTest() 3
  prefs: []
  type: TYPE_NORMAL
- en: Create instances of SimpleButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No call back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oButtonA = SimpleButton(window, (25, 30), 4
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonAUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonADown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a function to call back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oButtonB = SimpleButton(window, (150, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBDown.png'','
  prefs: []
  type: TYPE_NORMAL
- en: callBack=myCallBackFunction)
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a method of an object to call back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oButtonC = SimpleButton(window, (275, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCDown.png'','
  prefs: []
  type: TYPE_NORMAL
- en: callBack=oCallBackTest.myMethod)
  prefs: []
  type: TYPE_NORMAL
- en: counter = 0
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: Pass the event to the button, see if it has been clicked on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if oButtonA.handleEvent(event): 5'
  prefs: []
  type: TYPE_NORMAL
- en: print('User pressed button A, handled in the main loop')
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB and oButtonC have callbacks,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: no need to check result of these calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oButtonB.handleEvent(event) 6
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC.handleEvent(event) 7
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: counter = counter + 1
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oButtonA.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-8: A version of the main program that handles but on clicks three
    different ways* **140** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: We start with a simple function, myCallBackFunction() 1, that just prints a
    message to announce that it has been called. Next, we have a CallBackTest
  prefs: []
  type: TYPE_NORMAL
- en: class that contains the method myMethod() 2, which prints its own message
  prefs: []
  type: TYPE_NORMAL
- en: to announce that it’s been called. We create an oCallBackTest object from
  prefs: []
  type: TYPE_NORMAL
- en: the CallBackTest class 3\. We need this object so we can set up a callback to
  prefs: []
  type: TYPE_NORMAL
- en: oCallBack.myMethod().
  prefs: []
  type: TYPE_NORMAL
- en: Then we create three SimpleButton objects, each using a different
  prefs: []
  type: TYPE_NORMAL
- en: approach 4\. The first, oButtonA, has no callback. The second, oButtonB, sets
  prefs: []
  type: TYPE_NORMAL
- en: its callback to the function myCallBackFunction(). The third, oButtonC, sets
    its
  prefs: []
  type: TYPE_NORMAL
- en: callback to oCallBack.myMethod().
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we check for the user clicking on any of the three
  prefs: []
  type: TYPE_NORMAL
- en: buttons by calling the handleEvent() method of each button. Since oButtonA
  prefs: []
  type: TYPE_NORMAL
- en: has no callback, we must check if the value returned is True 5 and, if so,
  prefs: []
  type: TYPE_NORMAL
- en: perform an action. When oButtonB is clicked 6, the myCallBackFunction()
  prefs: []
  type: TYPE_NORMAL
- en: function will be called and will print its message. When oButtonC is clicked
    7,
  prefs: []
  type: TYPE_NORMAL
- en: the myMethod() method of the oCallBackTest object will be called and will
  prefs: []
  type: TYPE_NORMAL
- en: print its message.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers prefer using a callback approach, because the tar-
  prefs: []
  type: TYPE_NORMAL
- en: get to be called is set up when you create the object. It’s important to under-
  prefs: []
  type: TYPE_NORMAL
- en: stand this technique, especially if you are using a package that requires
  prefs: []
  type: TYPE_NORMAL
- en: it. However, I will use the original approach of checking for the value
  prefs: []
  type: TYPE_NORMAL
- en: returned by a call to handleEvent() in all my demonstration code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I showed how you can start with a procedural program and
  prefs: []
  type: TYPE_NORMAL
- en: extract related code to build a class. We created a Ball class to demonstrate
  prefs: []
  type: TYPE_NORMAL
- en: this, then modified the main code of our demo program from the previous
  prefs: []
  type: TYPE_NORMAL
- en: chapter to call methods of the class to tell the Ball object *what* to do, without
    worrying about *how* it achieves the outcome. With all the related code in a separate
    class, it’s easy to create a list of objects and instantiate and manage as many
    objects as we want to.
  prefs: []
  type: TYPE_NORMAL
- en: We then built a SimpleButton class and a SimpleText class that hide com-
  prefs: []
  type: TYPE_NORMAL
- en: plexity inside their implementation and create highly reusable code. In the
  prefs: []
  type: TYPE_NORMAL
- en: next chapter, I’ll build on these classes to develop “professional-strength”
  prefs: []
  type: TYPE_NORMAL
- en: button and text display classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I introduced the concept of a callback, where you pass in a func-
  prefs: []
  type: TYPE_NORMAL
- en: tion or method in a call to an object. The callback is later called back when
  prefs: []
  type: TYPE_NORMAL
- en: an event happens or an action completes.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **141**
  prefs: []
  type: TYPE_NORMAL
- en: '**7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**P Y G A M E G U I W I D G E T S**'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame allows programmers to take the
  prefs: []
  type: TYPE_NORMAL
- en: text-based language of Python and use it
  prefs: []
  type: TYPE_NORMAL
- en: to build GUI-based programs. Windows,
  prefs: []
  type: TYPE_NORMAL
- en: pointing devices, clicking, dragging, and
  prefs: []
  type: TYPE_NORMAL
- en: sounds have all become standard parts of our expe-
  prefs: []
  type: TYPE_NORMAL
- en: rience using computers. Unfortunately, the pygame
  prefs: []
  type: TYPE_NORMAL
- en: package doesn’t come with built-in basic user inter-
  prefs: []
  type: TYPE_NORMAL
- en: face elements, so we need to build them ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll do so with pygwidgets, a library of GUI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how standard widgets such as images, buttons,
  prefs: []
  type: TYPE_NORMAL
- en: and input or output fields can be built as classes and how client code uses
  prefs: []
  type: TYPE_NORMAL
- en: them. Building each element as a class allows programmers to incorporate
  prefs: []
  type: TYPE_NORMAL
- en: multiple instances of each element when creating a GUI. Before we get
  prefs: []
  type: TYPE_NORMAL
- en: started building these GUI widgets, however, I first need to discuss one
  prefs: []
  type: TYPE_NORMAL
- en: 'more Python feature: passing data in a call to a function or method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing Arguments into a Function or Method**'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments in a call to a function and the parameters defined in the
  prefs: []
  type: TYPE_NORMAL
- en: function have a one-to-one relationship, so that the value of the first argu-
  prefs: []
  type: TYPE_NORMAL
- en: ment is given to the first parameter, the value of the second argument is
  prefs: []
  type: TYPE_NORMAL
- en: given to the second parameter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7-1, duplicated fro[m Chapter 3, s](index_split_001.html#p76)hows that
    the same is true when you make a call to a method of an object. We can see that
    the first parameter, which is always self, is set to the object in the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'def someMethod(self, *<any other parameters>* ):'
  prefs: []
  type: TYPE_NORMAL
- en: oSomeObject.someMethod( *<any other arguments>* )
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-1: How arguments passed into a method match up with its parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: However, Python (and some other languages) allows you to make some
  prefs: []
  type: TYPE_NORMAL
- en: of the arguments optional. If an optional argument isn’t provided in a call,
  prefs: []
  type: TYPE_NORMAL
- en: we can provide a default value to use in the function or method instead. I’ll
  prefs: []
  type: TYPE_NORMAL
- en: explain by means of a real-world analogy.
  prefs: []
  type: TYPE_NORMAL
- en: If you order a hamburger at a Burger King restaurant, your burger will
  prefs: []
  type: TYPE_NORMAL
- en: come with ketchup, mustard, and pickles. But Burger King is famous for
  prefs: []
  type: TYPE_NORMAL
- en: saying, “You can have it your way.” If you want some other combination of
  prefs: []
  type: TYPE_NORMAL
- en: condiments, you must say what you want (or don’t want) when you make
  prefs: []
  type: TYPE_NORMAL
- en: your order.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by writing an orderBurgers() function that simulates making
  prefs: []
  type: TYPE_NORMAL
- en: a burger order in the regular way we’ve been defining functions, without
  prefs: []
  type: TYPE_NORMAL
- en: 'implementing default values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderBurgers(nBurgers, ketchup, mustard, pickles):'
  prefs: []
  type: TYPE_NORMAL
- en: You must specify the number of hamburgers you want to order, but
  prefs: []
  type: TYPE_NORMAL
- en: ideally, if you want the defaults of True for adding ketchup, mustard, and
  prefs: []
  type: TYPE_NORMAL
- en: pickles, you shouldn’t need to pass in any more arguments. So, to order two
  prefs: []
  type: TYPE_NORMAL
- en: hamburgers with the standard defaults, you might think your call should
  prefs: []
  type: TYPE_NORMAL
- en: 'look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers(2) # with ketchup, mustard, and pickles'
  prefs: []
  type: TYPE_NORMAL
- en: However, in Python, this will trigger an error because there is a mis-
  prefs: []
  type: TYPE_NORMAL
- en: match between the number of arguments in the call and the number of
  prefs: []
  type: TYPE_NORMAL
- en: 'parameters specified in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: orderBurgers() missing 3 required positional arguments: ''ketchup'','
  prefs: []
  type: TYPE_NORMAL
- en: '''mustard'', and ''pickles'''
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how Python allows us to set up optional parameters that can
  prefs: []
  type: TYPE_NORMAL
- en: be given default values if nothing is specified.
  prefs: []
  type: TYPE_NORMAL
- en: '**144** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: '***Positional and Keyword Parameters***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has two different types of parameters: positional parameters and'
  prefs: []
  type: TYPE_NORMAL
- en: keyword parameters. *Positional parameters* are the type that we’re already
  prefs: []
  type: TYPE_NORMAL
- en: familiar with, where each argument in a call has a matching parameter in
  prefs: []
  type: TYPE_NORMAL
- en: the function or method definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *keyword parameter* allows you to specify a default value. You write a keyword
    parameter as a variable name, an equal sign, and a default value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def someFunction( *<keywordParameter>* = *<default value>* ): You can have
    multiple keyword parameters, each with a name and a'
  prefs: []
  type: TYPE_NORMAL
- en: default value.
  prefs: []
  type: TYPE_NORMAL
- en: A function or method can have both positional parameters and key-
  prefs: []
  type: TYPE_NORMAL
- en: word parameters, in which case you must specify all positional parameters
  prefs: []
  type: TYPE_NORMAL
- en: '*before* any keyword parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: def someOtherFunction(positionalParam1, positionalParam2, ...
  prefs: []
  type: TYPE_NORMAL
- en: '*<keywordParameter1>* = *<default value 1>* ,'
  prefs: []
  type: TYPE_NORMAL
- en: '*<keywordParameter2>* = *<default value 2>* , ...):'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rewrite orderBurgers() to use one positional parameter and three
  prefs: []
  type: TYPE_NORMAL
- en: 'keyword parameters with default values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
  prefs: []
  type: TYPE_NORMAL
- en: When we make a call to this function, nBurgers is a positional parameter
  prefs: []
  type: TYPE_NORMAL
- en: and therefore must be specified as an argument in every call. The other three
  prefs: []
  type: TYPE_NORMAL
- en: are keyword parameters. If no values are passed for ketchup, mustard, and pick-
  prefs: []
  type: TYPE_NORMAL
- en: les, the function will use the default value of True for each of those parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'variables. Now we can order two burgers with all the condiments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2)
  prefs: []
  type: TYPE_NORMAL
- en: If we want something other than a default value, we can specify the name
  prefs: []
  type: TYPE_NORMAL
- en: of the keyword parameter and a different value in our call. For example, if
    we
  prefs: []
  type: TYPE_NORMAL
- en: 'only want ketchup on our two burgers, we can make the call this way:'
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, mustard=False, pickles=False)
  prefs: []
  type: TYPE_NORMAL
- en: When the function runs, the values of the mustard and pickles variables
  prefs: []
  type: TYPE_NORMAL
- en: are set to False. Since we did not specify a value for ketchup, it is given
    the
  prefs: []
  type: TYPE_NORMAL
- en: default of True.
  prefs: []
  type: TYPE_NORMAL
- en: You can also make the call specifying all arguments positionally, includ-
  prefs: []
  type: TYPE_NORMAL
- en: ing those written as keyword parameters. Python will use the ordering of
  prefs: []
  type: TYPE_NORMAL
- en: 'your arguments to assign each parameter the correct value:'
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, True, False, False)
  prefs: []
  type: TYPE_NORMAL
- en: In this call, we are again specifying two burgers with ketchup, no mus-
  prefs: []
  type: TYPE_NORMAL
- en: tard, and no pickles.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **145**
  prefs: []
  type: TYPE_NORMAL
- en: '***Additional Notes on Keyword Parameters***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly go over a few conventions and tips for using keyword param-
  prefs: []
  type: TYPE_NORMAL
- en: eters. As a Python convention, when you use keyword parameters and key-
  prefs: []
  type: TYPE_NORMAL
- en: words with arguments, the equal sign between the keyword and the value
  prefs: []
  type: TYPE_NORMAL
- en: 'should *not* have spaces around it, to show that these are not typical assignment
    statements. These lines are properly formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, mustard=False)
  prefs: []
  type: TYPE_NORMAL
- en: These lines will also work fine, but they don’t follow the formatting con-
  prefs: []
  type: TYPE_NORMAL
- en: 'vention and are less readable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderBurgers(nBurgers, ketchup = True, mustard = True, pickles = True):'
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, mustard = False)
  prefs: []
  type: TYPE_NORMAL
- en: When calling a function that has both positional parameters and key-
  prefs: []
  type: TYPE_NORMAL
- en: word parameters, you must provide values for all the positional parameters
  prefs: []
  type: TYPE_NORMAL
- en: first, before any optional keyword parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments in calls can be specified in any order. Calls to our
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers() function could be made in various ways, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers(2, mustard=False, pickles=False) # only ketchup'
  prefs: []
  type: TYPE_NORMAL
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers(2, pickles=False, mustard=False, ketchup=False) # plain'
  prefs: []
  type: TYPE_NORMAL
- en: All keyword parameters will be given the appropriate values, indepen-
  prefs: []
  type: TYPE_NORMAL
- en: dent of the order of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: While all the default values in the orderBurgers() example were Boolean
  prefs: []
  type: TYPE_NORMAL
- en: values, a keyword parameter can have a default value of any data type. For
  prefs: []
  type: TYPE_NORMAL
- en: example, we could write a function to allow a customer to make an ice
  prefs: []
  type: TYPE_NORMAL
- en: 'cream order like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderIceCream(flavor, nScoops=1, coneOrCup=''cone'', sprinkles=False):'
  prefs: []
  type: TYPE_NORMAL
- en: The caller must specify a flavor, but by default will get one scoop in a
  prefs: []
  type: TYPE_NORMAL
- en: cone with no sprinkles. The caller could override these defaults with differ-
  prefs: []
  type: TYPE_NORMAL
- en: ent keyword values.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using None as a Default Value***'
  prefs: []
  type: TYPE_NORMAL
- en: It’s sometimes helpful to know whether the caller passed in a value for a
  prefs: []
  type: TYPE_NORMAL
- en: keyword parameter or not. For this example, the caller orders a pizza. At
  prefs: []
  type: TYPE_NORMAL
- en: a minimum, the caller must specify a size. The second parameter will be a
  prefs: []
  type: TYPE_NORMAL
- en: style that defaults to 'regular' but could be 'deepdish'. As a third parameter,
  prefs: []
  type: TYPE_NORMAL
- en: '**146** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: the caller can optionally pass in a single desired topping. If the caller wants
    a topping, we must charge them extra.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 7-1, we’ll use a positional parameter for the size and key-
  prefs: []
  type: TYPE_NORMAL
- en: word parameters for the style and topping. The default for style is the string
  prefs: []
  type: TYPE_NORMAL
- en: '''regular''. Since the topping choice is optional, we’ll use the special Python'
  prefs: []
  type: TYPE_NORMAL
- en: value of None as the default, but the caller may pass in the topping of their
  prefs: []
  type: TYPE_NORMAL
- en: choice.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OrderPizzaWithNone.py**'
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderPizza(size, style=''regular'', topping=None):'
  prefs: []
  type: TYPE_NORMAL
- en: Do some calculations based on the size and style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check if a topping was specified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PRICE_OF_TOPPING = 1.50 # price for any topping'
  prefs: []
  type: TYPE_NORMAL
- en: 'if size == ''small'':'
  prefs: []
  type: TYPE_NORMAL
- en: price = 10.00
  prefs: []
  type: TYPE_NORMAL
- en: 'elif size == ''medium'':'
  prefs: []
  type: TYPE_NORMAL
- en: price = 14.00
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # large'
  prefs: []
  type: TYPE_NORMAL
- en: price = 18.00
  prefs: []
  type: TYPE_NORMAL
- en: 'if style == ''deepdish'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'price = price + 2.00 # charge extra for deepdish'
  prefs: []
  type: TYPE_NORMAL
- en: line = 'You have ordered a ' + size + ' ' + style + ' pizza with '
  prefs: []
  type: TYPE_NORMAL
- en: '1 if topping is None: # check if no topping was passed in'
  prefs: []
  type: TYPE_NORMAL
- en: print(line + 'no topping')
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(line + topping)
  prefs: []
  type: TYPE_NORMAL
- en: price = price + PRICE_OF_TOPPING
  prefs: []
  type: TYPE_NORMAL
- en: print('The price is $', price)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'You could order a pizza in the following ways:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 orderPizza(''large'') # large, defaults to regular, no topping'
  prefs: []
  type: TYPE_NORMAL
- en: 'orderPizza(''large'', style=''regular'') # same as above'
  prefs: []
  type: TYPE_NORMAL
- en: 3 orderPizza('medium', style='deepdish', topping='mushrooms')
  prefs: []
  type: TYPE_NORMAL
- en: 'orderPizza(''small'', topping=''mushrooms'') # style defaults to regular'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-1: A function with a keyword parameter defaulting to None*'
  prefs: []
  type: TYPE_NORMAL
- en: The first and second calls would be seen as the same, with the value of
  prefs: []
  type: TYPE_NORMAL
- en: the variable topping set to None 2\. In the third and fourth calls, the value
    of
  prefs: []
  type: TYPE_NORMAL
- en: topping is set to 'mushrooms' 3\. Because 'mushrooms' is not None, in these
    calls
  prefs: []
  type: TYPE_NORMAL
- en: the code would add in an extra charge for a topping on the pizzas 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Using None as a default value for a keyword parameter gives you a way to
  prefs: []
  type: TYPE_NORMAL
- en: see if the caller provided a value in the call. This may be a very subtle use
    of
  prefs: []
  type: TYPE_NORMAL
- en: keyword parameters, but it will be very useful in our upcoming discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **147**
  prefs: []
  type: TYPE_NORMAL
- en: '***Choosing Keywords and Default Values***'
  prefs: []
  type: TYPE_NORMAL
- en: Using default values makes calling functions and methods simpler, but
  prefs: []
  type: TYPE_NORMAL
- en: there is a downside. Your choice of each keyword for keyword parameters
  prefs: []
  type: TYPE_NORMAL
- en: is very important. Once programmers start making calls that override
  prefs: []
  type: TYPE_NORMAL
- en: default values, it’s very difficult to change the name of a keyword parameter
  prefs: []
  type: TYPE_NORMAL
- en: because that name must be changed in *all* calls to the function or method
  prefs: []
  type: TYPE_NORMAL
- en: in lockstep. Otherwise, code that was working will break. For more widely
  prefs: []
  type: TYPE_NORMAL
- en: distributed code, this can potentially cause a great deal of pain to program-
  prefs: []
  type: TYPE_NORMAL
- en: mers using your code. Bottom line, don’t change the name of a keyword
  prefs: []
  type: TYPE_NORMAL
- en: parameter unless it is absolutely necessary. So, choose wisely!
  prefs: []
  type: TYPE_NORMAL
- en: It’s also very important to use default values that should suit the widest
  prefs: []
  type: TYPE_NORMAL
- en: possible range of users. (On a personal note, I *hate* mustard! Whenever I go
    to Burger King, I have to remember to specify no mustard or I’ll get what I consider
    to be an inedible hamburger. I think they made a bad default choice.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Default Values in GUI Widgets***'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’ll present a collection of classes that you can use to
  prefs: []
  type: TYPE_NORMAL
- en: easily create GUI elements such as buttons and text fields within pygame.
  prefs: []
  type: TYPE_NORMAL
- en: These classes will each be initialized using a few positional parameters but
  prefs: []
  type: TYPE_NORMAL
- en: will also have assorted optional keyword parameters, all with reasonable
  prefs: []
  type: TYPE_NORMAL
- en: defaults to allow programmers to create GUI widgets by specifying only a
  prefs: []
  type: TYPE_NORMAL
- en: few positional arguments. More precise control can be obtained by specify-
  prefs: []
  type: TYPE_NORMAL
- en: ing values to overwrite the default values of keyword parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For an in-depth example, we’ll look at a widget to display text in the
  prefs: []
  type: TYPE_NORMAL
- en: application’s window. Text can be shown in a variety of fonts, font sizes, col-
  prefs: []
  type: TYPE_NORMAL
- en: ors, background colors, and so on. We’ll build a DisplayText class that will
  prefs: []
  type: TYPE_NORMAL
- en: have default values for all of these attributes but will give client code the
  prefs: []
  type: TYPE_NORMAL
- en: option of specifying different values.
  prefs: []
  type: TYPE_NORMAL
- en: '**The pygwidgets Package**'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will focus on the pygwidgets (pronounced “pig
  prefs: []
  type: TYPE_NORMAL
- en: 'wijits”) package, which was written with two goals in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. To demonstrate many different object-oriented programming techniques
  prefs: []
  type: TYPE_NORMAL
- en: 2\. To allow programmers to easily create and use GUI widgets in pygame
  prefs: []
  type: TYPE_NORMAL
- en: programs
  prefs: []
  type: TYPE_NORMAL
- en: 'The pygwidgets package contains the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TextButton**'
  prefs: []
  type: TYPE_NORMAL
- en: Button built with standard art, using a text string
  prefs: []
  type: TYPE_NORMAL
- en: '**CustomButton**'
  prefs: []
  type: TYPE_NORMAL
- en: Button with custom artwork
  prefs: []
  type: TYPE_NORMAL
- en: '**148** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: '**TextCheckBox**'
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox with standard art, built from a text string
  prefs: []
  type: TYPE_NORMAL
- en: '**CustomCheckBox**'
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox with custom artwork
  prefs: []
  type: TYPE_NORMAL
- en: '**TextRadioButton**'
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons with standard art, built from a text string
  prefs: []
  type: TYPE_NORMAL
- en: '**CustomRadioButton**'
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons with custom artwork
  prefs: []
  type: TYPE_NORMAL
- en: '**DisplayText**'
  prefs: []
  type: TYPE_NORMAL
- en: Field used to display output text
  prefs: []
  type: TYPE_NORMAL
- en: '**InputText**'
  prefs: []
  type: TYPE_NORMAL
- en: Field where the user can type text
  prefs: []
  type: TYPE_NORMAL
- en: '**Dragger**'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the user to drag an image
  prefs: []
  type: TYPE_NORMAL
- en: '**Image**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays an image at a location
  prefs: []
  type: TYPE_NORMAL
- en: '**ImageCollection**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays one of a collection of images at a location
  prefs: []
  type: TYPE_NORMAL
- en: '**Animation**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays a sequence of images
  prefs: []
  type: TYPE_NORMAL
- en: '**SpriteSheetAnimation**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays a sequence of images from a single larger image
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up***'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install pygwidgets, open the command line and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m pip install -U pip --user
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m pip install -U pygwidgets --user
  prefs: []
  type: TYPE_NORMAL
- en: These commands download and install the latest version of pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: from the Python Package Index (PyPI). It is placed into a folder (named
  prefs: []
  type: TYPE_NORMAL
- en: '*site-packages*) that is available to all your Python programs. Once installed,
    you can use pygwidgets by including the following statement at the beginning of
    your programs:'
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: This imports the entire package. After importing, you can instantiate
  prefs: []
  type: TYPE_NORMAL
- en: objects from its classes and call the methods of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **149**
  prefs: []
  type: TYPE_NORMAL
- en: The most current documentation of pygwidgets is a[t *https://pygwidgets*](https://pygwidgets.readthedocs.io/en/latest/)
  prefs: []
  type: TYPE_NORMAL
- en: '[*.readthedocs.io/en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).
    If you’d like to view the source code for the package, it’s available via my GitHub
    repository at [*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Overall Design Approach***'
  prefs: []
  type: TYPE_NORMAL
- en: As shown i[n Chapter 5, o](index_split_002.html#p118)ne of the first things
    you do in every pygame program is to define the window of the application. The
    following line creates
  prefs: []
  type: TYPE_NORMAL
- en: 'an application window and saves a reference to it in a variable named window:'
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: As we will soon see, whenever we instantiate any widget, we will need to
  prefs: []
  type: TYPE_NORMAL
- en: pass in the window variable so the widget can draw itself in the application’s
  prefs: []
  type: TYPE_NORMAL
- en: window.
  prefs: []
  type: TYPE_NORMAL
- en: Most widgets in pygwidgets work in a similar way, typically involving
  prefs: []
  type: TYPE_NORMAL
- en: 'these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Before the main while loop starts, create an instance of the widget, pass-
  prefs: []
  type: TYPE_NORMAL
- en: ing in any initialization arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. In the main loop, whenever any event happens, call the handleEvent()
  prefs: []
  type: TYPE_NORMAL
- en: method of the widget (passing in the event object).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. At the bottom of the main loop, call the draw() method of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1 in using any widget is to instantiate one with a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oWidget = pygwidgets. *<SomeWidgetClass>* (window, loc, *<other arguments as
    needed>* ) The first argument is always the window of the application. The second
  prefs: []
  type: TYPE_NORMAL
- en: argument is always the location in the window at which to display the wid-
  prefs: []
  type: TYPE_NORMAL
- en: 'get, given as a tuple: (x, y).'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 is to handle any event that could affect the widget by calling the
  prefs: []
  type: TYPE_NORMAL
- en: object’s handleEvent() method inside the event loop. If any event (like a mouse
  prefs: []
  type: TYPE_NORMAL
- en: click or button press) happens and the widget handles the event, this call will
  prefs: []
  type: TYPE_NORMAL
- en: 'return True. The code at the top of the main while loop generally looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if oWidget.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: The user has done something to oWidget that we should respond to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add code here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 3 is to add a line near the bottom of the while loop to call the
  prefs: []
  type: TYPE_NORMAL
- en: 'draw() method of the widget, to make it appear it in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: oWidget.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '**150** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: Since we specified the window to draw into, the location, and any
  prefs: []
  type: TYPE_NORMAL
- en: details that affect the appearance of the widget in step 1, we don’t pass any-
  prefs: []
  type: TYPE_NORMAL
- en: thing in the call to draw().
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding an Image***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example will be the simplest widget: we’ll use the Image class to
    dis-'
  prefs: []
  type: TYPE_NORMAL
- en: play an image in a window. When you instantiate an Image object, the only
  prefs: []
  type: TYPE_NORMAL
- en: required arguments are the window, the location in the window to draw
  prefs: []
  type: TYPE_NORMAL
- en: the image, and the path to the image file. Create the Image object before the
  prefs: []
  type: TYPE_NORMAL
- en: 'main loop starts, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: oImage = pygwidgets.Image(window, (100, 200), 'images/SomeImage.png')
  prefs: []
  type: TYPE_NORMAL
- en: The path used here assumes that the project folder containing the
  prefs: []
  type: TYPE_NORMAL
- en: main program also contains a folder named *images*, inside which is the
  prefs: []
  type: TYPE_NORMAL
- en: '*SomeImage.png* file. Then, in the main loop you just need to call the object’s
    draw() method:'
  prefs: []
  type: TYPE_NORMAL
- en: oImage.draw()
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method of the Image class contains a call to blit() to actu-
  prefs: []
  type: TYPE_NORMAL
- en: ally draw the image, so you never need to call blit() directly. To move the
  prefs: []
  type: TYPE_NORMAL
- en: image, you can call its setLoc() method (short for set location), specifying
  prefs: []
  type: TYPE_NORMAL
- en: 'the new x- and y-coordinates as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: oImage.setLoc((newX, newY))
  prefs: []
  type: TYPE_NORMAL
- en: The next time the image is drawn, it will show up at the new coordi-
  prefs: []
  type: TYPE_NORMAL
- en: nates. The documentation lists many additional methods that you can call
  prefs: []
  type: TYPE_NORMAL
- en: to flip, rotate, scale, get the image’s location and rectangle, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SPRITE MODULE**'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame has a built-in module to show images in a window, cal ed the *sprite*
  prefs: []
  type: TYPE_NORMAL
- en: '*module* . Such images are cal ed *sprites* . The sprite module provides a
    Sprite class for handling individual sprites and a Group class for handling multiple'
  prefs: []
  type: TYPE_NORMAL
- en: Sprite objects . Together, these classes provide excel ent functionality, and
    if
  prefs: []
  type: TYPE_NORMAL
- en: you intend to do heavy-duty pygame programming, it is probably worth your
  prefs: []
  type: TYPE_NORMAL
- en: time to look into them . However, in order to explain the underlying OOP con-
  prefs: []
  type: TYPE_NORMAL
- en: cepts, I have chosen not to use those classes . Instead, I will proceed with
    gen-
  prefs: []
  type: TYPE_NORMAL
- en: eral GUI elements so that they can be used in any environment and language .
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the sprite module, see the tutorial a[t *ht
    ps://*](https://www.pygame.org/docs/tut/SpriteIntro.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[*www.pygame.org/docs/tut/SpriteIntro.html* .](https://www.pygame.org/docs/tut/SpriteIntro.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **151**
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Buttons, Checkboxes, and Radio Buttons***'
  prefs: []
  type: TYPE_NORMAL
- en: When you instantiate a button, checkbox, or radio button widget in pygwidgets,
  prefs: []
  type: TYPE_NORMAL
- en: 'you have two options: instantiate a text version that draws its own art and'
  prefs: []
  type: TYPE_NORMAL
- en: adds a text label based on a string you pass in, or instantiate a custom ver-
  prefs: []
  type: TYPE_NORMAL
- en: sion where you supply the art. Table 7-1 shows the different button classes
  prefs: []
  type: TYPE_NORMAL
- en: that are available.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Text and Custom Button Classes in pygwidgets'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text version (builds art on**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom version (uses**'
  prefs: []
  type: TYPE_NORMAL
- en: '**the fly)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**your artwork)**'
  prefs: []
  type: TYPE_NORMAL
- en: Button
  prefs: []
  type: TYPE_NORMAL
- en: TextButton
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox
  prefs: []
  type: TYPE_NORMAL
- en: TextCheckBox
  prefs: []
  type: TYPE_NORMAL
- en: CustomCheckBox
  prefs: []
  type: TYPE_NORMAL
- en: Radio button
  prefs: []
  type: TYPE_NORMAL
- en: TextRadioButton
  prefs: []
  type: TYPE_NORMAL
- en: CustomRadioButton
  prefs: []
  type: TYPE_NORMAL
- en: The differences between the text and custom versions of these classes
  prefs: []
  type: TYPE_NORMAL
- en: are only relevant during instantiation. Once you create an object from
  prefs: []
  type: TYPE_NORMAL
- en: a text or custom button class, all the remaining methods of the pair of
  prefs: []
  type: TYPE_NORMAL
- en: classes are identical. To make this clear, let’s take a look at the TextButton
  prefs: []
  type: TYPE_NORMAL
- en: and CustomButton classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**TextButtons**'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the actual definition of the __init__() method of the TextButton class
  prefs: []
  type: TYPE_NORMAL
- en: 'in pygwidgets:'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, window, loc, text,
  prefs: []
  type: TYPE_NORMAL
- en: width=None,
  prefs: []
  type: TYPE_NORMAL
- en: height=40,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=PYGWIDGETS_BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: upColor=PYGWIDGETS_NORMAL_GRAY,
  prefs: []
  type: TYPE_NORMAL
- en: overColor=PYGWIDGETS_OVER_GRAY,
  prefs: []
  type: TYPE_NORMAL
- en: downColor=PYGWIDGETS_DOWN_GRAY,
  prefs: []
  type: TYPE_NORMAL
- en: fontName=DEFAULT_FONT_NAME,
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=DEFAULT_FONT_SIZE,
  prefs: []
  type: TYPE_NORMAL
- en: soundOnClick=None,
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=False,
  prefs: []
  type: TYPE_NORMAL
- en: callback=None
  prefs: []
  type: TYPE_NORMAL
- en: 'nickname=None):'
  prefs: []
  type: TYPE_NORMAL
- en: However, rather than reading through the code of a class, a programmer
  prefs: []
  type: TYPE_NORMAL
- en: will typically refer to its documentation. As mentioned earlier, you can find
  prefs: []
  type: TYPE_NORMAL
- en: the complete documentation for pygwidgets at [*https://pygwidgets.readthedocs.io/*](https://pygwidgets.readthedocs.io/en/latest/)
  prefs: []
  type: TYPE_NORMAL
- en: '[*en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also view documentation of a class by calling the built-in help()
  prefs: []
  type: TYPE_NORMAL
- en: 'function in the Python shell like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(pygwidgets.TextButton)'
  prefs: []
  type: TYPE_NORMAL
- en: '**152** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 24](index-182_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 25](index-182_2.png)'
  prefs: []
  type: TYPE_IMG
- en: When you create an instance of a TextButton, you are only required to pass
  prefs: []
  type: TYPE_NORMAL
- en: in the window, the location in the window, and the text to be shown on the
  prefs: []
  type: TYPE_NORMAL
- en: button. If you only specify these positional parameters, your button will use
  prefs: []
  type: TYPE_NORMAL
- en: reasonable defaults for the width and height, the background colors for the
  prefs: []
  type: TYPE_NORMAL
- en: four states of the button (different shades of gray), the font, and the font
    size.
  prefs: []
  type: TYPE_NORMAL
- en: By default, no sound effect will be played when the user clicks on the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to create a TextButton using all the defaults looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')
  prefs: []
  type: TYPE_NORMAL
- en: The code in the __init__() method of the TextButton class uses the
  prefs: []
  type: TYPE_NORMAL
- en: pygame drawing methods to construct its own art for all four states (up,
  prefs: []
  type: TYPE_NORMAL
- en: down, over, and disabled). The preceding line creates an “up” version of a
  prefs: []
  type: TYPE_NORMAL
- en: button that looks like Figure 7-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-2: A TextButton*'
  prefs: []
  type: TYPE_NORMAL
- en: '*using defaults*'
  prefs: []
  type: TYPE_NORMAL
- en: You can override any or all of the default parameters with keyword val-
  prefs: []
  type: TYPE_NORMAL
- en: 'ues like so:'
  prefs: []
  type: TYPE_NORMAL
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button',
  prefs: []
  type: TYPE_NORMAL
- en: width=200,
  prefs: []
  type: TYPE_NORMAL
- en: height=30,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=(255, 255, 128),
  prefs: []
  type: TYPE_NORMAL
- en: upColor=(128, 0, 0),
  prefs: []
  type: TYPE_NORMAL
- en: fontName='Courier',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=14,
  prefs: []
  type: TYPE_NORMAL
- en: soundOnClick='sounds/blip.wav',
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=True)
  prefs: []
  type: TYPE_NORMAL
- en: This instantiation will create a button that looks like Figure 7-3\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-3: A TextButton using keyword*'
  prefs: []
  type: TYPE_NORMAL
- en: '*arguments for font, size, colors, and so on*'
  prefs: []
  type: TYPE_NORMAL
- en: The image-switching behavior of these two buttons would work exactly
  prefs: []
  type: TYPE_NORMAL
- en: the same way; the only differences would be in the appearance of the images.
  prefs: []
  type: TYPE_NORMAL
- en: '**CustomButtons**'
  prefs: []
  type: TYPE_NORMAL
- en: The CustomButton class allows you to use your own art for a button. To instan-
  prefs: []
  type: TYPE_NORMAL
- en: tiate a CustomButton, you need only pass in a window, a location, and a path
  prefs: []
  type: TYPE_NORMAL
- en: 'to the image of the up state of the button. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: restartButton = pygwidgets.CustomButton(window, (100, 430),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/RestartButtonUp.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **153**
  prefs: []
  type: TYPE_NORMAL
- en: The down, over, and disabled states are optional keyword arguments, and for
    any of these where no value is passed in, CustomButton will use a copy of
  prefs: []
  type: TYPE_NORMAL
- en: the up image. It’s more typical (and strongly suggested) to pass in paths for
  prefs: []
  type: TYPE_NORMAL
- en: 'the optional images, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: restartButton = pygwidgets.CustomButton(window, (100, 430),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/RestartButtonUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: down='images/RestartButtonDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/RestartButtonOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/RestartButtonDisabled.png',
  prefs: []
  type: TYPE_NORMAL
- en: soundOnClick='sounds/blip.wav',
  prefs: []
  type: TYPE_NORMAL
- en: nickname='restart')
  prefs: []
  type: TYPE_NORMAL
- en: Here we also specified a sound effect that should be played when
  prefs: []
  type: TYPE_NORMAL
- en: the user clicks the button, and we provided an internal nickname we can
  prefs: []
  type: TYPE_NORMAL
- en: use later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Buttons**'
  prefs: []
  type: TYPE_NORMAL
- en: After instantiation, here’s some typical code to use a button object, oButton,
  prefs: []
  type: TYPE_NORMAL
- en: 'independent of it being a TextButton or a CustomButton:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if oButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: User has clicked this button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<Any code you want to run here when the button is clicked>*'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'oButton.draw() # at the bottom of the while loop, tell it to draw'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we detect an event, we need to call the handleEvent() method
  prefs: []
  type: TYPE_NORMAL
- en: of the button to allow it to react to the user’s actions. This call normally
  prefs: []
  type: TYPE_NORMAL
- en: returns False but will return True when the user completes a click on the
  prefs: []
  type: TYPE_NORMAL
- en: button. At the bottom of the main while loop, we need to call the draw()
  prefs: []
  type: TYPE_NORMAL
- en: method of the button to allow it to draw itself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Text Output and Input***'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 6, h](index_split_002.html#p150)andling text input and
    output in pygame is tricky, but here I’ll introduce new classes for a text display
    field and an input text
  prefs: []
  type: TYPE_NORMAL
- en: field. Both of these classes have minimal required (positional) parameters,
  prefs: []
  type: TYPE_NORMAL
- en: and they have reasonable defaults for other attributes (font, font size,
  prefs: []
  type: TYPE_NORMAL
- en: color, and so on) that are easily overridden.
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Output**'
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets package contains a DisplayText class for showing text that is
    a
  prefs: []
  type: TYPE_NORMAL
- en: more full-featured version of the SimpleText class fro[m Chapter 6](index_split_002.html#p150).
    When you **154** Chapter 7
  prefs: []
  type: TYPE_NORMAL
- en: instantiate a DisplayText field, the only required arguments are the window
    and the location. The first keyword parameter is value, which may be specified
    with a string as starting text to be shown in the field. This is typically
  prefs: []
  type: TYPE_NORMAL
- en: used for a default end user value or for text that never changes, like a label
  prefs: []
  type: TYPE_NORMAL
- en: or instructions. Since value is the first keyword parameter, it can be given
    as
  prefs: []
  type: TYPE_NORMAL
- en: 'either a positional or a keyword argument. For example, this:'
  prefs: []
  type: TYPE_NORMAL
- en: oTextField = pygwidgets.DisplayText(window, (10, 400), 'Hello World')
  prefs: []
  type: TYPE_NORMAL
- en: 'will work the same way as this:'
  prefs: []
  type: TYPE_NORMAL
- en: oTextField = pygwidgets.DisplayText(window, (10, 400), value='Hello World')
  prefs: []
  type: TYPE_NORMAL
- en: You can also customize the look of the output text by specifying any or
  prefs: []
  type: TYPE_NORMAL
- en: 'all of the optional keyword parameters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: oTextField = pygwidgets.DisplayText(window, (10, 400),
  prefs: []
  type: TYPE_NORMAL
- en: value='Some title text',
  prefs: []
  type: TYPE_NORMAL
- en: fontName='Courier',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=40,
  prefs: []
  type: TYPE_NORMAL
- en: width=150,
  prefs: []
  type: TYPE_NORMAL
- en: justified='center',
  prefs: []
  type: TYPE_NORMAL
- en: textColor=(255, 255, 0))
  prefs: []
  type: TYPE_NORMAL
- en: The DisplayText class has a number of additional methods, the most
  prefs: []
  type: TYPE_NORMAL
- en: important of which is setValue(), which you call to change the text drawn
  prefs: []
  type: TYPE_NORMAL
- en: 'in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: oTextField.setValue('Any new text you want to see')
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the main while loop, you need to call the object’s
  prefs: []
  type: TYPE_NORMAL
- en: 'draw() method:'
  prefs: []
  type: TYPE_NORMAL
- en: oTextField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: And of course, you can create as many DisplayText objects as you wish,
  prefs: []
  type: TYPE_NORMAL
- en: each displaying different text and each with its own font, size, color, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Input**'
  prefs: []
  type: TYPE_NORMAL
- en: In a typical text-based Python program, to get input from the user you
  prefs: []
  type: TYPE_NORMAL
- en: would make a call to the input() function, which stops the program until
  prefs: []
  type: TYPE_NORMAL
- en: the user enters text in the shell window. But in the world of event-driven
  prefs: []
  type: TYPE_NORMAL
- en: GUI programs, the main loop never stops. Therefore, we must use a differ-
  prefs: []
  type: TYPE_NORMAL
- en: ent approach.
  prefs: []
  type: TYPE_NORMAL
- en: For text input from the user, a GUI program typically presents a field
  prefs: []
  type: TYPE_NORMAL
- en: that the user can type in. An input field must deal with all keyboard keys,
  prefs: []
  type: TYPE_NORMAL
- en: some of which show while others are used for editing or cursor movement
  prefs: []
  type: TYPE_NORMAL
- en: within the field. It must also allow for the user holding down a key to repeat
  prefs: []
  type: TYPE_NORMAL
- en: it. The pygwidgets InputText class provides all this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **155**
  prefs: []
  type: TYPE_NORMAL
- en: 'The only required arguments to instantiate an InputText object are the window
    and a location:'
  prefs: []
  type: TYPE_NORMAL
- en: oInputField = pygwidgets.InputText(window, (10, 100))
  prefs: []
  type: TYPE_NORMAL
- en: However, you can customize the text attributes of an InputText object by
  prefs: []
  type: TYPE_NORMAL
- en: 'specifying optional keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: oInputField = pygwidgets.InputText(window, (10, 400),
  prefs: []
  type: TYPE_NORMAL
- en: value='Starting Text',
  prefs: []
  type: TYPE_NORMAL
- en: fontName='Helvetica',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=40,
  prefs: []
  type: TYPE_NORMAL
- en: width=150,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=(255, 255, 0))
  prefs: []
  type: TYPE_NORMAL
- en: After instantiating an InputText field, the typical code in the main loop
  prefs: []
  type: TYPE_NORMAL
- en: 'would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if oInputField.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: User has pressed Enter or Return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'userText = oInputField.getValue() # get the text the user entered'
  prefs: []
  type: TYPE_NORMAL
- en: '*<Any code you want to run using the user''s input>*'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'oInputField.draw() # at the bottom of the main while loop'
  prefs: []
  type: TYPE_NORMAL
- en: For every event, we need to call the handleEvent() method of the InputText
  prefs: []
  type: TYPE_NORMAL
- en: field to allow it to react to keystrokes and mouse clicks. This call normally
  prefs: []
  type: TYPE_NORMAL
- en: returns False, but when the user presses ENTER or RETURN, it returns True.
  prefs: []
  type: TYPE_NORMAL
- en: We can then retrieve the text that the user entered by calling the getValue()
  prefs: []
  type: TYPE_NORMAL
- en: method of the object.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the main while loop, we need to call the draw() method
  prefs: []
  type: TYPE_NORMAL
- en: to allow the field to draw itself.
  prefs: []
  type: TYPE_NORMAL
- en: If a window contains multiple input fields, key presses are handled by
  prefs: []
  type: TYPE_NORMAL
- en: the field with current keyboard focus, which is changed when a user clicks
  prefs: []
  type: TYPE_NORMAL
- en: in a different field. If you want to allow a field to have initial keyboard
    focus,
  prefs: []
  type: TYPE_NORMAL
- en: then you can set the initialFocus keyword parameter to True in the InputText
  prefs: []
  type: TYPE_NORMAL
- en: object of your choice when you create that object. Further, if you have mul-
  prefs: []
  type: TYPE_NORMAL
- en: tiple InputText fields in a window, a typical user interface design approach
    is
  prefs: []
  type: TYPE_NORMAL
- en: to include an OK or Submit button. When this button is clicked, you could
  prefs: []
  type: TYPE_NORMAL
- en: then call the getValue() method of each field.
  prefs: []
  type: TYPE_NORMAL
- en: '**156** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*At the time of writing, the InputText class does not handle highlighting multiple*
    *characters by dragging the mouse. If this functionality is added in a later version,*
    *no change will be required to programs that use InputText because the code will
    be* *entirely within that class. Any new behavior will be supported automatically
    in all* *InputText objects.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Other pygwidgets Classes***'
  prefs: []
  type: TYPE_NORMAL
- en: As you saw at the beginning of this section, pygwidgets contains a number of
  prefs: []
  type: TYPE_NORMAL
- en: other classes.
  prefs: []
  type: TYPE_NORMAL
- en: The ImageCollection class allows you to show any single image from a
  prefs: []
  type: TYPE_NORMAL
- en: collection of images. For example, suppose you have images of a character
  prefs: []
  type: TYPE_NORMAL
- en: facing front, left, back, and right. To represent all the potential images,
    you
  prefs: []
  type: TYPE_NORMAL
- en: 'can build a dictionary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: imageDict = {'front':'images/front.png', 'left':'images/left.png',
  prefs: []
  type: TYPE_NORMAL
- en: '''back'':''images/back.png'', ''right'':''images/right.png''}'
  prefs: []
  type: TYPE_NORMAL
- en: You can then create an ImageCollection object, specifying this dictionary
  prefs: []
  type: TYPE_NORMAL
- en: and the key of the image you want to start with. To change to a different
  prefs: []
  type: TYPE_NORMAL
- en: image, you call the replace() method and pass in a different key. Calling the
  prefs: []
  type: TYPE_NORMAL
- en: draw() method at the bottom of the loop always shows the current image.
  prefs: []
  type: TYPE_NORMAL
- en: The Dragger class displays a single image but allows the user to drag the
  prefs: []
  type: TYPE_NORMAL
- en: image anywhere in the window. You must call its handleEvent() method in
  prefs: []
  type: TYPE_NORMAL
- en: the event loop. When the user finishes dragging, handleEvent() returns True,
  prefs: []
  type: TYPE_NORMAL
- en: and you can call the Dragger object’s getMouseUpLoc() method to get the loca-
  prefs: []
  type: TYPE_NORMAL
- en: tion where the user released the mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: The Animation and SpriteSheetAnimation classes handle building and
  prefs: []
  type: TYPE_NORMAL
- en: showing an animation. Both require a set of images to iterate through.
  prefs: []
  type: TYPE_NORMAL
- en: The Animation class gets the images from individual files, while the
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation class requires a single image with evenly spaced internal
  prefs: []
  type: TYPE_NORMAL
- en: images. We’ll explore these classes more fully i[n Chapter 14\.](index_split_005.html#p324)
  prefs: []
  type: TYPE_NORMAL
- en: '***pygwidgets Example Program***'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7-4 shows a screenshot of a sample program that demonstrates
  prefs: []
  type: TYPE_NORMAL
- en: objects instantiated from many of the classes in pygwidgets, including Image,
  prefs: []
  type: TYPE_NORMAL
- en: DisplayText, InputText, TextButton, CustomButton, TextRadioButton, CustomRadioButton,
    TextCheckBox, CustomCheckBox, ImageCollection, and Dragger.
  prefs: []
  type: TYPE_NORMAL
- en: The source of this example program can be found in the *pygwidgets_test*
  prefs: []
  type: TYPE_NORMAL
- en: folder in my GitHub repository, [*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **157**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 26](index-187_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: The window of a program that demonstrates objects instantiated*'
  prefs: []
  type: TYPE_NORMAL
- en: '*from a variety of pygwidgets classes*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Importance of a Consistent API**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note about building an API for a set of classes: whenever possible,'
  prefs: []
  type: TYPE_NORMAL
- en: it’s a very good idea to build consistency into the parameters of methods in
  prefs: []
  type: TYPE_NORMAL
- en: different, but similar, classes. As a good example, the first two parameters
  prefs: []
  type: TYPE_NORMAL
- en: to the __init__() method of every class in pygwidgets are window and loc, in
  prefs: []
  type: TYPE_NORMAL
- en: that order. If these had been in a different order in some calls, using the
  prefs: []
  type: TYPE_NORMAL
- en: package as a whole would be much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if different classes implement the same functionality, it’s a
  prefs: []
  type: TYPE_NORMAL
- en: good idea to use the same method names. For example, many of the classes
  prefs: []
  type: TYPE_NORMAL
- en: in pygwidgets have a method named setValue() and another named getValue().
  prefs: []
  type: TYPE_NORMAL
- en: I’ll talk more about why this type of consistency is so important in the next
  prefs: []
  type: TYPE_NORMAL
- en: two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided an introduction to the object-oriented pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: package of graphical user interface widgets. We began by discussing default
  prefs: []
  type: TYPE_NORMAL
- en: values for parameters in methods, and I explained that a keyword param-
  prefs: []
  type: TYPE_NORMAL
- en: eter allows for a default value to be used if no matching argument value is
  prefs: []
  type: TYPE_NORMAL
- en: specified in a call.
  prefs: []
  type: TYPE_NORMAL
- en: '**158** Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: I then introduced you to the pygwidgets module, which contains a number of prebuilt
    GUI widget classes, and showed you how to use several of
  prefs: []
  type: TYPE_NORMAL
- en: these. Finally, I showed a sample program that provides examples of most of
  prefs: []
  type: TYPE_NORMAL
- en: these widgets.
  prefs: []
  type: TYPE_NORMAL
- en: There are two key advantages to writing classes like those in pygwidgets.
  prefs: []
  type: TYPE_NORMAL
- en: First, classes can hide complexity in methods. Once you have your class
  prefs: []
  type: TYPE_NORMAL
- en: working correctly, you never have to worry about the internal details again.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can reuse the code by creating as many instances of a class as
  prefs: []
  type: TYPE_NORMAL
- en: you need. Your classes can provide basic functionality by including keyword
  prefs: []
  type: TYPE_NORMAL
- en: parameters with well-chosen default values. However, the default values can
  prefs: []
  type: TYPE_NORMAL
- en: easily be overwritten to allow for customization.
  prefs: []
  type: TYPE_NORMAL
- en: You can publish the interfaces of your classes for other programmers
  prefs: []
  type: TYPE_NORMAL
- en: (and yourself) to take advantage of in different projects. Good documen-
  prefs: []
  type: TYPE_NORMAL
- en: tation and consistency go a long way toward making these types of classes
  prefs: []
  type: TYPE_NORMAL
- en: highly usable.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **159**
  prefs: []
  type: TYPE_NORMAL
- en: '**PART III**'
  prefs: []
  type: TYPE_NORMAL
- en: '**E N C A P S U L A T I O N ,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**P O LY M O R P H I S M , A N D**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I N H E R I T A N C E**'
  prefs: []
  type: TYPE_NORMAL
- en: The three main tenets of object-oriented program-
  prefs: []
  type: TYPE_NORMAL
- en: ming are encapsulation, polymorphism, and inheri-
  prefs: []
  type: TYPE_NORMAL
- en: tance. The next three chapters will explain each of
  prefs: []
  type: TYPE_NORMAL
- en: these in turn, describing the underlying concepts and
  prefs: []
  type: TYPE_NORMAL
- en: showing examples of how they are implemented in
  prefs: []
  type: TYPE_NORMAL
- en: Python. In order for a programming language to call
  prefs: []
  type: TYPE_NORMAL
- en: itself an OOP language, it must support all three of
  prefs: []
  type: TYPE_NORMAL
- en: these central requirements. (If you’re ever asked in an
  prefs: []
  type: TYPE_NORMAL
- en: interview about the requirements for a language to be
  prefs: []
  type: TYPE_NORMAL
- en: 'object-oriented, here’s an easy way to remember them:'
  prefs: []
  type: TYPE_NORMAL
- en: it’s as easy as PIE!)
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8 e](#p192)xplains encapsulation: hiding the details and keeping everything
    in one place.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9 d](#p212)iscusses polymorphism: how multiple classes can have methods
    with the same names.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10 c](index_split_004.html#p240)overs inheritance: building on code
    that already exists.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally[, Chapter 11 g](index_split_004.html#p270)oes into detail on a number
    of topics (mostly dealing with memory management) that do not logically fit into
    the previous
  prefs: []
  type: TYPE_NORMAL
- en: three chapters but are useful and important to OOP.
  prefs: []
  type: TYPE_NORMAL
- en: '**8**'
  prefs: []
  type: TYPE_NORMAL
- en: '**E N C A P S U L A T I O N**'
  prefs: []
  type: TYPE_NORMAL
- en: The first of the three main tenets of object-
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming is *encapsulation*. This
  prefs: []
  type: TYPE_NORMAL
- en: word might conjure up an image of a space
  prefs: []
  type: TYPE_NORMAL
- en: capsule, a cell wall, or a medicine gelcap, where
  prefs: []
  type: TYPE_NORMAL
- en: the precious cargo inside is protected from the outside
  prefs: []
  type: TYPE_NORMAL
- en: environment. In programming, encapsulation has a
  prefs: []
  type: TYPE_NORMAL
- en: 'similar but even more detailed meaning: hiding inter-'
  prefs: []
  type: TYPE_NORMAL
- en: nal details of state and behavior from any external
  prefs: []
  type: TYPE_NORMAL
- en: code and having all code in one place.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll see how encapsulation works with functions, then
  prefs: []
  type: TYPE_NORMAL
- en: with methods of objects. I’ll discuss different interpretations of encapsu-
  prefs: []
  type: TYPE_NORMAL
- en: 'lation: using direct access versus using getters and setters. I’ll show how'
  prefs: []
  type: TYPE_NORMAL
- en: Python allows you to mark an instance variable as private, indicating that
  prefs: []
  type: TYPE_NORMAL
- en: it should not be accessed by code external to a class, and I’ll touch on the
  prefs: []
  type: TYPE_NORMAL
- en: Python property decorator. Finally, I’ll discuss the concept of abstraction
    in
  prefs: []
  type: TYPE_NORMAL
- en: the design of classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation with Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are a prime example of encapsulation because when you call a
  prefs: []
  type: TYPE_NORMAL
- en: function, you generally don’t care *how* the function works internally. A well-written
    function contains a series of steps that make up a larger single task,
  prefs: []
  type: TYPE_NORMAL
- en: which you do care about. The name of the function should describe the
  prefs: []
  type: TYPE_NORMAL
- en: action that its code embodies. Consider the built-in len() function from the
  prefs: []
  type: TYPE_NORMAL
- en: Python Standard Library, used to find the number of characters in a string
  prefs: []
  type: TYPE_NORMAL
- en: or elements in a list. You pass in a string or list, and it returns the count.
  prefs: []
  type: TYPE_NORMAL
- en: When you write code that calls this function, you don’t care how len() does
  prefs: []
  type: TYPE_NORMAL
- en: what it does. You don’t stop to think about whether the code of the function
  prefs: []
  type: TYPE_NORMAL
- en: contains two lines or two thousand lines, whether it uses one local variable
  prefs: []
  type: TYPE_NORMAL
- en: or a hundred. You just need to know what argument to pass in and how to
  prefs: []
  type: TYPE_NORMAL
- en: use the result that’s returned.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true of functions that you write, like this function that cal-
  prefs: []
  type: TYPE_NORMAL
- en: 'culates and returns the average of a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculateAverage(numbersList):'
  prefs: []
  type: TYPE_NORMAL
- en: total = 0.0
  prefs: []
  type: TYPE_NORMAL
- en: 'for number in numbersList:'
  prefs: []
  type: TYPE_NORMAL
- en: total = total + number
  prefs: []
  type: TYPE_NORMAL
- en: nElements = len(numbersList)
  prefs: []
  type: TYPE_NORMAL
- en: average = total / nElements
  prefs: []
  type: TYPE_NORMAL
- en: return average
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve tested a function like this and found that it works, you
  prefs: []
  type: TYPE_NORMAL
- en: no longer have to worry about the details of the implementation. You
  prefs: []
  type: TYPE_NORMAL
- en: only need to know what argument(s) to send into the function and what it
  prefs: []
  type: TYPE_NORMAL
- en: returns.
  prefs: []
  type: TYPE_NORMAL
- en: However, if one day you find that there is a much simpler or faster algo-
  prefs: []
  type: TYPE_NORMAL
- en: rithm to calculate an average, you could rewrite the function in a new way.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the interface (the inputs and outputs) does not change, there is
  prefs: []
  type: TYPE_NORMAL
- en: no need to change any calls to the function. This type of modularization
  prefs: []
  type: TYPE_NORMAL
- en: makes the code more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation with Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike variables used in regular functions, instance variables in objects per-
  prefs: []
  type: TYPE_NORMAL
- en: sist across different method calls. To keep the remaining discussion clear,
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll introduce a new term: *client*. (I don’t want to use the term *user* here
    since that typically refers to the human user of the final program.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**client**'
  prefs: []
  type: TYPE_NORMAL
- en: Any software that creates an object from a class and makes calls to the methods
    of
  prefs: []
  type: TYPE_NORMAL
- en: that object .
  prefs: []
  type: TYPE_NORMAL
- en: We must also consider the duality of *inside* versus *outside* an object or
    class. When you’re working inside a class (writing the code of the methods
  prefs: []
  type: TYPE_NORMAL
- en: in a class), you need to concern yourself with how the different methods of
  prefs: []
  type: TYPE_NORMAL
- en: '**164** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'the class share the instance variables. You consider the efficiency of your
    algorithms. You think about what the interface should look like: what methods
    you should provide, what the parameters for each are, and what should'
  prefs: []
  type: TYPE_NORMAL
- en: be used as default values. In short, you are concerned with the design and
  prefs: []
  type: TYPE_NORMAL
- en: implementation of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: From the outside, as a client programmer, you need to know the inter-
  prefs: []
  type: TYPE_NORMAL
- en: face of the class. You’re concerned with what the class methods do, what
  prefs: []
  type: TYPE_NORMAL
- en: arguments should be passed in, and what data is passed back from each
  prefs: []
  type: TYPE_NORMAL
- en: method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class therefore provides encapsulation by:'
  prefs: []
  type: TYPE_NORMAL
- en: • Hiding all details of implementation in its methods and instance
  prefs: []
  type: TYPE_NORMAL
- en: variables
  prefs: []
  type: TYPE_NORMAL
- en: • Providing all the functionality a client needs from an object through its
  prefs: []
  type: TYPE_NORMAL
- en: interface (the methods defined in the class)
  prefs: []
  type: TYPE_NORMAL
- en: '***Objects Own Their Data***'
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, we say that the data inside an object is
  prefs: []
  type: TYPE_NORMAL
- en: '*owned* by the object. OOP programmers generally agree that, as a good'
  prefs: []
  type: TYPE_NORMAL
- en: design principle, client code should only be concerned with the interface
  prefs: []
  type: TYPE_NORMAL
- en: of a class and should not care about the implementation of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of a simple Person class in Listing 8-1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'class Person():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, salary):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: self.salary = salary
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-1: Data ownership in the Person class*'
  prefs: []
  type: TYPE_NORMAL
- en: The values of the instance variables self.name and self.salary are set
  prefs: []
  type: TYPE_NORMAL
- en: 'whenever we instantiate new Person objects, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oPerson1 = Person('Joe Schmoe', 90000)
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2 = Person('Jane Smith', 99000)
  prefs: []
  type: TYPE_NORMAL
- en: Each Person object owns its own set of the two instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interpretations of Encapsulation**'
  prefs: []
  type: TYPE_NORMAL
- en: Here is where things get a little controversial. Different programmers
  prefs: []
  type: TYPE_NORMAL
- en: have different views about the accessibility of an instance variable. Python
  prefs: []
  type: TYPE_NORMAL
- en: provides for a loose interpretation of encapsulation by allowing direct
  prefs: []
  type: TYPE_NORMAL
- en: access to instance variables using simple dot syntax. Client code can
  prefs: []
  type: TYPE_NORMAL
- en: legally access an instance variable of an object by name using the syntax
  prefs: []
  type: TYPE_NORMAL
- en: '*<object>* . *<instanceVariableName>* .'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **165**
  prefs: []
  type: TYPE_NORMAL
- en: However, a *strict* interpretation of encapsulation says that client software
    should never be able to retrieve or change the value of an instance variable
  prefs: []
  type: TYPE_NORMAL
- en: directly. Instead, the only way that a client can retrieve or change a value
  prefs: []
  type: TYPE_NORMAL
- en: held in an object is to use a method provided by the class for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '***Direct Access and Why You Should Avoid It***'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, Python does allow direct access to instance variables. Listing
    8-2
  prefs: []
  type: TYPE_NORMAL
- en: instantiates the same two objects from the Person class in Listing 8-1 as in
    the
  prefs: []
  type: TYPE_NORMAL
- en: previous section, but then accesses their self.salary instance variables directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PersonGettersSettersAndDirectAccess/Main_PersonDirectAccess.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Person example main program using direct access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Person import *
  prefs: []
  type: TYPE_NORMAL
- en: oPerson1 = Person('Joe Schmoe', 90000)
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2 = Person('Jane Smith', 99000)
  prefs: []
  type: TYPE_NORMAL
- en: Get the values of the salary variable directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 print(oPerson1.salary)
  prefs: []
  type: TYPE_NORMAL
- en: print(oPerson2.salary)
  prefs: []
  type: TYPE_NORMAL
- en: Change the salary variable directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 oPerson1.salary = 100000
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2.salary = 111111
  prefs: []
  type: TYPE_NORMAL
- en: Get the updated salaries and print again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print(oPerson1.salary)
  prefs: []
  type: TYPE_NORMAL
- en: print(oPerson2.salary)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-2: Example main code using direct access to an instance variable*'
  prefs: []
  type: TYPE_NORMAL
- en: Python allows you to write code like this that reaches into an object to
  prefs: []
  type: TYPE_NORMAL
- en: directly get 1 and set 2 any instance variable using standard dot syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Most Python programmers feel that this technique is perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Guido van Rossum (the creator of Python) famously said in refer-
  prefs: []
  type: TYPE_NORMAL
- en: ence to this issue, “We are all adults here,” meaning that programmers
  prefs: []
  type: TYPE_NORMAL
- en: should know what they are doing, and the risks involved, when they attempt
  prefs: []
  type: TYPE_NORMAL
- en: to access instance variables directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, I strongly believe that directly accessing an instance variable
  prefs: []
  type: TYPE_NORMAL
- en: of an object is an extremely dangerous practice, as it breaks the core idea
  prefs: []
  type: TYPE_NORMAL
- en: of encapsulation. To illustrate why this is the case, let’s take a look at a
    few
  prefs: []
  type: TYPE_NORMAL
- en: example scenarios where direct access can be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the Name of an Instance Variable**'
  prefs: []
  type: TYPE_NORMAL
- en: The first problem with direct access is that changing the name of an
  prefs: []
  type: TYPE_NORMAL
- en: instance variable will break any client code that uses the original name
  prefs: []
  type: TYPE_NORMAL
- en: '**166** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: directly. This can happen when the developer of a class decides that the initial
    choice of the name of the variable was not optimal, for reasons such as
  prefs: []
  type: TYPE_NORMAL
- en: 'the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • The name doesn’t describe the data it represents clearly enough.
  prefs: []
  type: TYPE_NORMAL
- en: • The variable is a Boolean, and they want to swap what True and False
  prefs: []
  type: TYPE_NORMAL
- en: represent by renaming the variable (for example, closed to open, allowed
  prefs: []
  type: TYPE_NORMAL
- en: to disallowed, active to disabled).
  prefs: []
  type: TYPE_NORMAL
- en: • There was a spelling or capitalization mistake in the original name.
  prefs: []
  type: TYPE_NORMAL
- en: • The variable was originally a Boolean, but they later realize that they
  prefs: []
  type: TYPE_NORMAL
- en: need to represent more than two values.
  prefs: []
  type: TYPE_NORMAL
- en: In any of these cases, if the developer changes the name of an instance
  prefs: []
  type: TYPE_NORMAL
- en: variable in the class from self. *<originalName>* to self. *<newName>* , then
    any client software that uses the original name directly will break.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing an Instance Variable into a Calculation**'
  prefs: []
  type: TYPE_NORMAL
- en: A second situation where direct access is problematic is when the code of
  prefs: []
  type: TYPE_NORMAL
- en: a class needs to change to meet new requirements. Suppose that when
  prefs: []
  type: TYPE_NORMAL
- en: writing a class, you use an instance variable to represent a piece of data,
  prefs: []
  type: TYPE_NORMAL
- en: but the functionality changes so that you need an algorithm to compute a
  prefs: []
  type: TYPE_NORMAL
- en: value instead. Take our Account class fro[m Chapter 4, f](index_split_001.html#p86)or
    example. To make our bank accounts more realistic, we might want to add an interest
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: You might think this is a simple matter of adding an instance variable for
  prefs: []
  type: TYPE_NORMAL
- en: the interest rate named self.interestRate. Then, using the direct access
  prefs: []
  type: TYPE_NORMAL
- en: 'approach, client software could access this value of an Account object using:'
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.interestRate
  prefs: []
  type: TYPE_NORMAL
- en: This would work, for a while. But later the bank might decide on a new
  prefs: []
  type: TYPE_NORMAL
- en: policy—say that the interest rate will depend on the amount of money in
  prefs: []
  type: TYPE_NORMAL
- en: 'the account. The interest rate might be calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculateInterestRate(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming self.balance has been set in another method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.balance < 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: self.interestRate = 1.0
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.balance < 5000:'
  prefs: []
  type: TYPE_NORMAL
- en: self.interestRate = 1.5
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.interestRate = 2.0
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just relying on a single interest rate value in self.interestRate,
  prefs: []
  type: TYPE_NORMAL
- en: the calculateInterestRate() method determines the current rate based on the
  prefs: []
  type: TYPE_NORMAL
- en: account balance.
  prefs: []
  type: TYPE_NORMAL
- en: Any client software that directly accesses oAccount.interestRate and
  prefs: []
  type: TYPE_NORMAL
- en: uses the value of the instance variable might then get an outdated value,
  prefs: []
  type: TYPE_NORMAL
- en: depending on the last time calculateInterestRate() was called. And any
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **167**
  prefs: []
  type: TYPE_NORMAL
- en: client software that *sets* a new interestRate may find that the new value is
    mysteriously changed by some other code that calls calculateInterestRate()
  prefs: []
  type: TYPE_NORMAL
- en: or when the bank account owner makes a deposit or withdrawal.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the interest calculation method was named getInterestRate()
  prefs: []
  type: TYPE_NORMAL
- en: and client software called that instead, the interest rate would always be cal-
  prefs: []
  type: TYPE_NORMAL
- en: culated on the fly and there would be no potential error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating Data**'
  prefs: []
  type: TYPE_NORMAL
- en: The third reason to avoid direct access when setting a value is that client
  prefs: []
  type: TYPE_NORMAL
- en: code can too easily set an instance variable to an invalid value. A better
  prefs: []
  type: TYPE_NORMAL
- en: approach is to call a method in the class, whose job is to set the value. As
  prefs: []
  type: TYPE_NORMAL
- en: the developer, you can include validation code in that method to ensure
  prefs: []
  type: TYPE_NORMAL
- en: that the value being set is appropriate. Consider the code in Listing 8-3,
  prefs: []
  type: TYPE_NORMAL
- en: whose purpose is to manage the members of a club.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: ValidatingData_ClubExample/Club.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Club class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Club():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, clubName, maxMembers):'
  prefs: []
  type: TYPE_NORMAL
- en: self.clubName = clubName 1
  prefs: []
  type: TYPE_NORMAL
- en: self.maxMembers = maxMembers
  prefs: []
  type: TYPE_NORMAL
- en: self.membersList = []
  prefs: []
  type: TYPE_NORMAL
- en: 'def addMember(self, name): 2'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that there is enough room left
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if len(self.membersList) < self.maxMembers:'
  prefs: []
  type: TYPE_NORMAL
- en: self.membersList.append(name)
  prefs: []
  type: TYPE_NORMAL
- en: print('OK.', name, 'has been added to the', self.clubName, 'club')
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, but we cannot add', name, 'to the', self.clubName, 'club.')
  prefs: []
  type: TYPE_NORMAL
- en: print('This club already has the maximum of', self.maxMembers, 'members.')
  prefs: []
  type: TYPE_NORMAL
- en: 'def report(self): 3'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print('Here are the', len(self.membersList), 'members of the', self.clubName,
  prefs: []
  type: TYPE_NORMAL
- en: '''club:'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'for name in self.membersList:'
  prefs: []
  type: TYPE_NORMAL
- en: print(' ' + name)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-3: An example of a Club class*'
  prefs: []
  type: TYPE_NORMAL
- en: The Club code keeps track of the name of the club, the maximum num-
  prefs: []
  type: TYPE_NORMAL
- en: ber of members, and the list of members, all in instance variables 1\. Once
  prefs: []
  type: TYPE_NORMAL
- en: instantiated, you can call methods to add a member to the club 2 and to
  prefs: []
  type: TYPE_NORMAL
- en: report the members of the club 3\. (We could easily add more methods to
  prefs: []
  type: TYPE_NORMAL
- en: '**168** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: remove members, change names, and so on, but these two are good enough the make
    the point.)
  prefs: []
  type: TYPE_NORMAL
- en: Here is some test code that uses the Club class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: ValidatingData_ClubExample/Main_Club.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Club example main program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Club import *
  prefs: []
  type: TYPE_NORMAL
- en: Create a club with at most 5 members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oProgrammingClub = Club('Programming', 5)
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Joe Schmoe')
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Cindy Lou Hoo')
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Dino Richmond')
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Susie Sweetness')
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Fred Farkle')
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.report()
  prefs: []
  type: TYPE_NORMAL
- en: We create a Programming club that allows a maximum of five members
  prefs: []
  type: TYPE_NORMAL
- en: and then we add five members. The code runs well and reports the mem-
  prefs: []
  type: TYPE_NORMAL
- en: 'bers added to the club:'
  prefs: []
  type: TYPE_NORMAL
- en: OK. Joe Schmoe has been added to the Programming club
  prefs: []
  type: TYPE_NORMAL
- en: OK. Cindy Lou Hoo has been added to the Programming club
  prefs: []
  type: TYPE_NORMAL
- en: OK. Dino Richmond has been added to the Programming club
  prefs: []
  type: TYPE_NORMAL
- en: OK. Susie Sweetness has been added to the Programming club
  prefs: []
  type: TYPE_NORMAL
- en: OK. Fred Farkle has been added to the Programming club
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try to add a sixth member:'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to add additional member
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Iwanna Join')
  prefs: []
  type: TYPE_NORMAL
- en: This attempt to add a member is rejected, and we see an appropriate
  prefs: []
  type: TYPE_NORMAL
- en: 'error message:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorry, but we cannot add Iwanna Join to the Programming club.
  prefs: []
  type: TYPE_NORMAL
- en: This club already has the maximum of 5 members.
  prefs: []
  type: TYPE_NORMAL
- en: The code of addMember() does all the validation needed to ensure that
  prefs: []
  type: TYPE_NORMAL
- en: a call to add a new member works correctly or generates an error message.
  prefs: []
  type: TYPE_NORMAL
- en: However, with direct access, a client could change the fundamental nature
  prefs: []
  type: TYPE_NORMAL
- en: of the Club class. For example, a client could maliciously or accidentally
  prefs: []
  type: TYPE_NORMAL
- en: 'change the maximum number of members:'
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.maxMembers = 300
  prefs: []
  type: TYPE_NORMAL
- en: Further, suppose you know that the Club class represents the members
  prefs: []
  type: TYPE_NORMAL
- en: as a list, and you know the name of the instance variable that represents the
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **169**
  prefs: []
  type: TYPE_NORMAL
- en: 'members. In that case you can write client code to add to the list of members
    directly, without making the method call, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.memberList.append('Iwanna Join')
  prefs: []
  type: TYPE_NORMAL
- en: This line would push the membership over the intended limit because
  prefs: []
  type: TYPE_NORMAL
- en: it avoids the code that ensures that the request to add the member is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Client code using direct access could even cause an error inside the
  prefs: []
  type: TYPE_NORMAL
- en: Club object. For example, the instance variable self.maxMembers is intended
  prefs: []
  type: TYPE_NORMAL
- en: to be an integer. Using direct access, client code could change its value to
    a
  prefs: []
  type: TYPE_NORMAL
- en: string. Any subsequent call to addMember() would crash at the first line of
    that
  prefs: []
  type: TYPE_NORMAL
- en: method, where it attempts to compare the length of the list of members
  prefs: []
  type: TYPE_NORMAL
- en: against the maximum number of members, because Python cannot com-
  prefs: []
  type: TYPE_NORMAL
- en: pare an integer to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing direct access to instance variables from outside an object can
  prefs: []
  type: TYPE_NORMAL
- en: be dangerous, bypassing safeguards that were designed to protect the data
  prefs: []
  type: TYPE_NORMAL
- en: of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strict Interpretation with Getters and Setters***'
  prefs: []
  type: TYPE_NORMAL
- en: The strict approach to encapsulation says that client code *never* accesses
    an instance variable directly. If a class wants to allow client software to access
  prefs: []
  type: TYPE_NORMAL
- en: the information held inside an object, the standard approach is to include a
  prefs: []
  type: TYPE_NORMAL
- en: '*getter* and a *setter* method in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**getter**'
  prefs: []
  type: TYPE_NORMAL
- en: A method that retrieves data from an object instantiated from a class .
  prefs: []
  type: TYPE_NORMAL
- en: '**setter**'
  prefs: []
  type: TYPE_NORMAL
- en: A method that assigns data into an object instantiated from a class .
  prefs: []
  type: TYPE_NORMAL
- en: Getter and setter methods are designed to allow writers of client soft-
  prefs: []
  type: TYPE_NORMAL
- en: ware to get data from and set data in an object, without needing explicit
  prefs: []
  type: TYPE_NORMAL
- en: knowledge of the implementation of a class—specifically, without having
  prefs: []
  type: TYPE_NORMAL
- en: to know or use the name of any instance variable. The Person class code
  prefs: []
  type: TYPE_NORMAL
- en: in Listing 8-1 has an instance variable self.salary. In Listing 8-4 we add a
  prefs: []
  type: TYPE_NORMAL
- en: getter and a setter to the Person class to allow the caller to get and set the
  prefs: []
  type: TYPE_NORMAL
- en: salary, without providing direct access to the Person’s self.salary instance
  prefs: []
  type: TYPE_NORMAL
- en: variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PersonGettersSettersAndDirectAccess/Person.py**'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Person():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, salary):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: self.salary = salary
  prefs: []
  type: TYPE_NORMAL
- en: Allow the caller to retrieve the salary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1 def getSalary(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '**170** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: return self.salary
  prefs: []
  type: TYPE_NORMAL
- en: Allow the caller to set a new salary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 def setSalary(self, salary):'
  prefs: []
  type: TYPE_NORMAL
- en: self.salary = salary
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-4: An example of a Person class with a get er and a set er*'
  prefs: []
  type: TYPE_NORMAL
- en: The get 1 and set 2 portions of these method names are not required
  prefs: []
  type: TYPE_NORMAL
- en: but are used by convention. You generally follow these words with a descrip-
  prefs: []
  type: TYPE_NORMAL
- en: tion of the data being accessed, in this case Salary. While it is typical to
  prefs: []
  type: TYPE_NORMAL
- en: use the name of the instance variable being accessed, this is also not a
  prefs: []
  type: TYPE_NORMAL
- en: requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-5 shows some test code that instantiates two Person objects,
  prefs: []
  type: TYPE_NORMAL
- en: then gets and sets their salaries using these getter and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PersonGettersSettersAndDirectAccess/Main_PersonGetterSetter.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Person example main program using getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Person import *
  prefs: []
  type: TYPE_NORMAL
- en: 1 oPerson1 = Person('Joe Schmoe', 90000)
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2 = Person('Jane Smith', 99000)
  prefs: []
  type: TYPE_NORMAL
- en: Get the salaries using getter and print
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 print(oPerson1.getSalary())
  prefs: []
  type: TYPE_NORMAL
- en: print(oPerson2.getSalary())
  prefs: []
  type: TYPE_NORMAL
- en: Change the salaries using setter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 oPerson1.setSalary(100000)
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2.setSalary(111111)
  prefs: []
  type: TYPE_NORMAL
- en: Get the salaries and print again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print(oPerson1.getSalary())
  prefs: []
  type: TYPE_NORMAL
- en: print(oPerson2.getSalary())
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-5: Example main code using get er and set er methods*'
  prefs: []
  type: TYPE_NORMAL
- en: First we create two Person objects from the Person class 1\. Then we use
  prefs: []
  type: TYPE_NORMAL
- en: the getter and setter methods to retrieve 2 and change 3 the salaries in
  prefs: []
  type: TYPE_NORMAL
- en: the Person objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters provide a formal way to get and set values in an
  prefs: []
  type: TYPE_NORMAL
- en: object. They enforce a layer of protection that only allows access to instance
  prefs: []
  type: TYPE_NORMAL
- en: variables if the class writer wants to allow it.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some Python literature uses the terms* accessor *for a getter method and*
    mutator *for* *the setter method. These are just different names for the same
    things. I will use the* *more generic terms* getter *and* setter *.*'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **171**
  prefs: []
  type: TYPE_NORMAL
- en: '***Safe Direct Access***'
  prefs: []
  type: TYPE_NORMAL
- en: There are certain circumstances where it seems reasonable to access
  prefs: []
  type: TYPE_NORMAL
- en: 'instance variables directly: when it is absolutely clear what the instance
    vari-'
  prefs: []
  type: TYPE_NORMAL
- en: able means, little or no validation of the data is needed, and there is no
  prefs: []
  type: TYPE_NORMAL
- en: chance that the name will ever change. A good example of this is the Rect
  prefs: []
  type: TYPE_NORMAL
- en: (rectangle) class in the pygame package. A rectangle in pygame is defined
  prefs: []
  type: TYPE_NORMAL
- en: 'using four values—x, y, width, and height—like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oRectangle = pygame.Rect(10, 20, 300, 300)
  prefs: []
  type: TYPE_NORMAL
- en: After creating that rectangle object, using oRectangle.x, oRectangle.y,
  prefs: []
  type: TYPE_NORMAL
- en: oRectangle.width, and oRectangle.height directly as variables seems acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making Instance Variables More Private**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, all instance variables are public (that is, can be accessed by code
  prefs: []
  type: TYPE_NORMAL
- en: external to the class). But what if you want to allow access to some of your
  prefs: []
  type: TYPE_NORMAL
- en: class’s instance variables, but not all of them? Some OOP languages allow
  prefs: []
  type: TYPE_NORMAL
- en: you to explicitly mark certain instance variables as public or private, but
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn’t have those keywords. However, there are two ways that pro-
  prefs: []
  type: TYPE_NORMAL
- en: grammers who develop classes in Python can indicate that their instance
  prefs: []
  type: TYPE_NORMAL
- en: variables and methods are intended to be private.
  prefs: []
  type: TYPE_NORMAL
- en: '***Implicitly Private***'
  prefs: []
  type: TYPE_NORMAL
- en: To mark an instance variable as one that should never be accessed exter-
  prefs: []
  type: TYPE_NORMAL
- en: nally, by convention you start the name of your instance variable with one
  prefs: []
  type: TYPE_NORMAL
- en: 'leading underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: self._name
  prefs: []
  type: TYPE_NORMAL
- en: self._socialSecurityNumber
  prefs: []
  type: TYPE_NORMAL
- en: self._dontTouchThis
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables with names like these are intended to represent pri-
  prefs: []
  type: TYPE_NORMAL
- en: vate data, and client software should never attempt to access them directly.
  prefs: []
  type: TYPE_NORMAL
- en: The code may still work if the instance variables are accessed, but it is not
  prefs: []
  type: TYPE_NORMAL
- en: guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same convention is used for method names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _internalMethod(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _dontCallMeFromClientSoftware(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is only a convention; there is no enforcement. If any client
  prefs: []
  type: TYPE_NORMAL
- en: software makes a call to a method with a name beginning with an under-
  prefs: []
  type: TYPE_NORMAL
- en: score, Python will allow it, but there is a good chance that doing so will
  prefs: []
  type: TYPE_NORMAL
- en: lead to unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**172** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: '***More Explicitly Private***'
  prefs: []
  type: TYPE_NORMAL
- en: Python does allow for a more explicit level of privatization. To disallow client
  prefs: []
  type: TYPE_NORMAL
- en: software from directly accessing your data, you create an instance variable
  prefs: []
  type: TYPE_NORMAL
- en: name that starts with two underscores.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we create a class named PrivatePerson with an instance variable
  prefs: []
  type: TYPE_NORMAL
- en: 'self.__privateData that should never be accessed from outside an object:'
  prefs: []
  type: TYPE_NORMAL
- en: PrivatePerson class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class PrivatePerson():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, privateData):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.__privateData = privateData
  prefs: []
  type: TYPE_NORMAL
- en: 'def getName(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.name
  prefs: []
  type: TYPE_NORMAL
- en: 'def setName(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: We can then create a PrivatePerson object, passing in some data that we
  prefs: []
  type: TYPE_NORMAL
- en: wish to keep private 1\. Attempting to access the __privateData instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: 'able directly from client software, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: usersPrivateData = oPrivatePerson.__privateData
  prefs: []
  type: TYPE_NORMAL
- en: 'will generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'AttributeError: ''PrivatePerson'' object has no attribute ''__privateData'''
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you create a method name that starts with two underscores,
  prefs: []
  type: TYPE_NORMAL
- en: any attempt by client software to call the method will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides this ability by performing *name mangling*. Behind
  prefs: []
  type: TYPE_NORMAL
- en: the scenes, Python changes any name that starts with two underscores by
  prefs: []
  type: TYPE_NORMAL
- en: prepending it with an underscore and the name of the class, so __ *<name>*
  prefs: []
  type: TYPE_NORMAL
- en: becomes _ *<className>* __ *<name>* . For example, in the PrivatePerson class,
    Python will change self.__privateData to self._PrivatePerson__privateData. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: if a client tries to use the name oPrivatePerson.__privateData, that name won’t
  prefs: []
  type: TYPE_NORMAL
- en: be recognized.
  prefs: []
  type: TYPE_NORMAL
- en: This is a subtle change designed as a deterrent to using direct
  prefs: []
  type: TYPE_NORMAL
- en: access, but you should note that it doesn’t absolutely guarantee privacy.
  prefs: []
  type: TYPE_NORMAL
- en: If the client programmer knows how this works, they can still access the
  prefs: []
  type: TYPE_NORMAL
- en: instance variable with *<object>* ._ *<className>* __ *<name>* (or, in our example,
    oPrivatePerson._PrivatePerson__privateData).
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **173**
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorators and @property**'
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, a decorator is a method that takes another method as an
  prefs: []
  type: TYPE_NORMAL
- en: argument and extends the way the original method works. (Decorators can
  prefs: []
  type: TYPE_NORMAL
- en: also be functions that decorate functions or methods, but I’ll concentrate
  prefs: []
  type: TYPE_NORMAL
- en: on methods.) Decorators are an advanced topic and are generally beyond
  prefs: []
  type: TYPE_NORMAL
- en: the scope of this book. However, there is a set of built-in decorators that
  prefs: []
  type: TYPE_NORMAL
- en: provide a compromise between direct access and the use of getters and set-
  prefs: []
  type: TYPE_NORMAL
- en: ters in a class.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator is written as a line that starts with the @ symbol followed
  prefs: []
  type: TYPE_NORMAL
- en: by a decorator name and is placed directly before the def statement of a
  prefs: []
  type: TYPE_NORMAL
- en: 'method. This applies the decorator to a method to add to its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '@ *<decorator>*'
  prefs: []
  type: TYPE_NORMAL
- en: def *<someMethod>* (self, *<parameters>* )
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use two built-in decorators and apply them to two methods in a
  prefs: []
  type: TYPE_NORMAL
- en: class to implement a *property*.
  prefs: []
  type: TYPE_NORMAL
- en: '**property**'
  prefs: []
  type: TYPE_NORMAL
- en: An attribute of a class that appears to client code to be an instance variable,
    but instead causes a method to be called when it is accessed .
  prefs: []
  type: TYPE_NORMAL
- en: A property allows class developers to use indirection, the way that
  prefs: []
  type: TYPE_NORMAL
- en: a magician uses misdirection—the audience thinks they are seeing one
  prefs: []
  type: TYPE_NORMAL
- en: thing, while behind the scenes something very different is happening.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a class to use property decorators, the developer writes a get-
  prefs: []
  type: TYPE_NORMAL
- en: ter and a setter method and adds a distinct built-in decorator to each one.
  prefs: []
  type: TYPE_NORMAL
- en: The first method is a getter and is preceded with the built-in @property deco-
  prefs: []
  type: TYPE_NORMAL
- en: rator. The name of the method defines a name of a property to be used by
  prefs: []
  type: TYPE_NORMAL
- en: client code. The second method is a setter and is preceded with the @ *<name*
  prefs: []
  type: TYPE_NORMAL
- en: '*of the property>* .setter decorator. Here is a minimal sample class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Example():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, startingValue):'
  prefs: []
  type: TYPE_NORMAL
- en: self._x = startingValue
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def x(self): # this is the decorated getter method'
  prefs: []
  type: TYPE_NORMAL
- en: return self._x
  prefs: []
  type: TYPE_NORMAL
- en: '@x.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def x(self, value): # this is the decorated setter method'
  prefs: []
  type: TYPE_NORMAL
- en: self._x = value
  prefs: []
  type: TYPE_NORMAL
- en: In the Example class, x is the name of the property. After the standard
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method, the unusual thing is that we have two methods that both
  prefs: []
  type: TYPE_NORMAL
- en: 'have the same name: the name of the property. The first method is a get-'
  prefs: []
  type: TYPE_NORMAL
- en: ter, while the second is a setter. The setter method is optional, and if it’s
    not
  prefs: []
  type: TYPE_NORMAL
- en: present, the property will be read-only.
  prefs: []
  type: TYPE_NORMAL
- en: '**174** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the Example class, here is some sample client code:'
  prefs: []
  type: TYPE_NORMAL
- en: oExample = Example(10)
  prefs: []
  type: TYPE_NORMAL
- en: print(oExample.x)
  prefs: []
  type: TYPE_NORMAL
- en: oExample.x = 20
  prefs: []
  type: TYPE_NORMAL
- en: In this code we create an instance of the Example class, make a call to
  prefs: []
  type: TYPE_NORMAL
- en: print(), and execute a simple assignment. From the client’s point of view,
  prefs: []
  type: TYPE_NORMAL
- en: this code is highly readable. When we write oExample.x, it looks like we are
  prefs: []
  type: TYPE_NORMAL
- en: using direct access to an instance variable. However, when client code
  prefs: []
  type: TYPE_NORMAL
- en: accesses the value of an object’s property (on the right side of an assign-
  prefs: []
  type: TYPE_NORMAL
- en: ment statement or as an argument in a call to a function or method),
  prefs: []
  type: TYPE_NORMAL
- en: Python translates it into a call to the getter method of the object. When an
  prefs: []
  type: TYPE_NORMAL
- en: object dot property appears on the left side of an assignment statement,
  prefs: []
  type: TYPE_NORMAL
- en: Python calls the setter method. The getter and setter methods affect the
  prefs: []
  type: TYPE_NORMAL
- en: real instance variable, self._x.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more realistic example that should help make this clear.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-6 shows a Student class that includes a property grade, properly dec-
  prefs: []
  type: TYPE_NORMAL
- en: orated getter and setter methods, and a private instance variable __grade.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PropertyDecorator/Student.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Using a property to (indirectly) access data in an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Student():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, startingGrade=0):'
  prefs: []
  type: TYPE_NORMAL
- en: self.__name = name
  prefs: []
  type: TYPE_NORMAL
- en: self.grade = startingGrade 1
  prefs: []
  type: TYPE_NORMAL
- en: '@property 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'def grade(self): 3'
  prefs: []
  type: TYPE_NORMAL
- en: return self.__grade
  prefs: []
  type: TYPE_NORMAL
- en: '@grade.setter 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'def grade(self, newGrade): 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: newGrade = int(newGrade)
  prefs: []
  type: TYPE_NORMAL
- en: 'except (TypeError, ValueError) as e:'
  prefs: []
  type: TYPE_NORMAL
- en: 'raise type(e)(''New grade: '' + str(newGrade) + '', is an invalid type.'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (newGrade < 0) or (newGrade > 100):'
  prefs: []
  type: TYPE_NORMAL
- en: 'raise ValueError(''New grade: '' + str(newGrade) + '', must be between 0 and
    100.'')'
  prefs: []
  type: TYPE_NORMAL
- en: self.__grade = newGrade
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-6: The Student class with property decorators*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method has a little trick to it, so let’s examine the
  prefs: []
  type: TYPE_NORMAL
- en: other methods first. Notice we have two methods with the name grade().
  prefs: []
  type: TYPE_NORMAL
- en: Preceding the definition of the first grade() method, we add an @property
  prefs: []
  type: TYPE_NORMAL
- en: decorator 2\. This defines the name grade as a property of any object cre-
  prefs: []
  type: TYPE_NORMAL
- en: ated from this class. The first method 3 is a getter that just returns the
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **175**
  prefs: []
  type: TYPE_NORMAL
- en: value of the current grade, kept in the private self.__grade instance variable,
    but could include any code that might be needed to calculate a value and
  prefs: []
  type: TYPE_NORMAL
- en: return it.
  prefs: []
  type: TYPE_NORMAL
- en: Preceding the second grade() method is an @grade.setter decorator 4\.
  prefs: []
  type: TYPE_NORMAL
- en: This second method 5 accepts a new value as a parameter, does a num-
  prefs: []
  type: TYPE_NORMAL
- en: ber of checks to ensure that value is valid, then sets the new value into
  prefs: []
  type: TYPE_NORMAL
- en: self.__grade.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method first stores the student’s name in an instance
  prefs: []
  type: TYPE_NORMAL
- en: variable. The next line 1 seems straightforward but is a little unusual. As
  prefs: []
  type: TYPE_NORMAL
- en: we have seen, we typically store the values of parameters into instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: 'ables. Therefore, we might be tempted to write this line as:'
  prefs: []
  type: TYPE_NORMAL
- en: self.__grade = startingGrade
  prefs: []
  type: TYPE_NORMAL
- en: But instead, we are storing the starting grade into the property grade.
  prefs: []
  type: TYPE_NORMAL
- en: Since grade is a property, Python translates this assignment statement into
    a
  prefs: []
  type: TYPE_NORMAL
- en: call to the setter method 5, which has the advantage of validating the input
  prefs: []
  type: TYPE_NORMAL
- en: before storing the value in the instance variable self.__grade.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-7 provides some test code that uses the Student class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PropertyDecorator/Main_Property.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Main Student property example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 oStudent1= Student('Joe Schmoe')
  prefs: []
  type: TYPE_NORMAL
- en: oStudent2= Student ('Jane Smith')
  prefs: []
  type: TYPE_NORMAL
- en: Get the students' grades using the 'grade' property and print
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 print(oStudent1.grade)
  prefs: []
  type: TYPE_NORMAL
- en: print(oStudent2.grade)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: Set new values using the 'grade' property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 oStudent1.grade = 85
  prefs: []
  type: TYPE_NORMAL
- en: oStudent2.grade = 92
  prefs: []
  type: TYPE_NORMAL
- en: 4 print(oStudent1.grade)
  prefs: []
  type: TYPE_NORMAL
- en: print(oStudent2.grade)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-7: The main code that creates Student objects and accesses a property*
    In the test code, we first create two Student objects 1 and print the'
  prefs: []
  type: TYPE_NORMAL
- en: grade of each 2\. It looks like we’re reaching into each object directly to
    get
  prefs: []
  type: TYPE_NORMAL
- en: the grade values, but since grade is a property Python turns these lines into
  prefs: []
  type: TYPE_NORMAL
- en: calls to the getter method and returns the value of the private instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: able self.__grade for each object.
  prefs: []
  type: TYPE_NORMAL
- en: We then set new grade values for each Student object 3\. Here it looks
  prefs: []
  type: TYPE_NORMAL
- en: like we’re setting values directly into each object’s data, but again, because
  prefs: []
  type: TYPE_NORMAL
- en: grade is a property, Python turns these lines into calls to the setter method.
  prefs: []
  type: TYPE_NORMAL
- en: That method validates each value before doing the assignment. The test
  prefs: []
  type: TYPE_NORMAL
- en: code ends by printing the new values of the grades 4\.
  prefs: []
  type: TYPE_NORMAL
- en: '**176** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the test code, we get this output, as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  prefs: []
  type: TYPE_NORMAL
- en: Using the @property and @ *<property_name>* .setter decorators gives you the
    best of both the direct access and getter-and-setter worlds. Client software
  prefs: []
  type: TYPE_NORMAL
- en: can be written in a way that *appears* to access instance variables directly,
    but as the class programmer, your decorated methods get and set the actual
  prefs: []
  type: TYPE_NORMAL
- en: instance variables owned by the object and even allow for validation of
  prefs: []
  type: TYPE_NORMAL
- en: inputs. This approach supports encapsulation because the client code is not
  prefs: []
  type: TYPE_NORMAL
- en: accessing an instance variable directly.
  prefs: []
  type: TYPE_NORMAL
- en: While this technique is used by many professional Python developers,
  prefs: []
  type: TYPE_NORMAL
- en: I personally find it a little ambiguous, because when I read other develop-
  prefs: []
  type: TYPE_NORMAL
- en: ers’ code that uses this approach, it is not immediately apparent whether it’s
  prefs: []
  type: TYPE_NORMAL
- en: using direct accesses to instance variables or using properties that Python
  prefs: []
  type: TYPE_NORMAL
- en: translates into calls to decorated methods. I prefer to use standard getter
  prefs: []
  type: TYPE_NORMAL
- en: and setter methods and will use them in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation in pygwidgets Classes**'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of encapsulation at the start of this chapter focused on two
  prefs: []
  type: TYPE_NORMAL
- en: 'areas: hiding internal details and having all related code in one place. All'
  prefs: []
  type: TYPE_NORMAL
- en: the classes in pygwidgets were designed with these considerations in mind.
  prefs: []
  type: TYPE_NORMAL
- en: As examples, consider the TextButton and CustomButton classes.
  prefs: []
  type: TYPE_NORMAL
- en: The methods of these two classes encapsulate all the functionality of
  prefs: []
  type: TYPE_NORMAL
- en: GUI buttons. While the source code of these classes is available, there is no
  prefs: []
  type: TYPE_NORMAL
- en: need for a client programmer to look at it to use them effectively. There’s
  prefs: []
  type: TYPE_NORMAL
- en: also no need for client code to attempt to access any of their instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: 'ables: all button functionality is available through calling the methods of'
  prefs: []
  type: TYPE_NORMAL
- en: these classes. This adheres to the strict interpretation of encapsulation,
  prefs: []
  type: TYPE_NORMAL
- en: meaning that the *only* way that client software should access an object’s data
    is by calling that object’s methods. A client programmer can think of these
  prefs: []
  type: TYPE_NORMAL
- en: classes as black boxes, since there is no reason to look at how they accom-
  prefs: []
  type: TYPE_NORMAL
- en: plish their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A whole* black box testing *industry has developed around the idea of a test
    programmer being given a class to test without being allowed to see the code of
    the class.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The tester is only supplied with documentation of the interfaces, and with
    that writes* *code that tests all the interfaces under many different cases to
    ensure that all methods* *work as described. The set of tests not only ensures
    that the code and documentation* *match, but is used again whenever code is added
    or modified in the class to ensure* *that the changes have not broken anything.*'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **177**
  prefs: []
  type: TYPE_NORMAL
- en: '**A Story from the Real World**'
  prefs: []
  type: TYPE_NORMAL
- en: A number of years ago, I was involved in the design and development of
  prefs: []
  type: TYPE_NORMAL
- en: a very large educational project that was built in an environment called
  prefs: []
  type: TYPE_NORMAL
- en: '*Director* from Macromedia (later Adobe), using the object-oriented *Lingo*
    language. Director was designed to be extended through *XTRAs* that could'
  prefs: []
  type: TYPE_NORMAL
- en: add functionality, similar to the way plug-ins are added to browsers. These
  prefs: []
  type: TYPE_NORMAL
- en: XTRAs were developed and sold by a number of third-party vendors. In the
  prefs: []
  type: TYPE_NORMAL
- en: design, we planned on storing navigational and other course-related infor-
  prefs: []
  type: TYPE_NORMAL
- en: mation in a database. I looked at all the different database XTRAs that
  prefs: []
  type: TYPE_NORMAL
- en: were available and purchased a particular XTRA, which I’ll call XTRA1\.
  prefs: []
  type: TYPE_NORMAL
- en: Each XTRA came with documentation of its API, which showed how to
  prefs: []
  type: TYPE_NORMAL
- en: make queries to the database using Structured Query Language (SQL). I
  prefs: []
  type: TYPE_NORMAL
- en: decided to create a Database class that incorporated all the functionality of
  prefs: []
  type: TYPE_NORMAL
- en: accessing the database using XTRA1’s API. That way, all code that commu-
  prefs: []
  type: TYPE_NORMAL
- en: nicated with the XTRA directly was in the Database class. Figure 8-1 shows
  prefs: []
  type: TYPE_NORMAL
- en: the overall architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Requests
  prefs: []
  type: TYPE_NORMAL
- en: info
  prefs: []
  type: TYPE_NORMAL
- en: Builds
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs: []
  type: TYPE_NORMAL
- en: Accesses
  prefs: []
  type: TYPE_NORMAL
- en: database
  prefs: []
  type: TYPE_NORMAL
- en: Main
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs: []
  type: TYPE_NORMAL
- en: program
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: XTRA
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: results
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: results
  prefs: []
  type: TYPE_NORMAL
- en: results
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8-1: The architecture of accessing a database using an object and an
    XTRA* When the program started, it created a single instance of the Database'
  prefs: []
  type: TYPE_NORMAL
- en: class. The main code was a client of the Database object. Whenever the main
  prefs: []
  type: TYPE_NORMAL
- en: code wanted information from the database, rather than formatting a SQL
  prefs: []
  type: TYPE_NORMAL
- en: query itself, it called a method of the Database object, supplying details about
  prefs: []
  type: TYPE_NORMAL
- en: what information it wanted. The methods in the Database object translated
  prefs: []
  type: TYPE_NORMAL
- en: each request into a SQL query made to XTRA1 to get data from the data-
  prefs: []
  type: TYPE_NORMAL
- en: base. That way, only the code of the Database object knew how to access the
  prefs: []
  type: TYPE_NORMAL
- en: XTRA using its API.
  prefs: []
  type: TYPE_NORMAL
- en: The program worked well, and the customers enjoyed using the prod-
  prefs: []
  type: TYPE_NORMAL
- en: uct. But every once in a while, we would run into errors in the data we got
  prefs: []
  type: TYPE_NORMAL
- en: back from the database. I contacted the XTRA1 developer and gave many
  prefs: []
  type: TYPE_NORMAL
- en: easily reproducible examples of the problems. Unfortunately, the developer
  prefs: []
  type: TYPE_NORMAL
- en: never addressed these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the lack of response, we eventually decided to purchase a
  prefs: []
  type: TYPE_NORMAL
- en: different database XTRA, XTRA2, to serve this purpose. XTRA2 worked in
  prefs: []
  type: TYPE_NORMAL
- en: '**178** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: a similar way but had some subtle differences in how it was initialized and
    required some minor changes in the way that SQL queries were built.
  prefs: []
  type: TYPE_NORMAL
- en: Because the Database class encapsulated all the details of communicat-
  prefs: []
  type: TYPE_NORMAL
- en: ing with the XTRA, we were able to make all the necessary changes to work
  prefs: []
  type: TYPE_NORMAL
- en: with XTRA2 only in the Database class. We did not change a single line in
  prefs: []
  type: TYPE_NORMAL
- en: the main program (the client code).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I was both the Database class developer and the client soft-
  prefs: []
  type: TYPE_NORMAL
- en: ware developer. If my client code had used the names of instance variables
  prefs: []
  type: TYPE_NORMAL
- en: in the class, I would have had to crawl through the program, modifying
  prefs: []
  type: TYPE_NORMAL
- en: each line of relevant code. Using encapsulation with a class saved me from
  prefs: []
  type: TYPE_NORMAL
- en: countless hours of reworking and testing.
  prefs: []
  type: TYPE_NORMAL
- en: As a follow-up to the story, while XTRA2 worked well, that company
  prefs: []
  type: TYPE_NORMAL
- en: eventually went out of business and I had to go through the same process
  prefs: []
  type: TYPE_NORMAL
- en: again. Once again, because of encapsulation, only the code of the Database
  prefs: []
  type: TYPE_NORMAL
- en: class was modified to work with XTRA3\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction**'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is another OOP concept closely related to encapsulation; many
  prefs: []
  type: TYPE_NORMAL
- en: developers consider it to be the fourth tenet of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas encapsulation is about implementation, hiding the details of
  prefs: []
  type: TYPE_NORMAL
- en: the code and data that make up a class, *abstraction* is about the client’s
    view of a class. It’s about the perception of a class from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: '**abstraction**'
  prefs: []
  type: TYPE_NORMAL
- en: Handling complexity by hiding unnecessary details .
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, abstraction is a reminder to make sure that the user’s view
  prefs: []
  type: TYPE_NORMAL
- en: of a system is as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is extremely common in consumer products. Many people
  prefs: []
  type: TYPE_NORMAL
- en: use TVs, computers, microwave ovens, cars, and so on every day. We become
  prefs: []
  type: TYPE_NORMAL
- en: comfortable with the user interface that these products extend to us. Through
  prefs: []
  type: TYPE_NORMAL
- en: their controls, they provide an abstraction of their functionality. You press
  prefs: []
  type: TYPE_NORMAL
- en: the accelerator pedal in a car to make it go forward. With a microwave, you
  prefs: []
  type: TYPE_NORMAL
- en: set an amount of time and press Start to heat up some food. But few of us
  prefs: []
  type: TYPE_NORMAL
- en: really know how these products work internally.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of abstraction from the world of computer science.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a *stack* is a mechanism for remembering data in a *last in,*
    *first out* *(LIFO)* order. Think of a pile of plates, where clean plates are
    added to the top and users take one from the top when they need a plate. A stack
  prefs: []
  type: TYPE_NORMAL
- en: 'has two standard operations: push adds an item to the top of the stack, and'
  prefs: []
  type: TYPE_NORMAL
- en: pop removes the topmost item from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: A stack is particularly useful whenever your program does any naviga-
  prefs: []
  type: TYPE_NORMAL
- en: tion because it can be used to leave a trail of breadcrumbs for finding your
  prefs: []
  type: TYPE_NORMAL
- en: way back. This is how programming languages keep track of the execution
  prefs: []
  type: TYPE_NORMAL
- en: 'of function and method calls in code: when you call a function or method,'
  prefs: []
  type: TYPE_NORMAL
- en: the return point is pushed onto a stack, and when the function or method
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **179**
  prefs: []
  type: TYPE_NORMAL
- en: returns, the place to return to is discovered by popping the most recent information
    off the top of the stack. In this way, code can make as many
  prefs: []
  type: TYPE_NORMAL
- en: levels of calls as you need, and it always unwinds correctly.
  prefs: []
  type: TYPE_NORMAL
- en: As an abstraction, suppose a client program required the functional-
  prefs: []
  type: TYPE_NORMAL
- en: ity of a stack that would be simple to create and would provide the ability
  prefs: []
  type: TYPE_NORMAL
- en: to push and pop information. If this were written as a class, the client code
  prefs: []
  type: TYPE_NORMAL
- en: 'would create a stack like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oStack = Stack()
  prefs: []
  type: TYPE_NORMAL
- en: 'A client would add information by calling a push() method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oStack.push( *<someData>* )
  prefs: []
  type: TYPE_NORMAL
- en: And it would retrieve the most recent data by calling a pop() method
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<someVariable>* = oStack.pop()'
  prefs: []
  type: TYPE_NORMAL
- en: The client would not need to know or care how these methods were
  prefs: []
  type: TYPE_NORMAL
- en: implemented or how the data was stored. The implementation of the Stack
  prefs: []
  type: TYPE_NORMAL
- en: would be handled completely by the methods of the Stack.
  prefs: []
  type: TYPE_NORMAL
- en: While the client code could view a Stack class as a black box, writing
  prefs: []
  type: TYPE_NORMAL
- en: such a class in Python is fairly trivial. Listing 8-8 shows how it could be
  prefs: []
  type: TYPE_NORMAL
- en: implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Stack/Stack.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Stack class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Stack():'
  prefs: []
  type: TYPE_NORMAL
- en: ''''''' Stack class implements a last in first out LIFO algorithm'''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, startingStackAsList=None):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if startingStackAsList is None:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.dataList = [ ]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.dataList = startingStackAsList[:] # make a copy'
  prefs: []
  type: TYPE_NORMAL
- en: '2 def push(self, item):'
  prefs: []
  type: TYPE_NORMAL
- en: self.dataList.append(item)
  prefs: []
  type: TYPE_NORMAL
- en: '3 def pop(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(self.dataList) == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: raise IndexError
  prefs: []
  type: TYPE_NORMAL
- en: element = self.dataList.pop()
  prefs: []
  type: TYPE_NORMAL
- en: return element
  prefs: []
  type: TYPE_NORMAL
- en: '**180** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: '4 def peek(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the top item, without removing it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: item = self.dataList[-1]
  prefs: []
  type: TYPE_NORMAL
- en: return item
  prefs: []
  type: TYPE_NORMAL
- en: '5 def getSize(self):'
  prefs: []
  type: TYPE_NORMAL
- en: nElements = len(self.dataList)
  prefs: []
  type: TYPE_NORMAL
- en: return nElements
  prefs: []
  type: TYPE_NORMAL
- en: '6 def show(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Show the stack in a vertical orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Stack is:')
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in reversed(self.dataList):'
  prefs: []
  type: TYPE_NORMAL
- en: print(' ', value)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-8: A stack as a Python class*'
  prefs: []
  type: TYPE_NORMAL
- en: The Stack class keeps track of all the data using a list instance variable
  prefs: []
  type: TYPE_NORMAL
- en: named self.dataList 1\. The client doesn’t need to know this level of detail,
  prefs: []
  type: TYPE_NORMAL
- en: but push() 2 just adds an item to the internal list using the Python append()
  prefs: []
  type: TYPE_NORMAL
- en: operation, while pop() 3 pops the last element from the internal list. Because
  prefs: []
  type: TYPE_NORMAL
- en: it is easy to do, this implementation of the Stack class also implements three
  prefs: []
  type: TYPE_NORMAL
- en: 'additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: • peek() 4 allows the caller to obtain the data at the top of the stack with-
  prefs: []
  type: TYPE_NORMAL
- en: out removing it from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: • getSize() 5 returns the number of items on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: • show() 6 prints the contents of the stack in the way that the client
  prefs: []
  type: TYPE_NORMAL
- en: 'thinks of a stack: the data is displayed vertically, with the most recent'
  prefs: []
  type: TYPE_NORMAL
- en: data pushed shown at the top. This can be helpful in debugging client
  prefs: []
  type: TYPE_NORMAL
- en: code that involves multiple calls to push() and pop().
  prefs: []
  type: TYPE_NORMAL
- en: This was an extremely simple example, but as you gain more experience
  prefs: []
  type: TYPE_NORMAL
- en: writing classes, your classes will typically become more complex. Along the
  prefs: []
  type: TYPE_NORMAL
- en: way, you may find cleaner and more efficient ways of writing some methods
  prefs: []
  type: TYPE_NORMAL
- en: and perhaps rewrite them. Because objects provide both encapsulation and
  prefs: []
  type: TYPE_NORMAL
- en: abstraction, as the writer of a class, you should feel free to modify its code
  prefs: []
  type: TYPE_NORMAL
- en: and data, as long as the published interfaces do not change. Changes to the
  prefs: []
  type: TYPE_NORMAL
- en: implementation of methods should have no ill effects on client software but
  prefs: []
  type: TYPE_NORMAL
- en: rather should allow you to make improvements without affecting any client
  prefs: []
  type: TYPE_NORMAL
- en: code. In fact, if you find ways to make your code more efficient and publish
    a
  prefs: []
  type: TYPE_NORMAL
- en: new version, client code may appear to speed up, with zero changes required
  prefs: []
  type: TYPE_NORMAL
- en: to that code.
  prefs: []
  type: TYPE_NORMAL
- en: A property is an excellent example of abstraction. As you saw earlier,
  prefs: []
  type: TYPE_NORMAL
- en: with properties the client programmer can use a syntax that makes their
  prefs: []
  type: TYPE_NORMAL
- en: intent clear (to get and set a value in an object). The implementation in the
  prefs: []
  type: TYPE_NORMAL
- en: methods that are called as a result can be much more complicated, but is
  prefs: []
  type: TYPE_NORMAL
- en: totally hidden from the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **181**
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is the first major tenet of object-oriented programming,
  prefs: []
  type: TYPE_NORMAL
- en: allowing classes to hide their implementation and data from client code
  prefs: []
  type: TYPE_NORMAL
- en: and ensuring that a class provides all the functionality that a client needs
  prefs: []
  type: TYPE_NORMAL
- en: in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: A key concept of OOP is that objects own their data, and that’s why
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you provide getter and setter methods if you want cli-
  prefs: []
  type: TYPE_NORMAL
- en: ent code to access the data held in an instance variable. Python does
  prefs: []
  type: TYPE_NORMAL
- en: allow direct access to instance variables using dot syntax, but I strongly
  prefs: []
  type: TYPE_NORMAL
- en: encourage you to stay away from this syntax for the reasons laid out in
  prefs: []
  type: TYPE_NORMAL
- en: this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are conventions for marking instance variables and methods as
  prefs: []
  type: TYPE_NORMAL
- en: private, using a leading underscore or double underscore depending on the
  prefs: []
  type: TYPE_NORMAL
- en: level of privatization you require. As a compromise, Python also allows the
  prefs: []
  type: TYPE_NORMAL
- en: use of the @property decorator. This makes it appear as if the client code is
  prefs: []
  type: TYPE_NORMAL
- en: able to access an instance variable directly, while behind the scenes Python
  prefs: []
  type: TYPE_NORMAL
- en: turns such references into calls to the decorated getter and setter methods
  prefs: []
  type: TYPE_NORMAL
- en: in the class.
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets package provides many good examples of encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: As a client programmer, you see a class from the outside and work with the
  prefs: []
  type: TYPE_NORMAL
- en: interfaces that the class provides. As a class designer, abstraction—handling
  prefs: []
  type: TYPE_NORMAL
- en: complexity by hiding details—helps you design a good interface by consid-
  prefs: []
  type: TYPE_NORMAL
- en: ering the interface of the class from the client’s point of view. However, in
  prefs: []
  type: TYPE_NORMAL
- en: Python, you often have the source code available so that you can look at the
  prefs: []
  type: TYPE_NORMAL
- en: implementation if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '**182** Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: '**9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**P O LY M O R P H I S M**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about the second major
  prefs: []
  type: TYPE_NORMAL
- en: 'tenet of OOP: *polymorphism*. Its component'
  prefs: []
  type: TYPE_NORMAL
- en: 'parts are from the Greek: the prefix *poly*'
  prefs: []
  type: TYPE_NORMAL
- en: means “much” or “many,” and *morphism* means
  prefs: []
  type: TYPE_NORMAL
- en: “shape,” “form,” or “structure.”
  prefs: []
  type: TYPE_NORMAL
- en: So, *polymorphism* essentially means *many forms*. I’m not talking about a *Star
    Trek*–style shape-shifting alien—in fact, it’s quite the opposite. Rather than
    one thing taking on many shapes, polymorphism in OOP is about
  prefs: []
  type: TYPE_NORMAL
- en: how multiple classes can have methods with the exact same names. This
  prefs: []
  type: TYPE_NORMAL
- en: will eventually give us a highly intuitive way to act on a collection of objects,
  prefs: []
  type: TYPE_NORMAL
- en: independent of what class each came from.
  prefs: []
  type: TYPE_NORMAL
- en: OOP programmers often use the term “send a message” when we talk
  prefs: []
  type: TYPE_NORMAL
- en: about client code calling a method of an object. What the object should do
  prefs: []
  type: TYPE_NORMAL
- en: when it receives the message is up to the object. With polymorphism, we can
  prefs: []
  type: TYPE_NORMAL
- en: send the same message to multiple objects, and each object will react differ-
  prefs: []
  type: TYPE_NORMAL
- en: ently depending on what it’s designed to do and the data available to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll discuss how this ability allows you to build pack-
  prefs: []
  type: TYPE_NORMAL
- en: ages of classes that are easily extensible and predictable. We’ll also use
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism with operators to make the same operators perform different operations
    depending on the data types they are working with. Finally,
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you how to use the print() function to get valuable debugging
  prefs: []
  type: TYPE_NORMAL
- en: information from objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending Messages to Real-World Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at polymorphism in the real world, using cars as an example. All
  prefs: []
  type: TYPE_NORMAL
- en: cars have an accelerator pedal. When the driver presses that pedal, they’re
  prefs: []
  type: TYPE_NORMAL
- en: sending the “accelerate” message to the car. The car they’re driving could
  prefs: []
  type: TYPE_NORMAL
- en: have an internal combustion engine or an electric motor, or be a hybrid.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these types of cars has its own implementation of what happens
  prefs: []
  type: TYPE_NORMAL
- en: when it receives the accelerate message, and each behaves accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism allows for easier adoption of new technology. If some-
  prefs: []
  type: TYPE_NORMAL
- en: one were to develop a nuclear-powered car, the user interface of the car
  prefs: []
  type: TYPE_NORMAL
- en: would remain the same—the driver would still press the accelerator pedal
  prefs: []
  type: TYPE_NORMAL
- en: to send the same message—but a very different mechanism would make the
  prefs: []
  type: TYPE_NORMAL
- en: nuclear-powered car go faster.
  prefs: []
  type: TYPE_NORMAL
- en: As another real-world example, imagine you enter a large room with a
  prefs: []
  type: TYPE_NORMAL
- en: bank of light switches that control a variety of different lights. Some of the
  prefs: []
  type: TYPE_NORMAL
- en: bulbs are old-style incandescent bulbs, some are fluorescent, and some are
  prefs: []
  type: TYPE_NORMAL
- en: newer LED bulbs. When you flip all the switches up, you are sending the
  prefs: []
  type: TYPE_NORMAL
- en: “turn on” message to all the bulbs. The underlying mechanisms that cause
  prefs: []
  type: TYPE_NORMAL
- en: incandescent, fluorescent, and LED bulbs to emit light are wildly different,
  prefs: []
  type: TYPE_NORMAL
- en: but each achieves the user’s intended goal.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Classic Example of Polymorphism in Programming**'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of OOP, polymorphism is about how client code can call a method
  prefs: []
  type: TYPE_NORMAL
- en: with the exact same name in different objects, and each object will do what-
  prefs: []
  type: TYPE_NORMAL
- en: ever it needs to do to implement the meaning of that method for that object.
  prefs: []
  type: TYPE_NORMAL
- en: The classic example of polymorphism is to consider code that repre-
  prefs: []
  type: TYPE_NORMAL
- en: sents different types of pets. Let’s say you have a collection of dogs, cats,
    and
  prefs: []
  type: TYPE_NORMAL
- en: birds, and each understands some basic commands. If you ask these pets
  prefs: []
  type: TYPE_NORMAL
- en: to speak (that is, you send the “speak” message to each), the dogs will say
  prefs: []
  type: TYPE_NORMAL
- en: “bark,” the cats will say “meow,” and the birds will say “tweet.” Listing 9-1
  prefs: []
  type: TYPE_NORMAL
- en: shows how we might implement this in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PetsPolymorphism.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Pets polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three classes, all with a different "speak" method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Dog():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: '**184** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def speak(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(self.name, 'says bark, bark, bark!')
  prefs: []
  type: TYPE_NORMAL
- en: 'class Cat():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: '2 def speak(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(self.name, 'says meeeoooow')
  prefs: []
  type: TYPE_NORMAL
- en: 'class Bird():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: '3 def speak(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(self.name, 'says tweet')
  prefs: []
  type: TYPE_NORMAL
- en: oDog1 = Dog('Rover')
  prefs: []
  type: TYPE_NORMAL
- en: oDog2 = Dog('Fido')
  prefs: []
  type: TYPE_NORMAL
- en: oCat1 = Cat('Fluffy')
  prefs: []
  type: TYPE_NORMAL
- en: oCat2 = Cat('Spike')
  prefs: []
  type: TYPE_NORMAL
- en: oBird = Bird('Big Bird')
  prefs: []
  type: TYPE_NORMAL
- en: 4 petsList = [oDog1, oDog2, oCat1, oCat2, oBird]
  prefs: []
  type: TYPE_NORMAL
- en: Send the same message (call the same method) of all pets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for oPet in petsList:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 oPet.speak()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-1: Sending the “speak” message to objects instantiated from different
    classes* Each class has a speak() method, but the content of each method'
  prefs: []
  type: TYPE_NORMAL
- en: is different 1 2 3\. Each class does whatever it needs to do in its ver-
  prefs: []
  type: TYPE_NORMAL
- en: sion of this method; the method name is the same, but it has different
  prefs: []
  type: TYPE_NORMAL
- en: implementations.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easy to deal with, we put all the pet objects into a list 4\.
  prefs: []
  type: TYPE_NORMAL
- en: To make them all speak, we then loop through all the objects and send
  prefs: []
  type: TYPE_NORMAL
- en: the same message by calling a method with the exact same name in each
  prefs: []
  type: TYPE_NORMAL
- en: object 5, without worrying about the type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Using Pygame Shapes**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at a demonstration of polymorphism using pygame. In
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5 w](index_split_002.html#p118)e used pygame to draw primitive shapes
    such as rectangles, circles, polygons, ellipses, and lines. Here we’ll build a
    demonstration'
  prefs: []
  type: TYPE_NORMAL
- en: program that will randomly create and draw different shapes in a window.
  prefs: []
  type: TYPE_NORMAL
- en: The user can then click on any shape, and the program will report the
  prefs: []
  type: TYPE_NORMAL
- en: type and area of the shape that was clicked. Because the shapes are ran-
  prefs: []
  type: TYPE_NORMAL
- en: domly created, each time the program runs, the size, location, number,
  prefs: []
  type: TYPE_NORMAL
- en: and position of the shapes will be different. Figure 9-1 shows some sample
  prefs: []
  type: TYPE_NORMAL
- en: output from the demonstration program.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **185**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 27](index-215_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: A pygame-based example of using polymorphism to draw different
    shapes* We’ll implement the program with a class for each of three different shapes:
    Square, Circle, and Triangle. The key thing to note here is that'
  prefs: []
  type: TYPE_NORMAL
- en: all three shape classes contain methods with the same names, __init__(),
  prefs: []
  type: TYPE_NORMAL
- en: draw(), getType(), getArea(), and clickedInside(), that perform the same tasks.
  prefs: []
  type: TYPE_NORMAL
- en: However, the implementation of each method is different because each
  prefs: []
  type: TYPE_NORMAL
- en: class deals with a different shape.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Square Shape Class***'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with the simplest shape. Listing 9-2 shows the code of the Square
  prefs: []
  type: TYPE_NORMAL
- en: class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Square.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Square class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Square():'
  prefs: []
  type: TYPE_NORMAL
- en: '**186** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y, self.widthAndHeight,
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight)
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = 'Square'
  prefs: []
  type: TYPE_NORMAL
- en: '2 def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: clicked = self.rect.collidepoint(mousePoint)
  prefs: []
  type: TYPE_NORMAL
- en: return clicked
  prefs: []
  type: TYPE_NORMAL
- en: '3 def getType(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  prefs: []
  type: TYPE_NORMAL
- en: '4 def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = self.widthAndHeight * self.widthAndHeight
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: '5 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect(self.window, self.color,
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y, self.widthAndHeight,
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-2: The Square class*'
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we set up a number of instance variables to
  prefs: []
  type: TYPE_NORMAL
- en: use in the methods of the class. That lets us keep the code of the methods
  prefs: []
  type: TYPE_NORMAL
- en: very simple. Since the __init__() method saved the rectangle of the Square,
  prefs: []
  type: TYPE_NORMAL
- en: the clickedInside() method 2 just checks if the location of a mouse click was
  prefs: []
  type: TYPE_NORMAL
- en: inside that rectangle, returning True or False.
  prefs: []
  type: TYPE_NORMAL
- en: The getType() method 3 simply returns the information that the item
  prefs: []
  type: TYPE_NORMAL
- en: clicked is a square. The getArea() method 4 multiplies the width by the
  prefs: []
  type: TYPE_NORMAL
- en: height and returns the resulting area. The draw() method 5 uses pygame’s
  prefs: []
  type: TYPE_NORMAL
- en: draw.rect() to draw the shape in the randomly chosen color.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Circle and Triangle Shape Classes***'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the code of the Circle and the Triangle classes.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to notice is that these classes have methods with the
  prefs: []
  type: TYPE_NORMAL
- en: same names as the Square class, but the code in these methods (especially
  prefs: []
  type: TYPE_NORMAL
- en: clickedInside() and getArea()) is very different. Listing 9-3 shows the Circle
  prefs: []
  type: TYPE_NORMAL
- en: class. Listing 9-4 shows the Triangle class that creates randomly sized right
  prefs: []
  type: TYPE_NORMAL
- en: triangles whose edges are parallel to the x- and y-axes, with the right angle
  prefs: []
  type: TYPE_NORMAL
- en: in the upper-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **187**
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Circle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Circle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Circle():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.radius = random.randrange(10, 50)
  prefs: []
  type: TYPE_NORMAL
- en: self.centerX = self.x + self.radius
  prefs: []
  type: TYPE_NORMAL
- en: self.centerY = self.y + self.radius
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y,
  prefs: []
  type: TYPE_NORMAL
- en: self.radius * 2, self.radius * 2)
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = 'Circle'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: distance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
  prefs: []
  type: TYPE_NORMAL
- en: ((mousePoint[1] - self.centerY) ** 2))
  prefs: []
  type: TYPE_NORMAL
- en: 'if distance <= self.radius:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: '2 def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = math.pi * (self.radius ** 2) squared
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: 'def getType(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  prefs: []
  type: TYPE_NORMAL
- en: '3 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle(self.window, self.color,
  prefs: []
  type: TYPE_NORMAL
- en: (self.centerX, self.centerY),
  prefs: []
  type: TYPE_NORMAL
- en: self.radius, 0)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-3: The Circle class*'
  prefs: []
  type: TYPE_NORMAL
- en: '**188** Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Triangle.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Triangle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Triangle():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.width = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.height = random.randrange(10, 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.triangleSlope = -1 * (self.height / self.width)
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y,
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height)
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = 'Triangle'
  prefs: []
  type: TYPE_NORMAL
- en: '4 def clickedInside(self, mousePoint):'
  prefs: []
  type: TYPE_NORMAL
- en: inRect = self.rect.collidepoint(mousePoint)
  prefs: []
  type: TYPE_NORMAL
- en: 'if not inRect:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: Do some math to see if the point is inside the triangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: xOffset = mousePoint[0] - self.x
  prefs: []
  type: TYPE_NORMAL
- en: yOffset = mousePoint[1] - self.y
  prefs: []
  type: TYPE_NORMAL
- en: 'if xOffset == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the slope (rise over run)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pointSlopeFromYIntercept = (yOffset - self.height) / xOffset
  prefs: []
  type: TYPE_NORMAL
- en: 'if pointSlopeFromYIntercept < self.triangleSlope:'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'def getType(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  prefs: []
  type: TYPE_NORMAL
- en: '5 def getArea(self):'
  prefs: []
  type: TYPE_NORMAL
- en: theArea = .5 * self.width * self.height
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **189**
  prefs: []
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon(self.window, self.color,
  prefs: []
  type: TYPE_NORMAL
- en: ((self.x, self.y + self.height),
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y),
  prefs: []
  type: TYPE_NORMAL
- en: (self.x + self.width, self.y)))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-4: The Triangle class*'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the polymorphism at work here, let’s look at the
  prefs: []
  type: TYPE_NORMAL
- en: codeof the clickedInside() method for each shape. The clickedInside()
  prefs: []
  type: TYPE_NORMAL
- en: 'method of the Square class was very simple: a check to see if the mouse'
  prefs: []
  type: TYPE_NORMAL
- en: click occurred inside the rectangle of the Square. The details of the cal-
  prefs: []
  type: TYPE_NORMAL
- en: culations for clickedInside() in the Circle and Triangle classes are not par-
  prefs: []
  type: TYPE_NORMAL
- en: ticularly important, but they clearly are doing different calculations. The
  prefs: []
  type: TYPE_NORMAL
- en: clickedInside() method of the Circle class 1 only reports a click if the user
  prefs: []
  type: TYPE_NORMAL
- en: clicks on a colored pixel of the shape. That is, it detects a click that is
    within
  prefs: []
  type: TYPE_NORMAL
- en: the bounding rectangle of the circle, but the click must also be within the
  prefs: []
  type: TYPE_NORMAL
- en: radius of the circle for it to count as a click. The clickedInside() method
    of
  prefs: []
  type: TYPE_NORMAL
- en: the Triangle class 4 must determine if the user has clicked on a pixel inside
  prefs: []
  type: TYPE_NORMAL
- en: the colored triangular portion of the rectangle. The methods in all three
  prefs: []
  type: TYPE_NORMAL
- en: classes accept a mouse click as a parameter and return either True or False
  prefs: []
  type: TYPE_NORMAL
- en: as a result.
  prefs: []
  type: TYPE_NORMAL
- en: The getArea() 2 5 and draw() methods 3 6 of these classes have names
  prefs: []
  type: TYPE_NORMAL
- en: that are identical to methods of the Square class, but they do different work
  prefs: []
  type: TYPE_NORMAL
- en: internally. There’s a different calculation for area, and they draw different
  prefs: []
  type: TYPE_NORMAL
- en: shapes.
  prefs: []
  type: TYPE_NORMAL
