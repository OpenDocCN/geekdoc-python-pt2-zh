- en: method, passing in the new text to display. The setValue() method has an opti-
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，传入新的显示文本。setValue() 方法有一个可选的
- en: 'mization, too: it remembers the last text that it rendered, and before doing'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化也做得很好：它记住了上次渲染的文本，并且在执行之前
- en: anything else, it checks if the new text is the same as the previous text. If
    the
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本没有变化，什么都不做，方法直接返回。如果有新文本，
- en: text has not changed, there is nothing to do and the method just returns. If
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本没有变化，什么也不做，方法直接返回。
- en: there is new text, it renders the new text into a surface to be drawn.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有新文本，它将渲染新的文本到一个要绘制的表面。
- en: The draw() method 5 draws the image contained in the self.textSurface
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法 5 绘制 self.textSurface 中包含的图像
- en: instance variable into the window at the given location. This method should
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将实例变量放入窗口的指定位置。此方法应在每一帧中调用。
- en: be called in every frame.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在每一帧中调用。
- en: 'There are multiple advantages to this approach:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有多个优点：
- en: • The class hides all the details of pygame’s rendering of text, so the user
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 该类隐藏了 pygame 渲染文本的所有细节，因此用户
- en: of this class never needs to know what pygame-specific calls are needed
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的实例不需要知道需要哪些特定于 pygame 的调用
- en: to show text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本。
- en: '**134** Chapter 6'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**134** 第 6 章'
- en: • Each SimpleText object remembers the window that it draws into, the location
    where the text should be placed, and the text color. Therefore,
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个 SimpleText 对象记住它绘制文本的窗口、文本放置的位置和文本颜色。因此，
- en: you only need to specify these values once, when you instantiate a
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在实例化时指定这些值一次
- en: SimpleText object, typically before the main loop starts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleText 对象，通常在主循环开始之前。
- en: • Each SimpleText object is also optimized to remember both the text that
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个 SimpleText 对象还被优化为记住它显示的文本
- en: it was last told to draw and the image (self.textSurface) that it made
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它记住了上次绘制的图像（self.textSurface），如果
- en: from the current text. It only needs to render a new surface when the
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文本的变化。只有当
- en: text changes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 文本发生变化时。
- en: • To show multiple pieces of text in a window, you only need to instanti-
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: • 要在窗口中显示多段文本，你只需要实例化
- en: ate multiple SimpleText objects. This is a key concept of object-oriented
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个 SimpleText 对象。这是面向对象编程的一个关键概念
- en: programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编程。
- en: '**Demo Ball with SimpleText and SimpleButton**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**演示球与 SimpleText 和 SimpleButton**'
- en: To cap this off, we’ll modify Listing 6-2 to use the SimpleText and SimpleButton
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改示例 6-2，使用 SimpleText 和 SimpleButton
- en: classes. The updated program in Listing 6-7 keeps track of the number of
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类的更新程序在示例 6-7 中跟踪了
- en: times it goes through the main loop and reports that information at the top
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它会检查主循环运行的次数，并在顶部报告该信息。
- en: of the window. Clicking the Restart button resets the counter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口上。点击重启按钮会重置计数器。
- en: '**File: PygameDemo8_SimpleTextDisplay/Main_Bal TextAndButton.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo8_SimpleTextDisplay/Main_Bal TextAndButton.py**'
- en: pygame demo 8 - SimpleText, SimpleButton, and Ball
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 8 - SimpleText、SimpleButton 和 Ball
- en: 1 - Import packages
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import random
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: '1 from Ball import * # bring in the Ball class code'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '1 from Ball import *  # 导入 Ball 类代码'
- en: from SimpleText import *
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleText import *
- en: from SimpleButton import *
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleButton import *
- en: 2 - Define constants
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WHITE = (255, 255, 255)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: WINDOW_WIDTH = 640
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: 5 - Initialize variables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
- en: oFrameCountLabel = SimpleText(window, (60, 20),
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountLabel = SimpleText(window, (60, 20),
- en: '''Program has run through this many loops: '', WHITE)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '''程序已经运行了这么多次：'', WHITE)'
- en: Object-Oriented Pygame **135**
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **135**
- en: oFrameCountDisplay = SimpleText(window, (500, 20), '', WHITE)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountDisplay = SimpleText(window, (500, 20), '', WHITE)
- en: oRestartButton = SimpleButton(window, (280, 60),
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: oRestartButton = SimpleButton(window, (280, 60),
- en: '''images/restartUp.png'', ''images/restartDown.png'')'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/restartUp.png'', ''images/restartDown.png'')'
- en: frameCounter = 0
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: frameCounter = 0
- en: 6 - Loop forever
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: '3 if oRestartButton.handleEvent(event):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '3 if oRestartButton.handleEvent(event):'
- en: 'frameCounter = 0 # clicked button, reset counter'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'frameCounter = 0 # 点击按钮，重置计数器'
- en: 8 - Do any "per frame" actions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: '4 oBall.update() # tell the ball to update itself'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '4 oBall.update() # 告诉球更新自己'
- en: 'frameCounter = frameCounter + 1 # increment each frame'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'frameCounter = frameCounter + 1 # 每帧递增'
- en: 5 oFrameCountDisplay.setValue(str(frameCounter))
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 5 oFrameCountDisplay.setValue(str(frameCounter))
- en: 9 - Clear the window before drawing it again
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在重新绘制之前清空窗口
- en: window.fill(BLACK)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw the window elements
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: '6 oBall.draw() # tell the ball to draw itself'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '6 oBall.draw() # 告诉球绘制自己'
- en: oFrameCountLabel.draw()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountLabel.draw()
- en: oFrameCountDisplay.draw()
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountDisplay.draw()
- en: oRestartButton.draw()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: oRestartButton.draw()
- en: 11 - Update the window
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢一些
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 6-7: An example main program to show Ball, SimpleText, and SimpleButton*
    At the top of the program, we import the code of the Ball, SimpleText,'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-7: 一个示例主程序，展示Ball、SimpleText和SimpleButton* 在程序的顶部，我们导入Ball、SimpleText的代码，'
- en: and SimpleButton classes 1\. Before our main loop starts, we create an instance
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 和SimpleButton类 1\. 在主循环开始之前，我们创建了一个实例
- en: of the Ball 2, two instances of the SimpleText class (oFrameCountLabel for the
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Ball 2的两个实例，SimpleText类的两个实例（oFrameCountLabel用于
- en: unchanging message label and oFrameCountDisplay for the changing dis-
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不变的消息标签和oFrameCountDisplay用于显示帧数的变化，
- en: play of frames), and an instance of the SimpleButton class that we store in
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 帧数显示（以及帧数的变化），还有一个SimpleButton类的实例，我们将其存储在
- en: oRestartButton. We also initialize a variable frameCounter to zero, which we
    will
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: oRestartButton。我们还初始化了一个变量frameCounter为零，后续会使用
- en: increment every time through the main loop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过主循环时递增。
- en: In the main loop, we check if the user pressed the Restart button 3\. If
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们检查用户是否按下了重启按钮 3\. 如果
- en: True, we reset the frame counter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，我们重置了帧计数器。
- en: We tell the ball to update its position 4\. We increment the frame coun-
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉球更新其位置 4\. 我们递增帧计数器—
- en: ter, then call the setValue() method of the text field to show the new count
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用文本字段的setValue()方法，显示新的计数
- en: of frames 5\. Finally, we tell the ball to draw itself tell the text fields
    to draw
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 帧数 5\. 最后，我们告诉球绘制自己，并告诉文本字段绘制
- en: themselves, and tell the Restart button to draw itself, by calling the draw()
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它们自己，并通过调用draw()方法，告诉重启按钮绘制自己
- en: method of each object 6\.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象的方法 6\。
- en: '**136** Chapter 6'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**136** 第6章'
- en: In the instantiation of the SimpleText objects, the last argument is a text
    color, and we specified that the objects should be rendered in WHITE so
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在SimpleText对象的实例化中，最后一个参数是文本颜色，我们指定这些对象应以白色渲染，因此
- en: they can be seen against a BLACK background. In the next chapter, I’ll show
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样它们就能在黑色背景下显示出来。在下一章，我将展示
- en: how to expand the SimpleText class to incorporate more attributes, without
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如何扩展SimpleText类以包含更多属性，而不
- en: complicating the interface of the class. We’ll build a more full-featured text
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不会使类的接口变得复杂。我们将构建一个功能更全的文本
- en: object that has reasonable default values for each of these attributes, but
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对象有合理的默认值来设置这些属性，但
- en: allows you to override those defaults.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你重写这些默认值。
- en: '**Interface vs. Implementation**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口与实现**'
- en: The SimpleButton and SimpleText examples bring up the important topic of
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton和SimpleText示例引出了一个重要的话题
- en: interface versus implementation. As mentioned i[n Chapter 4, t](index_split_001.html#p86)he
    interface refers to how something is used, while the implementation refers to
    how
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接口与实现。如第4章中提到的，[接口](index_split_001.html#p86)指的是某个东西如何被使用，而实现则指的是其内部工作原理。
- en: something works (internally).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内部是如何运作的（即某些功能的实现）。
- en: In an OOP environment, the interface is the set of methods in a class and
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP环境中，接口是类中一组方法的集合，
- en: their related parameters—also known as the *application programming interface*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它们相关的参数——也称为*应用程序编程接口*
- en: '*(API)*. The implementation is the actual code of all the methods in the class.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*(API)*。实现则是类中所有方法的实际代码。'
- en: An external package such as pygame will most likely come with docu-
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个外部包，如pygame，通常会附带文档
- en: mentation of the API that explains the calls that are available and the
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API文档解释了可以调用的函数以及每次调用时你需要传递的参数。
- en: arguments you are expected to pass with each call. The full pygame API
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在每次调用时传递的参数。完整的pygame API
- en: documentation is available at [*https://www.pygame.org/docs/*](https://www.pygame.org/docs/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在 [*https://www.pygame.org/docs/*](https://www.pygame.org/docs/) 找到。
- en: When you write code that makes calls to pygame, you don’t need to worry
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写调用 pygame 的代码时，你不需要担心
- en: about the implementation of the methods you are using. For example,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你正在使用的方法的实现。例如，
- en: when you make a call to blit() to draw image, you really don’t care *how*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 blit() 来绘制图像时，你其实并不关心 *如何*
- en: blit() does what it does; you just need to know *what* the call does and what
    arguments need to be passed in. On the other side, you can trust that the
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: blit() 做它应该做的事情；你只需要知道 *它* 的调用是做什么的，以及需要传入哪些参数。另一方面，你可以相信
- en: implementer(s) who wrote the blit() method have thought extensively
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现者（编写 blit() 方法的人）已经深入思考了
- en: about how to make blit() work most efficiently.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何让 blit() 高效工作。
- en: In the programming world, we often wear two hats as both the imple-
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，我们经常扮演两种角色，既是实现者，
- en: menter and the application developer, so we need to make an effort to design
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设计者和应用程序开发人员，因此我们需要努力设计
- en: APIs that not only make sense in the current situation, but also are general
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅在当前情况下有意义，而且是通用的 API，
- en: enough to be used by future programs of our own and by programs written
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 足够通用，可以供我们自己未来的程序和其他人编写的程序使用
- en: by other people. Our SimpleButton and SimpleText classes are good examples,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他人编写。我们的 SimpleButton 和 SimpleText 类是很好的例子，
- en: as they are written in a general way so that they can be reused easily. I’ll
    talk
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是以通用的方式编写的，因此可以轻松重用。我会讲解
- en: more about interface versus implementation i[n Chapter 8, w](#p192)hen we look
    at encapsulation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于接口与实现的内容[参见第8章，w](#p192)，我们将在那时探讨封装。
- en: '**Callbacks**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: When using a SimpleButton object, we handle checking for and reacting to a
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SimpleButton 对象时，我们处理检查并响应
- en: 'button click like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击事件如下：
- en: 'if oButton.handleEvent(event):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oButton.handleEvent(event):'
- en: print('The button was clicked')
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: print('按钮被点击了')
- en: Object-Oriented Pygame **137**
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **137**
- en: This approach to handling events works well with the SimpleButton class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事件处理方法适用于 SimpleButton 类。
- en: However, some other Python packages and many other programming lan-
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他一些 Python 包和许多其他编程语言
- en: 'guages handle events in a different way: with a *callback*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 语言通过不同的方式处理事件：使用 *回调函数*。
- en: '**callback**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: A function or method of an object that is cal ed when a particular action, event,
    or condition happens .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个特定的动作、事件或条件发生时，一个对象的函数或方法会被调用。
- en: An easy way to understand this is to think about the 1984 hit movie
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容易理解这个概念的方法是思考一下1984年上映的热门电影
- en: '*Ghostbusters*. The tagline for the movie is “Who you gonna call?” In the'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*幽灵捕手*。电影的标语是“你会打电话给谁？” 在'
- en: movie, the Ghostbusters ran an ad on TV that told people that if they saw
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 电影中，幽灵捕手在电视上播出了一则广告，告诉人们，如果他们看到
- en: a ghost (that’s the event to look for), they should call the Ghostbusters (the
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个幽灵（这就是需要寻找的事件），他们应该联系幽灵捕手（
- en: callback) to get rid of it. Upon receiving the call, the Ghostbusters take the
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: callback) 来摆脱它。接收到调用时，幽灵捕手会采取行动
- en: appropriate actions to eliminate the ghost.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 采取适当的行动来消除幽灵。
- en: As an example, consider a button object that is initialized to have a
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个按钮对象，它被初始化为拥有一个
- en: callback. When the user clicks the button, the button will call the callback
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数。当用户点击按钮时，按钮会调用回调函数
- en: function or method. That function or method executes whatever code is
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法。那个函数或方法执行任意代码
- en: needed to react to the button click.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 需要响应按钮点击事件。
- en: '***Creating a Cal back***'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建回调函数***'
- en: To set up a callback, when you create an object or call one of an object’s
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置回调函数，当你创建一个对象或调用一个对象的
- en: methods, you pass the name of a function or a method of an object to be
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，你传递一个函数的名称或一个对象的方法，以便执行
- en: called. As an example, there is a standard GUI package for Python called
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用。举个例子，有一个用于 Python 的标准 GUI 包，名为
- en: tkinter. The code needed to create a button with this package is very differ-
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter。使用此包创建按钮的代码非常不同，
- en: 'ent from what I have shown—here’s an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与我展示的有所不同——这是一个示例：
- en: import tkinter
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 tkinter
- en: 'def myFunction():'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myFunction():'
- en: print('myCallBackFunction was called')
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: print('myCallBackFunction 被调用了')
- en: oButton = tkinter.Button(text='Click me', command=myFunction)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = tkinter.Button(text='点击我', command=myFunction)
- en: When you create a button with tkinter, you must pass in a function (or
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 tkinter 创建按钮时，必须传入一个函数（或
- en: a method of an object), which will be called back when the user clicks the
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的方法），当用户点击按钮时，它会被调用。
- en: button. Here, we are passing myFunction as the function to be called back.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮。这里，我们将 myFunction 作为回调函数传递。
- en: (This call is using keyword parameters, which will be discussed at length
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （这个调用使用了关键字参数，我们将在后续详细讨论）
- en: in [Chapter 7.) T](#p172)he tkinter button remembers that function as the callback,
    and when the user clicks the resulting button, it calls the function
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](#p172)，tkinter按钮将该函数记住作为回调函数，当用户点击该按钮时，它会调用该函数。
- en: myFunction().
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: myFunction().
- en: You can also use a callback when you initiate some action that may
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动一些可能需要时间的操作时，你也可以使用回调。
- en: take some time. Instead of waiting for the action to finish and causing the
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些时间。与其等待操作完成并导致程序
- en: program appear to freeze for a period of time, you provide a callback to be
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 程序看起来会在一段时间内冻结，你提供一个回调函数
- en: called when the action is completed. For example, imagine that you want to
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作完成时调用。例如，假设你希望
- en: make a request across the internet. Rather than making a call and waiting
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 发出互联网请求。与其进行调用并等待
- en: for that call to return data, which may take a long time, there are packages
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个调用返回数据，可能需要一些时间，相关的包
- en: that allow you to use the approach of making the call and setting a callback.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让你使用调用并设置回调函数的方法。
- en: That way, the program can continue running, and the user is not locked
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，程序可以继续运行，用户不会被锁定
- en: '**138** Chapter 6'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**138** 第6章'
- en: out of it. This often involves multiple Python threads and is beyond the scope
    of this book, but the technique of using a callback is the general way
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从中解脱出来。这通常涉及多个 Python 线程，超出了本书的范围，但使用回调的技术是一般的方式
- en: that it is done.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它已完成。
- en: '***Using a Cal back with SimpleButton***'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用回调函数与 SimpleButton***'
- en: To demonstrate this concept, we’ll make a minor modification to the
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，我们将对
- en: SimpleButton class to allow it to accept a callback. As an additional optional
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 SimpleButton 类，使其能够接受回调函数。作为附加的可选项
- en: parameter, the caller can provide a function or method of an object to be
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 参数中，调用者可以提供一个函数或对象的方法作为回调
- en: called back when a click on a SimpleButton object happens. Each instance of
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 SimpleButton 对象时，会回调该函数。每个实例
- en: SimpleButton remembers the callback in an instance variable. When the user
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton 在实例变量中记住回调函数。当用户
- en: completes a click, the instance of SimpleButton calls the callback.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成点击后，SimpleButton 的实例调用回调函数。
- en: The main program in Listing 6-8 creates three instances of the
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-8 中的主程序创建了三个实例
- en: SimpleButton class, each of which handles the button click in a different way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton 类，每个类以不同的方式处理按钮点击。
- en: The first button, oButtonA, provides no callback; oButtonB provides a callback
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮 oButtonA 不提供回调；oButtonB 提供回调函数
- en: to a function; and oButtonC specifies a callback to a method of an object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到一个函数；oButtonC 指定一个回调，调用对象的方法。
- en: '**File: PygameDemo9_SimpleButtonWithCallback/Main_SimpleButtonCallback.py**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo9_SimpleButtonWithCallback/Main_SimpleButtonCallback.py**'
- en: pygame demo 9 - 3-button test with callbacks
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 9 - 3个按钮测试与回调函数
- en: 1 - Import packages
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: from SimpleButton import *
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleButton import *
- en: import sys
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: '#2 - Define constants'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#2 - 定义常量'
- en: GRAY = (200, 200, 200)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: GRAY = (200, 200, 200)
- en: WINDOW_WIDTH = 400
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 400
- en: WINDOW_HEIGHT = 100
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 100
- en: FRAMES_PER_SECOND = 30
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: Define a function to be used as a "callback"
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个函数，作为“回调”
- en: 'def myCallBackFunction(): 1'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myCallBackFunction(): 1'
- en: print('User pressed Button B, called myCallBackFunction')
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: print('用户按下了按钮B，调用了我的回调函数')
- en: Define a class with a method to be used as a "callback"
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个类，并为其方法指定一个“回调”函数
- en: 'class CallBackTest(): 2'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'class CallBackTest(): 2'
- en: '--- snipped any other methods in this class ---'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪切掉该类中的其他方法 ---'
- en: 'def myMethod(self):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myMethod(self):'
- en: print('User pressed ButtonC, called myMethod of the CallBackTest object')
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: print('用户按下了按钮C，调用了 CallBackTest 对象的 myMethod')
- en: 3 - Initialize the world
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图片、声音等。
- en: 5 - Initialize variables
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: Object-Oriented Pygame **139**
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **139**
- en: oCallBackTest = CallBackTest() 3
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: oCallBackTest = CallBackTest() 3
- en: Create instances of SimpleButton
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SimpleButton 的实例
- en: No call back
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无回调函数
- en: oButtonA = SimpleButton(window, (25, 30), 4
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonA = SimpleButton(window, (25, 30), 4
- en: '''images/buttonAUp.png'','
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonAUp.png'','
- en: '''images/buttonADown.png'')'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonADown.png'')'
- en: Specifying a function to call back
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个函数作为回调函数
- en: oButtonB = SimpleButton(window, (150, 30),
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonB = SimpleButton(window, (150, 30),
- en: '''images/buttonBUp.png'','
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonBUp.png'','
- en: '''images/buttonBDown.png'','
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonBDown.png'','
- en: callBack=myCallBackFunction)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: callBack=myCallBackFunction)
- en: Specifying a method of an object to call back
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个对象的方法进行回调
- en: oButtonC = SimpleButton(window, (275, 30),
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonC = SimpleButton(window, (275, 30),
- en: '''images/buttonCUp.png'','
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonCUp.png'','
- en: '''images/buttonCDown.png'','
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonCDown.png'','
- en: callBack=oCallBackTest.myMethod)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: callBack=oCallBackTest.myMethod)
- en: counter = 0
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: counter = 0
- en: 6 - Loop forever
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: Pass the event to the button, see if it has been clicked on
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事件传递给按钮，查看它是否被点击
- en: 'if oButtonA.handleEvent(event): 5'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oButtonA.handleEvent(event): 5'
- en: print('User pressed button A, handled in the main loop')
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: print('用户按下了按钮 A，已在主循环中处理')
- en: oButtonB and oButtonC have callbacks,
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: oButtonB 和 oButtonC 都有回调，
- en: no need to check result of these calls
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不需要检查这些调用的结果
- en: oButtonB.handleEvent(event) 6
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonB.handleEvent(event) 6
- en: oButtonC.handleEvent(event) 7
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonC.handleEvent(event) 7
- en: 8 - Do any "per frame" actions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”动作
- en: counter = counter + 1
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: counter = counter + 1
- en: 9 - Clear the window
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: window.fill(GRAY)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(GRAY)
- en: 10 - Draw all window elements
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: oButtonA.draw()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonA.draw()
- en: oButtonB.draw()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonB.draw()
- en: oButtonC.draw()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonC.draw()
- en: 11 - Update the window
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减缓速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 6-8: A version of the main program that handles but on clicks three
    different ways* **140** Chapter 6'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-8: 处理按钮点击的三种不同方式的主程序版本* **140** 第六章'
- en: We start with a simple function, myCallBackFunction() 1, that just prints a
    message to announce that it has been called. Next, we have a CallBackTest
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的函数 myCallBackFunction() 1 开始，它只会打印一条消息，表示它已被调用。接下来，我们有一个 CallBackTest
- en: class that contains the method myMethod() 2, which prints its own message
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 包含方法 myMethod() 的类 2，它打印自己的消息
- en: to announce that it’s been called. We create an oCallBackTest object from
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以宣布它已被调用。我们从 oCallBackTest 创建一个对象
- en: the CallBackTest class 3\. We need this object so we can set up a callback to
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: CallBackTest 类 3\. 我们需要这个对象，以便可以设置回调函数来
- en: oCallBack.myMethod().
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: oCallBack.myMethod()。
- en: Then we create three SimpleButton objects, each using a different
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建三个 SimpleButton 对象，每个对象使用不同的
- en: approach 4\. The first, oButtonA, has no callback. The second, oButtonB, sets
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 4\. 第一个，oButtonA，没有回调。第二个，oButtonB，设置
- en: its callback to the function myCallBackFunction(). The third, oButtonC, sets
    its
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将回调函数设置为 myCallBackFunction()。第三个，oButtonC，设置它的
- en: callback to oCallBack.myMethod().
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 回调到 oCallBack.myMethod()。
- en: In the main loop, we check for the user clicking on any of the three
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们检查用户是否点击了三个按钮中的任何一个
- en: buttons by calling the handleEvent() method of each button. Since oButtonA
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用每个按钮的 handleEvent() 方法来处理按钮事件。由于 oButtonA
- en: has no callback, we must check if the value returned is True 5 and, if so,
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回调函数，我们必须检查返回的值是否为 True 5，并且，如果是的话，
- en: perform an action. When oButtonB is clicked 6, the myCallBackFunction()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行某个操作。当 oButtonB 被点击时 6，myCallBackFunction()
- en: function will be called and will print its message. When oButtonC is clicked
    7,
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将被调用并打印消息。当 oButtonC 被点击时 7，
- en: the myMethod() method of the oCallBackTest object will be called and will
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: oCallBackTest 对象的 myMethod() 方法将被调用，并且
- en: print its message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打印它的消息。
- en: Some programmers prefer using a callback approach, because the tar-
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员更喜欢使用回调方法，因为目标—
- en: get to be called is set up when you create the object. It’s important to under-
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的方法是在创建对象时设置的。理解这一点非常重要—
- en: stand this technique, especially if you are using a package that requires
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种技术，特别是当你使用一个需要
- en: it. However, I will use the original approach of checking for the value
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 它。然而，我将使用原始方法来检查返回值
- en: returned by a call to handleEvent() in all my demonstration code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我所有的示范代码中，都会通过调用 handleEvent() 返回。
- en: '**Summary**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, I showed how you can start with a procedural program and
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了如何从一个过程化程序开始并
- en: extract related code to build a class. We created a Ball class to demonstrate
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 提取相关代码以构建一个类。我们创建了一个 Ball 类来演示
- en: this, then modified the main code of our demo program from the previous
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将我们的示范程序的主要代码从之前的
- en: chapter to call methods of the class to tell the Ball object *what* to do, without
    worrying about *how* it achieves the outcome. With all the related code in a separate
    class, it’s easy to create a list of objects and instantiate and manage as many
    objects as we want to.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We then built a SimpleButton class and a SimpleText class that hide com-
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: plexity inside their implementation and create highly reusable code. In the
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: next chapter, I’ll build on these classes to develop “professional-strength”
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: button and text display classes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I introduced the concept of a callback, where you pass in a func-
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: tion or method in a call to an object. The callback is later called back when
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: an event happens or an action completes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **141**
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**7**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**P Y G A M E G U I W I D G E T S**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Pygame allows programmers to take the
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: text-based language of Python and use it
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: to build GUI-based programs. Windows,
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: pointing devices, clicking, dragging, and
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: sounds have all become standard parts of our expe-
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: rience using computers. Unfortunately, the pygame
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: package doesn’t come with built-in basic user inter-
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: face elements, so we need to build them ourselves.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We’ll do so with pygwidgets, a library of GUI widgets.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how standard widgets such as images, buttons,
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: and input or output fields can be built as classes and how client code uses
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: them. Building each element as a class allows programmers to incorporate
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: multiple instances of each element when creating a GUI. Before we get
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: started building these GUI widgets, however, I first need to discuss one
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'more Python feature: passing data in a call to a function or method.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing Arguments into a Function or Method**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The arguments in a call to a function and the parameters defined in the
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: function have a one-to-one relationship, so that the value of the first argu-
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: ment is given to the first parameter, the value of the second argument is
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: given to the second parameter, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7-1, duplicated fro[m Chapter 3, s](index_split_001.html#p76)hows that
    the same is true when you make a call to a method of an object. We can see that
    the first parameter, which is always self, is set to the object in the call.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'def someMethod(self, *<any other parameters>* ):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: oSomeObject.someMethod( *<any other arguments>* )
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-1: How arguments passed into a method match up with its parameters*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: However, Python (and some other languages) allows you to make some
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: of the arguments optional. If an optional argument isn’t provided in a call,
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: we can provide a default value to use in the function or method instead. I’ll
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: explain by means of a real-world analogy.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: If you order a hamburger at a Burger King restaurant, your burger will
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: come with ketchup, mustard, and pickles. But Burger King is famous for
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: saying, “You can have it your way.” If you want some other combination of
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: condiments, you must say what you want (or don’t want) when you make
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: your order.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by writing an orderBurgers() function that simulates making
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个 orderBurgers() 函数开始，它模拟下订单
- en: a burger order in the regular way we’ve been defining functions, without
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们定义函数的常规方式订购汉堡，
- en: 'implementing default values:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实现默认值：
- en: 'def orderBurgers(nBurgers, ketchup, mustard, pickles):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderBurgers(nBurgers, ketchup, mustard, pickles):'
- en: You must specify the number of hamburgers you want to order, but
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须指定你想要订购的汉堡数量，但是
- en: ideally, if you want the defaults of True for adding ketchup, mustard, and
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，如果你想要添加番茄酱、芥末和酸黄瓜的默认值 True
- en: pickles, you shouldn’t need to pass in any more arguments. So, to order two
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 酸黄瓜，你不需要传递更多的参数。因此，要订购两个
- en: hamburgers with the standard defaults, you might think your call should
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准默认值订购汉堡时，你可能认为你的调用应该
- en: 'look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: 'orderBurgers(2) # with ketchup, mustard, and pickles'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderBurgers(2) # 带番茄酱、芥末和酸黄瓜'
- en: However, in Python, this will trigger an error because there is a mis-
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Python 中，这将触发一个错误，因为存在不匹配—
- en: match between the number of arguments in the call and the number of
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中的参数数量与
- en: 'parameters specified in the function:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中指定的参数：
- en: 'TypeError: orderBurgers() missing 3 required positional arguments: ''ketchup'','
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: TypeError：orderBurgers() 缺少 3 个必需的位置参数：'ketchup'，
- en: '''mustard'', and ''pickles'''
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '''芥末''，和''酸黄瓜'''
- en: Let’s see how Python allows us to set up optional parameters that can
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 如何允许我们设置可选参数，这些参数可以
- en: be given default values if nothing is specified.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定任何值，它们将被赋予默认值。
- en: '**144** Chapter 7'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**144** 第7章'
- en: '***Positional and Keyword Parameters***'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '***位置和关键字参数***'
- en: 'Python has two different types of parameters: positional parameters and'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种不同类型的参数：位置参数和
- en: keyword parameters. *Positional parameters* are the type that we’re already
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数。*位置参数*是我们已经熟悉的类型，
- en: familiar with, where each argument in a call has a matching parameter in
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的位置参数，其中调用中的每个参数都有一个对应的参数
- en: the function or method definition.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法定义。
- en: 'A *keyword parameter* allows you to specify a default value. You write a keyword
    parameter as a variable name, an equal sign, and a default value, like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*关键字参数*允许你指定一个默认值。你写一个关键字参数的方式是变量名、等号和默认值，像这样：
- en: 'def someFunction( *<keywordParameter>* = *<default value>* ): You can have
    multiple keyword parameters, each with a name and a'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'def someFunction( *<keywordParameter>* = *<default value>* ): 你可以有多个关键字参数，每个参数都有一个名称和一个'
- en: default value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值。
- en: A function or method can have both positional parameters and key-
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数或方法可以同时具有位置参数和关键字参数，
- en: word parameters, in which case you must specify all positional parameters
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数，在这种情况下，你必须在每次调用时指定所有位置参数
- en: '*before* any keyword parameters:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何关键字参数*之前*：
- en: def someOtherFunction(positionalParam1, positionalParam2, ...
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: def someOtherFunction(positionalParam1, positionalParam2, ...
- en: '*<keywordParameter1>* = *<default value 1>* ,'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*<keywordParameter1>* = *<default value 1>* ,'
- en: '*<keywordParameter2>* = *<default value 2>* , ...):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*<keywordParameter2>* = *<default value 2>* , ...):'
- en: Let’s rewrite orderBurgers() to use one positional parameter and three
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写 orderBurgers()，使用一个位置参数和三个
- en: 'keyword parameters with default values, like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 带有默认值的关键字参数，像这样：
- en: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
- en: When we make a call to this function, nBurgers is a positional parameter
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，nBurgers 是一个位置参数
- en: and therefore must be specified as an argument in every call. The other three
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，必须在每次调用时作为参数指定。其他三个
- en: are keyword parameters. If no values are passed for ketchup, mustard, and pick-
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 是关键字参数。如果没有为番茄酱、芥末和酸黄瓜传递值，
- en: les, the function will use the default value of True for each of those parameter
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，函数将对这些参数使用默认值 True
- en: 'variables. Now we can order two burgers with all the condiments like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。现在我们可以这样订购两个汉堡，附带所有调味料：
- en: orderBurgers(2)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2)
- en: If we want something other than a default value, we can specify the name
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要其他的值而不是默认值，我们可以指定名字
- en: of the keyword parameter and a different value in our call. For example, if
    we
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数和调用中的不同值。例如，如果我们
- en: 'only want ketchup on our two burgers, we can make the call this way:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在两个汉堡上加番茄酱，我们可以这样调用：
- en: orderBurgers(2, mustard=False, pickles=False)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2, mustard=False, pickles=False)
- en: When the function runs, the values of the mustard and pickles variables
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数运行时，芥末和酸黄瓜变量的值
- en: are set to False. Since we did not specify a value for ketchup, it is given
    the
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置为 False。由于我们没有为番茄酱指定值，它会被赋予
- en: default of True.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为True。
- en: You can also make the call specifying all arguments positionally, includ-
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: ing those written as keyword parameters. Python will use the ordering of
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'your arguments to assign each parameter the correct value:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, True, False, False)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: In this call, we are again specifying two burgers with ketchup, no mus-
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: tard, and no pickles.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **145**
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '***Additional Notes on Keyword Parameters***'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly go over a few conventions and tips for using keyword param-
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: eters. As a Python convention, when you use keyword parameters and key-
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: words with arguments, the equal sign between the keyword and the value
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'should *not* have spaces around it, to show that these are not typical assignment
    statements. These lines are properly formatted:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, mustard=False)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: These lines will also work fine, but they don’t follow the formatting con-
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'vention and are less readable:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderBurgers(nBurgers, ketchup = True, mustard = True, pickles = True):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: orderBurgers(2, mustard = False)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: When calling a function that has both positional parameters and key-
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: word parameters, you must provide values for all the positional parameters
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: first, before any optional keyword parameters.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments in calls can be specified in any order. Calls to our
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers() function could be made in various ways, such as:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers(2, mustard=False, pickles=False) # only ketchup'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'or:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'orderBurgers(2, pickles=False, mustard=False, ketchup=False) # plain'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: All keyword parameters will be given the appropriate values, indepen-
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: dent of the order of the arguments.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: While all the default values in the orderBurgers() example were Boolean
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: values, a keyword parameter can have a default value of any data type. For
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: example, we could write a function to allow a customer to make an ice
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'cream order like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderIceCream(flavor, nScoops=1, coneOrCup=''cone'', sprinkles=False):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: The caller must specify a flavor, but by default will get one scoop in a
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: cone with no sprinkles. The caller could override these defaults with differ-
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: ent keyword values.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '***Using None as a Default Value***'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: It’s sometimes helpful to know whether the caller passed in a value for a
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: keyword parameter or not. For this example, the caller orders a pizza. At
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: a minimum, the caller must specify a size. The second parameter will be a
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: style that defaults to 'regular' but could be 'deepdish'. As a third parameter,
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '**146** Chapter 7'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: the caller can optionally pass in a single desired topping. If the caller wants
    a topping, we must charge them extra.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 7-1, we’ll use a positional parameter for the size and key-
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: word parameters for the style and topping. The default for style is the string
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '''regular''. Since the topping choice is optional, we’ll use the special Python'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: value of None as the default, but the caller may pass in the topping of their
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: choice.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '**File: OrderPizzaWithNone.py**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'def orderPizza(size, style=''regular'', topping=None):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Do some calculations based on the size and style
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据大小和风格进行一些计算
- en: Check if a topping was specified
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否指定了配料
- en: 'PRICE_OF_TOPPING = 1.50 # price for any topping'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'PRICE_OF_TOPPING = 1.50 # 每种配料的价格'
- en: 'if size == ''small'':'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'if size == ''small'':'
- en: price = 10.00
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: price = 10.00
- en: 'elif size == ''medium'':'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif size == ''medium'':'
- en: price = 14.00
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: price = 14.00
- en: 'else: # large'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'else: # 大号'
- en: price = 18.00
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: price = 18.00
- en: 'if style == ''deepdish'':'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 'if style == ''deepdish'':'
- en: 'price = price + 2.00 # charge extra for deepdish'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'price = price + 2.00 # 对深盘收取额外费用'
- en: line = 'You have ordered a ' + size + ' ' + style + ' pizza with '
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: line = '你订购了一个 ' + size + ' ' + style + ' 比萨，上面有 '
- en: '1 if topping is None: # check if no topping was passed in'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '1 if topping is None: # 检查是否没有传入配料'
- en: print(line + 'no topping')
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: print(line + '没有配料')
- en: 'else:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print(line + topping)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: print(line + topping)
- en: price = price + PRICE_OF_TOPPING
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: price = price + PRICE_OF_TOPPING
- en: print('The price is $', price)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: print('价格是 $', price)
- en: print()
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: 'You could order a pizza in the following ways:'
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以通过以下几种方式订购比萨：
- en: '2 orderPizza(''large'') # large, defaults to regular, no topping'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '2 orderPizza(''large'') # 大号，默认为常规，没有配料'
- en: 'orderPizza(''large'', style=''regular'') # same as above'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderPizza(''large'', style=''regular'') # 与上面相同'
- en: 3 orderPizza('medium', style='deepdish', topping='mushrooms')
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 3 orderPizza('medium', style='deepdish', topping='mushrooms')
- en: 'orderPizza(''small'', topping=''mushrooms'') # style defaults to regular'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderPizza(''small'', topping=''mushrooms'') # 风格默认为常规'
- en: '*Listing 7-1: A function with a keyword parameter defaulting to None*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：带有默认值为 None 的关键字参数的函数*'
- en: The first and second calls would be seen as the same, with the value of
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个调用会被视为相同，topping 的值为
- en: the variable topping set to None 2\. In the third and fourth calls, the value
    of
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 topping 设置为 None 2\. 在第三和第四个调用中，topping 的值为
- en: topping is set to 'mushrooms' 3\. Because 'mushrooms' is not None, in these
    calls
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: topping 设置为 'mushrooms' 3\. 因为 'mushrooms' 不是 None，在这些调用中
- en: the code would add in an extra charge for a topping on the pizzas 1\.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 代码会为比萨上的配料添加额外费用 1\。
- en: Using None as a default value for a keyword parameter gives you a way to
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 None 作为关键字参数的默认值为你提供了一种方法来
- en: see if the caller provided a value in the call. This may be a very subtle use
    of
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 查看调用者是否在调用中提供了值。这可能是非常微妙的用法
- en: keyword parameters, but it will be very useful in our upcoming discussion.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数，但它将在我们接下来的讨论中非常有用。
- en: Pygame GUI Widgets **147**
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **147**
- en: '***Choosing Keywords and Default Values***'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '***选择关键字和默认值***'
- en: Using default values makes calling functions and methods simpler, but
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认值使调用函数和方法变得更简单，但
- en: there is a downside. Your choice of each keyword for keyword parameters
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这存在一个缺点。你为关键字参数选择的每个关键字
- en: is very important. Once programmers start making calls that override
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要。一旦程序员开始调用覆盖默认值的函数，
- en: default values, it’s very difficult to change the name of a keyword parameter
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值时，改变关键字参数的名称就变得非常困难
- en: because that name must be changed in *all* calls to the function or method
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该名称必须在*所有*对函数或方法的调用中都进行更改
- en: in lockstep. Otherwise, code that was working will break. For more widely
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 同步进行。否则，原本正常运行的代码将会崩溃。更多广泛
- en: distributed code, this can potentially cause a great deal of pain to program-
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式代码，这可能会给程序员带来很大的麻烦——
- en: mers using your code. Bottom line, don’t change the name of a keyword
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你代码的程序员。最重要的是，不要改变关键字的名称
- en: parameter unless it is absolutely necessary. So, choose wisely!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 除非绝对必要，否则不要更改关键字参数的名称。所以，明智地选择！
- en: It’s also very important to use default values that should suit the widest
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，选择适合最大范围用户的默认值也非常重要
- en: possible range of users. (On a personal note, I *hate* mustard! Whenever I go
    to Burger King, I have to remember to specify no mustard or I’ll get what I consider
    to be an inedible hamburger. I think they made a bad default choice.)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 可能适合更广泛用户范围的（顺便说一句，我*讨厌*芥末！每次去汉堡王时，我都得记得指定不加芥末，否则我会得到我认为无法吃的汉堡。我觉得他们做出了一个糟糕的默认选择。）
- en: '***Default Values in GUI Widgets***'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '***GUI 小部件中的默认值***'
- en: In the next section, I’ll present a collection of classes that you can use to
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将展示一系列类，你可以用来
- en: easily create GUI elements such as buttons and text fields within pygame.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松在 pygame 中创建按钮和文本字段等 GUI 元素。
- en: These classes will each be initialized using a few positional parameters but
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类将通过使用一些位置参数来初始化
- en: will also have assorted optional keyword parameters, all with reasonable
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 还将包含各种可选的关键字参数，所有这些参数都有合理的
- en: defaults to allow programmers to create GUI widgets by specifying only a
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为让程序员通过仅指定一个来创建 GUI 小部件
- en: few positional arguments. More precise control can be obtained by specify-
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 少数位置参数。通过指定更精确的控制可以获得更多的控制，
- en: ing values to overwrite the default values of keyword parameters.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 为关键字参数的默认值提供新的值。
- en: For an in-depth example, we’ll look at a widget to display text in the
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一个深入的例子，我们将看一个用于显示文本的小部件
- en: application’s window. Text can be shown in a variety of fonts, font sizes, col-
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序窗口。文本可以以各种字体、字体大小、颜色、背景色等形式显示。我们将构建一个 DisplayText 类来展示这一点。
- en: ors, background colors, and so on. We’ll build a DisplayText class that will
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 字体、背景色等方面。我们将构建一个 DisplayText 类来展示这一点。
- en: have default values for all of these attributes but will give client code the
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性有默认值，但会给客户端代码提供
- en: option of specifying different values.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 指定不同值的选项。
- en: '**The pygwidgets Package**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**pygwidgets 包**'
- en: The rest of this chapter will focus on the pygwidgets (pronounced “pig
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余内容将聚焦于 pygwidgets（发音为“pig widgets”）包
- en: 'wijits”) package, which was written with two goals in mind:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: wijits”) 包，该包的编写目标是：
- en: 1\. To demonstrate many different object-oriented programming techniques
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 展示多种不同的面向对象编程技术
- en: 2\. To allow programmers to easily create and use GUI widgets in pygame
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 让程序员可以轻松创建和使用 pygame 中的 GUI 小部件
- en: programs
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 程序
- en: 'The pygwidgets package contains the following classes:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包包含以下类：
- en: '**TextButton**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextButton**'
- en: Button built with standard art, using a text string
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本字符串构建的标准艺术按钮
- en: '**CustomButton**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**CustomButton**'
- en: Button with custom artwork
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义艺术作品的按钮
- en: '**148** Chapter 7'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**148** 第7章'
- en: '**TextCheckBox**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextCheckBox**'
- en: Checkbox with standard art, built from a text string
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本字符串构建的标准艺术复选框
- en: '**CustomCheckBox**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**CustomCheckBox**'
- en: Checkbox with custom artwork
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义艺术作品的复选框
- en: '**TextRadioButton**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextRadioButton**'
- en: Radio buttons with standard art, built from a text string
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本字符串构建的标准艺术单选按钮
- en: '**CustomRadioButton**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**CustomRadioButton**'
- en: Radio buttons with custom artwork
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义艺术作品的单选按钮
- en: '**DisplayText**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**DisplayText**'
- en: Field used to display output text
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示输出文本的字段
- en: '**InputText**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**InputText**'
- en: Field where the user can type text
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以输入文本的字段
- en: '**Dragger**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dragger**'
- en: Allows the user to drag an image
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户拖动图像
- en: '**Image**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像**'
- en: Displays an image at a location
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定位置显示图像
- en: '**ImageCollection**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**ImageCollection**'
- en: Displays one of a collection of images at a location
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定位置显示一张图片
- en: '**Animation**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画**'
- en: Displays a sequence of images
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一系列图像
- en: '**SpriteSheetAnimation**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpriteSheetAnimation**'
- en: Displays a sequence of images from a single larger image
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个较大图像中显示一系列图像
- en: '***Setting Up***'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '***设置***'
- en: 'To install pygwidgets, open the command line and enter the following:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 pygwidgets，请打开命令行并输入以下内容：
- en: python3 -m pip install -U pip --user
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pip --user
- en: python3 -m pip install -U pygwidgets --user
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pygwidgets --user
- en: These commands download and install the latest version of pygwidgets
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令下载并安装最新版本的 pygwidgets
- en: from the Python Package Index (PyPI). It is placed into a folder (named
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 包索引（PyPI）下载。它被放置在一个文件夹中（命名为
- en: '*site-packages*) that is available to all your Python programs. Once installed,
    you can use pygwidgets by including the following statement at the beginning of
    your programs:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*site-packages*)，它对所有 Python 程序可用。安装后，你可以通过在程序开始部分包括以下语句来使用 pygwidgets：'
- en: import pygwidgets
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygwidgets
- en: This imports the entire package. After importing, you can instantiate
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入整个包。导入后，你可以实例化
- en: objects from its classes and call the methods of those objects.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 从其类中创建对象并调用这些对象的方法。
- en: Pygame GUI Widgets **149**
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **149**
- en: The most current documentation of pygwidgets is a[t *https://pygwidgets*](https://pygwidgets.readthedocs.io/en/latest/)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 的最新文档可以在 [*https://pygwidgets*](https://pygwidgets.readthedocs.io/en/latest/)
    找到
- en: '[*.readthedocs.io/en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).
    If you’d like to view the source code for the package, it’s available via my GitHub
    repository at [*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[*.readthedocs.io/en/latest/*](https://pygwidgets.readthedocs.io/en/latest/)。如果你想查看该包的源代码，可以通过我的
    GitHub 仓库访问，链接在这里：[*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)'
- en: '***Overall Design Approach***'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '***总体设计方法***'
- en: As shown i[n Chapter 5, o](index_split_002.html#p118)ne of the first things
    you do in every pygame program is to define the window of the application. The
    following line creates
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如第5章所示，在每个 pygame 程序中你首先要做的事情之一就是定义应用程序的窗口。以下一行创建了
- en: 'an application window and saves a reference to it in a variable named window:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序窗口并将其引用保存在名为 window 的变量中：
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: As we will soon see, whenever we instantiate any widget, we will need to
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快会看到的，每当我们实例化一个小部件时，我们都需要
- en: pass in the window variable so the widget can draw itself in the application’s
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 将窗口变量传递给小部件，以便小部件可以在应用程序的
- en: window.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。
- en: Most widgets in pygwidgets work in a similar way, typically involving
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 中的大多数小部件工作方式类似，通常涉及
- en: 'these three steps:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这三步如下：
- en: 1\. Before the main while loop starts, create an instance of the widget, pass-
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在主 while 循环开始之前，创建一个小部件实例，传入
- en: ing in any initialization arguments.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何初始化参数中。
- en: 2\. In the main loop, whenever any event happens, call the handleEvent()
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 在主循环中，每当发生任何事件时，调用 handleEvent()
- en: method of the widget (passing in the event object).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的 handleEvent() 方法（传入事件对象）。
- en: 3\. At the bottom of the main loop, call the draw() method of the widget.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在主循环底部，调用小部件的 draw() 方法。
- en: 'Step 1 in using any widget is to instantiate one with a line like this:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何小部件的第一步是通过以下代码实例化一个：
- en: oWidget = pygwidgets. *<SomeWidgetClass>* (window, loc, *<other arguments as
    needed>* ) The first argument is always the window of the application. The second
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: oWidget = pygwidgets. *<SomeWidgetClass>* (window, loc, *<其他需要的参数>* ) 第一个参数始终是应用程序的窗口。第二个
- en: argument is always the location in the window at which to display the wid-
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 参数始终是小部件显示在窗口中的位置。
- en: 'get, given as a tuple: (x, y).'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的事件是一个元组：(x, y)。
- en: Step 2 is to handle any event that could affect the widget by calling the
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步是通过调用 handleEvent() 处理任何可能影响小部件的事件
- en: object’s handleEvent() method inside the event loop. If any event (like a mouse
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的 handleEvent() 方法位于事件循环中。如果任何事件（如鼠标
- en: click or button press) happens and the widget handles the event, this call will
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生点击或按键事件，并且小部件处理该事件，则此调用将
- en: 'return True. The code at the top of the main while loop generally looks like
    this:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True。主 while 循环顶部的代码通常看起来像这样：
- en: 'while True:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oWidget.handleEvent(event):'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oWidget.handleEvent(event):'
- en: The user has done something to oWidget that we should respond to
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户对 oWidget 做了某些事情，我们应该对此做出响应
- en: Add code here
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在此处添加代码
- en: Step 3 is to add a line near the bottom of the while loop to call the
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步是在 while 循环的底部添加一行，调用
- en: 'draw() method of the widget, to make it appear it in the window:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的 draw() 方法，以使其在窗口中显示：
- en: oWidget.draw()
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: oWidget.draw()
- en: '**150** Chapter 7'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**第150章 第七章**'
- en: Since we specified the window to draw into, the location, and any
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了要绘制的窗口、位置以及任何
- en: details that affect the appearance of the widget in step 1, we don’t pass any-
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中影响小部件外观的详细信息，我们没有传递任何
- en: thing in the call to draw().
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 draw() 时，您可以处理绘制过程中的任何问题。
- en: '***Adding an Image***'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '***添加图像***'
- en: 'Our first example will be the simplest widget: we’ll use the Image class to
    dis-'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例将是最简单的小部件：我们将使用 Image 类显示
- en: play an image in a window. When you instantiate an Image object, the only
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中显示图像。当您实例化一个图像对象时，唯一需要提供的
- en: required arguments are the window, the location in the window to draw
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的参数是窗口，以及要在窗口中绘制的位置
- en: the image, and the path to the image file. Create the Image object before the
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图像及其文件路径。创建图像对象应在
- en: 'main loop starts, like so:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环开始时，如下所示：
- en: oImage = pygwidgets.Image(window, (100, 200), 'images/SomeImage.png')
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: oImage = pygwidgets.Image(window, (100, 200), 'images/SomeImage.png')
- en: The path used here assumes that the project folder containing the
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的路径假定项目文件夹中包含
- en: main program also contains a folder named *images*, inside which is the
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序还包含一个名为 *images* 的文件夹，其中包含
- en: '*SomeImage.png* file. Then, in the main loop you just need to call the object’s
    draw() method:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*SomeImage.png* 文件。然后，在主循环中，您只需调用该对象的 draw() 方法：'
- en: oImage.draw()
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: oImage.draw()
- en: The draw() method of the Image class contains a call to blit() to actu-
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Image 类的 draw() 方法包含一个调用 blit() 来实际
- en: ally draw the image, so you never need to call blit() directly. To move the
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绘制图像，因此您无需直接调用 blit()。要移动图像，
- en: image, you can call its setLoc() method (short for set location), specifying
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 图像时，您可以调用它的 setLoc() 方法（简写为设置位置），指定
- en: 'the new x- and y-coordinates as a tuple:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 作为元组传入新的 x 和 y 坐标：
- en: oImage.setLoc((newX, newY))
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: oImage.setLoc((newX, newY))
- en: The next time the image is drawn, it will show up at the new coordi-
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次绘制图像时，它将显示在新的坐标位置。
- en: nates. The documentation lists many additional methods that you can call
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标。文档列出了您可以调用的许多附加方法
- en: to flip, rotate, scale, get the image’s location and rectangle, and so on.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转、旋转、缩放，获取图像的位置和矩形，等等。
- en: '**THE SPRITE MODULE**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵模块**'
- en: Pygame has a built-in module to show images in a window, cal ed the *sprite*
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '*module* . Such images are cal ed *sprites* . The sprite module provides a
    Sprite class for handling individual sprites and a Group class for handling multiple'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Sprite objects . Together, these classes provide excel ent functionality, and
    if
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: you intend to do heavy-duty pygame programming, it is probably worth your
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: time to look into them . However, in order to explain the underlying OOP con-
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: cepts, I have chosen not to use those classes . Instead, I will proceed with
    gen-
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: eral GUI elements so that they can be used in any environment and language .
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the sprite module, see the tutorial a[t *ht
    ps://*](https://www.pygame.org/docs/tut/SpriteIntro.html)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[*www.pygame.org/docs/tut/SpriteIntro.html* .](https://www.pygame.org/docs/tut/SpriteIntro.html)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **151**
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Buttons, Checkboxes, and Radio Buttons***'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: When you instantiate a button, checkbox, or radio button widget in pygwidgets,
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'you have two options: instantiate a text version that draws its own art and'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: adds a text label based on a string you pass in, or instantiate a custom ver-
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: sion where you supply the art. Table 7-1 shows the different button classes
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: that are available.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Text and Custom Button Classes in pygwidgets'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '**Text version (builds art on**'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom version (uses**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '**the fly)**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '**your artwork)**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Button
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: TextButton
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: TextCheckBox
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: CustomCheckBox
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Radio button
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: TextRadioButton
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: CustomRadioButton
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: The differences between the text and custom versions of these classes
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: are only relevant during instantiation. Once you create an object from
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: a text or custom button class, all the remaining methods of the pair of
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: classes are identical. To make this clear, let’s take a look at the TextButton
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: and CustomButton classes.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '**TextButtons**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Here is the actual definition of the __init__() method of the TextButton class
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'in pygwidgets:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, window, loc, text,
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: width=None,
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: height=40,
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: textColor=PYGWIDGETS_BLACK,
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: upColor=PYGWIDGETS_NORMAL_GRAY,
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: overColor=PYGWIDGETS_OVER_GRAY,
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: downColor=PYGWIDGETS_DOWN_GRAY,
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: fontName=DEFAULT_FONT_NAME,
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=DEFAULT_FONT_SIZE,
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: soundOnClick=None,
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=False,
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: callback=None
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'nickname=None):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: However, rather than reading through the code of a class, a programmer
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: will typically refer to its documentation. As mentioned earlier, you can find
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: the complete documentation for pygwidgets at [*https://pygwidgets.readthedocs.io/*](https://pygwidgets.readthedocs.io/en/latest/)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[*en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: You can also view documentation of a class by calling the built-in help()
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'function in the Python shell like so:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(pygwidgets.TextButton)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '**152** Chapter 7'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 24](index-182_1.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
- en: '![Image 25](index-182_2.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
- en: When you create an instance of a TextButton, you are only required to pass
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: in the window, the location in the window, and the text to be shown on the
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: button. If you only specify these positional parameters, your button will use
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: button。如果你只指定这些位置参数，按钮将使用
- en: reasonable defaults for the width and height, the background colors for the
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的默认值包括宽度和高度、背景颜色等
- en: four states of the button (different shades of gray), the font, and the font
    size.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的四种状态（不同的灰色阴影）、字体和字体大小。
- en: By default, no sound effect will be played when the user clicks on the button.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当用户点击按钮时不会播放任何声音效果。
- en: 'The code to create a TextButton using all the defaults looks like this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个使用所有默认设置的 TextButton 的代码如下：
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = pygwidgets.TextButton(window, (50, 50), '文本按钮')
- en: The code in the __init__() method of the TextButton class uses the
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: TextButton 类的 __init__() 方法中的代码使用了
- en: pygame drawing methods to construct its own art for all four states (up,
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: pygame 绘图方法用于构建其所有四种状态的艺术图像（上、
- en: down, over, and disabled). The preceding line creates an “up” version of a
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 按下、悬停和禁用）。前一行创建了一个“up”版本的
- en: button that looks like Figure 7-2\.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像图 7-2 的按钮。
- en: '*Figure 7-2: A TextButton*'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：一个文本按钮*'
- en: '*using defaults*'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用默认值*'
- en: You can override any or all of the default parameters with keyword val-
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字值重写任何或所有默认参数。
- en: 'ues like so:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式如下：
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button',
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = pygwidgets.TextButton(window, (50, 50), '文本按钮',
- en: width=200,
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: width=200,
- en: height=30,
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: height=30,
- en: textColor=(255, 255, 128),
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=(255, 255, 128),
- en: upColor=(128, 0, 0),
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: upColor=(128, 0, 0),
- en: fontName='Courier',
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: fontName='Courier',
- en: fontSize=14,
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=14,
- en: soundOnClick='sounds/blip.wav',
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: soundOnClick='sounds/blip.wav',
- en: enterToActivate=True)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: enterToActivate=True)
- en: This instantiation will create a button that looks like Figure 7-3\.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例化将创建一个像图 7-3 所示的按钮\。
- en: '*Figure 7-3: A TextButton using keyword*'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：一个使用关键字的文本按钮*'
- en: '*arguments for font, size, colors, and so on*'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '*字体、大小、颜色等参数*'
- en: The image-switching behavior of these two buttons would work exactly
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个按钮的图像切换行为会完全相同
- en: the same way; the only differences would be in the appearance of the images.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方式；唯一的区别在于图像的外观。
- en: '**CustomButtons**'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义按钮**'
- en: The CustomButton class allows you to use your own art for a button. To instan-
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton 类允许你使用自己的艺术作品来制作按钮。要实例化一个
- en: tiate a CustomButton, you need only pass in a window, a location, and a path
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个 CustomButton，你只需要传入一个窗口、一个位置和一个路径
- en: 'to the image of the up state of the button. Here is an example:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 到按钮的 up 状态图像。这里是一个示例：
- en: restartButton = pygwidgets.CustomButton(window, (100, 430),
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: restartButton = pygwidgets.CustomButton(window, (100, 430),
- en: '''images/RestartButtonUp.png'')'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/RestartButtonUp.png'')'
- en: Pygame GUI Widgets **153**
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **153**
- en: The down, over, and disabled states are optional keyword arguments, and for
    any of these where no value is passed in, CustomButton will use a copy of
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的按下、悬停和禁用状态是可选的关键字参数，对于这些没有传值的状态，CustomButton 将使用
- en: the up image. It’s more typical (and strongly suggested) to pass in paths for
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: up 图像。更典型（且强烈建议）的是传入图像路径，
- en: 'the optional images, like so:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的图像，如下所示：
- en: restartButton = pygwidgets.CustomButton(window, (100, 430),
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: restartButton = pygwidgets.CustomButton(window, (100, 430),
- en: '''images/RestartButtonUp.png'','
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/RestartButtonUp.png'','
- en: down='images/RestartButtonDown.png',
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: down='images/RestartButtonDown.png',
- en: over='images/RestartButtonOver.png',
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: over='images/RestartButtonOver.png',
- en: disabled='images/RestartButtonDisabled.png',
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: disabled='images/RestartButtonDisabled.png',
- en: soundOnClick='sounds/blip.wav',
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: soundOnClick='sounds/blip.wav',
- en: nickname='restart')
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: nickname='restart')
- en: Here we also specified a sound effect that should be played when
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们还指定了一个声音效果，应该在
- en: the user clicks the button, and we provided an internal nickname we can
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击按钮时播放该声音效果，并提供一个内部的昵称供我们
- en: use later.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后使用。
- en: '**Using Buttons**'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用按钮**'
- en: After instantiation, here’s some typical code to use a button object, oButton,
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化后，这里是一些典型的代码来使用按钮对象 oButton，
- en: 'independent of it being a TextButton or a CustomButton:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 TextButton 还是 CustomButton，都是独立的：
- en: 'while True:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oButton.handleEvent(event):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 'if oButton.handleEvent(event):'
- en: User has clicked this button
  id: totrans-706
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户点击了这个按钮
- en: '*<Any code you want to run here when the button is clicked>*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*<你想在按钮点击时运行的任何代码>*'
- en: '--- snip ---'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截断 ---'
- en: 'oButton.draw() # at the bottom of the while loop, tell it to draw'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 'oButton.draw() # 在 while 循环的底部，告诉它绘制'
- en: Every time we detect an event, we need to call the handleEvent() method
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们检测到一个事件时，都需要调用 handleEvent() 方法
- en: of the button to allow it to react to the user’s actions. This call normally
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 允许按钮根据用户的操作作出反应。这个调用通常
- en: returns False but will return True when the user completes a click on the
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False，但当用户完成点击时返回 True
- en: button. At the bottom of the main while loop, we need to call the draw()
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮。在主循环的底部，我们需要调用 draw()
- en: method of the button to allow it to draw itself.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的 method 方法允许它绘制自己。
- en: '***Text Output and Input***'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '***文本输出和输入***'
- en: As we saw in [Chapter 6, h](index_split_002.html#p150)andling text input and
    output in pygame is tricky, but here I’ll introduce new classes for a text display
    field and an input text
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第六章，h](index_split_002.html#p150)中所见，处理文本输入和输出在 pygame 中是棘手的，但在这里我将介绍用于文本显示字段和输入文本的新类
- en: field. Both of these classes have minimal required (positional) parameters,
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 字段。这两个类都有最小的必需（位置）参数，
- en: and they have reasonable defaults for other attributes (font, font size,
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 它们对其他属性（如字体、字体大小、颜色等）有合理的默认值，
- en: color, and so on) that are easily overridden.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色等）这些都可以轻松覆盖。
- en: '**Text Output**'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本输出**'
- en: The pygwidgets package contains a DisplayText class for showing text that is
    a
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包含一个 DisplayText 类，用于显示文本，这是一个
- en: more full-featured version of the SimpleText class fro[m Chapter 6](index_split_002.html#p150).
    When you **154** Chapter 7
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 更完整版本的 SimpleText 类来自[第六章](index_split_002.html#p150)。当你**154** 第七章
- en: instantiate a DisplayText field, the only required arguments are the window
    and the location. The first keyword parameter is value, which may be specified
    with a string as starting text to be shown in the field. This is typically
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个 DisplayText 字段时，唯一必需的参数是窗口和位置。第一个关键字参数是 value，它可以通过字符串指定作为显示在字段中的起始文本。这通常是
- en: used for a default end user value or for text that never changes, like a label
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 用于默认的最终用户值或从不改变的文本，如标签
- en: or instructions. Since value is the first keyword parameter, it can be given
    as
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 或说明。由于 value 是第一个关键字参数，它可以作为
- en: 'either a positional or a keyword argument. For example, this:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是位置参数还是关键字参数。例如，这个：
- en: oTextField = pygwidgets.DisplayText(window, (10, 400), 'Hello World')
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField = pygwidgets.DisplayText(window, (10, 400), 'Hello World')
- en: 'will work the same way as this:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 将与此相同地工作：
- en: oTextField = pygwidgets.DisplayText(window, (10, 400), value='Hello World')
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField = pygwidgets.DisplayText(window, (10, 400), value='Hello World')
- en: You can also customize the look of the output text by specifying any or
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过指定任意或
- en: 'all of the optional keyword parameters. For example:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可选的关键字参数。例如：
- en: oTextField = pygwidgets.DisplayText(window, (10, 400),
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField = pygwidgets.DisplayText(window, (10, 400)，
- en: value='Some title text',
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: value='一些标题文本'，
- en: fontName='Courier',
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: fontName='Courier'，
- en: fontSize=40,
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=40，
- en: width=150,
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: width=150，
- en: justified='center',
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: justified='center'，
- en: textColor=(255, 255, 0))
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=(255, 255, 0))
- en: The DisplayText class has a number of additional methods, the most
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: DisplayText 类有许多额外的方法，其中最
- en: important of which is setValue(), which you call to change the text drawn
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是 setValue()，你可以调用它来更改绘制的文本
- en: 'in the field:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段中：
- en: oTextField.setValue('Any new text you want to see')
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField.setValue('任何你想看到的新文本')
- en: At the bottom of the main while loop, you need to call the object’s
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的底部，你需要调用对象的
- en: 'draw() method:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法：
- en: oTextField.draw()
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField.draw()
- en: And of course, you can create as many DisplayText objects as you wish,
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以根据需要创建多个 DisplayText 对象，
- en: each displaying different text and each with its own font, size, color, and
    so on.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 每个显示不同的文本，并且每个都有自己的字体、大小、颜色等。
- en: '**Text Input**'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本输入**'
- en: In a typical text-based Python program, to get input from the user you
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于文本的 Python 程序中，要获取用户输入，你
- en: would make a call to the input() function, which stops the program until
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 会调用 input() 函数，程序会暂停，直到
- en: the user enters text in the shell window. But in the world of event-driven
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在终端窗口中输入文本。但在事件驱动的世界里，
- en: GUI programs, the main loop never stops. Therefore, we must use a differ-
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 程序中的主循环永远不会停止。因此，我们必须使用不同的
- en: ent approach.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的方法。
- en: For text input from the user, a GUI program typically presents a field
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自用户的文本输入，GUI 程序通常会呈现一个字段
- en: that the user can type in. An input field must deal with all keyboard keys,
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在其中输入的内容。输入字段必须处理所有键盘按键，
- en: some of which show while others are used for editing or cursor movement
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些显示，其他用于编辑或光标移动
- en: within the field. It must also allow for the user holding down a key to repeat
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 字段中的值。它还必须允许用户按住键来重复
- en: it. The pygwidgets InputText class provides all this functionality.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 它。pygwidgets 的 InputText 类提供了所有这些功能。
- en: Pygame GUI Widgets **155**
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **155**
- en: 'The only required arguments to instantiate an InputText object are the window
    and a location:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 InputText 对象所需的唯一参数是窗口和位置：
- en: oInputField = pygwidgets.InputText(window, (10, 100))
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: oInputField = pygwidgets.InputText(window, (10, 100))
- en: However, you can customize the text attributes of an InputText object by
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过以下方式自定义 InputText 对象的文本属性
- en: 'specifying optional keyword arguments:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 指定可选的关键字参数：
- en: oInputField = pygwidgets.InputText(window, (10, 400),
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: oInputField = pygwidgets.InputText(window, (10, 400)，
- en: value='Starting Text',
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: value='Starting Text'，
- en: fontName='Helvetica',
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: fontName='Helvetica'，
- en: fontSize=40,
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=40，
- en: width=150,
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: width=150，
- en: textColor=(255, 255, 0))
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=(255, 255, 0))
- en: After instantiating an InputText field, the typical code in the main loop
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 InputText 字段后，主循环中的典型代码是
- en: 'would look like this:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 会像这样：
- en: 'while True:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oInputField.handleEvent(event):'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oInputField.handleEvent(event):'
- en: User has pressed Enter or Return
  id: totrans-778
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户按下了 Enter 或 Return 键
- en: 'userText = oInputField.getValue() # get the text the user entered'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 'userText = oInputField.getValue()  # 获取用户输入的文本'
- en: '*<Any code you want to run using the user''s input>*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '*<你想要通过用户输入运行的任何代码>*'
- en: '--- snip ---'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪辑 ---'
- en: 'oInputField.draw() # at the bottom of the main while loop'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 'oInputField.draw()  # 在主 while 循环的底部'
- en: For every event, we need to call the handleEvent() method of the InputText
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个事件，我们需要调用 InputText 的 handleEvent() 方法
- en: field to allow it to react to keystrokes and mouse clicks. This call normally
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 字段以响应按键和鼠标点击。这通常通过以下方式调用
- en: returns False, but when the user presses ENTER or RETURN, it returns True.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False，但当用户按下 ENTER 或 RETURN 键时，它返回 True。
- en: We can then retrieve the text that the user entered by calling the getValue()
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用 getValue() 方法来获取用户输入的文本
- en: method of the object.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的方法。
- en: At the bottom of the main while loop, we need to call the draw() method
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 while 循环的底部，我们需要调用 draw() 方法
- en: to allow the field to draw itself.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 以允许字段自行绘制。
- en: If a window contains multiple input fields, key presses are handled by
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个窗口包含多个输入字段，键盘按键会由
- en: the field with current keyboard focus, which is changed when a user clicks
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 当前有键盘焦点的字段，当用户点击时会发生变化
- en: in a different field. If you want to allow a field to have initial keyboard
    focus,
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的领域中。如果你希望一个字段拥有初始的键盘焦点，
- en: then you can set the initialFocus keyword parameter to True in the InputText
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以将 initialFocus 关键字参数设置为 True，在 InputText
- en: object of your choice when you create that object. Further, if you have mul-
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建该对象时，选择你想要的对象。此外，如果你有多个
- en: tiple InputText fields in a window, a typical user interface design approach
    is
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个窗口中有多个 InputText 字段时，典型的用户界面设计方法是
- en: to include an OK or Submit button. When this button is clicked, you could
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 以包括一个 OK 或 Submit 按钮。当点击这个按钮时，你可以
- en: then call the getValue() method of each field.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用每个字段的 getValue() 方法。
- en: '**156** Chapter 7'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**156** 第七章'
- en: '**N O T E**'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*At the time of writing, the InputText class does not handle highlighting multiple*
    *characters by dragging the mouse. If this functionality is added in a later version,*
    *no change will be required to programs that use InputText because the code will
    be* *entirely within that class. Any new behavior will be supported automatically
    in all* *InputText objects.*'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*在撰写本文时，InputText 类不支持通过拖动鼠标高亮显示多个字符。如果以后版本添加了这个功能，* *那么使用 InputText 的程序将无需做任何更改，因为代码完全会包含在该类中。任何新的行为将自动支持所有*
    *InputText 对象。*'
- en: '***Other pygwidgets Classes***'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '***其他 pygwidgets 类***'
- en: As you saw at the beginning of this section, pygwidgets contains a number of
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节开始时看到的，pygwidgets 包含了多个
- en: other classes.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类。
- en: The ImageCollection class allows you to show any single image from a
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: ImageCollection 类允许你从一组图像中显示任何单个图像。
- en: collection of images. For example, suppose you have images of a character
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 一组图像。例如，假设你有一个角色的图像
- en: facing front, left, back, and right. To represent all the potential images,
    you
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 面朝前方、左侧、后方和右侧。为了表示所有可能的图像，你
- en: 'can build a dictionary like this:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以构建一个像这样的字典：
- en: imageDict = {'front':'images/front.png', 'left':'images/left.png',
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: imageDict = {'front':'images/front.png', 'left':'images/left.png'，
- en: '''back'':''images/back.png'', ''right'':''images/right.png''}'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '''back'':''images/back.png'', ''right'':''images/right.png''}'
- en: You can then create an ImageCollection object, specifying this dictionary
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个 ImageCollection 对象，指定这个字典
- en: and the key of the image you want to start with. To change to a different
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 以及你想要开始使用的图像的键。要更改为不同的图像
- en: image, you call the replace() method and pass in a different key. Calling the
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 图片时，你调用 replace() 方法并传入一个不同的键。调用该方法
- en: draw() method at the bottom of the loop always shows the current image.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: The Dragger class displays a single image but allows the user to drag the
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: image anywhere in the window. You must call its handleEvent() method in
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: the event loop. When the user finishes dragging, handleEvent() returns True,
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: and you can call the Dragger object’s getMouseUpLoc() method to get the loca-
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: tion where the user released the mouse button.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: The Animation and SpriteSheetAnimation classes handle building and
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: showing an animation. Both require a set of images to iterate through.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: The Animation class gets the images from individual files, while the
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation class requires a single image with evenly spaced internal
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: images. We’ll explore these classes more fully i[n Chapter 14\.](index_split_005.html#p324)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '***pygwidgets Example Program***'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7-4 shows a screenshot of a sample program that demonstrates
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: objects instantiated from many of the classes in pygwidgets, including Image,
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: DisplayText, InputText, TextButton, CustomButton, TextRadioButton, CustomRadioButton,
    TextCheckBox, CustomCheckBox, ImageCollection, and Dragger.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: The source of this example program can be found in the *pygwidgets_test*
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: folder in my GitHub repository, [*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: Pygame GUI Widgets **157**
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 26](index-187_1.png)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: The window of a program that demonstrates objects instantiated*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '*from a variety of pygwidgets classes*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '**The Importance of a Consistent API**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note about building an API for a set of classes: whenever possible,'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: it’s a very good idea to build consistency into the parameters of methods in
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: different, but similar, classes. As a good example, the first two parameters
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: to the __init__() method of every class in pygwidgets are window and loc, in
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: that order. If these had been in a different order in some calls, using the
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: package as a whole would be much more difficult.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if different classes implement the same functionality, it’s a
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: good idea to use the same method names. For example, many of the classes
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: in pygwidgets have a method named setValue() and another named getValue().
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: I’ll talk more about why this type of consistency is so important in the next
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: two chapters.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided an introduction to the object-oriented pygwidgets
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: package of graphical user interface widgets. We began by discussing default
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: values for parameters in methods, and I explained that a keyword param-
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: eter allows for a default value to be used if no matching argument value is
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: specified in a call.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '**158** Chapter 7'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: I then introduced you to the pygwidgets module, which contains a number of prebuilt
    GUI widget classes, and showed you how to use several of
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: these. Finally, I showed a sample program that provides examples of most of
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: these widgets.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: There are two key advantages to writing classes like those in pygwidgets.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: First, classes can hide complexity in methods. Once you have your class
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: working correctly, you never have to worry about the internal details again.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 正常工作时，你再也不需要担心内部细节了。
- en: Second, you can reuse the code by creating as many instances of a class as
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你可以通过创建多个类实例来复用代码
- en: you need. Your classes can provide basic functionality by including keyword
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的。通过包括关键字，你的类可以提供基本功能
- en: parameters with well-chosen default values. However, the default values can
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，使用精心挑选的默认值。然而，默认值可以
- en: easily be overwritten to allow for customization.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松地被覆盖，以允许定制化。
- en: You can publish the interfaces of your classes for other programmers
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以公开类的接口，供其他程序员使用
- en: (and yourself) to take advantage of in different projects. Good documen-
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: （以及你自己）可以在不同的项目中利用。良好的文档
- en: tation and consistency go a long way toward making these types of classes
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化和一致性对于使这些类型的类
- en: highly usable.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 高度可用。
- en: Pygame GUI Widgets **159**
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **159**
- en: '**PART III**'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三部分**'
- en: '**E N C A P S U L A T I O N ,**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**'
- en: '**P O LY M O R P H I S M , A N D**'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态性，和**'
- en: '**I N H E R I T A N C E**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**'
- en: The three main tenets of object-oriented program-
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的三大原则
- en: ming are encapsulation, polymorphism, and inheri-
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的封装、多态和继承是
- en: tance. The next three chapters will explain each of
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 实例。接下来的三章将解释每一个
- en: these in turn, describing the underlying concepts and
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反过来描述了底层的概念和
- en: showing examples of how they are implemented in
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了它们如何在
- en: Python. In order for a programming language to call
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Python。为了使编程语言能够调用
- en: itself an OOP language, it must support all three of
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 本身就是一门面向对象编程语言，它必须支持所有这三者
- en: these central requirements. (If you’re ever asked in an
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心要求。（如果你在面试中被问到
- en: interview about the requirements for a language to be
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 面试中要求语言的条件
- en: 'object-oriented, here’s an easy way to remember them:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的，这里有一个简单的记忆方法：
- en: it’s as easy as PIE!)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像 PIE 一样简单！）
- en: '[Chapter 8 e](#p192)xplains encapsulation: hiding the details and keeping everything
    in one place.'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章 e](#p192)解释了封装：隐藏细节并将所有内容保持在一个地方。'
- en: '[Chapter 9 d](#p212)iscusses polymorphism: how multiple classes can have methods
    with the same names.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章 d](#p212)讨论了多态：多个类可以拥有相同名称的方法。'
- en: '[Chapter 10 c](index_split_004.html#p240)overs inheritance: building on code
    that already exists.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章 c](index_split_004.html#p240)介绍了继承：在已有代码的基础上构建。'
- en: Finally[, Chapter 11 g](index_split_004.html#p270)oes into detail on a number
    of topics (mostly dealing with memory management) that do not logically fit into
    the previous
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[第11章 g](index_split_004.html#p270)详细讨论了若干主题（大多数涉及内存管理），这些内容在逻辑上不适合前面
- en: three chapters but are useful and important to OOP.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 这三章虽然重要，但也有用且对面向对象编程非常重要。
- en: '**8**'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**E N C A P S U L A T I O N**'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**'
- en: The first of the three main tenets of object-
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的三大原则之一
- en: oriented programming is *encapsulation*. This
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个重要概念是*封装*。这个
- en: word might conjure up an image of a space
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 这个词可能会让人想起太空
- en: capsule, a cell wall, or a medicine gelcap, where
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 胶囊，一个细胞壁，或一个药用胶囊，其中
- en: the precious cargo inside is protected from the outside
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的宝贵货物受到外部的保护
- en: environment. In programming, encapsulation has a
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 环境。在编程中，封装具有
- en: 'similar but even more detailed meaning: hiding inter-'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 相似但更详细的含义：隐藏
- en: nal details of state and behavior from any external
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 内部状态和行为的细节不受任何外部
- en: code and having all code in one place.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并且将所有代码放在一个地方。
- en: In this chapter, we’ll see how encapsulation works with functions, then
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到封装如何与函数配合使用，然后
- en: with methods of objects. I’ll discuss different interpretations of encapsu-
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象的方法。我要讨论封装的不同解释
- en: 'lation: using direct access versus using getters and setters. I’ll show how'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 封装：使用直接访问与使用 getter 和 setter。我将展示如何
- en: Python allows you to mark an instance variable as private, indicating that
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你将实例变量标记为私有，表示
- en: it should not be accessed by code external to a class, and I’ll touch on the
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 它不应该被类外的代码访问，我会触及到
- en: Python property decorator. Finally, I’ll discuss the concept of abstraction
    in
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: Python属性装饰器。最后，我将讨论抽象的概念
- en: the design of classes.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计。
- en: '**Encapsulation with Functions**'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装与函数**'
- en: Functions are a prime example of encapsulation because when you call a
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是封装的一个典型例子，因为当你调用一个
- en: function, you generally don’t care *how* the function works internally. A well-written
    function contains a series of steps that make up a larger single task,
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 函数时，你通常不关心*函数*如何在内部工作。一个写得很好的函数包含了一系列步骤，构成了一个更大的单一任务，
- en: which you do care about. The name of the function should describe the
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 你关心的是哪些内容。函数的名称应该描述
- en: action that its code embodies. Consider the built-in len() function from the
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 它的代码体现的动作。考虑内置的 len() 函数
- en: Python Standard Library, used to find the number of characters in a string
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库，用于查找字符串中的字符数
- en: or elements in a list. You pass in a string or list, and it returns the count.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 或列表中的元素。你传入一个字符串或列表，它会返回计数。
- en: When you write code that calls this function, you don’t care how len() does
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写调用这个函数的代码时，你不需要关心 len() 是如何
- en: what it does. You don’t stop to think about whether the code of the function
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 它的代码做什么。你不会停下来考虑函数代码
- en: contains two lines or two thousand lines, whether it uses one local variable
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 包含两行代码或两千行代码，无论它使用一个局部变量
- en: or a hundred. You just need to know what argument to pass in and how to
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 或一百个。你只需要知道传入什么参数并如何
- en: use the result that’s returned.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回的结果。
- en: The same is true of functions that you write, like this function that cal-
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的函数也同样如此，比如这个计算列表平均值的函数：
- en: 'culates and returns the average of a list of numbers:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 计算并返回一组数字的平均值：
- en: 'def calculateAverage(numbersList):'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculateAverage(numbersList):'
- en: total = 0.0
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0.0
- en: 'for number in numbersList:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 'for number in numbersList:'
- en: total = total + number
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + number
- en: nElements = len(numbersList)
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: nElements = len(numbersList)
- en: average = total / nElements
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: average = total / nElements
- en: return average
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: return average
- en: Once you’ve tested a function like this and found that it works, you
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试过这样的函数并确认它有效，你
- en: no longer have to worry about the details of the implementation. You
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要担心实现的细节。你
- en: only need to know what argument(s) to send into the function and what it
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要知道向函数传入什么参数，以及它
- en: returns.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值。
- en: However, if one day you find that there is a much simpler or faster algo-
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有一天你发现有一个更简单或更快速的算法，
- en: rithm to calculate an average, you could rewrite the function in a new way.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 算法计算平均值，你可以用新的方式重写函数。
- en: As long as the interface (the inputs and outputs) does not change, there is
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 只要接口（输入和输出）没有改变，就没有问题。
- en: no need to change any calls to the function. This type of modularization
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要改变任何对该函数的调用。这种模块化
- en: makes the code more maintainable.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码更具可维护性。
- en: '**Encapsulation with Objects**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象的封装**'
- en: Unlike variables used in regular functions, instance variables in objects per-
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数中使用的变量不同，对象中的实例变量每次
- en: sist across different method calls. To keep the remaining discussion clear,
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的方法调用之间保持一致。为了保持接下来的讨论清晰，
- en: 'I’ll introduce a new term: *client*. (I don’t want to use the term *user* here
    since that typically refers to the human user of the final program.)'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 我来介绍一个新术语：*客户端*。（我不想在这里使用*用户*这个术语，因为它通常指的是最终程序的人类用户。）
- en: '**client**'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: Any software that creates an object from a class and makes calls to the methods
    of
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从类中创建对象并调用其方法的软件，
- en: that object .
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 那个对象。
- en: We must also consider the duality of *inside* versus *outside* an object or
    class. When you’re working inside a class (writing the code of the methods
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑对象或类的*内部*与*外部*的二元性。当你在类内部工作时（编写方法的代码
- en: in a class), you need to concern yourself with how the different methods of
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中），你需要关心不同方法的
- en: '**164** Chapter 8'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '**164** 第8章'
- en: 'the class share the instance variables. You consider the efficiency of your
    algorithms. You think about what the interface should look like: what methods
    you should provide, what the parameters for each are, and what should'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 类共享实例变量。你考虑算法的效率。你思考接口应该是什么样子：应该提供哪些方法，每个方法的参数是什么，应该
- en: be used as default values. In short, you are concerned with the design and
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用作默认值。简而言之，你关心的是设计和
- en: implementation of the methods.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实现。
- en: From the outside, as a client programmer, you need to know the inter-
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部，作为客户端程序员，你需要了解接口
- en: face of the class. You’re concerned with what the class methods do, what
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 类的接口面。你关心的是类方法做什么，
- en: arguments should be passed in, and what data is passed back from each
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 参数应该传递什么数据，以及每个方法从类中返回什么数据
- en: method.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。
- en: 'A class therefore provides encapsulation by:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类通过以下方式提供封装：
- en: • Hiding all details of implementation in its methods and instance
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: • 隐藏其方法和实例中的所有实现细节
- en: variables
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: • Providing all the functionality a client needs from an object through its
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过其
- en: interface (the methods defined in the class)
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 接口（类中定义的方法）
- en: '***Objects Own Their Data***'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '***对象拥有自己的数据***'
- en: In object-oriented programming, we say that the data inside an object is
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们说数据存在于对象内部，属于
- en: '*owned* by the object. OOP programmers generally agree that, as a good'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '*由对象* 拥有。面向对象编程（OOP）程序员通常同意，作为好的'
- en: design principle, client code should only be concerned with the interface
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则是，客户端代码只应该关注接口
- en: of a class and should not care about the implementation of the methods.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只关心类的接口，而不必关心方法的实现。
- en: Consider the example of a simple Person class in Listing 8-1\.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下列表 8-1 中简单的 Person 类示例。
- en: 'class Person():'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Person():'
- en: 'def __init__(self, name, salary):'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, salary):'
- en: self.name = name
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.salary = salary
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: self.salary = salary
- en: '*Listing 8-1: Data ownership in the Person class*'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：Person 类中的数据所有权*'
- en: The values of the instance variables self.name and self.salary are set
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量 self.name 和 self.salary 的值已经设置
- en: 'whenever we instantiate new Person objects, like this:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们实例化新的 Person 对象时，像这样：
- en: oPerson1 = Person('Joe Schmoe', 90000)
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson1 = Person('Joe Schmoe', 90000)
- en: oPerson2 = Person('Jane Smith', 99000)
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2 = Person('Jane Smith', 99000)
- en: Each Person object owns its own set of the two instance variables.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Person 对象拥有自己的一组实例变量。
- en: '**Interpretations of Encapsulation**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装的解释**'
- en: Here is where things get a little controversial. Different programmers
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个有争议的地方。不同的程序员
- en: have different views about the accessibility of an instance variable. Python
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例变量的访问权限，Python 程序员
- en: provides for a loose interpretation of encapsulation by allowing direct
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许直接访问，提供了封装的宽松解释
- en: access to instance variables using simple dot syntax. Client code can
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的点语法访问实例变量。客户端代码可以
- en: legally access an instance variable of an object by name using the syntax
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法合法地访问对象的实例变量
- en: '*<object>* . *<instanceVariableName>* .'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '*<object>* . *<instanceVariableName>* .'
- en: Encapsulation **165**
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **165**
- en: However, a *strict* interpretation of encapsulation says that client software
    should never be able to retrieve or change the value of an instance variable
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，封装的*严格*解释认为，客户端软件永远不应该能够检索或更改实例变量的值
- en: directly. Instead, the only way that a client can retrieve or change a value
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问。相反，客户端访问或更改值的唯一方法是
- en: held in an object is to use a method provided by the class for this purpose.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在对象中的数据可以通过类提供的方法进行访问。
- en: Let’s look at both approaches.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这两种方法。
- en: '***Direct Access and Why You Should Avoid It***'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '***直接访问及为何应该避免它***'
- en: As mentioned, Python does allow direct access to instance variables. Listing
    8-2
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 确实允许直接访问实例变量。列表 8-2
- en: instantiates the same two objects from the Person class in Listing 8-1 as in
    the
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化了与列表 8-1 中相同的两个 Person 类对象
- en: previous section, but then accesses their self.salary instance variables directly.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中提到，接着直接访问它们的 self.salary 实例变量。
- en: '**File: PersonGettersSettersAndDirectAccess/Main_PersonDirectAccess.py**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PersonGettersSettersAndDirectAccess/Main_PersonDirectAccess.py**'
- en: Person example main program using direct access
  id: totrans-991
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Person 示例主程序使用直接访问
- en: from Person import *
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: from Person import *
- en: oPerson1 = Person('Joe Schmoe', 90000)
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson1 = Person('Joe Schmoe', 90000)
- en: oPerson2 = Person('Jane Smith', 99000)
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2 = Person('Jane Smith', 99000)
- en: Get the values of the salary variable directly
  id: totrans-995
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接获取薪资变量的值
- en: 1 print(oPerson1.salary)
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 1 print(oPerson1.salary)
- en: print(oPerson2.salary)
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson2.salary)
- en: Change the salary variable directly
  id: totrans-998
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接更改薪资变量
- en: 2 oPerson1.salary = 100000
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oPerson1.salary = 100000
- en: oPerson2.salary = 111111
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2.salary = 111111
- en: Get the updated salaries and print again
  id: totrans-1001
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取更新后的薪资并再次打印
- en: print(oPerson1.salary)
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson1.salary)
- en: print(oPerson2.salary)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson2.salary)
- en: '*Listing 8-2: Example main code using direct access to an instance variable*'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：使用直接访问实例变量的示例主代码*'
- en: Python allows you to write code like this that reaches into an object to
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你编写这样的代码，直接访问对象中的数据
- en: directly get 1 and set 2 any instance variable using standard dot syntax.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 直接获取 1 和设置 2 任何实例变量，使用标准的点语法。
- en: Most Python programmers feel that this technique is perfectly acceptable.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 程序员认为这种技术完全可以接受。
- en: In fact, Guido van Rossum (the creator of Python) famously said in refer-
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Python 的创造者 Guido van Rossum 曾在提到
- en: ence to this issue, “We are all adults here,” meaning that programmers
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题的回应是，“我们都是成年人”，意思是程序员
- en: should know what they are doing, and the risks involved, when they attempt
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员尝试访问实例变量时，应该知道他们在做什么，并意识到其中的风险。
- en: to access instance variables directly.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问实例变量。
- en: However, I strongly believe that directly accessing an instance variable
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我坚信直接访问实例变量
- en: of an object is an extremely dangerous practice, as it breaks the core idea
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: of encapsulation. To illustrate why this is the case, let’s take a look at a
    few
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: example scenarios where direct access can be problematic.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the Name of an Instance Variable**'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: The first problem with direct access is that changing the name of an
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: instance variable will break any client code that uses the original name
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '**166** Chapter 8'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: directly. This can happen when the developer of a class decides that the initial
    choice of the name of the variable was not optimal, for reasons such as
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: 'the following:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: • The name doesn’t describe the data it represents clearly enough.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: • The variable is a Boolean, and they want to swap what True and False
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: represent by renaming the variable (for example, closed to open, allowed
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: to disallowed, active to disabled).
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: • There was a spelling or capitalization mistake in the original name.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: • The variable was originally a Boolean, but they later realize that they
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: need to represent more than two values.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: In any of these cases, if the developer changes the name of an instance
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: variable in the class from self. *<originalName>* to self. *<newName>* , then
    any client software that uses the original name directly will break.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing an Instance Variable into a Calculation**'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: A second situation where direct access is problematic is when the code of
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: a class needs to change to meet new requirements. Suppose that when
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: writing a class, you use an instance variable to represent a piece of data,
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: but the functionality changes so that you need an algorithm to compute a
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: value instead. Take our Account class fro[m Chapter 4, f](index_split_001.html#p86)or
    example. To make our bank accounts more realistic, we might want to add an interest
    rate.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: You might think this is a simple matter of adding an instance variable for
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: the interest rate named self.interestRate. Then, using the direct access
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'approach, client software could access this value of an Account object using:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: oAccount.interestRate
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: This would work, for a while. But later the bank might decide on a new
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: policy—say that the interest rate will depend on the amount of money in
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: 'the account. The interest rate might be calculated like this:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculateInterestRate(self):'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: Assuming self.balance has been set in another method
  id: totrans-1045
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.balance < 1000:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: self.interestRate = 1.0
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.balance < 5000:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: self.interestRate = 1.5
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: self.interestRate = 2.0
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just relying on a single interest rate value in self.interestRate,
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: the calculateInterestRate() method determines the current rate based on the
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: account balance.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: Any client software that directly accesses oAccount.interestRate and
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: uses the value of the instance variable might then get an outdated value,
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: depending on the last time calculateInterestRate() was called. And any
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **167**
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: client software that *sets* a new interestRate may find that the new value is
    mysteriously changed by some other code that calls calculateInterestRate()
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: or when the bank account owner makes a deposit or withdrawal.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the interest calculation method was named getInterestRate()
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: and client software called that instead, the interest rate would always be cal-
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: culated on the fly and there would be no potential error.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating Data**'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: The third reason to avoid direct access when setting a value is that client
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: code can too easily set an instance variable to an invalid value. A better
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: approach is to call a method in the class, whose job is to set the value. As
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: the developer, you can include validation code in that method to ensure
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: that the value being set is appropriate. Consider the code in Listing 8-3,
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: whose purpose is to manage the members of a club.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '**File: ValidatingData_ClubExample/Club.py**'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: Club class
  id: totrans-1072
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Club():'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, clubName, maxMembers):'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: self.clubName = clubName 1
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: self.maxMembers = maxMembers
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: self.membersList = []
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: 'def addMember(self, name): 2'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that there is enough room left
  id: totrans-1079
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if len(self.membersList) < self.maxMembers:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: self.membersList.append(name)
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: print('OK.', name, 'has been added to the', self.clubName, 'club')
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: print('Sorry, but we cannot add', name, 'to the', self.clubName, 'club.')
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: print('This club already has the maximum of', self.maxMembers, 'members.')
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: 'def report(self): 3'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: print('Here are the', len(self.membersList), 'members of the', self.clubName,
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '''club:'')'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'for name in self.membersList:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: print(' ' + name)
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-3: An example of a Club class*'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: The Club code keeps track of the name of the club, the maximum num-
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: ber of members, and the list of members, all in instance variables 1\. Once
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: instantiated, you can call methods to add a member to the club 2 and to
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: report the members of the club 3\. (We could easily add more methods to
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '**168** Chapter 8'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: remove members, change names, and so on, but these two are good enough the make
    the point.)
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: Here is some test code that uses the Club class.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '**File: ValidatingData_ClubExample/Main_Club.py**'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: Club example main program
  id: totrans-1102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Club import *
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: Create a club with at most 5 members
  id: totrans-1104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oProgrammingClub = Club('Programming', 5)
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Joe Schmoe')
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Cindy Lou Hoo')
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Dino Richmond')
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Susie Sweetness')
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Fred Farkle')
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.report()
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: We create a Programming club that allows a maximum of five members
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: and then we add five members. The code runs well and reports the mem-
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: 'bers added to the club:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: OK. Joe Schmoe has been added to the Programming club
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: OK. Cindy Lou Hoo has been added to the Programming club
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: OK. Dino Richmond has been added to the Programming club
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: OK. Susie Sweetness has been added to the Programming club
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: OK. Fred Farkle has been added to the Programming club
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try to add a sixth member:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to add additional member
  id: totrans-1121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oProgrammingClub.addMember('Iwanna Join')
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: This attempt to add a member is rejected, and we see an appropriate
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: 'error message:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Sorry, but we cannot add Iwanna Join to the Programming club.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: This club already has the maximum of 5 members.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: The code of addMember() does all the validation needed to ensure that
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: a call to add a new member works correctly or generates an error message.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: However, with direct access, a client could change the fundamental nature
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: of the Club class. For example, a client could maliciously or accidentally
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: 'change the maximum number of members:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.maxMembers = 300
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: Further, suppose you know that the Club class represents the members
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: as a list, and you know the name of the instance variable that represents the
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **169**
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'members. In that case you can write client code to add to the list of members
    directly, without making the method call, like so:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: oProgrammingClub.memberList.append('Iwanna Join')
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: This line would push the membership over the intended limit because
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: it avoids the code that ensures that the request to add the member is valid.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: Client code using direct access could even cause an error inside the
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: Club object. For example, the instance variable self.maxMembers is intended
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: to be an integer. Using direct access, client code could change its value to
    a
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: string. Any subsequent call to addMember() would crash at the first line of
    that
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: method, where it attempts to compare the length of the list of members
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: against the maximum number of members, because Python cannot com-
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: pare an integer to a string.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Allowing direct access to instance variables from outside an object can
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: be dangerous, bypassing safeguards that were designed to protect the data
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: of an object.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '***Strict Interpretation with Getters and Setters***'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: The strict approach to encapsulation says that client code *never* accesses
    an instance variable directly. If a class wants to allow client software to access
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: the information held inside an object, the standard approach is to include a
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: '*getter* and a *setter* method in the class.'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '**getter**'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: A method that retrieves data from an object instantiated from a class .
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '**setter**'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: A method that assigns data into an object instantiated from a class .
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: Getter and setter methods are designed to allow writers of client soft-
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: ware to get data from and set data in an object, without needing explicit
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: knowledge of the implementation of a class—specifically, without having
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: to know or use the name of any instance variable. The Person class code
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: in Listing 8-1 has an instance variable self.salary. In Listing 8-4 we add a
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: getter and a setter to the Person class to allow the caller to get and set the
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: salary, without providing direct access to the Person’s self.salary instance
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: variable.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PersonGettersSettersAndDirectAccess/Person.py**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: 'class Person():'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, salary):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: self.salary = salary
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: Allow the caller to retrieve the salary
  id: totrans-1171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1 def getSalary(self):'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '**170** Chapter 8'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: return self.salary
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: Allow the caller to set a new salary
  id: totrans-1175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 def setSalary(self, salary):'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: self.salary = salary
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-4: An example of a Person class with a get er and a set er*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: The get 1 and set 2 portions of these method names are not required
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: but are used by convention. You generally follow these words with a descrip-
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: tion of the data being accessed, in this case Salary. While it is typical to
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: use the name of the instance variable being accessed, this is also not a
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: requirement.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-5 shows some test code that instantiates two Person objects,
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: then gets and sets their salaries using these getter and setter methods.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PersonGettersSettersAndDirectAccess/Main_PersonGetterSetter.py**'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: Person example main program using getters and setters
  id: totrans-1187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Person import *
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: 1 oPerson1 = Person('Joe Schmoe', 90000)
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2 = Person('Jane Smith', 99000)
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: Get the salaries using getter and print
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 print(oPerson1.getSalary())
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: print(oPerson2.getSalary())
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: Change the salaries using setter
  id: totrans-1194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 oPerson1.setSalary(100000)
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: oPerson2.setSalary(111111)
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: Get the salaries and print again
  id: totrans-1197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print(oPerson1.getSalary())
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: print(oPerson2.getSalary())
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-5: Example main code using get er and set er methods*'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: First we create two Person objects from the Person class 1\. Then we use
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: the getter and setter methods to retrieve 2 and change 3 the salaries in
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: the Person objects.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters provide a formal way to get and set values in an
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: object. They enforce a layer of protection that only allows access to instance
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: variables if the class writer wants to allow it.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '*Some Python literature uses the terms* accessor *for a getter method and*
    mutator *for* *the setter method. These are just different names for the same
    things. I will use the* *more generic terms* getter *and* setter *.*'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **171**
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '***Safe Direct Access***'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: There are certain circumstances where it seems reasonable to access
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'instance variables directly: when it is absolutely clear what the instance
    vari-'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: able means, little or no validation of the data is needed, and there is no
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: chance that the name will ever change. A good example of this is the Rect
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: (rectangle) class in the pygame package. A rectangle in pygame is defined
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: 'using four values—x, y, width, and height—like this:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: oRectangle = pygame.Rect(10, 20, 300, 300)
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: After creating that rectangle object, using oRectangle.x, oRectangle.y,
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: oRectangle.width, and oRectangle.height directly as variables seems acceptable.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '**Making Instance Variables More Private**'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: In Python, all instance variables are public (that is, can be accessed by code
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: external to the class). But what if you want to allow access to some of your
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: class’s instance variables, but not all of them? Some OOP languages allow
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: you to explicitly mark certain instance variables as public or private, but
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn’t have those keywords. However, there are two ways that pro-
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: grammers who develop classes in Python can indicate that their instance
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: variables and methods are intended to be private.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: '***Implicitly Private***'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: To mark an instance variable as one that should never be accessed exter-
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: nally, by convention you start the name of your instance variable with one
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: 'leading underscore:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: self._name
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: self._socialSecurityNumber
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: self._dontTouchThis
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables with names like these are intended to represent pri-
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: vate data, and client software should never attempt to access them directly.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: The code may still work if the instance variables are accessed, but it is not
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: guaranteed.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: 'The same convention is used for method names:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'def _internalMethod(self):'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: 'def _dontCallMeFromClientSoftware(self):'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is only a convention; there is no enforcement. If any client
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: software makes a call to a method with a name beginning with an under-
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: score, Python will allow it, but there is a good chance that doing so will
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: lead to unexpected errors.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '**172** Chapter 8'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '***More Explicitly Private***'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: Python does allow for a more explicit level of privatization. To disallow client
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: software from directly accessing your data, you create an instance variable
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: name that starts with two underscores.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we create a class named PrivatePerson with an instance variable
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: 'self.__privateData that should never be accessed from outside an object:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: PrivatePerson class
  id: totrans-1253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class PrivatePerson():'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, privateData):'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.__privateData = privateData
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: 'def getName(self):'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: return self.name
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: 'def setName(self, name):'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: We can then create a PrivatePerson object, passing in some data that we
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: wish to keep private 1\. Attempting to access the __privateData instance vari-
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 'able directly from client software, like this:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: usersPrivateData = oPrivatePerson.__privateData
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'will generate an error:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'AttributeError: ''PrivatePerson'' object has no attribute ''__privateData'''
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you create a method name that starts with two underscores,
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: any attempt by client software to call the method will generate an error.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: Python provides this ability by performing *name mangling*. Behind
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: the scenes, Python changes any name that starts with two underscores by
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: prepending it with an underscore and the name of the class, so __ *<name>*
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: becomes _ *<className>* __ *<name>* . For example, in the PrivatePerson class,
    Python will change self.__privateData to self._PrivatePerson__privateData. Therefore,
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: if a client tries to use the name oPrivatePerson.__privateData, that name won’t
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: be recognized.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: This is a subtle change designed as a deterrent to using direct
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: access, but you should note that it doesn’t absolutely guarantee privacy.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: If the client programmer knows how this works, they can still access the
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: instance variable with *<object>* ._ *<className>* __ *<name>* (or, in our example,
    oPrivatePerson._PrivatePerson__privateData).
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **173**
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorators and @property**'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, a decorator is a method that takes another method as an
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: argument and extends the way the original method works. (Decorators can
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: also be functions that decorate functions or methods, but I’ll concentrate
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: on methods.) Decorators are an advanced topic and are generally beyond
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: the scope of this book. However, there is a set of built-in decorators that
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: provide a compromise between direct access and the use of getters and set-
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: ters in a class.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: A decorator is written as a line that starts with the @ symbol followed
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: by a decorator name and is placed directly before the def statement of a
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: 'method. This applies the decorator to a method to add to its behavior:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '@ *<decorator>*'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: def *<someMethod>* (self, *<parameters>* )
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use two built-in decorators and apply them to two methods in a
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: class to implement a *property*.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: '**property**'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: An attribute of a class that appears to client code to be an instance variable,
    but instead causes a method to be called when it is accessed .
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: A property allows class developers to use indirection, the way that
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: a magician uses misdirection—the audience thinks they are seeing one
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: thing, while behind the scenes something very different is happening.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: When writing a class to use property decorators, the developer writes a get-
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: ter and a setter method and adds a distinct built-in decorator to each one.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: The first method is a getter and is preceded with the built-in @property deco-
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: rator. The name of the method defines a name of a property to be used by
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: client code. The second method is a setter and is preceded with the @ *<name*
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '*of the property>* .setter decorator. Here is a minimal sample class:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: 'class Example():'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, startingValue):'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: self._x = startingValue
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: 'def x(self): # this is the decorated getter method'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: return self._x
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: '@x.setter'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: 'def x(self, value): # this is the decorated setter method'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: self._x = value
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: In the Example class, x is the name of the property. After the standard
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method, the unusual thing is that we have two methods that both
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: 'have the same name: the name of the property. The first method is a get-'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: ter, while the second is a setter. The setter method is optional, and if it’s
    not
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: present, the property will be read-only.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '**174** Chapter 8'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the Example class, here is some sample client code:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: oExample = Example(10)
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: print(oExample.x)
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: oExample.x = 20
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: In this code we create an instance of the Example class, make a call to
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: print(), and execute a simple assignment. From the client’s point of view,
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: this code is highly readable. When we write oExample.x, it looks like we are
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: using direct access to an instance variable. However, when client code
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: accesses the value of an object’s property (on the right side of an assign-
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: ment statement or as an argument in a call to a function or method),
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: Python translates it into a call to the getter method of the object. When an
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: object dot property appears on the left side of an assignment statement,
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: Python calls the setter method. The getter and setter methods affect the
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: real instance variable, self._x.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more realistic example that should help make this clear.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-6 shows a Student class that includes a property grade, properly dec-
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: orated getter and setter methods, and a private instance variable __grade.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PropertyDecorator/Student.py**'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: Using a property to (indirectly) access data in an object
  id: totrans-1340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Student():'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, startingGrade=0):'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: self.__name = name
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: self.grade = startingGrade 1
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '@property 2'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: 'def grade(self): 3'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: return self.__grade
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '@grade.setter 4'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: 'def grade(self, newGrade): 5'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: newGrade = int(newGrade)
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: 'except (TypeError, ValueError) as e:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: 'raise type(e)(''New grade: '' + str(newGrade) + '', is an invalid type.'')'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: 'if (newGrade < 0) or (newGrade > 100):'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: 'raise ValueError(''New grade: '' + str(newGrade) + '', must be between 0 and
    100.'')'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: self.__grade = newGrade
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-6: The Student class with property decorators*'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method has a little trick to it, so let’s examine the
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: other methods first. Notice we have two methods with the name grade().
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: Preceding the definition of the first grade() method, we add an @property
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: decorator 2\. This defines the name grade as a property of any object cre-
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: ated from this class. The first method 3 is a getter that just returns the
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **175**
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: value of the current grade, kept in the private self.__grade instance variable,
    but could include any code that might be needed to calculate a value and
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: return it.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: Preceding the second grade() method is an @grade.setter decorator 4\.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: This second method 5 accepts a new value as a parameter, does a num-
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: ber of checks to ensure that value is valid, then sets the new value into
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: self.__grade.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method first stores the student’s name in an instance
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: variable. The next line 1 seems straightforward but is a little unusual. As
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: we have seen, we typically store the values of parameters into instance vari-
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: 'ables. Therefore, we might be tempted to write this line as:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: self.__grade = startingGrade
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: But instead, we are storing the starting grade into the property grade.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: Since grade is a property, Python translates this assignment statement into
    a
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: call to the setter method 5, which has the advantage of validating the input
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: before storing the value in the instance variable self.__grade.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-7 provides some test code that uses the Student class.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PropertyDecorator/Main_Property.py**'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: Main Student property example
  id: totrans-1381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 oStudent1= Student('Joe Schmoe')
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: oStudent2= Student ('Jane Smith')
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: Get the students' grades using the 'grade' property and print
  id: totrans-1384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 print(oStudent1.grade)
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: print(oStudent2.grade)
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: Set new values using the 'grade' property
  id: totrans-1388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 oStudent1.grade = 85
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: oStudent2.grade = 92
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: 4 print(oStudent1.grade)
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: print(oStudent2.grade)
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-7: The main code that creates Student objects and accesses a property*
    In the test code, we first create two Student objects 1 and print the'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: grade of each 2\. It looks like we’re reaching into each object directly to
    get
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: the grade values, but since grade is a property Python turns these lines into
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: calls to the getter method and returns the value of the private instance vari-
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: able self.__grade for each object.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: We then set new grade values for each Student object 3\. Here it looks
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: like we’re setting values directly into each object’s data, but again, because
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: grade is a property, Python turns these lines into calls to the setter method.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: That method validates each value before doing the assignment. The test
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: code ends by printing the new values of the grades 4\.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '**176** Chapter 8'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the test code, we get this output, as we expect:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: Using the @property and @ *<property_name>* .setter decorators gives you the
    best of both the direct access and getter-and-setter worlds. Client software
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: can be written in a way that *appears* to access instance variables directly,
    but as the class programmer, your decorated methods get and set the actual
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: instance variables owned by the object and even allow for validation of
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: inputs. This approach supports encapsulation because the client code is not
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: accessing an instance variable directly.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: While this technique is used by many professional Python developers,
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: I personally find it a little ambiguous, because when I read other develop-
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: ers’ code that uses this approach, it is not immediately apparent whether it’s
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: using direct accesses to instance variables or using properties that Python
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: translates into calls to decorated methods. I prefer to use standard getter
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: and setter methods and will use them in the rest of this book.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation in pygwidgets Classes**'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: The definition of encapsulation at the start of this chapter focused on two
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: 'areas: hiding internal details and having all related code in one place. All'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: the classes in pygwidgets were designed with these considerations in mind.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: As examples, consider the TextButton and CustomButton classes.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: The methods of these two classes encapsulate all the functionality of
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: GUI buttons. While the source code of these classes is available, there is no
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: need for a client programmer to look at it to use them effectively. There’s
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: also no need for client code to attempt to access any of their instance vari-
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'ables: all button functionality is available through calling the methods of'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: these classes. This adheres to the strict interpretation of encapsulation,
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: meaning that the *only* way that client software should access an object’s data
    is by calling that object’s methods. A client programmer can think of these
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: classes as black boxes, since there is no reason to look at how they accom-
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: plish their tasks.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '*A whole* black box testing *industry has developed around the idea of a test
    programmer being given a class to test without being allowed to see the code of
    the class.*'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '*The tester is only supplied with documentation of the interfaces, and with
    that writes* *code that tests all the interfaces under many different cases to
    ensure that all methods* *work as described. The set of tests not only ensures
    that the code and documentation* *match, but is used again whenever code is added
    or modified in the class to ensure* *that the changes have not broken anything.*'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **177**
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '**A Story from the Real World**'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: A number of years ago, I was involved in the design and development of
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: a very large educational project that was built in an environment called
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: '*Director* from Macromedia (later Adobe), using the object-oriented *Lingo*
    language. Director was designed to be extended through *XTRAs* that could'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: add functionality, similar to the way plug-ins are added to browsers. These
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: XTRAs were developed and sold by a number of third-party vendors. In the
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: design, we planned on storing navigational and other course-related infor-
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: mation in a database. I looked at all the different database XTRAs that
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: were available and purchased a particular XTRA, which I’ll call XTRA1\.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: Each XTRA came with documentation of its API, which showed how to
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: make queries to the database using Structured Query Language (SQL). I
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: decided to create a Database class that incorporated all the functionality of
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: accessing the database using XTRA1’s API. That way, all code that commu-
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: nicated with the XTRA directly was in the Database class. Figure 8-1 shows
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: the overall architecture.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: Requests
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: info
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: Builds
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: Accesses
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: database
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: Main
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: Database
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: Database
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: program
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: object
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: XTRA
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: results
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Database
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: results
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: results
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8-1: The architecture of accessing a database using an object and an
    XTRA* When the program started, it created a single instance of the Database'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: class. The main code was a client of the Database object. Whenever the main
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: code wanted information from the database, rather than formatting a SQL
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: query itself, it called a method of the Database object, supplying details about
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: what information it wanted. The methods in the Database object translated
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: each request into a SQL query made to XTRA1 to get data from the data-
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: base. That way, only the code of the Database object knew how to access the
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: XTRA using its API.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: The program worked well, and the customers enjoyed using the prod-
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: uct. But every once in a while, we would run into errors in the data we got
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: back from the database. I contacted the XTRA1 developer and gave many
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: easily reproducible examples of the problems. Unfortunately, the developer
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: never addressed these issues.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: Because of the lack of response, we eventually decided to purchase a
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: different database XTRA, XTRA2, to serve this purpose. XTRA2 worked in
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '**178** Chapter 8'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: a similar way but had some subtle differences in how it was initialized and
    required some minor changes in the way that SQL queries were built.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: Because the Database class encapsulated all the details of communicat-
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: ing with the XTRA, we were able to make all the necessary changes to work
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: with XTRA2 only in the Database class. We did not change a single line in
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: the main program (the client code).
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I was both the Database class developer and the client soft-
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: ware developer. If my client code had used the names of instance variables
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: in the class, I would have had to crawl through the program, modifying
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: each line of relevant code. Using encapsulation with a class saved me from
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: countless hours of reworking and testing.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: As a follow-up to the story, while XTRA2 worked well, that company
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: eventually went out of business and I had to go through the same process
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: again. Once again, because of encapsulation, only the code of the Database
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: class was modified to work with XTRA3\.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction**'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is another OOP concept closely related to encapsulation; many
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: developers consider it to be the fourth tenet of OOP.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: Whereas encapsulation is about implementation, hiding the details of
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: the code and data that make up a class, *abstraction* is about the client’s
    view of a class. It’s about the perception of a class from the outside.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '**abstraction**'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: Handling complexity by hiding unnecessary details .
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, abstraction is a reminder to make sure that the user’s view
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: of a system is as simple as possible.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is extremely common in consumer products. Many people
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: use TVs, computers, microwave ovens, cars, and so on every day. We become
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: comfortable with the user interface that these products extend to us. Through
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: their controls, they provide an abstraction of their functionality. You press
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: the accelerator pedal in a car to make it go forward. With a microwave, you
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: set an amount of time and press Start to heat up some food. But few of us
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: really know how these products work internally.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of abstraction from the world of computer science.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a *stack* is a mechanism for remembering data in a *last in,*
    *first out* *(LIFO)* order. Think of a pile of plates, where clean plates are
    added to the top and users take one from the top when they need a plate. A stack
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: 'has two standard operations: push adds an item to the top of the stack, and'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: pop removes the topmost item from the stack.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: A stack is particularly useful whenever your program does any naviga-
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: tion because it can be used to leave a trail of breadcrumbs for finding your
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: way back. This is how programming languages keep track of the execution
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: 'of function and method calls in code: when you call a function or method,'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: the return point is pushed onto a stack, and when the function or method
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **179**
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: returns, the place to return to is discovered by popping the most recent information
    off the top of the stack. In this way, code can make as many
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: levels of calls as you need, and it always unwinds correctly.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: As an abstraction, suppose a client program required the functional-
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: ity of a stack that would be simple to create and would provide the ability
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: to push and pop information. If this were written as a class, the client code
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: 'would create a stack like this:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: oStack = Stack()
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: 'A client would add information by calling a push() method like this:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: oStack.push( *<someData>* )
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: And it would retrieve the most recent data by calling a pop() method
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '*<someVariable>* = oStack.pop()'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: The client would not need to know or care how these methods were
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: implemented or how the data was stored. The implementation of the Stack
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: would be handled completely by the methods of the Stack.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: While the client code could view a Stack class as a black box, writing
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: such a class in Python is fairly trivial. Listing 8-8 shows how it could be
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: implemented.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Stack/Stack.py**'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: Stack class
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Stack():'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: ''''''' Stack class implements a last in first out LIFO algorithm'''''''
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, startingStackAsList=None):'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: 'if startingStackAsList is None:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.dataList = [ ]
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: 'self.dataList = startingStackAsList[:] # make a copy'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '2 def push(self, item):'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: self.dataList.append(item)
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '3 def pop(self):'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(self.dataList) == 0:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: raise IndexError
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: element = self.dataList.pop()
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: return element
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '**180** Chapter 8'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '4 def peek(self):'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the top item, without removing it
  id: totrans-1564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: item = self.dataList[-1]
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: return item
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: '5 def getSize(self):'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: nElements = len(self.dataList)
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: return nElements
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '6 def show(self):'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: Show the stack in a vertical orientation
  id: totrans-1571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print('Stack is:')
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in reversed(self.dataList):'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: print(' ', value)
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-8: A stack as a Python class*'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: The Stack class keeps track of all the data using a list instance variable
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: named self.dataList 1\. The client doesn’t need to know this level of detail,
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: but push() 2 just adds an item to the internal list using the Python append()
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: operation, while pop() 3 pops the last element from the internal list. Because
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: it is easy to do, this implementation of the Stack class also implements three
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: 'additional methods:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: • peek() 4 allows the caller to obtain the data at the top of the stack with-
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: out removing it from the stack.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: • getSize() 5 returns the number of items on the stack.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: • show() 6 prints the contents of the stack in the way that the client
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: 'thinks of a stack: the data is displayed vertically, with the most recent'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: data pushed shown at the top. This can be helpful in debugging client
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: code that involves multiple calls to push() and pop().
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: This was an extremely simple example, but as you gain more experience
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: writing classes, your classes will typically become more complex. Along the
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: way, you may find cleaner and more efficient ways of writing some methods
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: and perhaps rewrite them. Because objects provide both encapsulation and
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: abstraction, as the writer of a class, you should feel free to modify its code
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: and data, as long as the published interfaces do not change. Changes to the
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: implementation of methods should have no ill effects on client software but
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: rather should allow you to make improvements without affecting any client
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: code. In fact, if you find ways to make your code more efficient and publish
    a
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: new version, client code may appear to speed up, with zero changes required
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: to that code.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: A property is an excellent example of abstraction. As you saw earlier,
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: with properties the client programmer can use a syntax that makes their
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: intent clear (to get and set a value in an object). The implementation in the
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: methods that are called as a result can be much more complicated, but is
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: totally hidden from the client code.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation **181**
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is the first major tenet of object-oriented programming,
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: allowing classes to hide their implementation and data from client code
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: and ensuring that a class provides all the functionality that a client needs
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: in a single place.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: A key concept of OOP is that objects own their data, and that’s why
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you provide getter and setter methods if you want cli-
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: ent code to access the data held in an instance variable. Python does
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: allow direct access to instance variables using dot syntax, but I strongly
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: encourage you to stay away from this syntax for the reasons laid out in
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: this chapter.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: There are conventions for marking instance variables and methods as
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: private, using a leading underscore or double underscore depending on the
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: level of privatization you require. As a compromise, Python also allows the
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: use of the @property decorator. This makes it appear as if the client code is
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: able to access an instance variable directly, while behind the scenes Python
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: turns such references into calls to the decorated getter and setter methods
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: in the class.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: The pygwidgets package provides many good examples of encapsulation.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: As a client programmer, you see a class from the outside and work with the
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: interfaces that the class provides. As a class designer, abstraction—handling
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: complexity by hiding details—helps you design a good interface by consid-
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: ering the interface of the class from the client’s point of view. However, in
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Python, you often have the source code available so that you can look at the
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: implementation if you wish.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: '**182** Chapter 8'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: '**9**'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '**P O LY M O R P H I S M**'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about the second major
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: 'tenet of OOP: *polymorphism*. Its component'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: 'parts are from the Greek: the prefix *poly*'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: means “much” or “many,” and *morphism* means
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: “shape,” “form,” or “structure.”
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: So, *polymorphism* essentially means *many forms*. I’m not talking about a *Star
    Trek*–style shape-shifting alien—in fact, it’s quite the opposite. Rather than
    one thing taking on many shapes, polymorphism in OOP is about
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: how multiple classes can have methods with the exact same names. This
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: will eventually give us a highly intuitive way to act on a collection of objects,
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: independent of what class each came from.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: OOP programmers often use the term “send a message” when we talk
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: about client code calling a method of an object. What the object should do
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: when it receives the message is up to the object. With polymorphism, we can
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: send the same message to multiple objects, and each object will react differ-
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: ently depending on what it’s designed to do and the data available to it.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll discuss how this ability allows you to build pack-
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: ages of classes that are easily extensible and predictable. We’ll also use
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism with operators to make the same operators perform different operations
    depending on the data types they are working with. Finally,
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you how to use the print() function to get valuable debugging
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: information from objects.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending Messages to Real-World Objects**'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at polymorphism in the real world, using cars as an example. All
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: cars have an accelerator pedal. When the driver presses that pedal, they’re
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: sending the “accelerate” message to the car. The car they’re driving could
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: have an internal combustion engine or an electric motor, or be a hybrid.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: Each of these types of cars has its own implementation of what happens
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: when it receives the accelerate message, and each behaves accordingly.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism allows for easier adoption of new technology. If some-
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: one were to develop a nuclear-powered car, the user interface of the car
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: would remain the same—the driver would still press the accelerator pedal
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: to send the same message—but a very different mechanism would make the
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: nuclear-powered car go faster.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: As another real-world example, imagine you enter a large room with a
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: bank of light switches that control a variety of different lights. Some of the
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: bulbs are old-style incandescent bulbs, some are fluorescent, and some are
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: newer LED bulbs. When you flip all the switches up, you are sending the
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: “turn on” message to all the bulbs. The underlying mechanisms that cause
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: incandescent, fluorescent, and LED bulbs to emit light are wildly different,
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: but each achieves the user’s intended goal.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '**A Classic Example of Polymorphism in Programming**'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: In terms of OOP, polymorphism is about how client code can call a method
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: with the exact same name in different objects, and each object will do what-
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: ever it needs to do to implement the meaning of that method for that object.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: The classic example of polymorphism is to consider code that repre-
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: sents different types of pets. Let’s say you have a collection of dogs, cats,
    and
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: birds, and each understands some basic commands. If you ask these pets
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: to speak (that is, you send the “speak” message to each), the dogs will say
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: “bark,” the cats will say “meow,” and the birds will say “tweet.” Listing 9-1
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: shows how we might implement this in code.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PetsPolymorphism.py**'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: Pets polymorphism
  id: totrans-1683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three classes, all with a different "speak" method
  id: totrans-1684
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Dog():'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: '**184** Chapter 9'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '1 def speak(self):'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: print(self.name, 'says bark, bark, bark!')
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: 'class Cat():'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '2 def speak(self):'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: print(self.name, 'says meeeoooow')
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: 'class Bird():'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: '3 def speak(self):'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: print(self.name, 'says tweet')
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: oDog1 = Dog('Rover')
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: oDog2 = Dog('Fido')
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: oCat1 = Cat('Fluffy')
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: oCat2 = Cat('Spike')
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: oBird = Bird('Big Bird')
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: 4 petsList = [oDog1, oDog2, oCat1, oCat2, oBird]
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: Send the same message (call the same method) of all pets
  id: totrans-1707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for oPet in petsList:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: 5 oPet.speak()
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-1: Sending the “speak” message to objects instantiated from different
    classes* Each class has a speak() method, but the content of each method'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: is different 1 2 3\. Each class does whatever it needs to do in its ver-
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: sion of this method; the method name is the same, but it has different
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: implementations.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: To make things easy to deal with, we put all the pet objects into a list 4\.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: To make them all speak, we then loop through all the objects and send
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: the same message by calling a method with the exact same name in each
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: object 5, without worrying about the type of the object.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Using Pygame Shapes**'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at a demonstration of polymorphism using pygame. In
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5 w](index_split_002.html#p118)e used pygame to draw primitive shapes
    such as rectangles, circles, polygons, ellipses, and lines. Here we’ll build a
    demonstration'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: program that will randomly create and draw different shapes in a window.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: The user can then click on any shape, and the program will report the
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: type and area of the shape that was clicked. Because the shapes are ran-
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: domly created, each time the program runs, the size, location, number,
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: and position of the shapes will be different. Figure 9-1 shows some sample
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: output from the demonstration program.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **185**
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 27](index-215_1.png)'
  id: totrans-1728
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: A pygame-based example of using polymorphism to draw different
    shapes* We’ll implement the program with a class for each of three different shapes:
    Square, Circle, and Triangle. The key thing to note here is that'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: all three shape classes contain methods with the same names, __init__(),
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: draw(), getType(), getArea(), and clickedInside(), that perform the same tasks.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: However, the implementation of each method is different because each
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: class deals with a different shape.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: '***The Square Shape Class***'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with the simplest shape. Listing 9-2 shows the code of the Square
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: class.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Square.py**'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: Square class
  id: totrans-1738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  id: totrans-1741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: 'class Square():'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '**186** Chapter 9'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight = random.randrange(10, 100)
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y, self.widthAndHeight,
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight)
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = 'Square'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '2 def clickedInside(self, mousePoint):'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: clicked = self.rect.collidepoint(mousePoint)
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: return clicked
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: '3 def getType(self):'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: '4 def getArea(self):'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: theArea = self.widthAndHeight * self.widthAndHeight
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '5 def draw(self):'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect(self.window, self.color,
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y, self.widthAndHeight,
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: self.widthAndHeight))
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-2: The Square class*'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we set up a number of instance variables to
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: use in the methods of the class. That lets us keep the code of the methods
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: very simple. Since the __init__() method saved the rectangle of the Square,
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: the clickedInside() method 2 just checks if the location of a mouse click was
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: inside that rectangle, returning True or False.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: The getType() method 3 simply returns the information that the item
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: clicked is a square. The getArea() method 4 multiplies the width by the
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: height and returns the resulting area. The draw() method 5 uses pygame’s
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: draw.rect() to draw the shape in the randomly chosen color.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '***The Circle and Triangle Shape Classes***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the code of the Circle and the Triangle classes.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to notice is that these classes have methods with the
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: same names as the Square class, but the code in these methods (especially
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: clickedInside() and getArea()) is very different. Listing 9-3 shows the Circle
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: class. Listing 9-4 shows the Triangle class that creates randomly sized right
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: triangles whose edges are parallel to the x- and y-axes, with the right angle
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: in the upper-left corner.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **187**
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Circle.py**'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: Circle class
  id: totrans-1788
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: import math
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  id: totrans-1792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: 'class Circle():'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: self.radius = random.randrange(10, 50)
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: self.centerX = self.x + self.radius
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: self.centerY = self.y + self.radius
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y,
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: self.radius * 2, self.radius * 2)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = 'Circle'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: '1 def clickedInside(self, mousePoint):'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: distance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: ((mousePoint[1] - self.centerY) ** 2))
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: 'if distance <= self.radius:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: return True
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: '2 def getArea(self):'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: theArea = math.pi * (self.radius ** 2) squared
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: 'def getType(self):'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: '3 def draw(self):'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle(self.window, self.color,
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: (self.centerX, self.centerY),
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: self.radius, 0)
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-3: The Circle class*'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: '**188** Chapter 9'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Shapes/Triangle.py**'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: Triangle class
  id: totrans-1827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: Set up the colors
  id: totrans-1830
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: BLUE = (0, 0, 255)
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: 'class Triangle():'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: self.width = random.randrange(10, 100)
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: self.height = random.randrange(10, 100)
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: self.triangleSlope = -1 * (self.height / self.width)
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = pygame.Rect(self.x, self.y,
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height)
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: self.shapeType = 'Triangle'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: '4 def clickedInside(self, mousePoint):'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: inRect = self.rect.collidepoint(mousePoint)
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: 'if not inRect:'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: Do some math to see if the point is inside the triangle
  id: totrans-1850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: xOffset = mousePoint[0] - self.x
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: yOffset = mousePoint[1] - self.y
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: 'if xOffset == 0:'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: return True
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the slope (rise over run)
  id: totrans-1855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pointSlopeFromYIntercept = (yOffset - self.height) / xOffset
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: 'if pointSlopeFromYIntercept < self.triangleSlope:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: return True
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: 'def getType(self):'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: return self.shapeType
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: '5 def getArea(self):'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: theArea = .5 * self.width * self.height
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: return theArea
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism **189**
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon(self.window, self.color,
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: ((self.x, self.y + self.height),
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: (self.x, self.y),
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: (self.x + self.width, self.y)))
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-4: The Triangle class*'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: To understand the polymorphism at work here, let’s look at the
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: codeof the clickedInside() method for each shape. The clickedInside()
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: 'method of the Square class was very simple: a check to see if the mouse'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: click occurred inside the rectangle of the Square. The details of the cal-
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: culations for clickedInside() in the Circle and Triangle classes are not par-
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: ticularly important, but they clearly are doing different calculations. The
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: clickedInside() method of the Circle class 1 only reports a click if the user
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: clicks on a colored pixel of the shape. That is, it detects a click that is
    within
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: the bounding rectangle of the circle, but the click must also be within the
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: radius of the circle for it to count as a click. The clickedInside() method
    of
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: the Triangle class 4 must determine if the user has clicked on a pixel inside
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: the colored triangular portion of the rectangle. The methods in all three
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: classes accept a mouse click as a parameter and return either True or False
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: as a result.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: The getArea() 2 5 and draw() methods 3 6 of these classes have names
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: that are identical to methods of the Square class, but they do different work
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: internally. There’s a different calculation for area, and they draw different
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: shapes.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
