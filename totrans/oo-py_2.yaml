- en: method, passing in the new text to display. The setValue() method has an opti-
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，传入新的显示文本。setValue() 方法有一个可选的
- en: 'mization, too: it remembers the last text that it rendered, and before doing'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化也做得很好：它记住了上次渲染的文本，并且在执行之前
- en: anything else, it checks if the new text is the same as the previous text. If
    the
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本没有变化，什么都不做，方法直接返回。如果有新文本，
- en: text has not changed, there is nothing to do and the method just returns. If
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本没有变化，什么也不做，方法直接返回。
- en: there is new text, it renders the new text into a surface to be drawn.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有新文本，它将渲染新的文本到一个要绘制的表面。
- en: The draw() method 5 draws the image contained in the self.textSurface
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法 5 绘制 self.textSurface 中包含的图像
- en: instance variable into the window at the given location. This method should
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将实例变量放入窗口的指定位置。此方法应在每一帧中调用。
- en: be called in every frame.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在每一帧中调用。
- en: 'There are multiple advantages to this approach:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有多个优点：
- en: • The class hides all the details of pygame’s rendering of text, so the user
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 该类隐藏了 pygame 渲染文本的所有细节，因此用户
- en: of this class never needs to know what pygame-specific calls are needed
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的实例不需要知道需要哪些特定于 pygame 的调用
- en: to show text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本。
- en: '**134** Chapter 6'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**134** 第 6 章'
- en: • Each SimpleText object remembers the window that it draws into, the location
    where the text should be placed, and the text color. Therefore,
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个 SimpleText 对象记住它绘制文本的窗口、文本放置的位置和文本颜色。因此，
- en: you only need to specify these values once, when you instantiate a
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在实例化时指定这些值一次
- en: SimpleText object, typically before the main loop starts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleText 对象，通常在主循环开始之前。
- en: • Each SimpleText object is also optimized to remember both the text that
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个 SimpleText 对象还被优化为记住它显示的文本
- en: it was last told to draw and the image (self.textSurface) that it made
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它记住了上次绘制的图像（self.textSurface），如果
- en: from the current text. It only needs to render a new surface when the
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文本的变化。只有当
- en: text changes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 文本发生变化时。
- en: • To show multiple pieces of text in a window, you only need to instanti-
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: • 要在窗口中显示多段文本，你只需要实例化
- en: ate multiple SimpleText objects. This is a key concept of object-oriented
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个 SimpleText 对象。这是面向对象编程的一个关键概念
- en: programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编程。
- en: '**Demo Ball with SimpleText and SimpleButton**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**演示球与 SimpleText 和 SimpleButton**'
- en: To cap this off, we’ll modify Listing 6-2 to use the SimpleText and SimpleButton
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改示例 6-2，使用 SimpleText 和 SimpleButton
- en: classes. The updated program in Listing 6-7 keeps track of the number of
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类的更新程序在示例 6-7 中跟踪了
- en: times it goes through the main loop and reports that information at the top
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它会检查主循环运行的次数，并在顶部报告该信息。
- en: of the window. Clicking the Restart button resets the counter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口上。点击重启按钮会重置计数器。
- en: '**File: PygameDemo8_SimpleTextDisplay/Main_Bal TextAndButton.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo8_SimpleTextDisplay/Main_Bal TextAndButton.py**'
- en: pygame demo 8 - SimpleText, SimpleButton, and Ball
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 8 - SimpleText、SimpleButton 和 Ball
- en: 1 - Import packages
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import random
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: '1 from Ball import * # bring in the Ball class code'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '1 from Ball import *  # 导入 Ball 类代码'
- en: from SimpleText import *
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleText import *
- en: from SimpleButton import *
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleButton import *
- en: 2 - Define constants
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WHITE = (255, 255, 255)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: WINDOW_WIDTH = 640
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: 5 - Initialize variables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
- en: oFrameCountLabel = SimpleText(window, (60, 20),
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountLabel = SimpleText(window, (60, 20),
- en: '''Program has run through this many loops: '', WHITE)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '''程序已经运行了这么多次：'', WHITE)'
- en: Object-Oriented Pygame **135**
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **135**
- en: oFrameCountDisplay = SimpleText(window, (500, 20), '', WHITE)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountDisplay = SimpleText(window, (500, 20), '', WHITE)
- en: oRestartButton = SimpleButton(window, (280, 60),
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: oRestartButton = SimpleButton(window, (280, 60),
- en: '''images/restartUp.png'', ''images/restartDown.png'')'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/restartUp.png'', ''images/restartDown.png'')'
- en: frameCounter = 0
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: frameCounter = 0
- en: 6 - Loop forever
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: '3 if oRestartButton.handleEvent(event):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '3 if oRestartButton.handleEvent(event):'
- en: 'frameCounter = 0 # clicked button, reset counter'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'frameCounter = 0 # 点击按钮，重置计数器'
- en: 8 - Do any "per frame" actions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: '4 oBall.update() # tell the ball to update itself'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '4 oBall.update() # 告诉球更新自己'
- en: 'frameCounter = frameCounter + 1 # increment each frame'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'frameCounter = frameCounter + 1 # 每帧递增'
- en: 5 oFrameCountDisplay.setValue(str(frameCounter))
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 5 oFrameCountDisplay.setValue(str(frameCounter))
- en: 9 - Clear the window before drawing it again
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在重新绘制之前清空窗口
- en: window.fill(BLACK)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw the window elements
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: '6 oBall.draw() # tell the ball to draw itself'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '6 oBall.draw() # 告诉球绘制自己'
- en: oFrameCountLabel.draw()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountLabel.draw()
- en: oFrameCountDisplay.draw()
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: oFrameCountDisplay.draw()
- en: oRestartButton.draw()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: oRestartButton.draw()
- en: 11 - Update the window
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢一些
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 6-7: An example main program to show Ball, SimpleText, and SimpleButton*
    At the top of the program, we import the code of the Ball, SimpleText,'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-7: 一个示例主程序，展示Ball、SimpleText和SimpleButton* 在程序的顶部，我们导入Ball、SimpleText的代码，'
- en: and SimpleButton classes 1\. Before our main loop starts, we create an instance
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 和SimpleButton类 1\. 在主循环开始之前，我们创建了一个实例
- en: of the Ball 2, two instances of the SimpleText class (oFrameCountLabel for the
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Ball 2的两个实例，SimpleText类的两个实例（oFrameCountLabel用于
- en: unchanging message label and oFrameCountDisplay for the changing dis-
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不变的消息标签和oFrameCountDisplay用于显示帧数的变化，
- en: play of frames), and an instance of the SimpleButton class that we store in
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 帧数显示（以及帧数的变化），还有一个SimpleButton类的实例，我们将其存储在
- en: oRestartButton. We also initialize a variable frameCounter to zero, which we
    will
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: oRestartButton。我们还初始化了一个变量frameCounter为零，后续会使用
- en: increment every time through the main loop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过主循环时递增。
- en: In the main loop, we check if the user pressed the Restart button 3\. If
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们检查用户是否按下了重启按钮 3\. 如果
- en: True, we reset the frame counter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，我们重置了帧计数器。
- en: We tell the ball to update its position 4\. We increment the frame coun-
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉球更新其位置 4\. 我们递增帧计数器—
- en: ter, then call the setValue() method of the text field to show the new count
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用文本字段的setValue()方法，显示新的计数
- en: of frames 5\. Finally, we tell the ball to draw itself tell the text fields
    to draw
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 帧数 5\. 最后，我们告诉球绘制自己，并告诉文本字段绘制
- en: themselves, and tell the Restart button to draw itself, by calling the draw()
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它们自己，并通过调用draw()方法，告诉重启按钮绘制自己
- en: method of each object 6\.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象的方法 6\。
- en: '**136** Chapter 6'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**136** 第6章'
- en: In the instantiation of the SimpleText objects, the last argument is a text
    color, and we specified that the objects should be rendered in WHITE so
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在SimpleText对象的实例化中，最后一个参数是文本颜色，我们指定这些对象应以白色渲染，因此
- en: they can be seen against a BLACK background. In the next chapter, I’ll show
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样它们就能在黑色背景下显示出来。在下一章，我将展示
- en: how to expand the SimpleText class to incorporate more attributes, without
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如何扩展SimpleText类以包含更多属性，而不
- en: complicating the interface of the class. We’ll build a more full-featured text
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不会使类的接口变得复杂。我们将构建一个功能更全的文本
- en: object that has reasonable default values for each of these attributes, but
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对象有合理的默认值来设置这些属性，但
- en: allows you to override those defaults.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你重写这些默认值。
- en: '**Interface vs. Implementation**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口与实现**'
- en: The SimpleButton and SimpleText examples bring up the important topic of
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton和SimpleText示例引出了一个重要的话题
- en: interface versus implementation. As mentioned i[n Chapter 4, t](index_split_001.html#p86)he
    interface refers to how something is used, while the implementation refers to
    how
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接口与实现。如第4章中提到的，[接口](index_split_001.html#p86)指的是某个东西如何被使用，而实现则指的是其内部工作原理。
- en: something works (internally).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内部是如何运作的（即某些功能的实现）。
- en: In an OOP environment, the interface is the set of methods in a class and
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP环境中，接口是类中一组方法的集合，
- en: their related parameters—also known as the *application programming interface*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它们相关的参数——也称为*应用程序编程接口*
- en: '*(API)*. The implementation is the actual code of all the methods in the class.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*(API)*。实现则是类中所有方法的实际代码。'
- en: An external package such as pygame will most likely come with docu-
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个外部包，如pygame，通常会附带文档
- en: mentation of the API that explains the calls that are available and the
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API文档解释了可以调用的函数以及每次调用时你需要传递的参数。
- en: arguments you are expected to pass with each call. The full pygame API
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在每次调用时传递的参数。完整的pygame API
- en: documentation is available at [*https://www.pygame.org/docs/*](https://www.pygame.org/docs/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在 [*https://www.pygame.org/docs/*](https://www.pygame.org/docs/) 找到。
- en: When you write code that makes calls to pygame, you don’t need to worry
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写调用 pygame 的代码时，你不需要担心
- en: about the implementation of the methods you are using. For example,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你正在使用的方法的实现。例如，
- en: when you make a call to blit() to draw image, you really don’t care *how*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 blit() 来绘制图像时，你其实并不关心 *如何*
- en: blit() does what it does; you just need to know *what* the call does and what
    arguments need to be passed in. On the other side, you can trust that the
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: blit() 做它应该做的事情；你只需要知道 *它* 的调用是做什么的，以及需要传入哪些参数。另一方面，你可以相信
- en: implementer(s) who wrote the blit() method have thought extensively
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现者（编写 blit() 方法的人）已经深入思考了
- en: about how to make blit() work most efficiently.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何让 blit() 高效工作。
- en: In the programming world, we often wear two hats as both the imple-
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，我们经常扮演两种角色，既是实现者，
- en: menter and the application developer, so we need to make an effort to design
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设计者和应用程序开发人员，因此我们需要努力设计
- en: APIs that not only make sense in the current situation, but also are general
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅在当前情况下有意义，而且是通用的 API，
- en: enough to be used by future programs of our own and by programs written
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 足够通用，可以供我们自己未来的程序和其他人编写的程序使用
- en: by other people. Our SimpleButton and SimpleText classes are good examples,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他人编写。我们的 SimpleButton 和 SimpleText 类是很好的例子，
- en: as they are written in a general way so that they can be reused easily. I’ll
    talk
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是以通用的方式编写的，因此可以轻松重用。我会讲解
- en: more about interface versus implementation i[n Chapter 8, w](#p192)hen we look
    at encapsulation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于接口与实现的内容[参见第8章，w](#p192)，我们将在那时探讨封装。
- en: '**Callbacks**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: When using a SimpleButton object, we handle checking for and reacting to a
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SimpleButton 对象时，我们处理检查并响应
- en: 'button click like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击事件如下：
- en: 'if oButton.handleEvent(event):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oButton.handleEvent(event):'
- en: print('The button was clicked')
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: print('按钮被点击了')
- en: Object-Oriented Pygame **137**
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **137**
- en: This approach to handling events works well with the SimpleButton class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事件处理方法适用于 SimpleButton 类。
- en: However, some other Python packages and many other programming lan-
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他一些 Python 包和许多其他编程语言
- en: 'guages handle events in a different way: with a *callback*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 语言通过不同的方式处理事件：使用 *回调函数*。
- en: '**callback**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: A function or method of an object that is cal ed when a particular action, event,
    or condition happens .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个特定的动作、事件或条件发生时，一个对象的函数或方法会被调用。
- en: An easy way to understand this is to think about the 1984 hit movie
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容易理解这个概念的方法是思考一下1984年上映的热门电影
- en: '*Ghostbusters*. The tagline for the movie is “Who you gonna call?” In the'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*幽灵捕手*。电影的标语是“你会打电话给谁？” 在'
- en: movie, the Ghostbusters ran an ad on TV that told people that if they saw
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 电影中，幽灵捕手在电视上播出了一则广告，告诉人们，如果他们看到
- en: a ghost (that’s the event to look for), they should call the Ghostbusters (the
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个幽灵（这就是需要寻找的事件），他们应该联系幽灵捕手（
- en: callback) to get rid of it. Upon receiving the call, the Ghostbusters take the
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: callback) 来摆脱它。接收到调用时，幽灵捕手会采取行动
- en: appropriate actions to eliminate the ghost.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 采取适当的行动来消除幽灵。
- en: As an example, consider a button object that is initialized to have a
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个按钮对象，它被初始化为拥有一个
- en: callback. When the user clicks the button, the button will call the callback
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数。当用户点击按钮时，按钮会调用回调函数
- en: function or method. That function or method executes whatever code is
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法。那个函数或方法执行任意代码
- en: needed to react to the button click.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 需要响应按钮点击事件。
- en: '***Creating a Cal back***'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建回调函数***'
- en: To set up a callback, when you create an object or call one of an object’s
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置回调函数，当你创建一个对象或调用一个对象的
- en: methods, you pass the name of a function or a method of an object to be
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，你传递一个函数的名称或一个对象的方法，以便执行
- en: called. As an example, there is a standard GUI package for Python called
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用。举个例子，有一个用于 Python 的标准 GUI 包，名为
- en: tkinter. The code needed to create a button with this package is very differ-
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter。使用此包创建按钮的代码非常不同，
- en: 'ent from what I have shown—here’s an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与我展示的有所不同——这是一个示例：
- en: import tkinter
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 tkinter
- en: 'def myFunction():'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myFunction():'
- en: print('myCallBackFunction was called')
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: print('myCallBackFunction 被调用了')
- en: oButton = tkinter.Button(text='Click me', command=myFunction)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = tkinter.Button(text='点击我', command=myFunction)
- en: When you create a button with tkinter, you must pass in a function (or
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 tkinter 创建按钮时，必须传入一个函数（或
- en: a method of an object), which will be called back when the user clicks the
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的方法），当用户点击按钮时，它会被调用。
- en: button. Here, we are passing myFunction as the function to be called back.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮。这里，我们将 myFunction 作为回调函数传递。
- en: (This call is using keyword parameters, which will be discussed at length
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （这个调用使用了关键字参数，我们将在后续详细讨论）
- en: in [Chapter 7.) T](#p172)he tkinter button remembers that function as the callback,
    and when the user clicks the resulting button, it calls the function
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](#p172)，tkinter按钮将该函数记住作为回调函数，当用户点击该按钮时，它会调用该函数。
- en: myFunction().
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: myFunction().
- en: You can also use a callback when you initiate some action that may
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动一些可能需要时间的操作时，你也可以使用回调。
- en: take some time. Instead of waiting for the action to finish and causing the
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些时间。与其等待操作完成并导致程序
- en: program appear to freeze for a period of time, you provide a callback to be
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 程序看起来会在一段时间内冻结，你提供一个回调函数
- en: called when the action is completed. For example, imagine that you want to
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作完成时调用。例如，假设你希望
- en: make a request across the internet. Rather than making a call and waiting
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 发出互联网请求。与其进行调用并等待
- en: for that call to return data, which may take a long time, there are packages
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个调用返回数据，可能需要一些时间，相关的包
- en: that allow you to use the approach of making the call and setting a callback.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让你使用调用并设置回调函数的方法。
- en: That way, the program can continue running, and the user is not locked
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，程序可以继续运行，用户不会被锁定
- en: '**138** Chapter 6'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**138** 第6章'
- en: out of it. This often involves multiple Python threads and is beyond the scope
    of this book, but the technique of using a callback is the general way
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从中解脱出来。这通常涉及多个 Python 线程，超出了本书的范围，但使用回调的技术是一般的方式
- en: that it is done.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它已完成。
- en: '***Using a Cal back with SimpleButton***'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用回调函数与 SimpleButton***'
- en: To demonstrate this concept, we’ll make a minor modification to the
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，我们将对
- en: SimpleButton class to allow it to accept a callback. As an additional optional
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 SimpleButton 类，使其能够接受回调函数。作为附加的可选项
- en: parameter, the caller can provide a function or method of an object to be
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 参数中，调用者可以提供一个函数或对象的方法作为回调
- en: called back when a click on a SimpleButton object happens. Each instance of
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 SimpleButton 对象时，会回调该函数。每个实例
- en: SimpleButton remembers the callback in an instance variable. When the user
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton 在实例变量中记住回调函数。当用户
- en: completes a click, the instance of SimpleButton calls the callback.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成点击后，SimpleButton 的实例调用回调函数。
- en: The main program in Listing 6-8 creates three instances of the
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-8 中的主程序创建了三个实例
- en: SimpleButton class, each of which handles the button click in a different way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton 类，每个类以不同的方式处理按钮点击。
- en: The first button, oButtonA, provides no callback; oButtonB provides a callback
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮 oButtonA 不提供回调；oButtonB 提供回调函数
- en: to a function; and oButtonC specifies a callback to a method of an object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到一个函数；oButtonC 指定一个回调，调用对象的方法。
- en: '**File: PygameDemo9_SimpleButtonWithCallback/Main_SimpleButtonCallback.py**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo9_SimpleButtonWithCallback/Main_SimpleButtonCallback.py**'
- en: pygame demo 9 - 3-button test with callbacks
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 9 - 3个按钮测试与回调函数
- en: 1 - Import packages
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: from SimpleButton import *
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleButton import *
- en: import sys
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: '#2 - Define constants'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#2 - 定义常量'
- en: GRAY = (200, 200, 200)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: GRAY = (200, 200, 200)
- en: WINDOW_WIDTH = 400
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 400
- en: WINDOW_HEIGHT = 100
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 100
- en: FRAMES_PER_SECOND = 30
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: Define a function to be used as a "callback"
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个函数，作为“回调”
- en: 'def myCallBackFunction(): 1'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myCallBackFunction(): 1'
- en: print('User pressed Button B, called myCallBackFunction')
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: print('用户按下了按钮B，调用了我的回调函数')
- en: Define a class with a method to be used as a "callback"
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个类，并为其方法指定一个“回调”函数
- en: 'class CallBackTest(): 2'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'class CallBackTest(): 2'
- en: '--- snipped any other methods in this class ---'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪切掉该类中的其他方法 ---'
- en: 'def myMethod(self):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myMethod(self):'
- en: print('User pressed ButtonC, called myMethod of the CallBackTest object')
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: print('用户按下了按钮C，调用了 CallBackTest 对象的 myMethod')
- en: 3 - Initialize the world
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图片、声音等。
- en: 5 - Initialize variables
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: Object-Oriented Pygame **139**
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **139**
- en: oCallBackTest = CallBackTest() 3
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: oCallBackTest = CallBackTest() 3
- en: Create instances of SimpleButton
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SimpleButton 的实例
- en: No call back
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无回调函数
- en: oButtonA = SimpleButton(window, (25, 30), 4
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonA = SimpleButton(window, (25, 30), 4
- en: '''images/buttonAUp.png'','
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonAUp.png'','
- en: '''images/buttonADown.png'')'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonADown.png'')'
- en: Specifying a function to call back
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个函数作为回调函数
- en: oButtonB = SimpleButton(window, (150, 30),
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonB = SimpleButton(window, (150, 30),
- en: '''images/buttonBUp.png'','
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonBUp.png'','
- en: '''images/buttonBDown.png'','
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonBDown.png'','
- en: callBack=myCallBackFunction)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: callBack=myCallBackFunction)
- en: Specifying a method of an object to call back
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个对象的方法进行回调
- en: oButtonC = SimpleButton(window, (275, 30),
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonC = SimpleButton(window, (275, 30),
- en: '''images/buttonCUp.png'','
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonCUp.png'','
- en: '''images/buttonCDown.png'','
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonCDown.png'','
- en: callBack=oCallBackTest.myMethod)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: callBack=oCallBackTest.myMethod)
- en: counter = 0
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: counter = 0
- en: 6 - Loop forever
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: Pass the event to the button, see if it has been clicked on
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事件传递给按钮，查看它是否被点击
- en: 'if oButtonA.handleEvent(event): 5'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oButtonA.handleEvent(event): 5'
- en: print('User pressed button A, handled in the main loop')
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: print('用户按下了按钮 A，已在主循环中处理')
- en: oButtonB and oButtonC have callbacks,
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: oButtonB 和 oButtonC 都有回调，
- en: no need to check result of these calls
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不需要检查这些调用的结果
- en: oButtonB.handleEvent(event) 6
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonB.handleEvent(event) 6
- en: oButtonC.handleEvent(event) 7
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonC.handleEvent(event) 7
- en: 8 - Do any "per frame" actions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”动作
- en: counter = counter + 1
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: counter = counter + 1
- en: 9 - Clear the window
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: window.fill(GRAY)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(GRAY)
- en: 10 - Draw all window elements
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: oButtonA.draw()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonA.draw()
- en: oButtonB.draw()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonB.draw()
- en: oButtonC.draw()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonC.draw()
- en: 11 - Update the window
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减缓速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 6-8: A version of the main program that handles but on clicks three
    different ways* **140** Chapter 6'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-8: 处理按钮点击的三种不同方式的主程序版本* **140** 第六章'
- en: We start with a simple function, myCallBackFunction() 1, that just prints a
    message to announce that it has been called. Next, we have a CallBackTest
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的函数 myCallBackFunction() 1 开始，它只会打印一条消息，表示它已被调用。接下来，我们有一个 CallBackTest
- en: class that contains the method myMethod() 2, which prints its own message
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 包含方法 myMethod() 的类 2，它打印自己的消息
- en: to announce that it’s been called. We create an oCallBackTest object from
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以宣布它已被调用。我们从 oCallBackTest 创建一个对象
- en: the CallBackTest class 3\. We need this object so we can set up a callback to
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: CallBackTest 类 3\. 我们需要这个对象，以便可以设置回调函数来
- en: oCallBack.myMethod().
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: oCallBack.myMethod()。
- en: Then we create three SimpleButton objects, each using a different
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建三个 SimpleButton 对象，每个对象使用不同的
- en: approach 4\. The first, oButtonA, has no callback. The second, oButtonB, sets
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 4\. 第一个，oButtonA，没有回调。第二个，oButtonB，设置
- en: its callback to the function myCallBackFunction(). The third, oButtonC, sets
    its
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将回调函数设置为 myCallBackFunction()。第三个，oButtonC，设置它的
- en: callback to oCallBack.myMethod().
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 回调到 oCallBack.myMethod()。
- en: In the main loop, we check for the user clicking on any of the three
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们检查用户是否点击了三个按钮中的任何一个
- en: buttons by calling the handleEvent() method of each button. Since oButtonA
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用每个按钮的 handleEvent() 方法来处理按钮事件。由于 oButtonA
- en: has no callback, we must check if the value returned is True 5 and, if so,
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回调函数，我们必须检查返回的值是否为 True 5，并且，如果是的话，
- en: perform an action. When oButtonB is clicked 6, the myCallBackFunction()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行某个操作。当 oButtonB 被点击时 6，myCallBackFunction()
- en: function will be called and will print its message. When oButtonC is clicked
    7,
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将被调用并打印消息。当 oButtonC 被点击时 7，
- en: the myMethod() method of the oCallBackTest object will be called and will
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: oCallBackTest 对象的 myMethod() 方法将被调用，并且
- en: print its message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打印它的消息。
- en: Some programmers prefer using a callback approach, because the tar-
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员更喜欢使用回调方法，因为目标—
- en: get to be called is set up when you create the object. It’s important to under-
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的方法是在创建对象时设置的。理解这一点非常重要—
- en: stand this technique, especially if you are using a package that requires
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种技术，特别是当你使用一个需要
- en: it. However, I will use the original approach of checking for the value
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 它。然而，我将使用原始方法来检查返回值
- en: returned by a call to handleEvent() in all my demonstration code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我所有的示范代码中，都会通过调用 handleEvent() 返回。
- en: '**Summary**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, I showed how you can start with a procedural program and
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了如何从一个过程化程序开始并
- en: extract related code to build a class. We created a Ball class to demonstrate
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 提取相关代码以构建一个类。我们创建了一个 Ball 类来演示
- en: this, then modified the main code of our demo program from the previous
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将我们的示范程序的主要代码从之前的
- en: chapter to call methods of the class to tell the Ball object *what* to do, without
    worrying about *how* it achieves the outcome. With all the related code in a separate
    class, it’s easy to create a list of objects and instantiate and manage as many
    objects as we want to.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何调用类的方法，以告诉Ball对象*做什么*，而不必担心*如何*实现结果。所有相关代码都在一个单独的类中，我们可以轻松地创建对象列表，并根据需要实例化和管理多个对象。
- en: We then built a SimpleButton class and a SimpleText class that hide com-
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们构建了一个SimpleButton类和一个SimpleText类，这些类隐藏了
- en: plexity inside their implementation and create highly reusable code. In the
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性隐藏在其实现内部，并创建高可复用的代码。在
- en: next chapter, I’ll build on these classes to develop “professional-strength”
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将基于这些类来开发“专业级”功能，
- en: button and text display classes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮和文本显示类。
- en: Finally, I introduced the concept of a callback, where you pass in a func-
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我介绍了回调的概念，在回调中传递一个函数，
- en: tion or method in a call to an object. The callback is later called back when
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在对对象的调用中传递函数或方法。回调将在事件发生或动作完成时被调用。
- en: an event happens or an action completes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发生或动作完成时。
- en: Object-Oriented Pygame **141**
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的Pygame **141**
- en: '**7**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**P Y G A M E G U I W I D G E T S**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**P Y G A M E G U I W I D G E T S**'
- en: Pygame allows programmers to take the
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame允许程序员以
- en: text-based language of Python and use it
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文本的Python语言及其应用
- en: to build GUI-based programs. Windows,
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基于GUI的程序。Windows，
- en: pointing devices, clicking, dragging, and
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 指针设备、点击、拖动等操作，
- en: sounds have all become standard parts of our expe-
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 声音已成为我们体验中所有标准部分之一。
- en: rience using computers. Unfortunately, the pygame
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算机的体验。不幸的是，pygame
- en: package doesn’t come with built-in basic user inter-
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的程序包没有内置的基本用户交互功能，
- en: face elements, so we need to build them ourselves.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 界面元素，因此我们需要自己构建它们。
- en: We’ll do so with pygwidgets, a library of GUI widgets.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用pygwidgets，这是一个GUI小部件库。
- en: This chapter explains how standard widgets such as images, buttons,
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何构建标准小部件，例如图像、按钮、
- en: and input or output fields can be built as classes and how client code uses
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 输入或输出字段可以构建为类，客户端代码如何使用它们
- en: them. Building each element as a class allows programmers to incorporate
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它们中。将每个元素构建为一个类，使程序员能够融入
- en: multiple instances of each element when creating a GUI. Before we get
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建GUI时，可以为每个元素创建多个实例。在我们继续之前，
- en: started building these GUI widgets, however, I first need to discuss one
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建这些GUI小部件之前，我需要讨论一个
- en: 'more Python feature: passing data in a call to a function or method.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Python特性：在调用函数或方法时传递数据。
- en: '**Passing Arguments into a Function or Method**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**将参数传递给函数或方法**'
- en: The arguments in a call to a function and the parameters defined in the
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时传递的参数和函数中定义的参数之间有一一对应关系，
- en: function have a one-to-one relationship, so that the value of the first argu-
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数之间有一一关系，因此第一个参数的值将
- en: ment is given to the first parameter, the value of the second argument is
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个参数提供了值，第二个参数的值将
- en: given to the second parameter, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给第二个参数的值，依此类推。
- en: Figure 7-1, duplicated fro[m Chapter 3, s](index_split_001.html#p76)hows that
    the same is true when you make a call to a method of an object. We can see that
    the first parameter, which is always self, is set to the object in the call.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1，复制自第3章，显示了当你调用一个对象的方法时，同样的规则适用。我们可以看到，第一个参数，总是self，被设置为调用中的对象。
- en: 'def someMethod(self, *<any other parameters>* ):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'def someMethod(self, *<任何其他参数>* ):'
- en: oSomeObject.someMethod( *<any other arguments>* )
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: oSomeObject.someMethod( *<任何其他参数>* )
- en: '*Figure 7-1: How arguments passed into a method match up with its parameters*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：传递到方法中的参数如何与其参数匹配*'
- en: However, Python (and some other languages) allows you to make some
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python（和一些其他语言）允许你为一些
- en: of the arguments optional. If an optional argument isn’t provided in a call,
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 的参数是可选的。如果调用中没有提供可选参数，
- en: we can provide a default value to use in the function or method instead. I’ll
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个默认值来代替函数或方法中的参数值。我会
- en: explain by means of a real-world analogy.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个现实世界的类比来解释。
- en: If you order a hamburger at a Burger King restaurant, your burger will
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Burger King餐厅点一份汉堡，你的汉堡会
- en: come with ketchup, mustard, and pickles. But Burger King is famous for
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 配有番茄酱、芥末和泡菜。但Burger King以
- en: saying, “You can have it your way.” If you want some other combination of
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式说：“你可以按自己的方式来。”如果你想要其他组合的
- en: condiments, you must say what you want (or don’t want) when you make
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 调料时，你必须在点餐时说出你想要（或不想要）什么
- en: your order.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你的顺序。
- en: We’ll start by writing an orderBurgers() function that simulates making
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个 orderBurgers() 函数开始，它模拟下订单
- en: a burger order in the regular way we’ve been defining functions, without
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们定义函数的常规方式订购汉堡，
- en: 'implementing default values:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实现默认值：
- en: 'def orderBurgers(nBurgers, ketchup, mustard, pickles):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderBurgers(nBurgers, ketchup, mustard, pickles):'
- en: You must specify the number of hamburgers you want to order, but
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须指定你想要订购的汉堡数量，但是
- en: ideally, if you want the defaults of True for adding ketchup, mustard, and
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，如果你想要添加番茄酱、芥末和酸黄瓜的默认值 True
- en: pickles, you shouldn’t need to pass in any more arguments. So, to order two
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 酸黄瓜，你不需要传递更多的参数。因此，要订购两个
- en: hamburgers with the standard defaults, you might think your call should
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准默认值订购汉堡时，你可能认为你的调用应该
- en: 'look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: 'orderBurgers(2) # with ketchup, mustard, and pickles'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderBurgers(2) # 带番茄酱、芥末和酸黄瓜'
- en: However, in Python, this will trigger an error because there is a mis-
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Python 中，这将触发一个错误，因为存在不匹配—
- en: match between the number of arguments in the call and the number of
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中的参数数量与
- en: 'parameters specified in the function:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中指定的参数：
- en: 'TypeError: orderBurgers() missing 3 required positional arguments: ''ketchup'','
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: TypeError：orderBurgers() 缺少 3 个必需的位置参数：'ketchup'，
- en: '''mustard'', and ''pickles'''
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '''芥末''，和''酸黄瓜'''
- en: Let’s see how Python allows us to set up optional parameters that can
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 如何允许我们设置可选参数，这些参数可以
- en: be given default values if nothing is specified.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定任何值，它们将被赋予默认值。
- en: '**144** Chapter 7'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**144** 第7章'
- en: '***Positional and Keyword Parameters***'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '***位置和关键字参数***'
- en: 'Python has two different types of parameters: positional parameters and'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种不同类型的参数：位置参数和
- en: keyword parameters. *Positional parameters* are the type that we’re already
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数。*位置参数*是我们已经熟悉的类型，
- en: familiar with, where each argument in a call has a matching parameter in
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的位置参数，其中调用中的每个参数都有一个对应的参数
- en: the function or method definition.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法定义。
- en: 'A *keyword parameter* allows you to specify a default value. You write a keyword
    parameter as a variable name, an equal sign, and a default value, like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*关键字参数*允许你指定一个默认值。你写一个关键字参数的方式是变量名、等号和默认值，像这样：
- en: 'def someFunction( *<keywordParameter>* = *<default value>* ): You can have
    multiple keyword parameters, each with a name and a'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'def someFunction( *<keywordParameter>* = *<default value>* ): 你可以有多个关键字参数，每个参数都有一个名称和一个'
- en: default value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值。
- en: A function or method can have both positional parameters and key-
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数或方法可以同时具有位置参数和关键字参数，
- en: word parameters, in which case you must specify all positional parameters
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数，在这种情况下，你必须在每次调用时指定所有位置参数
- en: '*before* any keyword parameters:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何关键字参数*之前*：
- en: def someOtherFunction(positionalParam1, positionalParam2, ...
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: def someOtherFunction(positionalParam1, positionalParam2, ...
- en: '*<keywordParameter1>* = *<default value 1>* ,'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*<keywordParameter1>* = *<default value 1>* ,'
- en: '*<keywordParameter2>* = *<default value 2>* , ...):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*<keywordParameter2>* = *<default value 2>* , ...):'
- en: Let’s rewrite orderBurgers() to use one positional parameter and three
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写 orderBurgers()，使用一个位置参数和三个
- en: 'keyword parameters with default values, like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 带有默认值的关键字参数，像这样：
- en: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
- en: When we make a call to this function, nBurgers is a positional parameter
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，nBurgers 是一个位置参数
- en: and therefore must be specified as an argument in every call. The other three
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，必须在每次调用时作为参数指定。其他三个
- en: are keyword parameters. If no values are passed for ketchup, mustard, and pick-
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 是关键字参数。如果没有为番茄酱、芥末和酸黄瓜传递值，
- en: les, the function will use the default value of True for each of those parameter
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，函数将对这些参数使用默认值 True
- en: 'variables. Now we can order two burgers with all the condiments like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。现在我们可以这样订购两个汉堡，附带所有调味料：
- en: orderBurgers(2)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2)
- en: If we want something other than a default value, we can specify the name
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要其他的值而不是默认值，我们可以指定名字
- en: of the keyword parameter and a different value in our call. For example, if
    we
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数和调用中的不同值。例如，如果我们
- en: 'only want ketchup on our two burgers, we can make the call this way:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在两个汉堡上加番茄酱，我们可以这样调用：
- en: orderBurgers(2, mustard=False, pickles=False)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2, mustard=False, pickles=False)
- en: When the function runs, the values of the mustard and pickles variables
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数运行时，芥末和酸黄瓜变量的值
- en: are set to False. Since we did not specify a value for ketchup, it is given
    the
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置为 False。由于我们没有为番茄酱指定值，它会被赋予
- en: default of True.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为True。
- en: You can also make the call specifying all arguments positionally, includ-
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按位置指定所有参数来进行调用，包括-
- en: ing those written as keyword parameters. Python will use the ordering of
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们写为关键字参数。Python会使用参数的顺序
- en: 'your arguments to assign each parameter the correct value:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个参数分配正确值时，你的参数是：
- en: orderBurgers(2, True, False, False)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2, True, False, False)
- en: In this call, we are again specifying two burgers with ketchup, no mus-
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用中，我们再次指定了两个加番茄酱的汉堡，没有芥末-
- en: tard, and no pickles.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 无腌黄瓜且无芥末。
- en: Pygame GUI Widgets **145**
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **145**
- en: '***Additional Notes on Keyword Parameters***'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '***关于关键字参数的额外说明***'
- en: Let’s quickly go over a few conventions and tips for using keyword param-
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一些关于使用关键字参数的约定和技巧-
- en: eters. As a Python convention, when you use keyword parameters and key-
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。作为 Python 约定，当你使用关键字参数和关键字参数时-
- en: words with arguments, the equal sign between the keyword and the value
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 带有参数的关键字和值之间的等号
- en: 'should *not* have spaces around it, to show that these are not typical assignment
    statements. These lines are properly formatted:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 不应*有*空格，以表明这些不是典型的赋值语句。这些行格式正确：
- en: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):'
- en: orderBurgers(2, mustard=False)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2, mustard=False)
- en: These lines will also work fine, but they don’t follow the formatting con-
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行也能正常工作，但它们不符合格式约定-
- en: 'vention and are less readable:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 约定且可读性较差：
- en: 'def orderBurgers(nBurgers, ketchup = True, mustard = True, pickles = True):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderBurgers(nBurgers, ketchup = True, mustard = True, pickles = True):'
- en: orderBurgers(2, mustard = False)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers(2, mustard = False)
- en: When calling a function that has both positional parameters and key-
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个同时包含位置参数和关键字参数的函数时-
- en: word parameters, you must provide values for all the positional parameters
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数中，你必须为所有位置参数提供值。
- en: first, before any optional keyword parameters.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在任何可选的关键字参数之前。
- en: Keyword arguments in calls can be specified in any order. Calls to our
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中的关键字参数可以以任何顺序指定。我们对关键字参数的调用
- en: 'orderBurgers() function could be made in various ways, such as:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: orderBurgers()函数可以通过多种方式实现，例如：
- en: 'orderBurgers(2, mustard=False, pickles=False) # only ketchup'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderBurgers(2, mustard=False, pickles=False) # 只有番茄酱'
- en: 'or:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: 'orderBurgers(2, pickles=False, mustard=False, ketchup=False) # plain'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderBurgers(2, pickles=False, mustard=False, ketchup=False) # 普通汉堡'
- en: All keyword parameters will be given the appropriate values, indepen-
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关键字参数都会被赋予适当的值，独立地
- en: dent of the order of the arguments.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 参数顺序的独立性。
- en: While all the default values in the orderBurgers() example were Boolean
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 orderBurgers() 示例中的所有默认值都是布尔类型
- en: values, a keyword parameter can have a default value of any data type. For
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 值，一个关键字参数可以具有任何数据类型的默认值。例如，
- en: example, we could write a function to allow a customer to make an ice
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以写一个函数，允许顾客点冰淇淋
- en: 'cream order like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式点冰激凌：
- en: 'def orderIceCream(flavor, nScoops=1, coneOrCup=''cone'', sprinkles=False):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderIceCream(flavor, nScoops=1, coneOrCup=''cone'', sprinkles=False):'
- en: The caller must specify a flavor, but by default will get one scoop in a
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者必须指定口味，但默认情况下会得到一球‘regular’。
- en: cone with no sprinkles. The caller could override these defaults with differ-
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: cone，没有洒糖。调用者可以通过不同的方式覆盖这些默认值-
- en: ent keyword values.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 其他关键字值。
- en: '***Using None as a Default Value***'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用 None 作为默认值***'
- en: It’s sometimes helpful to know whether the caller passed in a value for a
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，知道调用者是否为某个参数传递了值是很有帮助的
- en: keyword parameter or not. For this example, the caller orders a pizza. At
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用关键字参数。举个例子，调用者点了一份比萨饼。在
- en: a minimum, the caller must specify a size. The second parameter will be a
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，调用者必须指定一个大小。第二个参数将是
- en: style that defaults to 'regular' but could be 'deepdish'. As a third parameter,
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 样式默认为“regular”，但可以是“deepdish”。作为第三个参数，
- en: '**146** Chapter 7'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**146** 第7章'
- en: the caller can optionally pass in a single desired topping. If the caller wants
    a topping, we must charge them extra.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以选择性地传递一个想要的配料。如果调用者想要配料，我们必须额外收费。
- en: In Listing 7-1, we’ll use a positional parameter for the size and key-
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7-1中，我们将为大小使用一个位置参数和关键字参数-
- en: word parameters for the style and topping. The default for style is the string
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 对样式和配料使用关键字参数。样式的默认值是字符串
- en: '''regular''. Since the topping choice is optional, we’ll use the special Python'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配料是可选的，我们将使用特殊的 Python
- en: value of None as the default, but the caller may pass in the topping of their
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: None值作为默认值，但调用者可以传递他们想要的配料
- en: choice.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 选择。
- en: '**File: OrderPizzaWithNone.py**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：OrderPizzaWithNone.py**'
- en: 'def orderPizza(size, style=''regular'', topping=None):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'def orderPizza(size, style=''regular'', topping=None):'
- en: Do some calculations based on the size and style
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据大小和风格进行一些计算
- en: Check if a topping was specified
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否指定了配料
- en: 'PRICE_OF_TOPPING = 1.50 # price for any topping'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'PRICE_OF_TOPPING = 1.50 # 每种配料的价格'
- en: 'if size == ''small'':'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'if size == ''small'':'
- en: price = 10.00
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: price = 10.00
- en: 'elif size == ''medium'':'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif size == ''medium'':'
- en: price = 14.00
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: price = 14.00
- en: 'else: # large'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'else: # 大号'
- en: price = 18.00
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: price = 18.00
- en: 'if style == ''deepdish'':'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 'if style == ''deepdish'':'
- en: 'price = price + 2.00 # charge extra for deepdish'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'price = price + 2.00 # 对深盘收取额外费用'
- en: line = 'You have ordered a ' + size + ' ' + style + ' pizza with '
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: line = '你订购了一个 ' + size + ' ' + style + ' 比萨，上面有 '
- en: '1 if topping is None: # check if no topping was passed in'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '1 if topping is None: # 检查是否没有传入配料'
- en: print(line + 'no topping')
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: print(line + '没有配料')
- en: 'else:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print(line + topping)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: print(line + topping)
- en: price = price + PRICE_OF_TOPPING
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: price = price + PRICE_OF_TOPPING
- en: print('The price is $', price)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: print('价格是 $', price)
- en: print()
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: 'You could order a pizza in the following ways:'
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以通过以下几种方式订购比萨：
- en: '2 orderPizza(''large'') # large, defaults to regular, no topping'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '2 orderPizza(''large'') # 大号，默认为常规，没有配料'
- en: 'orderPizza(''large'', style=''regular'') # same as above'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderPizza(''large'', style=''regular'') # 与上面相同'
- en: 3 orderPizza('medium', style='deepdish', topping='mushrooms')
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 3 orderPizza('medium', style='deepdish', topping='mushrooms')
- en: 'orderPizza(''small'', topping=''mushrooms'') # style defaults to regular'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'orderPizza(''small'', topping=''mushrooms'') # 风格默认为常规'
- en: '*Listing 7-1: A function with a keyword parameter defaulting to None*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：带有默认值为 None 的关键字参数的函数*'
- en: The first and second calls would be seen as the same, with the value of
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个调用会被视为相同，topping 的值为
- en: the variable topping set to None 2\. In the third and fourth calls, the value
    of
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 topping 设置为 None 2\. 在第三和第四个调用中，topping 的值为
- en: topping is set to 'mushrooms' 3\. Because 'mushrooms' is not None, in these
    calls
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: topping 设置为 'mushrooms' 3\. 因为 'mushrooms' 不是 None，在这些调用中
- en: the code would add in an extra charge for a topping on the pizzas 1\.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 代码会为比萨上的配料添加额外费用 1\。
- en: Using None as a default value for a keyword parameter gives you a way to
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 None 作为关键字参数的默认值为你提供了一种方法来
- en: see if the caller provided a value in the call. This may be a very subtle use
    of
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 查看调用者是否在调用中提供了值。这可能是非常微妙的用法
- en: keyword parameters, but it will be very useful in our upcoming discussion.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数，但它将在我们接下来的讨论中非常有用。
- en: Pygame GUI Widgets **147**
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **147**
- en: '***Choosing Keywords and Default Values***'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '***选择关键字和默认值***'
- en: Using default values makes calling functions and methods simpler, but
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认值使调用函数和方法变得更简单，但
- en: there is a downside. Your choice of each keyword for keyword parameters
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这存在一个缺点。你为关键字参数选择的每个关键字
- en: is very important. Once programmers start making calls that override
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要。一旦程序员开始调用覆盖默认值的函数，
- en: default values, it’s very difficult to change the name of a keyword parameter
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值时，改变关键字参数的名称就变得非常困难
- en: because that name must be changed in *all* calls to the function or method
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该名称必须在*所有*对函数或方法的调用中都进行更改
- en: in lockstep. Otherwise, code that was working will break. For more widely
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 同步进行。否则，原本正常运行的代码将会崩溃。更多广泛
- en: distributed code, this can potentially cause a great deal of pain to program-
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式代码，这可能会给程序员带来很大的麻烦——
- en: mers using your code. Bottom line, don’t change the name of a keyword
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你代码的程序员。最重要的是，不要改变关键字的名称
- en: parameter unless it is absolutely necessary. So, choose wisely!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 除非绝对必要，否则不要更改关键字参数的名称。所以，明智地选择！
- en: It’s also very important to use default values that should suit the widest
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，选择适合最大范围用户的默认值也非常重要
- en: possible range of users. (On a personal note, I *hate* mustard! Whenever I go
    to Burger King, I have to remember to specify no mustard or I’ll get what I consider
    to be an inedible hamburger. I think they made a bad default choice.)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 可能适合更广泛用户范围的（顺便说一句，我*讨厌*芥末！每次去汉堡王时，我都得记得指定不加芥末，否则我会得到我认为无法吃的汉堡。我觉得他们做出了一个糟糕的默认选择。）
- en: '***Default Values in GUI Widgets***'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '***GUI 小部件中的默认值***'
- en: In the next section, I’ll present a collection of classes that you can use to
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将展示一系列类，你可以用来
- en: easily create GUI elements such as buttons and text fields within pygame.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松在 pygame 中创建按钮和文本字段等 GUI 元素。
- en: These classes will each be initialized using a few positional parameters but
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类将通过使用一些位置参数来初始化
- en: will also have assorted optional keyword parameters, all with reasonable
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 还将包含各种可选的关键字参数，所有这些参数都有合理的
- en: defaults to allow programmers to create GUI widgets by specifying only a
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为让程序员通过仅指定一个来创建 GUI 小部件
- en: few positional arguments. More precise control can be obtained by specify-
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 少数位置参数。通过指定更精确的控制可以获得更多的控制，
- en: ing values to overwrite the default values of keyword parameters.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 为关键字参数的默认值提供新的值。
- en: For an in-depth example, we’ll look at a widget to display text in the
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一个深入的例子，我们将看一个用于显示文本的小部件
- en: application’s window. Text can be shown in a variety of fonts, font sizes, col-
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序窗口。文本可以以各种字体、字体大小、颜色、背景色等形式显示。我们将构建一个 DisplayText 类来展示这一点。
- en: ors, background colors, and so on. We’ll build a DisplayText class that will
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 字体、背景色等方面。我们将构建一个 DisplayText 类来展示这一点。
- en: have default values for all of these attributes but will give client code the
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性有默认值，但会给客户端代码提供
- en: option of specifying different values.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 指定不同值的选项。
- en: '**The pygwidgets Package**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**pygwidgets 包**'
- en: The rest of this chapter will focus on the pygwidgets (pronounced “pig
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余内容将聚焦于 pygwidgets（发音为“pig widgets”）包
- en: 'wijits”) package, which was written with two goals in mind:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: wijits”) 包，该包的编写目标是：
- en: 1\. To demonstrate many different object-oriented programming techniques
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 展示多种不同的面向对象编程技术
- en: 2\. To allow programmers to easily create and use GUI widgets in pygame
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 让程序员可以轻松创建和使用 pygame 中的 GUI 小部件
- en: programs
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 程序
- en: 'The pygwidgets package contains the following classes:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包包含以下类：
- en: '**TextButton**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextButton**'
- en: Button built with standard art, using a text string
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本字符串构建的标准艺术按钮
- en: '**CustomButton**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**CustomButton**'
- en: Button with custom artwork
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义艺术作品的按钮
- en: '**148** Chapter 7'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**148** 第7章'
- en: '**TextCheckBox**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextCheckBox**'
- en: Checkbox with standard art, built from a text string
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本字符串构建的标准艺术复选框
- en: '**CustomCheckBox**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**CustomCheckBox**'
- en: Checkbox with custom artwork
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义艺术作品的复选框
- en: '**TextRadioButton**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextRadioButton**'
- en: Radio buttons with standard art, built from a text string
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本字符串构建的标准艺术单选按钮
- en: '**CustomRadioButton**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**CustomRadioButton**'
- en: Radio buttons with custom artwork
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自定义艺术作品的单选按钮
- en: '**DisplayText**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**DisplayText**'
- en: Field used to display output text
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示输出文本的字段
- en: '**InputText**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**InputText**'
- en: Field where the user can type text
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以输入文本的字段
- en: '**Dragger**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dragger**'
- en: Allows the user to drag an image
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户拖动图像
- en: '**Image**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像**'
- en: Displays an image at a location
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定位置显示图像
- en: '**ImageCollection**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**ImageCollection**'
- en: Displays one of a collection of images at a location
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定位置显示一张图片
- en: '**Animation**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画**'
- en: Displays a sequence of images
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一系列图像
- en: '**SpriteSheetAnimation**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpriteSheetAnimation**'
- en: Displays a sequence of images from a single larger image
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个较大图像中显示一系列图像
- en: '***Setting Up***'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '***设置***'
- en: 'To install pygwidgets, open the command line and enter the following:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 pygwidgets，请打开命令行并输入以下内容：
- en: python3 -m pip install -U pip --user
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pip --user
- en: python3 -m pip install -U pygwidgets --user
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pygwidgets --user
- en: These commands download and install the latest version of pygwidgets
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令下载并安装最新版本的 pygwidgets
- en: from the Python Package Index (PyPI). It is placed into a folder (named
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 包索引（PyPI）下载。它被放置在一个文件夹中（命名为
- en: '*site-packages*) that is available to all your Python programs. Once installed,
    you can use pygwidgets by including the following statement at the beginning of
    your programs:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*site-packages*)，它对所有 Python 程序可用。安装后，你可以通过在程序开始部分包括以下语句来使用 pygwidgets：'
- en: import pygwidgets
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygwidgets
- en: This imports the entire package. After importing, you can instantiate
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入整个包。导入后，你可以实例化
- en: objects from its classes and call the methods of those objects.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 从其类中创建对象并调用这些对象的方法。
- en: Pygame GUI Widgets **149**
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **149**
- en: The most current documentation of pygwidgets is a[t *https://pygwidgets*](https://pygwidgets.readthedocs.io/en/latest/)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 的最新文档可以在 [*https://pygwidgets*](https://pygwidgets.readthedocs.io/en/latest/)
    找到
- en: '[*.readthedocs.io/en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).
    If you’d like to view the source code for the package, it’s available via my GitHub
    repository at [*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[*.readthedocs.io/en/latest/*](https://pygwidgets.readthedocs.io/en/latest/)。如果你想查看该包的源代码，可以通过我的
    GitHub 仓库访问，链接在这里：[*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)'
- en: '***Overall Design Approach***'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '***总体设计方法***'
- en: As shown i[n Chapter 5, o](index_split_002.html#p118)ne of the first things
    you do in every pygame program is to define the window of the application. The
    following line creates
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如第5章所示，在每个 pygame 程序中你首先要做的事情之一就是定义应用程序的窗口。以下一行创建了
- en: 'an application window and saves a reference to it in a variable named window:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序窗口并将其引用保存在名为 window 的变量中：
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: As we will soon see, whenever we instantiate any widget, we will need to
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快会看到的，每当我们实例化一个小部件时，我们都需要
- en: pass in the window variable so the widget can draw itself in the application’s
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 将窗口变量传递给小部件，以便小部件可以在应用程序的
- en: window.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。
- en: Most widgets in pygwidgets work in a similar way, typically involving
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 中的大多数小部件工作方式类似，通常涉及
- en: 'these three steps:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这三步如下：
- en: 1\. Before the main while loop starts, create an instance of the widget, pass-
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在主 while 循环开始之前，创建一个小部件实例，传入
- en: ing in any initialization arguments.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何初始化参数中。
- en: 2\. In the main loop, whenever any event happens, call the handleEvent()
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 在主循环中，每当发生任何事件时，调用 handleEvent()
- en: method of the widget (passing in the event object).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的 handleEvent() 方法（传入事件对象）。
- en: 3\. At the bottom of the main loop, call the draw() method of the widget.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在主循环底部，调用小部件的 draw() 方法。
- en: 'Step 1 in using any widget is to instantiate one with a line like this:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何小部件的第一步是通过以下代码实例化一个：
- en: oWidget = pygwidgets. *<SomeWidgetClass>* (window, loc, *<other arguments as
    needed>* ) The first argument is always the window of the application. The second
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: oWidget = pygwidgets. *<SomeWidgetClass>* (window, loc, *<其他需要的参数>* ) 第一个参数始终是应用程序的窗口。第二个
- en: argument is always the location in the window at which to display the wid-
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 参数始终是小部件显示在窗口中的位置。
- en: 'get, given as a tuple: (x, y).'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的事件是一个元组：(x, y)。
- en: Step 2 is to handle any event that could affect the widget by calling the
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步是通过调用 handleEvent() 处理任何可能影响小部件的事件
- en: object’s handleEvent() method inside the event loop. If any event (like a mouse
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的 handleEvent() 方法位于事件循环中。如果任何事件（如鼠标
- en: click or button press) happens and the widget handles the event, this call will
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生点击或按键事件，并且小部件处理该事件，则此调用将
- en: 'return True. The code at the top of the main while loop generally looks like
    this:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True。主 while 循环顶部的代码通常看起来像这样：
- en: 'while True:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oWidget.handleEvent(event):'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oWidget.handleEvent(event):'
- en: The user has done something to oWidget that we should respond to
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户对 oWidget 做了某些事情，我们应该对此做出响应
- en: Add code here
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在此处添加代码
- en: Step 3 is to add a line near the bottom of the while loop to call the
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步是在 while 循环的底部添加一行，调用
- en: 'draw() method of the widget, to make it appear it in the window:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的 draw() 方法，以使其在窗口中显示：
- en: oWidget.draw()
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: oWidget.draw()
- en: '**150** Chapter 7'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**第150章 第七章**'
- en: Since we specified the window to draw into, the location, and any
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了要绘制的窗口、位置以及任何
- en: details that affect the appearance of the widget in step 1, we don’t pass any-
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中影响小部件外观的详细信息，我们没有传递任何
- en: thing in the call to draw().
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 draw() 时，您可以处理绘制过程中的任何问题。
- en: '***Adding an Image***'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '***添加图像***'
- en: 'Our first example will be the simplest widget: we’ll use the Image class to
    dis-'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例将是最简单的小部件：我们将使用 Image 类显示
- en: play an image in a window. When you instantiate an Image object, the only
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中显示图像。当您实例化一个图像对象时，唯一需要提供的
- en: required arguments are the window, the location in the window to draw
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的参数是窗口，以及要在窗口中绘制的位置
- en: the image, and the path to the image file. Create the Image object before the
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图像及其文件路径。创建图像对象应在
- en: 'main loop starts, like so:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环开始时，如下所示：
- en: oImage = pygwidgets.Image(window, (100, 200), 'images/SomeImage.png')
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: oImage = pygwidgets.Image(window, (100, 200), 'images/SomeImage.png')
- en: The path used here assumes that the project folder containing the
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的路径假定项目文件夹中包含
- en: main program also contains a folder named *images*, inside which is the
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序还包含一个名为 *images* 的文件夹，其中包含
- en: '*SomeImage.png* file. Then, in the main loop you just need to call the object’s
    draw() method:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*SomeImage.png* 文件。然后，在主循环中，您只需调用该对象的 draw() 方法：'
- en: oImage.draw()
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: oImage.draw()
- en: The draw() method of the Image class contains a call to blit() to actu-
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Image 类的 draw() 方法包含一个调用 blit() 来实际
- en: ally draw the image, so you never need to call blit() directly. To move the
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绘制图像，因此您无需直接调用 blit()。要移动图像，
- en: image, you can call its setLoc() method (short for set location), specifying
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 图像时，您可以调用它的 setLoc() 方法（简写为设置位置），指定
- en: 'the new x- and y-coordinates as a tuple:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 作为元组传入新的 x 和 y 坐标：
- en: oImage.setLoc((newX, newY))
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: oImage.setLoc((newX, newY))
- en: The next time the image is drawn, it will show up at the new coordi-
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次绘制图像时，它将显示在新的坐标位置。
- en: nates. The documentation lists many additional methods that you can call
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标。文档列出了您可以调用的许多附加方法
- en: to flip, rotate, scale, get the image’s location and rectangle, and so on.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转、旋转、缩放，获取图像的位置和矩形，等等。
- en: '**THE SPRITE MODULE**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵模块**'
- en: Pygame has a built-in module to show images in a window, cal ed the *sprite*
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame有一个内置模块可以在窗口中显示图像，称为*精灵*。
- en: '*module* . Such images are cal ed *sprites* . The sprite module provides a
    Sprite class for handling individual sprites and a Group class for handling multiple'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块*。这种图像被称为*精灵*。精灵模块提供了一个Sprite类来处理单个精灵和一个Group类来处理多个精灵。'
- en: Sprite objects . Together, these classes provide excel ent functionality, and
    if
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite对象。一起，这些类提供了出色的功能，如果
- en: you intend to do heavy-duty pygame programming, it is probably worth your
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算进行大量的pygame编程，可能值得您的时间来深入了解它们。不过，为了说明底层的面向对象编程概念，
- en: time to look into them . However, in order to explain the underlying OOP con-
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候深入了解它们了。然而，为了说明底层的OOP概念，
- en: cepts, I have chosen not to use those classes . Instead, I will proceed with
    gen-
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上，我选择不使用这些类。相反，我将继续使用生成类。
- en: eral GUI elements so that they can be used in any environment and language .
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 一般GUI元素，以便它们可以在任何环境和语言中使用。
- en: If you want to learn more about the sprite module, see the tutorial a[t *ht
    ps://*](https://www.pygame.org/docs/tut/SpriteIntro.html)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于精灵模块的信息，请参阅教程 [*https://*](https://www.pygame.org/docs/tut/SpriteIntro.html)
- en: '[*www.pygame.org/docs/tut/SpriteIntro.html* .](https://www.pygame.org/docs/tut/SpriteIntro.html)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[*www.pygame.org/docs/tut/SpriteIntro.html*](https://www.pygame.org/docs/tut/SpriteIntro.html)'
- en: Pygame GUI Widgets **151**
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI小部件 **151**
- en: '***Adding Buttons, Checkboxes, and Radio Buttons***'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '***添加按钮、复选框和单选按钮***'
- en: When you instantiate a button, checkbox, or radio button widget in pygwidgets,
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在pygwidgets中实例化按钮、复选框或单选按钮小部件时，
- en: 'you have two options: instantiate a text version that draws its own art and'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个选项：实例化一个文本版本，该版本绘制自己的艺术图像，或者
- en: adds a text label based on a string you pass in, or instantiate a custom ver-
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个基于您传递字符串的文本标签，或者实例化一个自定义版本
- en: sion where you supply the art. Table 7-1 shows the different button classes
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 版本，您提供艺术作品的位置。表7-1显示了不同的按钮类。
- en: that are available.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的。
- en: '**Table 7-1:** Text and Custom Button Classes in pygwidgets'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** pygwidgets中的文本和自定义按钮类。'
- en: '**Text version (builds art on**'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本版本（在飞行中构建艺术作品）**'
- en: '**Custom version (uses**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义版本（使用飞行中的艺术作品）**'
- en: '**the fly)**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**（即时创建）**'
- en: '**your artwork)**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**您的艺术作品)**'
- en: Button
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮
- en: TextButton
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: TextButton
- en: CustomButton
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton
- en: Checkbox
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框
- en: TextCheckBox
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: TextCheckBox
- en: CustomCheckBox
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: CustomCheckBox
- en: Radio button
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮
- en: TextRadioButton
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: TextRadioButton
- en: CustomRadioButton
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: CustomRadioButton
- en: The differences between the text and custom versions of these classes
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的文本和自定义版本之间的差异。
- en: are only relevant during instantiation. Once you create an object from
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在实例化时相关。一旦您从
- en: a text or custom button class, all the remaining methods of the pair of
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 文本或自定义按钮类，所有剩余方法对这一对
- en: classes are identical. To make this clear, let’s take a look at the TextButton
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类是相同的。为了明确这一点，我们来看看TextButton
- en: and CustomButton classes.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 和CustomButton类。
- en: '**TextButtons**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextButtons**'
- en: Here is the actual definition of the __init__() method of the TextButton class
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这是TextButton类的__init__()方法的实际定义。
- en: 'in pygwidgets:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在pygwidgets中：
- en: def __init__(self, window, loc, text,
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, window, loc, text,
- en: width=None,
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: width=None,
- en: height=40,
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: height=40,
- en: textColor=PYGWIDGETS_BLACK,
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=PYGWIDGETS_BLACK,
- en: upColor=PYGWIDGETS_NORMAL_GRAY,
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: upColor=PYGWIDGETS_NORMAL_GRAY,
- en: overColor=PYGWIDGETS_OVER_GRAY,
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: overColor=PYGWIDGETS_OVER_GRAY,
- en: downColor=PYGWIDGETS_DOWN_GRAY,
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: downColor=PYGWIDGETS_DOWN_GRAY,
- en: fontName=DEFAULT_FONT_NAME,
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: fontName=DEFAULT_FONT_NAME,
- en: fontSize=DEFAULT_FONT_SIZE,
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=DEFAULT_FONT_SIZE,
- en: soundOnClick=None,
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: soundOnClick=None,
- en: enterToActivate=False,
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: enterToActivate=False,
- en: callback=None
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: callback=None
- en: 'nickname=None):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 'nickname=None):'
- en: However, rather than reading through the code of a class, a programmer
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其阅读类的代码，程序员
- en: will typically refer to its documentation. As mentioned earlier, you can find
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会参考其文档。如前所述，您可以找到
- en: the complete documentation for pygwidgets at [*https://pygwidgets.readthedocs.io/*](https://pygwidgets.readthedocs.io/en/latest/)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets的完整文档可以在[*https://pygwidgets.readthedocs.io/*](https://pygwidgets.readthedocs.io/en/latest/)查看。
- en: '[*en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '[*en/latest/*](https://pygwidgets.readthedocs.io/en/latest/).'
- en: You can also view documentation of a class by calling the built-in help()
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过调用内置的help()函数来查看类的文档。
- en: 'function in the Python shell like so:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python shell中可以这样调用函数：
- en: '>>> help(pygwidgets.TextButton)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> help(pygwidgets.TextButton)'
- en: '**152** Chapter 7'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**152** 第7章'
- en: '![Image 24](index-182_1.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![图片 24](index-182_1.png)'
- en: '![Image 25](index-182_2.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![图片 25](index-182_2.png)'
- en: When you create an instance of a TextButton, you are only required to pass
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个TextButton的实例时，您只需要传递
- en: in the window, the location in the window, and the text to be shown on the
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中，窗口中的位置，以及要显示的文本。
- en: button. If you only specify these positional parameters, your button will use
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: button。如果你只指定这些位置参数，按钮将使用
- en: reasonable defaults for the width and height, the background colors for the
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的默认值包括宽度和高度、背景颜色等
- en: four states of the button (different shades of gray), the font, and the font
    size.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的四种状态（不同的灰色阴影）、字体和字体大小。
- en: By default, no sound effect will be played when the user clicks on the button.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当用户点击按钮时不会播放任何声音效果。
- en: 'The code to create a TextButton using all the defaults looks like this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个使用所有默认设置的 TextButton 的代码如下：
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = pygwidgets.TextButton(window, (50, 50), '文本按钮')
- en: The code in the __init__() method of the TextButton class uses the
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: TextButton 类的 __init__() 方法中的代码使用了
- en: pygame drawing methods to construct its own art for all four states (up,
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: pygame 绘图方法用于构建其所有四种状态的艺术图像（上、
- en: down, over, and disabled). The preceding line creates an “up” version of a
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 按下、悬停和禁用）。前一行创建了一个“up”版本的
- en: button that looks like Figure 7-2\.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像图 7-2 的按钮。
- en: '*Figure 7-2: A TextButton*'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：一个文本按钮*'
- en: '*using defaults*'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用默认值*'
- en: You can override any or all of the default parameters with keyword val-
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字值重写任何或所有默认参数。
- en: 'ues like so:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式如下：
- en: oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button',
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: oButton = pygwidgets.TextButton(window, (50, 50), '文本按钮',
- en: width=200,
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: width=200,
- en: height=30,
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: height=30,
- en: textColor=(255, 255, 128),
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=(255, 255, 128),
- en: upColor=(128, 0, 0),
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: upColor=(128, 0, 0),
- en: fontName='Courier',
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: fontName='Courier',
- en: fontSize=14,
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=14,
- en: soundOnClick='sounds/blip.wav',
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: soundOnClick='sounds/blip.wav',
- en: enterToActivate=True)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: enterToActivate=True)
- en: This instantiation will create a button that looks like Figure 7-3\.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例化将创建一个像图 7-3 所示的按钮\。
- en: '*Figure 7-3: A TextButton using keyword*'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：一个使用关键字的文本按钮*'
- en: '*arguments for font, size, colors, and so on*'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '*字体、大小、颜色等参数*'
- en: The image-switching behavior of these two buttons would work exactly
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个按钮的图像切换行为会完全相同
- en: the same way; the only differences would be in the appearance of the images.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方式；唯一的区别在于图像的外观。
- en: '**CustomButtons**'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义按钮**'
- en: The CustomButton class allows you to use your own art for a button. To instan-
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: CustomButton 类允许你使用自己的艺术作品来制作按钮。要实例化一个
- en: tiate a CustomButton, you need only pass in a window, a location, and a path
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个 CustomButton，你只需要传入一个窗口、一个位置和一个路径
- en: 'to the image of the up state of the button. Here is an example:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 到按钮的 up 状态图像。这里是一个示例：
- en: restartButton = pygwidgets.CustomButton(window, (100, 430),
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: restartButton = pygwidgets.CustomButton(window, (100, 430),
- en: '''images/RestartButtonUp.png'')'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/RestartButtonUp.png'')'
- en: Pygame GUI Widgets **153**
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **153**
- en: The down, over, and disabled states are optional keyword arguments, and for
    any of these where no value is passed in, CustomButton will use a copy of
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的按下、悬停和禁用状态是可选的关键字参数，对于这些没有传值的状态，CustomButton 将使用
- en: the up image. It’s more typical (and strongly suggested) to pass in paths for
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: up 图像。更典型（且强烈建议）的是传入图像路径，
- en: 'the optional images, like so:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的图像，如下所示：
- en: restartButton = pygwidgets.CustomButton(window, (100, 430),
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: restartButton = pygwidgets.CustomButton(window, (100, 430),
- en: '''images/RestartButtonUp.png'','
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/RestartButtonUp.png'','
- en: down='images/RestartButtonDown.png',
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: down='images/RestartButtonDown.png',
- en: over='images/RestartButtonOver.png',
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: over='images/RestartButtonOver.png',
- en: disabled='images/RestartButtonDisabled.png',
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: disabled='images/RestartButtonDisabled.png',
- en: soundOnClick='sounds/blip.wav',
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: soundOnClick='sounds/blip.wav',
- en: nickname='restart')
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: nickname='restart')
- en: Here we also specified a sound effect that should be played when
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们还指定了一个声音效果，应该在
- en: the user clicks the button, and we provided an internal nickname we can
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击按钮时播放该声音效果，并提供一个内部的昵称供我们
- en: use later.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后使用。
- en: '**Using Buttons**'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用按钮**'
- en: After instantiation, here’s some typical code to use a button object, oButton,
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化后，这里是一些典型的代码来使用按钮对象 oButton，
- en: 'independent of it being a TextButton or a CustomButton:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 TextButton 还是 CustomButton，都是独立的：
- en: 'while True:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oButton.handleEvent(event):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 'if oButton.handleEvent(event):'
- en: User has clicked this button
  id: totrans-706
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户点击了这个按钮
- en: '*<Any code you want to run here when the button is clicked>*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*<你想在按钮点击时运行的任何代码>*'
- en: '--- snip ---'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截断 ---'
- en: 'oButton.draw() # at the bottom of the while loop, tell it to draw'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 'oButton.draw() # 在 while 循环的底部，告诉它绘制'
- en: Every time we detect an event, we need to call the handleEvent() method
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们检测到一个事件时，都需要调用 handleEvent() 方法
- en: of the button to allow it to react to the user’s actions. This call normally
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 允许按钮根据用户的操作作出反应。这个调用通常
- en: returns False but will return True when the user completes a click on the
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False，但当用户完成点击时返回 True
- en: button. At the bottom of the main while loop, we need to call the draw()
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮。在主循环的底部，我们需要调用 draw()
- en: method of the button to allow it to draw itself.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的 method 方法允许它绘制自己。
- en: '***Text Output and Input***'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '***文本输出和输入***'
- en: As we saw in [Chapter 6, h](index_split_002.html#p150)andling text input and
    output in pygame is tricky, but here I’ll introduce new classes for a text display
    field and an input text
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第六章，h](index_split_002.html#p150)中所见，处理文本输入和输出在 pygame 中是棘手的，但在这里我将介绍用于文本显示字段和输入文本的新类
- en: field. Both of these classes have minimal required (positional) parameters,
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 字段。这两个类都有最小的必需（位置）参数，
- en: and they have reasonable defaults for other attributes (font, font size,
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 它们对其他属性（如字体、字体大小、颜色等）有合理的默认值，
- en: color, and so on) that are easily overridden.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色等）这些都可以轻松覆盖。
- en: '**Text Output**'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本输出**'
- en: The pygwidgets package contains a DisplayText class for showing text that is
    a
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 包含一个 DisplayText 类，用于显示文本，这是一个
- en: more full-featured version of the SimpleText class fro[m Chapter 6](index_split_002.html#p150).
    When you **154** Chapter 7
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 更完整版本的 SimpleText 类来自[第六章](index_split_002.html#p150)。当你**154** 第七章
- en: instantiate a DisplayText field, the only required arguments are the window
    and the location. The first keyword parameter is value, which may be specified
    with a string as starting text to be shown in the field. This is typically
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个 DisplayText 字段时，唯一必需的参数是窗口和位置。第一个关键字参数是 value，它可以通过字符串指定作为显示在字段中的起始文本。这通常是
- en: used for a default end user value or for text that never changes, like a label
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 用于默认的最终用户值或从不改变的文本，如标签
- en: or instructions. Since value is the first keyword parameter, it can be given
    as
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 或说明。由于 value 是第一个关键字参数，它可以作为
- en: 'either a positional or a keyword argument. For example, this:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是位置参数还是关键字参数。例如，这个：
- en: oTextField = pygwidgets.DisplayText(window, (10, 400), 'Hello World')
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField = pygwidgets.DisplayText(window, (10, 400), 'Hello World')
- en: 'will work the same way as this:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 将与此相同地工作：
- en: oTextField = pygwidgets.DisplayText(window, (10, 400), value='Hello World')
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField = pygwidgets.DisplayText(window, (10, 400), value='Hello World')
- en: You can also customize the look of the output text by specifying any or
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过指定任意或
- en: 'all of the optional keyword parameters. For example:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可选的关键字参数。例如：
- en: oTextField = pygwidgets.DisplayText(window, (10, 400),
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField = pygwidgets.DisplayText(window, (10, 400)，
- en: value='Some title text',
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: value='一些标题文本'，
- en: fontName='Courier',
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: fontName='Courier'，
- en: fontSize=40,
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=40，
- en: width=150,
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: width=150，
- en: justified='center',
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: justified='center'，
- en: textColor=(255, 255, 0))
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=(255, 255, 0))
- en: The DisplayText class has a number of additional methods, the most
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: DisplayText 类有许多额外的方法，其中最
- en: important of which is setValue(), which you call to change the text drawn
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是 setValue()，你可以调用它来更改绘制的文本
- en: 'in the field:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段中：
- en: oTextField.setValue('Any new text you want to see')
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField.setValue('任何你想看到的新文本')
- en: At the bottom of the main while loop, you need to call the object’s
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的底部，你需要调用对象的
- en: 'draw() method:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法：
- en: oTextField.draw()
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: oTextField.draw()
- en: And of course, you can create as many DisplayText objects as you wish,
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以根据需要创建多个 DisplayText 对象，
- en: each displaying different text and each with its own font, size, color, and
    so on.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 每个显示不同的文本，并且每个都有自己的字体、大小、颜色等。
- en: '**Text Input**'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本输入**'
- en: In a typical text-based Python program, to get input from the user you
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于文本的 Python 程序中，要获取用户输入，你
- en: would make a call to the input() function, which stops the program until
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 会调用 input() 函数，程序会暂停，直到
- en: the user enters text in the shell window. But in the world of event-driven
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在终端窗口中输入文本。但在事件驱动的世界里，
- en: GUI programs, the main loop never stops. Therefore, we must use a differ-
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 程序中的主循环永远不会停止。因此，我们必须使用不同的
- en: ent approach.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的方法。
- en: For text input from the user, a GUI program typically presents a field
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自用户的文本输入，GUI 程序通常会呈现一个字段
- en: that the user can type in. An input field must deal with all keyboard keys,
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在其中输入的内容。输入字段必须处理所有键盘按键，
- en: some of which show while others are used for editing or cursor movement
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些显示，其他用于编辑或光标移动
- en: within the field. It must also allow for the user holding down a key to repeat
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 字段中的值。它还必须允许用户按住键来重复
- en: it. The pygwidgets InputText class provides all this functionality.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 它。pygwidgets 的 InputText 类提供了所有这些功能。
- en: Pygame GUI Widgets **155**
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **155**
- en: 'The only required arguments to instantiate an InputText object are the window
    and a location:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 InputText 对象所需的唯一参数是窗口和位置：
- en: oInputField = pygwidgets.InputText(window, (10, 100))
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: oInputField = pygwidgets.InputText(window, (10, 100))
- en: However, you can customize the text attributes of an InputText object by
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过以下方式自定义 InputText 对象的文本属性
- en: 'specifying optional keyword arguments:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 指定可选的关键字参数：
- en: oInputField = pygwidgets.InputText(window, (10, 400),
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: oInputField = pygwidgets.InputText(window, (10, 400)，
- en: value='Starting Text',
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: value='Starting Text'，
- en: fontName='Helvetica',
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: fontName='Helvetica'，
- en: fontSize=40,
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=40，
- en: width=150,
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: width=150，
- en: textColor=(255, 255, 0))
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=(255, 255, 0))
- en: After instantiating an InputText field, the typical code in the main loop
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 InputText 字段后，主循环中的典型代码是
- en: 'would look like this:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 会像这样：
- en: 'while True:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for event in pygame.event.get():'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oInputField.handleEvent(event):'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 oInputField.handleEvent(event):'
- en: User has pressed Enter or Return
  id: totrans-778
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户按下了 Enter 或 Return 键
- en: 'userText = oInputField.getValue() # get the text the user entered'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 'userText = oInputField.getValue()  # 获取用户输入的文本'
- en: '*<Any code you want to run using the user''s input>*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '*<你想要通过用户输入运行的任何代码>*'
- en: '--- snip ---'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪辑 ---'
- en: 'oInputField.draw() # at the bottom of the main while loop'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 'oInputField.draw()  # 在主 while 循环的底部'
- en: For every event, we need to call the handleEvent() method of the InputText
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个事件，我们需要调用 InputText 的 handleEvent() 方法
- en: field to allow it to react to keystrokes and mouse clicks. This call normally
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 字段以响应按键和鼠标点击。这通常通过以下方式调用
- en: returns False, but when the user presses ENTER or RETURN, it returns True.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False，但当用户按下 ENTER 或 RETURN 键时，它返回 True。
- en: We can then retrieve the text that the user entered by calling the getValue()
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用 getValue() 方法来获取用户输入的文本
- en: method of the object.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的方法。
- en: At the bottom of the main while loop, we need to call the draw() method
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 while 循环的底部，我们需要调用 draw() 方法
- en: to allow the field to draw itself.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 以允许字段自行绘制。
- en: If a window contains multiple input fields, key presses are handled by
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个窗口包含多个输入字段，键盘按键会由
- en: the field with current keyboard focus, which is changed when a user clicks
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 当前有键盘焦点的字段，当用户点击时会发生变化
- en: in a different field. If you want to allow a field to have initial keyboard
    focus,
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的领域中。如果你希望一个字段拥有初始的键盘焦点，
- en: then you can set the initialFocus keyword parameter to True in the InputText
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以将 initialFocus 关键字参数设置为 True，在 InputText
- en: object of your choice when you create that object. Further, if you have mul-
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建该对象时，选择你想要的对象。此外，如果你有多个
- en: tiple InputText fields in a window, a typical user interface design approach
    is
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个窗口中有多个 InputText 字段时，典型的用户界面设计方法是
- en: to include an OK or Submit button. When this button is clicked, you could
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 以包括一个 OK 或 Submit 按钮。当点击这个按钮时，你可以
- en: then call the getValue() method of each field.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用每个字段的 getValue() 方法。
- en: '**156** Chapter 7'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**156** 第七章'
- en: '**N O T E**'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*At the time of writing, the InputText class does not handle highlighting multiple*
    *characters by dragging the mouse. If this functionality is added in a later version,*
    *no change will be required to programs that use InputText because the code will
    be* *entirely within that class. Any new behavior will be supported automatically
    in all* *InputText objects.*'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*在撰写本文时，InputText 类不支持通过拖动鼠标高亮显示多个字符。如果以后版本添加了这个功能，* *那么使用 InputText 的程序将无需做任何更改，因为代码完全会包含在该类中。任何新的行为将自动支持所有*
    *InputText 对象。*'
- en: '***Other pygwidgets Classes***'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '***其他 pygwidgets 类***'
- en: As you saw at the beginning of this section, pygwidgets contains a number of
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节开始时看到的，pygwidgets 包含了多个
- en: other classes.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类。
- en: The ImageCollection class allows you to show any single image from a
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: ImageCollection 类允许你从一组图像中显示任何单个图像。
- en: collection of images. For example, suppose you have images of a character
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 一组图像。例如，假设你有一个角色的图像
- en: facing front, left, back, and right. To represent all the potential images,
    you
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 面朝前方、左侧、后方和右侧。为了表示所有可能的图像，你
- en: 'can build a dictionary like this:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以构建一个像这样的字典：
- en: imageDict = {'front':'images/front.png', 'left':'images/left.png',
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: imageDict = {'front':'images/front.png', 'left':'images/left.png'，
- en: '''back'':''images/back.png'', ''right'':''images/right.png''}'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '''back'':''images/back.png'', ''right'':''images/right.png''}'
- en: You can then create an ImageCollection object, specifying this dictionary
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个 ImageCollection 对象，指定这个字典
- en: and the key of the image you want to start with. To change to a different
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 以及你想要开始使用的图像的键。要更改为不同的图像
- en: image, you call the replace() method and pass in a different key. Calling the
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 图片时，你调用 replace() 方法并传入一个不同的键。调用该方法
- en: draw() method at the bottom of the loop always shows the current image.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 循环底部的`draw()`方法始终显示当前的图像。
- en: The Dragger class displays a single image but allows the user to drag the
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: Dragger类显示一张单独的图像，但允许用户拖动该图像
- en: image anywhere in the window. You must call its handleEvent() method in
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中任何位置显示图像。你必须调用其handleEvent()方法
- en: the event loop. When the user finishes dragging, handleEvent() returns True,
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环。当用户完成拖动时，handleEvent()返回True，
- en: and you can call the Dragger object’s getMouseUpLoc() method to get the loca-
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用Dragger对象的getMouseUpLoc()方法来获取鼠标释放的位置
- en: tion where the user released the mouse button.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 用户释放鼠标按钮时的位置。
- en: The Animation and SpriteSheetAnimation classes handle building and
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: Animation和SpriteSheetAnimation类处理构建和
- en: showing an animation. Both require a set of images to iterate through.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 显示动画。两者都需要一组图像进行迭代。
- en: The Animation class gets the images from individual files, while the
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: Animation类从单独的文件中获取图像，而
- en: SpriteSheetAnimation class requires a single image with evenly spaced internal
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteSheetAnimation类需要一张内部均匀间隔的图像
- en: images. We’ll explore these classes more fully i[n Chapter 14\.](index_split_005.html#p324)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 图像。我们将在[第14章](index_split_005.html#p324)中更详细地探讨这些类。
- en: '***pygwidgets Example Program***'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '***pygwidgets示例程序***'
- en: Figure 7-4 shows a screenshot of a sample program that demonstrates
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-4显示了一个示例程序的截图，演示了这些
- en: objects instantiated from many of the classes in pygwidgets, including Image,
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 从许多pygwidgets类实例化的对象，包括Image，
- en: DisplayText, InputText, TextButton, CustomButton, TextRadioButton, CustomRadioButton,
    TextCheckBox, CustomCheckBox, ImageCollection, and Dragger.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: DisplayText, InputText, TextButton, CustomButton, TextRadioButton, CustomRadioButton,
    TextCheckBox, CustomCheckBox, ImageCollection和Dragger。
- en: The source of this example program can be found in the *pygwidgets_test*
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例程序的源代码可以在*pygwidgets_test*文件夹中找到
- en: folder in my GitHub repository, [*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我GitHub仓库中的文件夹，[*https://github.com/IrvKalb/pygwidgets/*.](https://github.com/IrvKalb/pygwidgets/)
- en: Pygame GUI Widgets **157**
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI小部件 **157**
- en: '![Image 26](index-187_1.png)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![图像26](index-187_1.png)'
- en: '*Figure 7-4: The window of a program that demonstrates objects instantiated*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：演示实例化对象的程序窗口*'
- en: '*from a variety of pygwidgets classes*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '*来自各种pygwidgets类*'
- en: '**The Importance of a Consistent API**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性API的重要性**'
- en: 'One final note about building an API for a set of classes: whenever possible,'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为一组类构建API的最后一点：尽可能地
- en: it’s a very good idea to build consistency into the parameters of methods in
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的参数中构建一致性是一个非常好的主意
- en: different, but similar, classes. As a good example, the first two parameters
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 不同但类似的类。作为一个很好的例子，前两个参数
- en: to the __init__() method of every class in pygwidgets are window and loc, in
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets中每个类的__init__()方法中都有window和loc两个参数，
- en: that order. If these had been in a different order in some calls, using the
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顺序。如果这些在某些调用中顺序不同，使用参数
- en: package as a whole would be much more difficult.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 整个包将变得更加复杂。
- en: Additionally, if different classes implement the same functionality, it’s a
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果不同的类实现相同的功能，最好
- en: good idea to use the same method names. For example, many of the classes
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法名是个好主意。例如，许多类
- en: in pygwidgets have a method named setValue() and another named getValue().
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets中的类都有一个名为setValue()的方法和另一个名为getValue()的方法。
- en: I’ll talk more about why this type of consistency is so important in the next
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一节中详细讨论为什么这种一致性如此重要
- en: two chapters.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 两章内容。
- en: '**Summary**'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter provided an introduction to the object-oriented pygwidgets
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了面向对象的pygwidgets
- en: package of graphical user interface widgets. We began by discussing default
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面小部件包。我们首先讨论了默认
- en: values for parameters in methods, and I explained that a keyword param-
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中参数的值，我解释了一个关键字参数
- en: eter allows for a default value to be used if no matching argument value is
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 参数允许在没有匹配的参数值时使用默认值
- en: specified in a call.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用中指定。
- en: '**158** Chapter 7'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**第158章 第7章**'
- en: I then introduced you to the pygwidgets module, which contains a number of prebuilt
    GUI widget classes, and showed you how to use several of
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我向你介绍了pygwidgets模块，它包含多个预构建的GUI小部件类，并展示了如何使用其中的几个
- en: these. Finally, I showed a sample program that provides examples of most of
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这些。最后，我展示了一个示例程序，提供了大部分的示例
- en: these widgets.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小部件。
- en: There are two key advantages to writing classes like those in pygwidgets.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 编写像pygwidgets中的类有两个主要优点。
- en: First, classes can hide complexity in methods. Once you have your class
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类可以在方法中隐藏复杂性。一旦你有了类
- en: working correctly, you never have to worry about the internal details again.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 正常工作时，你再也不需要担心内部细节了。
- en: Second, you can reuse the code by creating as many instances of a class as
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你可以通过创建多个类实例来复用代码
- en: you need. Your classes can provide basic functionality by including keyword
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的。通过包括关键字，你的类可以提供基本功能
- en: parameters with well-chosen default values. However, the default values can
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，使用精心挑选的默认值。然而，默认值可以
- en: easily be overwritten to allow for customization.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松地被覆盖，以允许定制化。
- en: You can publish the interfaces of your classes for other programmers
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以公开类的接口，供其他程序员使用
- en: (and yourself) to take advantage of in different projects. Good documen-
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: （以及你自己）可以在不同的项目中利用。良好的文档
- en: tation and consistency go a long way toward making these types of classes
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化和一致性对于使这些类型的类
- en: highly usable.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 高度可用。
- en: Pygame GUI Widgets **159**
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame GUI 小部件 **159**
- en: '**PART III**'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三部分**'
- en: '**E N C A P S U L A T I O N ,**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**'
- en: '**P O LY M O R P H I S M , A N D**'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态性，和**'
- en: '**I N H E R I T A N C E**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**'
- en: The three main tenets of object-oriented program-
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的三大原则
- en: ming are encapsulation, polymorphism, and inheri-
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的封装、多态和继承是
- en: tance. The next three chapters will explain each of
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 实例。接下来的三章将解释每一个
- en: these in turn, describing the underlying concepts and
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反过来描述了底层的概念和
- en: showing examples of how they are implemented in
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了它们如何在
- en: Python. In order for a programming language to call
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Python。为了使编程语言能够调用
- en: itself an OOP language, it must support all three of
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 本身就是一门面向对象编程语言，它必须支持所有这三者
- en: these central requirements. (If you’re ever asked in an
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心要求。（如果你在面试中被问到
- en: interview about the requirements for a language to be
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 面试中要求语言的条件
- en: 'object-oriented, here’s an easy way to remember them:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的，这里有一个简单的记忆方法：
- en: it’s as easy as PIE!)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像 PIE 一样简单！）
- en: '[Chapter 8 e](#p192)xplains encapsulation: hiding the details and keeping everything
    in one place.'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章 e](#p192)解释了封装：隐藏细节并将所有内容保持在一个地方。'
- en: '[Chapter 9 d](#p212)iscusses polymorphism: how multiple classes can have methods
    with the same names.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章 d](#p212)讨论了多态：多个类可以拥有相同名称的方法。'
- en: '[Chapter 10 c](index_split_004.html#p240)overs inheritance: building on code
    that already exists.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章 c](index_split_004.html#p240)介绍了继承：在已有代码的基础上构建。'
- en: Finally[, Chapter 11 g](index_split_004.html#p270)oes into detail on a number
    of topics (mostly dealing with memory management) that do not logically fit into
    the previous
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[第11章 g](index_split_004.html#p270)详细讨论了若干主题（大多数涉及内存管理），这些内容在逻辑上不适合前面
- en: three chapters but are useful and important to OOP.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 这三章虽然重要，但也有用且对面向对象编程非常重要。
- en: '**8**'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**E N C A P S U L A T I O N**'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**'
- en: The first of the three main tenets of object-
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的三大原则之一
- en: oriented programming is *encapsulation*. This
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个重要概念是*封装*。这个
- en: word might conjure up an image of a space
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 这个词可能会让人想起太空
- en: capsule, a cell wall, or a medicine gelcap, where
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 胶囊，一个细胞壁，或一个药用胶囊，其中
- en: the precious cargo inside is protected from the outside
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的宝贵货物受到外部的保护
- en: environment. In programming, encapsulation has a
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 环境。在编程中，封装具有
- en: 'similar but even more detailed meaning: hiding inter-'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 相似但更详细的含义：隐藏
- en: nal details of state and behavior from any external
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 内部状态和行为的细节不受任何外部
- en: code and having all code in one place.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并且将所有代码放在一个地方。
- en: In this chapter, we’ll see how encapsulation works with functions, then
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到封装如何与函数配合使用，然后
- en: with methods of objects. I’ll discuss different interpretations of encapsu-
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象的方法。我要讨论封装的不同解释
- en: 'lation: using direct access versus using getters and setters. I’ll show how'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 封装：使用直接访问与使用 getter 和 setter。我将展示如何
- en: Python allows you to mark an instance variable as private, indicating that
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你将实例变量标记为私有，表示
- en: it should not be accessed by code external to a class, and I’ll touch on the
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 它不应该被类外的代码访问，我会触及到
- en: Python property decorator. Finally, I’ll discuss the concept of abstraction
    in
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: Python属性装饰器。最后，我将讨论抽象的概念
- en: the design of classes.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计。
- en: '**Encapsulation with Functions**'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装与函数**'
- en: Functions are a prime example of encapsulation because when you call a
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是封装的一个典型例子，因为当你调用一个
- en: function, you generally don’t care *how* the function works internally. A well-written
    function contains a series of steps that make up a larger single task,
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 函数时，你通常不关心*函数*如何在内部工作。一个写得很好的函数包含了一系列步骤，构成了一个更大的单一任务，
- en: which you do care about. The name of the function should describe the
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 你关心的是哪些内容。函数的名称应该描述
- en: action that its code embodies. Consider the built-in len() function from the
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 它的代码体现的动作。考虑内置的 len() 函数
- en: Python Standard Library, used to find the number of characters in a string
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库，用于查找字符串中的字符数
- en: or elements in a list. You pass in a string or list, and it returns the count.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 或列表中的元素。你传入一个字符串或列表，它会返回计数。
- en: When you write code that calls this function, you don’t care how len() does
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写调用这个函数的代码时，你不需要关心 len() 是如何
- en: what it does. You don’t stop to think about whether the code of the function
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 它的代码做什么。你不会停下来考虑函数代码
- en: contains two lines or two thousand lines, whether it uses one local variable
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 包含两行代码或两千行代码，无论它使用一个局部变量
- en: or a hundred. You just need to know what argument to pass in and how to
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 或一百个。你只需要知道传入什么参数并如何
- en: use the result that’s returned.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回的结果。
- en: The same is true of functions that you write, like this function that cal-
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的函数也同样如此，比如这个计算列表平均值的函数：
- en: 'culates and returns the average of a list of numbers:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 计算并返回一组数字的平均值：
- en: 'def calculateAverage(numbersList):'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculateAverage(numbersList):'
- en: total = 0.0
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0.0
- en: 'for number in numbersList:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 'for number in numbersList:'
- en: total = total + number
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + number
- en: nElements = len(numbersList)
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: nElements = len(numbersList)
- en: average = total / nElements
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: average = total / nElements
- en: return average
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: return average
- en: Once you’ve tested a function like this and found that it works, you
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试过这样的函数并确认它有效，你
- en: no longer have to worry about the details of the implementation. You
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要担心实现的细节。你
- en: only need to know what argument(s) to send into the function and what it
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要知道向函数传入什么参数，以及它
- en: returns.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值。
- en: However, if one day you find that there is a much simpler or faster algo-
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有一天你发现有一个更简单或更快速的算法，
- en: rithm to calculate an average, you could rewrite the function in a new way.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 算法计算平均值，你可以用新的方式重写函数。
- en: As long as the interface (the inputs and outputs) does not change, there is
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 只要接口（输入和输出）没有改变，就没有问题。
- en: no need to change any calls to the function. This type of modularization
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要改变任何对该函数的调用。这种模块化
- en: makes the code more maintainable.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码更具可维护性。
- en: '**Encapsulation with Objects**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象的封装**'
- en: Unlike variables used in regular functions, instance variables in objects per-
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数中使用的变量不同，对象中的实例变量每次
- en: sist across different method calls. To keep the remaining discussion clear,
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的方法调用之间保持一致。为了保持接下来的讨论清晰，
- en: 'I’ll introduce a new term: *client*. (I don’t want to use the term *user* here
    since that typically refers to the human user of the final program.)'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 我来介绍一个新术语：*客户端*。（我不想在这里使用*用户*这个术语，因为它通常指的是最终程序的人类用户。）
- en: '**client**'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: Any software that creates an object from a class and makes calls to the methods
    of
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从类中创建对象并调用其方法的软件，
- en: that object .
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 那个对象。
- en: We must also consider the duality of *inside* versus *outside* an object or
    class. When you’re working inside a class (writing the code of the methods
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑对象或类的*内部*与*外部*的二元性。当你在类内部工作时（编写方法的代码
- en: in a class), you need to concern yourself with how the different methods of
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中），你需要关心不同方法的
- en: '**164** Chapter 8'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '**164** 第8章'
- en: 'the class share the instance variables. You consider the efficiency of your
    algorithms. You think about what the interface should look like: what methods
    you should provide, what the parameters for each are, and what should'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 类共享实例变量。你考虑算法的效率。你思考接口应该是什么样子：应该提供哪些方法，每个方法的参数是什么，应该
- en: be used as default values. In short, you are concerned with the design and
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用作默认值。简而言之，你关心的是设计和
- en: implementation of the methods.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实现。
- en: From the outside, as a client programmer, you need to know the inter-
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部，作为客户端程序员，你需要了解接口
- en: face of the class. You’re concerned with what the class methods do, what
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 类的接口面。你关心的是类方法做什么，
- en: arguments should be passed in, and what data is passed back from each
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 参数应该传递什么数据，以及每个方法从类中返回什么数据
- en: method.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。
- en: 'A class therefore provides encapsulation by:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类通过以下方式提供封装：
- en: • Hiding all details of implementation in its methods and instance
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: • 隐藏其方法和实例中的所有实现细节
- en: variables
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: • Providing all the functionality a client needs from an object through its
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过其
- en: interface (the methods defined in the class)
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 接口（类中定义的方法）
- en: '***Objects Own Their Data***'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '***对象拥有自己的数据***'
- en: In object-oriented programming, we say that the data inside an object is
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们说数据存在于对象内部，属于
- en: '*owned* by the object. OOP programmers generally agree that, as a good'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '*由对象* 拥有。面向对象编程（OOP）程序员通常同意，作为好的'
- en: design principle, client code should only be concerned with the interface
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则是，客户端代码只应该关注接口
- en: of a class and should not care about the implementation of the methods.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只关心类的接口，而不必关心方法的实现。
- en: Consider the example of a simple Person class in Listing 8-1\.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下列表 8-1 中简单的 Person 类示例。
- en: 'class Person():'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Person():'
- en: 'def __init__(self, name, salary):'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, salary):'
- en: self.name = name
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.salary = salary
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: self.salary = salary
- en: '*Listing 8-1: Data ownership in the Person class*'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：Person 类中的数据所有权*'
- en: The values of the instance variables self.name and self.salary are set
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量 self.name 和 self.salary 的值已经设置
- en: 'whenever we instantiate new Person objects, like this:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们实例化新的 Person 对象时，像这样：
- en: oPerson1 = Person('Joe Schmoe', 90000)
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson1 = Person('Joe Schmoe', 90000)
- en: oPerson2 = Person('Jane Smith', 99000)
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2 = Person('Jane Smith', 99000)
- en: Each Person object owns its own set of the two instance variables.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Person 对象拥有自己的一组实例变量。
- en: '**Interpretations of Encapsulation**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装的解释**'
- en: Here is where things get a little controversial. Different programmers
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个有争议的地方。不同的程序员
- en: have different views about the accessibility of an instance variable. Python
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例变量的访问权限，Python 程序员
- en: provides for a loose interpretation of encapsulation by allowing direct
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许直接访问，提供了封装的宽松解释
- en: access to instance variables using simple dot syntax. Client code can
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的点语法访问实例变量。客户端代码可以
- en: legally access an instance variable of an object by name using the syntax
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法合法地访问对象的实例变量
- en: '*<object>* . *<instanceVariableName>* .'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '*<object>* . *<instanceVariableName>* .'
- en: Encapsulation **165**
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **165**
- en: However, a *strict* interpretation of encapsulation says that client software
    should never be able to retrieve or change the value of an instance variable
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，封装的*严格*解释认为，客户端软件永远不应该能够检索或更改实例变量的值
- en: directly. Instead, the only way that a client can retrieve or change a value
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问。相反，客户端访问或更改值的唯一方法是
- en: held in an object is to use a method provided by the class for this purpose.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在对象中的数据可以通过类提供的方法进行访问。
- en: Let’s look at both approaches.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这两种方法。
- en: '***Direct Access and Why You Should Avoid It***'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '***直接访问及为何应该避免它***'
- en: As mentioned, Python does allow direct access to instance variables. Listing
    8-2
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 确实允许直接访问实例变量。列表 8-2
- en: instantiates the same two objects from the Person class in Listing 8-1 as in
    the
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化了与列表 8-1 中相同的两个 Person 类对象
- en: previous section, but then accesses their self.salary instance variables directly.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中提到，接着直接访问它们的 self.salary 实例变量。
- en: '**File: PersonGettersSettersAndDirectAccess/Main_PersonDirectAccess.py**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PersonGettersSettersAndDirectAccess/Main_PersonDirectAccess.py**'
- en: Person example main program using direct access
  id: totrans-991
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Person 示例主程序使用直接访问
- en: from Person import *
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: from Person import *
- en: oPerson1 = Person('Joe Schmoe', 90000)
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson1 = Person('Joe Schmoe', 90000)
- en: oPerson2 = Person('Jane Smith', 99000)
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2 = Person('Jane Smith', 99000)
- en: Get the values of the salary variable directly
  id: totrans-995
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接获取薪资变量的值
- en: 1 print(oPerson1.salary)
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 1 print(oPerson1.salary)
- en: print(oPerson2.salary)
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson2.salary)
- en: Change the salary variable directly
  id: totrans-998
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接更改薪资变量
- en: 2 oPerson1.salary = 100000
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oPerson1.salary = 100000
- en: oPerson2.salary = 111111
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2.salary = 111111
- en: Get the updated salaries and print again
  id: totrans-1001
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取更新后的薪资并再次打印
- en: print(oPerson1.salary)
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson1.salary)
- en: print(oPerson2.salary)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson2.salary)
- en: '*Listing 8-2: Example main code using direct access to an instance variable*'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：使用直接访问实例变量的示例主代码*'
- en: Python allows you to write code like this that reaches into an object to
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你编写这样的代码，直接访问对象中的数据
- en: directly get 1 and set 2 any instance variable using standard dot syntax.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 直接获取 1 和设置 2 任何实例变量，使用标准的点语法。
- en: Most Python programmers feel that this technique is perfectly acceptable.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 程序员认为这种技术完全可以接受。
- en: In fact, Guido van Rossum (the creator of Python) famously said in refer-
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Python 的创造者 Guido van Rossum 曾在提到
- en: ence to this issue, “We are all adults here,” meaning that programmers
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题的回应是，“我们都是成年人”，意思是程序员
- en: should know what they are doing, and the risks involved, when they attempt
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员尝试访问实例变量时，应该知道他们在做什么，并意识到其中的风险。
- en: to access instance variables directly.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问实例变量。
- en: However, I strongly believe that directly accessing an instance variable
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我坚信直接访问实例变量
- en: of an object is an extremely dangerous practice, as it breaks the core idea
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问一个对象是一个极其危险的做法，因为它破坏了核心思想
- en: of encapsulation. To illustrate why this is the case, let’s take a look at a
    few
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的核心思想。为了说明为什么会这样，让我们看几个示例
- en: example scenarios where direct access can be problematic.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问可能会带来问题的示例场景。
- en: '**Changing the Name of an Instance Variable**'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改实例变量的名称**'
- en: The first problem with direct access is that changing the name of an
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问的第一个问题是更改实例变量名称时
- en: instance variable will break any client code that uses the original name
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量将破坏任何使用原始名称的客户端代码
- en: '**166** Chapter 8'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '**第166章 第8节**'
- en: directly. This can happen when the developer of a class decides that the initial
    choice of the name of the variable was not optimal, for reasons such as
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 直接地。这可能发生在类的开发者决定变量名称的初始选择不理想时，原因可能包括
- en: 'the following:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容：
- en: • The name doesn’t describe the data it represents clearly enough.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: • 名称没有清晰地描述它所表示的数据。
- en: • The variable is a Boolean, and they want to swap what True and False
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: • 变量是布尔值，他们想交换True和False
- en: represent by renaming the variable (for example, closed to open, allowed
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重命名变量来表示（例如，将closed更改为open，将allowed更改为disallowed）。
- en: to disallowed, active to disabled).
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 将“不允许”更改为“活动”变为“禁用”。
- en: • There was a spelling or capitalization mistake in the original name.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: • 原始名称存在拼写或大小写错误。
- en: • The variable was originally a Boolean, but they later realize that they
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: • 变量最初是布尔值，但后来他们意识到他们
- en: need to represent more than two values.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 需要表示两个以上的值。
- en: In any of these cases, if the developer changes the name of an instance
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，如果开发者更改了实例的名称
- en: variable in the class from self. *<originalName>* to self. *<newName>* , then
    any client software that uses the original name directly will break.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的变量从self. *<originalName>* 更改为self. *<newName>*，那么任何直接使用原始名称的客户端软件将会出错。
- en: '**Changing an Instance Variable into a Calculation**'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '**将实例变量转变为计算**'
- en: A second situation where direct access is problematic is when the code of
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况下，直接访问存在问题，当
- en: a class needs to change to meet new requirements. Suppose that when
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类需要改变以满足新的要求。假设当
- en: writing a class, you use an instance variable to represent a piece of data,
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类时，你使用实例变量来表示一块数据，
- en: but the functionality changes so that you need an algorithm to compute a
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 但是功能发生了变化，所以你需要一个算法来计算
- en: value instead. Take our Account class fro[m Chapter 4, f](index_split_001.html#p86)or
    example. To make our bank accounts more realistic, we might want to add an interest
    rate.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 不如改为使用一个值。以我们在第4章中的Account类为例。为了使我们的银行账户更具现实感，我们可能希望添加一个利率。
- en: You might think this is a simple matter of adding an instance variable for
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这是一个简单的增加实例变量的问题，用来表示
- en: the interest rate named self.interestRate. Then, using the direct access
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 利率命名为self.interestRate。然后，使用直接访问
- en: 'approach, client software could access this value of an Account object using:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法下，客户端软件可以通过以下方式访问Account对象的该值：
- en: oAccount.interestRate
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: oAccount.interestRate
- en: This would work, for a while. But later the bank might decide on a new
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以工作，一段时间。然而，后来银行可能决定新的
- en: policy—say that the interest rate will depend on the amount of money in
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 政策——比如利率将取决于账户中的金额
- en: 'the account. The interest rate might be calculated like this:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 账户。利率可能是这样计算的：
- en: 'def calculateInterestRate(self):'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculateInterestRate(self):'
- en: Assuming self.balance has been set in another method
  id: totrans-1045
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设self.balance在另一个方法中已经被设置
- en: 'if self.balance < 1000:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self.balance < 1000：
- en: self.interestRate = 1.0
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: self.interestRate = 1.0
- en: 'elif self.balance < 5000:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: elif self.balance < 5000：
- en: self.interestRate = 1.5
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: self.interestRate = 1.5
- en: 'else:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 其他：
- en: self.interestRate = 2.0
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: self.interestRate = 2.0
- en: Rather than just relying on a single interest rate value in self.interestRate,
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 与其只依赖self.interestRate中的单一利率值，
- en: the calculateInterestRate() method determines the current rate based on the
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: calculateInterestRate()方法根据
- en: account balance.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 账户余额。
- en: Any client software that directly accesses oAccount.interestRate and
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 任何直接访问oAccount.interestRate的客户端软件和
- en: uses the value of the instance variable might then get an outdated value,
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实例变量的值可能会得到一个过时的值，
- en: depending on the last time calculateInterestRate() was called. And any
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于上次调用calculateInterestRate()的时间。任何
- en: Encapsulation **167**
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 封装**第167章**
- en: client software that *sets* a new interestRate may find that the new value is
    mysteriously changed by some other code that calls calculateInterestRate()
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 设置新interestRate的客户端软件可能会发现，新值被某些其他调用calculateInterestRate()的代码神秘地更改了
- en: or when the bank account owner makes a deposit or withdrawal.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 或者当银行账户所有者进行存款或取款时。
- en: If, however, the interest calculation method was named getInterestRate()
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 如果利率计算方法名为 getInterestRate()
- en: and client software called that instead, the interest rate would always be cal-
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端软件调用了那个方法，利率总是会被计算——
- en: culated on the fly and there would be no potential error.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 计算在运行时进行，这样就没有潜在的错误。
- en: '**Validating Data**'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证数据**'
- en: The third reason to avoid direct access when setting a value is that client
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接访问设置值的第三个原因是客户端
- en: code can too easily set an instance variable to an invalid value. A better
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 代码过于容易将实例变量设置为无效值。一个更好的方法是
- en: approach is to call a method in the class, whose job is to set the value. As
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是调用类中的一个方法，该方法的任务是设置值。考虑列表 8-3 中的代码，
- en: the developer, you can include validation code in that method to ensure
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你可以在该方法中包含验证代码，确保
- en: that the value being set is appropriate. Consider the code in Listing 8-3,
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 确保设置的值是合适的。考虑列表 8-3 中的代码，
- en: whose purpose is to manage the members of a club.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 其目的是管理俱乐部的成员。
- en: '**File: ValidatingData_ClubExample/Club.py**'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：ValidatingData_ClubExample/Club.py**'
- en: Club class
  id: totrans-1072
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Club 类
- en: 'class Club():'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Club():'
- en: 'def __init__(self, clubName, maxMembers):'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, clubName, maxMembers):'
- en: self.clubName = clubName 1
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: self.clubName = clubName 1
- en: self.maxMembers = maxMembers
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxMembers = maxMembers
- en: self.membersList = []
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: self.membersList = []
- en: 'def addMember(self, name): 2'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addMember(self, name): 2'
- en: Make sure that there is enough room left
  id: totrans-1079
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保还有足够的空间
- en: 'if len(self.membersList) < self.maxMembers:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 len(self.membersList) < self.maxMembers:'
- en: self.membersList.append(name)
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: self.membersList.append(name)
- en: print('OK.', name, 'has been added to the', self.clubName, 'club')
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: print('好的。', name, '已被加入到', self.clubName, '俱乐部')
- en: 'else:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('Sorry, but we cannot add', name, 'to the', self.clubName, 'club.')
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: print('抱歉，我们无法将', name, '添加到', self.clubName, '俱乐部。')
- en: print('This club already has the maximum of', self.maxMembers, 'members.')
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: print('这个俱乐部已经有了最多的', self.maxMembers, '名成员。')
- en: 'def report(self): 3'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 'def report(self): 3'
- en: print()
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: print('Here are the', len(self.membersList), 'members of the', self.clubName,
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: print('这里是', len(self.membersList), '名', self.clubName, '俱乐部的成员。')
- en: '''club:'')'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '''club:'''
- en: 'for name in self.membersList:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 'for name in self.membersList:'
- en: print(' ' + name)
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: print(' ' + name)
- en: print()
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '*Listing 8-3: An example of a Club class*'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：Club 类示例*'
- en: The Club code keeps track of the name of the club, the maximum num-
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 俱乐部代码跟踪俱乐部的名称、最大成员数量等。
- en: ber of members, and the list of members, all in instance variables 1\. Once
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 成员数量和成员列表都在实例变量中 1。一次
- en: instantiated, you can call methods to add a member to the club 2 and to
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，你可以调用方法来向俱乐部添加成员，并且可以
- en: report the members of the club 3\. (We could easily add more methods to
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 报告俱乐部成员 3。（我们可以轻松地添加更多方法来
- en: '**168** Chapter 8'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '**168** 第 8 章'
- en: remove members, change names, and so on, but these two are good enough the make
    the point.)
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 删除成员、修改名称等，但这两个方法足够展示这个观点。
- en: Here is some test code that uses the Club class.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用 Club 类的测试代码。
- en: '**File: ValidatingData_ClubExample/Main_Club.py**'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：ValidatingData_ClubExample/Main_Club.py**'
- en: Club example main program
  id: totrans-1102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Club 示例主程序
- en: from Club import *
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Club 导入 *
- en: Create a club with at most 5 members
  id: totrans-1104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个最多允许 5 个成员的俱乐部
- en: oProgrammingClub = Club('Programming', 5)
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub = Club('编程', 5)
- en: oProgrammingClub.addMember('Joe Schmoe')
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.addMember('Joe Schmoe')
- en: oProgrammingClub.addMember('Cindy Lou Hoo')
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.addMember('Cindy Lou Hoo')
- en: oProgrammingClub.addMember('Dino Richmond')
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.addMember('Dino Richmond')
- en: oProgrammingClub.addMember('Susie Sweetness')
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.addMember('Susie Sweetness')
- en: oProgrammingClub.addMember('Fred Farkle')
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.addMember('Fred Farkle')
- en: oProgrammingClub.report()
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.report()
- en: We create a Programming club that allows a maximum of five members
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个最多允许五个成员的编程俱乐部
- en: and then we add five members. The code runs well and reports the mem-
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了五个成员。代码运行良好，并报告了这些成员—
- en: 'bers added to the club:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到俱乐部的成员：
- en: OK. Joe Schmoe has been added to the Programming club
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。Joe Schmoe 已经加入了编程俱乐部
- en: OK. Cindy Lou Hoo has been added to the Programming club
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。Cindy Lou Hoo 已经加入了编程俱乐部
- en: OK. Dino Richmond has been added to the Programming club
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。Dino Richmond 已经加入了编程俱乐部
- en: OK. Susie Sweetness has been added to the Programming club
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。Susie Sweetness 已经加入了编程俱乐部
- en: OK. Fred Farkle has been added to the Programming club
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。Fred Farkle 已经加入了编程俱乐部
- en: 'Now let’s try to add a sixth member:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试加入第六个成员：
- en: Attempt to add additional member
  id: totrans-1121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试添加额外的成员
- en: oProgrammingClub.addMember('Iwanna Join')
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.addMember('Iwanna Join')
- en: This attempt to add a member is rejected, and we see an appropriate
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 这次尝试添加成员被拒绝，我们看到一个适当的
- en: 'error message:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息：
- en: Sorry, but we cannot add Iwanna Join to the Programming club.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，但我们无法将 "Iwanna Join" 加入编程俱乐部。
- en: This club already has the maximum of 5 members.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个俱乐部已经有最多5名成员。
- en: The code of addMember() does all the validation needed to ensure that
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: addMember()的代码做了所有必要的验证，确保
- en: a call to add a new member works correctly or generates an error message.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个添加新成员的调用是否正常工作，或者生成错误信息。
- en: However, with direct access, a client could change the fundamental nature
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直接访问的情况下，客户端可以改变基础的本质。
- en: of the Club class. For example, a client could maliciously or accidentally
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: Club类的一个示例。例如，客户端可以恶意或意外地
- en: 'change the maximum number of members:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 更改最大成员数：
- en: oProgrammingClub.maxMembers = 300
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.maxMembers = 300
- en: Further, suppose you know that the Club class represents the members
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设你知道Club类表示俱乐部成员，
- en: as a list, and you know the name of the instance variable that represents the
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表，你知道表示成员的实例变量的名称。
- en: Encapsulation **169**
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **169**
- en: 'members. In that case you can write client code to add to the list of members
    directly, without making the method call, like so:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 成员。如果是这种情况，你可以直接编写客户端代码来添加成员到成员列表中，而不需要调用方法，如下所示：
- en: oProgrammingClub.memberList.append('Iwanna Join')
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: oProgrammingClub.memberList.append('Iwanna Join')
- en: This line would push the membership over the intended limit because
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会使会员人数超过预定的上限，因为
- en: it avoids the code that ensures that the request to add the member is valid.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 它避免了确保请求添加成员有效的代码。
- en: Client code using direct access could even cause an error inside the
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接访问的客户端代码甚至可能会在
- en: Club object. For example, the instance variable self.maxMembers is intended
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: Club对象。例如，实例变量self.maxMembers旨在
- en: to be an integer. Using direct access, client code could change its value to
    a
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 是整数。使用直接访问，客户端代码可能会将其值更改为一个
- en: string. Any subsequent call to addMember() would crash at the first line of
    that
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串。任何后续调用addMember()的操作都会在第一行崩溃。
- en: method, where it attempts to compare the length of the list of members
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，尝试比较成员列表的长度
- en: against the maximum number of members, because Python cannot com-
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 超过最大成员数，因为Python无法比较
- en: pare an integer to a string.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 比较一个整数和字符串。
- en: Allowing direct access to instance variables from outside an object can
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 允许从外部直接访问实例变量可能会
- en: be dangerous, bypassing safeguards that were designed to protect the data
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会很危险，绕过旨在保护数据的安全措施
- en: of an object.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的。
- en: '***Strict Interpretation with Getters and Setters***'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '***严格解释与Getter和Setter***'
- en: The strict approach to encapsulation says that client code *never* accesses
    an instance variable directly. If a class wants to allow client software to access
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的封装方法要求客户端代码*永远*不直接访问实例变量。如果类希望允许客户端软件访问
- en: the information held inside an object, the standard approach is to include a
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对象内部信息，标准做法是包含一个
- en: '*getter* and a *setter* method in the class.'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的*getter*和*setter*方法。
- en: '**getter**'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '**getter**'
- en: A method that retrieves data from an object instantiated from a class .
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从类实例化的对象中检索数据的方法。
- en: '**setter**'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '**setter**'
- en: A method that assigns data into an object instantiated from a class .
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将数据分配到从类实例化的对象中的方法。
- en: Getter and setter methods are designed to allow writers of client soft-
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: Getter和setter方法的设计旨在允许客户端软件的编写者
- en: ware to get data from and set data in an object, without needing explicit
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据和设置数据时，软件无需显式访问对象内部数据。
- en: knowledge of the implementation of a class—specifically, without having
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 没有了解类的实现细节的情况下，造成错误。
- en: to know or use the name of any instance variable. The Person class code
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要知道或使用任何实例变量的名称。Person类代码
- en: in Listing 8-1 has an instance variable self.salary. In Listing 8-4 we add a
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单8-1中，Person类具有实例变量self.salary。在清单8-4中，我们添加了一个
- en: getter and a setter to the Person class to allow the caller to get and set the
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 向Person类添加getter和setter，以允许调用者获取和设置该
- en: salary, without providing direct access to the Person’s self.salary instance
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 工资，而不提供直接访问Person的self.salary实例
- en: variable.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。
- en: '**File: PersonGettersSettersAndDirectAccess/Person.py**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PersonGettersSettersAndDirectAccess/Person.py**'
- en: 'class Person():'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Person():'
- en: 'def __init__(self, name, salary):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, salary):'
- en: self.name = name
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.salary = salary
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: self.salary = salary
- en: Allow the caller to retrieve the salary
  id: totrans-1171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许调用者检索工资
- en: '1 def getSalary(self):'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def getSalary(self):'
- en: '**170** Chapter 8'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '**170** 第8章'
- en: return self.salary
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: return self.salary
- en: Allow the caller to set a new salary
  id: totrans-1175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许调用者设置新的工资
- en: '2 def setSalary(self, salary):'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def setSalary(self, salary):'
- en: self.salary = salary
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: self.salary = salary
- en: '*Listing 8-4: An example of a Person class with a get er and a set er*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4：包含 getter 和 setter 的 Person 类示例*'
- en: The get 1 and set 2 portions of these method names are not required
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法名称中的 get 1 和 set 2 部分不是必须的
- en: but are used by convention. You generally follow these words with a descrip-
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通过惯例使用。你通常会跟随这些词，并加上描述性
- en: tion of the data being accessed, in this case Salary. While it is typical to
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据时需要考虑的封装性，在这种情况下是薪水。虽然通常
- en: use the name of the instance variable being accessed, this is also not a
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问的实例变量名称，这通常不是
- en: requirement.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 要求。
- en: Listing 8-5 shows some test code that instantiates two Person objects,
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5 展示了一些测试代码，实例化了两个 Person 对象，
- en: then gets and sets their salaries using these getter and setter methods.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这些 getter 和 setter 方法获取和设置他们的薪水。
- en: '**File: PersonGettersSettersAndDirectAccess/Main_PersonGetterSetter.py**'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PersonGettersSettersAndDirectAccess/Main_PersonGetterSetter.py**'
- en: Person example main program using getters and setters
  id: totrans-1187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Person 示例主程序使用 getter 和 setter
- en: from Person import *
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: from Person import *
- en: 1 oPerson1 = Person('Joe Schmoe', 90000)
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 1 oPerson1 = Person('乔·史密斯', 90000)
- en: oPerson2 = Person('Jane Smith', 99000)
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2 = Person('简·史密斯', 99000)
- en: Get the salaries using getter and print
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取薪水并打印
- en: 2 print(oPerson1.getSalary())
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 2 print(oPerson1.getSalary())
- en: print(oPerson2.getSalary())
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson2.getSalary())
- en: Change the salaries using setter
  id: totrans-1194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 setter 修改薪水
- en: 3 oPerson1.setSalary(100000)
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 3 oPerson1.setSalary(100000)
- en: oPerson2.setSalary(111111)
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: oPerson2.setSalary(111111)
- en: Get the salaries and print again
  id: totrans-1197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取薪水并再次打印
- en: print(oPerson1.getSalary())
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson1.getSalary())
- en: print(oPerson2.getSalary())
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: print(oPerson2.getSalary())
- en: '*Listing 8-5: Example main code using get er and set er methods*'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：使用 getter 和 setter 方法的示例主代码*'
- en: First we create two Person objects from the Person class 1\. Then we use
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们从 Person 类创建了两个 Person 对象 1\。然后我们使用
- en: the getter and setter methods to retrieve 2 and change 3 the salaries in
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 getter 和 setter 方法获取 2 和更改 3 薪水
- en: the Person objects.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Person 对象。
- en: Getters and setters provide a formal way to get and set values in an
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: Getter 和 setter 提供了一种正式的方式来获取和设置对象中的值
- en: object. They enforce a layer of protection that only allows access to instance
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。它们执行了一层保护，只允许访问实例
- en: variables if the class writer wants to allow it.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 变量如果类的编写者允许它的话。
- en: '**N O T E**'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*Some Python literature uses the terms* accessor *for a getter method and*
    mutator *for* *the setter method. These are just different names for the same
    things. I will use the* *more generic terms* getter *and* setter *.*'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些 Python 文献使用术语* 访问器 *表示 getter 方法，* 修改器 *表示 setter 方法。这些只是相同概念的不同名称。我将使用*
    *更通用的术语* getter *和* setter *。*'
- en: Encapsulation **171**
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **171**
- en: '***Safe Direct Access***'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '***安全的直接访问***'
- en: There are certain circumstances where it seems reasonable to access
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，访问似乎是合理的
- en: 'instance variables directly: when it is absolutely clear what the instance
    vari-'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量直接访问：当明确知道实例变量时，
- en: able means, little or no validation of the data is needed, and there is no
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 能够意味着，几乎不需要数据验证，并且没有
- en: chance that the name will ever change. A good example of this is the Rect
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有可能发生名称更改。一个很好的例子是 Rect
- en: (rectangle) class in the pygame package. A rectangle in pygame is defined
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: （矩形）类在 pygame 包中定义。一个 pygame 中的矩形通过
- en: 'using four values—x, y, width, and height—like this:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用四个值—x, y, 宽度和高度—像这样：
- en: oRectangle = pygame.Rect(10, 20, 300, 300)
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: oRectangle = pygame.Rect(10, 20, 300, 300)
- en: After creating that rectangle object, using oRectangle.x, oRectangle.y,
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了那个矩形对象后，使用 oRectangle.x, oRectangle.y,
- en: oRectangle.width, and oRectangle.height directly as variables seems acceptable.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: oRectangle.width 和 oRectangle.height 直接作为变量使用似乎是可以接受的。
- en: '**Making Instance Variables More Private**'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '**使实例变量更加私密**'
- en: In Python, all instance variables are public (that is, can be accessed by code
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，所有实例变量都是公共的（即可以被代码
- en: external to the class). But what if you want to allow access to some of your
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 外部访问类实例变量）。但是如果你想允许访问某些变量呢
- en: class’s instance variables, but not all of them? Some OOP languages allow
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实例变量，但并不是所有变量？一些面向对象编程语言允许
- en: you to explicitly mark certain instance variables as public or private, but
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显式地标记某些实例变量为公共或私有，但
- en: Python doesn’t have those keywords. However, there are two ways that pro-
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有这些关键字。然而，有两种方法可以让程序员
- en: grammers who develop classes in Python can indicate that their instance
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中开发类的程序员可以表明他们的实例
- en: variables and methods are intended to be private.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和方法通常被认为是私有的。
- en: '***Implicitly Private***'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '***隐式私有***'
- en: To mark an instance variable as one that should never be accessed exter-
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 要标记一个实例变量为永远不应被外部访问的类型——
- en: nally, by convention you start the name of your instance variable with one
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '最终，按照约定，你应当以一个下划线开始实例变量的名称  '
- en: 'leading underscore:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '下划线前缀：  '
- en: self._name
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 'self._name  '
- en: self._socialSecurityNumber
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 'self._socialSecurityNumber  '
- en: self._dontTouchThis
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 'self._dontTouchThis  '
- en: Instance variables with names like these are intended to represent pri-
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '像这样的实例变量名称是用于表示私有数据的，  '
- en: vate data, and client software should never attempt to access them directly.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '私有数据，客户端软件不应尝试直接访问。  '
- en: The code may still work if the instance variables are accessed, but it is not
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '如果实例变量被访问，代码仍然可能工作，但这并不是  '
- en: guaranteed.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '保证。  '
- en: 'The same convention is used for method names:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '对方法名也使用相同的约定：  '
- en: 'def _internalMethod(self):'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _internalMethod(self):  '
- en: 'def _dontCallMeFromClientSoftware(self):'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _dontCallMeFromClientSoftware(self):  '
- en: Again, this is only a convention; there is no enforcement. If any client
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '再次强调，这仅仅是一种约定，并没有强制执行。如果任何客户端  '
- en: software makes a call to a method with a name beginning with an under-
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '软件调用以下划线开头的方法名时  '
- en: score, Python will allow it, but there is a good chance that doing so will
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '得分，Python 会允许它，但很有可能这样做会  '
- en: lead to unexpected errors.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '可能会导致意外错误。  '
- en: '**172** Chapter 8'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '**172** 第8章  '
- en: '***More Explicitly Private***'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '***更明确的私有化***  '
- en: Python does allow for a more explicit level of privatization. To disallow client
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python 确实提供了一个更明确的私有化级别。为了禁止客户端  '
- en: software from directly accessing your data, you create an instance variable
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '软件直接访问数据时，你会创建一个实例变量  '
- en: name that starts with two underscores.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '以两个下划线开头的名称。  '
- en: Suppose we create a class named PrivatePerson with an instance variable
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们创建一个名为 PrivatePerson 的类，并且有一个实例变量  '
- en: 'self.__privateData that should never be accessed from outside an object:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.__privateData 是不应该从外部访问的：  '
- en: PrivatePerson class
  id: totrans-1253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'PrivatePerson 类  '
- en: 'class PrivatePerson():'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 'class PrivatePerson():  '
- en: 'def __init__(self, name, privateData):'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, privateData):  '
- en: self.name = name
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.name = name  '
- en: 1 self.__privateData = privateData
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '1 self.__privateData = privateData  '
- en: 'def getName(self):'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getName(self):  '
- en: return self.name
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 'return self.name  '
- en: 'def setName(self, name):'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setName(self, name):  '
- en: self.name = name
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.name = name  '
- en: We can then create a PrivatePerson object, passing in some data that we
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们可以创建一个 PrivatePerson 对象，传入一些我们  '
- en: wish to keep private 1\. Attempting to access the __privateData instance vari-
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '希望保持私有 1\. 尝试访问 __privateData 实例变量时  '
- en: 'able directly from client software, like this:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '客户端软件可以直接访问，像这样：  '
- en: usersPrivateData = oPrivatePerson.__privateData
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 'usersPrivateData = oPrivatePerson.__privateData  '
- en: 'will generate an error:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '会生成错误：  '
- en: 'AttributeError: ''PrivatePerson'' object has no attribute ''__privateData'''
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 'AttributeError: ''PrivatePerson'' 对象没有属性 ''__privateData''  '
- en: Similarly, if you create a method name that starts with two underscores,
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，如果你创建一个以两个下划线开头的方法名称，  '
- en: any attempt by client software to call the method will generate an error.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '客户端软件的任何调用该方法的尝试都会生成一个错误。  '
- en: Python provides this ability by performing *name mangling*. Behind
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了通过 *名称重整* 实现这个功能。幕后
- en: the scenes, Python changes any name that starts with two underscores by
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '在幕后，Python 会通过  '
- en: prepending it with an underscore and the name of the class, so __ *<name>*
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '在名称前加上下划线和类名，因此 __ *<name>*  '
- en: becomes _ *<className>* __ *<name>* . For example, in the PrivatePerson class,
    Python will change self.__privateData to self._PrivatePerson__privateData. Therefore,
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '变成 _ *<className>* __ *<name>*。例如，在 PrivatePerson 类中，Python 会将 self.__privateData
    更改为 self._PrivatePerson__privateData。因此，  '
- en: if a client tries to use the name oPrivatePerson.__privateData, that name won’t
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '如果客户端尝试使用名称 oPrivatePerson.__privateData，该名称将不会  '
- en: be recognized.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '会被识别。  '
- en: This is a subtle change designed as a deterrent to using direct
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个微妙的变化，旨在阻止直接  '
- en: access, but you should note that it doesn’t absolutely guarantee privacy.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '访问，但你应该注意，这并不绝对保证隐私。  '
- en: If the client programmer knows how this works, they can still access the
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '如果客户端程序员知道这个工作原理，他们仍然可以访问  '
- en: instance variable with *<object>* ._ *<className>* __ *<name>* (or, in our example,
    oPrivatePerson._PrivatePerson__privateData).
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '实例变量以 *<object>* ._ *<className>* __ *<name>* （或者在我们的示例中是 oPrivatePerson._PrivatePerson__privateData）。  '
- en: Encapsulation **173**
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '封装 **173**  '
- en: '**Decorators and @property**'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器和 @property**  '
- en: At a high level, a decorator is a method that takes another method as an
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '从高层次看，装饰器是一个方法，它接受另一个方法作为  '
- en: argument and extends the way the original method works. (Decorators can
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '参数并扩展原方法的工作方式。（装饰器可以  '
- en: also be functions that decorate functions or methods, but I’ll concentrate
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '也可以是装饰函数或方法的函数，但我将集中讨论  '
- en: on methods.) Decorators are an advanced topic and are generally beyond
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '（专注于方法。）装饰器是一个高级主题，通常超出  '
- en: the scope of this book. However, there is a set of built-in decorators that
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围之外。不过，有一组内建装饰器可以
- en: provide a compromise between direct access and the use of getters and set-
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了直接访问和使用getter、setter之间的折中。
- en: ters in a class.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的成员。
- en: A decorator is written as a line that starts with the @ symbol followed
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是以@符号开头的行，后面跟着
- en: by a decorator name and is placed directly before the def statement of a
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过装饰器名称，并且直接放置在方法的def语句之前。
- en: 'method. This applies the decorator to a method to add to its behavior:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。它应用装饰器给方法增加行为：
- en: '@ *<decorator>*'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '@ *<decorator>*'
- en: def *<someMethod>* (self, *<parameters>* )
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: def *<someMethod>* (self, *<parameters>* )
- en: We’ll use two built-in decorators and apply them to two methods in a
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个内建装饰器，并将它们应用到一个类中的两个方法。
- en: class to implement a *property*.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: class实现一个*property*。
- en: '**property**'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: '**property**'
- en: An attribute of a class that appears to client code to be an instance variable,
    but instead causes a method to be called when it is accessed .
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的属性，看起来像是客户端代码中的实例变量，但实际上，当访问它时会调用一个方法。
- en: A property allows class developers to use indirection, the way that
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 一个属性允许类开发者使用间接访问，类似于
- en: a magician uses misdirection—the audience thinks they are seeing one
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术师使用调虎离山之计——观众以为他们看到的是一种
- en: thing, while behind the scenes something very different is happening.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 做着相同的事情，但背后发生的事情却大不相同。
- en: When writing a class to use property decorators, the developer writes a get-
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写使用属性装饰器的类时，开发者编写一个getter方法，
- en: ter and a setter method and adds a distinct built-in decorator to each one.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 一个getter方法和一个setter方法，并为每个方法添加一个独特的内建装饰器。
- en: The first method is a getter and is preceded with the built-in @property deco-
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是getter方法，并且之前带有内建的@property装饰器。
- en: rator. The name of the method defines a name of a property to be used by
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器。方法的名称定义了一个由
- en: client code. The second method is a setter and is preceded with the @ *<name*
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码。第二个方法是setter方法，并且之前带有@ *<name*
- en: '*of the property>* .setter decorator. Here is a minimal sample class:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '*property>* .setter装饰器。以下是一个最小的示例类：'
- en: 'class Example():'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Example():'
- en: 'def __init__(self, startingValue):'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, startingValue):'
- en: self._x = startingValue
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: self._x = startingValue
- en: '@property'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def x(self): # this is the decorated getter method'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 'def x(self): # 这是带有装饰器的getter方法'
- en: return self._x
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: return self._x
- en: '@x.setter'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '@x.setter'
- en: 'def x(self, value): # this is the decorated setter method'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 'def x(self, value): # 这是带有装饰器的setter方法'
- en: self._x = value
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: self._x = value
- en: In the Example class, x is the name of the property. After the standard
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 在Example类中，x是属性的名称。标准
- en: __init__() method, the unusual thing is that we have two methods that both
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法，异常之处在于我们有两个方法，它们都'
- en: 'have the same name: the name of the property. The first method is a get-'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有相同的名称：属性的名称。第一个方法是一个getter方法。
- en: ter, while the second is a setter. The setter method is optional, and if it’s
    not
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个getter方法，第二个是setter方法。setter方法是可选的，如果没有提供
- en: present, the property will be read-only.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只存在getter方法，那么这个属性将是只读的。
- en: '**174** Chapter 8'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '**174** 第8章'
- en: 'Given the Example class, here is some sample client code:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 给定Example类，以下是一些客户端代码示例：
- en: oExample = Example(10)
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: oExample = Example(10)
- en: print(oExample.x)
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: print(oExample.x)
- en: oExample.x = 20
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: oExample.x = 20
- en: In this code we create an instance of the Example class, make a call to
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个Example类的实例，调用了
- en: print(), and execute a simple assignment. From the client’s point of view,
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: print()并执行一个简单的赋值。从客户端的角度来看，
- en: this code is highly readable. When we write oExample.x, it looks like we are
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码具有很高的可读性。当我们写oExample.x时，看起来像是我们正在
- en: using direct access to an instance variable. However, when client code
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接访问实例变量。然而，当客户端代码
- en: accesses the value of an object’s property (on the right side of an assign-
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 访问对象属性的值（出现在赋值语句的右边）。
- en: ment statement or as an argument in a call to a function or method),
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数或方法调用中的参数，或者作为赋值语句的一部分，
- en: Python translates it into a call to the getter method of the object. When an
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: Python将其转换为对对象的getter方法的调用。当一个
- en: object dot property appears on the left side of an assignment statement,
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的dot属性出现在赋值语句的左侧，
- en: Python calls the setter method. The getter and setter methods affect the
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: Python调用setter方法。getter和setter方法会影响
- en: real instance variable, self._x.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的实例变量，self._x。
- en: Here is a more realistic example that should help make this clear.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更实际的示例，应该有助于理解。
- en: Listing 8-6 shows a Student class that includes a property grade, properly dec-
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-6展示了一个Student类，其中包含一个属性grade，正确地使用了装饰器。
- en: orated getter and setter methods, and a private instance variable __grade.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰过的getter和setter方法，以及一个私有实例变量__grade。
- en: '**File: PropertyDecorator/Student.py**'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PropertyDecorator/Student.py**'
- en: Using a property to (indirectly) access data in an object
  id: totrans-1340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性间接访问对象中的数据。
- en: 'class Student():'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Student():'
- en: 'def __init__(self, name, startingGrade=0):'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, startingGrade=0):'
- en: self.__name = name
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: self.__name = name
- en: self.grade = startingGrade 1
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: self.grade = startingGrade 1
- en: '@property 2'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '@property 2'
- en: 'def grade(self): 3'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grade(self): 3'
- en: return self.__grade
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: return self.__grade
- en: '@grade.setter 4'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '@grade.setter 4'
- en: 'def grade(self, newGrade): 5'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grade(self, newGrade): 5'
- en: 'try:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: newGrade = int(newGrade)
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: newGrade = int(newGrade)
- en: 'except (TypeError, ValueError) as e:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 'except (TypeError, ValueError) as e:'
- en: 'raise type(e)(''New grade: '' + str(newGrade) + '', is an invalid type.'')'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 'raise type(e)(''New grade: '' + str(newGrade) + '', is an invalid type.'')'
- en: 'if (newGrade < 0) or (newGrade > 100):'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (newGrade < 0) or (newGrade > 100):'
- en: 'raise ValueError(''New grade: '' + str(newGrade) + '', must be between 0 and
    100.'')'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 'raise ValueError(''New grade: '' + str(newGrade) + '', must be between 0 and
    100.'')'
- en: self.__grade = newGrade
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: self.__grade = newGrade
- en: '*Listing 8-6: The Student class with property decorators*'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：带有属性装饰器的 Student 类*'
- en: The __init__() method has a little trick to it, so let’s examine the
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法有一个小技巧，让我们来检查一下
- en: other methods first. Notice we have two methods with the name grade().
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法先执行。注意我们有两个名为 grade() 的方法。
- en: Preceding the definition of the first grade() method, we add an @property
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 grade() 方法的定义前，我们添加了一个 @property 装饰器。
- en: decorator 2\. This defines the name grade as a property of any object cre-
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器 2\。这将定义名称 grade 作为任何创建的对象的属性。
- en: ated from this class. The first method 3 is a getter that just returns the
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个类创建的对象，第一种方法 3 是一个 getter 方法，只返回
- en: Encapsulation **175**
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **175**
- en: value of the current grade, kept in the private self.__grade instance variable,
    but could include any code that might be needed to calculate a value and
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 当前成绩的值存储在私有的 self.__grade 实例变量中，但也可以包含任何计算值所需的代码
- en: return it.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: return it.
- en: Preceding the second grade() method is an @grade.setter decorator 4\.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 grade() 方法前有一个 @grade.setter 装饰器 4\。
- en: This second method 5 accepts a new value as a parameter, does a num-
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 5 接受一个新值作为参数，进行一系列数值操作。
- en: ber of checks to ensure that value is valid, then sets the new value into
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一系列检查确保值有效，然后将新值设置到
- en: self.__grade.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: self.__grade.
- en: The __init__() method first stores the student’s name in an instance
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法首先将学生的姓名存储在实例中。
- en: variable. The next line 1 seems straightforward but is a little unusual. As
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。下一行 1 看似直接，但有些不寻常。正如
- en: we have seen, we typically store the values of parameters into instance vari-
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们通常将参数的值存储到实例变量中。
- en: 'ables. Therefore, we might be tempted to write this line as:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能会倾向于将这一行写成：
- en: self.__grade = startingGrade
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: self.__grade = startingGrade
- en: But instead, we are storing the starting grade into the property grade.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我们是将起始成绩存储到属性 grade 中。
- en: Since grade is a property, Python translates this assignment statement into
    a
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 grade 是一个属性，Python 会将此赋值语句转换为
- en: call to the setter method 5, which has the advantage of validating the input
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 setter 方法 5，这有一个验证输入的优点
- en: before storing the value in the instance variable self.__grade.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 在将值存储到实例变量 self.__grade 之前。
- en: Listing 8-7 provides some test code that uses the Student class.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7 提供了一些测试代码，使用了 Student 类。
- en: '**File: PropertyDecorator/Main_Property.py**'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PropertyDecorator/Main_Property.py**'
- en: Main Student property example
  id: totrans-1381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主学生属性示例
- en: 1 oStudent1= Student('Joe Schmoe')
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 1 oStudent1 = Student('Joe Schmoe')
- en: oStudent2= Student ('Jane Smith')
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: oStudent2 = Student('Jane Smith')
- en: Get the students' grades using the 'grade' property and print
  id: totrans-1384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 'grade' 属性获取学生的成绩并打印
- en: 2 print(oStudent1.grade)
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 2 print(oStudent1.grade)
- en: print(oStudent2.grade)
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: print(oStudent2.grade)
- en: print()
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: Set new values using the 'grade' property
  id: totrans-1388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 'grade' 属性设置新值。
- en: 3 oStudent1.grade = 85
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 3 oStudent1.grade = 85
- en: oStudent2.grade = 92
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: oStudent2.grade = 92
- en: 4 print(oStudent1.grade)
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 4 print(oStudent1.grade)
- en: print(oStudent2.grade)
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: print(oStudent2.grade)
- en: '*Listing 8-7: The main code that creates Student objects and accesses a property*
    In the test code, we first create two Student objects 1 and print the'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：创建 Student 对象并访问属性的主代码* 在测试代码中，我们首先创建两个 Student 对象 1 并打印当前'
- en: grade of each 2\. It looks like we’re reaching into each object directly to
    get
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 2 的成绩。看起来我们直接访问每个对象获取
- en: the grade values, but since grade is a property Python turns these lines into
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 成绩值，但由于 grade 是一个属性，Python 将这些行转换为
- en: calls to the getter method and returns the value of the private instance vari-
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 getter 方法并返回私有实例变量的值
- en: able self.__grade for each object.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个对象提供 self.__grade 属性。
- en: We then set new grade values for each Student object 3\. Here it looks
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为每个 Student 对象设置新的成绩值 3。在这里看起来
- en: like we’re setting values directly into each object’s data, but again, because
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们直接设置每个对象的数据一样，但再次强调，由于
- en: grade is a property, Python turns these lines into calls to the setter method.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成绩是一个属性，Python 会将这些行转换为调用 setter 方法。
- en: That method validates each value before doing the assignment. The test
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在进行赋值前验证每个值。测试
- en: code ends by printing the new values of the grades 4\.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最终会打印出新的成绩值 4\。
- en: '**176** Chapter 8'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '**176** 第8章'
- en: 'When we run the test code, we get this output, as we expect:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试代码时，得到的输出与预期一致：
- en: '0'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '85'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '85'
- en: '92'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '92'
- en: Using the @property and @ *<property_name>* .setter decorators gives you the
    best of both the direct access and getter-and-setter worlds. Client software
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @property 和 @ *<property_name>* .setter 装饰器，您可以同时享受直接访问和 getter/setter 两种方式的优点。客户端软件
- en: can be written in a way that *appears* to access instance variables directly,
    but as the class programmer, your decorated methods get and set the actual
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以写得*看似*直接访问实例变量，但作为类的开发者，您的装饰方法会获取并设置实际的
- en: instance variables owned by the object and even allow for validation of
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量由对象拥有，甚至可以进行验证
- en: inputs. This approach supports encapsulation because the client code is not
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 输入。这种方法支持封装，因为客户端代码不能
- en: accessing an instance variable directly.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问实例变量。
- en: While this technique is used by many professional Python developers,
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多专业的 Python 开发者使用这种技术，
- en: I personally find it a little ambiguous, because when I read other develop-
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人觉得它有些模糊，因为当我阅读其他开发者的
- en: ers’ code that uses this approach, it is not immediately apparent whether it’s
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用这种方法时，代码并不立即显现它是否
- en: using direct accesses to instance variables or using properties that Python
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接访问实例变量或使用 Python 的属性
- en: translates into calls to decorated methods. I prefer to use standard getter
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为对装饰方法的调用。我更喜欢使用标准的 getter
- en: and setter methods and will use them in the rest of this book.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 和 setter 方法，并将在本书的其余部分使用它们。
- en: '**Encapsulation in pygwidgets Classes**'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '**pygwidgets 类中的封装**'
- en: The definition of encapsulation at the start of this chapter focused on two
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时对封装的定义关注了两个
- en: 'areas: hiding internal details and having all related code in one place. All'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 区别：隐藏内部细节，并将所有相关代码集中在一个地方。所有
- en: the classes in pygwidgets were designed with these considerations in mind.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets 中的类设计时考虑了这些因素。
- en: As examples, consider the TextButton and CustomButton classes.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，考虑 TextButton 和 CustomButton 类。
- en: The methods of these two classes encapsulate all the functionality of
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类的方法封装了所有的功能
- en: GUI buttons. While the source code of these classes is available, there is no
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 按钮。虽然这些类的源代码是公开的，但没有
- en: need for a client programmer to look at it to use them effectively. There’s
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序员不需要查看它就能有效地使用它们。这里
- en: also no need for client code to attempt to access any of their instance vari-
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码也无需尝试访问它们的实例变量，
- en: 'ables: all button functionality is available through calling the methods of'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮功能都可以通过调用方法来实现，
- en: these classes. This adheres to the strict interpretation of encapsulation,
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类遵循了封装的严格解释，
- en: meaning that the *only* way that client software should access an object’s data
    is by calling that object’s methods. A client programmer can think of these
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端软件访问对象数据的*唯一*方式是通过调用该对象的方法。客户端程序员可以将这些
- en: classes as black boxes, since there is no reason to look at how they accom-
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 类作为黑盒使用，因为没有理由去查看它们是如何实现的。
- en: plish their tasks.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 完成他们的任务。
- en: '**N O T E**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*A whole* black box testing *industry has developed around the idea of a test
    programmer being given a class to test without being allowed to see the code of
    the class.*'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个完整的* 黑盒测试 *行业围绕着测试程序员在没有看到类代码的情况下被给定一个类进行测试的概念*。'
- en: '*The tester is only supplied with documentation of the interfaces, and with
    that writes* *code that tests all the interfaces under many different cases to
    ensure that all methods* *work as described. The set of tests not only ensures
    that the code and documentation* *match, but is used again whenever code is added
    or modified in the class to ensure* *that the changes have not broken anything.*'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试者只会获得接口的文档，并根据这些文档编写* *测试所有接口的代码，涵盖不同的情况，确保所有方法* *按描述工作。测试集不仅确保代码和文档一致*，*而且每当对类中的代码进行添加或修改时，还会再次使用这些测试*，*以确保更改没有破坏任何功能。*'
- en: Encapsulation **177**
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **177**
- en: '**A Story from the Real World**'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自现实世界的故事**'
- en: A number of years ago, I was involved in the design and development of
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我参与了一个非常大的教育项目的设计和开发
- en: a very large educational project that was built in an environment called
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常大的教育项目是在一个叫做 base 的环境中构建的
- en: '*Director* from Macromedia (later Adobe), using the object-oriented *Lingo*
    language. Director was designed to be extended through *XTRAs* that could'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Macromedia（后来的 Adobe）的 *Director*，使用面向对象的 *Lingo* 语言。Director 设计为通过 *XTRAs*
    扩展，XTRA 可以
- en: add functionality, similar to the way plug-ins are added to browsers. These
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 添加功能，类似于浏览器中插件的添加方式。这些
- en: XTRAs were developed and sold by a number of third-party vendors. In the
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: XTRA 是由多个第三方供应商开发并销售的。在
- en: design, we planned on storing navigational and other course-related infor-
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计时，我们计划存储导航和其他与课程相关的信息
- en: mation in a database. I looked at all the different database XTRAs that
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中的通信。我查看了所有不同的数据库 XTRA
- en: were available and purchased a particular XTRA, which I’ll call XTRA1\.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的 XTRA，最终购买了一个特定的 XTRA，称之为 XTRA1。
- en: Each XTRA came with documentation of its API, which showed how to
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 XTRA 都附带了其 API 文档，展示了如何
- en: make queries to the database using Structured Query Language (SQL). I
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构化查询语言（SQL）向数据库发起查询。我
- en: decided to create a Database class that incorporated all the functionality of
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定创建一个 Database 类，融合所有
- en: accessing the database using XTRA1’s API. That way, all code that commu-
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XTRA1 的 API 访问数据库。这样，所有与数据库交互的代码
- en: nicated with the XTRA directly was in the Database class. Figure 8-1 shows
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 直接与 XTRA 通信的代码位于 Database 类中。图 8-1 显示了
- en: the overall architecture.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 整体架构。
- en: Requests
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 请求
- en: info
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Builds
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 构建
- en: SQL
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: SQL
- en: Accesses
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 访问
- en: database
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库
- en: Main
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 主
- en: Database
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库
- en: Database
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库
- en: program
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 程序
- en: object
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: XTRA
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: XTRA
- en: Returns
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: results
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: Returns
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Database
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库
- en: Returns
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: results
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: results
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '*Figure 8-1: The architecture of accessing a database using an object and an
    XTRA* When the program started, it created a single instance of the Database'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：使用对象和 XTRA 访问数据库的架构* 当程序启动时，它创建了一个 Database 类的单一实例'
- en: class. The main code was a client of the Database object. Whenever the main
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 类。主代码是数据库对象的客户端。每当主代码
- en: code wanted information from the database, rather than formatting a SQL
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 代码希望从数据库中获取信息，而不是格式化 SQL
- en: query itself, it called a method of the Database object, supplying details about
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 查询本身，它调用了 Database 对象的一个方法，提供了有关
- en: what information it wanted. The methods in the Database object translated
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 想要什么信息时，数据库对象中的方法会将其转换
- en: each request into a SQL query made to XTRA1 to get data from the data-
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都会转化为一个 SQL 查询，发给 XTRA1 从数据库中获取数据
- en: base. That way, only the code of the Database object knew how to access the
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只有 Database 对象的代码知道如何访问
- en: XTRA using its API.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其 API 的 XTRA。
- en: The program worked well, and the customers enjoyed using the prod-
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行得很好，客户们都很喜欢使用这个产品
- en: uct. But every once in a while, we would run into errors in the data we got
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 这个产品。但偶尔，我们会遇到获取的数据中出现错误
- en: back from the database. I contacted the XTRA1 developer and gave many
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库返回的数据。我联系了 XTRA1 的开发者，提出了很多
- en: easily reproducible examples of the problems. Unfortunately, the developer
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 容易复制的例子中说明了这些问题。不幸的是，开发者
- en: never addressed these issues.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 从未解决这些问题。
- en: Because of the lack of response, we eventually decided to purchase a
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏回应，我们最终决定购买一个
- en: different database XTRA, XTRA2, to serve this purpose. XTRA2 worked in
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个数据库 XTRA，XTRA2，来实现这个目的。XTRA2 在
- en: '**178** Chapter 8'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: '**178** 第 8 章'
- en: a similar way but had some subtle differences in how it was initialized and
    required some minor changes in the way that SQL queries were built.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式工作，但在初始化和 SQL 查询构建方式上有一些微妙的差异，需要做一些小的修改。
- en: Because the Database class encapsulated all the details of communicat-
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Database 类封装了所有与通信相关的细节，
- en: ing with the XTRA, we were able to make all the necessary changes to work
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 与 XTRA 一起工作，我们能够进行所有必要的修改以使其正常工作
- en: with XTRA2 only in the Database class. We did not change a single line in
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在数据库类中使用 XTRA2。我们没有改动主程序中的任何一行
- en: the main program (the client code).
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序（客户端代码）。
- en: In this case, I was both the Database class developer and the client soft-
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我既是 Database 类的开发者，也是客户端软件的开发者
- en: ware developer. If my client code had used the names of instance variables
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员。如果我的客户端代码使用了实例变量的名称
- en: in the class, I would have had to crawl through the program, modifying
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在类中，我将不得不逐步修改程序中的代码，
- en: each line of relevant code. Using encapsulation with a class saved me from
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行相关的代码。通过使用类的封装，我避免了
- en: countless hours of reworking and testing.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 无数的返工和测试时间。
- en: As a follow-up to the story, while XTRA2 worked well, that company
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个故事的延续，虽然XTRA2表现良好，但该公司
- en: eventually went out of business and I had to go through the same process
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 最终破产了，我不得不经历同样的过程
- en: again. Once again, because of encapsulation, only the code of the Database
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于封装，只有数据库的代码
- en: class was modified to work with XTRA3\.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 类被修改以与XTRA3\一起工作。
- en: '**Abstraction**'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**'
- en: Abstraction is another OOP concept closely related to encapsulation; many
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是另一个与封装密切相关的OOP概念；许多
- en: developers consider it to be the fourth tenet of OOP.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员认为它是面向对象编程（OOP）的第四条原则。
- en: Whereas encapsulation is about implementation, hiding the details of
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 封装关注的是实现，隐藏了
- en: the code and data that make up a class, *abstraction* is about the client’s
    view of a class. It’s about the perception of a class from the outside.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和数据构成一个类，*抽象*是关于客户端如何看待这个类的。这是关于从外部看待类的感知。
- en: '**abstraction**'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**'
- en: Handling complexity by hiding unnecessary details .
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隐藏不必要的细节来处理复杂性。
- en: Essentially, abstraction is a reminder to make sure that the user’s view
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，抽象提醒我们确保用户看到的视图
- en: of a system is as simple as possible.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的设计应尽可能简单。
- en: Abstraction is extremely common in consumer products. Many people
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象在消费品中非常常见。许多人
- en: use TVs, computers, microwave ovens, cars, and so on every day. We become
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 每天都使用电视、电脑、微波炉、汽车等。我们变得
- en: comfortable with the user interface that these products extend to us. Through
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些产品扩展的用户界面，我们变得
- en: their controls, they provide an abstraction of their functionality. You press
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的控制界面提供了功能的抽象。你按下
- en: the accelerator pedal in a car to make it go forward. With a microwave, you
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车中的加速踏板使其向前行驶。用微波炉时，你
- en: set an amount of time and press Start to heat up some food. But few of us
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 设置时间并按开始键来加热食物。但是很少有人
- en: really know how these products work internally.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 真正了解这些产品如何在内部工作。
- en: Here’s an example of abstraction from the world of computer science.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算机科学中抽象的一个例子。
- en: In programming, a *stack* is a mechanism for remembering data in a *last in,*
    *first out* *(LIFO)* order. Think of a pile of plates, where clean plates are
    added to the top and users take one from the top when they need a plate. A stack
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*栈*是一种按*后进先出*（*LIFO*）顺序记住数据的机制。可以把它想象成一堆盘子，干净的盘子被放在最上面，用户需要盘子时从最上面拿取。栈
- en: 'has two standard operations: push adds an item to the top of the stack, and'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个标准操作：push将项目添加到栈顶，和
- en: pop removes the topmost item from the stack.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: pop从栈中移除最上面的项目。
- en: A stack is particularly useful whenever your program does any naviga-
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你的程序进行任何导航时，栈特别有用
- en: tion because it can be used to leave a trail of breadcrumbs for finding your
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它可以用来留下寻找你
- en: way back. This is how programming languages keep track of the execution
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的方式。这就是编程语言跟踪执行
- en: 'of function and method calls in code: when you call a function or method,'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法调用的过程：当你调用一个函数或方法时，
- en: the return point is pushed onto a stack, and when the function or method
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 返回点被推入栈中，当函数或方法
- en: Encapsulation **179**
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **179**
- en: returns, the place to return to is discovered by popping the most recent information
    off the top of the stack. In this way, code can make as many
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 返回时，通过弹出栈顶的最新信息来发现返回的位置。这样，代码可以进行任意数量的
- en: levels of calls as you need, and it always unwinds correctly.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要调用的层级，它总是能够正确地展开。
- en: As an abstraction, suppose a client program required the functional-
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种抽象，假设客户端程序需要功能
- en: ity of a stack that would be simple to create and would provide the ability
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的特性使其容易创建，并提供了
- en: to push and pop information. If this were written as a class, the client code
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 用来推送和弹出信息。如果将其编写为一个类，客户端代码
- en: 'would create a stack like this:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个这样的栈：
- en: oStack = Stack()
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: oStack = Stack()
- en: 'A client would add information by calling a push() method like this:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过像这样调用push()方法来添加信息：
- en: oStack.push( *<someData>* )
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: oStack.push( *<someData>* )
- en: And it would retrieve the most recent data by calling a pop() method
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 它将通过调用pop()方法来检索最新的数据
- en: 'like this:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '*<someVariable>* = oStack.pop()'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: '*<someVariable>* = oStack.pop()'
- en: The client would not need to know or care how these methods were
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端无需知道或关心这些方法如何实现
- en: implemented or how the data was stored. The implementation of the Stack
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的实现或者数据如何存储。栈的实现
- en: would be handled completely by the methods of the Stack.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将完全由 Stack 类的方法处理。
- en: While the client code could view a Stack class as a black box, writing
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管客户端代码可能将 Stack 类视为一个黑盒，但编写
- en: such a class in Python is fairly trivial. Listing 8-8 shows how it could be
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中实现这样的类相对简单。清单 8-8 显示了它如何
- en: implemented.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 实现。
- en: '**File: Stack/Stack.py**'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Stack/Stack.py**'
- en: Stack class
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stack 类
- en: 'class Stack():'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '类 Stack():'
- en: ''''''' Stack class implements a last in first out LIFO algorithm'''''''
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''' Stack 类实现了一个先进后出（LIFO）算法'''''''
- en: 'def __init__(self, startingStackAsList=None):'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, startingStackAsList=None):'
- en: 'if startingStackAsList is None:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 startingStackAsList 为 None：
- en: 1 self.dataList = [ ]
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 1 self.dataList = [ ]
- en: 'else:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'self.dataList = startingStackAsList[:] # make a copy'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.dataList = startingStackAsList[:]  # 创建一个副本'
- en: '2 def push(self, item):'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def push(self, item):'
- en: self.dataList.append(item)
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: self.dataList.append(item)
- en: '3 def pop(self):'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def pop(self):'
- en: 'if len(self.dataList) == 0:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 len(self.dataList) == 0：
- en: raise IndexError
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 IndexError
- en: element = self.dataList.pop()
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 元素 = self.dataList.pop()
- en: return element
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元素
- en: '**180** Chapter 8'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '**180** 第8章'
- en: '4 def peek(self):'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def peek(self):'
- en: Retrieve the top item, without removing it
  id: totrans-1564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取栈顶元素，而不移除它
- en: item = self.dataList[-1]
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: item = self.dataList[-1]
- en: return item
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 返回项目
- en: '5 def getSize(self):'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def getSize(self):'
- en: nElements = len(self.dataList)
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: nElements = len(self.dataList)
- en: return nElements
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 nElements
- en: '6 def show(self):'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def show(self):'
- en: Show the stack in a vertical orientation
  id: totrans-1571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示栈的垂直排列
- en: print('Stack is:')
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: print('栈内容为：')
- en: 'for value in reversed(self.dataList):'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 对 self.dataList 进行反转遍历：
- en: print(' ', value)
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: print(' ', value)
- en: '*Listing 8-8: A stack as a Python class*'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-8：作为 Python 类的栈*'
- en: The Stack class keeps track of all the data using a list instance variable
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: Stack 类通过一个列表实例变量来跟踪所有的数据
- en: named self.dataList 1\. The client doesn’t need to know this level of detail,
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 self.dataList 1。客户端不需要知道这一层细节，
- en: but push() 2 just adds an item to the internal list using the Python append()
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 push() 2 只是通过 Python 的 append() 方法将项目添加到内部列表
- en: operation, while pop() 3 pops the last element from the internal list. Because
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 而 pop() 3 将最后一个元素从内部列表中弹出。因为
- en: it is easy to do, this implementation of the Stack class also implements three
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 它很容易实现，这个 Stack 类的实现也包括了三个
- en: 'additional methods:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法：
- en: • peek() 4 allows the caller to obtain the data at the top of the stack with-
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: • peek() 4 允许调用者获取栈顶的数据，而不移除它
- en: out removing it from the stack.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 从栈中移除它。
- en: • getSize() 5 returns the number of items on the stack.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: • getSize() 5 返回栈中的项目数量。
- en: • show() 6 prints the contents of the stack in the way that the client
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: • show() 6 打印栈的内容，按照客户端
- en: 'thinks of a stack: the data is displayed vertically, with the most recent'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个栈：数据垂直显示，最新的操作
- en: data pushed shown at the top. This can be helpful in debugging client
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 数据推送显示在顶部。这在调试客户端
- en: code that involves multiple calls to push() and pop().
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及多次调用 push() 和 pop() 的代码。
- en: This was an extremely simple example, but as you gain more experience
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，但随着你经验的积累
- en: writing classes, your classes will typically become more complex. Along the
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类时，你的类通常会变得更复杂。随着
- en: way, you may find cleaner and more efficient ways of writing some methods
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可能会找到更简洁、更高效的方式来编写一些方法
- en: and perhaps rewrite them. Because objects provide both encapsulation and
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可能会重写它们。因为对象提供了封装和
- en: abstraction, as the writer of a class, you should feel free to modify its code
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象，作为一个类的编写者，你应该自由修改其代码
- en: and data, as long as the published interfaces do not change. Changes to the
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 并且数据，只要发布的接口不变。对代码的更改
- en: implementation of methods should have no ill effects on client software but
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实现不应该对客户端软件产生不良影响
- en: rather should allow you to make improvements without affecting any client
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，应该允许你在不影响任何客户端代码的情况下进行改进
- en: code. In fact, if you find ways to make your code more efficient and publish
    a
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 代码。事实上，如果你找到方法让你的代码更加高效并发布一个
- en: new version, client code may appear to speed up, with zero changes required
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的客户端代码可能看起来更快，且无需做任何更改
- en: to that code.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 到那段代码。
- en: A property is an excellent example of abstraction. As you saw earlier,
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是抽象的一个极好例子。正如你之前所看到的，
- en: with properties the client programmer can use a syntax that makes their
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性时，客户端程序员可以使用一种语法，使得他们
- en: intent clear (to get and set a value in an object). The implementation in the
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 意图明确（获取和设置对象中的值）。在此
- en: methods that are called as a result can be much more complicated, but is
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用的结果可能会更加复杂，但应该
- en: totally hidden from the client code.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 完全隐藏于客户端代码之外。
- en: Encapsulation **181**
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 封装 **181**
- en: '**Summary**'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Encapsulation is the first major tenet of object-oriented programming,
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程的第一个主要原则，
- en: allowing classes to hide their implementation and data from client code
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 允许类隐藏它们的实现和数据，避免暴露给客户端代码
- en: and ensuring that a class provides all the functionality that a client needs
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 并确保类提供客户端所需的所有功能
- en: in a single place.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个地方实现。
- en: A key concept of OOP is that objects own their data, and that’s why
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个关键概念是对象拥有它们的数据，这就是
- en: I recommend that you provide getter and setter methods if you want cli-
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你提供getter和setter方法，如果你希望客户端
- en: ent code to access the data held in an instance variable. Python does
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 外部代码访问实例变量中的数据。Python并不
- en: allow direct access to instance variables using dot syntax, but I strongly
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 允许通过点符号直接访问实例变量，但我强烈
- en: encourage you to stay away from this syntax for the reasons laid out in
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你避免使用这种语法，原因已在
- en: this chapter.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容。
- en: There are conventions for marking instance variables and methods as
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 有约定用来标记实例变量和方法为
- en: private, using a leading underscore or double underscore depending on the
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 私有化，使用前导下划线或双下划线，具体取决于
- en: level of privatization you require. As a compromise, Python also allows the
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所需的私有化级别进行限制。作为折衷，Python还允许
- en: use of the @property decorator. This makes it appear as if the client code is
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 使用@property装饰器。这使得客户端代码看起来像是在
- en: able to access an instance variable directly, while behind the scenes Python
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 能够直接访问实例变量，而在幕后，Python
- en: turns such references into calls to the decorated getter and setter methods
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类引用转化为对装饰过的getter和setter方法的调用
- en: in the class.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中。
- en: The pygwidgets package provides many good examples of encapsulation.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets包提供了许多封装的良好示例。
- en: As a client programmer, you see a class from the outside and work with the
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 作为客户端程序员，你从外部看到一个类，并与
- en: interfaces that the class provides. As a class designer, abstraction—handling
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供的接口。作为类的设计者，抽象——处理
- en: complexity by hiding details—helps you design a good interface by consid-
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隐藏细节来减少复杂性——帮助你通过考虑设计良好的接口
- en: ering the interface of the class from the client’s point of view. However, in
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端角度考虑类的接口。然而，在
- en: Python, you often have the source code available so that you can look at the
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你通常可以查看源代码，这样你可以查看
- en: implementation if you wish.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以提供实现。
- en: '**182** Chapter 8'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '**182** 第8章'
- en: '**9**'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**P O LY M O R P H I S M**'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**'
- en: This chapter is about the second major
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解第二个主要原则
- en: 'tenet of OOP: *polymorphism*. Its component'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的基本原则之一：*多态*。它的组成部分
- en: 'parts are from the Greek: the prefix *poly*'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分来自希腊语：前缀*poly*
- en: means “much” or “many,” and *morphism* means
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着“多”或“许多”，而*morphism*意思是
- en: “shape,” “form,” or “structure.”
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: “形状”、“形式”或“结构”。
- en: So, *polymorphism* essentially means *many forms*. I’m not talking about a *Star
    Trek*–style shape-shifting alien—in fact, it’s quite the opposite. Rather than
    one thing taking on many shapes, polymorphism in OOP is about
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*多态*本质上意味着*多种形式*。我不是在谈论一种*星际迷航*风格的变形外星人——实际上，它是完全相反的。与其说是一个事物变成多种形态，不如说面向对象编程中的多态是关于
- en: how multiple classes can have methods with the exact same names. This
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让多个类拥有相同名称的方法。这个
- en: will eventually give us a highly intuitive way to act on a collection of objects,
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将获得一种高度直观的方式来操作一组对象，
- en: independent of what class each came from.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 无论每个方法来自哪个类，它们的行为是独立的。
- en: OOP programmers often use the term “send a message” when we talk
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的程序员通常会使用“发送消息”这个术语来描述
- en: about client code calling a method of an object. What the object should do
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 关于客户端代码调用对象的方法。对象应该做什么
- en: when it receives the message is up to the object. With polymorphism, we can
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 当它接收到消息时，做什么由对象决定。通过多态，我们可以
- en: send the same message to multiple objects, and each object will react differ-
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 发送相同的消息给多个对象，每个对象将作出不同反应，
- en: ently depending on what it’s designed to do and the data available to it.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它的设计和可用的数据，可能会有所不同。
- en: In this chapter, I’ll discuss how this ability allows you to build pack-
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论这种能力如何让你构建封装
- en: ages of classes that are easily extensible and predictable. We’ll also use
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 提供易于扩展和可预测的类的优点。我们还将使用
- en: polymorphism with operators to make the same operators perform different operations
    depending on the data types they are working with. Finally,
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符的多态性使相同的运算符根据它们所处理的数据类型执行不同的操作。最后，
- en: I’ll show you how to use the print() function to get valuable debugging
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何使用print()函数来获取有价值的调试
- en: information from objects.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象中获取信息。
- en: '**Sending Messages to Real-World Objects**'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '**向现实世界的对象发送消息**'
- en: Let’s look at polymorphism in the real world, using cars as an example. All
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用汽车作为例子来看看现实世界中的多态性。所有
- en: cars have an accelerator pedal. When the driver presses that pedal, they’re
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车有加速踏板。当驾驶员踩下那个踏板时，它们会
- en: sending the “accelerate” message to the car. The car they’re driving could
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 发送“加速”消息给汽车。驾驶的汽车可能会
- en: have an internal combustion engine or an electric motor, or be a hybrid.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 都配备有内燃机或电动机，或者是混合动力。
- en: Each of these types of cars has its own implementation of what happens
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的汽车都有自己的实现方式来处理加速消息，
- en: when it receives the accelerate message, and each behaves accordingly.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 当它接收到加速消息时，每个对象会根据自身行为做出反应。
- en: Polymorphism allows for easier adoption of new technology. If some-
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性让新技术更容易被采纳。如果某个
- en: one were to develop a nuclear-powered car, the user interface of the car
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人开发了一辆核能汽车，汽车的用户界面
- en: would remain the same—the driver would still press the accelerator pedal
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 保持一致——驾驶员仍然会踩下加速踏板
- en: to send the same message—but a very different mechanism would make the
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 发送相同的消息——但实现机制完全不同，使得
- en: nuclear-powered car go faster.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 核能汽车会加速。
- en: As another real-world example, imagine you enter a large room with a
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个现实世界的例子，假设你走进一个大房间，里面有
- en: bank of light switches that control a variety of different lights. Some of the
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 控制各种不同灯光的电灯开关组合。有些灯泡是
- en: bulbs are old-style incandescent bulbs, some are fluorescent, and some are
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 灯泡有的是旧式的白炽灯泡，有的是荧光灯泡，有的是
- en: newer LED bulbs. When you flip all the switches up, you are sending the
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的LED灯泡。当你把所有的开关都打开时，你实际上是在发送
- en: “turn on” message to all the bulbs. The underlying mechanisms that cause
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 向所有灯泡发送“打开”的消息。导致灯泡发光的底层机制
- en: incandescent, fluorescent, and LED bulbs to emit light are wildly different,
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 白炽灯、荧光灯和LED灯泡发光的方式有很大不同，
- en: but each achieves the user’s intended goal.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 但每种方式都能实现用户的目标。
- en: '**A Classic Example of Polymorphism in Programming**'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程中多态性的经典示例**'
- en: In terms of OOP, polymorphism is about how client code can call a method
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，多态性指的是客户端代码如何调用
- en: with the exact same name in different objects, and each object will do what-
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同方法名但在不同对象中进行实现，且每个对象执行不同的操作。
- en: ever it needs to do to implement the meaning of that method for that object.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 它将根据该对象的需求执行方法的实际意义。
- en: The classic example of polymorphism is to consider code that repre-
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性的经典示例是考虑代码中
- en: sents different types of pets. Let’s say you have a collection of dogs, cats,
    and
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不同类型的宠物的集合。假设你有一群狗、猫和
- en: birds, and each understands some basic commands. If you ask these pets
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 狗、猫和鸟会理解一些基本命令。如果你问这些宠物
- en: to speak (that is, you send the “speak” message to each), the dogs will say
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 以说话（也就是说，你将“speak”消息发送给每个对象），狗会说
- en: “bark,” the cats will say “meow,” and the birds will say “tweet.” Listing 9-1
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: “汪”，猫会说“喵”，鸟会说“叽叽”。列出 9-1
- en: shows how we might implement this in code.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了我们如何在代码中实现这一点。
- en: '**File: PetsPolymorphism.py**'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PetsPolymorphism.py**'
- en: Pets polymorphism
  id: totrans-1683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宠物的多态性
- en: Three classes, all with a different "speak" method
  id: totrans-1684
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个类，每个类都有不同的 "speak" 方法
- en: 'class Dog():'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Dog():'
- en: 'def __init__(self, name):'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: '**184** Chapter 9'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '**184** 第9章'
- en: '1 def speak(self):'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def speak(self):'
- en: print(self.name, 'says bark, bark, bark!')
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: print(self.name, '说汪汪汪！')
- en: 'class Cat():'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Cat():'
- en: 'def __init__(self, name):'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: '2 def speak(self):'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def speak(self):'
- en: print(self.name, 'says meeeoooow')
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: print(self.name, '说喵喵喵')
- en: 'class Bird():'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Bird():'
- en: 'def __init__(self, name):'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: '3 def speak(self):'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def speak(self):'
- en: print(self.name, 'says tweet')
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: print(self.name, '说叽叽')
- en: oDog1 = Dog('Rover')
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: oDog1 = Dog('Rover')
- en: oDog2 = Dog('Fido')
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: oDog2 = Dog('Fido')
- en: oCat1 = Cat('Fluffy')
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: oCat1 = Cat('Fluffy')
- en: oCat2 = Cat('Spike')
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: oCat2 = Cat('Spike')
- en: oBird = Bird('Big Bird')
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: oBird = Bird('大鸟')
- en: 4 petsList = [oDog1, oDog2, oCat1, oCat2, oBird]
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 4 petsList = [oDog1, oDog2, oCat1, oCat2, oBird]
- en: Send the same message (call the same method) of all pets
  id: totrans-1707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送相同的消息（调用相同的方法）给所有宠物
- en: 'for oPet in petsList:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 petsList 中的每个 oPet：
- en: 5 oPet.speak()
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 5 oPet.speak()
- en: '*Listing 9-1: Sending the “speak” message to objects instantiated from different
    classes* Each class has a speak() method, but the content of each method'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 9-1：向从不同类实例化的对象发送“speak”消息* 每个类都有一个 speak() 方法，但每个方法的内容'
- en: is different 1 2 3\. Each class does whatever it needs to do in its ver-
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 是不同的 1 2 3\. 每个类都根据其实现方式做出响应
- en: sion of this method; the method name is the same, but it has different
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的实现；方法名相同，但实现不同
- en: implementations.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 实现。
- en: To make things easy to deal with, we put all the pet objects into a list 4\.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于处理，我们将所有宠物对象放入一个列表4中。
- en: To make them all speak, we then loop through all the objects and send
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它们都发声，我们循环遍历所有对象并发送
- en: the same message by calling a method with the exact same name in each
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用每个类中具有相同名称的方法来传递相同的消息
- en: object 5, without worrying about the type of the object.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 对象5，用户无需担心对象的类型。
- en: '**Example Using Pygame Shapes**'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Pygame形状的示例**'
- en: Next, we’ll look at a demonstration of polymorphism using pygame. In
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看使用pygame的多态性演示。在
- en: '[Chapter 5 w](index_split_002.html#p118)e used pygame to draw primitive shapes
    such as rectangles, circles, polygons, ellipses, and lines. Here we’ll build a
    demonstration'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章 w](index_split_002.html#p118)我们使用pygame绘制了矩形、圆形、多边形、椭圆形和直线等基本形状。在这里，我们将构建一个演示'
- en: program that will randomly create and draw different shapes in a window.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将随机创建并绘制不同的形状到窗口中。
- en: The user can then click on any shape, and the program will report the
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以点击任何形状，程序将报告
- en: type and area of the shape that was clicked. Because the shapes are ran-
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的类型和面积。
- en: domly created, each time the program runs, the size, location, number,
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 随机创建，每次程序运行时，形状的大小、位置、数量，
- en: and position of the shapes will be different. Figure 9-1 shows some sample
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 和形状的不同。图9-1展示了一些示例
- en: output from the demonstration program.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 演示程序的输出。
- en: Polymorphism **185**
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性 **185**
- en: '![Image 27](index-215_1.png)'
  id: totrans-1728
  prefs: []
  type: TYPE_IMG
  zh: '![图片 27](index-215_1.png)'
- en: '*Figure 9-1: A pygame-based example of using polymorphism to draw different
    shapes* We’ll implement the program with a class for each of three different shapes:
    Square, Circle, and Triangle. The key thing to note here is that'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：基于pygame的使用多态性绘制不同形状的示例* 我们将实现一个程序，每种不同的形状（方形、圆形和三角形）都有一个类。这里需要注意的是'
- en: all three shape classes contain methods with the same names, __init__(),
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个形状类都包含具有相同名称的方法：__init__()，
- en: draw(), getType(), getArea(), and clickedInside(), that perform the same tasks.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: draw(), getType(), getArea(), 和 clickedInside()，这些方法执行相同的任务。
- en: However, the implementation of each method is different because each
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个方法的实现不同，因为每个
- en: class deals with a different shape.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 类处理的是不同的形状。
- en: '***The Square Shape Class***'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '***方形形状类***'
- en: I’ll start with the simplest shape. Listing 9-2 shows the code of the Square
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从最简单的形状开始。列表9-2展示了方形的代码
- en: class.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 类。
- en: '**File: Shapes/Square.py**'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Shapes/Square.py**'
- en: Square class
  id: totrans-1738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方形类
- en: import pygame
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 导入pygame
- en: import random
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 导入random
- en: Set up the colors
  id: totrans-1741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: RED = (255, 0, 0)
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 红色 = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色 = (0, 255, 0)
- en: BLUE = (0, 0, 255)
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色 = (0, 0, 255)
- en: 'class Square():'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Square():'
- en: '**186** Chapter 9'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '**186** 第9章'
- en: '1 def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __init__(self, window, maxWidth, maxHeight):'
- en: self.window = window
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.widthAndHeight = random.randrange(10, 100)
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: self.widthAndHeight = random.randrange(10, 100)
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(1, maxWidth - 100)
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(25, maxHeight - 100)
- en: self.rect = pygame.Rect(self.x, self.y, self.widthAndHeight,
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y, self.widthAndHeight,
- en: self.widthAndHeight)
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: self.widthAndHeight)
- en: self.shapeType = 'Square'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: self.shapeType = 'Square'
- en: '2 def clickedInside(self, mousePoint):'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def clickedInside(self, mousePoint):'
- en: clicked = self.rect.collidepoint(mousePoint)
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: clicked = self.rect.collidepoint(mousePoint)
- en: return clicked
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 返回clicked
- en: '3 def getType(self):'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def getType(self):'
- en: return self.shapeType
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 返回self.shapeType
- en: '4 def getArea(self):'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def getArea(self):'
- en: theArea = self.widthAndHeight * self.widthAndHeight
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = self.widthAndHeight * self.widthAndHeight
- en: return theArea
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 返回theArea
- en: '5 def draw(self):'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def draw(self):'
- en: pygame.draw.rect(self.window, self.color,
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.rect(self.window, self.color,
- en: (self.x, self.y, self.widthAndHeight,
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: (self.x, self.y, self.widthAndHeight,
- en: self.widthAndHeight))
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: self.widthAndHeight))
- en: '*Listing 9-2: The Square class*'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-2：方形类*'
- en: In the __init__() method 1, we set up a number of instance variables to
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 在__init__()方法1中，我们设置了多个实例变量来
- en: use in the methods of the class. That lets us keep the code of the methods
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的方法中使用。这让我们能够保持方法代码的
- en: very simple. Since the __init__() method saved the rectangle of the Square,
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。由于__init__()方法保存了方形的矩形，
- en: the clickedInside() method 2 just checks if the location of a mouse click was
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: clickedInside()方法2仅检查鼠标点击的位置是否
- en: inside that rectangle, returning True or False.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 在该矩形内部，返回True或False。
- en: The getType() method 3 simply returns the information that the item
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: getType()方法3仅返回被点击形状的类型和面积信息。由于形状是随机创建的，
- en: clicked is a square. The getArea() method 4 multiplies the width by the
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: clicked 是一个正方形。getArea() 方法 4 将宽度与
- en: height and returns the resulting area. The draw() method 5 uses pygame’s
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: height 并返回计算得到的面积。draw() 方法 5 使用 pygame 的
- en: draw.rect() to draw the shape in the randomly chosen color.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: draw.rect() 用于用随机选择的颜色绘制形状。
- en: '***The Circle and Triangle Shape Classes***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '***Circle 和 Triangle 形状类***'
- en: Next, let’s take a look at the code of the Circle and the Triangle classes.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Circle 类和 Triangle 类的代码。
- en: The important thing to notice is that these classes have methods with the
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是，这些类包含具有以下功能的方法
- en: same names as the Square class, but the code in these methods (especially
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Square 类的方法有相同的名称，但这些方法中的代码（特别是
- en: clickedInside() and getArea()) is very different. Listing 9-3 shows the Circle
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: clickedInside() 和 getArea() 方法的区别非常大。列表 9-3 展示了 Circle
- en: class. Listing 9-4 shows the Triangle class that creates randomly sized right
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: class。列表 9-4 展示了 Triangle 类，该类创建了随机大小的直角
- en: triangles whose edges are parallel to the x- and y-axes, with the right angle
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形的边与 x 和 y 轴平行，且有一个直角
- en: in the upper-left corner.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 在左上角。
- en: Polymorphism **187**
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性 **187**
- en: '**File: Shapes/Circle.py**'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Shapes/Circle.py**'
- en: Circle class
  id: totrans-1788
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Circle 类
- en: import pygame
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: import random
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: import math
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: Set up the colors
  id: totrans-1792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: RED = (255, 0, 0)
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: RED = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = (0, 255, 0)
- en: BLUE = (0, 0, 255)
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: BLUE = (0, 0, 255)
- en: 'class Circle():'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Circle():'
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight):'
- en: self.window = window
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(1, maxWidth - 100)
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(25, maxHeight - 100)
- en: self.radius = random.randrange(10, 50)
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: self.radius = random.randrange(10, 50)
- en: self.centerX = self.x + self.radius
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: self.centerX = self.x + self.radius
- en: self.centerY = self.y + self.radius
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: self.centerY = self.y + self.radius
- en: self.rect = pygame.Rect(self.x, self.y,
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y,
- en: self.radius * 2, self.radius * 2)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: self.radius * 2, self.radius * 2)
- en: self.shapeType = 'Circle'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: self.shapeType = 'Circle'
- en: '1 def clickedInside(self, mousePoint):'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def clickedInside(self, mousePoint):'
- en: distance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: distance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +
- en: ((mousePoint[1] - self.centerY) ** 2))
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: ((mousePoint[1] - self.centerY) ** 2))
- en: 'if distance <= self.radius:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 'if distance <= self.radius:'
- en: return True
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'else:'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return False
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: '2 def getArea(self):'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def getArea(self):'
- en: theArea = math.pi * (self.radius ** 2) squared
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = math.pi * (self.radius ** 2) 平方
- en: return theArea
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: return theArea
- en: 'def getType(self):'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getType(self):'
- en: return self.shapeType
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: return self.shapeType
- en: '3 def draw(self):'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def draw(self):'
- en: pygame.draw.circle(self.window, self.color,
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.circle(self.window, self.color,
- en: (self.centerX, self.centerY),
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: (self.centerX, self.centerY),
- en: self.radius, 0)
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: self.radius, 0)
- en: '*Listing 9-3: The Circle class*'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：Circle 类*'
- en: '**188** Chapter 9'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '**188** 第9章'
- en: '**File: Shapes/Triangle.py**'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Shapes/Triangle.py**'
- en: Triangle class
  id: totrans-1827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Triangle 类
- en: import pygame
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: import random
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: Set up the colors
  id: totrans-1830
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: RED = (255, 0, 0)
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: RED = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = (0, 255, 0)
- en: BLUE = (0, 0, 255)
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: BLUE = (0, 0, 255)
- en: 'class Triangle():'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Triangle():'
- en: 'def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight):'
- en: self.window = window
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.width = random.randrange(10, 100)
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = random.randrange(10, 100)
- en: self.height = random.randrange(10, 100)
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = random.randrange(10, 100)
- en: self.triangleSlope = -1 * (self.height / self.width)
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: self.triangleSlope = -1 * (self.height / self.width)
- en: self.color = random.choice((RED, GREEN, BLUE))
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = random.choice((RED, GREEN, BLUE))
- en: self.x = random.randrange(1, maxWidth - 100)
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(1, maxWidth - 100)
- en: self.y = random.randrange(25, maxHeight - 100)
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(25, maxHeight - 100)
- en: self.rect = pygame.Rect(self.x, self.y,
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = pygame.Rect(self.x, self.y,
- en: self.width, self.height)
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height)
- en: self.shapeType = 'Triangle'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: self.shapeType = 'Triangle'
- en: '4 def clickedInside(self, mousePoint):'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def clickedInside(self, mousePoint):'
- en: inRect = self.rect.collidepoint(mousePoint)
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: inRect = self.rect.collidepoint(mousePoint)
- en: 'if not inRect:'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not inRect:'
- en: return False
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: Do some math to see if the point is inside the triangle
  id: totrans-1850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行一些数学运算，查看该点是否在三角形内
- en: xOffset = mousePoint[0] - self.x
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: xOffset = mousePoint[0] - self.x
- en: yOffset = mousePoint[1] - self.y
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: yOffset = mousePoint[1] - self.y
- en: 'if xOffset == 0:'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 'if xOffset == 0:'
- en: return True
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: Calculate the slope (rise over run)
  id: totrans-1855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算斜率（上升除以运行）
- en: pointSlopeFromYIntercept = (yOffset - self.height) / xOffset
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: pointSlopeFromYIntercept = (yOffset - self.height) / xOffset
- en: 'if pointSlopeFromYIntercept < self.triangleSlope:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 'if pointSlopeFromYIntercept < self.triangleSlope:'
- en: return True
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: 'else:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return False
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'def getType(self):'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getType(self):'
- en: return self.shapeType
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: return self.shapeType
- en: '5 def getArea(self):'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def getArea(self):'
- en: theArea = .5 * self.width * self.height
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: theArea = .5 * self.width * self.height
- en: return theArea
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: return theArea
- en: Polymorphism **189**
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性 **189**
- en: '6 def draw(self):'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def draw(self):'
- en: pygame.draw.polygon(self.window, self.color,
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.polygon(self.window, self.color,
- en: ((self.x, self.y + self.height),
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: ((self.x, self.y + self.height),
- en: (self.x, self.y),
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: （self.x, self.y），
- en: (self.x + self.width, self.y)))
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: (self.x + self.width, self.y)))
- en: '*Listing 9-4: The Triangle class*'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-4: 三角形类*'
- en: To understand the polymorphism at work here, let’s look at the
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这里的多态性，我们来看一下
- en: codeof the clickedInside() method for each shape. The clickedInside()
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: clickedInside()方法的代码。clickedInside()
- en: 'method of the Square class was very simple: a check to see if the mouse'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形类的method非常简单：检查鼠标
- en: click occurred inside the rectangle of the Square. The details of the cal-
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 点击发生在正方形的矩形内部。计算细节
- en: culations for clickedInside() in the Circle and Triangle classes are not par-
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形和三角形类中clickedInside()的计算并不完全相同，
- en: ticularly important, but they clearly are doing different calculations. The
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是，它们显然在进行不同的计算。每个形状的
- en: clickedInside() method of the Circle class 1 only reports a click if the user
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形类的clickedInside()方法 1 仅在用户
- en: clicks on a colored pixel of the shape. That is, it detects a click that is
    within
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 点击形状的彩色像素。也就是说，它检测的是点击是否位于
- en: the bounding rectangle of the circle, but the click must also be within the
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的边界矩形内，但点击也必须在
- en: radius of the circle for it to count as a click. The clickedInside() method
    of
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的半径才会被算作一次点击。圆形类的clickedInside()方法
- en: the Triangle class 4 must determine if the user has clicked on a pixel inside
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形类 4 必须判断用户是否点击了位于内部的像素
- en: the colored triangular portion of the rectangle. The methods in all three
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的彩色三角形部分内。所有三个方法中的方法
- en: classes accept a mouse click as a parameter and return either True or False
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类接受鼠标点击作为参数，并返回True或False
- en: as a result.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 结果。
- en: The getArea() 2 5 and draw() methods 3 6 of these classes have names
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的getArea() 2 5和draw() 3 6方法具有名称
- en: that are identical to methods of the Square class, but they do different work
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 与正方形类的方法相同，但它们做的是不同的工作
- en: internally. There’s a different calculation for area, and they draw different
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 内部有所不同。它们的面积计算不同，绘制的方式也不同
- en: shapes.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 形状。
