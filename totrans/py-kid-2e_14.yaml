- en: '12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finishing Your First Game: Bounce!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we got started building our first game, *Bounce*!,
    by creating a canvas and adding a bouncing ball to our code. Right now, our ball
    will bounce around the screen forever, which doesn’t make for much of a game.
    In this chapter, we’ll add a paddle for the player to use. We’ll also add an element
    of chance to the game, which will make it more challenging and fun to play.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Paddle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s not much fun to be had with a bouncing ball when there’s nothing to
    hit it with. So let’s create a paddle!
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by adding the following code directly after the Ball class to create
    a paddle (you’ll put this in a new line below the ball’s draw function):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0186-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This added code is almost exactly the same as what we did with our first version
    of the Ball class, except that we call create_rectangle (rather than create_oval)
    and we move the rectangle to position 200, 300 (200 pixels across and 300 pixels
    down).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at the bottom of your code listing, create an object of the Paddle class,
    and then change the main loop to call the paddle’s draw function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Changes can be seen at ➊ and ➋. If you run the game now, you should see the
    bouncing ball and a stationary rectangular paddle ([Figure 12-1](ch12.xhtml#ch12fig01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Ball and paddle*'
  prefs: []
  type: TYPE_NORMAL
- en: Making the Paddle Move
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the paddle move left and right, we’ll use event bindings to bind the
    *left* and *right* arrow keys to new functions in the Paddle class. When the player
    presses the left arrow key, the x variable will be set to −2 (to move left). Pressing
    the right arrow key sets the x variable to 2 (to move right).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0187-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step is to add the x object variable to the __init__ function of
    our Paddle class, as well as a variable for the canvas width, as we did with the
    Ball class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'See ➊ and ➋ for changes. Now we’ll add the functions for changing the direction
    between left (turn_left) and right (turn_right) just after the draw function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can bind these functions to the correct key in the __init__ function of
    the class with these two lines. We used binding in “Making an Object React to
    Something” on [page 162](ch10.xhtml#ch10lev1sec13) to make Python call a function
    when a key is pressed. In this case, we bind the turn_left function of our Paddle
    class to the left arrow key, using the event name <KeyPress-Left>. We then bind
    the turn_right function to the right arrow key, using the event name <KeyPress-Right>.
    Our __init__ function now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'See ➊ and ➋ for the changes. The draw function for the Paddle class is similar
    to that for the Ball class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We use the canvas’s move function to move the paddle in the direction of the
    x variable with self.canvas.move(self.id, self.x, 0). Then we get the paddle’s
    coordinates to see if it has hit the left or right side of the screen, using the
    value in pos. Rather than bouncing like the ball, the paddle should stop moving.
    So, when the left *x* coordinate (pos[0]) is less than or equal to 0 (<= 0), we
    set the x variable to 0 with self.x = 0. In the same way, when the right *x* coordinate
    (pos[2]) is greater than or equal to the canvas width (>= self.canvas_width),
    we also set the x variable to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*If you run the program now, you may need to click the canvas before the game
    will recognize the left and right arrow key actions. Clicking the canvas gives
    the canvas focus, which means it knows to take charge when someone presses a key
    on the keyboard.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Out When the Ball Hits the Paddle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point in our code, the ball won’t hit the paddle. In fact, the ball
    will fly straight through the paddle. The ball needs to know when it has hit the
    paddle, just as it needs to know when it’s hit a wall.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0189-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could solve this problem by adding code to the draw function (where we have
    code that checks for walls), but it’s a better idea to move this code into new
    functions to break things into smaller chunks. If we put too much code in one
    place (inside one function, for example), we can make the code much more difficult
    to understand. Let’s make the necessary changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we change the ball’s __init__ function so we can pass in the paddle
    object as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we change the parameters of __init__ to include the paddle ➊. Then,
    we assign the paddle parameter to the object variable paddle ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having saved the paddle object, we need to change the code where we create
    the ball object. This change is at the bottom of our program, just before the
    main while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To see if the ball has struck the paddle, we need code that’s a little more
    complicated than the previously added code to check for walls. We’ll name this
    function hit_paddle and call it in the draw function of the Ball class, where
    we check to see if the ball has hit the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the newly added code, if hit_paddle returns True ➊, we change the direction
    of the ball by setting the y object variable to its value multiplied by –1 ➋ (the
    same as when it hits the top or bottom of the canvas). With this code, we’re basically
    saying, “If the ball (self) has hit the paddle, then we reverse its vertical direction.”
  prefs: []
  type: TYPE_NORMAL
- en: We could combine the top, bottom, and paddle checks into one if-statement—but
    it’s easier for new programmers to read this code if we keep them separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t try to run the game yet; we still need to create the hit_paddle function.
    Let’s do that now. Add the hit_paddle function just before the draw function in
    the Ball class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the function with the pos parameter. This parameter contains
    the ball’s current coordinates. Then, we get the paddle’s coordinates and store
    them in the paddle_pos variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the first part of our if-then statement, which says, “If the right
    side of the ball is greater than the left side of the paddle, and the left side
    of the ball is less than the right side of the paddle. . .” Here, pos[2] contains
    the *x* coordinate for the ball’s right side, and pos[0] contains the *x* coordinate
    for its left side. The variable paddle_pos[0] contains the *x* coordinate for
    the paddle’s left side, and paddle_pos[2] contains its *x* coordinate for the
    right side. [Figure 12-2](ch12.xhtml#ch12fig02) shows how these coordinates look
    when the ball is about to hit the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/12fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Ball about to hit the paddle—showing horizontal coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: The ball is falling toward the paddle, but in this case, you see that the right
    side of the ball (pos[2]) hasn’t yet crossed over the left side of the paddle
    (that’s paddle_pos[0]).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see if the bottom of the ball (pos[3]) is between the paddle’s top
    (paddle_pos[1]) and bottom (paddle_pos[3]). In [Figure 12-3](ch12.xhtml#ch12fig03),
    you can see that the bottom of the ball (pos[3]) has yet to hit the top of the
    paddle (paddle_pos[1]).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/12fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: Ball about to hit the paddle—showing vertical coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: So, based on the current position of the ball, the hit_paddle function would
    return False.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Why do we need to see if the bottom of the ball is between the top and bottom
    of the paddle? Why not just see if the bottom of the ball has hit the top of the
    paddle? Because each time we move the ball across the canvas, we move in 3-pixel
    jumps. If we just checked to see if the ball had reached the top of the paddle
    (pos[1]), we might have jumped past that position. In that case, the ball would
    continue traveling and would pass through the paddle without stopping.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Element of Chance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s time to turn our program into a game rather than just a bouncing ball
    and a paddle. Games need an *element of chance*, or a way for the player to lose.
    In our current game, the ball will bounce forever, so there’s nothing to lose.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0192-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll finish our game by adding code that says that the game ends if the ball
    hits the bottom of the canvas (in other words, once it hits the ground).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the hit_bottom object variable to the bottom of the Ball class’s
    __init__ function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we change the main loop at the bottom of the program, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now the loop keeps checking hit_bottom ➊ to see if the ball has indeed hit the
    bottom of the screen. The code should continue moving the ball and paddle only
    if the ball hasn’t touched the bottom, as you can see in the preceding if statement.
    The game ends when the ball and paddle stop moving. (We no longer animate them.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The final change is to the draw function of the Ball class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We altered the if statement to see if the ball has hit the bottom of the screen
    (that is, if the ball’s position is greater than or equal to canvas_height) ➊.
    If so, in the following line, we set hit_bottom to True, rather than changing
    the value of the y variable, because there’s no need to bounce the ball once it
    hits the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the game now and miss hitting the ball with the paddle, all movement
    on your screen should stop. The game should end once the ball touches the bottom
    of the canvas, as shown in [Figure 12-4](ch12.xhtml#ch12fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/12fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Ball hitting the bottom of the screen*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program should now look like the following code. If you have trouble getting
    your game to work, check what you’ve entered against this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What You Learned
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we finished creating our first game using the tkinter module.
    We created classes for the paddle used in our game, and used coordinates to check
    when the ball hits the paddle or the walls of our game canvas. We used event bindings
    to bind the left and right arrow keys to the movement of the paddle, and used
    a main loop to call the draw function, to animate it. Finally, we changed our
    code to add an element of chance, so that when the player misses the ball and
    it hits the bottom of the canvas, the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0196-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Programming Puzzles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the moment, our game is pretty simple. You could change a lot to create a
    more interesting game. Try enhancing your code in the following ways, and then
    compare your answers with the solutions at *[http://python-for-kids.com](http://python-for-kids.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: '#1: Delay the Game Start'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our game starts quickly, and you need to click the canvas before it will recognize
    pressing the left and right arrow keys on your keyboard. Can you add a delay to
    the start of the game in order to give the player enough time to click the canvas?
    Or even better, can you add an event binding for a mouse click, which starts the
    game only then?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 1: You’ve already added event bindings to the Paddle class, so that might
    be a good place to start.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 2: The event binding for the left mouse button is the string ’<Button-1>’.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2: A Proper “Game Over”'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Everything freezes when the game ends, which isn’t very player-friendly. Try
    adding the text “Game Over” when the ball hits the bottom of the screen. You can
    use the create_text function, but you might also find the named parameter state
    useful (it takes values such as normal and hidden). Have a look at itemconfig
    in “More Ways to Use the Identifier” on [page 165](ch10.xhtml#ch10lev1sec14).
    As an additional challenge, add a delay so that the text doesn’t appear right
    away.
  prefs: []
  type: TYPE_NORMAL
- en: '#3: Accelerate the Ball'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In tennis, when a ball hits your racket, it sometimes flies away faster than
    the speed at which it arrived, depending on how hard you swing. The ball in our
    game goes at the same speed, whether or not the paddle is moving. Try changing
    the program so that the paddle’s speed is passed on to the speed of the ball.
  prefs: []
  type: TYPE_NORMAL
- en: '#4: Record the Player’s Score'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How about recording the score? Every time the ball hits the paddle, the score
    should increase. Try displaying the score at the top-right corner of the canvas.
    You might want to look back at itemconfig in “More Ways to Use the Identifier”
    on [page 165](ch10.xhtml#ch10lev1sec14) for a hint.
  prefs: []
  type: TYPE_NORMAL
