- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INTEGERS, FLOATS, AND STRINGS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll learn the difference between expressions and statements,
    discover how to assign values to variables, and become familiar with the most
    common types of data in Python: integers, floats, and strings. In the process,
    you’ll likely be surprised by how much programming you can accomplish using simple
    mathematical operations.'
  prefs: []
  type: TYPE_NORMAL
- en: While working through this and the following chapters, I recommend running the
    code examples rather than just reading them. Typing in the commands will help
    you to remember them and reduce any apprehension you might feel about coding.
    I’ll be using the console and text editor in Spyder for the examples in this primer.
    I suggest you do the same so that you can follow along. If you need a refresher
    on these tools, see [Chapter 3](ch03.xhtml) for the Jupyter Qt console and [Chapter
    4](ch04.xhtml) for the Spyder IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathematical Expressions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computer science, *expressions* are instructions that evaluate to a single
    value. The most familiar expressions are mathematical, such as 1 + 2, which evaluates
    to 3\. Using Python, you can incorporate equations into your programs (and even
    use an interactive console as a calculator). To do so, you’ll need to be familiar
    with the mathematical operators.
  prefs: []
  type: TYPE_NORMAL
- en: '***Mathematical Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Symbols used to represent an action or process are called *operators*. These
    perform a function or manipulate values in some way. Common operators are the
    plus (`+`) and minus (`-`) signs, used for addition and subtraction, respectively.
    [Table 7-1](ch07.xhtml#ch07tab1) lists some of the available mathematical operators
    in Python. Most of these should be familiar to you, with a few exceptions that
    we’ll expand on next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Mathematical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| + | Addition | 5 + 3 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| - | Subtraction | 5 - 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| * | Multiplication | 5 * 3 | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| / | Division | 5/3 | 1.6666666666666667 |'
  prefs: []
  type: TYPE_TB
- en: '| // | Division (floor or integer) | 5 // 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| % | Modulus (remainder) | 5 % 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ** | Power | 5**3 | 125 |'
  prefs: []
  type: TYPE_TB
- en: Whereas the division operator (`/`) represents true division, *floor* division
    (`//`) returns an integer with any fractional part ignored. Note that floor division
    will not round up. If the result is `1.99999`, you’ll still get `1` as the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want only the fraction, or *remainder*, of the division operation, use
    the *modulo* operator (`%`). The remainder may seem like a strange thing to separate
    out, but it can be useful. For example, you can use it to identify even and odd
    numbers. Enter the following code in a console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The command for executing the code will depend on what tool you’re using.
    For the Jupyter Qt console, this will be pressing ENTER (or SHIFT-ENTER if you’re
    within indented code) on your keyboard.*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, dividing `4` by `2` using the modulo operator returned
    `0`, meaning the operation resulted in no remainder and thus `4` is even. Other
    uses for modulo include instructing your program to do something every *n*th time
    and converting seconds to hours, minutes, and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The power, or *exponent*, operator also has a non-intuitive feature. Not only
    can you raise numbers to a power, you can also calculate the root by using a decimal
    value after the `**` operator. For example, to take the square root of 9, enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To take the cube root of 27, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '***The Assignment Operator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using Python as a hand calculator is a bit like calling in an air strike on
    an ant. For programs to be truly useful, you need to store the output of expressions
    in a reusable manner. That’s where assignment statements, assignment operators,
    and variables come in.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas expressions evaluate to a single value, *statements carry out* some
    action. The *assignment* statement, for example, creates a new *variable*. Variables
    are just *references* to data stored in memory. In an assignment statement, the
    equal sign (`=`) is an assignment *operator* that assigns a value or expression
    to a variable ([Figure 7-1](ch07.xhtml#ch07fig1)). A simple example is `my_name
    = 'Lee'`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Rudiments of an assignment statement*'
  prefs: []
  type: TYPE_NORMAL
- en: In assignment statements, the item to the left of the equal sign is the variable’s
    name. This acts as a label for accessing information in memory. The item on the
    right is the variable’s value. These values don’t have to be numeric. Text data,
    lists of items, even images and music can be stored as variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about assignment statements, let’s use them to make our math
    expressions more persistent and purposeful by assigning the results to a variable.
    Because this is such a common programming task, Python helps you out by providing
    special *augmented* assignment operators, which we’ll talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: '***Augmented Assignment Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For convenience, you can combine mathematical operators to form *augmented
    assignment operators* that let you perform two operations at the same time. Here’s
    an example *without* an augmented operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can add a variable to itself, and entering the variable name in
    the console will display its value. In the text editor, you’ll need to use `print(x)`
    to display the value to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an augmented assignment operator (`+=`), you can add 5 to `x` without
    having to repeat `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To make an augmented assignment operator, just add the mathematical operator
    ([Table 7-1](ch07.xhtml#ch07tab1)) before the equal sign (`=`). For example, to
    multiply `x` by 2, you could enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, because you assign the result of each expression to the variable
    `x`, each expression can build on the one before.
  prefs: []
  type: TYPE_NORMAL
- en: '***Precedence***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mathematical expressions in Python use familiar rules of precedence ([Table
    7-2](ch07.xhtml#ch07tab2)). Expressions bounded by parentheses are always performed
    first, and operations within the same precedence level are evaluated left to right.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** Mathematical Precedence'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 (highest) | () | Parentheses |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | ** | Power |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | -n, +n | Negative and positive arguments |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *, /, //, % | Multiplication, division, floor division, modulus |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | +, - | Addition and subtraction |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s an example of precedence in action. Follow along in your head and see
    if you get the same answer as Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The precedence level influences how you use *whitespace* within an expression.
    For example, the expression that follows will execute, but you might find it less
    readable than the previous version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can find guidelines for improving the readability of expressions in PEP8
    (*[https://pep8.org/](https://pep8.org/)*). Although there are some set rules—such
    as never use more than one space, always have the same amount of whitespace on
    both sides of a mathematical operator, and surround assignment (=) and augmented
    assignment operators (like +=) with a single space—you’re mostly free to use your
    own judgement. If you have poor eyesight, you might prefer to use more whitespace
    than is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '***The math Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Python standard library includes a `math` module that provides access to
    underlying C library functions. *Functions* are like mini-programs that perform
    some task or tasks. They hide the details of these programs from you so that you
    can write cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: To use a function, enter the function name followed by parentheses. Values or
    variables you enter in the parentheses will be input to the function. We look
    at functions in more detail in [Chapter 11](ch11.xhtml), including how to write
    your own custom versions.
  prefs: []
  type: TYPE_NORMAL
- en: Groups of related functions are often gathered into *modules*. The `math` module
    lets you efficiently perform common and useful mathematical calculations including
    working with factorials, quadratic equations, and trigonometric, exponential,
    and hyperbolic functions. It also includes constants including *π* and *e*. A
    subset of the available functions is listed in [Table 7-3](ch07.xhtml#ch07tab3).
  prefs: []
  type: TYPE_NORMAL
- en: To use the `math` module, you first must *import* it using an `import` statement.
    Think of this as checking a book out of a library. As there are literally thousands
    of available modules, you don’t want them all to load by default. This would be
    like emptying all the book shelves in a library onto your desk at once. Instead,
    you just take down books you need. Importing modules follows this principle with
    respect to your computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** A Subset of Python Math Module Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil(x)` | Returns the smallest integer greater than or equal to `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `fabs(x)` | Returns the absolute value of `x` as a floating-point number
    |'
  prefs: []
  type: TYPE_TB
- en: '| `factorial(x)` | Returns the factorial of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `floor(x)` | Returns the largest integer less than or equal to `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `frexp(x)` | Returns the mantissa and exponent of `x` as the pair (`m`, `e`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isnan(x)` | Returns True if `x` is a NaN (Not a Number) |'
  prefs: []
  type: TYPE_TB
- en: '| `exp(x)` | Returns `e**x` |'
  prefs: []
  type: TYPE_TB
- en: '| `log(x[, b])` | Returns the logarithm of `x` to the base `b` (defaults to
    `e`) |'
  prefs: []
  type: TYPE_TB
- en: '| `log2(x)` | Returns the base-2 logarithm of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `log10(x)` | Returns the base-10 logarithm of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `pow(x, y)` | Returns `x` raised to the power `y` |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt(x)` | Returns the square root of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `acos(x)` | Returns the arc cosine of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `asin(x)` | Returns the arc sine of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `atan(x)` | Returns the arc tangent of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2(y, x)` | Returns the arc tangent of `y` / `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `cos(x)` | Returns the cosine of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `hypot(x, y)` | Returns the Euclidean norm, `sqrt(x**2 + y**2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sin(x)` | Returns the sine of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `tan(x)` | Returns the tangent of `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `degrees(x)` | Converts `x` from radians to degrees |'
  prefs: []
  type: TYPE_TB
- en: '| `radians(x)` | Converts `x` from degrees to radians |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s use the `math` module to calculate the cosine of 45 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by importing the `math` module, converting 45 to radians (all trigonometric
    calculations in Python use radians), and assigning the result to the variable,
    `x`. Note that you enter the name of the module followed by a dot (`.`), and the
    `radians()` function with the angle you want to convert in the parentheses. Using
    a dot in this manner is called *dot notation*. It tells Python to use the `math`
    module’s `radians()` function. You can think of it as an apostrophe indicating
    possession: “`math`’s `radians()` function.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, call the `cos()` function on `x`. You can also assign this value to
    a variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s use `math` to access *π* and calculate the circumference of a circle
    with a diameter of 100 units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `math` module handles basic math well, but for more advanced functionality,
    such as calculus, you’ll want to use external libraries like *SymPy*, which we
    examine in later chapters. In the meantime, to learn more about `math` and see
    a complete list of the available functions and constants, along with detailed
    documentation, visit *[https://docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recalling information that you’ve recently learned helps you retain the knowledge.
    Take a few minutes to complete this short quiz. You can find answers and suggestions
    in the [appendix](app01.xhtml#app01).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  True or false: Statements are computational instructions that evaluate
    to a single value.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.  The expression `12%4` evaluates to:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  3
  prefs: []
  type: TYPE_NORMAL
- en: b.  48
  prefs: []
  type: TYPE_NORMAL
- en: c.  0
  prefs: []
  type: TYPE_NORMAL
- en: d.  12.4
  prefs: []
  type: TYPE_NORMAL
- en: '3.  The mathematical operator with the highest precedence is:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Power (**)
  prefs: []
  type: TYPE_NORMAL
- en: b.  Floor division (//)
  prefs: []
  type: TYPE_NORMAL
- en: c.  Parentheses (())
  prefs: []
  type: TYPE_NORMAL
- en: d.  Negative and positive arguments (-n, +n)
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Write a line of code that first takes the square root of 42 and then raises
    the result to the 4th power.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error Messages**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As soon as you start coding, you’re going to make mistakes. One issue is that
    computers are much more literal than people. You and I can be very flexible when
    it comes to contextual meaning, grammar, and even spelling, but with computers,
    what you see is what you get ([Figure 7-2](ch07.xhtml#ch07fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Computers take everything literally.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t bend Python’s syntactic rules like you can the grammatical rules that
    govern human speech. When you try to perform an illegal operation in Python, such
    as divide a number by zero, it halts execution and displays an error message,
    a process called *raising an exception*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example that a human could handle but Python can’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Python displayed an error message indicating a `TypeError` because you tried
    to divide an integer (`int`) by a string of text (`str`). Although you and I can
    easily guess the correct answer, Python won’t even try, because you mixed *data
    types* (more on these in a moment). To Python, this is as silly as dividing 25
    by “Steve.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to divide by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This raises the aptly named `ZeroDivisionError` and again provides a record,
    called a *traceback*, which describes where the interpreter encountered a problem
    in your code. In this case, the traceback includes the assignment statement that
    caused the exception and the type of error encountered. For some errors, it will
    also provide a pointer (`^`) to where the exception occurs in the line.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In many cases, it’s the line before the line referenced in the traceback that
    causes the problem. So always remember to look up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the type of error that the interpreter encountered will help you debug
    your code when you make mistakes. [Table 7-4](ch07.xhtml#ch07tab4) lists some
    of the common error types that you’ll encounter (you can find more at *[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)*).
    Don’t worry if you don’t understand them all now. They should make more sense
    by the end of this primer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-4:** Some Common Python Error Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Error type** | **Thrown when…** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SyntaxError` | a syntax error is encountered. |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexError` | trying to access an item at an invalid index. |'
  prefs: []
  type: TYPE_TB
- en: '| `ModuleNotFoundError` | a module or package can’t be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyError` | a dictionary key can’t be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `ImportError` | a problem occurs when loading a module or package. |'
  prefs: []
  type: TYPE_TB
- en: '| `StopIteration` | the `next()` function goes beyond the iterator items. |'
  prefs: []
  type: TYPE_TB
- en: '| `TypeError` | an operation or function is applied to data of an inappropriate
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `ValueError` | a function’s argument is of an inappropriate type. |'
  prefs: []
  type: TYPE_TB
- en: '| `NameError` | an object (variable, function, and so on) can’t be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `RecursionError` | the maximum recursion depth exceeded (long-running loop
    terminated). |'
  prefs: []
  type: TYPE_TB
- en: '| `ZeroDivisionError` | the denominator in the division operation is zero.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MemoryError` | an operation runs out of memory. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyboardInterrupt` | the user presses the interrupt key (such as CTRL-C)
    during execution. |'
  prefs: []
  type: TYPE_TB
- en: 'Errors are no big deal. The last line in a traceback includes the error type
    and a brief explanation (such as `NameError: name` ''`load`'' `is not defined`).
    If you copy and paste this line into a search engine, you’ll find lots of friendly
    explanations that are easier to understand than the overly technical ones provided
    in the traceback report and the official documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Later, we’ll look at ways to handle certain exceptions so that a program can
    keep running rather than crash when it encounters one. It’s also possible to write
    custom exceptions for a specific program in the event that the supplied exceptions
    are insufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as errors have types, every value in Python is automatically assigned to
    a specific data type. This lets Python distinguish between the letters of the
    alphabet, like “abc,” and numbers, like “123.”
  prefs: []
  type: TYPE_NORMAL
- en: The same principles apply to humans. We wouldn’t try to multiply letters together
    (unless we were doing algebra). Nor would we name our children using numbers (unless
    we were Elon Musk). Without conscious thought, our brains recognize different
    types of data, and after we’ve categorized that data, we know how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, a *data type* is a classification that dictates what values
    objects can hold (in other words, what input is acceptable) and how they can be
    used (what operations can be performed using them, such as converting text to
    lowercase). Whereas many programming languages use *static typing* that requires
    you to explicitly declare the data type for any variable you create, Python uses
    *dynamic typing*, wherein variables can be any data type and even change types
    during execution. This makes Python a friendlier language, though this comes at
    a cost. Languages using static typing are better at catching bugs because they
    can check that data is being used correctly before the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python permits optional static typing using type hints. We won’t cover these
    here, but you can learn more at [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by looking at some of the built-in data types that you’ll use with
    Python ([Table 7-5](ch07.xhtml#ch07tab5)). Because numbers and text occur in pretty
    much every computer program, here we’ll focus on three data types: *strings*,
    *integers*, and *floating-point numbers (floats)*; we cover other data types in
    subsequent chapters. These three data types are highlighted in bold in [Table
    7-5](ch07.xhtml#ch07tab5).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-5:** Some Common Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Data type** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Numeric type** | **Integer** | -1**,** 0**,** 1**,** 4000 |'
  prefs: []
  type: TYPE_TB
- en: '| **Numeric type** | **Float** | -1.5**,** 0.0**,** 0.33**,** 4000.001 |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric type | Complex | `a = 4 + 3j` |'
  prefs: []
  type: TYPE_TB
- en: '| **Text type** | **String** | ''a''**,** "b"**,** "Hello, world" |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence type | Tuple | `(2, 5, ''Pluto'', 4.56)` |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence type | List | `[2, 5, ''Pluto'', 4.56]` |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence type | Range | `range(0, 10, 1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Set type | Set | `{2, 5, ''Pluto'', 4.56}` |'
  prefs: []
  type: TYPE_TB
- en: '| Set type | Frozenset | `frozenset({2, 5, ''Pluto'', 4.56})` |'
  prefs: []
  type: TYPE_TB
- en: '| Mapping type | Dictionary | `{''key'': ''value''}` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean type | Bool | `True`, `False` |'
  prefs: []
  type: TYPE_TB
- en: Additional binary types, not listed in [Table 7-5](ch07.xhtml#ch07tab5), include
    *Bytes*, *Bytearray*, and *Memoryview*. For more on all these built-in types,
    visit *[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing the Data Type***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can query for data type using the built-in `type()` function that ships
    with Python. Enter a value or variable in the parentheses, as in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `isinstance()` function to check whether a variable is
    an instance of a particular data type. For example, to check whether the integer
    `42` is an integer or a string, enter `42` in the parentheses, along with the
    data type you’re checking for, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Much like the human brain, Python can recognize data types based on context.
    Numbers without a decimal are considered integers. Numbers with a decimal point
    are floats, even if there are no values behind the decimal point (such as `5.`).
    Strings are identified by enclosing characters in quotation marks (such as “Hello”
    or ‘123’).
  prefs: []
  type: TYPE_NORMAL
- en: '***Integers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *integer* type represents whole numbers, such as 0, 42, and 5,280\. The
    length of an integer is limited only by your system’s maximum available memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python recognizes integers by the absence of a decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with large numbers, you can use an underscore (`_`) to separate
    thousands, such as `15_000_000` for `15000000`. Python doesn’t need this separator
    to understand these values, but you’ll have an easier time reading them. It reduces
    key-in errors and saves you from having to count lots of zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, we’ll look at how to make the output more readable, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '***Floats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Floats*, or *floating-point numbers*, have decimal points. They include 0.0,
    0.42, and 3.14159\. With floats, you get 15 to 17 digits of precision. Small rounding
    errors, caused by the universal CPU need to store digits in the binary number
    system, mean that floats aren’t always perfectly accurate. For example, notice
    that the following addition results in an extra 0.00000000000000004:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you need more exact precision for scientific work, you can use the built-in
    `decimal` module (*[https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html)*).
    For more on floating-point accuracy, see *[https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting Floats and Integers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Operations using integers sometimes return integers and sometimes return floats.
    Try the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Even though most operations between integers always yield an integer, division
    may not (42 / 5, for example). Because dividing an integer by an integer can result
    in a float, Python automatically converts the quotient into a floating-point value,
    even if the result is still an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The process of converting from one data type to another is known as *type casting*.
    This can occur *implicitly*, as in the previous example, or *explicitly*, in which
    you use predefined functions. Explicit type casting is commonly used on user input,
    to ensure that the input values are the proper type for subsequent operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Python, you can convert integers to floats in several ways. One is to
    combine them in the same mathematical operation. Notice that adding a float value
    to an integer turns that integer into a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use explicit type casting with the `float()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If `x` is an integer, the following would work as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a float into an integer, use the `int()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that `int()` simply drops the decimal part and keeps the whole number to
    the left of the decimal point. If you want to account for any fractional remainder,
    you’ll need to use rounding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rounding**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To *round* a floating-point number up or down to the nearest integer rather
    than just remove the decimal part, you’ll want to use the built-in `round()`function.
    In the following example, we use `round()` to convert the float 5.89 to the nearest
    integer, 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `round()` function rounds to no decimal places by default and returns an
    integer. To specify the number of significant digits for rounding, include the
    number after the value to round. In the following example, we round the value
    of the `y` variable to one decimal place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Because you preserved a value after the decimal point, `y` is still a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working in an interactive console, you can also round numbers directly,
    without the need for a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If a float value is halfway between integer values, the rounding function rounds
    odd numbers up, and even numbers down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous examples, you should always be aware of data
    types when working with numbers. Integers can automatically convert to floats
    during the processing of your code, and vice versa. For example, doing any operation
    that *uses* a float (such as `5 *= 1.0`), or *results* in a float (such as `5
    /= 3`), will produce a float.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Write an expression that raises a `SyntaxError`.
  prefs: []
  type: TYPE_NORMAL
- en: '6.  What error would you expect from the expression, `round(``''``Alice``''``)`:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  a `TypeError`
  prefs: []
  type: TYPE_NORMAL
- en: b.  a `ValueError`
  prefs: []
  type: TYPE_NORMAL
- en: c.  a `NameError`
  prefs: []
  type: TYPE_NORMAL
- en: d.  a `SyntaxError`
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Round *π* to five decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: '8.  Use Python to determine the data type of this object: `(1, 2, 3)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '9.  True or false: The tiny inaccuracies that sometimes occur in floating-point
    numbers are a Python-specific issue.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Strings*, also known as *string literals*, are what we think of as text values.
    You can recognize them by their quotation marks. The most famous string value
    in programming, “Hello, World!”, is generally the first thing you learn to print.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings should be surrounded by quotes, which mark the beginning and end of
    the string. In the console, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you should encase strings in single quotes, but if you need to include
    a single quote within your string, say, as an apostrophe, you can use double quotes,
    as in line `In [55]`. In line `In [58]`, note how numbers are treated as strings
    if they’re surrounded by quotes. You won’t be able to use these numbers in mathematical
    expressions without converting them into a numeric type, like integers or floats.
  prefs: []
  type: TYPE_NORMAL
- en: Triple quotes (`"""`) let you stretch strings across multiple lines. Although
    computers don’t care how long a line of code is, humans do. For readability, PEP
    8 recommends a maximum line length of 79 characters. If you want to write a very
    long string, say, for in-code documentation, you can use triple quotes at the
    start and end of the string, as in line `In [59]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To honor the line length guideline, you can use the line continuation character
    (`\`) to break lines between triple quotes. But note that, if you’re using strings
    with single or double quotes, you’ll need to place it *outside* the strings, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Triple quotes also allow you to add simple drawings to your program, such as
    a grid to show board positions in a tic-tac-toe game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can convert other data types to strings using the `str()` function.
    The following example converts an integer into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Behind the scenes, strings are sequences of characters in Unicode, an international
    encoding standard in which each letter, digit, or symbol is assigned a unique
    numeric value. Unicode ensures that computers everywhere see an A as an A, and
    a ☺ as a happy face.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Escape Sequences**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Escape sequences* are special characters that let you insert otherwise illegal
    text into a string. In the previous section, we were able to include a single
    quote apostrophe by first enclosing the string in triple quotes. With the backslash
    (`\`) escape character, used *within* the quotes, we could use single quotes exclusively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the backslash doesn’t appear in the final string. To print a backslash
    character, you’ll need to escape it with another backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 7-6](ch07.xhtml#ch07tab6) lists some useful escape sequences and their
    result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-6:** Useful Python Escape Sequences'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Escape sequence** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\``''` | Single quote (`''`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\``″` | Double quote (`"`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Backslash (`\`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\a` | Ring ASCII bell (such as `print(``''``\a``''``)` in Windows 10) |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | ASCII linefeed (newline) |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | ASCII carriage return |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | ASCII tab |'
  prefs: []
  type: TYPE_TB
- en: For the full list of escape sequences, visit the documentation at *[https://docs.python.org/3/reference/lexical_analysis.html](https://docs.python.org/3/reference/lexical_analysis.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raw Strings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Raw strings* don’t recognize escape sequences. These are helpful when you
    need to deal with lots of backslashes, such as in a Windows path name. In a normal
    string, you must escape backslashes with the `\\` escape sequence, which can become
    awkward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With a raw string, what you see is what you get. To use one, just add an `r`
    prefix to the string, before the first quotation mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Operator Overloading**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Python can apply context to certain operators depending on whether they’re
    used with numbers or strings. An operator doing different things on different
    data types is known as *operator overloading.* That sounds bad, but it’s not.
    To see an example, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When used with strings, the `+` addition operator becomes the *string concatenation*
    operator. Also note that spaces are legitimate characters, so I added a space
    before the single quote at the end of `Hello`. Alternatively, the space could
    have been added before `world`, or separated out entirely, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `*` multiplication operator becomes the *string replication*
    operator when a string is multiplied by an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful for drawing in scripts, such as generating a dividing line
    within your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can’t mix and match these easily among data types. You can’t
    add a number to a string, for instance, or multiply two words together.
  prefs: []
  type: TYPE_NORMAL
- en: '**String Formatting**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In many cases, you’ll want to create a string that includes other strings.
    For example, you might want to reference a variable in the `print()` function.
    *Format strings*, also called *f-strings*, make this easy. You just need to prefix
    the string with an `f` and put the variable name in curly brackets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re working in the console, you can omit the print() function and apply
    the f-string directly (such as: f''{solute} dissolves in {solvent}'').*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an f-string, expressions in curly brackets are evaluated at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the text’s alignment with f-strings, letting you create
    tabular output. In the following example, 25 spaces are reserved and `<` justifies
    these spaces to the left, `^` centers the text, and `>` justifies to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use f-strings to format numeric values. To add commas to a long number,
    use this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To use exponential notation, use the `e` qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To format numbers to a specific precision point, use the `f` qualifier. For
    example, to print Euler’s number, *e*, to three decimal places, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a number to a percent, use the `%` qualifier. Include a number to
    specify the number of decimal places to preserve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, f-strings make code very readable, so long as your variable
    names make sense.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 10.  If `x =` `'``30_000_000``'`, what data type is `x`?
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Which of the following is the result of running the code `f'{3.14159:.2f}'`
    in Jupyter Qt console?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `'3.14'`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `'314,159'`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `'3.141590e+00'`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `'314.15%'`
  prefs: []
  type: TYPE_NORMAL
- en: 12.  Draw an owl in the text editor and print it to the screen. Each line of
    code should not exceed 79 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 13.  Write a program that converts 1,824 seconds into minutes and seconds and
    then print the results.
  prefs: []
  type: TYPE_NORMAL
- en: '**String Slicing**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each character in a string has a unique index that locates it within the string.
    Think of this as the character’s address. Python starts counting with 0; thus,
    the index for the first character in a string is `0`, not `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console, enter the following to retrieve the first and last characters
    in the string `''PYTHON''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To use an index, enter the variable name (such as `x`) with the index that you
    want in square brackets (`[]`). Note that, even though `PYTHON` has six characters,
    the last index is `5`, again because Python starts counting at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ask for an index beyond the end of the string, you will get the (very
    common) `index out of range` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You can also *slice* strings (and many other data types) using indexes. Slicing
    lets you chop a string into smaller pieces. For example, you might take the first
    three characters, the last two, the one in the middle, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To slice a string, enter endpoints that encompass the characters in which you’re
    interested. For example, to get the first three characters in `PYTHON`, enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that you get the characters at indexes `0`, `1`, and `2`, but not at index
    `3`. When slicing, Python takes everything *up to* but *not including* the ending
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the starting and ending indexes are used so often, Python provides
    a shorthand technique in which you leave off those indexes. Rerun the preceding
    code, omitting the `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To return the whole string, you can use just the colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also take larger strides through the string by specifying a step size.
    The default step size is `1`. If you want to start at the beginning and take every
    other character, add another colon followed by a step size of `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The extra colon is needed because we are using the syntax `x[start:end:step]`.
    When no values are provided, Python defaults to taking the starting and ending
    indexes, for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can slice going forward or backward through a string. To slice in reverse,
    you use *negative* indexes. For example, if you just want the end part of a string,
    you can use negative indexes when slicing. To get the last character and the last
    three characters, respectively, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the “first” index in reverse is `-1`, not `0` as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the string in reverse, step backward one character at a time using
    `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Membership Operators**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `in` and `not in` operators tell you whether a character or substring exists
    within a string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This functionality is useful with conditional statements, which we’ll cover
    in more detail later. For example, if you’d like to know whether `''``Waldo``''`
    is part of the string contained in the variable `x`, you could enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**String Methods**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A nice thing about data types is that they come with methods (a type of function)
    that helps you manipulate them. Methods represent actions that data types can
    perform. For example, although the `in` operator tells you that a character or
    substring is *present*, it doesn’t tell you how many times it occurs. If you want
    to count number of occurrences, you can use the `count()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To count the number of times lowercase “i” occurs in the string “I am a scientist,”
    enter the string (or a variable representing the string), followed by a dot (`.`)
    and the `count()` method with the character or substring you’re searching for
    in the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Python comes with a long list of string methods (see *[https://docs.python.org/3/library/stdtypes.html#string-methods/](https://docs.python.org/3/library/stdtypes.html#string-methods/)*).
    Some of the more-used methods are listed in [Table 7-7](ch07.xhtml#ch07tab7).
    You should replace text in bold with your specific string or substring. Text in
    italics is optional. For example, the *start* and *end* indexing options default
    to the starting and ending indexes of the string, respectively, if you choose
    to ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-7:** Common String Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| str`.capitalize()` | Capitalizes the first character with the rest lowercase
    |'
  prefs: []
  type: TYPE_TB
- en: '| str`.count(`sub`,` start`,` end`)` | Counts occurrences of a character or
    substring |'
  prefs: []
  type: TYPE_TB
- en: '| str`.endswith(`suffix`,` start`,` end`)` | Returns True if string ends with
    the suffix |'
  prefs: []
  type: TYPE_TB
- en: '| str`.find(`sub, start`,` end`)` | Returns lowest index where substring is
    found within slice |'
  prefs: []
  type: TYPE_TB
- en: '| str`.isalnum()` | Returns True if all string characters are alphanumeric
    |'
  prefs: []
  type: TYPE_TB
- en: '| str`.isalpha()` | Returns True if all string characters are alphabetic |'
  prefs: []
  type: TYPE_TB
- en: '| str`.isdigit()` | Returns True if all string characters are digits |'
  prefs: []
  type: TYPE_TB
- en: '| str`.islower()` | Returns True if all string characters are lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| str`.isupper()` | Returns True if all string characters are uppercase |'
  prefs: []
  type: TYPE_TB
- en: '| str`.lower()` | Changes all cased characters to lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| str`.replace(`old, new, count`)` | Replace old substring with new substring
    |'
  prefs: []
  type: TYPE_TB
- en: '| str`.split(sep=None,` maxsplit=-1`)` | Return list of words with “sep” character
    as the delimiter |'
  prefs: []
  type: TYPE_TB
- en: '| str`.startswith(`prefix`,` start`,` end`)` | Return True if string starts
    with the prefix |'
  prefs: []
  type: TYPE_TB
- en: '| str`.strip(`chars`)` | Removes leading and trailing characters; removes whitespace
    if no character is specified |'
  prefs: []
  type: TYPE_TB
- en: '| str`.title()` | Capitalizes the first character in each word |'
  prefs: []
  type: TYPE_TB
- en: '| str`.upper()` | Changes all cased characters to uppercase |'
  prefs: []
  type: TYPE_TB
- en: 'Because strings are *immutable* (unchangeable), these methods return *copies*
    of strings rather than alter the original object. Enter the following into the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you assigned a lowercase string (`'``string``'`) to the `x`
    variable. You then called the `upper()` string method on `x` as you printed it.
    Python was able to see and use the uppercase string, but when you use the `x`
    variable later, it’s still in its original lowercase form.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make `x` always refer to an uppercase string, you need to reassign it to
    itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To see another example of string immutability, let’s try to change the `I`
    in `''STRING''` to `A` using its index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This raised a `TypeError`, as the string data type is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To (sort of) get around immutability, use the `replace()` method, which requires
    the creation of a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split()` method breaks up a string and returns a *list* data type (covered
    in [Chapter 9](ch09.xhtml)). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If you look carefully at the results, you’ll notice that punctuation marks get
    lumped in with words.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `split()` uses a space as the *delimiter* character on which to
    split the string. You can also specify a delimiter such as a hyphen or, as in
    the following case, a comma with trailing whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that, compared to line `Out[113]`, the comma is no longer attached to `Tee-hee`,
    but the period is still attached to the `Brutus` item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To strip the punctuation marks, import the `string` module, which includes
    a `punctuation` string, and use the built-in `translate()` function to eliminate
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `maketrans()` method takes three arguments; the first two are empty strings
    (`''`), and the third is the list of punctuation marks to remove. This tells the
    function to replace all punctuation with `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can split the string on white space and get a list of words only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that the remaining comma in line `Out[120]` is part of the list and is
    used to separate items in the list, like `Teehee` and `Brutus`. It doesn’t count
    as part of a string. Note also that the hyphen is missing from `Teehee`. This
    is because the `punctuation` string includes a hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to strip unwanted characters from strings with Python.
    For working with large bodies of text, you’ll want to use either *regular expressions*
    (*regex*) or a *natural language processing* library. These tools are specially
    designed for working with text, and we explore some of them in [Chapter 15](ch15.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 14.  Which of the following is the result of running the code `'``latchstring``'``[2:8]`?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `'``atchstr``'`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `'``tchstr``'`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `'``gnirts``'`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `'``atchst``'`
  prefs: []
  type: TYPE_NORMAL
- en: '15.  To get a subset of a string value, you should use:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  negative indexes
  prefs: []
  type: TYPE_NORMAL
- en: b.  string iteration
  prefs: []
  type: TYPE_NORMAL
- en: c.  augmented operators
  prefs: []
  type: TYPE_NORMAL
- en: d.  string slicing
  prefs: []
  type: TYPE_NORMAL
- en: '16.  Running the code `''``latchstring``''``[12]` results in:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  a `SyntaxError`
  prefs: []
  type: TYPE_NORMAL
- en: b.  a `StopIteration` error
  prefs: []
  type: TYPE_NORMAL
- en: c.  an `IndexError`
  prefs: []
  type: TYPE_NORMAL
- en: d.  a `ValueError`
  prefs: []
  type: TYPE_NORMAL
- en: 17.  Using the previous `caesar_said` example, use the `translate()` function
    to remove all the punctuation, *except for* the hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: 18.  Convert the string `'``impractical python projects``'` to “title” format.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned that *expressions* are instructions that evaluate
    to a single value, like a mathematical formula. *Statements* express some action
    to be carried out but don’t evaluate to a value. *Operators*, which are symbols
    used to represent an action or process, perform a function, or manipulate values
    in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also learned that a *variable* is a *label* for data stored in memory.
    Variables have *names* and *values*. Every value in Python is automatically assigned
    a *data type*, and you learned about the three most basic types: *integers*, *floats*,
    and *strings*.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn more about variables, which are objects that
    let you connect to and manipulate data.
  prefs: []
  type: TYPE_NORMAL
