- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: SOLVING PROBLEMS USING GENETIC ALGORITHMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法解决问题
- en: '*Steve: We’re lost.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Steve: 我们迷路了。'
- en: 'Mike: How lost are we?*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mike: 我们迷路到什么程度了？*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: When many people think of math, they think of equations and operations that
    are “set in stone” and answers that are either right or wrong. They might be surprised
    to learn how much guessing and checking we’ve done in our algebra explorations
    already.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多人想到数学时，他们会想到那些“石刻般”的方程式和运算，以及那些非对即错的答案。他们可能会惊讶地发现，我们在代数探索中已经进行了许多猜测和检查。
- en: In this chapter, you learn to crack passwords and hidden messages in an indirect
    fashion. It’s kind of like the “guess-and-check” method of [Chapter 4](ch04.xhtml#ch04),
    where we just plugged a bunch of integers into an equation and if any made the
    equation true, we printed them out. This time, we’ll guess a bunch of values,
    not just one. It’s not the most elegant way of solving a problem, but with a computer
    at our disposal, sometimes brute force works best.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将以一种间接的方式学习破解密码和隐藏信息。这有点像 [第 4 章](ch04.xhtml#ch04)中的“猜测与检查”方法，我们将一堆整数代入方程式，如果有任何一个使方程成立，我们就输出它们。这一次，我们将猜测多个值，而不仅仅是一个。虽然这不是最优雅的解题方式，但有了计算机，有时候蛮力最有效。
- en: 'To figure out our secret phrase, we generate guesses and then rate them on
    how well they match the target. But here’s where we depart from a guess-and-check
    method: we keep the best guesses and mutate them, randomly, again and again until
    we uncover the message. The program won’t know which letters are right and which
    letters are wrong, but we get closer and closer by mutating the best guess we’ve
    made so far. Although this method might not seem promising right now, you’ll see
    that it helps crack the code surprisingly quickly. This method is called a *genetic
    algorithm*, which computer scientists use to find solutions to problems based
    on the theory of natural selection and evolutionary biology. It was inspired by
    biological organisms that adapt and mutate, and the way they build on tiny advantages,
    as we saw in the Sheep model in [Chapter 9](ch09.xhtml#ch09), on Classes.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出我们的秘密短语，我们生成猜测，然后根据它们与目标的匹配程度进行评分。但这就是我们与猜测与检查方法不同之处：我们保留最好的猜测，并且随机地不断进行变异，直到揭开消息为止。程序不知道哪些字母是对的，哪些是错的，但我们通过不断变异我们到目前为止最好的猜测，越来越接近正确答案。尽管现在看起来这个方法可能并不令人乐观，但你会发现，它实际上能够出奇地快速地破解密码。这个方法叫做
    *遗传算法*，计算机科学家使用它基于自然选择和进化生物学理论来寻找问题的解决方案。它的灵感来自于适应和变异的生物体，以及它们如何在微小的优势上逐步发展，正如我们在
    [第 9 章](ch09.xhtml#ch09)的《羊群模型》中看到的那样。
- en: For more complicated problems, however, random mutating won’t be enough to solve
    our problem. In those cases, we add *crossover*, which we use to combine the most
    fit organisms (or best guesses) to improve their likelihood of cracking the code,
    just like how the fittest organisms are more likely to pass down a combination
    of their genetic material. All this activity, other than the scoring, will be
    fairly random, so it might be surprising that our genetic algorithms work so well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更复杂的问题，仅靠随机变异并不足以解决问题。在这些情况下，我们加入 *交叉*，用来将最适应的个体（或最佳猜测）组合在一起，从而提高它们破解密码的可能性，就像最适应的生物更有可能传递他们基因的组合一样。除了评分外，所有这些活动都是相当随机的，因此可能会令人惊讶的是，我们的遗传算法竟然如此有效。
- en: USING A GENETIC ALGORITHM TO GUESS PHRASES
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用遗传算法来猜测短语
- en: Open IDLE and create a new file called *geneticQuote.py*. Instead of guessing
    a number like in [Chapter 4](ch04.xhtml#ch04), this program tries to guess a secret
    phrase. All we have to tell the program is the number of characters it guessed
    correctly—not where or which characters, just how many.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 IDLE，创建一个名为 *geneticQuote.py* 的新文件。与 [第 4 章](ch04.xhtml#ch04)中通过猜测数字不同，这个程序尝试猜测一个秘密短语。我们只需要告诉程序它猜对了多少个字符——不是在哪个位置，也不是哪些字符，只是猜对了多少个字符。
- en: Our program is going to be able to do much better than guess short passwords.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将能够做得比猜测短密码更好。
- en: WRITING THE MAKELIST() FUNCTION
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 MAKELIST() 函数
- en: 'To see how this works, let’s create a target phrase. Here’s a long sentence
    that my son came up with from the comic book *Naruto*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这如何工作，让我们创建一个目标短语。这里是我儿子从漫画书 *火影忍者* 中想出来的一句长句子：
- en: target = "I never go back on my word, because that is my Ninja way."
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: target = "我从不食言，因为那是我的忍者之道。"
- en: 'In English, we have a bunch of characters we can choose from: lowercase letters,
    uppercase letters, a space, and some punctuation.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们可以选择许多字符：小写字母、大写字母、空格和一些标点符号。
- en: characters = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: characters = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"
- en: Let’s create a function called makeList() that will randomly create a list of
    characters that’s the same length as target. Later, when we try to guess what
    the target phrase is, we’ll score the guess by comparing it character by character
    with the target. A higher score means a guess is closer to the target. Then, we’ll
    randomly change one of the characters in that guess to see if that increases its
    score. It seems surprising that such a random method will ever get us to the exact
    target phrase, but it will.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为 makeList() 的函数，它会随机生成一个与目标长度相同的字符列表。稍后，当我们尝试猜测目标短语时，我们会通过逐字符地将猜测与目标进行比较来打分。得分越高，说明猜测越接近目标。接着，我们会随机改变猜测中的一个字符，看是否能够提高其得分。看起来这种随机的方法似乎不可能得到确切的目标短语，但事实上它是会做到的。
- en: First, import the random module and write the makeList() function, as shown
    in [Listing 12-1](ch12.xhtml#ch12list1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入 random 模块并编写 makeList() 函数，如[清单 12-1](ch12.xhtml#ch12list1)所示。
- en: '*genetic'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*遗传'
- en: Quote.py*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Quote.py*
- en: import random
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 random 模块
- en: target = "I never go back on my word, because that is my Ninja way."
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: target = "I never go back on my word, because that is my Ninja way."
- en: characters = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: characters = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"
- en: 'def makeList():'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'def makeList():'
- en: '''''''Returns a list of characters the same length'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回一个字符列表，长度与目标相同'
- en: as the target'''
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与目标的长度相同'''
- en: 'charList = [] #empty list to fill with random characters'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'charList = [] # 用于填充随机字符的空列表'
- en: 'for i in range(len(target)):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(target)):'
- en: charList.append(random.choice(characters))
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: charList.append(random.choice(characters))
- en: return charList
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: return charList
- en: '*Listing 12-1: Writing the makeList() function to create a list of random characters
    that’s the same length as the target*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-1：编写 makeList() 函数来创建一个与目标长度相同的随机字符列表*'
- en: Here, we create an empty list called charList and loop over the list the same
    number of times as there are characters in the target. On each loop,the program
    puts a random character from characters into charList. Once the loop is done,
    it returns charList. Let’s test it to make sure it works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个空列表 charList，并按目标字符数的次数循环。在每次循环中，程序将 characters 中的一个随机字符放入 charList。一旦循环完成，它返回
    charList。让我们测试一下，确保它能正常工作。
- en: TESTING THE MAKELIST() FUNCTION
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试 MAKELIST() 函数
- en: 'First, let’s find out what the length of the target is, and check that our
    random list is the same length:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们找出目标的长度，并检查我们的随机列表是否具有相同的长度：
- en: '>>> len(target)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(target)'
- en: '57'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: '>>> newList = makeList()'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> newList = makeList()'
- en: '>>> newList'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> newList'
- en: '[''p'', ''H'', ''Z'', ''!'', ''R'', ''i'', ''e'', ''j'', ''c'', ''F'', ''a'',
    ''u'', ''F'', ''y'', ''.'','
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[''p'', ''H'', ''Z'', ''!'', ''R'', ''i'', ''e'', ''j'', ''c'', ''F'', ''a'',
    ''u'', ''F'', ''y'', ''.'','
- en: '''w'', ''u'', ''.'', ''H'', ''W'', ''w'', ''P'', ''Z'', ''D'', ''D'', ''E'',
    ''H'', ''N'', ''f'', '' '','
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '''w'', ''u'', ''.'', ''H'', ''W'', ''w'', ''P'', ''Z'', ''D'', ''D'', ''E'',
    ''H'', ''N'', ''f'', '' '','
- en: '''W'', ''S'', ''A'', ''B'', '','', ''w'', ''?'', ''K'', ''b'', ''N'', ''f'',
    ''k'', ''g'', ''Q'', ''T'','
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '''W'', ''S'', ''A'', ''B'', '','', ''w'', ''?'', ''K'', ''b'', ''N'', ''f'',
    ''k'', ''g'', ''Q'', ''T'','
- en: '''n'', ''Q'', ''H'', ''o'', ''r'', ''G'', ''h'', ''w'', ''l'', ''l'', ''W'',
    ''d'']'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '''n'', ''Q'', ''H'', ''o'', ''r'', ''G'', ''h'', ''w'', ''l'', ''l'', ''W'',
    ''d'']'
- en: '>>> len(newList)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(newList)'
- en: '57'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: 'We measured the length of the target list, and it’s 57 characters long. Our
    new list is the same length, 57 characters. Why make a list instead of a string?
    We make a list because lists are sometimes easier to work with than strings. For
    example, you can’t simply replace a character in a string with another character.
    But in a list you can, as you can see here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测量了目标列表的长度，它有 57 个字符。我们的新列表也是相同的长度，57 个字符。为什么要创建一个列表而不是字符串？我们创建列表是因为有时候列表比字符串更容易操作。例如，你不能简单地在字符串中替换一个字符为另一个字符。但在列表中，你是可以做到的，正如你在这里看到的：
- en: '>>> a = "Hello"'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = "Hello"'
- en: '>>> a[0] = "J"'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[0] = "J"'
- en: 'Traceback (most recent call last):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最先）：
- en: File "<pyshell#16>", line 1, in <module>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#16>"，第 1 行，在 <module> 中
- en: a[0] = "J"
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: a[0] = "J"
- en: 'TypeError: ''str'' object does not support item assignment'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: ''str'' 对象不支持项赋值'
- en: '>>> b = ["H","e","l","l","o"]'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = ["H","e","l","l","o"]'
- en: '>>> b[0] = "J"'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b[0] = "J"'
- en: '>>> b'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[''J'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[''J'', ''e'', ''l'', ''l'', ''o'']'
- en: In this example, when we try to replace the first item in the "Hello" string
    with "J", Python doesn’t let us, and we get an error. Doing the same thing using
    a list, however, is no problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们尝试用 "J" 替换 "Hello" 字符串中的第一个字符时，Python 不允许我们这么做，并且会报错。然而，使用列表做同样的事情则没有问题。
- en: 'In the case of our *geneticQuote.py* program, we want to see the random quote
    as a string because that’s easier to read. Here’s how to print out a list as a
    string, using Python’s join() function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *geneticQuote.py* 程序中，我们希望将随机的名言以字符串的形式展示，因为那样更容易阅读。以下是如何使用 Python 的 join()
    函数将列表打印为字符串：
- en: '>>> print(''''.join(newList))'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''''.join(newList))'
- en: pHZ!RiejcFauFy.wu.HWwPZDDEHNf WSAB,w?KbNfkgQTnQHorGhwllWd
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: pHZ!RiejcFauFy.wu.HWwPZDDEHNf WSAB,w?KbNfkgQTnQHorGhwllWd
- en: Those are all the characters in newList, but in string form. It doesn’t look
    like a very promising start!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是 newList 中的字符，但以字符串形式呈现。看起来并不是一个非常有前景的开始！
- en: WRITING THE SCORE() FUNCTION
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 SCORE() 函数
- en: Now let’s write a function called score() to score each guess by comparing it
    character by character with the target, like in [Listing 12-2](ch12.xhtml#ch12list2).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一个名为 score() 的函数，通过将每个猜测与目标逐字符进行比较来给出得分，像 [列表 12-2](ch12.xhtml#ch12list2)
    中那样。
- en: '*genetic'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*genetic'
- en: Quote.py*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Quote.py*
- en: 'def score(mylist):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'def score(mylist):'
- en: '''''''Returns one integer: the number of matches with target'''''''
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回一个整数：与目标的匹配数'''''''
- en: matches = 0
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: matches = 0
- en: 'for i in range(len(target)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(target)):'
- en: 'if mylist[i] == target[i]:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mylist[i] == target[i]:'
- en: matches += 1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: matches += 1
- en: return matches
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: return matches
- en: '*Listing 12-2: Writing the score() function for scoring a guess*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-2：编写 score() 函数来评估猜测结果*'
- en: The score() function takes each item in a list we feed it (mylist) and checks
    if the first character of mylist matches the first character of the target list.
    Then the function checks whether the second characters match, and so on. For each
    character matched, we increment matches by 1\. In the end, this function returns
    a single number, not which ones are right, so we don’t actually know *which* characters
    we got right!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: score() 函数接受我们提供的列表（mylist）中的每个项，并检查 mylist 的第一个字符是否与目标列表的第一个字符匹配。然后函数会检查第二个字符是否匹配，依此类推。对于每个匹配的字符，我们将
    matches 增加 1。最后，这个函数返回一个数字，而不是哪些字符是正确的，因此我们实际上并不知道*哪些*字符是正确的！
- en: What’s our score?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的得分是多少？
- en: '>>> newList = makeList()'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> newList = makeList()'
- en: '>>> score(newList)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> score(newList)'
- en: '0'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Our first guess was a total strikeout. Not a single match!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一次尝试完全失败了。没有一个匹配！
- en: WRITING THE MUTATE() FUNCTION
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 MUTATE() 函数
- en: Now we’ll write a function to mutate a list by randomly changing one character.
    This will allow our program to “make guesses” until we get closer to the target
    phrase we’re trying to guess. The code is in [Listing 12-3](ch12.xhtml#ch12list3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一个函数，通过随机改变一个字符来变异一个列表。这将允许我们的程序“猜测”直到接近我们想要猜测的目标短语。代码见 [列表 12-3](ch12.xhtml#ch12list3)。
- en: '*genetic'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*genetic'
- en: Quote.py*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Quote.py*
- en: 'def mutate(mylist):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'def mutate(mylist):'
- en: '''''''Returns mylist with one letter changed'''''''
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回修改了一个字母的 mylist'''''''
- en: newlist = list(mylist)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: newlist = list(mylist)
- en: new_letter = random.choice(characters)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: new_letter = random.choice(characters)
- en: index = random.randint(0,len(target)-1)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: index = random.randint(0,len(target)-1)
- en: newlist[index] = new_letter
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: newlist[index] = new_letter
- en: return newlist
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: return newlist
- en: '*Listing 12-3: Writing the mutate() function for changing one character in
    a list*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-3：编写 mutate() 函数来更改列表中的一个字符*'
- en: First, we copy the elements of the list to a variable called newlist. We then
    randomly choose a character from the characters list to be the new letter that
    will replace one of the existing characters. We randomly choose a number between
    0 and the length of the target to be the index of the letter we replace. Then
    we set the character in newlist at that index to be the new letter. This process
    repeats over and over again in a loop. If the new list has a higher score, it’ll
    become the “best” list, and the best list will keep getting mutated in the hope
    of improving its score even more.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将列表的元素复制到一个名为 newlist 的变量中。然后我们从 characters 列表中随机选择一个字符作为新字母，替换掉现有字符中的一个。我们随机选择一个介于
    0 和目标长度之间的数字作为替换字母的索引。然后我们将 newlist 中该索引处的字符替换为新字母。这个过程会在一个循环中不断重复。如果新列表的得分更高，它将成为“最佳”列表，而最佳列表将继续进行变异，希望能够进一步提高得分。
- en: GENERATING A RANDOM NUMBER
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Starting off the program after all the function definitions, we make sure of
    our randomness by calling random.seed(). Calling random.seed() resets the random
    number generator to the present time. Then we make a list of characters and, since
    the first list is the best one so far, declare it the best list. Its score will
    be the best score.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有函数定义之后启动程序，我们通过调用 random.seed() 来确保随机性。调用 random.seed() 会将随机数生成器重置为当前时间。然后我们创建一个字符列表，并将第一个列表声明为最佳列表，因为它是到目前为止最好的。它的得分将是最高分。
- en: '*genetic'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*genetic'
- en: Quote.py*
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Quote.py*
- en: random.seed()
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: random.seed()
- en: bestList = makeList()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: bestList = makeList()
- en: bestScore = score(bestList)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: bestScore = score(bestList)
- en: 'We keep track of how many guesses we’ve made:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪已经做出的猜测次数：
- en: guesses = 0
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: guesses = 0
- en: 'Now we start an infinite loop that will mutate bestList to make a new guess.
    We calculate its score and increment the guesses variable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始一个无限循环，变异 bestList 以生成新的猜测。我们计算它的分数并增加 guesses 变量：
- en: 'while True:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: guess = mutate(bestList)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: guess = mutate(bestList)
- en: guessScore = score(guess)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: guessScore = score(guess)
- en: guesses += 1
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: guesses += 1
- en: If the score of the new guess is less than or equal to the best score so far,
    the program can “continue,” as shown next. That means it will go back to the beginning
    of the loop, since it wasn’t a good guess, and we don’t need to do anything else
    with it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新猜测的分数小于或等于当前最佳分数，程序可以“继续”，如下所示。这意味着它将返回循环的开始，因为这不是一个好的猜测，我们不需要对其做其他处理。
- en: 'if guessScore <= bestScore:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'if guessScore <= bestScore:'
- en: continue
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: 'If we’re still in the loop, that means the guess is good enough to print out.
    We print its score, too. We can print the list (as a string), the score, and how
    many total guesses were made. If the score of the new guess is the same as the
    length of the target, then we’ve solved the quote and we can break out of the
    loop:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然在循环中，说明这个猜测足够好，可以打印出来。我们也打印它的分数。我们可以打印列表（作为字符串）、分数以及做出的总猜测次数。如果新猜测的分数等于目标的长度，那么我们已经解决了这个问题，可以退出循环：
- en: print(''.join(guess),guessScore,guesses)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: print(''.join(guess),guessScore,guesses)
- en: 'if guessScore == len(target):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'if guessScore == len(target):'
- en: break
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'Otherwise, the new guess must be better than the best list so far, but not
    perfect yet, so we can declare it the best list and save its score as the best
    score:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，新猜测必须比当前最好的列表更好，但还不完美，所以我们可以宣布它为最佳列表，并将其分数保存为最佳分数：
- en: bestList = list(guess)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: bestList = list(guess)
- en: bestScore = guessScore
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: bestScore = guessScore
- en: Listing 12-4 shows the entire code for the *geneticQuote.py* program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-4 显示了 *geneticQuote.py* 程序的完整代码。
- en: '*genetic Quote.py*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*genetic Quote.py*'
- en: import random
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: target = "I never go back on my word, because that is my Ninja way."
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: target = "I never go back on my word, because that is my Ninja way."
- en: characters = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: characters = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"
- en: '#function to create a "guess" list of characters the same length as target'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个与目标长度相同的字符“猜测”列表的函数'
- en: 'def makeList():'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'def makeList():'
- en: '''''''Returns a list of characters the same length'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回一个字符列表，长度与目标相同'
- en: as the target'''
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为目标'''
- en: 'charList = [] #empty list to fill with random characters'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'charList = [] #空列表，用于填充随机字符'
- en: 'for i in range(len(target)):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(target)):'
- en: charList.append(random.choice(characters))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: charList.append(random.choice(characters))
- en: return charList
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: return charList
- en: '#function to "score" the guess list by comparing it to target'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#函数用于通过与目标比较来“评分”猜测列表'
- en: 'def score(mylist):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'def score(mylist):'
- en: '''''''Returns one integer: the number of matches with target'''''''
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回一个整数：与目标匹配的数量'''''''
- en: matches = 0
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: matches = 0
- en: 'for i in range(len(target)):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(target)):'
- en: 'if mylist[i] == target[i]:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mylist[i] == target[i]:'
- en: matches += 1
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: matches += 1
- en: return matches
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: return matches
- en: '#function to "mutate" a list by randomly changing one letter'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#函数用于通过随机更改一个字母来“变异”列表'
- en: 'def mutate(mylist):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'def mutate(mylist):'
- en: '''''''Returns mylist with one letter changed'''''''
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回我的列表，并将一个字母更改'''''''
- en: newlist = list(mylist)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: newlist = list(mylist)
- en: new_letter = random.choice(characters)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: new_letter = random.choice(characters)
- en: index = random.randint(0,len(target)-1)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: index = random.randint(0,len(target)-1)
- en: newlist[index] = new_letter
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: newlist[index] = new_letter
- en: return newlist
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: return newlist
- en: '#create a list, set the list to be the bestList'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个列表，并将该列表设置为 bestList'
- en: '#set the score of bestList to be the bestScore'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#将 bestList 的分数设置为 bestScore'
- en: random.seed()
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: random.seed()
- en: bestList = makeList()
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: bestList = makeList()
- en: bestScore = score(bestList)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: bestScore = score(bestList)
- en: guesses = 0
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: guesses = 0
- en: '#make an infinite loop that will create a mutation'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个无限循环来生成变异'
- en: '#of the bestList, score it'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#对 bestList 进行评分'
- en: 'while True:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: guess = mutate(bestList)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: guess = mutate(bestList)
- en: guessScore = score(guess)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: guessScore = score(guess)
- en: guesses += 1
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: guesses += 1
- en: '#if the score of the newList is lower than the bestList,'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#如果 newList 的分数低于 bestList，'
- en: '#"continue" on to the next iteration of the loop'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#"继续"进入下一次循环迭代'
- en: 'if guessScore <= bestScore:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'if guessScore <= bestScore:'
- en: continue
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '#if the score of the newlist is the optimal score,'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#如果新列表的分数是最佳分数，'
- en: '#print the list and break out of the loop'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#打印列表并退出循环'
- en: print(''.join(guess),guessScore,guesses)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: print(''.join(guess),guessScore,guesses)
- en: 'if guessScore == len(target):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'if guessScore == len(target):'
- en: break
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: '#otherwise, set the bestList to the value of the newList'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '#否则，将 bestList 设置为 newList 的值'
- en: '#and the bestScore to be the value of the score of the newList'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '#并且 bestScore 赋值为 newList 中分数的值'
- en: bestList = list(guess)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: bestList = list(guess)
- en: bestScore = guessScore
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: bestScore = guessScore
- en: '*Listing 12-4: The complete code for the* geneticQuote.py *program*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-4：* geneticQuote.py *程序的完整代码*'
- en: Now when we run this, we get a very fast solution, with all the guesses that
    improved the score printed out.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行这个时，我们得到了一个非常快速的解决方案，所有提高分数的猜测都会被打印出来。
- en: i.fpzgPG.'kHT!NW WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 1 178
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: i.fpzgPG.'kHT!NW WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 1 178
- en: i.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 2 237
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: i.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 2 237
- en: i.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 3 266
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: i.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 3 266
- en: i fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 4 324
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: i fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 4 324
- en: --snip--
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: --略--
- en: I nevgP go back on my word, because that is my Ninja way. 55 8936
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我 nevgP 从不食言，因为那是我的忍者之道。55 8936
- en: I neveP go back on my word, because that is my Ninja way. 56 10019
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我 neveP 从不食言，因为那是我的忍者之道。56 10019
- en: I never go back on my word, because that is my Ninja way. 57 16028
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我从不食言，因为那是我的忍者之道。57 16028
- en: This output shows that the final score was 57, and it took 16,028 total guesses
    to match the quote exactly. Notice on the first line of output that 178 guesses
    were needed to get a score of 1! There are more efficient ways of guessing a quote,
    but I wanted to introduce the idea of genetic algorithms using an easy example.
    The point was to show how a method of scoring guesses and randomly mutating the
    “best guess so far” could produce accurate results in a surprisingly short amount
    of time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示最终分数是 57，并且总共进行了 16,028 次猜测才完全匹配引用。在输出的第一行中，注意到需要 178 次猜测才能得到 1 分！有更高效的方式来猜测一个引用，但我想通过一个简单的例子来介绍遗传算法的概念。重点是展示如何通过对猜测进行评分并随机变异“迄今为止最好的猜测”，在惊人的短时间内得出准确的结果。
- en: Now, you can use this idea of scoring and mutating thousands of random guesses
    to solve other problems, too.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这种对猜测进行评分和变异的思路来解决其他问题。
- en: '### SOLVING THE TRAVELING SALESPERSON PROBLEM (TSP)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '### 解决旅行推销员问题（TSP）'
- en: One of my students was unimpressed with the quote-guessing program because “we
    already know what the quote is.” So let’s use a genetic algorithm to solve a problem
    we don’t already know the solution for. *The Traveling Salesperson Problem*, or
    *TSP* for short, is an age-old brainteaser that is easy to understand but can
    become very difficult to solve. A salesperson has to travel to a given number
    of cities, and the goal is to find the route with the shortest distance. Sounds
    easy? And with a computer, we should simply be able to run all the possible routes
    through a program and measure their distances, right?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一个学生对引用猜测程序不感兴趣，因为“我们已经知道引用是什么了。”所以让我们使用遗传算法来解决一个我们还不知道解决方案的问题。*旅行推销员问题*，简称
    *TSP*，是一个古老的智力题，容易理解但可能变得非常难以解决。一个推销员必须到达给定数量的城市，目标是找到最短的路线。听起来很简单吧？而且有了计算机，我们应该只需运行所有可能的路线，并测量它们的距离，对吧？
- en: It turns out, above a certain number of cities, the computational complexity
    gets too much even for today’s supercomputers. Let’s see how many possible routes
    there are when you have six cities, as shown in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，超过某个城市数量后，即便是今天的超级计算机，计算复杂度也会变得过于庞大。让我们来看一下，当你有六个城市时，会有多少条可能的路线，正如在[图 12-1](ch12.xhtml#ch12fig1)中所示。
- en: '![image](../images/f254-01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f254-01.jpg)'
- en: '*Figure 12-1: The number of paths between* n *cities for* n *between 2 and
    6*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：* n *个城市之间路径的数量，* n *在 2 到 6 之间*'
- en: When there are two or three cities, there’s only one possible route. Add a fourth
    city, and it could be visited between any of the previous three, so multiply the
    previous number of routes by 3\. So between four cities there are three possible
    routes. Add a fifth city, and it could be visited between any of the previous
    four, so there are four times as many as the previous step, so 12 possible routes.
    See the pattern? Between *n* cities, there are
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当城市数量为两三个时，只有一条可能的路线。加上第四个城市，它可以在之前的任何三个城市之间被访问，所以将前一个路线数量乘以 3。那么四个城市之间有三条可能的路线。再加上第五个城市，它可以在之前的四个城市之间被访问，所以是前一步的四倍，即有
    12 条可能的路线。看出规律了吗？在 *n* 个城市之间，有
- en: '![image](../images/e254-01.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e254-01.jpg)'
- en: possible routes. So between 10 cities there are 181,440 possible routes. Between
    20 cities, there are 60,822,550,204,416,000 routes. What’s after a trillion? Even
    if a computer can check a million routes per second, it would still take almost
    2,000 years to calculate. That’s too slow for our purposes. There must be a better
    way.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的路线。比如，在10个城市之间有181,440种可能的路线。在20个城市之间，有60,822,550,204,416,000条路线。超过一万亿的是什么？即使一台计算机每秒能检查一百万条路线，也需要近2000年才能完成计算。对于我们的目的来说，这样的速度太慢了。必须有更好的方法。
- en: USING GENETIC ALGORITHMS
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用遗传算法
- en: Similar to our quote-guessing program, we’re going to create an object with
    a route in its “genes” and then score its route by how short it is. The best route
    will then be mutated randomly, and we’ll score its mutation. We could take a bunch
    of “best routes,” splice together their lists, and score their “offspring.” The
    best part of this exploration is we *don’t* know the answer already. We could
    give the program a set of cities and their locations, or just have it randomly
    draw cities and try to optimize the route.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们的猜名言程序，我们将创建一个带有“基因”中路线的对象，并通过路线的长度来评分。最佳路线将随机变异，然后我们将对其变异进行评分。我们可以收集一堆“最佳路线”，将它们的列表拼接在一起，然后评分它们的“后代”。这次探索的最棒之处在于我们*并不知道*答案。我们可以给程序一组城市及其位置，或者让程序随机绘制城市并尝试优化路线。
- en: Open a new Processing sketch and call it *travelingSalesperson.pyde*. The first
    thing we should create is a City object. Each city will have its own x- and y-coordinate
    and a number we use to identify it. That way, we can define a route using a list
    of city numbers. For example, [5,3,0,2,4,1] means you start at city 5 and go to
    city 3, then city 0, and so on. The rules are the salesperson has to finally return
    to the first city. [Listing 12-5](ch12.xhtml#ch12list5) shows the City class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Processing草图并命名为*travelingSalesperson.pyde*。我们首先要创建的是City对象。每个城市将有自己的x和y坐标，以及一个用于标识的编号。这样，我们就可以使用城市编号的列表来定义一条路线。例如，[5,3,0,2,4,1]表示你从城市5出发，前往城市3，然后是城市0，依此类推。规则是销售员最终必须返回到第一个城市。[Listing
    12-5](ch12.xhtml#ch12list5)展示了City类。
- en: '*travelingSales person.pyde*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*travelingSalesperson.pyde*'
- en: 'class City:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'class City:'
- en: 'def __init__(self,x,y,num):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y,num):'
- en: self.x = x
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: 'self.number = num #identifying number'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.number = num #标识编号'
- en: 'def display(self):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display(self):'
- en: 'fill(0,255,255) #sky blue'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(0,255,255) #天空蓝'
- en: ellipse(self.x,self.y,10,10)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.x,self.y,10,10)
- en: noFill()
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: noFill()
- en: '*Listing 12-5: Writing the City class for the* travelingSalesperson.pyde *program*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-5：为* travelingSalesperson.pyde *程序编写City类*'
- en: When initializing City, we get an x- and y-coordinate and give each City its
    own (self) x- and y-component. We also get a number that’s the city’s identifying
    number. In the display() method, we choose a color (sky blue, in this case) and
    create an ellipse at that location. We turn off the fill after drawing the city
    with the noFill() function, since no other shapes need to be filled in with color.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化City时，我们获得x和y坐标，并为每个City对象赋予自己的x和y分量。我们还得到一个编号，这是城市的标识号。在display()方法中，我们选择一个颜色（此例为天空蓝），并在该位置创建一个椭圆。绘制完城市后，我们使用noFill()函数关闭填充，因为其他形状无需用颜色填充。
- en: Let’s make sure that works. Let’s create the setup() function, declaring a size
    for the display window and creating an instance of our City class. Remember, we
    have to give it a location of two coordinates and an identifying number as in
    [Listing 12-6](ch12.xhtml#ch12list6).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保它有效。我们来创建setup()函数，为显示窗口指定大小，并创建City类的一个实例。记住，我们需要为它提供两个坐标的位置以及一个标识编号，如[Listing
    12-6](ch12.xhtml#ch12list6)所示。
- en: 'def setup():'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: background(0)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: background(0)
- en: city0 = City(100,200,0)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: city0 = City(100,200,0)
- en: city0.display()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: city0.display()
- en: '*Listing 12-6: Writing the setup() function for creating one city*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-6：编写创建一个城市的setup()函数*'
- en: Run this, and you’ll see your first city (see [Figure 12-2](ch12.xhtml#ch12fig2))!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个，你将看到你的第一个城市（见[图12-2](ch12.xhtml#ch12fig2)）！
- en: '![image](../images/f256-01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f256-01.jpg)'
- en: '*Figure 12-2: The first city*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：第一个城市*'
- en: 'It might help to have the city display its number above it. To do that, add
    this to the city’s display() method, just before noFill():'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有助于在城市上方显示其编号。为此，在城市的display()方法中，在noFill()之前添加以下代码：
- en: textSize(20)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: textSize(20)
- en: text(self.number,self.x-10,self.y-10)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: text(self.number,self.x-10,self.y-10)
- en: 'We declare the size of the text using Processing’s built-in textSize() function.
    Then we use the text() function to tell the program what to print (the number
    of the city) and where to print it (10 pixels to the left and above the city).
    While we’re creating cities, let’s start a cities list and put a few more cities
    on the screen in random locations. To use methods from the random module, we have
    to import random at the top of the file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Processing内置的`textSize()`函数来声明文本的大小。然后我们使用`text()`函数告诉程序要打印什么（城市的编号）以及打印的位置（在城市的左上方，距离城市10像素）。在创建城市时，让我们启动一个`cities`列表，并在屏幕上随机位置添加更多城市。为了使用`random`模块中的方法，我们需要在文件顶部导入`random`模块：
- en: import random
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: Now we can update our setup() function like in [Listing 12-7](ch12.xhtml#ch12list7).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像[列表12-7](ch12.xhtml#ch12list7)中一样更新`setup()`函数。
- en: '*travelingSalesperson.pyde*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*travelingSalesperson.pyde*'
- en: cities = []
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: cities = []
- en: 'def setup():'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: background(0)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: background(0)
- en: 'for i in range(6):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(6):'
- en: cities.append(City(random.randint(50,width-50),
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: cities.append(City(random.randint(50,width-50),
- en: random.randint(50,height-50),i))
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: random.randint(50,height-50),i))
- en: 'for city in cities:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'for city in cities:'
- en: city.display()
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: city.display()
- en: '*Listing 12-7: Writing the setup() function for creating six random cities*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-7：编写`setup()`函数以创建六个随机城市*'
- en: In the setup() function, we’ve added a loop to run six times. It adds a City
    object at a random location on the screen 50 units from the edges. The next loop
    iterates over all the elements in the cities list and displays each one. Run this,
    and you’ll see six cities in random locations, labeled with their ID numbers,
    as in [Figure 12-3](ch12.xhtml#ch12fig3).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们添加了一个循环，循环六次。每次循环都会在屏幕上随机位置（距离边缘50个单位）添加一个City对象。下一个循环遍历`cities`列表中的所有元素并显示每个城市。运行这个代码，你将看到六个城市出现在随机位置，并标上它们的ID编号，如[图12-3](ch12.xhtml#ch12fig3)所示。
- en: '![image](../images/f257-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f257-01.jpg)'
- en: '*Figure 12-3: Six cities, labeled with their numbers*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：六个城市，标有它们的编号*'
- en: 'Now let’s think about the route between the cities. We put the City objects
    (containing their locations and numbers) into the cities list, and eventually
    that list of numbers (our “genetic material”) will consist of the city numbers
    in a certain order. So the Route object needs a random list of numbers, too: a
    random sequence of all the city numbers. Of course, the numbers will be range
    from 0 to 1 less than the number of cities. We don’t want to keep changing numbers
    here and there in our code whenever we want to change the number of cities, so
    we’ll create a variable for the number of cities. Put this line at the beginning
    of the file, before the City class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们思考城市之间的路线。我们将City对象（包含它们的位置和编号）放入`cities`列表，最终这些编号（我们的“遗传物质”）会按特定的顺序排列。因此，Route对象也需要一个随机的数字列表：一个包含所有城市编号的随机顺序。当然，这些编号会在0到城市数量减1之间。我们不想在代码中每次想要改变城市数量时都去更改这些数字，因此我们会为城市数量创建一个变量。把这行代码放在文件的开头，City类之前：
- en: N_CITIES = 10
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: N_CITIES = 10
- en: Why is N_CITIES in all capital letters? Throughout all the code, we won’t be
    changing the number of cities. So it’s not really a variable; instead, it’s a
    constant. It’s customary in Python to capitalize constant names to set them apart
    from variables. This doesn’t change the way Python deals with them at all; variables
    with capitalized names can still be changed. So be careful.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`N_CITIES`是全大写字母？在整个代码中，我们不会改变城市的数量。因此它实际上不是一个变量，而是一个常量。在Python中，习惯上会将常量的名称大写，以与变量区分。这并不会改变Python对它们的处理方式；即使是大写名称的变量也依然可以修改。所以要小心。
- en: We’ll use N_CITIES wherever we would be using the total number of cities, and
    we’ll only need to change the value once! Place the code shown in [Listing 12-8](ch12.xhtml#ch12list8)
    after the City class.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中需要使用城市总数的地方使用`N_CITIES`，这样我们只需要更改一次值！把[列表12-8](ch12.xhtml#ch12list8)中显示的代码放在City类之后。
- en: 'class Route:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Route:'
- en: 'def __init__(self):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.distance = 0
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: self.distance = 0
- en: '#put cities in a list in order:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '#按顺序将城市放入列表：'
- en: self.cityNums = random.sample(list(range(N_CITIES)),N_CITIES)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: self.cityNums = random.sample(list(range(N_CITIES)), N_CITIES)
- en: '*Listing 12-8: The Route class*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-8：Route类*'
- en: First, we set the route’s distance (or length, but length is a keyword in Processing)
    to zero, and then we create a cityNums list that puts the numbers of the cities
    in a random order for that route.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将路线的距离（或长度，虽然“长度”是Processing中的一个关键字）设置为零，然后我们创建一个`cityNums`列表，将城市的编号按随机顺序排列，形成这条路线的城市顺序。
- en: 'You can use the random module’s sample() function to give Python a list and
    then sample a number of items from that list by telling it how many items to choose
    randomly. It’s like choice(), but it won’t select an item more than once. In probability,
    it’s called “sampling without replacement.” Enter the following in IDLE to see
    how sampling works:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 random 模块的 sample() 函数，给 Python 一个列表，然后通过告诉它要随机选择多少项来从列表中选择一些项。这类似于 choice()，但它不会选择同一项两次。在概率论中，这叫做“无替代抽样”。在
    IDLE 中输入以下内容，看看抽样是如何工作的：
- en: '>>> n = list(range(10))'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> n = list(range(10))'
- en: '>>> n'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> n'
- en: '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
- en: '>>> import random'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import random'
- en: '>>> x = random.sample(n,5)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = random.sample(n,5)'
- en: '>>> x'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[2, 0, 5, 3, 8]'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[2, 0, 5, 3, 8]'
- en: Here, we create a list called n of the numbers between 0 and 9 by calling range(10)
    and converting it (it’s a “generator”) into a list. We then import the random
    module and ask Python to use the sample() function to pick a sample of five items
    from list n and save them to list x. In our Route code in [Listing 12-8](ch12.xhtml#ch12list8),
    since the variable N_CITIES, representing the number of cities, is 10, we’re choosing
    10 numbers at random using range(10), the numbers 0 to 9, and assigning them to
    the Route’s cityNums property.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用 range(10) 并将其转换（它是一个“生成器”）成列表，创建一个名为 n 的列表，包含 0 到 9 之间的数字。然后我们导入
    random 模块，并要求 Python 使用 sample() 函数从列表 n 中随机挑选五个项目，并将它们保存到列表 x 中。在我们的 Route 代码
    [列表 12-8](ch12.xhtml#ch12list8) 中，由于变量 N_CITIES 表示城市数量为 10，我们正在使用 range(10) 随机选择
    10 个数字（0 到 9），并将它们赋值给 Route 的 cityNums 属性。
- en: And how will this display? Let’s draw purple lines between the cities. You can
    use any color you’d prefer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个如何显示呢？让我们在城市之间绘制紫色的线条。你可以使用任何你喜欢的颜色。
- en: Drawing lines between cities like this should remind you of drawing lines between
    the points on a graph in algebra or trigonometry lessons. The only difference
    is now at the end of the graph we have to return to the starting point. Remember
    using beginShape, vertex, and endShape in Chapter 6? Just like we used lines to
    draw a shape, we’ll draw the Route object as the outline of a shape, except this
    time we just won’t fill it in. Using endshape(CLOSE) will automatically close
    the loop! Add the code in [Listing 12-9](ch12.xhtml#ch12list9) to the Route class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样在城市之间绘制线条，应该会让你想起代数或三角学课程中在图表点之间绘制线条。唯一的区别是现在在图形的末端，我们必须回到起点。记得第 6 章中使用过
    beginShape、vertex 和 endShape 吗？就像我们用线条绘制形状一样，我们会把 Route 对象画成一个形状的轮廓，只不过这次我们不会填充它。使用
    endShape(CLOSE) 将自动闭合循环！将 [列表 12-9](ch12.xhtml#ch12list9) 中的代码添加到 Route 类中。
- en: 'def display(self):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display(self):'
- en: strokeWeight(3)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(3)
- en: 'stroke(255,0,255) #purple'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(255,0,255) #紫色'
- en: beginShape()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: 'for i in self.cityNums:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in self.cityNums:'
- en: vertex(cities[i].x,cities[i].y)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(cities[i].x,cities[i].y)
- en: '#then display the cities and their numbers'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '#然后显示城市及其编号'
- en: cities[i].display()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: cities[i].display()
- en: endShape(CLOSE)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: '*Listing 12-9: Writing the display method of the Route class*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-9：编写 Route 类的 display 方法*'
- en: The loop makes every city in the Route’s cityNums list a vertex of a polygon.
    The route is the outline of the polygon. Notice that inside the Route’s display()
    method we call the city’s display() method. That way, we don’t have to manually
    command the cities to display separately.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环使 Route 的 cityNums 列表中的每个城市成为多边形的一个顶点。路线是多边形的轮廓。注意在 Route 的 display() 方法中，我们调用了城市的
    display() 方法。这样，我们就不需要手动命令每个城市单独显示了。
- en: In the setup() function, we’ll create a Route object with the cities list and
    a list of numbers as arguments. Then we’ll display it. The last two lines of code
    at the bottom of [Listing 12-10](ch12.xhtml#ch12list10) do this.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 setup() 函数中，我们将使用城市列表和数字列表作为参数创建一个 Route 对象。然后我们会显示它。下面 [列表 12-10](ch12.xhtml#ch12list10)
    的最后两行代码就是这样做的。
- en: 'def setup():'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: background(0)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: background(0)
- en: 'for i in range(N_CITIES):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(N_CITIES):'
- en: cities.append(City(random.randint(50,width-50),
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: cities.append(City(random.randint(50,width-50),
- en: random.randint(50,height-50),i))
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: random.randint(50,height-50),i))
- en: route1 = Route()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: route1 = Route()
- en: route1.display()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: route1.display()
- en: '*Listing 12-10: Displaying a route*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-10：显示路线*'
- en: Run this, and you’ll see a path between the cities, in random order, as shown
    in [Figure 12-4](ch12.xhtml#ch12fig4).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，你将看到城市之间的路径，按随机顺序排列，如 [图 12-4](ch12.xhtml#ch12fig4) 所示。
- en: '![image](../images/f259-01.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f259-01.jpg)'
- en: '*Figure 12-4: A random route order*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：随机的路线顺序*'
- en: To change the number of cities, simply change the first line, where we declare
    N_CITIES, to a different number and then run the program. [Figure 12-5](ch12.xhtml#ch12fig5)
    shows my output for N_CITIES = 7.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改城市的数量，只需更改第一行中声明 N_CITIES 的数值，然后运行程序即可。[图 12-5](ch12.xhtml#ch12fig5) 显示了
    N_CITIES = 7 时的输出结果。
- en: '![image](../images/f260-01.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f260-01.jpg)'
- en: '*Figure 12-5: A route with seven cities*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5: 七个城市的路线*'
- en: Now that you can create and display routes, let’s write a function to measure
    the distance of each route.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建并显示路线了，让我们编写一个函数来衡量每条路线的距离。
- en: WRITING THE CALCLENGTH() METHOD
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 CALCLENGTH() 方法
- en: The Route object has a distance property that’s set to zero when it’s created.
    Each Route object also has a list of cities, in order, called cityNums. We just
    have to loop through the cityNums list and keep a running total of the distances
    between each pair of cities. No problem for cities 0 to 4, but we also need to
    calculate the distance from the last city back to the first one.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Route 对象有一个距离属性，在创建时被设置为零。每个 Route 对象还有一个城市列表，按顺序排列，称为 cityNums。我们只需要遍历 cityNums
    列表，保持每对城市之间的距离总和。对于城市 0 到 4 没问题，但我们还需要计算从最后一个城市回到第一个城市的距离。
- en: '[Listing 12-11](ch12.xhtml#ch12list11) shows the code for the calcLength()
    method, which goes inside the Route object.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-11](ch12.xhtml#ch12list11) 显示了 calcLength() 方法的代码，该方法位于 Route 对象内部。'
- en: 'def calcLength(self):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calcLength(self):'
- en: self.distance = 0
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: self.distance = 0
- en: 'for i,num in enumerate(self.cityNums):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i,num in enumerate(self.cityNums):'
- en: '# find the distance from the current city to the previous city'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算当前城市到前一个城市的距离'
- en: self.distance += dist(cities[num].x,
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: self.distance += dist(cities[num].x,
- en: cities[num].y,
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: cities[num].y,
- en: cities[self.cityNums[i-1]].x,
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: cities[self.cityNums[i-1]].x,
- en: cities[self.cityNums[i-1]].y)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: cities[self.cityNums[i-1]].y)
- en: return self.distance
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: return self.distance
- en: '*Listing 12-11: Calculating a Route’s length*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-11: 计算路线的长度*'
- en: 'First, we zero out the distance property of the Route so every time we call
    this method it’ll start at zero. We use the enumerate() function so we can get
    not just the number in the cityNums list but also its index. We then increment
    the distance property by the distance from the current city (num) to the previous
    city (self.cityNums[i-1]). Next, let’s add this line of code to the end of our
    setup() function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 Route 的距离属性清零，这样每次调用该方法时，它都会从零开始。我们使用 enumerate() 函数，这样不仅可以获取 cityNums
    列表中的城市编号，还能得到其索引。然后，我们将距离属性按从当前城市（num）到前一个城市（self.cityNums[i-1]）的距离递增。接下来，让我们将这行代码添加到
    setup() 函数的末尾：
- en: println(route1.calcLength())
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: println(route1.calcLength())
- en: We can now see the total distance covered by the salesperson in the console,
    like in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在控制台中看到销售员行驶的总距离，如 [图 12-6](ch12.xhtml#ch12fig6) 所示。
- en: '![image](../images/f261-01.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f261-01.jpg)'
- en: '*Figure 12-6: We’ve calculated the distance . . . I think*.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6: 我们已经计算出距离...我想说*。'
- en: Is this really the distance? Let’s make sure.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是距离吗？让我们确认一下。
- en: TESTING THE CALCLENGTH() METHOD
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试 CALCLENGTH() 方法
- en: 'Let’s give the program an easy route that’s a square of sidelength 200 and check
    the distance. First, we change our constant for the number of cities to 4:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给程序一个简单的路线，这条路线是一个边长为 200 的正方形，接着检查距离。首先，我们将城市数量的常量更改为 4：
- en: N_CITIES = 4
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: N_CITIES = 4
- en: Next, we change the setup() function to what’s shown in [Listing 12-12](ch12.xhtml#ch12list12).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 setup() 函数更改为 [列表 12-12](ch12.xhtml#ch12list12) 中所示的内容。
- en: cities = [City(100,100,0), City(300,100,1),
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: cities = [City(100,100,0), City(300,100,1),
- en: City(300,300,2), City(100,300,3)]
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: City(300,300,2), City(100,300,3)]
- en: 'def setup():'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: background(0)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: background(0)
- en: '''''''for i in range(N_CITIES):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''for i in range(N_CITIES):'
- en: cities.append(City(random.randint(0,width),
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: cities.append(City(random.randint(0,width),
- en: random.randint(0,height),i))'''
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: random.randint(0,height),i))'''
- en: route1 = Route()
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: route1 = Route()
- en: route1.cityNums = [0,1,2,3]
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: route1.cityNums = [0,1,2,3]
- en: route1.display()
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: route1.display()
- en: println(route1.calcLength())
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: println(route1.calcLength())
- en: '*Listing 12-12: Creating a Route manually to test the calcLength() method*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-12: 手动创建一个路线以测试 calcLength() 方法*'
- en: We comment out the loop to create cities at random, because we’ll go back to
    it after checking the calcLength() method. We create a new cities list containing
    the vertices of a square of sidelength 200\. We also declare the cityNums list
    for route1; otherwise, it would randomly mix the cities. We expect the length
    of this Route to be 800.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注释掉了随机创建城市的循环，因为我们会在检查完 calcLength() 方法后再回来处理这个部分。我们创建了一个新的城市列表，包含了边长为 200
    的正方形的顶点。我们还为 route1 声明了 cityNums 列表；否则，它会随机排列城市。我们预计这个 Route 的长度应该是 800。
- en: When we run the code, we see what’s in [Figure 12-7](ch12.xhtml#ch12fig7).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f262-01.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-7: The calcLength() method works!*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: It’s 800 units, as predicted! You can try some rectangles or some other easy-to-verify
    routes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: RANDOM ROUTES
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to find the shortest possible route to a destination, we need to find all
    the possible routes. To do this, we need our infinite loop and Processing’s built-in
    draw() function. We’ll move the route code from setup() to the draw() function.
    We’ll also create a bunch of random routes and display them and their length.
    The entire code is shown in [Listing 12-13](ch12.xhtml#ch12list13).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '*travelingSales person.pyde*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: N_CITIES = 10
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'class City:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self,x,y,num):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: self.x = x
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: self.y = y
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'self.number = num #identifying number'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'def display(self):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(0,255,255) #sky blue'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(self.x,self.y,10,10)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: textSize(20)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: text(self.number,self.x-10,self.y-10)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: noFill()
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'class Route:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: self.distance = 0
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '#put cities in a list in numList order:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: self.cityNums = random.sample(list(range(N_CITIES)),N_CITIES)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'def display(self):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: strokeWeight(3)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(255,0,255) #purple'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: beginShape()
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in self.cityNums:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: vertex(cities[i].x,cities[i].y)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '#then display the cities and their numbers'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: cities[i].display()
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: endShape(CLOSE)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'def calcLength(self):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: self.distance = 0
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'for i,num in enumerate(self.cityNums):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '# find the distance to the previous city'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: self.distance += dist(cities[num].x,
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: cities[num].y,
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: cities[self.cityNums[i-1]].x,
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: cities[self.cityNums[i-1]].y)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: return self.distance
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: cities = []
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N_CITIES):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: cities.append(City(random.randint(50,width-50),
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: random.randint(50,height-50),i))
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: background(0)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: route1 = Route()
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: route1.display()
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: println(route1.calcLength())
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-13: Creating and displaying random routes*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, you should see a bunch of routes being displayed and a bunch
    of numbers being printed to the console.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: But we’re really only interested in keeping the best (shortest) route, so we’ll
    add some code to save the “bestRoute” and check the new random routes. Change
    setup() and draw() to what’s shown in [Listing 12-14](ch12.xhtml#ch12list14).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: cities = []
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: random_improvements = 0
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: mutated_improvements = 0
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: global best, record_distance
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N_CITIES):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: cities.append(City(random.randint(50,width-50),
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: random.randint(50,height-50),i))
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: best = Route()
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: record_distance = best.calcLength()
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: global best, record_distance, random_improvements
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: background(0)
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: best.display()
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: println(record_distance)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'println("random: "+str(random_improvements))'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: route1 = Route()
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: length1 = route1.calcLength()
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'if length1 < record_distance:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: record_distance = length1
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: best = route1
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: random_improvements += 1
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-14: Keeping track of random improvements*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Before the setup() function, we create a variable to count the number of random
    improvements that are made by the program. At the same time, we create a variable
    we’ll use in a few steps to count the mutated improvements.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In setup(), we created route1 to be the first Route, we named it the “best route,”
    and we named its distance the record_distance. Since we want to share these variables
    with other functions, we declare them to be global variables at the beginning
    of the function.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In draw(), we keep generating new random routes and checking if they’re better
    than the one we think is the best route so far. Since we’re using only 10 cities,
    this could pay off with an optimal solution, if we leave it running a while. You’ll
    see that it only requires around a dozen random improvements. But, remember, there
    are only 181,440 unique routes through 10 cities. One 10-city route is shown in
    [Figure 12-8](ch12.xhtml#ch12fig8).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: If you change the number of cities to 20, however, your program will just keep
    running, for days if you let it, and will probably not get close to an optimal
    solution. We need to start using the idea from the phrase-guessing program at
    the beginning of the chapter of scoring our guesses and mutating the best ones.
    Unlike before, we’ll create a “mating pool” of the best routes and combine their
    number lists as if they were genes.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f265-01.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-8: Finding an optimal route randomly—if you can wait a few minutes*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: APPLYING THE PHRASE-GUESSING MUTATION IDEA
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The list of numbers (the cities the salesperson will visit in order) will be
    the genetic material of the Route. First, we see how well some randomly mutated
    routes solve the Traveling Salesman Problem (just like with our phrase-guessing
    programs) and then we mutate and “mate” the better routes with each other to (hopefully)
    create a more optimal route.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: MUTATING TWO NUMBERS IN A LIST
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s write a method to randomly mutate two of the numbers in a Route object’s
    cityNums list. It’s really just a swap. You can probably guess how we’ll randomly
    choose two numbers and make the city numbers that have those indices in the list
    trade places.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Python has a unique notation for swapping the values of two numbers. You can
    swap two numbers without creating a temporary variable. For example, if you enter
    the code in [Listing 12-15](ch12.xhtml#ch12list15) in IDLE, it wouldn’t work.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = 2'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = 3'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = y'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = x'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-15: The wrong way to swap the values of variables*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: When you change the value of x to be the same as y by entering x = y, they both
    become 3\. Now when you try to set y to be the same as x, it’s not set to the
    original value of x (2), but the current value of x, which is 3\. So both variables
    ended up as 3.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'But you *can* swap the values on the same line, like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = 2'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = 3'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x,y = y,x'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Swapping the values of two variables like this is very useful for the mutating
    we’re about to do. Instead of limiting the swapping to only two numbers, we can
    mutate more cities. We can put the swapping in a loop so the program will choose
    any number of cities and swap the first two numbers, then the next pair, and so
    on. The code for the mutateN() method is shown in [Listing 12-16](ch12.xhtml#ch12list16).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'def mutateN(self,num):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: indices = random.sample(list(range(N_CITIES)),num)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: child = Route()
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: child.cityNums = self.cityNums[::]
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(num-1):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: child.cityNums[indices[i]],child.cityNums[indices[(i+1)%num]] = \
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: child.cityNums[indices[(i+1)%num]],child.cityNums[indices[i]]
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: return child
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-16: Writing the mutateN() method, for mutating any number of cities*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: We give the mutateN() method num, a number of cities to swap. Then the method
    makes a list of indices to swap by taking a random sample from the range of city
    numbers. It creates a “child” Route and copies its own city number list to the
    child. Then it swaps num-1 times. If it swapped the full num times, the first
    city swapped would simply get swapped with all the other indices and end up where
    it started.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: That long line of code is simply the a,b = b,a syntax we saw before, only with
    the two cityNums being swapped. The mod (%) operator makes sure your indices don’t
    exceed num, the number of cities in your sample. So if you’re swapping four cities,
    for example, when i is 4, it changes i + 1 from 5 to 5 % 4, which is 1.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add a section to the end of the draw() function to mutate the best
    Route’s list of numbers and test the mutated Route’s length, as shown in [Listing
    12-17](ch12.xhtml#ch12list17).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: global best,record_distance,random_improvements
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: global mutated_improvements
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: background(0)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: best.display()
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: println(record_distance)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'println("random: "+str(random_improvements))'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'println("mutated: "+str(mutated_improvements))'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: route1 = Route()
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: length1 = route1.calcLength()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'if length1 < record_distance:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: record_distance = length1
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: best = route1
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: random_improvements += 1
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2,6):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '#create a new Route'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: mutated = Route()
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '#set its number list to the best one'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: mutated.cityNums = best.cityNums[::]
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'mutated = mutated.mutateN(i) #mutate it'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: length2 = mutated.calcLength()
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'if length2 < record_distance:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: record_distance = length2
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: best = mutated
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: mutated_improvements += 1
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-17: Mutating the best “organism”*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'In the for i in range(2,6): loop, we’re telling the program to mutate 2, 3, 4, and
    5 numbers in the number list and check the results. Now the program often does
    pretty well on a 20-city route in a few seconds, like in [Figure 12-9](ch12.xhtml#ch12fig9).'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f267-01.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: A 20-city route*'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: The mutated “organisms” are improving the distance much better than the random
    ones! [Figure 12-10](ch12.xhtml#ch12fig10) shows the printout.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f268-01.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-10: The mutations are doing much better than the random improvements!*'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-10](ch12.xhtml#ch12fig10) categorizes all the improvements, and
    here 29 of them were due to mutations and only one was due to a randomly generated
    Route. This shows that mutating lists is better at finding the optimal route than
    creating new random ones. I stepped up the mutating to swap anywhere from 2 to
    10 cities by changing this line:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2,11):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Although this improves its performance for 20-city problems and even for some
    30-city problems, the program often gets stuck in a non-optimal rut, like in [Figure
    12-11](ch12.xhtml#ch12fig11).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f268-02.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-11: A 30-city problem stuck in a non-optimal rut*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to take the final step and go fully genetic. Now we won’t be restricting
    ourselves to what we think is the best route so far. Instead, we’ll have an enormous
    population to choose from.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make a population list for any number of routes we want, we’ll take the
    “fittest” ones, cross their number lists, and hopefully make an even better route!
    Just before the setup() function, after the cities list, add the population list
    and the constant for the number of routes, as shown in [Listing 12-18](ch12.xhtml#ch12list18).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: cities = []
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: random_improvements = 0
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: mutated_improvements = 0
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: population = []
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'POP_N = 1000 #number of routes'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-18: Starting a population list and a variable for population size*'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: We just created an empty list to put our population of routes into, and a variable
    for the total number of routes. In the setup() function, we fill the population
    list with POP_N routes, as shown in [Listing 12-19](ch12.xhtml#ch12list19).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: global best,record_distance,first,population
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N_CITIES):'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: cities.append(City(random.randint(50,width-50),
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: random.randint(50,height-50),i))
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '#put organisms in population list'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(POP_N):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: population.append(Route())
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: best = random.choice(population)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: record_distance = best.calcLength()
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: first = record_distance
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-19: Creating a population of routes*'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Notice we had to declare the population list to be a global variable. We put
    POP_N routes in the population list by using for i in range(POP_N), and then we
    made a randomly chosen route the best one so far.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: CROSSING OVER TO IMPROVE ROUTES
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the draw() function, we’re going to sort the population list so the Route
    objects with the lowest lengths are at the beginning. We’ll create a method called
    crossover() to splice the cityNums lists together at random. Here’s what it’ll
    do:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'a: [6, 0, 7, 8, 2, 1, 3, 9, 4, 5]'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'b: [1, 0, 4, 9, 6, 2, 5, 8, 7, 3]'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'index: 3'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'c: [6, 0, 7, 1, 4, 9, 2, 5, 8, 3]'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'The “parents” are lists a and b. The index is chosen randomly: index 3\. Then
    a list is sliced off between index 2 (7) and index 3 (8), so the child list starts
    [6,0,7]. The remaining numbers that aren’t in that slice are added to the child
    list in the order they occur in list b: [1,4,9,2,5,8,3]. We concatenate those
    two lists, and that’s the child list. The code for the crossover() method is shown
    in [Listing 12-20](ch12.xhtml#ch12list20).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'def crossover(self,partner):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Splice together genes with partner''s genes'''''''
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: child = Route()
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '#randomly choose slice point'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: index = random.randint(1,N_CITIES - 2)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '#add numbers up to slice point'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: child.cityNums = self.cityNums[:index]
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '#half the time reverse them'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'if random.random()<0.5:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: child.cityNums = child.cityNums[::-1]
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '#list of numbers not in the slice'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: notinslice = [x for x in partner.cityNums if x not in child.cityNums]
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '#add the numbers not in the slice'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: child.cityNums += notinslice
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: return child
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-20: Writing the crossover() method of the Route class*'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: The crossover() method requires we specify the partner, the other parent. The
    child route is created, and an index where the slicing will take place is chosen
    randomly. The child list gets the numbers in the first slice, and then half the
    time we reverse those numbers, for genetic diversity. We create a list of the
    numbers that aren’t in the slice and add each one as it occurs in the other parent’s
    (or partner’s) list. Finally, concatenate those slices and return the child route.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: In the draw() function, we need to check the routes in the population list for
    the shortest one. Do we need to check each one like before? Luckily, Python provides
    a handy sort() function we can use to sort the population list by calcLength().
    So the first Route in the list will be the shortest one. The final code for the
    draw() function is shown in [Listing 12-21](ch12.xhtml#ch12list21).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: global best,record_distance,population
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: background(0)
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: best.display()
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: println(record_distance)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '#println(best.cityNums) #If you need the exact Route through the cities!'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: ➊ population.sort(key=Route.calcLength)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'population = population[:POP_N] #limit size of population'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: length1 = population[0].calcLength()
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'if length1 < record_distance:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: record_distance = length1
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: best = population[0]
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '#do crossover on population'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '➋ for i in range(POP_N):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: parentA,parentB = random.sample(population,2)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '#reproduce:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: child = parentA.crossover(parentB)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: population.append(child)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '#mutateN the best in the population'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for i in range(3,25):'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'if i < N_CITIES:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: new = best.mutateN(i)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: population.append(new)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '#mutateN random Routes in the population'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for i in range(3,25):'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'if i < N_CITIES:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: new = random.choice(population)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: new = new.mutateN(i)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: population.append(new)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-21: Writing the final draw() function*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: We use the sort() function at ➊, and then trim the end of the population list
    (the longest routes) so the list remains POP_N routes long. Then we check the
    first item in the population list to see if it’s shorter than the best route.
    If so, we make it the best, like before. Next, we randomly sample two routes from
    the population and perform a crossover on their cityNums lists and add the resulting
    child route to the population ➋. At ➌, we mutate the best route, swapping 3, 4,
    and 5 numbers, all the way up to 24 numbers (if that’s less than the number of
    cities in the sketch). Finally, we randomly choose routes from the population
    and mutate them to try to improve our distance ➍.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Now, using a population of 10,000 routes, our program can make a pretty good
    approximation of the optimal route through 100 cities. [Figure 12-12](ch12.xhtml#ch12fig12)
    shows the program improving a route from an initial length of 26,000 units to
    under 4,000 units.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f271-01.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-12: Improvements of the route through 100 cities*'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: This took “only” a half an hour to crank through!
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: SUMMARY
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we didn’t just use Python to answer the types of questions
    you get in math class whose answers are already known. Instead, we used indirect
    methods (scoring a string of characters or a route through a bunch of cities)
    to find solutions to questions without an answer key!
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we mimicked the behavior of organisms whose genes mutate, taking
    advantage of the fact that some mutations are more useful than others for solving
    the problem at hand. We knew our target phrase at the beginning of the chapter,
    but to figure out whether our final route was the optimal one, we had to save
    the city locations and run the program a few more times. This is because genetic
    algorithms, just like real organisms, can only work with what they start out with,
    and they often end up in a non-optimal rut, as you saw.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: But these indirect methods are surprisingly effective and are used extensively
    in machine learning and industrial processes. Equations are good for expressing
    a very simple relationship, but many situations are not that simple. Now you have
    plenty of useful tools, like our “sheep and grass” model, fractals, cellular automata,
    and, finally, genetic algorithms, for studying and modeling very complicated systems.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
