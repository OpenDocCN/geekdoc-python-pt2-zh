- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: SOLVING PROBLEMS USING GENETIC ALGORITHMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法解决问题
- en: '*Steve: We’re lost.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Steve: 我们迷路了。*'
- en: 'Mike: How lost are we?*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mike: 我们有多迷路？*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: When many people think of math, they think of equations and operations that
    are “set in stone” and answers that are either right or wrong. They might be surprised
    to learn how much guessing and checking we’ve done in our algebra explorations
    already.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当很多人想到数学时，他们会想到“石刻般”的方程式和运算，答案要么是对的，要么是错的。他们可能会惊讶地发现，在我们代数探索中，已经进行了很多的猜测和验证。
- en: In this chapter, you learn to crack passwords and hidden messages in an indirect
    fashion. It’s kind of like the “guess-and-check” method of [Chapter 4](ch04.xhtml#ch04),
    where we just plugged a bunch of integers into an equation and if any made the
    equation true, we printed them out. This time, we’ll guess a bunch of values,
    not just one. It’s not the most elegant way of solving a problem, but with a computer
    at our disposal, sometimes brute force works best.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以一种间接的方式破解密码和隐藏信息。这有点像[第4章](ch04.xhtml#ch04)中的“猜测和验证”方法，我们只是将一堆整数代入方程，如果其中任何一个让方程成立，我们就将其打印出来。这次，我们将猜测一堆值，而不仅仅是一个。这不是解决问题的最优雅方式，但有了计算机，有时候蛮力方法反而是最有效的。
- en: 'To figure out our secret phrase, we generate guesses and then rate them on
    how well they match the target. But here’s where we depart from a guess-and-check
    method: we keep the best guesses and mutate them, randomly, again and again until
    we uncover the message. The program won’t know which letters are right and which
    letters are wrong, but we get closer and closer by mutating the best guess we’ve
    made so far. Although this method might not seem promising right now, you’ll see
    that it helps crack the code surprisingly quickly. This method is called a *genetic
    algorithm*, which computer scientists use to find solutions to problems based
    on the theory of natural selection and evolutionary biology. It was inspired by
    biological organisms that adapt and mutate, and the way they build on tiny advantages,
    as we saw in the Sheep model in [Chapter 9](ch09.xhtml#ch09), on Classes.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出我们的秘密短语，我们生成猜测，然后根据它们与目标的匹配程度进行评分。但这就是我们与猜测和验证方法不同的地方：我们保留最好的猜测，并随机地反复变异，直到揭开谜底。程序不知道哪些字母是对的，哪些字母是错的，但通过不断变异我们目前为止做出的最佳猜测，我们会越来越接近正确答案。虽然这种方法现在看起来可能不太有希望，但你会发现它能出奇地迅速破解密码。这种方法被称为
    *遗传算法*，计算机科学家使用它基于自然选择和进化生物学理论来寻找问题的解决方案。它的灵感来自于适应和变异的生物体，以及它们如何建立微小的优势，正如我们在[第9章](ch09.xhtml#ch09)的类章节中看到的羊模型一样。
- en: For more complicated problems, however, random mutating won’t be enough to solve
    our problem. In those cases, we add *crossover*, which we use to combine the most
    fit organisms (or best guesses) to improve their likelihood of cracking the code,
    just like how the fittest organisms are more likely to pass down a combination
    of their genetic material. All this activity, other than the scoring, will be
    fairly random, so it might be surprising that our genetic algorithms work so well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更复杂的问题，随机变异不足以解决我们的难题。在这些情况下，我们加入 *交叉*，用来结合最适应的个体（或最佳猜测），以提高破解密码的可能性，就像最适应的生物更有可能将它们的遗传物质组合传递给后代一样。除了评分之外，所有这些活动都将相当随机，因此，可能会让人惊讶的是，我们的遗传算法竟然能这么有效。
- en: USING A GENETIC ALGORITHM TO GUESS PHRASES
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用遗传算法猜测短语
- en: Open IDLE and create a new file called *geneticQuote.py*. Instead of guessing
    a number like in [Chapter 4](ch04.xhtml#ch04), this program tries to guess a secret
    phrase. All we have to tell the program is the number of characters it guessed
    correctly—not where or which characters, just how many.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 IDLE，创建一个名为 *geneticQuote.py* 的新文件。与在[第4章](ch04.xhtml#ch04)中猜数字不同，这个程序试图猜测一个秘密短语。我们只需要告诉程序它猜对了多少个字符——而不是字符的位置或是哪一个字符，只需告诉它猜对了多少个字符。
- en: Our program is going to be able to do much better than guess short passwords.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将能够比猜测短密码做得更好。
- en: WRITING THE MAKELIST() FUNCTION
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 MAKELIST() 函数
- en: 'To see how this works, let’s create a target phrase. Here’s a long sentence
    that my son came up with from the comic book *Naruto*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个如何工作，让我们创建一个目标短语。这里有一句我儿子从漫画《火影忍者》中想出来的长句子：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In English, we have a bunch of characters we can choose from: lowercase letters,
    uppercase letters, a space, and some punctuation.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们可以选择一堆字符：小写字母、大写字母、空格和一些标点符号。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s create a function called `makeList()` that will randomly create a list
    of characters that’s the same length as `target`. Later, when we try to guess
    what the target phrase is, we’ll score the guess by comparing it character by
    character with the target. A higher score means a guess is closer to the target.
    Then, we’ll randomly change one of the characters in that guess to see if that
    increases its score. It seems surprising that such a random method will ever get
    us to the exact target phrase, but it will.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`makeList()`的函数，它将随机创建一个与`target`长度相同的字符列表。稍后，当我们尝试猜测目标短语时，我们将通过逐个字符地与目标进行比较来评分。较高的分数意味着猜测更接近目标。然后，我们将随机更改猜测中的一个字符，看看是否能提高其分数。看起来这种随机方法似乎不可能让我们得到确切的目标短语，但它会成功。
- en: First, import the `random` module and write the `makeList()` function, as shown
    in [Listing 12-1](ch12.xhtml#ch12list1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入`random`模块并编写`makeList()`函数，如[列表 12-1](ch12.xhtml#ch12list1)所示。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-1: Writing the `makeList()` function to create a list of random
    characters that’s the same length as the target*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-1：编写`makeList()`函数以创建一个与目标长度相同的随机字符列表*'
- en: Here, we create an empty list called `charList` and loop over the list the same
    number of times as there are characters in the target. On each loop,the program
    puts a random character from `characters` into `charList`. Once the loop is done,
    it returns `charList`. Let’s test it to make sure it works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个名为`charList`的空列表，并根据目标中的字符数量循环。每次循环时，程序将从`characters`中随机选取一个字符放入`charList`中。循环完成后，返回`charList`。让我们测试它，以确保它能正常工作。
- en: TESTING THE MAKELIST() FUNCTION
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试MAKE LIST()函数
- en: 'First, let’s find out what the length of the target is, and check that our
    random list is the same length:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找出目标的长度，并检查我们的随机列表是否具有相同的长度：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We measured the length of the `target` list, and it’s 57 characters long. Our
    new list is the same length, 57 characters. Why make a list instead of a string?
    We make a list because lists are sometimes easier to work with than strings. For
    example, you can’t simply replace a character in a string with another character.
    But in a list you can, as you can see here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测量了`target`列表的长度，它有57个字符。我们的新列表长度也为57个字符。为什么要创建一个列表而不是字符串呢？我们创建列表是因为有时列表比字符串更容易操作。例如，你不能简单地在字符串中用另一个字符替换一个字符。但在列表中，你可以做到这一点，就像你在这里看到的那样：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, when we try to replace the first item in the `"Hello"` string
    with `"J"`, Python doesn’t let us, and we get an error. Doing the same thing using
    a list, however, is no problem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们尝试用`"J"`替换`"Hello"`字符串中的第一个项时，Python不允许我们这样做，并且会报错。然而，使用列表进行相同的操作就没有问题。
- en: 'In the case of our *geneticQuote.py* program, we want to see the random quote
    as a string because that’s easier to read. Here’s how to print out a list as a
    string, using Python’s `join()` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的*geneticQuote.py*程序中，我们希望以字符串形式查看随机生成的引号，因为这样更容易阅读。以下是如何使用Python的`join()`函数将列表打印为字符串：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Those are all the characters in `newList`, but in string form. It doesn’t look
    like a very promising start!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是`newList`中的字符，但它们是字符串形式。看起来不像是一个有前景的开始！
- en: WRITING THE SCORE() FUNCTION
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写SCORE()函数
- en: Now let’s write a function called `score()` to score each guess by comparing
    it character by character with the target, like in [Listing 12-2](ch12.xhtml#ch12list2).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个名为`score()`的函数，通过将每个猜测逐个字符与目标进行比较，来为每个猜测打分，如[列表 12-2](ch12.xhtml#ch12list2)所示。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-2: Writing the `score()` function for scoring a guess*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-2：编写`score()`函数以为猜测打分*'
- en: The `score()` function takes each item in a list we feed it (`mylist`) and checks
    if the first character of `mylist` matches the first character of the `target`
    list. Then the function checks whether the second characters match, and so on.
    For each character matched, we increment `matches` by 1\. In the end, this function
    returns a single number, not which ones are right, so we don’t actually know *which*
    characters we got right!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`score()`函数接受我们传入的列表（`mylist`）中的每个项，并检查`mylist`的第一个字符是否与`target`列表的第一个字符匹配。然后，函数检查第二个字符是否匹配，以此类推。对于每个匹配的字符，我们将`matches`增加1。最终，函数返回一个单一的数字，而不是正确的字符，因此我们实际上并不知道*哪些*字符是正确的！'
- en: What’s our score?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的得分是多少？
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our first guess was a total strikeout. Not a single match!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一次猜测完全失败。一个匹配都没有！
- en: WRITING THE MUTATE() FUNCTION
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写MUTATE()函数
- en: Now we’ll write a function to mutate a list by randomly changing one character.
    This will allow our program to “make guesses” until we get closer to the target
    phrase we’re trying to guess. The code is in [Listing 12-3](ch12.xhtml#ch12list3).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个函数，通过随机更改一个字符来突变列表。这将允许我们的程序“猜测”直到接近我们尝试猜测的目标短语。代码见[Listing 12-3](ch12.xhtml#ch12list3)。
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-3: Writing the `mutate()` function for changing one character in
    a list*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-3：编写用于更改列表中一个字符的`mutate()`函数*'
- en: First, we copy the elements of the list to a variable called `newlist`. We then
    randomly choose a character from the `characters` list to be the new letter that
    will replace one of the existing characters. We randomly choose a number between
    0 and the length of the target to be the index of the letter we replace. Then
    we set the character in `newlist` at that index to be the new letter. This process
    repeats over and over again in a loop. If the new list has a higher score, it’ll
    become the “best” list, and the best list will keep getting mutated in the hope
    of improving its score even more.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将列表中的元素复制到一个名为`newlist`的变量中。然后我们从`characters`列表中随机选择一个字符，作为将替换现有字符的新字母。我们随机选择一个0到目标长度之间的数字，作为替换字母的索引。然后我们将`newlist`中该索引位置的字符设置为新字母。这个过程在循环中反复进行。如果新列表的得分更高，它将成为“最佳”列表，最佳列表会继续突变，希望进一步提高其得分。
- en: GENERATING A RANDOM NUMBER
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Starting off the program after all the function definitions, we make sure of
    our randomness by calling `random.seed()`. Calling `random.seed()` resets the
    random number generator to the present time. Then we make a list of characters
    and, since the first list is the best one so far, declare it the best list. Its
    score will be the best score.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有函数定义之后启动程序时，我们通过调用`random.seed()`来确保随机性。调用`random.seed()`会将随机数生成器重置为当前时间。然后我们创建一个字符列表，由于第一个列表是目前为止最好的列表，所以我们将其声明为最佳列表。它的得分将是最佳得分。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We keep track of how many guesses we’ve made:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪我们已经做了多少次猜测：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we start an infinite loop that will mutate `bestList` to make a new guess.
    We calculate its score and increment the `guesses` variable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始一个无限循环，将突变`bestList`以生成新的猜测。我们计算其得分，并增加`guesses`变量：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the score of the new guess is less than or equal to the best score so far,
    the program can “continue,” as shown next. That means it will go back to the beginning
    of the loop, since it wasn’t a good guess, and we don’t need to do anything else
    with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新猜测的得分小于或等于目前为止的最佳得分，程序可以“继续”，如下面所示。那意味着它会回到循环的开头，因为它不是一个好的猜测，我们不需要对其做任何其他处理。
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we’re still in the loop, that means the guess is good enough to print out.
    We print its score, too. We can print the list (as a string), the score, and how
    many total guesses were made. If the score of the new guess is the same as the
    length of the target, then we’ve solved the quote and we can break out of the
    loop:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然在循环中，那意味着猜测已经足够好，可以输出了。我们也打印出它的得分。我们可以打印出列表（作为字符串）、得分以及进行了多少次总猜测。如果新猜测的得分等于目标的长度，那么我们就解决了这个引用，可以跳出循环：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Otherwise, the new guess must be better than the best list so far, but not
    perfect yet, so we can declare it the best list and save its score as the best
    score:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，新猜测必须比目前为止的最佳列表更好，但还不完美，所以我们可以将其声明为最佳列表并保存其得分作为最佳得分：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 12-4 shows the entire code for the *geneticQuote.py* program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-4展示了*geneticQuote.py*程序的完整代码。
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-4: The complete code for the* geneticQuote.py *program*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-4：* *geneticQuote.py* *程序的完整代码*'
- en: Now when we run this, we get a very fast solution, with all the guesses that
    improved the score printed out.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行这个时，我们会得到一个非常快速的解决方案，并打印出所有改善得分的猜测。
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This output shows that the final score was 57, and it took 16,028 total guesses
    to match the quote exactly. Notice on the first line of output that 178 guesses
    were needed to get a score of 1! There are more efficient ways of guessing a quote,
    but I wanted to introduce the idea of genetic algorithms using an easy example.
    The point was to show how a method of scoring guesses and randomly mutating the
    “best guess so far” could produce accurate results in a surprisingly short amount
    of time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示最终得分为57，总共进行了16,028次猜测才能完全匹配该引用。请注意输出的第一行，达到得分1时需要进行178次猜测！有更高效的方法来猜测一个引用，但我想通过一个简单的例子介绍基因算法的概念。重点是展示如何通过评分猜测并随机突变“目前最佳猜测”来在非常短的时间内得到准确结果。
- en: Now, you can use this idea of scoring and mutating thousands of random guesses
    to solve other problems, too.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以利用这种通过打分和变异成千上万的随机猜测的思路，来解决其他问题。
- en: '### SOLVING THE TRAVELING SALESPERSON PROBLEM (TSP)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '### 求解旅行商问题 (TSP)'
- en: One of my students was unimpressed with the quote-guessing program because “we
    already know what the quote is.” So let’s use a genetic algorithm to solve a problem
    we don’t already know the solution for. *The Traveling Salesperson Problem*, or
    *TSP* for short, is an age-old brainteaser that is easy to understand but can
    become very difficult to solve. A salesperson has to travel to a given number
    of cities, and the goal is to find the route with the shortest distance. Sounds
    easy? And with a computer, we should simply be able to run all the possible routes
    through a program and measure their distances, right?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一个学生对猜测名言的程序不感兴趣，因为“我们已经知道名言是什么了。”所以让我们使用遗传算法来解决一个我们还不知道答案的问题。*旅行商问题*，简称*TSP*，是一个古老的难题，容易理解，但解决起来却非常困难。一个销售员需要访问给定的多个城市，目标是找到距离最短的路线。听起来简单吧？而且通过计算机，我们应该可以通过程序运行所有可能的路线并测量它们的距离，对吧？
- en: It turns out, above a certain number of cities, the computational complexity
    gets too much even for today’s supercomputers. Let’s see how many possible routes
    there are when you have six cities, as shown in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，当城市数量超过一定程度时，即使是今天的超级计算机，计算复杂度也变得太大了。让我们看看在有六个城市时，有多少条可能的路线，如[图12-1](ch12.xhtml#ch12fig1)所示。
- en: '![image](../images/f254-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f254-01.jpg)'
- en: '*Figure 12-1: The number of paths between* `n` *cities for* `n` *between 2
    and 6*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：在`n`城市之间的路径数量，`n`从2到6的可能路线。*'
- en: When there are two or three cities, there’s only one possible route. Add a fourth
    city, and it could be visited between any of the previous three, so multiply the
    previous number of routes by 3\. So between four cities there are three possible
    routes. Add a fifth city, and it could be visited between any of the previous
    four, so there are four times as many as the previous step, so 12 possible routes.
    See the pattern? Between *n* cities, there are
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有两三个城市时，只有一条可能的路线。加上第四个城市后，它可以在之前的三个城市之间访问，因此将前一个步骤的路线数量乘以3。所以，在四个城市之间，有三条可能的路线。再加上第五个城市，它可以在之前的四个城市之间访问，因此数量是前一步的四倍，结果是12条可能的路线。看到规律了吗？在*n*个城市之间，有
- en: '![image](../images/e254-01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e254-01.jpg)'
- en: possible routes. So between 10 cities there are 181,440 possible routes. Between
    20 cities, there are 60,822,550,204,416,000 routes. What’s after a trillion? Even
    if a computer can check a million routes per second, it would still take almost
    2,000 years to calculate. That’s too slow for our purposes. There must be a better
    way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在10个城市之间有181,440条可能的路线。在20个城市之间，有60,822,550,204,416,000条路线。超过一万亿之后呢？即使一台计算机每秒能检查一百万条路线，计算仍然需要将近2000年。这对于我们的目的来说太慢了。肯定有更好的方法。
- en: USING GENETIC ALGORITHMS
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用遗传算法
- en: Similar to our quote-guessing program, we’re going to create an object with
    a route in its “genes” and then score its route by how short it is. The best route
    will then be mutated randomly, and we’ll score its mutation. We could take a bunch
    of “best routes,” splice together their lists, and score their “offspring.” The
    best part of this exploration is we *don’t* know the answer already. We could
    give the program a set of cities and their locations, or just have it randomly
    draw cities and try to optimize the route.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们的名言猜测程序，我们将创建一个包含路线“基因”的对象，然后通过路线的短暂程度来为其打分。最佳路线随后将被随机变异，我们会对其变异进行评分。我们可以将一堆“最佳路线”拼接在一起，生成它们的“后代”，然后为后代打分。这个探索的最佳部分是我们*并不知道*答案。我们可以给程序一组城市及其位置，或者仅让它随机绘制城市并尝试优化路线。
- en: Open a new Processing sketch and call it *travelingSalesperson.pyde*. The first
    thing we should create is a `City` object. Each city will have its own x- and
    y-coordinate and a number we use to identify it. That way, we can define a route
    using a list of city numbers. For example, [5,3,0,2,4,1] means you start at city
    5 and go to city 3, then city 0, and so on. The rules are the salesperson has
    to finally return to the first city. [Listing 12-5](ch12.xhtml#ch12list5) shows
    the `City` class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Processing草图，并命名为*travelingSalesperson.pyde*。我们首先需要创建一个`City`对象。每个城市将有自己的x和y坐标以及一个用于标识它的编号。这样，我们就可以通过一个城市编号列表来定义一条路线。例如，[5,3,0,2,4,1]表示从城市5出发，前往城市3，再到城市0，依此类推。规则是销售员必须最终返回到第一个城市。[Listing
    12-5](ch12.xhtml#ch12list5)显示了`City`类。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 12-5: Writing the `City` class for the* `travelingSalesperson.pyde`
    *program*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-5：编写`City`类以供`travelingSalesperson.pyde`程序使用*'
- en: When initializing `City`, we get an x- and y-coordinate and give each `City`
    its own (`self`) x- and y-component. We also get a number that’s the city’s identifying
    number. In the `display()` method, we choose a color (sky blue, in this case)
    and create an ellipse at that location. We turn off the fill after drawing the
    city with the `noFill()` function, since no other shapes need to be filled in
    with color.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`City`时，我们获取x和y坐标，并为每个`City`对象赋予它自己的（`self`）x和y分量。我们还获取一个数字，这个数字是城市的标识号。在`display()`方法中，我们选择一个颜色（在这种情况下是天蓝色），并在该位置绘制一个椭圆。在用`noFill()`函数绘制城市后，我们关闭填充，因为其他形状不需要填充颜色。
- en: Let’s make sure that works. Let’s create the `setup()` function, declaring a
    size for the display window and creating an instance of our `City` class. Remember,
    we have to give it a location of two coordinates and an identifying number as
    in [Listing 12-6](ch12.xhtml#ch12list6).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保它能够正常工作。我们创建`setup()`函数，声明一个显示窗口的大小，并创建`City`类的一个实例。记住，我们必须为它提供两个坐标的位置和一个标识编号，如在[清单
    12-6](ch12.xhtml#ch12list6)中所示。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 12-6: Writing the `setup()` function for creating one city*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-6：编写`setup()`函数以创建一个城市*'
- en: Run this, and you’ll see your first city (see [Figure 12-2](ch12.xhtml#ch12fig2))!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个，你将看到你的第一座城市（见[图 12-2](ch12.xhtml#ch12fig2)）！
- en: '![image](../images/f256-01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f256-01.jpg)'
- en: '*Figure 12-2: The first city*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：第一座城市*'
- en: 'It might help to have the city display its number above it. To do that, add
    this to the city’s `display()` method, just before `noFill()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有助于让城市在其上方显示编号。要做到这一点，在城市的`display()`方法中，`noFill()`之前添加以下代码：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We declare the size of the text using Processing’s built-in `textSize()` function.
    Then we use the `text()` function to tell the program what to print (the number
    of the city) and where to print it (10 pixels to the left and above the city).
    While we’re creating cities, let’s start a `cities` list and put a few more cities
    on the screen in random locations. To use methods from the `random` module, we
    have to import `random` at the top of the file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Processing内置的`textSize()`函数声明文本的大小。然后，我们使用`text()`函数告诉程序要打印的内容（城市的编号）以及打印位置（离城市左侧和上方10个像素）。在创建城市时，让我们开始一个`cities`列表，并在随机位置将更多城市添加到屏幕上。为了使用`random`模块中的方法，我们需要在文件顶部导入`random`：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we can update our `setup()` function like in [Listing 12-7](ch12.xhtml#ch12list7).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像在[清单 12-7](ch12.xhtml#ch12list7)中一样更新我们的`setup()`函数。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 12-7: Writing the `setup()` function for creating six random cities*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-7：编写`setup()`函数以创建六个随机城市*'
- en: In the `setup()` function, we’ve added a loop to run six times. It adds a `City`
    object at a random location on the screen 50 units from the edges. The next loop
    iterates over all the elements in the `cities` list and displays each one. Run
    this, and you’ll see six cities in random locations, labeled with their ID numbers,
    as in [Figure 12-3](ch12.xhtml#ch12fig3).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们添加了一个循环，执行六次。它在屏幕上添加一个位置随机的`City`对象，离边缘50个单位。下一个循环遍历`cities`列表中的所有元素，并显示每一个。运行这个，你将看到六个城市在随机位置显示，每个城市都标有其ID号，如在[图
    12-3](ch12.xhtml#ch12fig3)中所示。
- en: '![image](../images/f257-01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f257-01.jpg)'
- en: '*Figure 12-3: Six cities, labeled with their numbers*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：六个城市，标有它们的编号*'
- en: 'Now let’s think about the route between the cities. We put the `City` objects
    (containing their locations and numbers) into the `cities` list, and eventually
    that list of numbers (our “genetic material”) will consist of the city numbers
    in a certain order. So the `Route` object needs a random list of numbers, too:
    a random sequence of all the city numbers. Of course, the numbers will be range
    from 0 to 1 less than the number of cities. We don’t want to keep changing numbers
    here and there in our code whenever we want to change the number of cities, so
    we’ll create a variable for the number of cities. Put this line at the beginning
    of the file, before the `City` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下城市之间的路线。我们将`City`对象（包含它们的位置和编号）放入`cities`列表中，最终，这个数字列表（我们的“遗传物质”）将由按某种顺序排列的城市编号组成。因此，`Route`对象也需要一个随机的数字列表：一个包含所有城市编号的随机顺序。当然，数字的范围将从0到城市数量减去1。我们不想在每次想要更改城市数量时就到处修改代码中的数字，因此我们将为城市数量创建一个变量。将这一行放在文件的开头，在`City`类之前：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why is `N_CITIES` in all capital letters? Throughout all the code, we won’t
    be changing the number of cities. So it’s not really a variable; instead, it’s
    a constant. It’s customary in Python to capitalize constant names to set them
    apart from variables. This doesn’t change the way Python deals with them at all;
    variables with capitalized names can still be changed. So be careful.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `N_CITIES` 要全大写？在整个代码中，我们不会改变城市的数量。因此，它实际上不是一个变量，而是一个常量。在 Python 中，常量的名称通常会大写，以便与变量区分开。这样做不会改变
    Python 对这些常量的处理方式；即使是大写名称的变量，也仍然可以被修改。所以要小心。
- en: We’ll use `N_CITIES` wherever we would be using the total number of cities,
    and we’ll only need to change the value once! Place the code shown in [Listing
    12-8](ch12.xhtml#ch12list8) after the `City` class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在需要使用城市总数的地方使用 `N_CITIES`，而且我们只需要改变一次这个值！将 [Listing 12-8](ch12.xhtml#ch12list8)
    中显示的代码放在 `City` 类之后。
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 12-8: The `Route` class*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-8: `Route` 类*'
- en: First, we set the route’s distance (or length, but `length` is a keyword in
    Processing) to zero, and then we create a `cityNums` list that puts the numbers
    of the cities in a random order for that route.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将路线的距离（或长度，但 `length` 是 Processing 中的关键字）设置为零，然后我们创建一个 `cityNums` 列表，将城市的编号按随机顺序排列，以构成这条路线。
- en: 'You can use the `random` module’s `sample()` function to give Python a list
    and then sample a number of items from that list by telling it how many items
    to choose randomly. It’s like `choice()`, but it won’t select an item more than
    once. In probability, it’s called “sampling without replacement.” Enter the following
    in IDLE to see how sampling works:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `random` 模块的 `sample()` 函数，给 Python 一个列表，然后通过告诉它要随机选择多少个项目来从该列表中取样。这就像
    `choice()` 函数，但它不会选择同一个项目超过一次。在概率论中，这种方法叫做“无放回抽样”。输入以下代码到 IDLE 中查看抽样的效果：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we create a list called `n` of the numbers between 0 and 9 by calling
    `range(10)` and converting it (it’s a “generator”) into a list. We then import
    the `random` module and ask Python to use the `sample()` function to pick a sample
    of five items from list `n` and save them to list `x`. In our `Route` code in
    [Listing 12-8](ch12.xhtml#ch12list8), since the variable `N_CITIES`, representing
    the number of cities, is 10, we’re choosing 10 numbers at random using `range(10)`,
    the numbers 0 to 9, and assigning them to the `Route`’s `cityNums` property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用 `range(10)` 并将其转换为一个列表（它是一个“生成器”）来创建一个名为 `n` 的包含 0 到 9 之间数字的列表。接着，我们导入
    `random` 模块，并让 Python 使用 `sample()` 函数从列表 `n` 中随机选择五个项目，并将它们保存到列表 `x` 中。在我们的 `Route`
    代码中，参考 [Listing 12-8](ch12.xhtml#ch12list8)，由于变量 `N_CITIES` 代表城市数量，值为 10，我们使用
    `range(10)` 随机选择了 0 到 9 之间的 10 个数字，并将它们赋值给 `Route` 的 `cityNums` 属性。
- en: And how will this display? Let’s draw purple lines between the cities. You can
    use any color you’d prefer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它将如何显示呢？让我们在城市之间绘制紫色的线条。你也可以使用任何你喜欢的颜色。
- en: Drawing lines between cities like this should remind you of drawing lines between
    the points on a graph in algebra or trigonometry lessons. The only difference
    is now at the end of the graph we have to return to the starting point. Remember
    using `beginShape`, `vertex`, and `endShape` in Chapter 6? Just like we used lines
    to draw a shape, we’ll draw the `Route` object as the outline of a shape, except
    this time we just won’t fill it in. Using `endshape(CLOSE)` will automatically
    close the loop! Add the code in [Listing 12-9](ch12.xhtml#ch12list9) to the `Route`
    class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样在城市之间画线应该会让你想起代数或三角函数课上画图形的情形。唯一的区别是，现在在图形的结尾我们必须回到起点。还记得第 6 章中使用 `beginShape`、`vertex`
    和 `endShape` 吗？就像我们用线条绘制形状一样，我们会将 `Route` 对象绘制成形状的轮廓，只不过这次我们不会填充它。使用 `endshape(CLOSE)`
    会自动关闭循环！将 [Listing 12-9](ch12.xhtml#ch12list9) 中的代码添加到 `Route` 类中。
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 12-9: Writing the `display` method of the `Route` class*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-9: 编写 `Route` 类的 `display` 方法*'
- en: The loop makes every city in the `Route`’s `cityNums` list a vertex of a polygon.
    The route is the outline of the polygon. Notice that inside the `Route`’s `display()`
    method we call the city’s `display()` method. That way, we don’t have to manually
    command the cities to display separately.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将 `Route` 的 `cityNums` 列表中的每个城市都作为多边形的一个顶点。路线就是多边形的轮廓。注意，在 `Route` 的 `display()`
    方法中，我们调用了城市的 `display()` 方法。这样，我们就不需要手动分别命令每个城市进行显示。
- en: In the `setup()` function, we’ll create a `Route` object with the `cities` list
    and a list of numbers as arguments. Then we’ll display it. The last two lines
    of code at the bottom of [Listing 12-10](ch12.xhtml#ch12list10) do this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 函数中，我们将创建一个 `Route` 对象，并传入 `cities` 列表和一个数字列表作为参数。然后我们显示它。[清单 12-10](ch12.xhtml#ch12list10)底部的最后两行代码就是实现这一点。
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 12-10: Displaying a route*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-10：显示一条路线*'
- en: Run this, and you’ll see a path between the cities, in random order, as shown
    in [Figure 12-4](ch12.xhtml#ch12fig4).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个，你会看到一个随机顺序的城市间路径，如[图 12-4](ch12.xhtml#ch12fig4)所示。
- en: '![image](../images/f259-01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f259-01.jpg)'
- en: '*Figure 12-4: A random route order*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：一个随机的路线顺序*'
- en: To change the number of cities, simply change the first line, where we declare
    `N_CITIES`, to a different number and then run the program. [Figure 12-5](ch12.xhtml#ch12fig5)
    shows my output for `N_CITIES = 7`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变城市的数量，只需将第一行中声明 `N_CITIES` 的值改为其他数字，然后运行程序。[图 12-5](ch12.xhtml#ch12fig5)显示了我对
    `N_CITIES = 7` 的输出。
- en: '![image](../images/f260-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f260-01.jpg)'
- en: '*Figure 12-5: A route with seven cities*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：包含七个城市的路线*'
- en: Now that you can create and display routes, let’s write a function to measure
    the distance of each route.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建和显示路线了，接下来我们写一个函数来测量每条路线的距离。
- en: WRITING THE CALCLENGTH() METHOD
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 `CALCLENGTH()` 方法
- en: The `Route` object has a `distance` property that’s set to zero when it’s created.
    Each `Route` object also has a list of cities, in order, called `cityNums`. We
    just have to loop through the `cityNums` list and keep a running total of the
    distances between each pair of cities. No problem for cities 0 to 4, but we also
    need to calculate the distance from the last city back to the first one.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route` 对象有一个 `distance` 属性，它在创建时被设为零。每个 `Route` 对象还有一个按顺序排列的城市列表，叫做 `cityNums`。我们只需遍历
    `cityNums` 列表，并累加每对城市之间的距离。对于城市 0 到 4 没问题，但我们还需要计算从最后一个城市返回第一个城市的距离。'
- en: '[Listing 12-11](ch12.xhtml#ch12list11) shows the code for the `calcLength()`
    method, which goes inside the `Route` object.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-11](ch12.xhtml#ch12list11)显示了 `calcLength()` 方法的代码，它位于 `Route` 对象内部。'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 12-11: Calculating a `Route`’s length*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-11：计算 `Route` 的长度*'
- en: 'First, we zero out the `distance` property of the `Route` so every time we call
    this method it’ll start at zero. We use the `enumerate()` function so we can get
    not just the number in the `cityNums` list but also its index. We then increment
    the `distance` property by the distance from the current city (`num`) to the previous
    city (`self.cityNums[i-1]`). Next, let’s add this line of code to the end of our
    `setup()` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `Route` 的 `distance` 属性设为零，这样每次调用此方法时，它都会从零开始。我们使用 `enumerate()` 函数，这样不仅能获取
    `cityNums` 列表中的城市编号，还能获取其索引。然后，我们通过当前城市（`num`）与前一个城市（`self.cityNums[i-1]`）之间的距离来增加
    `distance` 属性。接下来，让我们在 `setup()` 函数的末尾添加这一行代码：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can now see the total distance covered by the salesperson in the console,
    like in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在控制台中看到销售人员所走的总距离，像在[图 12-6](ch12.xhtml#ch12fig6)中一样。
- en: '![image](../images/f261-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f261-01.jpg)'
- en: '*Figure 12-6: We’ve calculated the distance . . . I think*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：我们已经计算出距离……我想是的*。'
- en: Is this really the distance? Let’s make sure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是距离吗？让我们确认一下。
- en: TESTING THE CALCLENGTH() METHOD
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试 `CALCLENGTH()` 方法
- en: 'Let’s give the program an easy route that’s a square of sidelength 200 and check
    the distance. First, we change our constant for the number of cities to 4:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给程序设置一个简单的路线，即一个边长为 200 的正方形，并检查距离。首先，我们将城市数量的常量改为 4：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we change the `setup()` function to what’s shown in [Listing 12-12](ch12.xhtml#ch12list12).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `setup()` 函数改为[清单 12-12](ch12.xhtml#ch12list12)所示的样子。
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 12-12: Creating a `Route` manually to test the `calcLength()` method*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-12：手动创建一个 `Route` 来测试 `calcLength()` 方法*'
- en: We comment out the loop to create cities at random, because we’ll go back to
    it after checking the `calcLength()` method. We create a new `cities` list containing
    the vertices of a square of sidelength 200\. We also declare the `cityNums` list
    for `route1`; otherwise, it would randomly mix the cities. We expect the length
    of this `Route` to be 800.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注释掉了随机创建城市的循环，因为在检查 `calcLength()` 方法之后，我们会回到这个部分。我们创建了一个新的 `cities` 列表，包含一个边长为
    200 的正方形的顶点。我们还声明了 `cityNums` 列表用于 `route1`；否则，它会随机混合城市。我们预计这个 `Route` 的长度是 800。
- en: When we run the code, we see what’s in [Figure 12-7](ch12.xhtml#ch12fig7).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，看到的内容如[图 12-7](ch12.xhtml#ch12fig7)所示。
- en: '![image](../images/f262-01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f262-01.jpg)'
- en: '*Figure 12-7: The `calcLength()` method works!*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：`calcLength()` 方法有效！*'
- en: It’s 800 units, as predicted! You can try some rectangles or some other easy-to-verify
    routes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 800 单位，正如预测的那样！你可以尝试一些矩形路线或其他容易验证的路线。
- en: RANDOM ROUTES
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机路线
- en: In order to find the shortest possible route to a destination, we need to find all
    the possible routes. To do this, we need our infinite loop and Processing’s built-in
    `draw()` function. We’ll move the route code from `setup()` to the `draw()` function.
    We’ll also create a bunch of random routes and display them and their length.
    The entire code is shown in [Listing 12-13](ch12.xhtml#ch12list13).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到到达目的地的最短路线，我们需要找出所有可能的路线。为此，我们需要使用无限循环和 Processing 内建的 `draw()` 函数。我们将把路线代码从
    `setup()` 函数移到 `draw()` 函数中。我们还会创建一堆随机路线，并显示它们及其长度。完整的代码展示在 [Listing 12-13](ch12.xhtml#ch12list13)
    中。
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 12-13: Creating and displaying random routes*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-13: 创建和显示随机路线*'
- en: When you run this, you should see a bunch of routes being displayed and a bunch
    of numbers being printed to the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，你应该会看到一堆路线被显示，并且一堆数字被打印到控制台。
- en: But we’re really only interested in keeping the best (shortest) route, so we’ll
    add some code to save the “`bestRoute`” and check the new random routes. Change
    `setup()` and `draw()` to what’s shown in [Listing 12-14](ch12.xhtml#ch12list14).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真正关心的是保留最好的（最短的）路线，因此我们将添加一些代码来保存“`bestRoute`”并检查新的随机路线。将 `setup()` 和 `draw()`
    修改为 [Listing 12-14](ch12.xhtml#ch12list14) 中所示。
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 12-14: Keeping track of random improvements*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-14: 跟踪随机改进*'
- en: Before the `setup()` function, we create a variable to count the number of random
    improvements that are made by the program. At the same time, we create a variable
    we’ll use in a few steps to count the mutated improvements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 函数之前，我们创建一个变量来计数程序所做的随机改进次数。同时，我们创建另一个变量，稍后会用它来计数突变改进的次数。
- en: In `setup()`, we created `route1` to be the first `Route`, we named it the “best
    route,” and we named its distance the `record_distance`. Since we want to share
    these variables with other functions, we declare them to be global variables at
    the beginning of the function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 中，我们创建了 `route1` 作为第一个 `Route`，我们将其命名为“最佳路线”，并将其距离命名为 `record_distance`。由于我们希望将这些变量与其他函数共享，我们在函数开始时将它们声明为全局变量。
- en: In `draw()`, we keep generating new random routes and checking if they’re better
    than the one we think is the best route so far. Since we’re using only 10 cities,
    this could pay off with an optimal solution, if we leave it running a while. You’ll
    see that it only requires around a dozen random improvements. But, remember, there
    are only 181,440 unique routes through 10 cities. One 10-city route is shown in
    [Figure 12-8](ch12.xhtml#ch12fig8).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw()` 中，我们持续生成新的随机路线，并检查它们是否比我们认为最好的路线更优。由于我们只使用 10 个城市，如果让程序运行一段时间，这可能会得到一个最优解。你会发现，它只需要大约十几个随机改进。但是，请记住，只有
    181,440 条独特的路线可以穿越 10 个城市。一个 10 城市路线如 [Figure 12-8](ch12.xhtml#ch12fig8) 所示。
- en: If you change the number of cities to 20, however, your program will just keep
    running, for days if you let it, and will probably not get close to an optimal
    solution. We need to start using the idea from the phrase-guessing program at
    the beginning of the chapter of scoring our guesses and mutating the best ones.
    Unlike before, we’ll create a “mating pool” of the best routes and combine their
    number lists as if they were genes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将城市数增加到 20，程序将不断运行，如果你允许它运行几天，可能永远也无法接近最优解。我们需要开始使用章节开头提到的短语猜测程序中的思路，给我们的猜测打分，并突变最好的猜测。与之前不同，我们将创建一个“交配池”，将最好的路线进行基因般的组合。
- en: '![image](../images/f265-01.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f265-01.jpg)'
- en: '*Figure 12-8: Finding an optimal route randomly—if you can wait a few minutes*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 12-8: 随机寻找最优路线——如果你能等几分钟的话*'
- en: APPLYING THE PHRASE-GUESSING MUTATION IDEA
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用短语猜测突变思想
- en: The list of numbers (the cities the salesperson will visit in order) will be
    the genetic material of the `Route`. First, we see how well some randomly mutated
    routes solve the Traveling Salesman Problem (just like with our phrase-guessing
    programs) and then we mutate and “mate” the better routes with each other to (hopefully)
    create a more optimal route.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表（销售员访问的城市顺序）将是 `Route` 的遗传物质。首先，我们看看一些随机突变的路线如何解决旅行商问题（就像我们在短语猜测程序中做的一样），然后我们将突变和“交配”更好的路线，以（希望）创造一个更优的路线。
- en: MUTATING TWO NUMBERS IN A LIST
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在列表中突变两个数字
- en: Let’s write a method to randomly mutate two of the numbers in a `Route` object’s
    `cityNums` list. It’s really just a swap. You can probably guess how we’ll randomly
    choose two numbers and make the city numbers that have those indices in the list
    trade places.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个方法，随机变异 `Route` 对象中 `cityNums` 列表中的两个数字。实际上，这只是一个交换操作。你应该能猜到我们将如何随机选择两个数字并让它们在列表中交换位置。
- en: Python has a unique notation for swapping the values of two numbers. You can
    swap two numbers without creating a temporary variable. For example, if you enter
    the code in [Listing 12-15](ch12.xhtml#ch12list15) in IDLE, it wouldn’t work.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一种独特的语法来交换两个数字的值。你可以在不创建临时变量的情况下交换两个数字。例如，如果你在 IDLE 中输入 [列表 12-15](ch12.xhtml#ch12list15)
    中的代码，它将无法正常工作。
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 12-15: The wrong way to swap the values of variables*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-15：交换变量值的错误方式*'
- en: When you change the value of `x` to be the same as `y` by entering `x = y`,
    they both become 3\. Now when you try to set `y` to be the same as `x`, it’s not
    set to the original value of `x` (2), but the current value of `x`, which is 3\.
    So both variables ended up as 3.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入 `x = y` 将 `x` 的值改为与 `y` 相同，它们都变成了 3。现在当你尝试将 `y` 设置为与 `x` 相同的值时，它并没有设置为
    `x` 原来的值（2），而是当前 `x` 的值，即 3。所以两个变量最终都变成了 3。
- en: 'But you *can* swap the values on the same line, like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但你*可以*在同一行交换值，像这样：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Swapping the values of two variables like this is very useful for the mutating
    we’re about to do. Instead of limiting the swapping to only two numbers, we can
    mutate more cities. We can put the swapping in a loop so the program will choose
    any number of cities and swap the first two numbers, then the next pair, and so
    on. The code for the `mutateN()` method is shown in [Listing 12-16](ch12.xhtml#ch12list16).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样交换两个变量的值对我们接下来要做的变异非常有用。我们可以将交换操作扩展到多个城市，而不仅仅局限于交换两个数字。我们可以将交换操作放入循环中，这样程序将选择任意数量的城市并交换前两个数字，然后交换下一个数字对，以此类推。`mutateN()`
    方法的代码如 [列表 12-16](ch12.xhtml#ch12list16) 所示。
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 12-16: Writing the `mutateN()` method, for mutating any number of
    cities*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-16：编写 `mutateN()` 方法，变异任意数量的城市*'
- en: We give the `mutateN()` method `num`, a number of cities to swap. Then the method
    makes a list of indices to swap by taking a random sample from the range of city
    numbers. It creates a “child” `Route` and copies its own city number list to the
    child. Then it swaps `num-1` times. If it swapped the full `num` times, the first
    city swapped would simply get swapped with all the other indices and end up where
    it started.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 `mutateN()` 方法传入 `num`，即要交换的城市数量。然后该方法通过从城市编号的范围中随机抽取样本，生成一个要交换的索引列表。它创建一个“子”
    `Route`，并将自身的城市编号列表复制给子类。然后它交换 `num-1` 次。如果交换了完整的 `num` 次，第一次交换的城市将会与所有其他索引交换，最后回到它原来的位置。
- en: That long line of code is simply the `a,b = b,a` syntax we saw before, only
    with the two `cityNums` being swapped. The mod (`%`) operator makes sure your
    indices don’t exceed `num`, the number of cities in your sample. So if you’re
    swapping four cities, for example, when `i` is `4`, it changes `i + 1` from `5`
    to `5 % 4`, which is 1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那一长行代码其实就是我们之前看到的 `a,b = b,a` 语法，只不过这里交换的是两个 `cityNums`。`%` 运算符确保索引不会超过 `num`，即样本中的城市数量。例如，如果你交换的是四个城市，当
    `i` 为 `4` 时，它会将 `i + 1` 从 `5` 改为 `5 % 4`，结果是 1。
- en: Next, we add a section to the end of the `draw()` function to mutate the best
    `Route`’s list of numbers and test the mutated `Route`’s length, as shown in [Listing
    12-17](ch12.xhtml#ch12list17).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `draw()` 函数的末尾添加一个部分，变异最优秀的 `Route` 的城市编号列表，并测试变异后的 `Route` 的长度，如 [列表
    12-17](ch12.xhtml#ch12list17) 所示。
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 12-17: Mutating the best “organism”*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-17：变异最优秀的“生物”*'
- en: In the `for i in range(2,6):` loop, we’re telling the program to mutate 2, 3, 4, and
    5 numbers in the `number` list and check the results. Now the program often does
    pretty well on a 20-city route in a few seconds, like in [Figure 12-9](ch12.xhtml#ch12fig9).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for i in range(2,6):` 循环中，我们告诉程序在 `number` 列表中变异 2、3、4 和 5 个数字，并检查结果。现在，程序通常可以在几秒钟内很好地处理
    20 城市的路线，如 [图 12-9](ch12.xhtml#ch12fig9) 所示。
- en: '![image](../images/f267-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f267-01.jpg)'
- en: '*Figure 12-9: A 20-city route*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-9：一条 20 城市的路线*'
- en: The mutated “organisms” are improving the distance much better than the random
    ones! [Figure 12-10](ch12.xhtml#ch12fig10) shows the printout.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 变异后的“生物”在改善距离方面表现得比随机的要好得多！[图 12-10](ch12.xhtml#ch12fig10) 显示了打印输出。
- en: '![image](../images/f268-01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f268-01.jpg)'
- en: '*Figure 12-10: The mutations are doing much better than the random improvements!*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-10：变异的结果比随机改进效果要好得多！*'
- en: '[Figure 12-10](ch12.xhtml#ch12fig10) categorizes all the improvements, and
    here 29 of them were due to mutations and only one was due to a randomly generated
    `Route`. This shows that mutating lists is better at finding the optimal route
    than creating new random ones. I stepped up the mutating to swap anywhere from
    2 to 10 cities by changing this line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-10](ch12.xhtml#ch12fig10)对所有改进进行了分类，其中29个改进来自变异，只有一个改进来自随机生成的`Route`。这表明，变异列表比创建新的随机路线更能找到最优路线。我通过修改这一行，增加了变异强度，将2到10个城市进行交换：'
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although this improves its performance for 20-city problems and even for some
    30-city problems, the program often gets stuck in a non-optimal rut, like in [Figure
    12-11](ch12.xhtml#ch12fig11).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在20城市问题中有所提升，甚至对于一些30城市问题也有效，但程序往往会陷入非最优的死胡同，如[图 12-11](ch12.xhtml#ch12fig11)所示。
- en: '![image](../images/f268-02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f268-02.jpg)'
- en: '*Figure 12-11: A 30-city problem stuck in a non-optimal rut*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-11：一个陷入非最优状态的30城市问题*'
- en: We’re going to take the final step and go fully genetic. Now we won’t be restricting
    ourselves to what we think is the best route so far. Instead, we’ll have an enormous
    population to choose from.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迈出最后一步，完全走向基因算法。现在，我们不再局限于我们认为最好的路线。相反，我们将拥有一个庞大的种群来选择最佳路线。
- en: We’ll make a `population` list for any number of routes we want, we’ll take
    the “fittest” ones, cross their number lists, and hopefully make an even better
    route! Just before the `setup()` function, after the `cities` list, add the `population`
    list and the constant for the number of routes, as shown in [Listing 12-18](ch12.xhtml#ch12list18).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为任意数量的路线创建一个`population`列表，挑选出最“适应”的路线，交叉它们的数字列表，并希望能生成更好的路线！在`setup()`函数之前，在`cities`列表后，添加`population`列表和路线数量常量，如[列表
    12-18](ch12.xhtml#ch12list18)所示。
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 12-18: Starting a `population` list and a variable for population
    size*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-18：初始化`population`列表和种群大小变量*'
- en: We just created an empty list to put our population of routes into, and a variable
    for the total number of routes. In the `setup()` function, we fill the `population`
    list with `POP_N` routes, as shown in [Listing 12-19](ch12.xhtml#ch12list19).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个空列表，用来存放我们的路线种群，并为总路线数创建了一个变量。在`setup()`函数中，我们将`POP_N`条路线填充进`population`列表，如[列表
    12-19](ch12.xhtml#ch12list19)所示。
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 12-19: Creating a population of routes*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-19：创建路线种群*'
- en: Notice we had to declare the `population` list to be a global variable. We put
    `POP_N` routes in the `population` list by using `for i in range(POP_N)`, and
    then we made a randomly chosen route the best one so far.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须将`population`列表声明为全局变量。我们使用`for i in range(POP_N)`将`POP_N`条路线放入`population`列表中，然后我们将一个随机选择的路线作为当前最好的路线。
- en: CROSSING OVER TO IMPROVE ROUTES
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 改进路线的交叉
- en: 'In the `draw()` function, we’re going to sort the `population` list so the
    `Route` objects with the lowest lengths are at the beginning. We’ll create a method
    called `crossover()` to splice the `cityNums` lists together at random. Here’s
    what it’ll do:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中，我们将对`population`列表进行排序，以便最短的`Route`对象排在最前面。我们将创建一个名为`crossover()`的方法，随机地将`cityNums`列表拼接在一起。它的工作方式如下：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The “parents” are lists `a` and `b`. The index is chosen randomly: index 3\.
    Then `a` list is sliced off between index 2 (`7`) and index 3 (`8`), so the child
    list starts `[6,0,7]`. The remaining numbers that aren’t in that slice are added
    to the child list in the order they occur in list `b`: `[1,4,9,2,5,8,3]`. We concatenate
    those two lists, and that’s the child list. The code for the `crossover()` method
    is shown in [Listing 12-20](ch12.xhtml#ch12list20).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: “父母”是列表`a`和`b`。索引是随机选择的：索引3。然后，`a`列表从索引2（`7`）到索引3（`8`）之间被切割，因此子列表从`[6,0,7]`开始。剩余的、不在切片中的数字按它们在`b`列表中的顺序添加到子列表中：`[1,4,9,2,5,8,3]`。我们将这两个列表连接起来，得到子列表。`crossover()`方法的代码见[列表
    12-20](ch12.xhtml#ch12list20)。
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 12-20: Writing the `crossover()` method of the `Route` class*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-20：编写`Route`类的`crossover()`方法*'
- en: The `crossover()` method requires we specify the `partner`, the other parent.
    The `child` route is created, and an index where the slicing will take place is
    chosen randomly. The child list gets the numbers in the first slice, and then
    half the time we reverse those numbers, for genetic diversity. We create a list
    of the numbers that aren’t in the slice and add each one as it occurs in the other
    parent’s (or partner’s) list. Finally, concatenate those slices and return the
    `child` route.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`crossover()`方法要求我们指定`partner`，另一个父母路线。`child`路线就此生成，并且会随机选择一个切片位置。子列表获取第一个切片中的数字，然后我们有一半的时间会反转这些数字，以增加基因多样性。我们创建一个列表，包含不在切片中的数字，并将这些数字按顺序加入另一个父母（或合作父母）的列表中。最后，连接这些切片并返回`child`路线。'
- en: In the `draw()` function, we need to check the routes in the `population` list
    for the shortest one. Do we need to check each one like before? Luckily, Python
    provides a handy `sort()` function we can use to sort the `population` list by
    `calcLength()`. So the first `Route` in the list will be the shortest one. The
    final code for the `draw()` function is shown in [Listing 12-21](ch12.xhtml#ch12list21).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中，我们需要检查`population`列表中的路线，找出最短的一条。我们还需要像之前那样检查每一条路线吗？幸运的是，Python提供了一个方便的`sort()`函数，我们可以用它按`calcLength()`对`population`列表进行排序。所以，列表中的第一个`Route`就是最短的那条。`draw()`函数的最终代码展示在[列表12-21](ch12.xhtml#ch12list21)中。
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 12-21: Writing the final `draw()` function*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-21：编写最终的`draw()`函数*'
- en: We use the `sort()` function at ➊, and then trim the end of the `population`
    list (the longest routes) so the list remains `POP_N` routes long. Then we check
    the first item in the `population` list to see if it’s shorter than the best route.
    If so, we make it the best, like before. Next, we randomly sample two routes from
    the population and perform a crossover on their `cityNums` lists and add the resulting
    `child` route to the population ➋. At ➌, we mutate the `best` route, swapping
    3, 4, and 5 numbers, all the way up to 24 numbers (if that’s less than the number
    of cities in the sketch). Finally, we randomly choose routes from the population
    and mutate them to try to improve our distance ➍.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➊使用`sort()`函数，然后修剪`population`列表的末尾（最长的路线），使得列表保持`POP_N`条路线的长度。接下来，我们检查`population`列表中的第一个项目，看它是否比最优路线更短。如果是，我们就像以前一样将其设为最佳路线。接着，我们随机从人群中选取两条路线，对它们的`cityNums`列表进行交叉操作，并将结果`child`路线添加到人群中
    ➋。在➌，我们突变`best`路线，交换3、4、5个数字，直到最多24个数字（如果这少于草图中城市的数量）。最后，我们随机从人群中选择路线，并对其进行突变，以尝试改进距离
    ☐。
- en: Now, using a population of 10,000 routes, our program can make a pretty good
    approximation of the optimal route through 100 cities. [Figure 12-12](ch12.xhtml#ch12fig12)
    shows the program improving a route from an initial length of 26,000 units to
    under 4,000 units.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用10,000条路线的人群，我们的程序可以对100个城市的最优路线做出相当好的近似。[图12-12](ch12.xhtml#ch12fig12)展示了程序如何将一条初始长度为26,000单位的路线优化到低于4,000单位。
- en: '![image](../images/f271-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f271-01.jpg)'
- en: '*Figure 12-12: Improvements of the route through 100 cities*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：通过100个城市的路线改进*'
- en: This took “only” a half an hour to crank through!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这“只”花了半个小时就完成了！
- en: SUMMARY
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we didn’t just use Python to answer the types of questions
    you get in math class whose answers are already known. Instead, we used indirect
    methods (scoring a string of characters or a route through a bunch of cities)
    to find solutions to questions without an answer key!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅仅使用Python来解答那些数学课上答案已经知道的问题。相反，我们使用间接方法（为字符串或经过多个城市的路线打分）来解决没有答案的题目！
- en: To do this, we mimicked the behavior of organisms whose genes mutate, taking
    advantage of the fact that some mutations are more useful than others for solving
    the problem at hand. We knew our target phrase at the beginning of the chapter,
    but to figure out whether our final route was the optimal one, we had to save
    the city locations and run the program a few more times. This is because genetic
    algorithms, just like real organisms, can only work with what they start out with,
    and they often end up in a non-optimal rut, as you saw.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们模仿了基因发生突变的生物体行为，利用了某些突变比其他突变在解决当前问题时更有用的事实。我们在本章开始时就知道了目标短语，但为了确定我们的最终路线是否最优，我们必须保存城市位置并多次运行程序。这是因为遗传算法，就像真实的生物体一样，只能从它们开始时的状态出发，并且常常陷入非最优的困境，正如你所看到的那样。
- en: But these indirect methods are surprisingly effective and are used extensively
    in machine learning and industrial processes. Equations are good for expressing
    a very simple relationship, but many situations are not that simple. Now you have
    plenty of useful tools, like our “sheep and grass” model, fractals, cellular automata,
    and, finally, genetic algorithms, for studying and modeling very complicated systems.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些间接方法出奇地有效，并且在机器学习和工业过程中得到广泛应用。方程式适合表达非常简单的关系，但许多情况并不像那样简单。现在你有了许多有用的工具，比如我们的“羊与草”模型、分形、元胞自动机，最后是遗传算法，用于研究和建模非常复杂的系统。
