- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: ORGANIZING VALUES USING LISTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表组织值
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: We’ve seen that we can use strings to work with a sequence of characters. In
    this chapter, we’ll learn about lists, which help us work with sequences of other
    types of values, such as integers and floats. We’ll also learn that we can nest
    lists inside of lists, which lets us work with grids of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，可以使用字符串处理字符序列。在本章中，我们将学习列表，它帮助我们处理其他类型值的序列，如整数和浮点数。我们还将学习如何将列表嵌套在列表中，这使得我们可以处理数据的网格。
- en: 'We’ll solve three problems using lists: finding the smallest neighborhood of
    a collection of villages, determining whether sufficient money has been raised
    for a school trip, and calculating the number of bonuses offered by a bakery.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过列表解决三个问题：找到一组村庄中最小的邻域，确定是否筹集到了足够的资金进行学校旅行，以及计算面包店提供的奖金数量。
- en: 'Problem #11: Village Neighborhood'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #11：村庄邻域'
- en: In this problem, we’re going to find the size of the smallest neighborhood of
    a collection of villages. We’ll find it helpful to store all of the neighborhood
    sizes. We might have as many as 100 villages, though, and using a separate variable
    for each village would be a nightmare. We’ll see that lists allow us to aggregate
    what would otherwise be separate variables into one collection. We’ll also learn
    about Python’s powerful list operations for modifying, searching, and sorting
    a list.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们要找到一组村庄中最小的邻域大小。我们会发现将所有邻域大小存储起来会很有帮助。虽然我们可能最多有 100 个村庄，但为每个村庄使用单独的变量会非常麻烦。我们会看到，列表可以将本来应该是独立变量的数据聚合成一个集合。我们还将学习
    Python 强大的列表操作，用于修改、查找和排序列表。
- en: This is DMOJ problem ccc18s1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 ccc18s1。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: There are *n* villages located at distinct points on a straight road. Each village
    is represented by an integer that indicates its position on the road.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有 *n* 个村庄位于直路上的不同位置。每个村庄由一个整数表示，指示其在道路上的位置。
- en: A village’s left neighbor is the village with the next smallest position; a
    village’s right neighbor is the village with the next biggest position. The *neighborhood*
    of a village consists of half the space between that village and its left neighbor,
    plus half the space between that village and its right neighbor. For example,
    if there’s a village at position 10, with its left neighbor at position 6 and
    its right neighbor at position 15, then this village’s neighborhood starts from
    position 8 (halfway between 6 and 10) and ends at position 12.5 (halfway between
    10 and 15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个村庄的左邻居是位置最接近且较小的村庄；右邻居是位置最接近且较大的村庄。一个村庄的*邻域*包括该村庄与其左邻居之间的空间的一半，加上该村庄与其右邻居之间的空间的一半。例如，如果一个村庄位于位置
    10，左邻居位于位置 6，右邻居位于位置 15，则该村庄的邻域从位置 8（6 和 10 之间的一半）开始，到位置 12.5（10 和 15 之间的一半）结束。
- en: The leftmost and rightmost villages have only one neighbor, so the definition
    of a neighborhood doesn’t make sense for them. We’ll ignore the neighborhoods
    of those two villages in this problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最左和最右的村庄只有一个邻居，因此它们的邻域定义没有意义。在这个问题中，我们将忽略这两个村庄的邻域。
- en: The *size* of a neighborhood is calculated as the neighborhood’s rightmost position
    minus the neighborhood’s leftmost position. For example, the neighborhood that
    goes from 8 to 12.5 has size 12.5 – 8 = 4.5.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*邻域*的*大小*是通过计算邻域的最右位置减去邻域的最左位置来得出的。例如，从 8 到 12.5 的邻域大小为 12.5 – 8 = 4.5。'
- en: Determine the size of the smallest neighborhood.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确定最小邻域的大小。
- en: Input
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing integer *n*, the number of villages. *n* is between 3 and
    100.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示村庄的数量。*n* 的范围是 3 到 100。
- en: '*n* lines, each of which gives the position of a village. Each position is
    an integer between –1,000,000,000 and 1,000,000,000\. The positions need not come
    in order from left to right; the neighbor of a village could be anywhere in these
    lines.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一个村庄的位置。每个位置是介于 -1,000,000,000 和 1,000,000,000 之间的整数。位置不必按从左到右的顺序排列；一个村庄的邻居可能位于这些行中的任何地方。'
- en: Output
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the size of the smallest neighborhood. Include exactly one digit after
    the decimal point.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出最小邻域的大小。保留一位小数。
- en: Why Lists?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用列表？
- en: As part of reading the input, we’ll need to read *n* integers (the integers
    that represent the positions of the villages). We dealt with this once already
    when solving Data Plan in [Chapter 3](ch03.xhtml#ch03). There, we used a range
    for loop to loop exactly *n* times. We’ll do that here, too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读取输入的一部分，我们需要读取 *n* 个整数（表示村庄位置的整数）。在解决[第3章](ch03.xhtml#ch03)的数据规划问题时，我们已经处理过一次。那里，我们使用了一个范围循环，循环了
    *n* 次。我们在这里也会这样做。
- en: There’s one crucial difference between Data Plan and Village Neighborhood. In
    Data Plan, we read an integer, used it, and never referred to it again. We didn’t
    need to keep it around. But in Village Neighborhood, it’s not enough to see each
    integer just once. A village’s neighborhood depends on its left and right neighbors.
    Without access to those neighbors, we can’t calculate the size of the village’s
    neighborhood. We need to store all of the village positions for later use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据规划与村庄邻域之间有一个至关重要的区别。在数据规划中，我们读取一个整数，使用它，然后不再引用它。我们不需要将它保留下来。但在村庄邻域中，光是看到每个整数一次是不够的。一个村庄的邻域依赖于它的左邻居和右邻居。如果没有这些邻居，我们无法计算该村庄邻域的大小。因此，我们需要存储所有村庄位置，以便后续使用。
- en: 'For an example of why we need to store all of the village positions, consider
    this test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明为什么我们需要存储所有村庄位置，考虑这个测试用例：
- en: '6'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '20'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '50'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: '4'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '19'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '15'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '1'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: There are six villages here. To find the size of a village’s neighborhood, we
    need that village’s left and right neighbors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有六个村庄。为了找到一个村庄的邻域大小，我们需要该村庄的左邻居和右邻居。
- en: The first village in the input is at position 20\. What’s the size of that village’s
    neighborhood? To answer that, we need access to all of the village positions so
    that we can find its left and right neighbors. Scanning through the positions,
    you can identify that the left neighbor is at position 19 and the right neighbor
    is at position 50\. The size of this village’s neighborhood is therefore (20 –
    19)/2 + (50 – 20)/2 = 15.5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第一个村庄位于位置20。这个村庄的邻域大小是多少？要回答这个问题，我们需要访问所有村庄位置，以便找到它的左邻居和右邻居。通过扫描这些位置，你可以发现左邻居在位置19，右邻居在位置50。因此，该村庄的邻域大小是
    (20 – 19)/2 + (50 – 20)/2 = 15.5。
- en: The second village in the input is at position 50\. What’s the size of that
    village’s neighborhood? Again, we need to look through the positions to figure
    it out. This village happens to be the rightmost one, so we ignore this village’s
    neighborhood.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第二个村庄位于位置50。这个村庄的邻域大小是多少？我们仍然需要查看位置来计算它。这个村庄恰好是最右边的一个，所以我们忽略这个村庄的邻域。
- en: The third village in the input is at position 4\. The left neighbor is at position
    1, and the right neighbor is at position 15, so the size of this village’s neighborhood
    is (4 – 1)/2 + (15 – 4)/2 = 7.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第三个村庄位于位置4。左邻居在位置1，右邻居在位置15，所以该村庄邻域的大小为 (4 – 1)/2 + (15 – 4)/2 = 7。
- en: The fourth village in the input is at position 19\. The left neighbor is at
    position 15, and the right neighbor is at position 20, so the size of this village’s
    neighborhood is (19 – 15)/2 + (20 – 19)/2 = 2.5.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第四个村庄位于位置19。左邻居在位置15，右邻居在位置20，所以该村庄的邻域大小是 (19 – 15)/2 + (20 – 19)/2 = 2.5。
- en: The only remaining village that we need to consider is at position 15\. If you
    calculate its neighborhood size, you should get an answer of 7.5.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的唯一剩下的村庄位于位置15。如果你计算它的邻域大小，你应该得到7.5的答案。
- en: Comparing all of the neighborhood sizes that we calculated, we see that the
    minimum—and the correct answer for this test case—is 2.5.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 比较我们计算的所有邻域大小，我们可以看到最小值——也是此测试用例的正确答案——是2.5。
- en: We need a way to store all of the village positions so that we can find the
    neighbors of each village. A string won’t help, because strings store characters,
    not integers. Python lists to the rescue!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来存储所有的村庄位置，以便找到每个村庄的邻居。字符串不适用，因为字符串存储的是字符，而不是整数。Python 列表来帮忙！
- en: Lists
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: A *list* is a Python type that stores a sequence of values. (You’ll sometimes
    see list values referred to as *elements*.) We use opening and closing square
    brackets to delimit the list.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是一种存储值序列的Python类型。（你有时会看到列表中的值被称为 *元素*。）我们使用方括号来表示列表的开始和结束。'
- en: We can store only characters in strings, but we can store any type of value
    in lists. This list of integers holds the village positions from the prior section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在字符串中存储字符，但我们可以在列表中存储任何类型的值。这个整数列表保存了前面部分的村庄位置。
- en: '>>> [20, 50, 4, 19, 15, 1]'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [20, 50, 4, 19, 15, 1]'
- en: '[20, 50, 4, 19, 15, 1]'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50, 4, 19, 15, 1]'
- en: 'Here’s a list of strings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串列表：
- en: '>>> [''one'', ''two'', ''hello'']'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [''one'', ''two'', ''hello'']'
- en: '[''one'', ''two'', ''hello'']'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[''one'', ''two'', ''hello'']'
- en: 'We can even create a list whose values are of different types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以创建一个值类型不同的列表：
- en: '>>> [''hello'', 50, 365.25]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [''hello'', 50, 365.25]'
- en: '[''hello'', 50, 365.25]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[''hello'', 50, 365.25]'
- en: 'Much of what you learned about strings applies to lists as well. For example,
    lists support the + operator for concatenation and the * operator for replication:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你学到的很多关于字符串的内容也适用于列表。例如，列表支持 + 运算符进行连接，支持 * 运算符进行复制：
- en: '>>> [1, 2, 3] + [4, 5, 6]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [1, 2, 3] + [4, 5, 6]'
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6]'
- en: '>>> [1, 2, 3] * 4'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> [1, 2, 3] * 4'
- en: '[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]'
- en: 'We even have the in operator, which tells us whether a value is in a list or
    not:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至有 `in` 运算符，它告诉我们一个值是否在列表中：
- en: '>>> ''one'' in [''one'', ''two'', ''hello'']'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''one'' in [''one'', ''two'', ''hello'']'
- en: 'True'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> ''n'' in [''one'', ''two'', ''three'']'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''n'' in [''one'', ''two'', ''three'']'
- en: 'False'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'And we have the len function to give us the length of a list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `len` 函数来获取列表的长度：
- en: '>>> len([''one'', ''two'', ''hello''])'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len([''one'', ''two'', ''hello''])'
- en: '3'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'A list is a sequence, and we can use a for loop to loop through its values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个序列，我们可以使用 for 循环遍历它的值：
- en: '>>> for value in [20, 50, 4, 19, 15, 1]:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for value in [20, 50, 4, 19, 15, 1]:'
- en: '...     print(value)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(value)'
- en: '...'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '20'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '50'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: '4'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '19'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '15'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '1'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: We can make variables refer to lists, just as we make them refer to strings,
    integers, and floats. Let’s make two variables refer to lists and then concatenate
    them to produce a new list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像让变量指向字符串、整数和浮点数一样让它们指向列表。让我们让两个变量指向列表，然后将它们连接起来生成一个新的列表。
- en: '>>> lst1 = [1, 2, 3]'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1 = [1, 2, 3]'
- en: '>>> lst2 = [4, 5, 6]'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst2 = [4, 5, 6]'
- en: '>>> lst1 + lst2'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1 + lst2'
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6]'
- en: 'While we displayed the concatenated list, we did not store it, as we can see
    by looking at the lists again:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们显示连接后的列表时，我们并没有将其存储下来，正如我们通过再次查看列表所看到的：
- en: '>>> lst1'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1'
- en: '[1, 2, 3]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: '>>> lst2'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst2'
- en: '[4, 5, 6]'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 6]'
- en: 'To make a variable refer to the concatenated list, we use assignment:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要让变量指向连接后的列表，我们使用赋值：
- en: '>>> lst3 = lst1 + lst2'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst3 = lst1 + lst2'
- en: '>>> lst3'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst3'
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6]'
- en: Names like lst, lst1, and lst2 can be used when there’s no need to be more specific
    about what a list contains.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像 lst、lst1 和 lst2 这样的名称可以在不需要明确说明列表内容时使用。
- en: 'But don’t use list itself as a variable name. It’s already a name that we can
    use to convert a sequence to a list:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要将 list 本身作为变量名。它已经是一个可以用来将序列转换为列表的名称：
- en: '>>> list(''abcde'')'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(''abcde'')'
- en: '[''a'', ''b'', ''c'', ''d'', ''e'']'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[''a'', ''b'', ''c'', ''d'', ''e'']'
- en: If you make a variable named list, you’ll lose this valuable behavior, and you’ll
    confuse readers who will expect list not to be tampered with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个名为 list 的变量，你将失去这个有价值的行为，并且会混淆读者，他们会期望 list 不被篡改。
- en: 'Finally, lists support indexing and slicing. Indexing returns a single value,
    and slicing returns a list of values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列表支持索引和切片。索引返回单个值，而切片返回一组值：
- en: '>>> lst = [50, 30, 81, 40]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [50, 30, 81, 40]'
- en: '>>> lst[1]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[1]'
- en: '30'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '>>> lst[-2]'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[-2]'
- en: '81'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '81'
- en: '>>> lst[1:3]'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[1:3]'
- en: '[30, 81]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81]'
- en: 'If we have a list of strings, we can access one of its string’s characters
    by indexing twice, first to select a string and then to select a character:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个字符串列表，我们可以通过双重索引来访问其中某个字符串的字符，首先选择一个字符串，然后选择其中的一个字符：
- en: '>>> lst = [''one'', ''two'', ''hello'']'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [''one'', ''two'', ''hello'']'
- en: '>>> lst[2]'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[2]'
- en: '''hello'''
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello'''
- en: '>>> lst[2][1]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[2][1]'
- en: '''e'''
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '''e'''
- en: '**CONCEPT CHECK**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What does the following code store in the total variable?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会把什么存储在 total 变量中？
- en: lst = [a list of numbers]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: lst = [一组数字]
- en: total = 0
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: i = 1
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while i <= len(lst):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i <= len(lst):'
- en: total = total + i
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + i
- en: i = i + 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: i = i + 1
- en: A. The sum of the list
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: A. 列表的总和
- en: B. The sum of the list, not including its first value
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: B. 列表的总和，不包括其第一个值
- en: C. The sum of the list, not including its first and last values
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C. 列表的总和，不包括其第一个和最后一个值
- en: D. This code causes an error because it accesses an invalid index of the list
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会导致错误，因为它访问了列表的无效索引
- en: E. None of the above
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: E. 以上都不是
- en: 'Answer: E. This code adds the numbers 1, 2, 3, and so on, up to the length
    of the list. It doesn’t add numbers from the list or index the list at all!'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：E. 这段代码将数字 1、2、3 等加到列表的长度上，并没有对列表进行加法或索引操作！
- en: List Mutability
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的可变性
- en: Strings are *immutable*, which means they cannot be modified. When it looks
    like we’re changing a string (for example, using string concatenation), we’re
    really creating a new string, not modifying one that already exists.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是*不可变的*，这意味着它们不能被修改。当看起来我们在改变一个字符串时（例如使用字符串拼接），我们实际上是在创建一个新字符串，而不是修改已存在的字符串。
- en: Lists, on the other hand, are *mutable*, which means they *can* be modified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，列表是*可变的*，这意味着它们*可以*被修改。
- en: 'We can observe this difference by using indexing. If we try to change a character
    of a string, we get an error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引来观察这个区别。如果我们尝试改变字符串中的某个字符，我们会得到一个错误：
- en: '>>> s = ''hello'''
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''hello'''
- en: '>>> s[0] = ''j'''
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s[0] = ''j'''
- en: 'Traceback (most recent call last):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，位于 <module>
- en: 'TypeError: ''str'' object does not support item assignment'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: ''str'' 对象不支持项赋值'
- en: The error message says that strings don’t support item assignment, which just
    means that we can’t change their characters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息显示字符串不支持项赋值，这意味着我们不能更改它们的字符。
- en: 'But because lists are mutable, we can change their values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于列表是可变的，我们可以更改它们的值：
- en: '>>> lst = [''h'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [''h'', ''e'', ''l'', ''l'', ''o'']'
- en: '>>> lst'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[''h'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[''h'', ''e'', ''l'', ''l'', ''o'']'
- en: '>>> lst[0] = ''j'''
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[0] = ''j'''
- en: '>>> lst'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[''j'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[''j'', ''e'', ''l'', ''l'', ''o'']'
- en: '>>> lst[2] = ''x'''
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[2] = ''x'''
- en: '>>> lst'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[''j'', ''e'', ''x'', ''l'', ''o'']'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[''j'', ''e'', ''x'', ''l'', ''o'']'
- en: 'Without a precise understanding of the assignment statement, mutability can
    lead to seemingly bewildering behavior. Here’s an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有对赋值语句的准确理解，可变性可能导致看似令人困惑的行为。这里有一个例子：
- en: '>>> x = [1, 2, 3, 4, 5]'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3, 4, 5]'
- en: ❶ >>> y = x
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> y = x
- en: '>>> x[0] = 99'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x[0] = 99'
- en: '>>> x'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[99, 2, 3, 4, 5]'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[99, 2, 3, 4, 5]'
- en: 'No surprises yet. But you might be surprised by this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有什么意外。但你可能会被这个惊讶：
- en: '>>> y'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y'
- en: '[99, 2, 3, 4, 5]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[99, 2, 3, 4, 5]'
- en: How did the 99 get into y like that?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 99 是怎么进入 y 的？
- en: When we assign x to y ❶, y is set to refer to the same list as x. The assignment
    statement doesn’t copy the list. There’s only one list, and it happens to have
    two names (or *aliases*) that refer to it. So if we make a change to that list,
    we see that change whether we refer to the list by x or y.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 x 赋值给 y ❶时，y 被设置为引用与 x 相同的列表。赋值语句并没有复制列表。只有一个列表，恰好有两个名称（或*别名*）指向它。因此，如果我们对该列表进行更改，无论是通过
    x 还是 y 来引用，我们都会看到这个变化。
- en: Mutability is useful because it directly models what we might want to do with
    the values in a list. If we want to change a value, we just change it. Without
    mutability, changing one value isn’t possible. We’d have to create a new list
    that was the same as the old list except for the value that we wanted to change.
    That would work, but it is a roundabout and less transparent way of changing a
    value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性很有用，因为它直接模拟了我们可能想对列表中的值做的操作。如果我们想更改某个值，我们只需要更改它。如果没有可变性，改变某个值就不可能。我们必须创建一个新的列表，这个新列表与旧列表相同，除了我们想要更改的值。这样是可行的，但它是一种曲折且不够直观的方式来更改一个值。
- en: 'If you really do want a copy of a list, not just another name for it, you can
    use slicing. Leave out both the start and end indices, which results in a copy
    of the entire list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想要一个列表的副本，而不仅仅是它的另一个名称，你可以使用切片。省略起始和结束索引，这样会得到整个列表的副本：
- en: '>>> x = [1, 2, 3, 4, 5]'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3, 4, 5]'
- en: '>>> y = x[:]'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = x[:]'
- en: '>>> x[0] = 99'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x[0] = 99'
- en: '>>> x'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '[99, 2, 3, 4, 5]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[99, 2, 3, 4, 5]'
- en: '>>> y'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y'
- en: '[1, 2, 3, 4, 5]'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5]'
- en: Observe this time that the y list didn’t change when the x list changed. They’re
    separate lists.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这次观察到，当 x 列表发生变化时，y 列表并没有变化。它们是独立的列表。
- en: '**CONCEPT CHECK**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: lst = ['abc', 'def', 'ghi']
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: lst = ['abc', 'def', 'ghi']
- en: lst[1] = 'wxyz'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: lst[1] = 'wxyz'
- en: print(len(lst))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: print(len(lst))
- en: A. 3
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: A. 3
- en: B. 9
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: B. 9
- en: C. 10
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: C. 10
- en: D. 4
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: D. 4
- en: E. This code produces an error
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: E. 这段代码会产生错误
- en: 'Answer: A. Changing a list value is allowed (because lists are mutable). But
    changing the value at index 1 to a longer string doesn’t change the fact that
    the list has three values.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 改变列表的值是允许的（因为列表是可变的）。但是将索引 1 处的值更改为一个更长的字符串并不会改变列表包含三个值这一事实。
- en: Learning About Methods
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习方法
- en: Like strings, lists have many useful methods. I’ll show you some of them in
    the next section, but first I’d like to show you how you can learn about methods
    on your own.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 和字符串一样，列表也有许多有用的方法。我将在下一节中展示其中的一些，但首先我想向你展示如何自己学习这些方法。
- en: You can use Python’s dir function to get a list of methods for a particular
    type. Just call dir with a value as the argument, and you’ll get the methods for
    the type of that value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we get when we call dir using a string value as the argument:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '>>> dir('''')'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[''__add__'', ''__class__'', ''__contains__'', ''__delattr__'','
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <more stuff with underscores>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '''capitalize'', ''casefold'', ''center'', ''count'', ''encode'','
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '''endswith'', ''expandtabs'', ''find'', ''format'','
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '''format_map'', ''index'', ''isalnum'', ''isalpha'', ''isascii'','
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '''isdecimal'', ''isdigit'', ''isidentifier'', ''islower'','
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '''isnumeric'', ''isprintable'', ''isspace'', ''istitle'','
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '''isupper'', ''join'', ''ljust'', ''lower'', ''lstrip'','
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '''maketrans'', ''partition'', ''replace'', ''rfind'', ''rindex'','
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '''rjust'', ''rpartition'', ''rsplit'', ''rstrip'', ''split'','
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '''splitlines'', ''startswith'', ''strip'', ''swapcase'', ''title'','
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '''translate'', ''upper'', ''zfill'']'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we called dir with an empty string. We could have called dir with
    any string value; the empty string is just fastest to type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the names at the top with underscores; those names are for Python’s internal
    use and not generally of interest to programmers. The rest of the names are string
    methods that you can call. In that list, you’ll find string methods that you already
    know, such as isupper and count, and many others that we haven’t come across yet.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to use a method, you can use the name of that method in a call
    to help. Here’s the help we get on the string count method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(''''.count)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Help on built-in function count:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: count(...) method of builtins.str instance
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: ❶ S.count(sub[, start[, end]]) -> int
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of non-overlapping occurrences of
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: substring sub in string S[start:end].  Optional
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: arguments start and end are interpreted as in
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: slice notation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The help tells us how to call the method ❶.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Square brackets identify optional arguments. You would use start and end if
    you wanted to count the occurrences of sub within only a slice of the string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth browsing the list of methods to check whether one is available to
    help with your current programming task. Even if you’ve used a method before,
    looking at the help can show you features that you didn’t know existed!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: To see which list methods are available, call dir([]). To learn about them,
    call help([].xxx), where xxx is the name of a list method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the help for the string center method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(''''.center)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Help on built-in function center:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: center(width, fillchar=' ', /) method of builtins.str instance
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Return a centered string of length width.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Padding is done using the specified fill character
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: (default is a space).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: What is the string produced by the following code?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '''cave''.center(8, ''x'')'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: A. 'xxcavexx'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: B. ' cave '
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: C. 'xxxxcavexxxx'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: D. ' cave '
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. We’re calling center with a width of 8 and a fillchar of ''x''.
    (Had we provided only one argument, a space would have been used for fillchar.)
    The resulting string will therefore be of length 8\. The string ''cave'' has four
    characters, so we need four more characters to get us to length 8\. Python therefore
    adds two spaces at the beginning and two spaces at the end to center the string.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 我们调用了 center 方法，宽度为 8，填充字符为 'x'。（如果我们只提供了一个参数，填充字符就会使用空格。）因此，生成的字符串长度将为
    8。字符串 'cave' 有四个字符，所以我们需要四个额外的字符才能达到长度 8。Python 因此在字符串的前后各添加了两个空格来居中字符串。
- en: List Methods
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表方法
- en: Time to make progress on Village Neighborhood. I can think of two operations
    on a list that would help us solve it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在村庄邻里问题上取得进展了。我能想到两种操作，可以帮助我们解决这个问题。
- en: 'First, adding to a list. We’ll start off with no village positions and read
    them one at a time from the input. We therefore need a way to add each of these
    positions to a growing list: first the list will have nothing, and then it will
    have one village position in it, then two, and so on.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向列表中添加内容。我们将从没有任何村庄位置的列表开始，并从输入中逐一读取它们。因此，我们需要一种方法将每个位置添加到正在增长的列表中：首先列表是空的，然后它会包含一个村庄位置，接着是两个，依此类推。
- en: 'Second, sorting a list. Once we’ve read in the village positions, we need to
    find the smallest neighborhood. This involves looking at each village position
    and the distance to its left and right neighbors. The village positions could
    come in any order, so in general it’s not easy to find the neighbors of a given
    village. Think back to the work we did in “Why Lists?” in this chapter. For each
    village, we had to scan the entire list to find its neighbors. It’d be so much
    easier if we had the villages ordered by position. Then we’d know exactly where
    the neighbors were: they’d be just to the left and just to the right of a village.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，排序列表。一旦我们读取了村庄位置，我们需要找到最小的邻里。这涉及到查看每个村庄位置及其左右邻居的距离。村庄的位置可能是无序的，因此通常很难找到某个特定村庄的邻居。回想一下我们在本章“为什么使用列表？”部分做的工作。对于每个村庄，我们必须扫描整个列表来找到它的邻居。如果我们能将村庄按位置排序，那就简单多了。那时我们就能准确知道邻居的位置：它们就在某个村庄的左边和右边。
- en: 'For example, here are our sample villages in the order that we read them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是我们按顺序读取的示例村庄：
- en: 20 50 4 19 15 1
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 20 50 4 19 15 1
- en: 'That’s a mess! On a real street, they’d come in order of position, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这可真乱七八糟！在真实的街道上，它们会按位置顺序排列，如下所示：
- en: 1 4 15 19 20 50
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 1 4 15 19 20 50
- en: 'Want the neighbors of the village at position 4? Just look immediately to the
    left and immediately to the right: 1 and 15\. The neighbors of the village at
    15? Boom, they’re right there—4 and 19\. No more searching all over the place.
    We’ll sort the list of village positions to simplify our code.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 想要找到位置为 4 的村庄的邻居吗？只需查看它的左边和右边：分别是 1 和 15。位置为 15 的村庄邻居呢？嗖，邻居就在那儿——4 和 19。不再需要到处寻找了。我们将排序村庄位置列表，以简化代码。
- en: We can add to a list using the append method and sort a list using the sort
    method. We’ll learn these two methods, and a few others that you’ll likely find
    useful as you continue working with lists, and then we’ll come back to solve Village
    Neighborhood.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 append 方法向列表添加内容，使用 sort 方法对列表进行排序。我们将学习这两种方法，以及其他一些在继续处理列表时可能会发现有用的方法，然后我们将回过头来解决村庄邻里问题。
- en: Adding to a List
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向列表添加内容
- en: 'The append method *appends* to a list, which means that it adds a value to
    the end of the values already there. Here’s append adding three village positions
    to an initially empty list:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: append 方法会*附加*一个值到列表中，这意味着它会将一个值添加到已存在的值的末尾。下面是将三个村庄位置添加到一个最初为空的列表中的例子：
- en: '>>> positions = []'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = []'
- en: '>>> positions.append(20)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.append(20)'
- en: '>>> positions'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20]'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[20]'
- en: '>>> positions.append(50)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.append(50)'
- en: '>>> positions'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20, 50]'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50]'
- en: '>>> positions.append(4)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.append(4)'
- en: '>>> positions'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20, 50, 4]'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50, 4]'
- en: Notice that we’re using append without using an assignment statement. The append
    method doesn’t return a list; it modifies an existing list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在使用 append 方法时没有使用赋值语句。append 方法不会返回一个新的列表；它会修改现有的列表。
- en: 'It’s a common error to use an assignment statement with a method that changes
    a list. Making this error results in the list being lost, like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用会更改列表的函数时，使用赋值语句是一个常见的错误。犯这个错误会导致列表丢失，如下所示：
- en: '>>> positions'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20, 50, 4]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50, 4]'
- en: '>>> positions = positions.append(19)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = positions.append(19)'
- en: '>>> positions'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: 'Nothing is there! Technically, positions now refers to a None value; you can
    see that using print:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 没有值！从技术上讲，`positions` 现在指向一个 `None` 值；你可以通过 `print` 来查看：
- en: '>>> print(positions)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(positions)'
- en: None
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: None
- en: The None value is used to convey that no information is available. That’s absolutely
    not expected here—we wanted our four village positions!—but we’ve lost the list
    through an errant assignment statement.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 值用于表示没有可用信息。在这里完全没有预期——我们希望得到四个村庄的位置！——但是我们通过一个错误的赋值语句丢失了列表。'
- en: If your list is disappearing or you’re getting error messages related to the
    None value, make sure you’re not using an assignment statement with a method that
    simply modifies a list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的列表消失了，或者遇到与 `None` 值相关的错误信息，请确保你没有在方法中使用赋值语句，这些方法只是修改列表内容。
- en: 'The extend method is related to append. You use extend whenever you’d like
    to concatenate a list (not a single value) to the end of an existing list. Here’s
    an example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法与 `append` 相关。每当你想把一个列表（而不是单个值）连接到现有列表的末尾时，就使用 `extend`。以下是一个示例：'
- en: '>>> lst1 = [1, 2, 3]'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1 = [1, 2, 3]'
- en: '>>> lst2 = [4, 5, 6]'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst2 = [4, 5, 6]'
- en: '>>> lst1.extend(lst2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1.extend(lst2)'
- en: '>>> lst1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1'
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6]'
- en: '>>> lst2'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst2'
- en: '[4, 5, 6]'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 6]'
- en: 'If you want to insert into a list at a position other than its end, you can
    use the insert method. It takes an index and a value and inserts the value at
    the index:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在列表的某个位置插入元素，可以使用 `insert` 方法。它接受一个索引和一个值，并将该值插入到指定的索引位置：
- en: '>>> lst = [10, 20, 30, 40]'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [10, 20, 30, 40]'
- en: '>>> lst.insert(1, 99)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.insert(1, 99)'
- en: '>>> lst'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[10, 99, 20, 30, 40]'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 99, 20, 30, 40]'
- en: Sorting a List
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序列表
- en: 'The sort method *sorts* a list, putting its values in order. If we call it
    with no arguments, it sorts from smallest to largest:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 方法*排序*列表，将其中的值按顺序排列。如果我们不传递任何参数，它会从最小值到最大值排序：'
- en: '>>> positions = [20, 50, 4, 19, 15, 1]'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = [20, 50, 4, 19, 15, 1]'
- en: '>>> positions.sort()'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.sort()'
- en: '>>> positions'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[1, 4, 15, 19, 20, 50]'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 4, 15, 19, 20, 50]'
- en: 'If we call it with a reverse argument of value True, it sorts from largest
    to smallest:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `reverse=True` 参数来调用它，它会从最大值排序到最小值：
- en: '>>> positions.sort(reverse=True)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.sort(reverse=True)'
- en: '>>> positions'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[50, 20, 19, 15, 4, 1]'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[50, 20, 19, 15, 4, 1]'
- en: 'The syntax that I’ve used, reverse=True, is new. Based on how we’ve called
    methods and functions to this point in the book, you might expect that True by
    itself would work. But no: sort requires the whole reverse=True to be there, for
    reasons I’ll explain in [Chapter 6](ch06.xhtml#ch06).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的语法 `reverse=True` 是新的。根据我们目前在书中的方法和函数调用方式，你可能会期望 `True` 自己工作。但不是这样：`sort`
    需要完整的 `reverse=True` 参数，原因我会在[第 6 章](ch06.xhtml#ch06)中解释。
- en: Removing Values from a List
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从列表中移除值
- en: The pop method removes a value by index. If no argument is provided, pop both
    removes and returns the rightmost value.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 方法通过索引移除值。如果没有提供参数，`pop` 会移除并返回最右侧的值。'
- en: '>>> lst = [50, 30, 81, 40]'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [50, 30, 81, 40]'
- en: '>>> lst.pop()'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.pop()'
- en: '40'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: 'We can pass the index of the value to remove as an argument to pop. Here, we
    remove and return the value at index 0:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将要移除值的索引作为参数传递给 `pop` 方法。这里，我们移除并返回索引为 0 的值：
- en: '>>> lst.pop(0)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.pop(0)'
- en: '50'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: 'Since pop returns something—unlike methods like append and sort—it makes sense
    to assign its return value to a variable:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pop` 会返回某个值——不同于像 `append` 和 `sort` 这样的函数——因此将其返回值赋给变量是有意义的：
- en: '>>> lst'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30, 81]'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81]'
- en: '>>> value = lst.pop()'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value = lst.pop()'
- en: '>>> value'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value'
- en: '81'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '81'
- en: '>>> lst'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30]'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[30]'
- en: 'The remove method removes by value, not index. Pass it the value to remove,
    and it removes the leftmost occurrence of that value from the list. If the value
    is not present, remove produces an error. In the following, there are two occurrences
    of 50 in the list, so remove(50) works twice before producing an error:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法通过值来移除，而不是通过索引。传递给它要移除的值，它会移除列表中最左侧出现的该值。如果该值不存在，`remove` 会产生错误。在以下示例中，列表中有两个
    50，因此 `remove(50)` 会执行两次，直到产生错误：'
- en: '>>> lst = [50, 30, 81, 40, 50]'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [50, 30, 81, 40, 50]'
- en: '>>> lst.remove(50)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.remove(50)'
- en: '>>> lst'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30, 81, 40, 50]'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81, 40, 50]'
- en: '>>> lst.remove(50)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.remove(50)'
- en: '>>> lst'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30, 81, 40]'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81, 40]'
- en: '>>> lst.remove(50)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.remove(50)'
- en: 'Traceback (most recent call last):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'ValueError: list.remove(x): x not in list'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: list.remove(x): x not in list'
- en: '**CONCEPT CHECK**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of lst after the following code runs?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行后，`lst` 的值是什么？
- en: lst = [2, 4, 6, 8]
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: lst = [2, 4, 6, 8]
- en: lst.remove(4)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: lst.remove(4)
- en: lst.pop(2)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: lst.pop(2)
- en: A. [2, 4]
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: A. [2, 4]
- en: B. [6, 8]
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: B. [6, 8]
- en: C. [2, 6]
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: C. [2, 6]
- en: D. [2, 8]
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: D. [2, 8]
- en: E. This code produces an error
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: E. 这段代码产生错误
- en: 'Answer: C. The remove call removes the value 4, leaving [2, 6, 8]. Now the
    pop call removes the value at index 2, which is value 8. That leaves a final list
    of [2, 6].'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C. remove调用移除了值4，剩下[2, 6, 8]。然后pop调用移除了索引2处的值8。最终剩下的列表是[2, 6]。
- en: Solving the Problem
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: 'Suppose that we’ve successfully read and sorted the village positions. Here’s
    what our list would look like at that point:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功读取并排序了村庄位置。此时，我们的列表应如下所示：
- en: '>>> positions = [1, 4, 15, 19, 20, 50]'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = [1, 4, 15, 19, 20, 50]'
- en: '>>> positions'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[1, 4, 15, 19, 20, 50]'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 4, 15, 19, 20, 50]'
- en: 'To find the size of the smallest neighborhood, we start by finding the size
    of the neighborhood for the village at index 1. (Notice that we don’t start at
    index 0: the village at index 0 is the leftmost one, and per the problem description,
    we can ignore it.) We can find that neighborhood size like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最小邻里的大小，我们首先找到索引1处村庄的邻里大小。（注意我们没有从索引0开始：索引0处的村庄是最左边的村庄，根据题目描述，我们可以忽略它。）我们可以这样找到该邻里大小：
- en: '>>> left = (positions[1] - positions[0]) / 2'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> left = (positions[1] - positions[0]) / 2'
- en: '>>> right = (positions[2] - positions[1]) / 2'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> right = (positions[2] - positions[1]) / 2'
- en: '>>> min_size = left + right'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> min_size = left + right'
- en: '>>> min_size'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> min_size'
- en: '7.0'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '7.0'
- en: The left variable stores the size of the left part of the neighborhood, and
    right stores the size of the right part. We then add them up to obtain the total
    size of the neighborhood. We get a value of 7.0.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: left变量存储了邻里左侧部分的大小，right存储了右侧部分的大小。然后我们将它们加在一起，得到邻里的总大小。我们得到的值是7.0。
- en: That’s the value to beat. How do we know whether any other village has a smaller
    neighborhood? We can use a loop to process those other villages. If we find a
    neighborhood that’s smaller than our current smallest, we update our current smallest
    to that smaller size.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们需要超越的目标。我们如何知道是否有其他村庄的邻里更小呢？我们可以使用循环来处理其他村庄。如果我们找到一个比当前最小邻里还小的邻里，就更新当前最小值为那个更小的值。
- en: The code for our solution is in [Listing 5-1](ch05.xhtml#ch05ex01).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案的代码位于[列表 5-1](ch05.xhtml#ch05ex01)。
- en: n = int(input())
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: ❶ positions = []
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ positions = []
- en: '❷ for i in range(n):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for i in range(n):'
- en: ❸ positions.append(int(input()))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ positions.append(int(input()))
- en: ❹ positions.sort()
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ positions.sort()
- en: ❺ left = (positions[1] - positions[0]) / 2
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ left = (positions[1] - positions[0]) / 2
- en: right = (positions[2] - positions[1]) / 2
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: right = (positions[2] - positions[1]) / 2
- en: min_size = left + right
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = left + right
- en: '❻ for i in range(2, n - 1):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '❻ for i in range(2, n - 1):'
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: left = (positions[i] - positions[i - 1]) / 2
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: right = (positions[i + 1] - positions[i]) / 2
- en: size = left + right
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: size = left + right
- en: '❼ if size < min_size:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '❼ if size < min_size:'
- en: min_size = size
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = size
- en: print(min_size)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: print(min_size)
- en: '*Listing 5-1: Solving Village Neighborhood*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：解决村庄邻里问题*'
- en: We begin by reading n, the number of villages, from the input. We also set positions
    to refer to an empty list ❶.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过输入读取n，表示村庄的数量。我们还将positions设置为指向一个空列表 ❶。
- en: 'Each iteration of the first range for loop ❷ is responsible for reading one
    village position and appending it to the positions list. It does that by using
    input to read the next village position, int to convert it to an integer, and
    the list method append to append that integer to the list ❸. That one line ❸ is
    equivalent to these three separate lines:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第一轮range循环的每次迭代 ❷ 都负责读取一个村庄位置，并将其附加到positions列表中。它通过使用input读取下一个村庄位置，使用int将其转换为整数，并使用list方法append将该整数附加到列表
    ❸。这一行 ❸ 等价于下面三行：
- en: position = input()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: position = input()
- en: position = int(position)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: position = int(position)
- en: positions.append(position)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(position)
- en: Having read the village positions, we next sort them in increasing order ❹.
    We then find the size of the neighborhood of the village at index 1, storing it
    using min_size ❺.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取了村庄位置后，我们接下来按升序对其进行排序 ❹。然后，我们找到索引1处村庄的邻里大小，并使用min_size ❺保存它。
- en: Next, in a second loop, we loop through each of the other villages whose neighborhood
    sizes we need to compute ❻. Those villages start at index 2 and end at index n
    - 2. (We don’t want to consider the village at index n - 1, because that’s the
    rightmost village.) We therefore use range with a first argument of 2 (thus starting
    at 2) and a second argument of n - 1 (thus ending at n - 2).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第二个循环中，我们遍历每个其他需要计算邻里大小的村庄 ❻。这些村庄从索引2开始，到索引n - 2结束。（我们不考虑索引n - 1处的村庄，因为那是最右边的村庄。）因此，我们使用range，第一参数为2（即从2开始），第二参数为n
    - 1（即到n - 2结束）。
- en: Inside the loop, we calculate the size of the current village’s neighborhood,
    exactly as we did for the first village. The size of the smallest neighborhood
    that we’ve found so far is referred to by min_size. Is the current village’s neighborhood
    smaller than our smallest so far? To answer that, we use an if statement ❼. If
    this village’s neighborhood is smaller than min_size, we update min_size to the
    size of this neighborhood. If this village’s neighborhood isn’t smaller than min_size,
    then we do nothing, because this village doesn’t change the size of the smallest
    neighborhood.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们计算当前村庄邻域的大小，正如我们为第一个村庄所做的那样。我们迄今为止找到的最小邻域大小被 min_size 所表示。当前村庄的邻域是否比我们目前找到的最小邻域更小？为了回答这个问题，我们使用一个
    if 语句 ❼。如果当前村庄的邻域小于 min_size，我们就将 min_size 更新为该邻域的大小。如果当前村庄的邻域不小于 min_size，那么我们什么也不做，因为这个村庄不会改变最小邻域的大小。
- en: Having gone through all of the villages, min_size must be the size of the smallest
    neighborhood. We therefore output the value of min_size.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有村庄的遍历后，min_size 必须是最小的邻域大小。因此，我们输出 min_size 的值。
- en: The “Output” section of this problem description specified “Include exactly
    one digit after the decimal point.” What if the smallest size was something like
    6.25 or 8.33333? Shouldn’t we do something about that?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题描述中的“输出”部分规定了“输出时小数点后恰好保留一位”。如果最小的大小是 6.25 或 8.33333 之类的数字呢？我们是不是应该对这个情况做点什么？
- en: 'No. We’re safe with what we’ve done. The only neighborhood sizes we can get
    are numbers like 3.0 (with a 0 after the decimal point) and 3.5 (with a .5 after
    the decimal point). Here’s why. When we calculate the left part of a neighborhood,
    we subtract two integers and divide that resulting integer by 2\. If we have an
    even integer before dividing by 2, then dividing gives us a .0 number (no remainder).
    And if we have an odd integer before dividing by 2, then dividing gives us a .5
    number. The same goes for the right part of the neighborhood: the size will be
    a .0 number or a .5 number. Adding the left and right parts to get the total size
    is therefore guaranteed to give us another .0 or .5 number.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们的操作是安全的。我们能得到的邻域大小只有像 3.0（小数点后有 0）和 3.5（小数点后有 .5）这样的数字。原因如下。当我们计算邻域的左边部分时，我们会减去两个整数并将结果除以
    2。如果我们在除以 2 之前有一个偶数整数，那么除法结果会是一个 .0 的数字（没有余数）。如果我们在除以 2 之前有一个奇数整数，那么除法结果会是一个 .5
    的数字。邻域的右边部分也一样：大小会是 .0 或 .5 的数字。因此，将左边和右边的部分相加得到总大小，最终结果必定是 .0 或 .5 的数字。
- en: 'Avoiding Code Duplication: Two More Solutions'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免代码重复：另外两种解决方案
- en: It’s a little disappointing that we’re including the “compute neighborhood size”
    code both prior to and in the second range for loop. In general, repeated code
    is a sign that we might be able to improve the code’s design. We’d like to avoid
    repeated code because it adds to the amount of code that we must maintain, and
    it makes it harder to fix problems in the code if it turns out that the repeated
    code is flawed. Here, the repeated code seems acceptable to me (it’s only three
    lines), but let’s talk about two ways to avoid it. These are general approaches
    that you’ll be able to apply to other similar problems.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有点令人失望的是，我们在循环之前和第二个范围的 for 循环中都包含了“计算邻域大小”的代码。通常，重复的代码意味着我们可以改善代码的设计。我们希望避免重复代码，因为它增加了我们必须维护的代码量，并且如果重复的代码有问题，修复起来会更加困难。在这里，我认为重复的代码是可以接受的（只有三行），但我们来讨论两种避免重复代码的方法。这些是通用方法，你可以将它们应用到其他类似的问题中。
- en: Using a Huge Size
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用超大尺寸
- en: The only reason we’re calculating the size of a village’s neighborhood before
    the loop is so that the loop has something to compare the other neighborhood sizes
    against. If we entered the loop without a value for min_size, we’d get an error
    when the code tries to compare it to the size of the current village.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环之前计算村庄邻域的大小，唯一的原因是为了让循环可以将其他邻域大小与其进行比较。如果我们在没有 min_size 值的情况下进入循环，那么当代码尝试将其与当前村庄的大小进行比较时，就会报错。
- en: If we set min_size to 0.0 before the loop, then the loop will never find a smaller
    size, and we’ll incorrectly output 0.0 no matter the test case. Using 0.0 would
    be a bug!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在循环之前将 min_size 设置为 0.0，那么循环将永远找不到更小的大小，无论测试用例如何，我们都会错误地输出 0.0。使用 0.0 会是一个
    bug！
- en: But a huge value, one at least as big as every possible neighborhood size, *will*
    work. We just need to make it so huge that the first iteration of the loop is
    guaranteed to find a size that’s no bigger, ensuring that our fake huge size never
    gets output.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一个巨大的值，至少和每个可能的邻里大小一样大，*会*起作用。我们只需要让它足够大，以确保循环的第一次迭代能找到一个不更大的大小，从而保证我们的伪巨大值永远不会被输出。
- en: From the “Input” section of this problem description, we know that each position
    is between –1,000,000,000 and 1,000,000,000\. The biggest neighborhood we could
    ever have, then, occurs when we have a village at position –1,000,000,000, another
    at position 1,000,000,000, and a village somewhere in between. That in-between
    village will have a neighborhood size of 1,000,000,000\. We can therefore start
    min_size with a size of 1000000000.0 or greater. This alternate approach is in
    [Listing 5-2](ch05.xhtml#ch05ex02).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个问题描述中的“输入”部分，我们知道每个位置的值介于–1,000,000,000 和 1,000,000,000之间。我们能遇到的最大邻里大小发生在村庄位置为–1,000,000,000，另一个在1,000,000,000，且有一个村庄在它们之间。位于中间的村庄将有一个邻里大小为1,000,000,000。我们因此可以从1000000000.0或更大的值开始设定min_size。这个替代方法见[列表
    5-2](ch05.xhtml#ch05ex02)。
- en: n = int(input())
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: positions = []
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: 'for i in range(n):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: positions.append(int(input()))
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(int(input()))
- en: positions.sort()
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: positions.sort()
- en: min_size = 1000000000.0
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = 1000000000.0
- en: '❶ for i in range(1, n - 1):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for i in range(1, n - 1):'
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: left = (positions[i] - positions[i - 1]) / 2
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: right = (positions[i + 1] - positions[i]) / 2
- en: size = left + right
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: size = left + right
- en: 'if size < min_size:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'if size < min_size:'
- en: min_size = size
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = size
- en: print(min_size)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: print(min_size)
- en: '*Listing 5-2: Solving Village Neighborhood with a huge value*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：使用一个巨大值解决村庄邻里问题*'
- en: Careful! We need to start computing sizes at index 1 now ❶ (not 2); otherwise,
    we’d forget to include the neighborhood of the village at index 1.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！我们现在需要从索引1开始计算大小❶（而不是2）；否则我们会忘记包括索引1处村庄的邻里。
- en: Building a List of Sizes
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建大小列表
- en: 'Another way to avoid the code duplication is to store each neighborhood size
    in a list of sizes. Python has a built-in min function that takes a sequence and
    returns its minimum:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免代码重复的方法是将每个邻里大小存储在一个大小列表中。Python有一个内建的min函数，它接受一个序列并返回其最小值：
- en: '>>> min(''qwerty'')'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> min(''qwerty'')'
- en: '''e'''
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '''e'''
- en: '>>> min([15.5, 7.0, 2.5, 7.5])'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> min([15.5, 7.0, 2.5, 7.5])'
- en: '2.5'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '2.5'
- en: (Python also has a max function that returns the maximum of a sequence.)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: （Python还有一个max函数，返回一个序列的最大值。）
- en: See [Listing 5-3](ch05.xhtml#ch05ex03) for a solution that uses min on a list
    of neighborhood sizes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[列表 5-3](ch05.xhtml#ch05ex03)，该解决方案使用min对邻里大小列表进行处理。
- en: n = int(input())
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: positions = []
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: 'for i in range(n):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: positions.append(int(input()))
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(int(input()))
- en: positions.sort()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: positions.sort()
- en: sizes = []
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: sizes = []
- en: 'for i in range(1, n - 1):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, n - 1):'
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: left = (positions[i] - positions[i - 1]) / 2
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: right = (positions[i + 1] - positions[i]) / 2
- en: size = left + right
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: size = left + right
- en: sizes.append(size)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: sizes.append(size)
- en: min_size = min(sizes)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = min(sizes)
- en: print(min_size)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: print(min_size)
- en: '*Listing 5-3: Solving Village Neighborhood using* min'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：使用* min 解决村庄邻里问题'
- en: Feel free to submit any of these solutions to the judge, whichever you like
    best!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 随时将这些解决方案提交给评测系统，选择你最喜欢的一种！
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 134](ch05.xhtml#ch05lev1sec18).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决“章节练习”中的第1题，见[第134页](ch05.xhtml#ch05lev1sec18)。
- en: 'Problem #12: School Trip'
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #12：学校旅行'
- en: Many problems you’ll encounter have input with multiple integers or floats per
    line. We’ve avoided these problems until now, but they are everywhere! We’ll now
    learn how we can use lists to process the input for these kinds of problems.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遇到的许多问题都包含每行有多个整数或浮点数的输入。我们到现在为止已经避免了这些问题，但它们无处不在！接下来我们将学习如何使用列表来处理这些类型的问题输入。
- en: This is DMOJ problem ecoo17r1p1.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题eco17r1p1。
- en: The Challenge
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Students would like to go on a school trip at the end of the year, but they
    need money to pay for it. To raise money, they have organized a brunch. To attend
    the brunch, a student in their first year pays $12, a student in their second
    year pays $10, a student in their third year pays $7, and a student in their fourth
    year pays $5.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们希望在年末去学校旅行，但他们需要钱来支付费用。为了筹集资金，他们组织了一次早午餐活动。参加早午餐的费用为：大一学生12美元，大二学生10美元，大三学生7美元，大四学生5美元。
- en: Of all of the money raised at the brunch, 50 percent of it can be used to pay
    for the school trip (the other 50 percent is used to pay for the brunch itself).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '所有在早午餐中筹集的资金中，50%可以用于支付学校旅行费用（另50%用于支付早午餐本身）。  '
- en: We are told the cost of the school trip, the proportion of students in each
    year, and the total number of students. Determine whether the students need to
    raise more money for the school trip.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '我们知道学校旅行的费用、每年级学生的比例以及学生的总人数。请判断学生们是否需要筹集更多的钱来支付学校旅行的费用。  '
- en: Input
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '输入  '
- en: 'The input consists of 10 test cases, with three lines per test case (30 lines
    in all). Here are the three lines for each test case:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '输入包含10个测试案例，每个测试案例有三行（共30行）。每个测试案例的三行如下：  '
- en: The first line contains the cost in dollars of the school trip; it’s an integer
    between 50 and 50,000.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一行包含学校旅行的费用（以美元为单位）；它是一个介于50和50,000之间的整数。  '
- en: The second line contains four numbers indicating the proportion of brunching
    students who are in first, second, third, and fourth year, respectively. There
    is a space between each pair of numbers. Each number is between 0 and 1, and their
    sum is 1 (for 100 percent).
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第二行包含四个数字，表示参加早午餐的学生分别在第一年、第二年、第三年和第四年中的比例。每对数字之间有一个空格。每个数字在0和1之间，它们的总和为1（即100%）。  '
- en: The third line contains integer *n*, the number of students attending the brunch.
    *n* is between 4 and 2,000.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第三行包含一个整数*n*，表示参加早午餐的学生人数。*n*的范围是4到2000之间。  '
- en: Output
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '输出  '
- en: 'For each test case: if the students need to raise more money for the school
    trip, output YES; otherwise, output NO.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '对于每个测试案例：如果学生需要为学校旅行筹集更多的钱，输出YES；否则，输出NO。  '
- en: A Catch
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '一个特殊情况  '
- en: Suppose that there are 50 students and that 10 percent of them (a proportion
    of 0.1) are in their fourth year. Then we can calculate that 50 * 0.1 = 5 students
    are in their fourth year.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有50名学生，其中10%（即比例为0.1）的学生是四年级的。那么我们可以计算出50 * 0.1 = 5名四年级学生。
- en: Now suppose that there are 50 students, but that 15 percent of them (a proportion
    of 0.15) are in their fourth year. If we multiply, we get 50 * 0.15 = 7.5 students
    in their fourth year.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '现在假设有50名学生，其中15%（即比例为0.15）的学生是四年级的。如果我们相乘，就得到50 * 0.15 = 7.5名四年级学生。  '
- en: Having 7.5 students doesn’t make any sense, and I haven’t told you what we should
    do in such a case. The full problem description specifies that we are to round
    down—so we’d round down to 7 here. This could result in the sum of the students
    in first year, second year, third year, and fourth year not equaling the total
    number of students. For the students who are not accounted for, we are to add
    them to the year with the most students. It’s guaranteed that exactly one year
    will have the most students (there won’t be a tie between multiple years).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '7.5名学生是没有意义的，我也没有告诉你我们应该如何处理这种情况。完整的问题描述中规定我们需要向下取整——所以我们在这里会向下取整为7。这可能导致第一年、第二年、第三年和第四年学生的总和不等于学生总数。对于未被计算在内的学生，我们需要将他们分配到人数最多的年级。保证有且只有一个年级会有最多的学生（不会出现多个年级平分秋色的情况）。  '
- en: We’ll first solve the problem ignoring this catch. Then we’ll incorporate the
    catch to give us a full solution.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将首先忽略这个特殊情况来解决问题。然后，我们将考虑这个特殊情况，给出完整的解决方案。  '
- en: Splitting Strings and Joining Lists
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '字符串分割和列表连接  '
- en: 'The second line of each test case consists of four proportions, like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '每个测试案例的第二行包含四个比例，如下所示：  '
- en: 0.2 0.08 0.4 0.32
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '0.2 0.08 0.4 0.32  '
- en: We need a way to extract those four numbers from a string for further processing.
    We’ll learn about the string split method for splitting a string into a list of
    its pieces. While we’re at it, we’ll also learn about the string join method,
    which lets us go the other way and collapse a list into a single string.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要一种方法来提取这四个数字以便进一步处理。我们将学习字符串的split方法，用于将字符串分割成多个部分。顺便提一下，我们还将学习字符串的join方法，它允许我们将一个列表合并成一个单一的字符串。  '
- en: Splitting a String into a List
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '将字符串分割成列表  '
- en: Remember that the input function returns a string, no matter what the input
    looks like. If the input should be interpreted as an integer, we need to convert
    the string to an integer. If the input should be interpreted as a float, we need
    to convert the string to a float. And if the input should be interpreted as four
    floats? Well, then we had better split it up into individual floats before converting
    anything!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，无论输入的样子如何，input 函数始终返回一个字符串。如果输入应该解释为整数，我们需要将字符串转换为整数。如果输入应该解释为浮点数，我们需要将字符串转换为浮点数。如果输入应该被解释为四个浮点数？那么我们最好先将其分割成单独的浮点数，然后再进行转换！
- en: 'The string split method splits a string into a list of its pieces. By default,
    split splits around spaces, which is exactly what we need for our four floats:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的 split 方法将字符串分割成它的各个部分的列表。默认情况下，split 会在空格处进行分割，这正是我们需要的四个浮点数：
- en: '>>> s = ''0.2 0.08 0.4 0.32'''
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''0.2 0.08 0.4 0.32'''
- en: '>>> s.split()'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.split()'
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
- en: 'The split method returns a list of strings, at which point we can access each
    one independently. Here, I save the list that split returns and then access two
    of its values:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: split 方法返回一个字符串列表，此时我们可以独立访问每一个字符串。这里，我保存了 split 返回的列表，然后访问其中的两个值：
- en: '>>> proportions = s.split()'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions = s.split()'
- en: '>>> proportions'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions'
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
- en: '>>> proportions[1]'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions[1]'
- en: '''0.08'''
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '''0.08'''
- en: '>>> proportions[2]'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions[2]'
- en: '''0.4'''
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '''0.4'''
- en: 'Data in the wild is often comma-separated rather than space-separated. Piece
    of cake: we can call split with an argument that tells it what to use as a separator:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况中，数据通常是用逗号分隔的，而不是空格分隔的。非常简单：我们可以通过给 split 函数传递一个参数，告诉它使用什么作为分隔符：
- en: '>>> info = ''Toronto,Ontario,Canada'''
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> info = ''Toronto,Ontario,Canada'''
- en: '>>> info.split('','')'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> info.split('','')'
- en: '[''Toronto'', ''Ontario'', ''Canada'']'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[''Toronto'', ''Ontario'', ''Canada'']'
- en: Joining a List into a String
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将列表连接成字符串
- en: 'To go the other way, from a list to a string rather than a string to a list,
    we can use the string join method. The string on which join is called is used
    as the separator between list values. Here are two examples:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要反过来，从列表转换为字符串，而不是从字符串转换为列表，我们可以使用字符串的 join 方法。调用 join 的字符串将作为分隔符，连接列表中的各个值。这里有两个示例：
- en: '>>> lst = [''Toronto'', ''Ontario'', ''Canada'']'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [''Toronto'', ''Ontario'', ''Canada'']'
- en: '>>> '',''.join(lst)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> '',''.join(lst)'
- en: '''Toronto,Ontario,Canada'''
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '''Toronto,Ontario,Canada'''
- en: '>>> ''**''.join(lst)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''**''.join(lst)'
- en: '''Toronto**Ontario**Canada'''
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '''Toronto**Ontario**Canada'''
- en: 'Technically, join can join the values in any sequence, not just in a list.
    Here’s an example of joining the characters from a string:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，join 可以将任何顺序中的值连接起来，而不仅仅是连接列表中的值。以下是一个从字符串中连接字符的示例：
- en: '>>> ''*''.join(''abcd'')'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''*''.join(''abcd'')'
- en: '''a*b*c*d'''
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '''a*b*c*d'''
- en: Changing List Values
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改列表值
- en: 'When we use split on a string of four pieces, we get a list of strings:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在包含四个部分的字符串上使用 split 时，会得到一个字符串列表：
- en: '>>> s = ''0.2 0.08 0.4 0.32'''
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = ''0.2 0.08 0.4 0.32'''
- en: '>>> proportions = s.split()'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions = s.split()'
- en: '>>> proportions'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions'
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
- en: In “Converting Between Strings and Integers” in [Chapter 1](ch01.xhtml#ch01),
    we learned that strings that look like numbers can’t be used in numerical calculations.
    So, we need to convert this list of strings to a list of floats.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.xhtml#ch01)《字符串与整数转换》中，我们学到了看起来像数字的字符串不能直接用于数值计算。因此，我们需要将这个字符串列表转换为浮点数列表。
- en: 'We can convert a string to a float using float, like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 float 将字符串转换为浮点数，如下所示：
- en: '>>> float(''45.6'')'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> float(''45.6'')'
- en: '45.6'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '45.6'
- en: 'That’s just one float. How can we convert a whole list of strings to a list
    of floats? It’s awfully tempting to try to make that happen using the following
    loop:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个浮点数。我们如何将整个字符串列表转换为浮点数列表呢？我们很容易就会想要通过以下循环来实现这一点：
- en: '>>> for value in proportions:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for value in proportions:'
- en: '...     value = float(value)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '...     value = float(value)'
- en: The logic is that this should go through each value in the list and convert
    it to a float.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 其逻辑是，这应该遍历列表中的每个值并将其转换为浮点数。
- en: 'Sadly, it doesn’t work. The list still refers to strings:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，它不起作用。列表仍然引用的是字符串：
- en: '>>> proportions'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions'
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
- en: 'What could be wrong? Is float not working? We can see that float is doing just
    fine by looking at the type of value after conversion:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 出了什么问题？是 float 无法工作吗？我们可以通过查看转换后的值的类型来看到，float 完全正常工作：
- en: '>>> for value in proportions:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for value in proportions:'
- en: '...     value = float(value)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '...     value = float(value)'
- en: '...     type(value)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '...     type(value)'
- en: '...'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: <class 'float'>
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: <class 'float'>
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: <class 'float'>
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: <class 'float'>
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: Four floats! But the list obdurately remains one of strings.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 四个浮动数！但是列表顽固地仍然是字符串类型。
- en: 'What’s happening here is that we’re not changing the values referred to in
    the list. We’re changing what the variable value refers to, but that doesn’t change
    the fact that the list refers to the old string values. To actually change the
    values that the list references, we need to assign new values at the list’s indices.
    Here’s how to do it:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，我们没有改变列表中引用的值。我们只是在改变变量值所指向的内容，但这并没有改变列表仍然引用旧的字符串值的事实。为了实际更改列表引用的值，我们需要在列表的索引位置分配新值。以下是方法：
- en: '>>> proportions'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions'
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
- en: '>>> for i in range(len(proportions)):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(len(proportions)):'
- en: '...     proportions[i] = float(proportions[i])'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '...     proportions[i] = float(proportions[i])'
- en: '...'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> proportions'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> proportions'
- en: '[0.2, 0.08, 0.4, 0.32]'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.2, 0.08, 0.4, 0.32]'
- en: The range for loop loops through each index, and an assignment statement changes
    what’s referred to by that index.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: for循环遍历每个索引，并通过赋值语句改变该索引所指向的内容。
- en: Solving Most of the Problem
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决大部分问题
- en: We’re now in good shape to solve the problem minus the catch.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好解决问题，唯一的问题就是陷阱。
- en: We’ll start with an example to highlight what our code will have to do. Then
    we’ll move onto the code itself.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个示例来说明我们的代码需要做什么。然后我们将进入代码本身。
- en: Exploring a Test Case
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: The input for this problem consists of 10 test cases, but I’ll present only
    one here. If you type this test case from the keyboard, you’ll see the answer.
    But the program won’t terminate there, because it’s waiting for the next test
    case. If you use input redirection with this test case, you’ll again see the answer.
    But then you’ll get an EOFError. EOF stands for “end of file”; the error is caused
    by the program trying to read more input than is available. Once your code is
    working for one test case, you can try adding a few more to your input to make
    sure that those work, too. Once you have 10, your program should run to completion.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的输入由10个测试用例组成，但这里我只会展示其中一个。如果你从键盘输入这个测试用例，你将看到答案。但程序不会在此终止，因为它正在等待下一个测试用例。如果你使用输入重定向来运行这个测试用例，你也会看到答案。但接着你会遇到EOFError错误。EOF代表“文件结束”；这个错误是因为程序尝试读取更多输入数据，但没有更多数据可读。当你的代码能够处理一个测试用例时，你可以尝试添加更多测试用例，确保它们也能正常工作。最终，输入10个测试用例时，程序应该能够运行完成。
- en: 'Here’s the test case I’d like to trace with you:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想和你一起跟踪的测试用例：
- en: '504'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '504'
- en: 0.2 0.08 0.4 0.32
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 0.2 0.08 0.4 0.32
- en: '125'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '125'
- en: The school trip costs $504, and there are 125 students who attend the brunch.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 学校旅行费用为504美元，有125名学生参加早午餐。
- en: To determine how much money is raised at the brunch, we calculate the money
    raised from each year of students. There are 125 * 0.2 = 25 students in their
    first year, and each of them pays $12 for the brunch. So, the first-year students
    raise 25 * 12 = 300 dollars. We can similarly calculate the money raised by the
    students in second, third, and fourth years. See [Table 5-1](ch05.xhtml#ch05tab01)
    for this work.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定在早午餐中筹集了多少钱，我们需要计算每年学生所筹集的资金。有125名学生中的20%是第一年学生，即125 * 0.2 = 25人，他们每人支付12美元参加早午餐。所以，一年级学生筹集了25
    * 12 = 300美元。我们可以用同样的方法计算二年级、三年级和四年级学生所筹集的资金。有关详细计算，请参见[表5-1](ch05.xhtml#ch05tab01)。
- en: '**Table 5-1:** School Trip Example'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1：** 学校旅行示例'
- en: '| **Year** | **Students in year** | **Cost per student** | **Money raised**
    |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| **年份** | **该年学生人数** | **每位学生费用** | **筹集的资金** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| First year | 25 | 12 | 300 |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| 一年级 | 25 | 12 | 300 |'
- en: '| Second year | 10 | 10 | 100 |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| 二年级 | 10 | 10 | 100 |'
- en: '| Third year | 50 | 7 | 350 |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| 三年级 | 50 | 7 | 350 |'
- en: '| Fourth year | 40 | 5 | 200 |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 四年级 | 40 | 5 | 200 |'
- en: The money raised by each year of students is calculated by multiplying the number
    of students in that year by the cost per student in that year; see the rightmost
    column of the table. For the total money raised by all students, we can add the
    four numbers in this rightmost column. That gives us 300 + 100 + 350 + 200 = 950
    dollars. Only 50 percent of that can be used for the school trip. So we’re left
    with 950 / 2 = 475 dollars, not sufficient to pay for the $504 trip. The correct
    output is therefore YES, because more money must be raised.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 每年学生所筹集的资金是通过将该年学生人数与每位学生的费用相乘得到的；请参见表格最右列。所有学生所筹集的总金额可以通过将这一列中的四个数字相加得到。计算结果为300
    + 100 + 350 + 200 = 950美元。只有其中50%的资金可以用于学校旅行。因此，我们剩下950 / 2 = 475美元，无法支付504美元的旅行费用。所以，正确的输出应该是YES，因为需要筹集更多资金。
- en: The Code
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: This partial solution will correctly handle any input where multiplying a proportion
    by the number of students gives a whole number of students (such as the test case
    that we just did). See [Listing 5-4](ch05.xhtml#ch05ex04) for the code.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的解决方案将正确处理任何输入，其中将比例与学生人数相乘得到的是整数（比如我们刚才做的测试用例）。请参见 [列表 5-4](ch05.xhtml#ch05ex04)
    获取代码。
- en: ❶ YEAR_COSTS = [12, 10, 7, 5]
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ YEAR_COSTS = [12, 10, 7, 5]
- en: '❷ for dataset in range(10):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for dataset in range(10):'
- en: trip_cost = int(input())
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: trip_cost = int(input())
- en: ❸ proportions = input().split()
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ proportions = input().split()
- en: num_students = int(input())
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: num_students = int(input())
- en: '❹ for i in range(len(proportions)):'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ for i in range(len(proportions)):'
- en: proportions[i] = float(proportions[i])
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: proportions[i] = float(proportions[i])
- en: ❺ students_per_year = []
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ students_per_year = []
- en: 'for proportion in proportions:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 'for proportion in proportions:'
- en: ❻ students = int(num_students * proportion)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ students = int(num_students * proportion)
- en: students_per_year.append(students)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: students_per_year.append(students)
- en: total_raised = 0
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: total_raised = 0
- en: '❼ for i in range(len(students_per_year)):'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '❼ for i in range(len(students_per_year)):'
- en: total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]
- en: '❽ if total_raised / 2 < trip_cost:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '❽ if total_raised / 2 < trip_cost:'
- en: print('YES')
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: print('YES')
- en: 'else:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('NO')
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: '*Listing 5-4: Solving most of School Trip*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4: 解决大部分学校旅行问题*'
- en: 'To begin, we use variable YEAR_COSTS to refer to a list of costs for attending
    the brunch: the cost for students in their first, second, third, and fourth year
    ❶. Once we’ve determined the number of students in each year, we’ll multiply by
    these values to determine the money raised. The costs never change, so we’ll never
    change what this variable refers to. For such “constant” variables, Python convention
    is to write their names in capital letters, as I’ve done here.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们使用变量 YEAR_COSTS 来表示一份列出了学生参加午餐费用的列表：第一年、第二年、第三年和第四年学生的费用 ❶。一旦确定了每年学生的人数，我们将乘以这些费用来确定筹集的资金。费用是固定的，所以我们永远不会改变这个变量的值。对于这种“常量”变量，Python
    的约定是将其名称写成大写字母，正如我在这里所做的。
- en: The input contains 10 test cases, so we loop 10 times ❷, once for each test
    case. The rest of the program is inside this loop, because we want to repeat everything
    10 times.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含 10 个测试用例，所以我们循环 10 次 ❷，每次处理一个测试用例。程序的其余部分都在这个循环内，因为我们要将所有内容重复执行 10 次。
- en: For each test case, we read the three lines of input. The second line is the
    one that has the four proportions, so we use split to split it into a list of
    four strings ❸. We use a range for loop to convert each of those strings to a
    float ❹.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，我们读取三行输入。第二行包含四个比例，因此我们使用 split 将其拆分成四个字符串的列表 ❸。我们使用一个范围 for 循环将每个字符串转换为浮点数
    ❹。
- en: Using those proportions, our next task is to determine the number of students
    in each year. We begin with an empty list ❺. Then, for each proportion, we multiply
    the total number of students by that proportion ❻ and append it to the list. Notice
    at ❻ that I’m using int to guarantee that we’re appending only integers. When
    used on a float, int drops the fractional part by rounding toward 0.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些比例，接下来的任务是确定每年学生的人数。我们从一个空列表 ❺ 开始。然后，对于每个比例，我们将总学生人数乘以该比例 ❻，并将其添加到列表中。请注意，在
    ❻ 处，我使用了 int 来确保我们只添加整数。当用于浮点数时，int 会通过向零舍入来去掉小数部分。
- en: 'Now we have the two lists that we need to calculate how much money has been
    raised. In students_per_year, we have a list of the number of students in each
    year, which looks something like this:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了计算筹集资金所需的两个列表。在 students_per_year 中，我们有每年学生人数的列表，它大概是这样的：
- en: '[25, 10, 50, 40]'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[25, 10, 50, 40]'
- en: 'And in YEAR_COSTS, we have the cost of brunch for students in each year:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在 YEAR_COSTS 中，我们有每年学生的午餐费用：
- en: '[12, 10, 7, 5]'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[12, 10, 7, 5]'
- en: Each value at index 0 in these lists tells us something about students in their
    first year, each value at index 1 tells us something about students in their second
    year, and so on. Such lists are called *parallel lists*, because they work in
    parallel to tell us more than each does alone.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表中索引为 0 的每个值告诉我们第一年学生的情况，索引为 1 的每个值告诉我们第二年学生的情况，以此类推。这样的列表被称为 *并行列表*，因为它们并行工作，提供的信息比单独使用任何一个都要多。
- en: We use these two lists to calculate the total money raised, by multiplying each
    number of students by the corresponding cost per student and adding up all of
    these results ❼.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这两个列表来计算筹集的总金额，通过将每个学生的人数乘以每个学生的对应费用，并将所有结果加起来 ❼。
- en: Has enough money been raised for the school trip? To find out, we use an if
    statement ❽. Half of the money raised by the brunch can be used for the school
    trip. If that amount is less than the cost of the school trip, then we need to
    raise more money (YES); otherwise, we don’t (NO).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 是否为学校旅行筹集了足够的资金？为了确定这一点，我们使用了 if 语句 ❽。早午餐筹集的资金的一半可以用于学校旅行。如果这个金额少于学校旅行的费用，那么我们需要筹集更多资金（YES）；否则，不需要（NO）。
- en: 'The code we’ve written is very general. The only clue that there are four years
    of students is at ❶. If we wanted to solve a similar problem for a different number
    of years, all we’d have to do is change that line (and provide input with the
    expected number of proportions). This is the power of lists: they help us write
    flexible code that can accommodate changes to problems we are solving.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码是非常通用的。唯一的线索是❶，表明有四个年级的学生。如果我们想为不同年级数的类似问题提供解决方案，只需要更改那一行（并提供包含预期比例的输入）。这就是列表的强大之处：它们帮助我们编写灵活的代码，能够适应我们解决问题时的变化。
- en: How to Handle the Catch
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何处理异常
- en: Now let’s see why our current program does the wrong thing for some test cases,
    and the Python features we’ll use to fix it.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看为什么我们的当前程序会在某些测试用例中出错，以及我们将使用的 Python 特性来修复它。
- en: Exploring a Test Case
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: 'Here’s a test case that our current code gets wrong:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个当前代码处理错误的测试用例：
- en: '50'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: 0.7 0.1 0.1 0.1
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7 0.1 0.1 0.1
- en: '9'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: This time, the school trip costs $50, and there are nine students that attend
    the brunch. For the number of students in their first year, our current program
    would calculate 9 * 0.7 = 6.3 and then round down to 6\. The fact that we have
    to round down is why we have to be careful with this test case. To see what our
    current program would do for all four years, see [Table 5-2](ch05.xhtml#ch05tab02).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，学校旅行费用为50美元，共有9名学生参加了早午餐。对于大一的学生人数，当前程序会计算 9 * 0.7 = 6.3，然后向下取整为6。由于我们必须向下取整，这也是我们需要小心这个测试用例的原因。要查看我们当前程序对于所有四年级的计算结果，请参见[表5-2](ch05.xhtml#ch05tab02)。
- en: '**Table 5-2:** An Example Case from School Trip That Our Current Program Gets
    Wrong'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-2：** 一个来自学校旅行的示例案例，当前程序计算错误'
- en: '| **Year** | **Students in year** | **Cost per student** | **Money raised**
    |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| **年级** | **年级学生数** | **每个学生费用** | **筹集资金** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| First year | 6 | 12 | 72 |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 大一 | 6 | 12 | 72 |'
- en: '| Second year | 0 | 10 | 0 |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 大二 | 0 | 10 | 0 |'
- en: '| Third year | 0 | 7 | 0 |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 大三 | 0 | 7 | 0 |'
- en: '| Fourth year | 0 | 5 | 0 |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 大四 | 0 | 5 | 0 |'
- en: In each year besides the first year, there are 0 students because 9 * 0.1 =
    0.9 rounds down to 0\. So it looks like all we raise is $72\. Half of $72 is $36,
    not sufficient to pay for the $50 school trip. Our current program outputs YES.
    We need to raise more money.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 除了大一以外的每个年级都有0名学生，因为 9 * 0.1 = 0.9 向下取整为 0。所以看起来我们只筹集了72美元。72美元的一半是36美元，不足以支付50美元的学校旅行费用。我们的当前程序输出YES。我们需要筹集更多的资金。
- en: . . . Or not. We’re supposed to have nine students here, not six! We’ve lost
    three students to rounding. The problem description specifies that we should add
    those students to the year with the most students, which in this case is the first
    year. If we do that, we see that we actually raise 9 * 12 = 108 dollars. Half
    of $108 is $54, so in fact we do *not* need to raise any more money for the $50
    school trip! The correct output is NO.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 或者不修复。我们这里应该有9名学生，而不是6名！我们由于向下取整失去了3名学生。问题描述中规定，我们应该将这些学生加到人数最多的年级，这里是大一。如果我们这样做，就会看到我们实际上筹集了
    9 * 12 = 108 美元。108 美元的一半是 54 美元，因此实际上我们不需要再为50美元的学校旅行筹集更多资金！正确的输出是NO。
- en: More List Operations
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多列表操作
- en: 'To fix our program, we need to do two things: figure out how many students
    were lost to rounding, and add those students to the year with the most students.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复我们的程序，我们需要做两件事：找出由于四舍五入丢失的学生人数，并将这些学生添加到人数最多的年级。
- en: Summing a List
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 求和列表
- en: 'To determine the number of students lost to rounding, we can add up the students
    in our students_per_year list and then subtract that from the total number of
    students. Python’s sum function takes a list and returns the sum of its values:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定由于四舍五入丢失的学生人数，我们可以将 students_per_year 列表中的学生数加起来，然后从总学生数中减去这个值。Python 的
    sum 函数接受一个列表并返回其值的总和：
- en: '>>> students_per_year = [6, 0, 0, 0]'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year = [6, 0, 0, 0]'
- en: '>>> sum(students_per_year)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sum(students_per_year)'
- en: '6'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '>>> students_per_year = [25, 10, 50, 40]'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year = [25, 10, 50, 40]'
- en: '>>> sum(students_per_year)'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sum(students_per_year)'
- en: '125'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '125'
- en: Finding the Index of the Maximum
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找最大值的索引
- en: 'Python’s max function takes a sequence and returns its maximum value:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 max 函数接受一个序列并返回其最大值：
- en: '>>> students_per_year = [6, 0, 0, 0]'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year = [6, 0, 0, 0]'
- en: '>>> max(students_per_year)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> max(students_per_year)'
- en: '6'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '>>> students_per_year = [25, 10, 50, 40]'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year = [25, 10, 50, 40]'
- en: '>>> max(students_per_year)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> max(students_per_year)'
- en: '50'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: 'We want the index of the maximum, not the maximum itself, so that we can increase
    the number of students at that index. Given the maximum value, we can find its
    index using the index method. It returns the leftmost index where the provided
    value is found or generates an error if the value is not in the list at all:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最大值的索引，而不是最大值本身，以便我们可以增加该索引处的学生人数。给定最大值，我们可以使用`index`方法找到它的索引。它返回提供值所在的最左边的索引，或者如果该值不在列表中，则会生成错误：
- en: '>>> students_per_year = [6, 0, 0, 0]'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year = [6, 0, 0, 0]'
- en: '>>> students_per_year.index(6)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year.index(6)'
- en: '0'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> students_per_year.index(0)'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year.index(0)'
- en: '1'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> students_per_year.index(50)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> students_per_year.index(50)'
- en: 'Traceback (most recent call last):'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'ValueError: 50 is not in list'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: 50 is not in list'
- en: We’ll be searching for a value that we know is in the list, so we won’t have
    to worry about getting an error.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寻找一个我们知道在列表中的值，因此不必担心会发生错误。
- en: Solving the Problem
  id: totrans-587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re there! We can now update our partial solution to handle any valid test
    case. The new program is in [Listing 5-5](ch05.xhtml#ch05ex05).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到了！现在我们可以更新我们的部分解决方案以处理任何有效的测试用例。新程序在[列表 5-5](ch05.xhtml#ch05ex05)中。
- en: YEAR_COSTS = [12, 10, 7, 5]
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: YEAR_COSTS = [12, 10, 7, 5]
- en: 'for dataset in range(10):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dataset in range(10):'
- en: trip_cost = int(input())
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: trip_cost = int(input())
- en: proportions = input().split()
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: proportions = input().split()
- en: num_students = int(input())
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: num_students = int(input())
- en: 'for i in range(len(proportions)):'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(proportions)):'
- en: proportions[i] = float(proportions[i])
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: proportions[i] = float(proportions[i])
- en: students_per_year = []
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: students_per_year = []
- en: 'for proportion in proportions:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 'for proportion in proportions:'
- en: students = int(num_students * proportion)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: students = int(num_students * proportion)
- en: students_per_year.append(students)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: students_per_year.append(students)
- en: ❶ counted = sum(students_per_year)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ counted = sum(students_per_year)
- en: uncounted = num_students - counted
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: uncounted = num_students - counted
- en: most = max(students_per_year)
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: most = max(students_per_year)
- en: where = students_per_year.index(most)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: where = students_per_year.index(most)
- en: ❷ students_per_year[where] = students_per_year[where] + uncounted
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ students_per_year[where] = students_per_year[where] + uncounted
- en: total_raised = 0
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: total_raised = 0
- en: 'for i in range(len(students_per_year)):'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(students_per_year)):'
- en: total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]
- en: 'if total_raised / 2 < trip_cost:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 'if total_raised / 2 < trip_cost:'
- en: print('YES')
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: print('YES')
- en: 'else:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('NO')
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: '*Listing 5-5: Solving School Trip*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：解决学校旅行问题*'
- en: The only new code is the five lines starting at ❶. We use sum to calculate how
    many students we’ve counted so far and then subtract this from the total number
    of students to arrive at the number of uncounted students. We then use max and
    index to identify the index of the year to which we should add the uncounted students.
    Finally, we add the uncounted students to this index ❷. (Adding 0 to a number
    doesn’t change that number, so don’t worry about coding special behavior for when
    uncounted is 0. This code is safe in that case.)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新代码是从❶开始的五行。我们使用`sum`计算目前为止已计数的学生数，然后从学生总数中减去这些，得到未计数的学生数。然后，我们使用`max`和`index`来找出应该将未计数学生加到的年份索引。最后，我们将未计数的学生加到该索引❷处。（将0加到数字上不会改变该数字，因此不必担心编码特殊行为来处理未计数为0的情况。该代码在这种情况下是安全的。）
- en: That’s all for this problem. Go ahead and submit to the judge! And then come
    back—we’re about to explore even more general list structures.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题就解决了。现在提交给评测系统吧！然后再回来——我们将进一步探索更一般的列表结构。
- en: Before continuing, you might like to try solving exercise 5 from “Chapter Exercises”
    on [page 134](ch05.xhtml#ch05lev1sec18).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可以尝试解决《章节练习》中第5题，位于[第134页](ch05.xhtml#ch05lev1sec18)。
- en: 'Problem #13: Baker Bonus'
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #13：面包师奖金'
- en: In this problem, we’ll see how lists help us work with two-dimensional data.
    This kind of data arises often in real-world programs. For example, data in the
    form of a spreadsheet consists of rows and columns; processing such data requires
    techniques like those we’re about to learn.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将看到如何使用列表来处理二维数据。这类数据在实际程序中非常常见。例如，电子表格形式的数据由行和列组成；处理这种数据需要像我们即将学习的技术。
- en: This is DMOJ problem ecoo17r3p1.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题eco17r3p1。
- en: The Challenge
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Baker Brie has a number of franchisees, each of which sells baked goods to
    consumers. Having reached the milestone of being in business for 13 years, Baker
    Brie will celebrate by awarding bonuses based on sales. The bonuses depend on
    sales per day and sales per franchisee. Here’s how the bonuses work:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: For every day on which the total sales across all franchisees is a multiple
    of 13, that multiple will be given as bonuses. For example, a day where the franchisees
    sold a combined 26 baked goods will add 26 / 13 = 2 bonuses to the total.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every franchisee whose total sales across all days is a multiple of 13,
    that multiple will be given as bonuses. For example, a franchisee that sold a
    total of 39 baked goods will add 39 / 13 = 3 bonuses to the total.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the total number of bonuses awarded.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the integer number of franchisees *f* and integer number of
    days *d*, separated by a space. *f* is between 4 and 130, and *d* is between 2
    and 4,745.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*d* lines, one per day, containing *f* integers separated by spaces. Each integer
    specifies a number of sales. The first of these lines gives the sales for each
    franchise on the first day, the second gives the sales for each franchise on the
    second day, and so on. Each integer is between 1 and 13,000.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For each test case, output the total number of bonuses awarded.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Representing a Table
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data for this problem can be visualized as a table. We’ll start with an
    example and then look at how to represent a table as a list.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we have *d* days and *f* franchisees, we can lay out the data as a table
    with *d* rows and *f* columns.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample test case:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 6 4
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 1 13 2 1 1 8
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 2 12 10 5 11 4
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 39 6 13 52 3 3
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 15 8 6 2 7 14
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: The table corresponding to this test case is in [Table 5-3](ch05.xhtml#ch05tab03).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** Baker Bonus Table'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | 13 | 2 | 1 | 1 | 8 |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| **1** | 2 | 12 | 10 | 5 | 11 | 4 |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| **2** | 39 | 6 | 13 | 52 | 3 | 3 |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
- en: '| **3** | 15 | 8 | 6 | 2 | 7 | 14 |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
- en: I’ve numbered the rows and columns starting at 0 to coincide with how we’ll
    shortly store this data in a list.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: How many bonuses are awarded in this test case? Let’s first look at the rows
    of the table, which correspond to days. The sum of the sales for row 0 is 1 +
    13 + 2 + 1 + 1 + 8 = 26\. As 26 is a multiple of 13, this row gives us 26 / 13
    = 2 bonuses. The sum of row 1 is 44\. That’s not a multiple of 13, so no bonuses
    there. The sum of row 2 is 116—again, no bonuses. The sum of row 3 is 52, which
    gives us 52 / 13 = 4 bonuses.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the columns, which correspond to franchisees. The sum of column
    0 is 1 + 2 + 39 + 15 = 57\. That’s not a multiple of 13, so no bonuses. In fact,
    the only column that gives us any bonuses is column 1\. Its sum is 39, giving
    us 39 / 13 = 3 bonuses.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: The total number of bonuses awarded is 2 + 4 + 3 = 9\. So, 9 is the correct
    output for this test case.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Nested Lists
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To this point, we’ve seen lists of integers, floats, and strings. We can also
    create lists of lists, called *nested lists*. Each value of such a list is itself
    a list. It’s common to use a variable name like grid or table to refer to a nested
    list. Here’s a Python list corresponding to [Table 5-3](ch05.xhtml#ch05tab03):'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid = [[ 1, 13,  2,  1,  1,  8],'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '...         [ 2, 12, 10,  5, 11,  4],'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '...         [39,  6, 13, 52,  3,  3],'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '...         [15,  8,  6,  2,  7, 14]]'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'Each list value corresponds to one row. If we index once, we get a row, which
    is itself a list:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid[0]'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 13, 2, 1, 1, 8]'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid[2]'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[39, 6, 13, 52, 3, 3]'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'If we index twice, we get a single value. Here’s the value in row 1, column
    2:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid[1][2]'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with columns is a little trickier than working with rows, because each
    column is spread over multiple lists. To access a column, we need to aggregate
    one value from each row. We can do that with a loop, which incrementally builds
    a new list representing a column. Here, I obtain column 1:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '>>> column = []'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(grid)):'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: ❶ ...     column.append(grid[i][1])
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '>>> column'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[13, 12, 6, 8]'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the first index (the row) varies, but the second (the column) does
    not ❶. This picks out each value with the same column index.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'What about summing rows and columns? To sum a row, we can use the sum function.
    Here’s the sum of row 0:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sum(grid[0])'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a loop, like this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total = 0'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for value in grid[0]:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '...     total = total + value'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Using sum is the easier option, so we’ll use that.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum a column, we can build a column list and use sum on that, or we can
    calculate it directly without making a new list. Here’s the latter approach for
    column 1:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total = 0'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(grid)):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '...     total = total + grid[i][1]'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: lst = [[1, 1],
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 3, 4]]'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(lst)):'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(len(lst[0])):'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: x = x + lst[i][j]
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: A. 2
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: B. 7
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: C. 11
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces an error (it uses an invalid index)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The variable i goes through the values 0 and 1 (because the length
    of lst is 2); the variable j also goes through the values 0 and 1 (because the
    length of lst[0] is 2). The values in the list that are summed are therefore those
    where each index is 0 or 1\. In particular, this does not include the 4 at lst[1][2].'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: The following code contains two print calls. What is the output?
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: lst = [[5, 10], [15, 20]]
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: x = lst[0]
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: x[0] = 99
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: print(lst)
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: lst = [[5, 10], [15, 20]]
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: y = lst[0]
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: y = y + [99]
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: print(lst)
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: A.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[[99, 10], [15, 20]]'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: B.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[[99, 10], [15, 20]]'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10, 99], [15, 20]]'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: C.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: D.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10, 99], [15, 20]]'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. x refers to the first row of lst; it’s another way to reference
    lst[0]. Therefore, when we do x[0] = 99, that change is also reflected when looking
    at the list through lst.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: Next, y also refers to the first row of lst. But then we assign a new list to
    y—and it’s that list, not the first row of lst, that has the 99 appended to it.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our code to solve this problem is in [Listing 5-6](ch05.xhtml#ch05ex06).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: ❶ lst = input().split()
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: franchisees = int(lst[0])
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: days = int(lst[1])
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: grid = []
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(days):'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: row = input().split()
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for j in range(franchisees):'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: row[j] = int(row[j])
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: ❹ grid.append(row)
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = 0
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '❺ for row in grid:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: ❻ total = sum(row)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'if total % 13 == 0:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = bonuses + total // 13
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '❼ for col_index in range(franchisees):'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '❽ for row_index in range(days):'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: total = total + grid[row_index][col_index]
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'if total % 13 == 0:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = bonuses + total // 13
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: print(bonuses)
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-6: Solving Baker Bonus*'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: As with School Trip, the input contains 10 test cases, so we place all of our
    code inside a loop that iterates 10 times.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: For each test case, we read the first line of input and call split to break
    it into a list ❶. That list will contain two values—the number of franchisees
    and the number of days—and we convert them to integers and assign them to appropriately
    named variables.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: The grid variable begins as an empty list. It will ultimately refer to a list
    of rows, where each row is a list of sales for a given day.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: We use a range for loop to loop once for each day ❷. We then read a row from
    the input and call split to split it into a list of individual sales values. These
    values are strings right now, so we use a nested loop to convert them all to integers
    ❸. Then, we add the row to our grid ❹.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now read the input and stored the grid. It’s time to add up the number
    of bonuses. We take that in two steps: first for the bonuses from the rows and
    second for the bonuses from the columns.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: To find the bonuses from the rows, we use a for loop on grid ❺. As with any
    for loop on a list, it gives us its values one at a time. Here, each value is
    a list, so row refers to a different list on each iteration. The sum function
    works on any list of numbers, so we use it here to add up the values in the current
    row ❻. If the sum is divisible by 13, then we add the number of bonuses.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: We can’t loop through columns of the list like we did rows, so we have to resort
    to looping through indices. We accomplish that by using a range for loop through
    the indices of the columns ❼. Using sum is not an option for summing the current
    column, so we’ll need a nested loop. That nested loop goes through the rows ❽,
    adding up each value in the desired column. We then check whether that total is
    divisible by 13 and add any bonuses if it is.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: We finish by printing the total number of bonuses.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Judge time! If you submit our code, you should see that all test cases pass.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about lists, which help us work with collections
    of whatever type we choose. Lists of numbers, lists of strings, lists of lists:
    Python supports whatever we need. We also learned about list methods and why sorting
    a list can make it easier to process the values in a list.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to strings, lists are mutable, which means that we can change their
    contents. This helps us more easily manipulate lists, but we must be careful to
    modify the list that we think we’re modifying.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: We’re at the point in our learning where we can write programs with many lines
    of code. We can direct what our programs do using if statements and loops. We
    can store and manipulate information using strings and lists. We can write programs
    to solve challenging problems. Such programs can become difficult to design and
    read. Fortunately, there’s a tool we can use to help us organize our programs
    to keep their complexity under control, and we’ll learn that tool in the next
    chapter. Working through some of the following exercises may deepen your appreciation
    of the difficulty in writing larger amounts of code. Then you’ll be ready to continue!
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem ccc07j3, Deal or No Deal Calculator
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci17c1p1, Cezar
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci18c2p1, Preokret
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc00s2, Babbling Brooks (Check out Python’s round function.)
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo18r1p1, Willow’s Wild Ride
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo19r1p1, Free Shirts
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc14c7p2, Tides
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem wac3p3, Wesley Plays DDR
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo18r1p2, Rue’s Rings (If you use f-strings here, you’ll need
    a way to include the { and } symbols themselves. You can include a { in the f-string
    by using {{ and a } by using }}.)
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci19c5p1, Emacs
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci20c2p1, Crtanje (You’ll need to support rows from –100 to
    100\. But how do we support negative-indexed rows when Python lists start at index
    0? Here’s a trick: use index x + 100 any time you need access to row x. That shifts
    the row numbers to be between 0 and 200 rather than between –100 and 100\. Also,
    one small annoyance here with strings: \ is a special character, so you’ll have
    to use ''\\'' rather than ''\'' if you want a \ character.)'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc19c5p2, Charlie’s Crazy Conquest (You’ll have to be careful
    with indices and the game rules for this one!)
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Village Neighborhood is originally from the 2018 Canadian Computing Competition,
    Senior Level. School Trip is originally from the 2017 Educational Computing Organization
    of Ontario Programming Contest, Round 1\. Baker Bonus is originally from the 2017
    Educational Computing Organization of Ontario Programming Contest, Round 3.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
