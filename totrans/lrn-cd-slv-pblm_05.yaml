- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ORGANIZING VALUES USING LISTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: We’ve seen that we can use strings to work with a sequence of characters. In
    this chapter, we’ll learn about lists, which help us work with sequences of other
    types of values, such as integers and floats. We’ll also learn that we can nest
    lists inside of lists, which lets us work with grids of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll solve three problems using lists: finding the smallest neighborhood of
    a collection of villages, determining whether sufficient money has been raised
    for a school trip, and calculating the number of bonuses offered by a bakery.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #11: Village Neighborhood'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’re going to find the size of the smallest neighborhood of
    a collection of villages. We’ll find it helpful to store all of the neighborhood
    sizes. We might have as many as 100 villages, though, and using a separate variable
    for each village would be a nightmare. We’ll see that lists allow us to aggregate
    what would otherwise be separate variables into one collection. We’ll also learn
    about Python’s powerful list operations for modifying, searching, and sorting
    a list.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem ccc18s1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are *n* villages located at distinct points on a straight road. Each village
    is represented by an integer that indicates its position on the road.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A village’s left neighbor is the village with the next smallest position; a
    village’s right neighbor is the village with the next biggest position. The *neighborhood*
    of a village consists of half the space between that village and its left neighbor,
    plus half the space between that village and its right neighbor. For example,
    if there’s a village at position 10, with its left neighbor at position 6 and
    its right neighbor at position 15, then this village’s neighborhood starts from
    position 8 (halfway between 6 and 10) and ends at position 12.5 (halfway between
    10 and 15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost and rightmost villages have only one neighbor, so the definition
    of a neighborhood doesn’t make sense for them. We’ll ignore the neighborhoods
    of those two villages in this problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The *size* of a neighborhood is calculated as the neighborhood’s rightmost position
    minus the neighborhood’s leftmost position. For example, the neighborhood that
    goes from 8 to 12.5 has size 12.5 – 8 = 4.5.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Determine the size of the smallest neighborhood.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A line containing integer *n*, the number of villages. *n* is between 3 and
    100.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each of which gives the position of a village. Each position is
    an integer between –1,000,000,000 and 1,000,000,000\. The positions need not come
    in order from left to right; the neighbor of a village could be anywhere in these
    lines.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the size of the smallest neighborhood. Include exactly one digit after
    the decimal point.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Why Lists?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of reading the input, we’ll need to read *n* integers (the integers
    that represent the positions of the villages). We dealt with this once already
    when solving Data Plan in [Chapter 3](ch03.xhtml#ch03). There, we used a range
    for loop to loop exactly *n* times. We’ll do that here, too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: There’s one crucial difference between Data Plan and Village Neighborhood. In
    Data Plan, we read an integer, used it, and never referred to it again. We didn’t
    need to keep it around. But in Village Neighborhood, it’s not enough to see each
    integer just once. A village’s neighborhood depends on its left and right neighbors.
    Without access to those neighbors, we can’t calculate the size of the village’s
    neighborhood. We need to store all of the village positions for later use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of why we need to store all of the village positions, consider
    this test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: There are six villages here. To find the size of a village’s neighborhood, we
    need that village’s left and right neighbors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The first village in the input is at position 20\. What’s the size of that village’s
    neighborhood? To answer that, we need access to all of the village positions so
    that we can find its left and right neighbors. Scanning through the positions,
    you can identify that the left neighbor is at position 19 and the right neighbor
    is at position 50\. The size of this village’s neighborhood is therefore (20 –
    19)/2 + (50 – 20)/2 = 15.5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The second village in the input is at position 50\. What’s the size of that
    village’s neighborhood? Again, we need to look through the positions to figure
    it out. This village happens to be the rightmost one, so we ignore this village’s
    neighborhood.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The third village in the input is at position 4\. The left neighbor is at position
    1, and the right neighbor is at position 15, so the size of this village’s neighborhood
    is (4 – 1)/2 + (15 – 4)/2 = 7.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The fourth village in the input is at position 19\. The left neighbor is at
    position 15, and the right neighbor is at position 20, so the size of this village’s
    neighborhood is (19 – 15)/2 + (20 – 19)/2 = 2.5.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The only remaining village that we need to consider is at position 15\. If you
    calculate its neighborhood size, you should get an answer of 7.5.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Comparing all of the neighborhood sizes that we calculated, we see that the
    minimum—and the correct answer for this test case—is 2.5.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to store all of the village positions so that we can find the
    neighbors of each village. A string won’t help, because strings store characters,
    not integers. Python lists to the rescue!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *list* is a Python type that stores a sequence of values. (You’ll sometimes
    see list values referred to as *elements*.) We use opening and closing square
    brackets to delimit the list.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We can store only characters in strings, but we can store any type of value
    in lists. This list of integers holds the village positions from the prior section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '>>> [20, 50, 4, 19, 15, 1]'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 50, 4, 19, 15, 1]'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a list of strings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '>>> [''one'', ''two'', ''hello'']'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[''one'', ''two'', ''hello'']'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even create a list whose values are of different types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '>>> [''hello'', 50, 365.25]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[''hello'', 50, 365.25]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of what you learned about strings applies to lists as well. For example,
    lists support the + operator for concatenation and the * operator for replication:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '>>> [1, 2, 3] + [4, 5, 6]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '>>> [1, 2, 3] * 4'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'We even have the in operator, which tells us whether a value is in a list or
    not:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''one'' in [''one'', ''two'', ''hello'']'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''n'' in [''one'', ''two'', ''three'']'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'And we have the len function to give us the length of a list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '>>> len([''one'', ''two'', ''hello''])'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'A list is a sequence, and we can use a for loop to loop through its values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for value in [20, 50, 4, 19, 15, 1]:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(value)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We can make variables refer to lists, just as we make them refer to strings,
    integers, and floats. Let’s make two variables refer to lists and then concatenate
    them to produce a new list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst1 = [1, 2, 3]'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst2 = [4, 5, 6]'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst1 + lst2'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'While we displayed the concatenated list, we did not store it, as we can see
    by looking at the lists again:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst1'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst2'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 5, 6]'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a variable refer to the concatenated list, we use assignment:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst3 = lst1 + lst2'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst3'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Names like lst, lst1, and lst2 can be used when there’s no need to be more specific
    about what a list contains.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'But don’t use list itself as a variable name. It’s already a name that we can
    use to convert a sequence to a list:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '>>> list(''abcde'')'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[''a'', ''b'', ''c'', ''d'', ''e'']'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: If you make a variable named list, you’ll lose this valuable behavior, and you’ll
    confuse readers who will expect list not to be tampered with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, lists support indexing and slicing. Indexing returns a single value,
    and slicing returns a list of values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = [50, 30, 81, 40]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[1]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[-2]'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '81'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[1:3]'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[30, 81]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a list of strings, we can access one of its string’s characters
    by indexing twice, first to select a string and then to select a character:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = [''one'', ''two'', ''hello'']'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[2]'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '''hello'''
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[2][1]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '''e'''
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: What does the following code store in the total variable?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: lst = [a list of numbers]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'while i <= len(lst):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: total = total + i
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: i = i + 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A. The sum of the list
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: B. The sum of the list, not including its first value
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: C. The sum of the list, not including its first and last values
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: D. This code causes an error because it accesses an invalid index of the list
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: E. None of the above
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: E. This code adds the numbers 1, 2, 3, and so on, up to the length
    of the list. It doesn’t add numbers from the list or index the list at all!'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: List Mutability
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings are *immutable*, which means they cannot be modified. When it looks
    like we’re changing a string (for example, using string concatenation), we’re
    really creating a new string, not modifying one that already exists.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Lists, on the other hand, are *mutable*, which means they *can* be modified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe this difference by using indexing. If we try to change a character
    of a string, we get an error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''hello'''
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s[0] = ''j'''
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: ''str'' object does not support item assignment'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The error message says that strings don’t support item assignment, which just
    means that we can’t change their characters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'But because lists are mutable, we can change their values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = [''h'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[''h'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[0] = ''j'''
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[''j'', ''e'', ''l'', ''l'', ''o'']'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[2] = ''x'''
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[''j'', ''e'', ''x'', ''l'', ''o'']'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a precise understanding of the assignment statement, mutability can
    lead to seemingly bewildering behavior. Here’s an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = [1, 2, 3, 4, 5]'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> y = x
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x[0] = 99'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 2, 3, 4, 5]'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'No surprises yet. But you might be surprised by this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 2, 3, 4, 5]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: How did the 99 get into y like that?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: When we assign x to y ❶, y is set to refer to the same list as x. The assignment
    statement doesn’t copy the list. There’s only one list, and it happens to have
    two names (or *aliases*) that refer to it. So if we make a change to that list,
    we see that change whether we refer to the list by x or y.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Mutability is useful because it directly models what we might want to do with
    the values in a list. If we want to change a value, we just change it. Without
    mutability, changing one value isn’t possible. We’d have to create a new list
    that was the same as the old list except for the value that we wanted to change.
    That would work, but it is a roundabout and less transparent way of changing a
    value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'If you really do want a copy of a list, not just another name for it, you can
    use slicing. Leave out both the start and end indices, which results in a copy
    of the entire list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = [1, 2, 3, 4, 5]'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = x[:]'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x[0] = 99'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 2, 3, 4, 5]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4, 5]'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Observe this time that the y list didn’t change when the x list changed. They’re
    separate lists.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: lst = ['abc', 'def', 'ghi']
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: lst[1] = 'wxyz'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: print(len(lst))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: A. 3
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: B. 9
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: C. 10
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: D. 4
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: E. This code produces an error
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. Changing a list value is allowed (because lists are mutable). But
    changing the value at index 1 to a longer string doesn’t change the fact that
    the list has three values.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Learning About Methods
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like strings, lists have many useful methods. I’ll show you some of them in
    the next section, but first I’d like to show you how you can learn about methods
    on your own.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You can use Python’s dir function to get a list of methods for a particular
    type. Just call dir with a value as the argument, and you’ll get the methods for
    the type of that value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we get when we call dir using a string value as the argument:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '>>> dir('''')'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[''__add__'', ''__class__'', ''__contains__'', ''__delattr__'','
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <more stuff with underscores>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '''capitalize'', ''casefold'', ''center'', ''count'', ''encode'','
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '''endswith'', ''expandtabs'', ''find'', ''format'','
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '''format_map'', ''index'', ''isalnum'', ''isalpha'', ''isascii'','
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '''isdecimal'', ''isdigit'', ''isidentifier'', ''islower'','
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '''isnumeric'', ''isprintable'', ''isspace'', ''istitle'','
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '''isupper'', ''join'', ''ljust'', ''lower'', ''lstrip'','
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '''maketrans'', ''partition'', ''replace'', ''rfind'', ''rindex'','
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '''rjust'', ''rpartition'', ''rsplit'', ''rstrip'', ''split'','
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '''splitlines'', ''startswith'', ''strip'', ''swapcase'', ''title'','
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '''translate'', ''upper'', ''zfill'']'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we called dir with an empty string. We could have called dir with
    any string value; the empty string is just fastest to type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the names at the top with underscores; those names are for Python’s internal
    use and not generally of interest to programmers. The rest of the names are string
    methods that you can call. In that list, you’ll find string methods that you already
    know, such as isupper and count, and many others that we haven’t come across yet.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to use a method, you can use the name of that method in a call
    to help. Here’s the help we get on the string count method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(''''.count)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Help on built-in function count:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: count(...) method of builtins.str instance
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: ❶ S.count(sub[, start[, end]]) -> int
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of non-overlapping occurrences of
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: substring sub in string S[start:end].  Optional
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: arguments start and end are interpreted as in
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: slice notation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The help tells us how to call the method ❶.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Square brackets identify optional arguments. You would use start and end if
    you wanted to count the occurrences of sub within only a slice of the string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth browsing the list of methods to check whether one is available to
    help with your current programming task. Even if you’ve used a method before,
    looking at the help can show you features that you didn’t know existed!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: To see which list methods are available, call dir([]). To learn about them,
    call help([].xxx), where xxx is the name of a list method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the help for the string center method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(''''.center)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Help on built-in function center:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: center(width, fillchar=' ', /) method of builtins.str instance
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Return a centered string of length width.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Padding is done using the specified fill character
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: (default is a space).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: What is the string produced by the following code?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '''cave''.center(8, ''x'')'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: A. 'xxcavexx'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: B. ' cave '
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: C. 'xxxxcavexxxx'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: D. ' cave '
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. We’re calling center with a width of 8 and a fillchar of ''x''.
    (Had we provided only one argument, a space would have been used for fillchar.)
    The resulting string will therefore be of length 8\. The string ''cave'' has four
    characters, so we need four more characters to get us to length 8\. Python therefore
    adds two spaces at the beginning and two spaces at the end to center the string.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 我们调用了 center 方法，宽度为 8，填充字符为 'x'。（如果我们只提供了一个参数，填充字符就会使用空格。）因此，生成的字符串长度将为
    8。字符串 'cave' 有四个字符，所以我们需要四个额外的字符才能达到长度 8。Python 因此在字符串的前后各添加了两个空格来居中字符串。
- en: List Methods
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表方法
- en: Time to make progress on Village Neighborhood. I can think of two operations
    on a list that would help us solve it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在村庄邻里问题上取得进展了。我能想到两种操作，可以帮助我们解决这个问题。
- en: 'First, adding to a list. We’ll start off with no village positions and read
    them one at a time from the input. We therefore need a way to add each of these
    positions to a growing list: first the list will have nothing, and then it will
    have one village position in it, then two, and so on.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向列表中添加内容。我们将从没有任何村庄位置的列表开始，并从输入中逐一读取它们。因此，我们需要一种方法将每个位置添加到正在增长的列表中：首先列表是空的，然后它会包含一个村庄位置，接着是两个，依此类推。
- en: 'Second, sorting a list. Once we’ve read in the village positions, we need to
    find the smallest neighborhood. This involves looking at each village position
    and the distance to its left and right neighbors. The village positions could
    come in any order, so in general it’s not easy to find the neighbors of a given
    village. Think back to the work we did in “Why Lists?” in this chapter. For each
    village, we had to scan the entire list to find its neighbors. It’d be so much
    easier if we had the villages ordered by position. Then we’d know exactly where
    the neighbors were: they’d be just to the left and just to the right of a village.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，排序列表。一旦我们读取了村庄位置，我们需要找到最小的邻里。这涉及到查看每个村庄位置及其左右邻居的距离。村庄的位置可能是无序的，因此通常很难找到某个特定村庄的邻居。回想一下我们在本章“为什么使用列表？”部分做的工作。对于每个村庄，我们必须扫描整个列表来找到它的邻居。如果我们能将村庄按位置排序，那就简单多了。那时我们就能准确知道邻居的位置：它们就在某个村庄的左边和右边。
- en: 'For example, here are our sample villages in the order that we read them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是我们按顺序读取的示例村庄：
- en: 20 50 4 19 15 1
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 20 50 4 19 15 1
- en: 'That’s a mess! On a real street, they’d come in order of position, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这可真乱七八糟！在真实的街道上，它们会按位置顺序排列，如下所示：
- en: 1 4 15 19 20 50
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 1 4 15 19 20 50
- en: 'Want the neighbors of the village at position 4? Just look immediately to the
    left and immediately to the right: 1 and 15\. The neighbors of the village at
    15? Boom, they’re right there—4 and 19\. No more searching all over the place.
    We’ll sort the list of village positions to simplify our code.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 想要找到位置为 4 的村庄的邻居吗？只需查看它的左边和右边：分别是 1 和 15。位置为 15 的村庄邻居呢？嗖，邻居就在那儿——4 和 19。不再需要到处寻找了。我们将排序村庄位置列表，以简化代码。
- en: We can add to a list using the append method and sort a list using the sort
    method. We’ll learn these two methods, and a few others that you’ll likely find
    useful as you continue working with lists, and then we’ll come back to solve Village
    Neighborhood.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 append 方法向列表添加内容，使用 sort 方法对列表进行排序。我们将学习这两种方法，以及其他一些在继续处理列表时可能会发现有用的方法，然后我们将回过头来解决村庄邻里问题。
- en: Adding to a List
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向列表添加内容
- en: 'The append method *appends* to a list, which means that it adds a value to
    the end of the values already there. Here’s append adding three village positions
    to an initially empty list:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: append 方法会*附加*一个值到列表中，这意味着它会将一个值添加到已存在的值的末尾。下面是将三个村庄位置添加到一个最初为空的列表中的例子：
- en: '>>> positions = []'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = []'
- en: '>>> positions.append(20)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.append(20)'
- en: '>>> positions'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20]'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[20]'
- en: '>>> positions.append(50)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.append(50)'
- en: '>>> positions'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20, 50]'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50]'
- en: '>>> positions.append(4)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.append(4)'
- en: '>>> positions'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20, 50, 4]'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50, 4]'
- en: Notice that we’re using append without using an assignment statement. The append
    method doesn’t return a list; it modifies an existing list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在使用 append 方法时没有使用赋值语句。append 方法不会返回一个新的列表；它会修改现有的列表。
- en: 'It’s a common error to use an assignment statement with a method that changes
    a list. Making this error results in the list being lost, like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用会更改列表的函数时，使用赋值语句是一个常见的错误。犯这个错误会导致列表丢失，如下所示：
- en: '>>> positions'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[20, 50, 4]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 50, 4]'
- en: '>>> positions = positions.append(19)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = positions.append(19)'
- en: '>>> positions'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: 'Nothing is there! Technically, positions now refers to a None value; you can
    see that using print:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 没有值！从技术上讲，`positions` 现在指向一个 `None` 值；你可以通过 `print` 来查看：
- en: '>>> print(positions)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(positions)'
- en: None
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: None
- en: The None value is used to convey that no information is available. That’s absolutely
    not expected here—we wanted our four village positions!—but we’ve lost the list
    through an errant assignment statement.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 值用于表示没有可用信息。在这里完全没有预期——我们希望得到四个村庄的位置！——但是我们通过一个错误的赋值语句丢失了列表。'
- en: If your list is disappearing or you’re getting error messages related to the
    None value, make sure you’re not using an assignment statement with a method that
    simply modifies a list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的列表消失了，或者遇到与 `None` 值相关的错误信息，请确保你没有在方法中使用赋值语句，这些方法只是修改列表内容。
- en: 'The extend method is related to append. You use extend whenever you’d like
    to concatenate a list (not a single value) to the end of an existing list. Here’s
    an example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法与 `append` 相关。每当你想把一个列表（而不是单个值）连接到现有列表的末尾时，就使用 `extend`。以下是一个示例：'
- en: '>>> lst1 = [1, 2, 3]'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1 = [1, 2, 3]'
- en: '>>> lst2 = [4, 5, 6]'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst2 = [4, 5, 6]'
- en: '>>> lst1.extend(lst2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1.extend(lst2)'
- en: '>>> lst1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst1'
- en: '[1, 2, 3, 4, 5, 6]'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6]'
- en: '>>> lst2'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst2'
- en: '[4, 5, 6]'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 6]'
- en: 'If you want to insert into a list at a position other than its end, you can
    use the insert method. It takes an index and a value and inserts the value at
    the index:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在列表的某个位置插入元素，可以使用 `insert` 方法。它接受一个索引和一个值，并将该值插入到指定的索引位置：
- en: '>>> lst = [10, 20, 30, 40]'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [10, 20, 30, 40]'
- en: '>>> lst.insert(1, 99)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.insert(1, 99)'
- en: '>>> lst'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[10, 99, 20, 30, 40]'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 99, 20, 30, 40]'
- en: Sorting a List
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序列表
- en: 'The sort method *sorts* a list, putting its values in order. If we call it
    with no arguments, it sorts from smallest to largest:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 方法*排序*列表，将其中的值按顺序排列。如果我们不传递任何参数，它会从最小值到最大值排序：'
- en: '>>> positions = [20, 50, 4, 19, 15, 1]'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = [20, 50, 4, 19, 15, 1]'
- en: '>>> positions.sort()'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.sort()'
- en: '>>> positions'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[1, 4, 15, 19, 20, 50]'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 4, 15, 19, 20, 50]'
- en: 'If we call it with a reverse argument of value True, it sorts from largest
    to smallest:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `reverse=True` 参数来调用它，它会从最大值排序到最小值：
- en: '>>> positions.sort(reverse=True)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions.sort(reverse=True)'
- en: '>>> positions'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions'
- en: '[50, 20, 19, 15, 4, 1]'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[50, 20, 19, 15, 4, 1]'
- en: 'The syntax that I’ve used, reverse=True, is new. Based on how we’ve called
    methods and functions to this point in the book, you might expect that True by
    itself would work. But no: sort requires the whole reverse=True to be there, for
    reasons I’ll explain in [Chapter 6](ch06.xhtml#ch06).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的语法 `reverse=True` 是新的。根据我们目前在书中的方法和函数调用方式，你可能会期望 `True` 自己工作。但不是这样：`sort`
    需要完整的 `reverse=True` 参数，原因我会在[第 6 章](ch06.xhtml#ch06)中解释。
- en: Removing Values from a List
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从列表中移除值
- en: The pop method removes a value by index. If no argument is provided, pop both
    removes and returns the rightmost value.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 方法通过索引移除值。如果没有提供参数，`pop` 会移除并返回最右侧的值。'
- en: '>>> lst = [50, 30, 81, 40]'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [50, 30, 81, 40]'
- en: '>>> lst.pop()'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.pop()'
- en: '40'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: 'We can pass the index of the value to remove as an argument to pop. Here, we
    remove and return the value at index 0:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将要移除值的索引作为参数传递给 `pop` 方法。这里，我们移除并返回索引为 0 的值：
- en: '>>> lst.pop(0)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.pop(0)'
- en: '50'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: 'Since pop returns something—unlike methods like append and sort—it makes sense
    to assign its return value to a variable:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pop` 会返回某个值——不同于像 `append` 和 `sort` 这样的函数——因此将其返回值赋给变量是有意义的：
- en: '>>> lst'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30, 81]'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81]'
- en: '>>> value = lst.pop()'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value = lst.pop()'
- en: '>>> value'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value'
- en: '81'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '81'
- en: '>>> lst'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30]'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[30]'
- en: 'The remove method removes by value, not index. Pass it the value to remove,
    and it removes the leftmost occurrence of that value from the list. If the value
    is not present, remove produces an error. In the following, there are two occurrences
    of 50 in the list, so remove(50) works twice before producing an error:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法通过值来移除，而不是通过索引。传递给它要移除的值，它会移除列表中最左侧出现的该值。如果该值不存在，`remove` 会产生错误。在以下示例中，列表中有两个
    50，因此 `remove(50)` 会执行两次，直到产生错误：'
- en: '>>> lst = [50, 30, 81, 40, 50]'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [50, 30, 81, 40, 50]'
- en: '>>> lst.remove(50)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.remove(50)'
- en: '>>> lst'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30, 81, 40, 50]'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81, 40, 50]'
- en: '>>> lst.remove(50)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.remove(50)'
- en: '>>> lst'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[30, 81, 40]'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[30, 81, 40]'
- en: '>>> lst.remove(50)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst.remove(50)'
- en: 'Traceback (most recent call last):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'ValueError: list.remove(x): x not in list'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: list.remove(x): x not in list'
- en: '**CONCEPT CHECK**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of lst after the following code runs?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行后，`lst` 的值是什么？
- en: lst = [2, 4, 6, 8]
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: lst = [2, 4, 6, 8]
- en: lst.remove(4)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: lst.remove(4)
- en: lst.pop(2)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: lst.pop(2)
- en: A. [2, 4]
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: A. [2, 4]
- en: B. [6, 8]
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: B. [6, 8]
- en: C. [2, 6]
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: C. [2, 6]
- en: D. [2, 8]
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: D. [2, 8]
- en: E. This code produces an error
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: E. 这段代码产生错误
- en: 'Answer: C. The remove call removes the value 4, leaving [2, 6, 8]. Now the
    pop call removes the value at index 2, which is value 8. That leaves a final list
    of [2, 6].'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that we’ve successfully read and sorted the village positions. Here’s
    what our list would look like at that point:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '>>> positions = [1, 4, 15, 19, 20, 50]'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '>>> positions'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 4, 15, 19, 20, 50]'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the size of the smallest neighborhood, we start by finding the size
    of the neighborhood for the village at index 1. (Notice that we don’t start at
    index 0: the village at index 0 is the leftmost one, and per the problem description,
    we can ignore it.) We can find that neighborhood size like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '>>> left = (positions[1] - positions[0]) / 2'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '>>> right = (positions[2] - positions[1]) / 2'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '>>> min_size = left + right'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '>>> min_size'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '7.0'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The left variable stores the size of the left part of the neighborhood, and
    right stores the size of the right part. We then add them up to obtain the total
    size of the neighborhood. We get a value of 7.0.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: That’s the value to beat. How do we know whether any other village has a smaller
    neighborhood? We can use a loop to process those other villages. If we find a
    neighborhood that’s smaller than our current smallest, we update our current smallest
    to that smaller size.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The code for our solution is in [Listing 5-1](ch05.xhtml#ch05ex01).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: ❶ positions = []
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(n):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: ❸ positions.append(int(input()))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ❹ positions.sort()
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: ❺ left = (positions[1] - positions[0]) / 2
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: right = (positions[2] - positions[1]) / 2
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: min_size = left + right
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '❻ for i in range(2, n - 1):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: size = left + right
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '❼ if size < min_size:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: min_size = size
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: print(min_size)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-1: Solving Village Neighborhood*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: We begin by reading n, the number of villages, from the input. We also set positions
    to refer to an empty list ❶.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Each iteration of the first range for loop ❷ is responsible for reading one
    village position and appending it to the positions list. It does that by using
    input to read the next village position, int to convert it to an integer, and
    the list method append to append that integer to the list ❸. That one line ❸ is
    equivalent to these three separate lines:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: position = input()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: position = int(position)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(position)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Having read the village positions, we next sort them in increasing order ❹.
    We then find the size of the neighborhood of the village at index 1, storing it
    using min_size ❺.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Next, in a second loop, we loop through each of the other villages whose neighborhood
    sizes we need to compute ❻. Those villages start at index 2 and end at index n
    - 2. (We don’t want to consider the village at index n - 1, because that’s the
    rightmost village.) We therefore use range with a first argument of 2 (thus starting
    at 2) and a second argument of n - 1 (thus ending at n - 2).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, we calculate the size of the current village’s neighborhood,
    exactly as we did for the first village. The size of the smallest neighborhood
    that we’ve found so far is referred to by min_size. Is the current village’s neighborhood
    smaller than our smallest so far? To answer that, we use an if statement ❼. If
    this village’s neighborhood is smaller than min_size, we update min_size to the
    size of this neighborhood. If this village’s neighborhood isn’t smaller than min_size,
    then we do nothing, because this village doesn’t change the size of the smallest
    neighborhood.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Having gone through all of the villages, min_size must be the size of the smallest
    neighborhood. We therefore output the value of min_size.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The “Output” section of this problem description specified “Include exactly
    one digit after the decimal point.” What if the smallest size was something like
    6.25 or 8.33333? Shouldn’t we do something about that?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'No. We’re safe with what we’ve done. The only neighborhood sizes we can get
    are numbers like 3.0 (with a 0 after the decimal point) and 3.5 (with a .5 after
    the decimal point). Here’s why. When we calculate the left part of a neighborhood,
    we subtract two integers and divide that resulting integer by 2\. If we have an
    even integer before dividing by 2, then dividing gives us a .0 number (no remainder).
    And if we have an odd integer before dividing by 2, then dividing gives us a .5
    number. The same goes for the right part of the neighborhood: the size will be
    a .0 number or a .5 number. Adding the left and right parts to get the total size
    is therefore guaranteed to give us another .0 or .5 number.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoiding Code Duplication: Two More Solutions'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a little disappointing that we’re including the “compute neighborhood size”
    code both prior to and in the second range for loop. In general, repeated code
    is a sign that we might be able to improve the code’s design. We’d like to avoid
    repeated code because it adds to the amount of code that we must maintain, and
    it makes it harder to fix problems in the code if it turns out that the repeated
    code is flawed. Here, the repeated code seems acceptable to me (it’s only three
    lines), but let’s talk about two ways to avoid it. These are general approaches
    that you’ll be able to apply to other similar problems.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Using a Huge Size
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The only reason we’re calculating the size of a village’s neighborhood before
    the loop is so that the loop has something to compare the other neighborhood sizes
    against. If we entered the loop without a value for min_size, we’d get an error
    when the code tries to compare it to the size of the current village.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: If we set min_size to 0.0 before the loop, then the loop will never find a smaller
    size, and we’ll incorrectly output 0.0 no matter the test case. Using 0.0 would
    be a bug!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: But a huge value, one at least as big as every possible neighborhood size, *will*
    work. We just need to make it so huge that the first iteration of the loop is
    guaranteed to find a size that’s no bigger, ensuring that our fake huge size never
    gets output.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: From the “Input” section of this problem description, we know that each position
    is between –1,000,000,000 and 1,000,000,000\. The biggest neighborhood we could
    ever have, then, occurs when we have a village at position –1,000,000,000, another
    at position 1,000,000,000, and a village somewhere in between. That in-between
    village will have a neighborhood size of 1,000,000,000\. We can therefore start
    min_size with a size of 1000000000.0 or greater. This alternate approach is in
    [Listing 5-2](ch05.xhtml#ch05ex02).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(int(input()))
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: positions.sort()
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: min_size = 1000000000.0
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for i in range(1, n - 1):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: size = left + right
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'if size < min_size:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: min_size = size
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: print(min_size)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-2: Solving Village Neighborhood with a huge value*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Careful! We need to start computing sizes at index 1 now ❶ (not 2); otherwise,
    we’d forget to include the neighborhood of the village at index 1.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Building a List of Sizes
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another way to avoid the code duplication is to store each neighborhood size
    in a list of sizes. Python has a built-in min function that takes a sequence and
    returns its minimum:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '>>> min(''qwerty'')'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '''e'''
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '>>> min([15.5, 7.0, 2.5, 7.5])'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '2.5'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: (Python also has a max function that returns the maximum of a sequence.)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 5-3](ch05.xhtml#ch05ex03) for a solution that uses min on a list
    of neighborhood sizes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(int(input()))
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: positions.sort()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: sizes = []
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, n - 1):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: size = left + right
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: sizes.append(size)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: min_size = min(sizes)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: print(min_size)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: Solving Village Neighborhood using* min'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to submit any of these solutions to the judge, whichever you like
    best!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 134](ch05.xhtml#ch05lev1sec18).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #12: School Trip'
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many problems you’ll encounter have input with multiple integers or floats per
    line. We’ve avoided these problems until now, but they are everywhere! We’ll now
    learn how we can use lists to process the input for these kinds of problems.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem ecoo17r1p1.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Students would like to go on a school trip at the end of the year, but they
    need money to pay for it. To raise money, they have organized a brunch. To attend
    the brunch, a student in their first year pays $12, a student in their second
    year pays $10, a student in their third year pays $7, and a student in their fourth
    year pays $5.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Of all of the money raised at the brunch, 50 percent of it can be used to pay
    for the school trip (the other 50 percent is used to pay for the brunch itself).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: We are told the cost of the school trip, the proportion of students in each
    year, and the total number of students. Determine whether the students need to
    raise more money for the school trip.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of 10 test cases, with three lines per test case (30 lines
    in all). Here are the three lines for each test case:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains the cost in dollars of the school trip; it’s an integer
    between 50 and 50,000.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains four numbers indicating the proportion of brunching
    students who are in first, second, third, and fourth year, respectively. There
    is a space between each pair of numbers. Each number is between 0 and 1, and their
    sum is 1 (for 100 percent).
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains integer *n*, the number of students attending the brunch.
    *n* is between 4 and 2,000.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For each test case: if the students need to raise more money for the school
    trip, output YES; otherwise, output NO.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: A Catch
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose that there are 50 students and that 10 percent of them (a proportion
    of 0.1) are in their fourth year. Then we can calculate that 50 * 0.1 = 5 students
    are in their fourth year.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose that there are 50 students, but that 15 percent of them (a proportion
    of 0.15) are in their fourth year. If we multiply, we get 50 * 0.15 = 7.5 students
    in their fourth year.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Having 7.5 students doesn’t make any sense, and I haven’t told you what we should
    do in such a case. The full problem description specifies that we are to round
    down—so we’d round down to 7 here. This could result in the sum of the students
    in first year, second year, third year, and fourth year not equaling the total
    number of students. For the students who are not accounted for, we are to add
    them to the year with the most students. It’s guaranteed that exactly one year
    will have the most students (there won’t be a tie between multiple years).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first solve the problem ignoring this catch. Then we’ll incorporate the
    catch to give us a full solution.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Splitting Strings and Joining Lists
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second line of each test case consists of four proportions, like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 0.2 0.08 0.4 0.32
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to extract those four numbers from a string for further processing.
    We’ll learn about the string split method for splitting a string into a list of
    its pieces. While we’re at it, we’ll also learn about the string join method,
    which lets us go the other way and collapse a list into a single string.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a String into a List
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember that the input function returns a string, no matter what the input
    looks like. If the input should be interpreted as an integer, we need to convert
    the string to an integer. If the input should be interpreted as a float, we need
    to convert the string to a float. And if the input should be interpreted as four
    floats? Well, then we had better split it up into individual floats before converting
    anything!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'The string split method splits a string into a list of its pieces. By default,
    split splits around spaces, which is exactly what we need for our four floats:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''0.2 0.08 0.4 0.32'''
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.split()'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'The split method returns a list of strings, at which point we can access each
    one independently. Here, I save the list that split returns and then access two
    of its values:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions = s.split()'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions[1]'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '''0.08'''
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions[2]'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '''0.4'''
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Data in the wild is often comma-separated rather than space-separated. Piece
    of cake: we can call split with an argument that tells it what to use as a separator:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '>>> info = ''Toronto,Ontario,Canada'''
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '>>> info.split('','')'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[''Toronto'', ''Ontario'', ''Canada'']'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Joining a List into a String
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To go the other way, from a list to a string rather than a string to a list,
    we can use the string join method. The string on which join is called is used
    as the separator between list values. Here are two examples:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = [''Toronto'', ''Ontario'', ''Canada'']'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '>>> '',''.join(lst)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '''Toronto,Ontario,Canada'''
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''**''.join(lst)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '''Toronto**Ontario**Canada'''
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, join can join the values in any sequence, not just in a list.
    Here’s an example of joining the characters from a string:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''*''.join(''abcd'')'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '''a*b*c*d'''
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Changing List Values
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we use split on a string of four pieces, we get a list of strings:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = ''0.2 0.08 0.4 0.32'''
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions = s.split()'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: In “Converting Between Strings and Integers” in [Chapter 1](ch01.xhtml#ch01),
    we learned that strings that look like numbers can’t be used in numerical calculations.
    So, we need to convert this list of strings to a list of floats.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert a string to a float using float, like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '>>> float(''45.6'')'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '45.6'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s just one float. How can we convert a whole list of strings to a list
    of floats? It’s awfully tempting to try to make that happen using the following
    loop:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for value in proportions:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '...     value = float(value)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: The logic is that this should go through each value in the list and convert
    it to a float.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, it doesn’t work. The list still refers to strings:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'What could be wrong? Is float not working? We can see that float is doing just
    fine by looking at the type of value after conversion:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for value in proportions:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '...     value = float(value)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '...     type(value)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: <class 'float'>
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: <class 'float'>
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: <class 'float'>
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: <class 'float'>
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Four floats! But the list obdurately remains one of strings.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s happening here is that we’re not changing the values referred to in
    the list. We’re changing what the variable value refers to, but that doesn’t change
    the fact that the list refers to the old string values. To actually change the
    values that the list references, we need to assign new values at the list’s indices.
    Here’s how to do it:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[''0.2'', ''0.08'', ''0.4'', ''0.32'']'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(proportions)):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '...     proportions[i] = float(proportions[i])'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '>>> proportions'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[0.2, 0.08, 0.4, 0.32]'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The range for loop loops through each index, and an assignment statement changes
    what’s referred to by that index.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Solving Most of the Problem
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re now in good shape to solve the problem minus the catch.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with an example to highlight what our code will have to do. Then
    we’ll move onto the code itself.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input for this problem consists of 10 test cases, but I’ll present only
    one here. If you type this test case from the keyboard, you’ll see the answer.
    But the program won’t terminate there, because it’s waiting for the next test
    case. If you use input redirection with this test case, you’ll again see the answer.
    But then you’ll get an EOFError. EOF stands for “end of file”; the error is caused
    by the program trying to read more input than is available. Once your code is
    working for one test case, you can try adding a few more to your input to make
    sure that those work, too. Once you have 10, your program should run to completion.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the test case I’d like to trace with you:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '504'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 0.2 0.08 0.4 0.32
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '125'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: The school trip costs $504, and there are 125 students who attend the brunch.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: To determine how much money is raised at the brunch, we calculate the money
    raised from each year of students. There are 125 * 0.2 = 25 students in their
    first year, and each of them pays $12 for the brunch. So, the first-year students
    raise 25 * 12 = 300 dollars. We can similarly calculate the money raised by the
    students in second, third, and fourth years. See [Table 5-1](ch05.xhtml#ch05tab01)
    for this work.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** School Trip Example'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '| **Year** | **Students in year** | **Cost per student** | **Money raised**
    |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
- en: '| First year | 25 | 12 | 300 |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
- en: '| Second year | 10 | 10 | 100 |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
- en: '| Third year | 50 | 7 | 350 |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
- en: '| Fourth year | 40 | 5 | 200 |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
- en: The money raised by each year of students is calculated by multiplying the number
    of students in that year by the cost per student in that year; see the rightmost
    column of the table. For the total money raised by all students, we can add the
    four numbers in this rightmost column. That gives us 300 + 100 + 350 + 200 = 950
    dollars. Only 50 percent of that can be used for the school trip. So we’re left
    with 950 / 2 = 475 dollars, not sufficient to pay for the $504 trip. The correct
    output is therefore YES, because more money must be raised.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This partial solution will correctly handle any input where multiplying a proportion
    by the number of students gives a whole number of students (such as the test case
    that we just did). See [Listing 5-4](ch05.xhtml#ch05ex04) for the code.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: ❶ YEAR_COSTS = [12, 10, 7, 5]
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for dataset in range(10):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: trip_cost = int(input())
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: ❸ proportions = input().split()
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: num_students = int(input())
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '❹ for i in range(len(proportions)):'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: proportions[i] = float(proportions[i])
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: ❺ students_per_year = []
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'for proportion in proportions:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: ❻ students = int(num_students * proportion)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: students_per_year.append(students)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: total_raised = 0
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '❼ for i in range(len(students_per_year)):'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '❽ if total_raised / 2 < trip_cost:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: print('YES')
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: print('NO')
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-4: Solving most of School Trip*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we use variable YEAR_COSTS to refer to a list of costs for attending
    the brunch: the cost for students in their first, second, third, and fourth year
    ❶. Once we’ve determined the number of students in each year, we’ll multiply by
    these values to determine the money raised. The costs never change, so we’ll never
    change what this variable refers to. For such “constant” variables, Python convention
    is to write their names in capital letters, as I’ve done here.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The input contains 10 test cases, so we loop 10 times ❷, once for each test
    case. The rest of the program is inside this loop, because we want to repeat everything
    10 times.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: For each test case, we read the three lines of input. The second line is the
    one that has the four proportions, so we use split to split it into a list of
    four strings ❸. We use a range for loop to convert each of those strings to a
    float ❹.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Using those proportions, our next task is to determine the number of students
    in each year. We begin with an empty list ❺. Then, for each proportion, we multiply
    the total number of students by that proportion ❻ and append it to the list. Notice
    at ❻ that I’m using int to guarantee that we’re appending only integers. When
    used on a float, int drops the fractional part by rounding toward 0.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the two lists that we need to calculate how much money has been
    raised. In students_per_year, we have a list of the number of students in each
    year, which looks something like this:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[25, 10, 50, 40]'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'And in YEAR_COSTS, we have the cost of brunch for students in each year:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[12, 10, 7, 5]'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Each value at index 0 in these lists tells us something about students in their
    first year, each value at index 1 tells us something about students in their second
    year, and so on. Such lists are called *parallel lists*, because they work in
    parallel to tell us more than each does alone.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: We use these two lists to calculate the total money raised, by multiplying each
    number of students by the corresponding cost per student and adding up all of
    these results ❼.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Has enough money been raised for the school trip? To find out, we use an if
    statement ❽. Half of the money raised by the brunch can be used for the school
    trip. If that amount is less than the cost of the school trip, then we need to
    raise more money (YES); otherwise, we don’t (NO).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we’ve written is very general. The only clue that there are four years
    of students is at ❶. If we wanted to solve a similar problem for a different number
    of years, all we’d have to do is change that line (and provide input with the
    expected number of proportions). This is the power of lists: they help us write
    flexible code that can accommodate changes to problems we are solving.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: How to Handle the Catch
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s see why our current program does the wrong thing for some test cases,
    and the Python features we’ll use to fix it.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s a test case that our current code gets wrong:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 0.7 0.1 0.1 0.1
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: This time, the school trip costs $50, and there are nine students that attend
    the brunch. For the number of students in their first year, our current program
    would calculate 9 * 0.7 = 6.3 and then round down to 6\. The fact that we have
    to round down is why we have to be careful with this test case. To see what our
    current program would do for all four years, see [Table 5-2](ch05.xhtml#ch05tab02).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** An Example Case from School Trip That Our Current Program Gets
    Wrong'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '| **Year** | **Students in year** | **Cost per student** | **Money raised**
    |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
- en: '| First year | 6 | 12 | 72 |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
- en: '| Second year | 0 | 10 | 0 |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
- en: '| Third year | 0 | 7 | 0 |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
- en: '| Fourth year | 0 | 5 | 0 |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
- en: In each year besides the first year, there are 0 students because 9 * 0.1 =
    0.9 rounds down to 0\. So it looks like all we raise is $72\. Half of $72 is $36,
    not sufficient to pay for the $50 school trip. Our current program outputs YES.
    We need to raise more money.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: . . . Or not. We’re supposed to have nine students here, not six! We’ve lost
    three students to rounding. The problem description specifies that we should add
    those students to the year with the most students, which in this case is the first
    year. If we do that, we see that we actually raise 9 * 12 = 108 dollars. Half
    of $108 is $54, so in fact we do *not* need to raise any more money for the $50
    school trip! The correct output is NO.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: More List Operations
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To fix our program, we need to do two things: figure out how many students
    were lost to rounding, and add those students to the year with the most students.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Summing a List
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To determine the number of students lost to rounding, we can add up the students
    in our students_per_year list and then subtract that from the total number of
    students. Python’s sum function takes a list and returns the sum of its values:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year = [6, 0, 0, 0]'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sum(students_per_year)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year = [25, 10, 50, 40]'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sum(students_per_year)'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '125'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Index of the Maximum
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python’s max function takes a sequence and returns its maximum value:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year = [6, 0, 0, 0]'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '>>> max(students_per_year)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year = [25, 10, 50, 40]'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '>>> max(students_per_year)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the index of the maximum, not the maximum itself, so that we can increase
    the number of students at that index. Given the maximum value, we can find its
    index using the index method. It returns the leftmost index where the provided
    value is found or generates an error if the value is not in the list at all:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year = [6, 0, 0, 0]'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year.index(6)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year.index(0)'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '>>> students_per_year.index(50)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: 50 is not in list'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be searching for a value that we know is in the list, so we won’t have
    to worry about getting an error.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re there! We can now update our partial solution to handle any valid test
    case. The new program is in [Listing 5-5](ch05.xhtml#ch05ex05).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: YEAR_COSTS = [12, 10, 7, 5]
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: trip_cost = int(input())
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: proportions = input().split()
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: num_students = int(input())
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(proportions)):'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: proportions[i] = float(proportions[i])
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: students_per_year = []
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'for proportion in proportions:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: students = int(num_students * proportion)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: students_per_year.append(students)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: ❶ counted = sum(students_per_year)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: uncounted = num_students - counted
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: most = max(students_per_year)
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: where = students_per_year.index(most)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: ❷ students_per_year[where] = students_per_year[where] + uncounted
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: total_raised = 0
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(students_per_year)):'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'if total_raised / 2 < trip_cost:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: print('YES')
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: print('NO')
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Solving School Trip*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: The only new code is the five lines starting at ❶. We use sum to calculate how
    many students we’ve counted so far and then subtract this from the total number
    of students to arrive at the number of uncounted students. We then use max and
    index to identify the index of the year to which we should add the uncounted students.
    Finally, we add the uncounted students to this index ❷. (Adding 0 to a number
    doesn’t change that number, so don’t worry about coding special behavior for when
    uncounted is 0. This code is safe in that case.)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for this problem. Go ahead and submit to the judge! And then come
    back—we’re about to explore even more general list structures.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 5 from “Chapter Exercises”
    on [page 134](ch05.xhtml#ch05lev1sec18).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #13: Baker Bonus'
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll see how lists help us work with two-dimensional data.
    This kind of data arises often in real-world programs. For example, data in the
    form of a spreadsheet consists of rows and columns; processing such data requires
    techniques like those we’re about to learn.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem ecoo17r3p1.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Baker Brie has a number of franchisees, each of which sells baked goods to
    consumers. Having reached the milestone of being in business for 13 years, Baker
    Brie will celebrate by awarding bonuses based on sales. The bonuses depend on
    sales per day and sales per franchisee. Here’s how the bonuses work:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: For every day on which the total sales across all franchisees is a multiple
    of 13, that multiple will be given as bonuses. For example, a day where the franchisees
    sold a combined 26 baked goods will add 26 / 13 = 2 bonuses to the total.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every franchisee whose total sales across all days is a multiple of 13,
    that multiple will be given as bonuses. For example, a franchisee that sold a
    total of 39 baked goods will add 39 / 13 = 3 bonuses to the total.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the total number of bonuses awarded.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the integer number of franchisees *f* and integer number of
    days *d*, separated by a space. *f* is between 4 and 130, and *d* is between 2
    and 4,745.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*d* lines, one per day, containing *f* integers separated by spaces. Each integer
    specifies a number of sales. The first of these lines gives the sales for each
    franchise on the first day, the second gives the sales for each franchise on the
    second day, and so on. Each integer is between 1 and 13,000.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For each test case, output the total number of bonuses awarded.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Representing a Table
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data for this problem can be visualized as a table. We’ll start with an
    example and then look at how to represent a table as a list.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we have *d* days and *f* franchisees, we can lay out the data as a table
    with *d* rows and *f* columns.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample test case:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 6 4
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 1 13 2 1 1 8
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 2 12 10 5 11 4
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 39 6 13 52 3 3
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 15 8 6 2 7 14
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: The table corresponding to this test case is in [Table 5-3](ch05.xhtml#ch05tab03).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** Baker Bonus Table'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | 13 | 2 | 1 | 1 | 8 |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| **1** | 2 | 12 | 10 | 5 | 11 | 4 |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| **2** | 39 | 6 | 13 | 52 | 3 | 3 |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
- en: '| **3** | 15 | 8 | 6 | 2 | 7 | 14 |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
- en: I’ve numbered the rows and columns starting at 0 to coincide with how we’ll
    shortly store this data in a list.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: How many bonuses are awarded in this test case? Let’s first look at the rows
    of the table, which correspond to days. The sum of the sales for row 0 is 1 +
    13 + 2 + 1 + 1 + 8 = 26\. As 26 is a multiple of 13, this row gives us 26 / 13
    = 2 bonuses. The sum of row 1 is 44\. That’s not a multiple of 13, so no bonuses
    there. The sum of row 2 is 116—again, no bonuses. The sum of row 3 is 52, which
    gives us 52 / 13 = 4 bonuses.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the columns, which correspond to franchisees. The sum of column
    0 is 1 + 2 + 39 + 15 = 57\. That’s not a multiple of 13, so no bonuses. In fact,
    the only column that gives us any bonuses is column 1\. Its sum is 39, giving
    us 39 / 13 = 3 bonuses.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: The total number of bonuses awarded is 2 + 4 + 3 = 9\. So, 9 is the correct
    output for this test case.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Nested Lists
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To this point, we’ve seen lists of integers, floats, and strings. We can also
    create lists of lists, called *nested lists*. Each value of such a list is itself
    a list. It’s common to use a variable name like grid or table to refer to a nested
    list. Here’s a Python list corresponding to [Table 5-3](ch05.xhtml#ch05tab03):'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid = [[ 1, 13,  2,  1,  1,  8],'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '...         [ 2, 12, 10,  5, 11,  4],'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '...         [39,  6, 13, 52,  3,  3],'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '...         [15,  8,  6,  2,  7, 14]]'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'Each list value corresponds to one row. If we index once, we get a row, which
    is itself a list:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid[0]'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 13, 2, 1, 1, 8]'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid[2]'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[39, 6, 13, 52, 3, 3]'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'If we index twice, we get a single value. Here’s the value in row 1, column
    2:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '>>> grid[1][2]'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with columns is a little trickier than working with rows, because each
    column is spread over multiple lists. To access a column, we need to aggregate
    one value from each row. We can do that with a loop, which incrementally builds
    a new list representing a column. Here, I obtain column 1:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '>>> column = []'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(grid)):'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: ❶ ...     column.append(grid[i][1])
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '>>> column'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[13, 12, 6, 8]'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the first index (the row) varies, but the second (the column) does
    not ❶. This picks out each value with the same column index.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'What about summing rows and columns? To sum a row, we can use the sum function.
    Here’s the sum of row 0:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sum(grid[0])'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a loop, like this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total = 0'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for value in grid[0]:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '...     total = total + value'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Using sum is the easier option, so we’ll use that.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum a column, we can build a column list and use sum on that, or we can
    calculate it directly without making a new list. Here’s the latter approach for
    column 1:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total = 0'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(len(grid)):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '...     total = total + grid[i][1]'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '>>> total'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: lst = [[1, 1],
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 3, 4]]'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(lst)):'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(len(lst[0])):'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: x = x + lst[i][j]
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: A. 2
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: B. 7
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: C. 11
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces an error (it uses an invalid index)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The variable i goes through the values 0 and 1 (because the length
    of lst is 2); the variable j also goes through the values 0 and 1 (because the
    length of lst[0] is 2). The values in the list that are summed are therefore those
    where each index is 0 or 1\. In particular, this does not include the 4 at lst[1][2].'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: The following code contains two print calls. What is the output?
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: lst = [[5, 10], [15, 20]]
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: x = lst[0]
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: x[0] = 99
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: print(lst)
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: lst = [[5, 10], [15, 20]]
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: y = lst[0]
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: y = y + [99]
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: print(lst)
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: A.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[[99, 10], [15, 20]]'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: B.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[[99, 10], [15, 20]]'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10, 99], [15, 20]]'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: C.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: D.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10], [15, 20]]'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 10, 99], [15, 20]]'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. x refers to the first row of lst; it’s another way to reference
    lst[0]. Therefore, when we do x[0] = 99, that change is also reflected when looking
    at the list through lst.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: Next, y also refers to the first row of lst. But then we assign a new list to
    y—and it’s that list, not the first row of lst, that has the 99 appended to it.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our code to solve this problem is in [Listing 5-6](ch05.xhtml#ch05ex06).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: ❶ lst = input().split()
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: franchisees = int(lst[0])
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: days = int(lst[1])
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: grid = []
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(days):'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: row = input().split()
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for j in range(franchisees):'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: row[j] = int(row[j])
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: ❹ grid.append(row)
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = 0
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '❺ for row in grid:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: ❻ total = sum(row)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'if total % 13 == 0:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = bonuses + total // 13
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '❼ for col_index in range(franchisees):'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '❽ for row_index in range(days):'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: total = total + grid[row_index][col_index]
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'if total % 13 == 0:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = bonuses + total // 13
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: print(bonuses)
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-6: Solving Baker Bonus*'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: As with School Trip, the input contains 10 test cases, so we place all of our
    code inside a loop that iterates 10 times.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: For each test case, we read the first line of input and call split to break
    it into a list ❶. That list will contain two values—the number of franchisees
    and the number of days—and we convert them to integers and assign them to appropriately
    named variables.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: The grid variable begins as an empty list. It will ultimately refer to a list
    of rows, where each row is a list of sales for a given day.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: We use a range for loop to loop once for each day ❷. We then read a row from
    the input and call split to split it into a list of individual sales values. These
    values are strings right now, so we use a nested loop to convert them all to integers
    ❸. Then, we add the row to our grid ❹.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now read the input and stored the grid. It’s time to add up the number
    of bonuses. We take that in two steps: first for the bonuses from the rows and
    second for the bonuses from the columns.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: To find the bonuses from the rows, we use a for loop on grid ❺. As with any
    for loop on a list, it gives us its values one at a time. Here, each value is
    a list, so row refers to a different list on each iteration. The sum function
    works on any list of numbers, so we use it here to add up the values in the current
    row ❻. If the sum is divisible by 13, then we add the number of bonuses.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: We can’t loop through columns of the list like we did rows, so we have to resort
    to looping through indices. We accomplish that by using a range for loop through
    the indices of the columns ❼. Using sum is not an option for summing the current
    column, so we’ll need a nested loop. That nested loop goes through the rows ❽,
    adding up each value in the desired column. We then check whether that total is
    divisible by 13 and add any bonuses if it is.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: We finish by printing the total number of bonuses.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Judge time! If you submit our code, you should see that all test cases pass.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about lists, which help us work with collections
    of whatever type we choose. Lists of numbers, lists of strings, lists of lists:
    Python supports whatever we need. We also learned about list methods and why sorting
    a list can make it easier to process the values in a list.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to strings, lists are mutable, which means that we can change their
    contents. This helps us more easily manipulate lists, but we must be careful to
    modify the list that we think we’re modifying.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: We’re at the point in our learning where we can write programs with many lines
    of code. We can direct what our programs do using if statements and loops. We
    can store and manipulate information using strings and lists. We can write programs
    to solve challenging problems. Such programs can become difficult to design and
    read. Fortunately, there’s a tool we can use to help us organize our programs
    to keep their complexity under control, and we’ll learn that tool in the next
    chapter. Working through some of the following exercises may deepen your appreciation
    of the difficulty in writing larger amounts of code. Then you’ll be ready to continue!
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem ccc07j3, Deal or No Deal Calculator
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci17c1p1, Cezar
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci18c2p1, Preokret
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc00s2, Babbling Brooks (Check out Python’s round function.)
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo18r1p1, Willow’s Wild Ride
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo19r1p1, Free Shirts
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc14c7p2, Tides
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem wac3p3, Wesley Plays DDR
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo18r1p2, Rue’s Rings (If you use f-strings here, you’ll need
    a way to include the { and } symbols themselves. You can include a { in the f-string
    by using {{ and a } by using }}.)
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci19c5p1, Emacs
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci20c2p1, Crtanje (You’ll need to support rows from –100 to
    100\. But how do we support negative-indexed rows when Python lists start at index
    0? Here’s a trick: use index x + 100 any time you need access to row x. That shifts
    the row numbers to be between 0 and 200 rather than between –100 and 100\. Also,
    one small annoyance here with strings: \ is a special character, so you’ll have
    to use ''\\'' rather than ''\'' if you want a \ character.)'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc19c5p2, Charlie’s Crazy Conquest (You’ll have to be careful
    with indices and the game rules for this one!)
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Village Neighborhood is originally from the 2018 Canadian Computing Competition,
    Senior Level. School Trip is originally from the 2017 Educational Computing Organization
    of Ontario Programming Contest, Round 1\. Baker Bonus is originally from the 2017
    Educational Computing Organization of Ontario Programming Contest, Round 3.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
