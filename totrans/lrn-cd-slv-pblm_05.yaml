- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: ORGANIZING VALUES USING LISTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表组织值
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: We’ve seen that we can use strings to work with a sequence of characters. In
    this chapter, we’ll learn about lists, which help us work with sequences of other
    types of values, such as integers and floats. We’ll also learn that we can nest
    lists inside of lists, which lets us work with grids of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，字符串可以用来处理字符序列。在本章中，我们将学习列表，它们帮助我们处理其他类型值的序列，如整数和浮点数。我们还将学习如何将列表嵌套在列表中，这使得我们可以处理数据的网格。
- en: 'We’ll solve three problems using lists: finding the smallest neighborhood of
    a collection of villages, determining whether sufficient money has been raised
    for a school trip, and calculating the number of bonuses offered by a bakery.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用列表来解决三个问题：找到一组村庄中最小邻里的大小，判断是否筹集到了足够的资金进行学校旅行，以及计算面包店提供的奖金数量。
- en: 'Problem #11: Village Neighborhood'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #11：村庄邻里'
- en: In this problem, we’re going to find the size of the smallest neighborhood of
    a collection of villages. We’ll find it helpful to store all of the neighborhood
    sizes. We might have as many as 100 villages, though, and using a separate variable
    for each village would be a nightmare. We’ll see that lists allow us to aggregate
    what would otherwise be separate variables into one collection. We’ll also learn
    about Python’s powerful list operations for modifying, searching, and sorting
    a list.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本问题中，我们将找到一组村庄中最小邻里的大小。我们会发现，存储所有邻里大小非常有用。不过，可能会有多达100个村庄，单独为每个村庄使用一个变量会很麻烦。我们将看到，列表允许我们将原本是分开的变量聚集到一个集合中。我们还将学习
    Python 强大的列表操作，用于修改、查找和排序列表。
- en: This is DMOJ problem `ccc18s1`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ccc18s1`。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: There are *n* villages located at distinct points on a straight road. Each village
    is represented by an integer that indicates its position on the road.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有 *n* 个村庄，位于一条直路上的不同位置。每个村庄用一个整数表示，表示它在路上的位置。
- en: A village’s left neighbor is the village with the next smallest position; a
    village’s right neighbor is the village with the next biggest position. The *neighborhood*
    of a village consists of half the space between that village and its left neighbor,
    plus half the space between that village and its right neighbor. For example,
    if there’s a village at position 10, with its left neighbor at position 6 and
    its right neighbor at position 15, then this village’s neighborhood starts from
    position 8 (halfway between 6 and 10) and ends at position 12.5 (halfway between
    10 and 15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个村庄的左邻居是位置最小的下一个村庄；一个村庄的右邻居是位置最大的下一个村庄。一个村庄的 *邻里* 包含该村庄与其左邻居之间空间的一半，加上该村庄与其右邻居之间空间的一半。例如，如果一个村庄位于位置
    10，左邻居在位置 6，右邻居在位置 15，那么这个村庄的邻里从位置 8（6 和 10 之间的中点）开始，到位置 12.5（10 和 15 之间的中点）结束。
- en: The leftmost and rightmost villages have only one neighbor, so the definition
    of a neighborhood doesn’t make sense for them. We’ll ignore the neighborhoods
    of those two villages in this problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最左边和最右边的村庄只有一个邻居，因此它们的邻里定义没有意义。在本问题中，我们将忽略这两个村庄的邻里。
- en: The *size* of a neighborhood is calculated as the neighborhood’s rightmost position
    minus the neighborhood’s leftmost position. For example, the neighborhood that
    goes from 8 to 12.5 has size 12.5 – 8 = 4.5.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 邻里的 *大小* 计算方法是：邻里的最右端位置减去邻里的最左端位置。例如，从 8 到 12.5 的邻里，大小为 12.5 – 8 = 4.5。
- en: Determine the size of the smallest neighborhood.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确定最小邻里的大小。
- en: Input
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing integer *n*, the number of villages. *n* is between 3 and
    100.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示村庄的数量。*n* 的值在 3 到 100 之间。
- en: '*n* lines, each of which gives the position of a village. Each position is
    an integer between –1,000,000,000 and 1,000,000,000\. The positions need not come
    in order from left to right; the neighbor of a village could be anywhere in these
    lines.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一个村庄的位置。每个位置是一个介于 -1,000,000,000 和 1,000,000,000 之间的整数。位置不必按从左到右的顺序给出；一个村庄的邻居可能出现在这些行中的任何位置。'
- en: Output
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the size of the smallest neighborhood. Include exactly one digit after
    the decimal point.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出最小邻里的大小。输出时保留一位小数。
- en: Why Lists?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择列表？
- en: As part of reading the input, we’ll need to read *n* integers (the integers
    that represent the positions of the villages). We dealt with this once already
    when solving Data Plan in [Chapter 3](ch03.xhtml#ch03). There, we used a range
    `for` loop to loop exactly *n* times. We’ll do that here, too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读取输入的一部分，我们需要读取 *n* 个整数（表示村庄位置的整数）。当我们在[第3章](ch03.xhtml#ch03)解决 Data Plan
    时，就已经处理过这个问题。在那里，我们使用了一个 `for` 循环，精确地循环了 *n* 次。在这里我们也会这样做。
- en: There’s one crucial difference between Data Plan and Village Neighborhood. In
    Data Plan, we read an integer, used it, and never referred to it again. We didn’t
    need to keep it around. But in Village Neighborhood, it’s not enough to see each
    integer just once. A village’s neighborhood depends on its left and right neighbors.
    Without access to those neighbors, we can’t calculate the size of the village’s
    neighborhood. We need to store all of the village positions for later use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Data Plan 和 Village Neighborhood 之间有一个关键的区别。在 Data Plan 中，我们读取一个整数，使用它，然后再也不引用它了。我们不需要将其保留。但在
    Village Neighborhood 中，单次看到每个整数是不够的。一个村庄的邻里关系取决于它的左邻和右邻。如果没有访问这些邻居，我们就无法计算该村庄的邻里大小。我们需要存储所有村庄的位置以备后用。
- en: 'For an example of why we need to store all of the village positions, consider
    this test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子说明为什么我们需要存储所有村庄位置，考虑这个测试案例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are six villages here. To find the size of a village’s neighborhood, we
    need that village’s left and right neighbors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有六个村庄。为了找出一个村庄的邻里大小，我们需要该村庄的左邻和右邻。
- en: The first village in the input is at position 20\. What’s the size of that village’s
    neighborhood? To answer that, we need access to all of the village positions so
    that we can find its left and right neighbors. Scanning through the positions,
    you can identify that the left neighbor is at position 19 and the right neighbor
    is at position 50\. The size of this village’s neighborhood is therefore (20 –
    19)/2 + (50 – 20)/2 = 15.5.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第一个村庄位于位置 20。那么该村庄的邻里大小是多少？为了回答这个问题，我们需要访问所有村庄的位置，以便找到它的左邻和右邻。通过扫描位置，你可以识别出左邻在位置
    19，右邻在位置 50。因此，该村庄的邻里大小为 (20 – 19)/2 + (50 – 20)/2 = 15.5。
- en: The second village in the input is at position 50\. What’s the size of that
    village’s neighborhood? Again, we need to look through the positions to figure
    it out. This village happens to be the rightmost one, so we ignore this village’s
    neighborhood.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第二个村庄位于位置 50。那么该村庄的邻里大小是多少呢？我们仍然需要查看位置来计算。这个村庄恰好是最右侧的村庄，因此我们忽略该村庄的邻里关系。
- en: The third village in the input is at position 4\. The left neighbor is at position
    1, and the right neighbor is at position 15, so the size of this village’s neighborhood
    is (4 – 1)/2 + (15 – 4)/2 = 7.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第三个村庄位于位置 4。左邻位于位置 1，右邻位于位置 15，所以该村庄的邻里大小为 (4 – 1)/2 + (15 – 4)/2 = 7。
- en: The fourth village in the input is at position 19\. The left neighbor is at
    position 15, and the right neighbor is at position 20, so the size of this village’s
    neighborhood is (19 – 15)/2 + (20 – 19)/2 = 2.5.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中的第四个村庄位于位置 19。左邻位于位置 15，右邻位于位置 20，所以该村庄的邻里大小为 (19 – 15)/2 + (20 – 19)/2 =
    2.5。
- en: The only remaining village that we need to consider is at position 15\. If you
    calculate its neighborhood size, you should get an answer of 7.5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下需要考虑的村庄位于位置 15。如果你计算它的邻里大小，你应该得到答案 7.5。
- en: Comparing all of the neighborhood sizes that we calculated, we see that the
    minimum—and the correct answer for this test case—is 2.5.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 比较我们计算的所有邻里大小，我们发现最小的邻里大小——也就是此测试案例的正确答案——是 2.5。
- en: We need a way to store all of the village positions so that we can find the
    neighbors of each village. A string won’t help, because strings store characters,
    not integers. Python lists to the rescue!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来存储所有的村庄位置，以便找到每个村庄的邻居。字符串不行，因为字符串只存储字符，而不存储整数。Python 列表来帮忙！
- en: Lists
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: A *list* is a Python type that stores a sequence of values. (You’ll sometimes
    see list values referred to as *elements*.) We use opening and closing square
    brackets to delimit the list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是一种 Python 类型，用于存储一系列值。（你有时会看到列表的值被称为 *元素*。）我们用开方括号和闭方括号来界定列表。'
- en: We can store only characters in strings, but we can store any type of value
    in lists. This list of integers holds the village positions from the prior section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在字符串中存储字符，但我们可以在列表中存储任何类型的值。这个整数列表包含了上一部分的村庄位置。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s a list of strings:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串列表：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can even create a list whose values are of different types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以创建一个值类型不同的列表：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Much of what you learned about strings applies to lists as well. For example,
    lists support the `+` operator for concatenation and the `*` operator for replication:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你对字符串的很多了解也适用于列表。例如，列表支持`+`操作符进行拼接，支持`*`操作符进行复制：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We even have the `in` operator, which tells us whether a value is in a list
    or not:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至有`in`操作符，它可以告诉我们一个值是否在列表中：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we have the `len` function to give us the length of a list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`len`函数来获取列表的长度：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A list is a sequence, and we can use a `for` loop to loop through its values:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个序列，我们可以使用`for`循环遍历它的值：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can make variables refer to lists, just as we make them refer to strings,
    integers, and floats. Let’s make two variables refer to lists and then concatenate
    them to produce a new list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使变量指向字符串、整数和浮动数一样让变量指向列表。让我们让两个变量指向列表，然后将它们拼接起来，生成一个新列表。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While we displayed the concatenated list, we did not store it, as we can see
    by looking at the lists again:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们展示了拼接后的列表，但我们并没有存储它，正如我们通过再次查看列表所看到的那样：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make a variable refer to the concatenated list, we use assignment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一个变量指向拼接后的列表，我们使用赋值：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Names like `lst`, `lst1`, and `lst2` can be used when there’s no need to be
    more specific about what a list contains.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要具体说明列表包含什么内容时，可以使用像`lst`、`lst1`和`lst2`这样的名称。
- en: 'But don’t use `list` itself as a variable name. It’s already a name that we
    can use to convert a sequence to a list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要使用`list`本身作为变量名。它已经是一个我们可以用来将序列转换为列表的名称：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you make a variable named `list`, you’ll lose this valuable behavior, and
    you’ll confuse readers who will expect `list` not to be tampered with.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个名为`list`的变量，你将失去这种有价值的行为，并且会让读者感到困惑，他们会期望`list`不被篡改。
- en: 'Finally, lists support indexing and slicing. Indexing returns a single value,
    and slicing returns a list of values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列表支持索引和切片。索引返回一个单一值，而切片返回一个值的列表：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we have a list of strings, we can access one of its string’s characters
    by indexing twice, first to select a string and then to select a character:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个字符串列表，我们可以通过两次索引来访问其中一个字符串的字符，第一次选择字符串，第二次选择字符：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**CONCEPT CHECK**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What does the following code store in the `total` variable?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会将什么存储到`total`变量中？
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A. The sum of the list
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: A. 列表的和
- en: B. The sum of the list, not including its first value
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: B. 列表的和，不包括其第一个值
- en: C. The sum of the list, not including its first and last values
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C. 列表的和，不包括其第一个和最后一个值
- en: D. This code causes an error because it accesses an invalid index of the list
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会报错，因为它访问了列表的一个无效索引
- en: E. None of the above
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: E. 以上都不是
- en: 'Answer: E. This code adds the numbers `1`, `2`, `3`, and so on, up to the length
    of the list. It doesn’t add numbers from the list or index the list at all!'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：E. 这段代码将`1`、`2`、`3`等数字加到列表的长度，直到列表的末尾。它并没有加列表中的数字，也没有索引列表！
- en: List Mutability
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的可变性
- en: Strings are *immutable*, which means they cannot be modified. When it looks
    like we’re changing a string (for example, using string concatenation), we’re
    really creating a new string, not modifying one that already exists.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是*不可变的*，这意味着它们不能被修改。当看起来我们在修改字符串时（例如，使用字符串拼接），我们实际上是在创建一个新字符串，而不是修改已经存在的字符串。
- en: Lists, on the other hand, are *mutable*, which means they *can* be modified.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，列表是*可变的*，这意味着它们*可以*被修改。
- en: 'We can observe this difference by using indexing. If we try to change a character
    of a string, we get an error:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用索引来观察这个区别。如果我们尝试改变一个字符串的字符，就会得到一个错误：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The error message says that strings don’t support item assignment, which just
    means that we can’t change their characters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息说字符串不支持项赋值，这意味着我们不能改变它们的字符。
- en: 'But because lists are mutable, we can change their values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于列表是可变的，我们可以改变它们的值：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Without a precise understanding of the assignment statement, mutability can
    lead to seemingly bewildering behavior. Here’s an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有对赋值语句的准确理解，可变性可能会导致看似令人困惑的行为。这里有一个例子：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'No surprises yet. But you might be surprised by this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有什么意外。但你可能会对这个感到惊讶：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How did the `99` get into `y` like that?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`99`是怎么进到`y`中的呢？'
- en: When we assign `x` to `y` ❶, `y` is set to refer to the same list as `x`. The
    assignment statement doesn’t copy the list. There’s only one list, and it happens
    to have two names (or *aliases*) that refer to it. So if we make a change to that
    list, we see that change whether we refer to the list by `x` or `y`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`x`赋值给`y` ❶时，`y`被设置为引用与`x`相同的列表。赋值语句并不会复制列表。实际上只有一个列表，它恰好有两个名称（或*别名*）指向它。所以，如果我们对该列表进行更改，无论是通过`x`还是`y`来引用它，我们都能看到这个更改。
- en: Mutability is useful because it directly models what we might want to do with
    the values in a list. If we want to change a value, we just change it. Without
    mutability, changing one value isn’t possible. We’d have to create a new list
    that was the same as the old list except for the value that we wanted to change.
    That would work, but it is a roundabout and less transparent way of changing a
    value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性很有用，因为它直接模拟了我们可能希望在列表中执行的操作。如果我们想更改一个值，我们只需修改它。如果没有可变性，修改一个值是不可能的。我们必须创建一个新的列表，内容与旧列表相同，除了我们希望更改的那个值。这样也是可行的，但它是一个迂回且不太透明的方式来改变一个值。
- en: 'If you really do want a copy of a list, not just another name for it, you can
    use slicing. Leave out both the start and end indices, which results in a copy
    of the entire list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想要一个列表的副本，而不仅仅是另一个名称，你可以使用切片。省略起始和结束索引，这样就会得到整个列表的副本：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Observe this time that the `y` list didn’t change when the `x` list changed.
    They’re separate lists.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这次请注意，当`x`列表改变时，`y`列表没有变化。它们是独立的列表。
- en: '**CONCEPT CHECK**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A. `3`
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: A. `3`
- en: B. `9`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: B. `9`
- en: C. `10`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C. `10`
- en: D. `4`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: D. `4`
- en: E. This code produces an error
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: E. 这段代码会产生一个错误
- en: 'Answer: A. Changing a list value is allowed (because lists are mutable). But
    changing the value at index 1 to a longer string doesn’t change the fact that
    the list has three values.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 改变列表的值是允许的（因为列表是可变的）。但是，将索引 1 处的值更改为更长的字符串，并不会改变列表有三个值这一事实。
- en: Learning About Methods
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习方法
- en: Like strings, lists have many useful methods. I’ll show you some of them in
    the next section, but first I’d like to show you how you can learn about methods
    on your own.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 像字符串一样，列表也有许多有用的方法。我将在下一节中展示一些它们，但首先我想教你如何自行学习方法。
- en: You can use Python’s `dir` function to get a list of methods for a particular
    type. Just call `dir` with a value as the argument, and you’ll get the methods
    for the type of that value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Python 的`dir`函数获取特定类型的方法列表。只需用一个值作为参数调用`dir`，你就会得到该值类型的所有方法。
- en: 'Here’s what we get when we call `dir` using a string value as the argument:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用字符串值作为参数调用`dir`时得到的结果：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we called `dir` with an empty string. We could have called `dir`
    with any string value; the empty string is just fastest to type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们用空字符串调用了`dir`。我们本可以用任何字符串值来调用`dir`；空字符串只是最快打出来的。
- en: Ignore the names at the top with underscores; those names are for Python’s internal
    use and not generally of interest to programmers. The rest of the names are string
    methods that you can call. In that list, you’ll find string methods that you already
    know, such as `isupper` and `count`, and many others that we haven’t come across
    yet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略顶部带有下划线的名称；这些名称是供 Python 内部使用的，一般对程序员没有兴趣。其余的名称是你可以调用的字符串方法。在那个列表中，你会发现一些你已经知道的字符串方法，比如`isupper`和`count`，以及我们尚未遇到的许多其他方法。
- en: 'To learn how to use a method, you can use the name of that method in a call
    to `help`. Here’s the help we get on the string `count` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用某个方法，你可以在`help`中调用该方法的名称。这是我们在字符串`count`方法上的帮助信息：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The help tells us how to call the method ❶.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助信息告诉我们如何调用该方法 ❶。
- en: Square brackets identify optional arguments. You would use `start` and `end`
    if you wanted to count the occurrences of `sub` within only a slice of the string.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示可选的参数。如果你只想在字符串的某一部分内统计`sub`的出现次数，可以使用`start`和`end`。
- en: It’s worth browsing the list of methods to check whether one is available to
    help with your current programming task. Even if you’ve used a method before,
    looking at the help can show you features that you didn’t know existed!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览方法列表是值得的，看看是否有方法可以帮助你完成当前的编程任务。即使你之前使用过某个方法，查看帮助也能让你发现你以前不知道的功能！
- en: To see which list methods are available, call `dir([])`. To learn about them,
    call `help([].`xxx), where xxx is the name of a list method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪些列表方法可用，请调用`dir([])`。要了解它们，可以调用`help([].xxx)`，其中xxx是列表方法的名称。
- en: '**CONCEPT CHECK**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'Here is the help for the string `center` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`center`方法的帮助文档：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What is the string produced by the following code?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成的字符串是什么？
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A. `'xxcavexx'`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: A. `'xxcavexx'`
- en: B. `' cave '`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: B. `' cave '`
- en: C. `'xxxxcavexxxx'`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: C. `'xxxxcavexxxx'`
- en: D. `' cave '`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: D. `' cave '`
- en: 'Answer: A. We’re calling `center` with a `width` of `8` and a `fillchar` of
    `''x''`. (Had we provided only one argument, a space would have been used for
    `fillchar`.) The resulting string will therefore be of length 8\. The string `''cave''`
    has four characters, so we need four more characters to get us to length 8\. Python
    therefore adds two spaces at the beginning and two spaces at the end to center
    the string.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 我们在调用`center`时，`width`是`8`，`fillchar`是`'x'`。（如果我们只提供一个参数，`fillchar`会使用空格。）因此，生成的字符串的长度将是8。字符串`'cave'`有四个字符，因此我们需要再加四个字符来达到长度8。所以Python会在字符串的开头和结尾各加两个空格，使得字符串居中。
- en: List Methods
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表方法
- en: Time to make progress on Village Neighborhood. I can think of two operations
    on a list that would help us solve it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该在村庄邻里问题上取得进展了。我能想到两个对列表进行操作的方式，这将有助于我们解决它。
- en: 'First, adding to a list. We’ll start off with no village positions and read
    them one at a time from the input. We therefore need a way to add each of these
    positions to a growing list: first the list will have nothing, and then it will
    have one village position in it, then two, and so on.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向列表添加元素。我们从没有任何村庄位置开始，然后一次从输入中读取一个村庄位置。因此，我们需要一种方法来将每个位置添加到一个增长的列表中：一开始列表什么都没有，然后它会有一个村庄位置，再然后两个，以此类推。
- en: 'Second, sorting a list. Once we’ve read in the village positions, we need to
    find the smallest neighborhood. This involves looking at each village position
    and the distance to its left and right neighbors. The village positions could
    come in any order, so in general it’s not easy to find the neighbors of a given
    village. Think back to the work we did in “Why Lists?” in this chapter. For each
    village, we had to scan the entire list to find its neighbors. It’d be so much
    easier if we had the villages ordered by position. Then we’d know exactly where
    the neighbors were: they’d be just to the left and just to the right of a village.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，排序一个列表。在读取完所有村庄位置后，我们需要找到最小的邻里。这涉及到查看每个村庄的位置以及它左右邻居的距离。村庄的位置可能是任意顺序，因此通常很难找到某个村庄的邻居。回想一下我们在本章“为什么使用列表？”中的工作。对于每个村庄，我们必须扫描整个列表来找出它的邻居。如果我们能够按位置对村庄进行排序，那就容易多了。那样我们就能确切知道邻居在哪里：它们将恰好位于村庄的左边和右边。
- en: 'For example, here are our sample villages in the order that we read them:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是我们按顺序读取的示例村庄：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That’s a mess! On a real street, they’d come in order of position, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这太乱了！在真实的街道上，它们会按位置顺序排列，像这样：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Want the neighbors of the village at position 4? Just look immediately to the
    left and immediately to the right: 1 and 15\. The neighbors of the village at
    15? Boom, they’re right there—4 and 19\. No more searching all over the place.
    We’ll sort the list of village positions to simplify our code.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道位置为4的村庄的邻居吗？只需查看它左边和右边的位置：1和15。位置为15的村庄的邻居呢？嗖，它们就在那儿——4和19。再也不需要到处找了。我们将排序村庄位置的列表，以简化代码。
- en: We can add to a list using the `append` method and sort a list using the `sort`
    method. We’ll learn these two methods, and a few others that you’ll likely find
    useful as you continue working with lists, and then we’ll come back to solve Village
    Neighborhood.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`append`方法向列表添加元素，并使用`sort`方法对列表进行排序。我们将学习这两种方法，以及其他一些你在继续处理列表时可能会觉得有用的方法，然后我们会回到村庄邻里问题上。
- en: Adding to a List
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向列表添加元素
- en: 'The `append` method *appends* to a list, which means that it adds a value to
    the end of the values already there. Here’s `append` adding three village positions
    to an initially empty list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`方法*追加*到一个列表中，这意味着它会将一个值添加到已经存在的值的末尾。下面是`append`向一个最初为空的列表添加三个村庄位置：'
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we’re using `append` without using an assignment statement. The
    `append` method doesn’t return a list; it modifies an existing list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在使用`append`时并没有使用赋值语句。`append`方法不会返回一个列表；它会修改现有的列表。
- en: 'It’s a common error to use an assignment statement with a method that changes
    a list. Making this error results in the list being lost, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法改变列表时使用赋值语句是一个常见的错误。犯这个错误会导致列表丢失，像这样：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nothing is there! Technically, `positions` now refers to a `None` value; you
    can see that using `print`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没有！从技术上讲，`positions`现在引用的是一个`None`值；你可以通过`print`查看到这一点：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `None` value is used to convey that no information is available. That’s
    absolutely not expected here—we wanted our four village positions!—but we’ve lost
    the list through an errant assignment statement.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 值用于表示没有可用的信息。这里绝对不应该是这种情况——我们希望得到四个村庄的位置！——但是由于一个错误的赋值语句，我们丢失了列表。'
- en: If your list is disappearing or you’re getting error messages related to the
    `None` value, make sure you’re not using an assignment statement with a method
    that simply modifies a list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的列表丢失了，或者你收到与 `None` 值相关的错误消息，确保你没有使用赋值语句与一个只修改列表的方法一起使用。
- en: 'The `extend` method is related to `append`. You use `extend` whenever you’d
    like to concatenate a list (not a single value) to the end of an existing list.
    Here’s an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法与 `append` 方法相关。当你想将一个列表（而不是单一的值）连接到现有列表的末尾时，可以使用 `extend`。这是一个示例：'
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to insert into a list at a position other than its end, you can
    use the `insert` method. It takes an index and a value and inserts the value at
    the index:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在列表中的某个位置插入元素，而不是插入到末尾，可以使用 `insert` 方法。它接受一个索引和一个值，并将该值插入到指定位置：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sorting a List
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序列表
- en: 'The `sort` method *sorts* a list, putting its values in order. If we call it
    with no arguments, it sorts from smallest to largest:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 方法 *排序* 一个列表，将其值按顺序排列。如果我们调用时不传递任何参数，它会按从小到大的顺序排序：'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we call it with a `reverse` argument of value `True`, it sorts from largest
    to smallest:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `reverse` 参数并将其设置为 `True`，它会从大到小排序：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The syntax that I’ve used, `reverse=True`, is new. Based on how we’ve called
    methods and functions to this point in the book, you might expect that `True`
    by itself would work. But no: `sort` requires the whole `reverse=True` to be there,
    for reasons I’ll explain in [Chapter 6](ch06.xhtml#ch06).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的语法，`reverse=True`，是新的。根据我们在本书中到目前为止调用方法和函数的方式，你可能会期待单独的 `True` 就能工作。但事实并非如此：`sort`
    需要完整的 `reverse=True` 参数，原因我将在[第6章](ch06.xhtml#ch06)中解释。
- en: Removing Values from a List
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从列表中移除值
- en: The `pop` method removes a value by index. If no argument is provided, `pop`
    both removes and returns the rightmost value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 方法通过索引移除一个值。如果没有提供参数，`pop` 会移除并返回最右边的值。'
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can pass the index of the value to remove as an argument to `pop`. Here,
    we remove and return the value at index `0`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将要移除的值的索引作为参数传递给 `pop` 方法。在这里，我们移除并返回索引为 `0` 的值：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since `pop` returns something—unlike methods like `append` and `sort`—it makes
    sense to assign its return value to a variable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pop` 会返回值——与 `append` 和 `sort` 等方法不同——将其返回值赋给一个变量是有意义的：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `remove` method removes by value, not index. Pass it the value to remove,
    and it removes the leftmost occurrence of that value from the list. If the value
    is not present, `remove` produces an error. In the following, there are two occurrences
    of `50` in the list, so `remove(50)` works twice before producing an error:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法通过值移除，而不是通过索引。传递给它一个值，它会移除该值在列表中的最左侧出现。如果值不存在，`remove` 会产生错误。如下所示，列表中有两个
    `50`，因此 `remove(50)` 会执行两次，直到产生错误：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**CONCEPT CHECK**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of `lst` after the following code runs?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码运行后，`lst` 的值是什么？
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A. `[2, 4]`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: A. `[2, 4]`
- en: B. `[6, 8]`
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: B. `[6, 8]`
- en: C. `[2, 6]`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C. `[2, 6]`
- en: D. `[2, 8]`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: D. `[2, 8]`
- en: E. This code produces an error
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: E. 这段代码会产生错误
- en: 'Answer: C. The `remove` call removes the value `4`, leaving `[2, 6, 8]`. Now
    the `pop` call removes the value at index `2`, which is value `8`. That leaves
    a final list of `[2, 6]`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C. `remove` 调用移除了值 `4`，剩下 `[2, 6, 8]`。现在 `pop` 调用移除了索引为 `2` 的值，即值 `8`。这留下了最终的列表
    `[2, 6]`。
- en: Solving the Problem
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: 'Suppose that we’ve successfully read and sorted the village positions. Here’s
    what our list would look like at that point:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功读取并排序了村庄位置。此时我们的列表将如下所示：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To find the size of the smallest neighborhood, we start by finding the size
    of the neighborhood for the village at index `1`. (Notice that we don’t start
    at index `0`: the village at index `0` is the leftmost one, and per the problem
    description, we can ignore it.) We can find that neighborhood size like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最小邻里的大小，我们首先要找到索引为 `1` 的村庄的邻里大小。（注意，我们没有从索引 `0` 开始：索引 `0` 处的村庄是最左边的，根据问题描述，我们可以忽略它。）我们可以这样找到该邻里的大小：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `left` variable stores the size of the left part of the neighborhood, and
    `right` stores the size of the right part. We then add them up to obtain the total
    size of the neighborhood. We get a value of `7.0`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`left` 变量存储邻里左侧部分的大小，而 `right` 存储右侧部分的大小。然后，我们将它们相加得到邻里的总大小。我们得到的值是 `7.0`。'
- en: That’s the value to beat. How do we know whether any other village has a smaller
    neighborhood? We can use a loop to process those other villages. If we find a
    neighborhood that’s smaller than our current smallest, we update our current smallest
    to that smaller size.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们需要超越的值。我们怎么知道其他村庄是否有更小的邻里呢？我们可以使用一个循环来处理这些其他村庄。如果我们找到一个比当前最小邻里还小的邻里，我们就将当前最小邻里更新为这个更小的大小。
- en: The code for our solution is in [Listing 5-1](ch05.xhtml#ch05ex01).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案的代码在[清单 5-1](ch05.xhtml#ch05ex01)中。
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 5-1: Solving Village Neighborhood*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：解决村庄邻里问题*'
- en: We begin by reading `n`, the number of villages, from the input. We also set
    `positions` to refer to an empty list ❶.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从输入中读取`n`，即村庄的数量。我们还将`positions`设置为空列表❶。
- en: 'Each iteration of the first range `for` loop ❷ is responsible for reading one
    village position and appending it to the `positions` list. It does that by using
    `input` to read the next village position, `int` to convert it to an integer,
    and the list method `append` to append that integer to the list ❸. That one line
    ❸ is equivalent to these three separate lines:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个范围`for`循环的每次迭代❷负责读取一个村庄的位置，并将其添加到`positions`列表中。它通过使用`input`读取下一个村庄的位置，使用`int`将其转换为整数，并使用列表方法`append`将该整数添加到列表❸。这一行代码❸等价于以下三行代码：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Having read the village positions, we next sort them in increasing order ❹.
    We then find the size of the neighborhood of the village at index `1`, storing
    it using `min_size` ❺.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取了村庄位置之后，我们接着按升序对它们进行排序❹。然后，我们找到索引为`1`的村庄的邻里大小，并使用`min_size`存储❺。
- en: Next, in a second loop, we loop through each of the other villages whose neighborhood
    sizes we need to compute ❻. Those villages start at index `2` and end at index
    `n - 2`. (We don’t want to consider the village at index `n - 1`, because that’s
    the rightmost village.) We therefore use `range` with a first argument of `2`
    (thus starting at `2`) and a second argument of `n - 1` (thus ending at `n - 2`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第二个循环中，我们遍历其他村庄，这些村庄的邻里大小需要计算❻。这些村庄的索引从`2`开始，到`n - 2`结束。（我们不想考虑索引为`n -
    1`的村庄，因为那是最右边的村庄。）因此，我们使用`range`，第一个参数为`2`（即从`2`开始），第二个参数为`n - 1`（即到`n - 2`结束）。
- en: Inside the loop, we calculate the size of the current village’s neighborhood,
    exactly as we did for the first village. The size of the smallest neighborhood
    that we’ve found so far is referred to by `min_size`. Is the current village’s
    neighborhood smaller than our smallest so far? To answer that, we use an `if`
    statement ❼. If this village’s neighborhood is smaller than `min_size`, we update
    `min_size` to the size of this neighborhood. If this village’s neighborhood isn’t
    smaller than `min_size`, then we do nothing, because this village doesn’t change
    the size of the smallest neighborhood.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们计算当前村庄邻里的大小，正如我们为第一个村庄所做的那样。到目前为止我们找到的最小邻里大小由`min_size`表示。当前村庄的邻里是否比我们找到的最小邻里更小？为了回答这个问题，我们使用`if`语句❼。如果当前村庄的邻里比`min_size`小，我们就将`min_size`更新为当前村庄的邻里大小。如果当前村庄的邻里不小于`min_size`，我们就什么也不做，因为这个村庄不会改变最小邻里的大小。
- en: Having gone through all of the villages, `min_size` must be the size of the
    smallest neighborhood. We therefore output the value of `min_size`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历完所有村庄后，`min_size`一定是最小的邻里大小。因此，我们输出`min_size`的值。
- en: The “Output” section of this problem description specified “Include exactly
    one digit after the decimal point.” What if the smallest size was something like
    6.25 or 8.33333? Shouldn’t we do something about that?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题描述的“输出”部分要求“保留小数点后正好一位数字”。如果最小的大小是像6.25或8.33333这样的数值呢？我们是不是应该对这个问题做些什么？
- en: 'No. We’re safe with what we’ve done. The only neighborhood sizes we can get
    are numbers like `3.0` (with a `0` after the decimal point) and `3.5` (with a
    `.5` after the decimal point). Here’s why. When we calculate the left part of
    a neighborhood, we subtract two integers and divide that resulting integer by
    2\. If we have an even integer before dividing by 2, then dividing gives us a
    `.0` number (no remainder). And if we have an odd integer before dividing by 2,
    then dividing gives us a `.5` number. The same goes for the right part of the
    neighborhood: the size will be a `.0` number or a `.5` number. Adding the left
    and right parts to get the total size is therefore guaranteed to give us another
    `.0` or `.5` number.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不，按照我们所做的已经很安全了。我们能获得的邻域大小只有类似`3.0`（小数点后有`0`）和`3.5`（小数点后有`.5`）这样的数字。原因如下。当我们计算邻域的左部分时，我们先减去两个整数，然后将得到的整数除以2。如果除以2之前是偶数，那么结果将是`.0`数（没有余数）。如果除以2之前是奇数，那么结果将是`.5`数。邻域的右部分也是如此：其大小要么是`.0`，要么是`.5`。因此，将左部分和右部分相加得到总大小，必然会得到一个`.0`或`.5`的数字。
- en: 'Avoiding Code Duplication: Two More Solutions'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免代码重复：另外两种解决方案
- en: It’s a little disappointing that we’re including the “compute neighborhood size”
    code both prior to and in the second range `for` loop. In general, repeated code
    is a sign that we might be able to improve the code’s design. We’d like to avoid
    repeated code because it adds to the amount of code that we must maintain, and
    it makes it harder to fix problems in the code if it turns out that the repeated
    code is flawed. Here, the repeated code seems acceptable to me (it’s only three
    lines), but let’s talk about two ways to avoid it. These are general approaches
    that you’ll be able to apply to other similar problems.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点令人失望的是，我们在第二个范围的`for`循环之前和其中都包含了“计算邻域大小”的代码。通常来说，重复的代码意味着我们有可能改善代码的设计。我们希望避免重复代码，因为它增加了我们需要维护的代码量，并且如果重复的代码存在缺陷，修复起来也更加困难。在这里，重复的代码我认为是可以接受的（只有三行），但我们可以讨论两种避免重复的方式。这些是你可以应用于其他类似问题的通用方法。
- en: Using a Huge Size
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用一个巨大值
- en: The only reason we’re calculating the size of a village’s neighborhood before
    the loop is so that the loop has something to compare the other neighborhood sizes
    against. If we entered the loop without a value for `min_size`, we’d get an error
    when the code tries to compare it to the size of the current village.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以在循环之前计算村庄邻域的大小，是为了让循环能够有一个值来与其他邻域大小进行比较。如果我们没有给`min_size`赋初值就进入循环，当代码尝试将其与当前村庄的大小进行比较时，就会出错。
- en: If we set `min_size` to `0.0` before the loop, then the loop will never find
    a smaller size, and we’ll incorrectly output `0.0` no matter the test case. Using
    `0.0` would be a bug!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在循环之前将`min_size`设置为`0.0`，那么循环将永远找不到更小的值，我们将错误地输出`0.0`，无论测试用例是什么。使用`0.0`会是一个错误！
- en: But a huge value, one at least as big as every possible neighborhood size, *will*
    work. We just need to make it so huge that the first iteration of the loop is
    guaranteed to find a size that’s no bigger, ensuring that our fake huge size never
    gets output.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一个非常大的值，至少大到能够覆盖所有可能的邻域大小，*是*可行的。我们只需要让它变得足够大，确保第一次循环时就能找到一个大小不再增大的值，保证我们的伪巨大值不会被输出。
- en: From the “Input” section of this problem description, we know that each position
    is between –1,000,000,000 and 1,000,000,000\. The biggest neighborhood we could
    ever have, then, occurs when we have a village at position –1,000,000,000, another
    at position 1,000,000,000, and a village somewhere in between. That in-between
    village will have a neighborhood size of 1,000,000,000\. We can therefore start
    `min_size` with a size of `1000000000.0` or greater. This alternate approach is
    in [Listing 5-2](ch05.xhtml#ch05ex02).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从问题描述中的“输入”部分我们知道，每个位置的范围在-1,000,000,000到1,000,000,000之间。那么我们能拥有的最大邻域就是当一个村庄位于-1,000,000,000，另一个村庄位于1,000,000,000，并且中间有一个村庄时。这个中间的村庄将拥有一个大小为1,000,000,000的邻域。因此，我们可以将`min_size`初始化为`1000000000.0`或更大的值。这个替代方法见[列表
    5-2](ch05.xhtml#ch05ex02)。
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 5-2: Solving Village Neighborhood with a huge value*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：用一个巨大值解决村庄邻域问题*'
- en: Careful! We need to start computing sizes at index `1` now ❶ (not `2`); otherwise,
    we’d forget to include the neighborhood of the village at index `1`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！现在我们需要从索引`1`开始计算大小❶（而不是从`2`）；否则，我们会忘记包括索引`1`处村庄的邻域。
- en: Building a List of Sizes
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建大小列表
- en: 'Another way to avoid the code duplication is to store each neighborhood size
    in a list of sizes. Python has a built-in `min` function that takes a sequence
    and returns its minimum:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个避免代码重复的方法是将每个邻里大小存储在一个大小列表中。Python 有一个内建的 `min` 函数，它可以接受一个序列并返回其中的最小值：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: (Python also has a `max` function that returns the maximum of a sequence.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: （Python 也有一个 `max` 函数，可以返回序列中的最大值。）
- en: See [Listing 5-3](ch05.xhtml#ch05ex03) for a solution that uses `min` on a list
    of neighborhood sizes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[清单 5-3](ch05.xhtml#ch05ex03)，它展示了如何在邻里大小列表上使用`min`。
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 5-3: Solving Village Neighborhood using* min'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：使用* min 解决村庄邻里问题'
- en: Feel free to submit any of these solutions to the judge, whichever you like
    best!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以提交这些解答给评审，任选你最喜欢的一个！
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 134](ch05.xhtml#ch05lev1sec18).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决“章节练习”中的第1题，见[第134页](ch05.xhtml#ch05lev1sec18)。
- en: 'Problem #12: School Trip'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #12：学校旅行'
- en: Many problems you’ll encounter have input with multiple integers or floats per
    line. We’ve avoided these problems until now, but they are everywhere! We’ll now
    learn how we can use lists to process the input for these kinds of problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 许多问题中，输入行会包含多个整数或浮动数字。到现在为止我们避免了这些问题，但它们随处可见！接下来我们将学习如何使用列表处理这类问题的输入。
- en: This is DMOJ problem `ecoo17r1p1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题`ecoo17r1p1`。
- en: The Challenge
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Students would like to go on a school trip at the end of the year, but they
    need money to pay for it. To raise money, they have organized a brunch. To attend
    the brunch, a student in their first year pays $12, a student in their second
    year pays $10, a student in their third year pays $7, and a student in their fourth
    year pays $5.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们希望在年底进行一次学校旅行，但他们需要资金来支付旅行费用。为了筹集资金，他们组织了一次早午餐活动。参加早午餐的学生，第一年级学生支付$12，第二年级学生支付$10，第三年级学生支付$7，第四年级学生支付$5。
- en: Of all of the money raised at the brunch, 50 percent of it can be used to pay
    for the school trip (the other 50 percent is used to pay for the brunch itself).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在早午餐筹集的所有资金中，50%的资金可以用来支付学校旅行的费用（剩下的50%用于支付早午餐本身的费用）。
- en: We are told the cost of the school trip, the proportion of students in each
    year, and the total number of students. Determine whether the students need to
    raise more money for the school trip.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道学校旅行的费用、每年级学生的比例，以及学生的总人数。确定学生们是否需要为学校旅行筹集更多的资金。
- en: Input
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of 10 test cases, with three lines per test case (30 lines
    in all). Here are the three lines for each test case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括10个测试用例，每个测试用例有三行（共30行）。以下是每个测试用例的三行：
- en: The first line contains the cost in dollars of the school trip; it’s an integer
    between 50 and 50,000.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含学校旅行的费用，单位是美元，整数范围在50到50,000之间。
- en: The second line contains four numbers indicating the proportion of brunching
    students who are in first, second, third, and fourth year, respectively. There
    is a space between each pair of numbers. Each number is between 0 and 1, and their
    sum is 1 (for 100 percent).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含四个数字，分别表示参加早午餐的学生在第一、第二、第三和第四年级的比例。每两个数字之间有一个空格。每个数字介于0和1之间，它们的和为1（即100%）。
- en: The third line contains integer *n*, the number of students attending the brunch.
    *n* is between 4 and 2,000.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行包含整数 *n*，表示参加早午餐的学生人数。*n* 介于4到2,000之间。
- en: Output
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'For each test case: if the students need to raise more money for the school
    trip, output `YES`; otherwise, output `NO`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例：如果学生们需要为学校旅行筹集更多的钱，输出`YES`；否则，输出`NO`。
- en: A Catch
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个陷阱
- en: Suppose that there are 50 students and that 10 percent of them (a proportion
    of 0.1) are in their fourth year. Then we can calculate that 50 * 0.1 = 5 students
    are in their fourth year.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有50名学生，其中10%（即0.1的比例）是四年级学生。然后我们可以计算出50 * 0.1 = 5名四年级学生。
- en: Now suppose that there are 50 students, but that 15 percent of them (a proportion
    of 0.15) are in their fourth year. If we multiply, we get 50 * 0.15 = 7.5 students
    in their fourth year.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有50名学生，其中15%（即0.15的比例）是四年级学生。如果我们相乘，得到50 * 0.15 = 7.5名四年级学生。
- en: Having 7.5 students doesn’t make any sense, and I haven’t told you what we should
    do in such a case. The full problem description specifies that we are to round
    down—so we’d round down to 7 here. This could result in the sum of the students
    in first year, second year, third year, and fourth year not equaling the total
    number of students. For the students who are not accounted for, we are to add
    them to the year with the most students. It’s guaranteed that exactly one year
    will have the most students (there won’t be a tie between multiple years).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有7.5个学生没有任何意义，而且我还没告诉你在这种情况下应该怎么做。完整的问题描述指出，我们需要将数字向下取整——所以这里我们需要将其取整到7。这样可能会导致一、二、三、四年级的学生总数与所有学生总数不符。对于没有被计算到的学生，我们需要将他们添加到学生最多的那一年级。可以保证，只有一个年级的学生数最多（不会出现多个年级平分的情况）。
- en: We’ll first solve the problem ignoring this catch. Then we’ll incorporate the
    catch to give us a full solution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解决问题时忽略这个限制条件，然后再将这个限制条件纳入进来，提供完整的解决方案。
- en: Splitting Strings and Joining Lists
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分字符串和连接列表
- en: 'The second line of each test case consists of four proportions, like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的第二行包含四个比例，像这样：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We need a way to extract those four numbers from a string for further processing.
    We’ll learn about the string `split` method for splitting a string into a list
    of its pieces. While we’re at it, we’ll also learn about the string `join` method,
    which lets us go the other way and collapse a list into a single string.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法，从字符串中提取出这四个数字以进行进一步处理。我们将学习字符串的`split`方法，来将一个字符串拆分为它的各个部分。同时，我们还将学习字符串的`join`方法，它让我们可以反过来，将一个列表合并成一个单一的字符串。
- en: Splitting a String into a List
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将字符串拆分为列表
- en: Remember that the `input` function returns a string, no matter what the input
    looks like. If the input should be interpreted as an integer, we need to convert
    the string to an integer. If the input should be interpreted as a float, we need
    to convert the string to a float. And if the input should be interpreted as four
    floats? Well, then we had better split it up into individual floats before converting
    anything!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，不管输入是什么样的，`input`函数总是返回一个字符串。如果输入应该被解释为整数，我们需要将字符串转换为整数。如果输入应该被解释为浮点数，我们需要将字符串转换为浮点数。如果输入应该被解释为四个浮点数？那么，在转换任何东西之前，我们最好先将它拆分成单独的浮点数！
- en: 'The string `split` method splits a string into a list of its pieces. By default,
    `split` splits around spaces, which is exactly what we need for our four floats:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的`split`方法将字符串拆分为它的各个部分。默认情况下，`split`会以空格为分隔符，这正好适用于我们的四个浮点数：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `split` method returns a list of strings, at which point we can access
    each one independently. Here, I save the list that `split` returns and then access
    two of its values:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`方法返回一个字符串列表，在此时我们可以独立访问其中的每个值：这里，我保存了`split`返回的列表，然后访问了其中的两个值：'
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Data in the wild is often comma-separated rather than space-separated. Piece
    of cake: we can call `split` with an argument that tells it what to use as a separator:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现实中的数据通常是以逗号分隔，而不是空格分隔。小菜一碟：我们可以传递一个参数给`split`，告诉它使用什么作为分隔符：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Joining a List into a String
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将列表连接成字符串
- en: 'To go the other way, from a list to a string rather than a string to a list,
    we can use the string `join` method. The string on which `join` is called is used
    as the separator between list values. Here are two examples:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现从列表到字符串的转换，而不是从字符串到列表，我们可以使用字符串的`join`方法。`join`方法调用的字符串将作为列表值之间的分隔符。以下是两个示例：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Technically, `join` can join the values in any sequence, not just in a list.
    Here’s an example of joining the characters from a string:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`join`可以连接任何序列中的值，不仅仅是列表。这是一个连接字符串中字符的示例：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Changing List Values
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列表值
- en: 'When we use `split` on a string of four pieces, we get a list of strings:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对一个由四个部分组成的字符串使用`split`时，我们会得到一个字符串列表：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In “Converting Between Strings and Integers” in [Chapter 1](ch01.xhtml#ch01),
    we learned that strings that look like numbers can’t be used in numerical calculations.
    So, we need to convert this list of strings to a list of floats.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)的《字符串与整数之间的转换》中，我们了解到，看起来像数字的字符串不能用于数值计算。因此，我们需要将这个字符串列表转换为浮点数列表。
- en: 'We can convert a string to a float using `float`, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`float`将字符串转换为浮点数，像这样：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That’s just one float. How can we convert a whole list of strings to a list
    of floats? It’s awfully tempting to try to make that happen using the following
    loop:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一个浮点数。我们如何将整个字符串列表转换为浮点数列表呢？很容易诱惑我们通过以下循环来实现：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The logic is that this should go through each value in the list and convert
    it to a float.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是，程序应该遍历列表中的每个值并将其转换为浮点数。
- en: 'Sadly, it doesn’t work. The list still refers to strings:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，它没有奏效。列表仍然指向字符串：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What could be wrong? Is `float` not working? We can see that `float` is doing
    just fine by looking at the type of `value` after conversion:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可能哪里出了问题？`float`没有起作用吗？我们可以通过查看转换后`value`的类型来确认`float`正常工作：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Four floats! But the list obdurately remains one of strings.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 四个浮点数！但列表顽固地保持字符串形式。
- en: 'What’s happening here is that we’re not changing the values referred to in
    the list. We’re changing what the variable `value` refers to, but that doesn’t
    change the fact that the list refers to the old string values. To actually change
    the values that the list references, we need to assign new values at the list’s
    indices. Here’s how to do it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，我们并没有改变列表中所指向的值。我们改变了变量`value`所指向的内容，但这并没有改变列表仍然指向原来的字符串值。要真正改变列表引用的值，我们需要在列表的索引位置赋予新值。下面是如何做的：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The range `for` loop loops through each index, and an assignment statement changes
    what’s referred to by that index.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环遍历每个索引，并通过赋值语句修改该索引所指向的值。'
- en: Solving Most of the Problem
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决大部分问题
- en: We’re now in good shape to solve the problem minus the catch.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好解决问题，只剩下那个特殊情况。
- en: We’ll start with an example to highlight what our code will have to do. Then
    we’ll move onto the code itself.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个示例开始，突出我们代码需要做的事情。然后我们会进入代码本身。
- en: Exploring a Test Case
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: The input for this problem consists of 10 test cases, but I’ll present only
    one here. If you type this test case from the keyboard, you’ll see the answer.
    But the program won’t terminate there, because it’s waiting for the next test
    case. If you use input redirection with this test case, you’ll again see the answer.
    But then you’ll get an `EOFError`. EOF stands for “end of file”; the error is
    caused by the program trying to read more input than is available. Once your code
    is working for one test case, you can try adding a few more to your input to make
    sure that those work, too. Once you have 10, your program should run to completion.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的输入包括 10 个测试用例，但我这里只展示一个。如果你从键盘输入这个测试用例，你将看到答案。但程序不会在这里终止，因为它在等待下一个测试用例。如果你使用输入重定向来处理这个测试用例，你仍然会看到答案。但接下来你会遇到一个`EOFError`。EOF代表“文件结束”；该错误是因为程序试图读取更多输入，而可用的输入已经用尽。一旦你的代码在一个测试用例中正常工作，你可以尝试在输入中添加更多测试用例，以确保它们也能正常工作。当你有了
    10 个测试用例后，程序应该能运行到完成。
- en: 'Here’s the test case I’d like to trace with you:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想要和你一起追踪的测试用例：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The school trip costs $504, and there are 125 students who attend the brunch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 学校旅行的费用是 504 美元，共有 125 名学生参加早午餐。
- en: To determine how much money is raised at the brunch, we calculate the money
    raised from each year of students. There are 125 * 0.2 = 25 students in their
    first year, and each of them pays $12 for the brunch. So, the first-year students
    raise 25 * 12 = 300 dollars. We can similarly calculate the money raised by the
    students in second, third, and fourth years. See [Table 5-1](ch05.xhtml#ch05tab01)
    for this work.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算早午餐筹集的资金，我们计算每年学生筹集的资金。第一年有 125 * 0.2 = 25 名学生参加，每个学生支付 12 美元。所以，第一年学生筹集了
    25 * 12 = 300 美元。我们可以同样计算第二、三、四年学生筹集的资金。有关这部分的更多内容，请参见[表 5-1](ch05.xhtml#ch05tab01)。
- en: '**Table 5-1:** School Trip Example'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1:** 学校旅行示例'
- en: '| **Year** | **Students in year** | **Cost per student** | **Money raised**
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **学年** | **该学年的学生数** | **每个学生的费用** | **筹集的资金** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| First year | 25 | 12 | 300 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 第一学年 | 25 | 12 | 300 |'
- en: '| Second year | 10 | 10 | 100 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 第二学年 | 10 | 10 | 100 |'
- en: '| Third year | 50 | 7 | 350 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 第三学年 | 50 | 7 | 350 |'
- en: '| Fourth year | 40 | 5 | 200 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 第四学年 | 40 | 5 | 200 |'
- en: The money raised by each year of students is calculated by multiplying the number
    of students in that year by the cost per student in that year; see the rightmost
    column of the table. For the total money raised by all students, we can add the
    four numbers in this rightmost column. That gives us 300 + 100 + 350 + 200 = 950
    dollars. Only 50 percent of that can be used for the school trip. So we’re left
    with 950 / 2 = 475 dollars, not sufficient to pay for the $504 trip. The correct
    output is therefore `YES`, because more money must be raised.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每年学生所筹集的资金通过将该年学生人数乘以该年每个学生的费用来计算；请参见表格最右列。对于所有学生筹集的总资金，我们可以将最右列中的四个数字相加。这样得到300
    + 100 + 350 + 200 = 950美元。只有50%的资金可以用于学校旅行。所以剩下的950 / 2 = 475美元，仍然不足以支付504美元的旅行费用。因此，正确的输出是`YES`，因为还需要筹集更多的钱。
- en: The Code
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: This partial solution will correctly handle any input where multiplying a proportion
    by the number of students gives a whole number of students (such as the test case
    that we just did). See [Listing 5-4](ch05.xhtml#ch05ex04) for the code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分解决方案将正确处理任何输入，其中将比例乘以学生人数得到一个整数学生人数（例如我们刚才做的测试用例）。请参见[清单 5-4](ch05.xhtml#ch05ex04)以获取代码。
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 5-4: Solving most of School Trip*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：解决大部分学校旅行问题*'
- en: 'To begin, we use variable `YEAR_COSTS` to refer to a list of costs for attending
    the brunch: the cost for students in their first, second, third, and fourth year
    ❶. Once we’ve determined the number of students in each year, we’ll multiply by
    these values to determine the money raised. The costs never change, so we’ll never
    change what this variable refers to. For such “constant” variables, Python convention
    is to write their names in capital letters, as I’ve done here.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用变量`YEAR_COSTS`来表示参加早午餐的费用列表：包括第一、第二、第三和第四年学生的费用 ❶。一旦我们确定了每年学生的人数，就会将这些人数乘以这些费用值来计算筹集到的资金。费用是固定不变的，因此我们永远不会改变该变量指代的内容。对于这样的“常量”变量，Python
    的约定是将其名称写成大写字母，正如我在这里所做的那样。
- en: The input contains 10 test cases, so we loop 10 times ❷, once for each test
    case. The rest of the program is inside this loop, because we want to repeat everything
    10 times.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含10个测试用例，因此我们循环10次 ❷，每次处理一个测试用例。程序的其余部分在这个循环内，因为我们希望重复执行10次。
- en: For each test case, we read the three lines of input. The second line is the
    one that has the four proportions, so we use `split` to split it into a list of
    four strings ❸. We use a range `for` loop to convert each of those strings to
    a float ❹.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，我们读取三行输入。第二行是包含四个比例的那一行，因此我们使用`split`将其拆分为四个字符串的列表 ❸。然后，我们使用`for`循环遍历范围，将每个字符串转换为浮点数
    ❹。
- en: Using those proportions, our next task is to determine the number of students
    in each year. We begin with an empty list ❺. Then, for each proportion, we multiply
    the total number of students by that proportion ❻ and append it to the list. Notice
    at ❻ that I’m using `int` to guarantee that we’re appending only integers. When
    used on a float, `int` drops the fractional part by rounding toward 0.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些比例，我们的下一个任务是确定每年学生的人数。我们从一个空列表开始 ❺。然后，对于每个比例，我们将总学生人数乘以该比例 ❻，并将结果附加到列表中。注意在❻处，我使用了`int`来保证我们仅添加整数。`int`用于浮点数时，通过向0舍入来丢弃小数部分。
- en: 'Now we have the two lists that we need to calculate how much money has been
    raised. In `students_per_year`, we have a list of the number of students in each
    year, which looks something like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个列表，可以用来计算已筹集的资金。在`students_per_year`中，我们有一个每年学生人数的列表，大致如下所示：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And in `YEAR_COSTS`, we have the cost of brunch for students in each year:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 而在`YEAR_COSTS`中，我们有每年学生的早午餐费用：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Each value at index 0 in these lists tells us something about students in their
    first year, each value at index 1 tells us something about students in their second
    year, and so on. Such lists are called *parallel lists*, because they work in
    parallel to tell us more than each does alone.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表中索引为0的每个值告诉我们第一年学生的情况，索引为1的每个值告诉我们第二年学生的情况，依此类推。这样的列表被称为*平行列表*，因为它们并行工作，以告诉我们每个列表单独无法提供的信息。
- en: We use these two lists to calculate the total money raised, by multiplying each
    number of students by the corresponding cost per student and adding up all of
    these results ❼.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这两个列表来计算总筹款金额，通过将每个学生人数与相应的学生费用相乘，并将所有这些结果相加 ❼。
- en: Has enough money been raised for the school trip? To find out, we use an `if`
    statement ❽. Half of the money raised by the brunch can be used for the school
    trip. If that amount is less than the cost of the school trip, then we need to
    raise more money (`YES`); otherwise, we don’t (`NO`).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 是否筹集了足够的钱用于学校旅行？为了找出答案，我们使用`if`语句❽。早午餐筹集的一半钱可以用于学校旅行。如果这笔钱少于学校旅行的费用，那么我们需要筹集更多的钱（`YES`）；否则，我们不需要（`NO`）。
- en: 'The code we’ve written is very general. The only clue that there are four years
    of students is at ❶. If we wanted to solve a similar problem for a different number
    of years, all we’d have to do is change that line (and provide input with the
    expected number of proportions). This is the power of lists: they help us write
    flexible code that can accommodate changes to problems we are solving.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码非常通用。唯一能知道有四个年级学生的线索在❶。如果我们想为不同年数的问题解决类似的问题，我们所需要做的就是修改这一行（并提供期望比例的输入）。这就是列表的强大之处：它们帮助我们编写灵活的代码，能够适应我们正在解决问题的变化。
- en: How to Handle the Catch
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何处理捕获
- en: Now let’s see why our current program does the wrong thing for some test cases,
    and the Python features we’ll use to fix it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看为什么我们当前的程序在一些测试用例中会做出错误的处理，以及我们将使用哪些Python功能来修复它。
- en: Exploring a Test Case
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: 'Here’s a test case that our current code gets wrong:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们当前代码错误处理的一个测试用例：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This time, the school trip costs $50, and there are nine students that attend
    the brunch. For the number of students in their first year, our current program
    would calculate 9 * 0.7 = 6.3 and then round down to 6\. The fact that we have
    to round down is why we have to be careful with this test case. To see what our
    current program would do for all four years, see [Table 5-2](ch05.xhtml#ch05tab02).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，学校旅行的费用是50美元，九个学生参加了早午餐。对于第一年的学生人数，我们当前的程序会计算9 * 0.7 = 6.3，然后向下四舍五入为6。必须向下四舍五入是我们需要小心这个测试用例的原因。要查看我们当前的程序在四个年级的表现，请参见[表5-2](ch05.xhtml#ch05tab02)。
- en: '**Table 5-2:** An Example Case from School Trip That Our Current Program Gets
    Wrong'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-2：** 当前程序处理错误的学校旅行示例案例'
- en: '| **Year** | **Students in year** | **Cost per student** | **Money raised**
    |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **学年** | **该年学生人数** | **每个学生的费用** | **筹集的金额** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| First year | 6 | 12 | 72 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 第一学年 | 6 | 12 | 72 |'
- en: '| Second year | 0 | 10 | 0 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 第二学年 | 0 | 10 | 0 |'
- en: '| Third year | 0 | 7 | 0 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 第三年 | 0 | 7 | 0 |'
- en: '| Fourth year | 0 | 5 | 0 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 第四学年 | 0 | 5 | 0 |'
- en: In each year besides the first year, there are 0 students because 9 * 0.1 =
    0.9 rounds down to 0\. So it looks like all we raise is $72\. Half of $72 is $36,
    not sufficient to pay for the $50 school trip. Our current program outputs `YES`.
    We need to raise more money.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除第一年外，每年都没有学生，因为9 * 0.1 = 0.9向下四舍五入为0。所以看起来我们筹集的全部金额只有72美元。72美元的一半是36美元，无法支付50美元的学校旅行费用。我们当前的程序输出`YES`。我们需要筹集更多的钱。
- en: . . . Or not. We’re supposed to have nine students here, not six! We’ve lost
    three students to rounding. The problem description specifies that we should add
    those students to the year with the most students, which in this case is the first
    year. If we do that, we see that we actually raise 9 * 12 = 108 dollars. Half
    of $108 is $54, so in fact we do *not* need to raise any more money for the $50
    school trip! The correct output is `NO`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 或者不。我们应该有九个学生在这里，而不是六个！我们损失了三个学生，因为四舍五入。问题描述中指定我们应该将这些学生加入到学生最多的年级，而在本例中是第一年。如果我们这么做，我们会看到我们实际上筹集了9
    * 12 = 108美元。108美元的一半是54美元，因此实际上我们*不*需要再为50美元的学校旅行筹集更多的钱！正确的输出是`NO`。
- en: More List Operations
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多列表操作
- en: 'To fix our program, we need to do two things: figure out how many students
    were lost to rounding, and add those students to the year with the most students.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复我们的程序，我们需要做两件事：计算因四舍五入而丢失的学生人数，并将这些学生加到学生最多的年级。
- en: Summing a List
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 求和一个列表
- en: 'To determine the number of students lost to rounding, we can add up the students
    in our `students_per_year` list and then subtract that from the total number of
    students. Python’s `sum` function takes a list and returns the sum of its values:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定因四舍五入而丢失的学生人数，我们可以将`students_per_year`列表中的学生人数加起来，然后从总学生人数中减去这个值。Python的`sum`函数接收一个列表并返回其值的总和：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finding the Index of the Maximum
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找最大值的索引
- en: 'Python’s `max` function takes a sequence and returns its maximum value:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`max`函数接收一个序列并返回其最大值：
- en: '[PRE64]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We want the index of the maximum, not the maximum itself, so that we can increase
    the number of students at that index. Given the maximum value, we can find its
    index using the `index` method. It returns the leftmost index where the provided
    value is found or generates an error if the value is not in the list at all:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是最大值的索引，而不是最大值本身，这样我们才能增加该索引处的学生数量。给定最大值后，我们可以使用`index`方法找到它的索引。它返回提供值所在的最左边的索引，若值不在列表中，则会产生错误：
- en: '[PRE65]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We’ll be searching for a value that we know is in the list, so we won’t have
    to worry about getting an error.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将搜索一个我们知道在列表中的值，因此不需要担心出现错误。
- en: Solving the Problem
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re there! We can now update our partial solution to handle any valid test
    case. The new program is in [Listing 5-5](ch05.xhtml#ch05ex05).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到了！现在我们可以更新我们的部分解决方案，来处理任何有效的测试用例。新程序见[列表 5-5](ch05.xhtml#ch05ex05)。
- en: '[PRE66]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Listing 5-5: Solving School Trip*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：解决学校旅行问题*'
- en: The only new code is the five lines starting at ❶. We use `sum` to calculate
    how many students we’ve counted so far and then subtract this from the total number
    of students to arrive at the number of uncounted students. We then use `max` and
    `index` to identify the index of the year to which we should add the uncounted
    students. Finally, we add the uncounted students to this index ❷. (Adding `0`
    to a number doesn’t change that number, so don’t worry about coding special behavior
    for when `uncounted` is `0`. This code is safe in that case.)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新代码是从❶开始的五行。我们使用`sum`来计算迄今为止我们已经统计了多少学生，然后从总学生数中减去这一数值，得到未统计学生的数量。接着，我们使用`max`和`index`来识别应当添加未统计学生数量的年份索引。最后，我们将未统计的学生数添加到这个索引上❷。（将`0`加到一个数字上不会改变该数字，因此不必担心当`uncounted`为`0`时需要编写特殊的行为代码。这个代码在这种情况下是安全的。）
- en: That’s all for this problem. Go ahead and submit to the judge! And then come
    back—we’re about to explore even more general list structures.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个问题的全部内容。去提交给评审吧！然后再回来——我们即将探索更多一般的列表结构。
- en: Before continuing, you might like to try solving exercise 5 from “Chapter Exercises”
    on [page 134](ch05.xhtml#ch05lev1sec18).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决“章节练习”中第5题，见[第134页](ch05.xhtml#ch05lev1sec18)。
- en: 'Problem #13: Baker Bonus'
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #13：面包师奖金'
- en: In this problem, we’ll see how lists help us work with two-dimensional data.
    This kind of data arises often in real-world programs. For example, data in the
    form of a spreadsheet consists of rows and columns; processing such data requires
    techniques like those we’re about to learn.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将看到列表如何帮助我们处理二维数据。这种数据在实际的程序中经常出现。例如，电子表格中的数据由行和列组成；处理这样的数据需要像我们即将学习的技巧。
- en: This is DMOJ problem `ecoo17r3p1`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ecoo17r3p1`。
- en: The Challenge
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Baker Brie has a number of franchisees, each of which sells baked goods to
    consumers. Having reached the milestone of being in business for 13 years, Baker
    Brie will celebrate by awarding bonuses based on sales. The bonuses depend on
    sales per day and sales per franchisee. Here’s how the bonuses work:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 面包师布里有若干特许经营商，每个特许经营商将烘焙商品销售给消费者。布里已经达到了13年的营业里程碑，她将通过根据销售额发放奖金来庆祝。这些奖金取决于每天的销售额和每个特许经营商的销售额。奖金的分配方式如下：
- en: For every day on which the total sales across all franchisees is a multiple
    of 13, that multiple will be given as bonuses. For example, a day where the franchisees
    sold a combined 26 baked goods will add 26 / 13 = 2 bonuses to the total.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一天，如果所有特许经营商的总销售额是13的倍数，那么那个倍数将作为奖金发放。例如，一个特许经营商当天共售出了26件烘焙商品，那么他将获得26 /
    13 = 2个奖金。
- en: For every franchisee whose total sales across all days is a multiple of 13,
    that multiple will be given as bonuses. For example, a franchisee that sold a
    total of 39 baked goods will add 39 / 13 = 3 bonuses to the total.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个在所有天数中总销售额是13的倍数的特许经营商，那个倍数将作为奖金发放。例如，一个特许经营商总共售出了39件烘焙商品，则他将获得39 / 13 =
    3个奖金。
- en: Determine the total number of bonuses awarded.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 确定总共发放的奖金数。
- en: Input
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含10个测试用例。每个测试用例包含以下几行：
- en: A line containing the integer number of franchisees *f* and integer number of
    days *d*, separated by a space. *f* is between 4 and 130, and *d* is between 2
    and 4,745.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含特许经营商的整数数量*f*和天数*d*，它们之间由空格分隔。*f*的值在4到130之间，*d*的值在2到4,745之间。
- en: '*d* lines, one per day, containing *f* integers separated by spaces. Each integer
    specifies a number of sales. The first of these lines gives the sales for each
    franchise on the first day, the second gives the sales for each franchise on the
    second day, and so on. Each integer is between 1 and 13,000.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d* 行，每行包含 *f* 个由空格分隔的整数。每个整数表示一个销售量。这些行中的第一行给出了第一天每个加盟商的销售额，第二行给出了第二天的销售额，依此类推。每个整数在
    1 到 13,000 之间。'
- en: Output
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: For each test case, output the total number of bonuses awarded.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出奖励的奖金总数。
- en: Representing a Table
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格表示
- en: The data for this problem can be visualized as a table. We’ll start with an
    example and then look at how to represent a table as a list.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的数据可以通过表格来表示。我们将从一个示例开始，然后看看如何将表格表示为一个列表。
- en: Exploring a Test Case
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: If we have *d* days and *f* franchisees, we can lay out the data as a table
    with *d* rows and *f* columns.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有 *d* 天数和 *f* 加盟商，我们可以将数据排成一个有 *d* 行和 *f* 列的表格。
- en: 'Here’s a sample test case:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例测试用例：
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The table corresponding to this test case is in [Table 5-3](ch05.xhtml#ch05tab03).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对应这个测试用例的表格在 [表 5-3](ch05.xhtml#ch05tab03) 中。
- en: '**Table 5-3:** Baker Bonus Table'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-3：** 烘焙商奖金表'
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** | **5** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | 1 | 13 | 2 | 1 | 1 | 8 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1 | 13 | 2 | 1 | 1 | 8 |'
- en: '| **1** | 2 | 12 | 10 | 5 | 11 | 4 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 2 | 12 | 10 | 5 | 11 | 4 |'
- en: '| **2** | 39 | 6 | 13 | 52 | 3 | 3 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 39 | 6 | 13 | 52 | 3 | 3 |'
- en: '| **3** | 15 | 8 | 6 | 2 | 7 | 14 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 15 | 8 | 6 | 2 | 7 | 14 |'
- en: I’ve numbered the rows and columns starting at 0 to coincide with how we’ll
    shortly store this data in a list.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经给行和列编号，从 0 开始，以便与我们稍后将数据存储到列表中的方式一致。
- en: How many bonuses are awarded in this test case? Let’s first look at the rows
    of the table, which correspond to days. The sum of the sales for row 0 is 1 +
    13 + 2 + 1 + 1 + 8 = 26\. As 26 is a multiple of 13, this row gives us 26 / 13
    = 2 bonuses. The sum of row 1 is 44\. That’s not a multiple of 13, so no bonuses
    there. The sum of row 2 is 116—again, no bonuses. The sum of row 3 is 52, which
    gives us 52 / 13 = 4 bonuses.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，奖励了多少奖金？首先，让我们看看表格的行，它们对应的是天数。第 0 行的销售总和是 1 + 13 + 2 + 1 + 1 + 8 =
    26\. 由于 26 是 13 的倍数，这一行给我们带来了 26 / 13 = 2 个奖金。第 1 行的总和是 44\. 这不是 13 的倍数，所以这一行没有奖金。第
    2 行的总和是 116——同样，没有奖金。第 3 行的总和是 52，给我们带来了 52 / 13 = 4 个奖金。
- en: Now let’s look at the columns, which correspond to franchisees. The sum of column
    0 is 1 + 2 + 39 + 15 = 57\. That’s not a multiple of 13, so no bonuses. In fact,
    the only column that gives us any bonuses is column 1\. Its sum is 39, giving
    us 39 / 13 = 3 bonuses.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下与加盟商对应的列。第 0 列的总和是 1 + 2 + 39 + 15 = 57\. 这不是 13 的倍数，所以没有奖金。实际上，唯一给我们带来奖金的列是第
    1 列。它的总和是 39，给我们带来了 39 / 13 = 3 个奖金。
- en: The total number of bonuses awarded is 2 + 4 + 3 = 9\. So, `9` is the correct
    output for this test case.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 奖金总数是 2 + 4 + 3 = 9\. 所以，`9` 是这个测试用例的正确输出。
- en: Nested Lists
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套列表
- en: 'To this point, we’ve seen lists of integers, floats, and strings. We can also
    create lists of lists, called *nested lists*. Each value of such a list is itself
    a list. It’s common to use a variable name like `grid` or `table` to refer to
    a nested list. Here’s a Python list corresponding to [Table 5-3](ch05.xhtml#ch05tab03):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了整数、浮点数和字符串的列表。我们还可以创建列表的列表，称为 *嵌套列表*。每个嵌套列表中的值本身就是一个列表。通常会使用类似
    `grid` 或 `table` 的变量名来表示一个嵌套列表。这里是一个对应于 [表 5-3](ch05.xhtml#ch05tab03) 的 Python
    列表：
- en: '[PRE68]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Each list value corresponds to one row. If we index once, we get a row, which
    is itself a list:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每个列表的值对应一行。如果我们索引一次，就能得到一行，它本身就是一个列表：
- en: '[PRE69]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we index twice, we get a single value. Here’s the value in row 1, column
    2:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们索引两次，就能得到一个单一的值。这里是第 1 行第 2 列的值：
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Working with columns is a little trickier than working with rows, because each
    column is spread over multiple lists. To access a column, we need to aggregate
    one value from each row. We can do that with a loop, which incrementally builds
    a new list representing a column. Here, I obtain column 1:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 处理列比处理行稍微复杂一些，因为每列的值分布在多个列表中。要访问一列，我们需要从每一行聚合一个值。我们可以通过一个循环来实现，它逐步构建出代表某一列的新列表。在这里，我获取了第
    1 列：
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice how the first index (the row) varies, but the second (the column) does
    not ❶. This picks out each value with the same column index.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个索引（行）在变化，而第二个索引（列）保持不变 ❶。这会选出每个值，其列索引相同。
- en: 'What about summing rows and columns? To sum a row, we can use the `sum` function.
    Here’s the sum of row 0:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何计算行和列的和呢？为了求一行的和，我们可以使用 `sum` 函数。这里是第 0 行的和：
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can also use a loop, like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用类似这样的循环：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using `sum` is the easier option, so we’ll use that.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sum` 是更简便的选项，因此我们将使用它。
- en: 'To sum a column, we can build a `column` list and use `sum` on that, or we
    can calculate it directly without making a new list. Here’s the latter approach
    for column 1:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一列的和，我们可以构建一个 `column` 列表并对其使用 `sum`，或者我们可以直接计算而不创建新的列表。下面是对第 1 列的后者方法：
- en: '[PRE74]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**CONCEPT CHECK**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE75]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: A. `2`
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: A. `2`
- en: B. `7`
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: B. `7`
- en: C. `11`
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: C. `11`
- en: D. This code produces an error (it uses an invalid index)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会产生错误（使用了无效的索引）
- en: 'Answer: B. The variable `i` goes through the values 0 and 1 (because the length
    of `lst` is 2); the variable `j` also goes through the values 0 and 1 (because
    the length of `lst[0]` is 2). The values in the list that are summed are therefore
    those where each index is 0 or 1\. In particular, this does not include the `4`
    at `lst[1][2]`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 变量 `i` 遍历值 0 和 1（因为 `lst` 的长度是 2）；变量 `j` 也遍历值 0 和 1（因为 `lst[0]` 的长度是 2）。因此，列表中求和的值是那些索引为
    0 或 1 的项，特别是这不包括位于 `lst[1][2]` 的 `4`。
- en: '**CONCEPT CHECK**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: The following code contains two `print` calls. What is the output?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含两个 `print` 调用。输出是什么？
- en: '[PRE76]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: '[[99, 10], [15, 20]]'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[[99, 10], [15, 20]]'
- en: '[[5, 10], [15, 20]]'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 10], [15, 20]]'
- en: B.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: '[[99, 10], [15, 20]]'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[[99, 10], [15, 20]]'
- en: '[[5, 10, 99], [15, 20]]'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 10, 99], [15, 20]]'
- en: C.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: '[[5, 10], [15, 20]]'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 10], [15, 20]]'
- en: '[[5, 10], [15, 20]]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 10], [15, 20]]'
- en: D.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: D.
- en: '[[5, 10], [15, 20]]'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 10], [15, 20]]'
- en: '[[5, 10, 99], [15, 20]]'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 10, 99], [15, 20]]'
- en: 'Answer: A. `x` refers to the first row of `lst`; it’s another way to reference
    `lst[0]`. Therefore, when we do `x[0] = 99`, that change is also reflected when
    looking at the list through `lst`.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. `x` 指的是 `lst` 的第一行；它是引用 `lst[0]` 的另一种方式。因此，当我们执行 `x[0] = 99` 时，这一改变也会反映在通过
    `lst` 查看列表时。
- en: Next, `y` also refers to the first row of `lst`. But then we assign a new list
    to `y`—and it’s that list, not the first row of `lst`, that has the `99` appended
    to it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`y` 也指向 `lst` 的第一行。但然后我们将一个新列表赋值给 `y`——而是那个列表，而不是 `lst` 的第一行，才会在末尾附加 `99`。
- en: Solving the Problem
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Our code to solve this problem is in [Listing 5-6](ch05.xhtml#ch05ex06).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决此问题的代码见[清单 5-6](ch05.xhtml#ch05ex06)。
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '*Listing 5-6: Solving Baker Bonus*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6: 解决面包师奖金问题*'
- en: As with School Trip, the input contains 10 test cases, so we place all of our
    code inside a loop that iterates 10 times.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与“学校旅行”类似，输入包含 10 个测试用例，因此我们将所有代码放在一个循环中，这个循环执行 10 次。
- en: For each test case, we read the first line of input and call `split` to break
    it into a list ❶. That list will contain two values—the number of franchisees
    and the number of days—and we convert them to integers and assign them to appropriately
    named variables.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，我们读取输入的第一行并调用 `split` 将其拆分为一个列表 ❶。该列表将包含两个值——特许经营者的数量和天数——我们将它们转换为整数并赋值给适当命名的变量。
- en: The `grid` variable begins as an empty list. It will ultimately refer to a list
    of rows, where each row is a list of sales for a given day.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid` 变量开始时是一个空列表。它最终会指向一个行列表，每行是给定日期的销售数据。'
- en: We use a range `for` loop to loop once for each day ❷. We then read a row from
    the input and call `split` to split it into a list of individual sales values.
    These values are strings right now, so we use a nested loop to convert them all
    to integers ❸. Then, we add the row to our grid ❹.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `for` 循环遍历每一天 ❷。然后，我们读取输入中的一行并调用 `split` 将其拆分为一个销售值列表。这些值现在是字符串类型，因此我们使用嵌套循环将它们全部转换为整数
    ❸。接着，我们将该行添加到网格 ❹ 中。
- en: 'We’ve now read the input and stored the grid. It’s time to add up the number
    of bonuses. We take that in two steps: first for the bonuses from the rows and
    second for the bonuses from the columns.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经读取了输入并存储了网格。接下来是计算奖金总数。我们分两步进行：首先是按行计算奖金，然后是按列计算奖金。
- en: To find the bonuses from the rows, we use a `for` loop on `grid` ❺. As with
    any `for` loop on a list, it gives us its values one at a time. Here, each value
    is a list, so `row` refers to a different list on each iteration. The `sum` function
    works on any list of numbers, so we use it here to add up the values in the current
    row ❻. If the sum is divisible by 13, then we add the number of bonuses.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从行中找到奖金，我们在 `grid` 上使用 `for` 循环❺。与任何在列表上的 `for` 循环一样，它会一次给我们一个值。在这里，每个值都是一个列表，所以
    `row` 在每次迭代时指代一个不同的列表。`sum` 函数适用于任何数字列表，因此我们在这里使用它来计算当前行❻的值总和。如果总和能被13整除，我们就加上奖金数。
- en: We can’t loop through columns of the list like we did rows, so we have to resort
    to looping through indices. We accomplish that by using a range `for` loop through
    the indices of the columns ❼. Using `sum` is not an option for summing the current
    column, so we’ll need a nested loop. That nested loop goes through the rows ❽,
    adding up each value in the desired column. We then check whether that total is
    divisible by 13 and add any bonuses if it is.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能像处理行一样遍历列表的列，因此我们必须依靠通过索引来循环。我们通过使用 `for` 循环遍历列的索引❼来实现这一点。使用 `sum` 来求当前列的和并不可行，因此我们需要一个嵌套循环。这个嵌套循环会遍历行❽，把目标列中的每个值加起来。然后我们检查该总和是否能被13整除，如果能，就加上奖励。
- en: We finish by printing the total number of bonuses.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印总奖金数来结束。
- en: Judge time! If you submit our code, you should see that all test cases pass.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 判断时间！如果你提交我们的代码，你应该看到所有测试用例都通过了。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小结
- en: 'In this chapter, we learned about lists, which help us work with collections
    of whatever type we choose. Lists of numbers, lists of strings, lists of lists:
    Python supports whatever we need. We also learned about list methods and why sorting
    a list can make it easier to process the values in a list.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了列表，它帮助我们处理我们选择的任何类型的集合。数字列表、字符串列表、列表的列表：Python 支持我们需要的任何类型。我们还学习了列表方法，以及为什么排序列表可以让处理列表中的值变得更加容易。
- en: In contrast to strings, lists are mutable, which means that we can change their
    contents. This helps us more easily manipulate lists, but we must be careful to
    modify the list that we think we’re modifying.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串不同，列表是可变的，这意味着我们可以更改它们的内容。这帮助我们更容易地操作列表，但我们必须小心修改我们想要修改的列表。
- en: We’re at the point in our learning where we can write programs with many lines
    of code. We can direct what our programs do using `if` statements and loops. We
    can store and manipulate information using strings and lists. We can write programs
    to solve challenging problems. Such programs can become difficult to design and
    read. Fortunately, there’s a tool we can use to help us organize our programs
    to keep their complexity under control, and we’ll learn that tool in the next
    chapter. Working through some of the following exercises may deepen your appreciation
    of the difficulty in writing larger amounts of code. Then you’ll be ready to continue!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进入学习的阶段，现在可以编写包含多行代码的程序。我们可以通过 `if` 语句和循环来控制程序的行为。我们可以使用字符串和列表来存储和操作信息。我们可以编写程序来解决具有挑战性的问题。这样的程序可能变得难以设计和阅读。幸运的是，我们有一个工具可以帮助我们组织程序，以保持复杂度在可控范围内，我们将在下一章学习这个工具。完成以下的一些练习可能会加深你对编写大量代码的困难的理解。然后你就可以准备继续学习了！
- en: Chapter Exercises
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章练习
- en: Here are some exercises for you to try.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。
- en: DMOJ problem `ccc07j3`, Deal or No Deal Calculator
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc07j3`，交易还是不交易计算器
- en: DMOJ problem `coci17c1p1`, Cezar
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci17c1p1`，凯撒
- en: DMOJ problem `coci18c2p1`, Preokret
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci18c2p1`，Preokret
- en: DMOJ problem `ccc00s2`, Babbling Brooks (Check out Python’s `round` function.)
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc00s2`，喋喋不休的溪流（看看 Python 的 `round` 函数。）
- en: DMOJ problem `ecoo18r1p1`, Willow’s Wild Ride
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ecoo18r1p1`，柳树的疯狂之旅
- en: DMOJ problem `ecoo19r1p1`, Free Shirts
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ecoo19r1p1`，免费 T 恤
- en: DMOJ problem `dmopc14c7p2`, Tides
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `dmopc14c7p2`，潮汐
- en: DMOJ problem `wac3p3`, Wesley Plays DDR
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `wac3p3`，韦斯利玩 DDR
- en: DMOJ problem `ecoo18r1p2`, Rue’s Rings (If you use f-strings here, you’ll need
    a way to include the `{` and `}` symbols themselves. You can include a `{` in
    the f-string by using `{{` and a `}` by using `}}`.)
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ecoo18r1p2`，Rue 的戒指（如果你在这里使用 f-strings，你需要一种方法来包含 `{` 和 `}` 符号本身。你可以通过
    `{{` 来包含 `{`，通过 `}}` 来包含 `}`。）
- en: DMOJ problem `coci19c5p1`, Emacs
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci19c5p1`，Emacs
- en: 'DMOJ problem `coci20c2p1`, Crtanje (You’ll need to support rows from –100 to
    100\. But how do we support negative-indexed rows when Python lists start at index
    0? Here’s a trick: use index `x + 100` any time you need access to row `x`. That
    shifts the row numbers to be between 0 and 200 rather than between –100 and 100\.
    Also, one small annoyance here with strings: `\` is a special character, so you’ll
    have to use `''\\''` rather than `''\''` if you want a `\` character.)'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci20c2p1`，Crtanje（你需要支持从 –100 到 100 的行。但当 Python 列表从索引 0 开始时，我们如何支持负索引的行呢？这里有一个小技巧：每次需要访问行
    `x` 时，使用索引 `x + 100`。这样就将行号从 –100 到 100 转换为 0 到 200。此外，关于字符串的一个小烦恼：`\` 是一个特殊字符，所以如果你想要一个
    `\` 字符，必须使用 `'\\'` 而不是 `'\'`。）
- en: DMOJ problem `dmopc19c5p2`, Charlie’s Crazy Conquest (You’ll have to be careful
    with indices and the game rules for this one!)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `dmopc19c5p2`，Charlie的疯狂征服（你需要小心索引和游戏规则！）
- en: Notes
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Village Neighborhood is originally from the 2018 Canadian Computing Competition,
    Senior Level. School Trip is originally from the 2017 Educational Computing Organization
    of Ontario Programming Contest, Round 1\. Baker Bonus is originally from the 2017
    Educational Computing Organization of Ontario Programming Contest, Round 3.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Village Neighborhood 最初来自 2018 年加拿大计算机竞赛，高级组。School Trip 最初来自 2017 年安大略省教育计算组织编程竞赛，第一轮。Baker
    Bonus 最初来自 2017 年安大略省教育计算组织编程竞赛，第三轮。
