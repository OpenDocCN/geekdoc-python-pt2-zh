- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: BIG O AND PROGRAM EFFICIENCY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大O和程序效率
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: 'In the first seven chapters of this book, we focused on writing programs that
    were correct: for any valid input, we wanted our program to produce the desired
    output. In addition to correct code, though, we generally want efficient code,
    code that runs quickly even in the face of huge amounts of input. You may have
    received the occasional time limit exceeded error when working through the first
    seven chapters, but our first formal foray into program efficiency wasn’t until
    [Chapter 8](ch08.xhtml#ch08), when we solved Email Addresses. We saw there that
    sometimes we need to make our programs more efficient so that they can finish
    within a given time limit.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前七章中，我们主要专注于编写正确的程序：对于任何有效的输入，我们希望程序能够输出期望的结果。然而，除了正确的代码外，我们通常还希望代码是高效的，即使面对大量的输入时也能快速运行。在前七章的学习过程中，或许你曾经偶尔遇到过时间超限错误，但我们真正正式接触程序效率的部分是在[第8章](ch08.xhtml#ch08)，当时我们解决了电子邮件地址问题。我们在那时看到，有时候我们需要让程序更加高效，以便能够在给定的时间限制内完成。
- en: 'In this chapter, we’ll first learn how programmers think and communicate about
    program efficiency. Then, we’ll study two problems where we’ll need to write efficient
    code: determining the most desired piece of a scarf and painting a ribbon.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们首先将学习程序员如何思考和沟通程序效率。接着，我们将研究两个需要编写高效代码的问题：确定围巾上最受欢迎的部分和绘制一个丝带。
- en: 'For each problem, we’ll see that our initial ideas lead to an algorithm that
    would not be efficient enough. But we’ll keep at it until we design a faster algorithm
    for the same problem, one that’s dramatically more efficient than before. This
    exemplifies a common workflow for programmers: first, come up with a correct algorithm;
    then, only if needed, make it faster.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个问题，我们会看到最初的想法会导致一个不够高效的算法。但我们会继续努力，直到为同一个问题设计出一个更快的算法，一个明显更高效的算法。这体现了程序员常见的工作流程：首先，提出一个正确的算法；然后，如果需要，才优化它使其更快。
- en: The Problem with Timing
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间测试的难题
- en: Each competitive programming problem that we solve in this book has a time limit
    on how long our program will be allowed to run. (I began including time limits
    in the problem descriptions of [Chapter 8](ch08.xhtml#ch08), when we started running
    into programming problems where efficiency is a serious concern.) If our program
    exceeds the time limit, then the judge terminates our program with a time limit
    exceeded error. A time limit is designed to prevent solutions that are too slow
    from passing the test cases. For example, perhaps we come up with a complete-search
    solution but the author of the problem has worked out a solution that’s much faster.
    That faster solution may be a variation of complete search, as it was when we
    solved the Cow Baseball problem in [Chapter 9](ch09.xhtml#ch09), or it may be
    a different approach entirely. Regardless, the time limit may be set such that
    our complete-search solution will not finish in time. As such, in addition to
    being correct, we may need our programs to be fast.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们解决的每个竞赛编程问题都有一个时间限制，规定了我们的程序可以运行的最长时间。（当我们在[第8章](ch08.xhtml#ch08)中开始遇到效率成为严重问题的编程挑战时，我开始在问题描述中加入时间限制。）如果我们的程序超出了时间限制，评测系统将终止程序，并报告时间超限错误。时间限制的设置是为了防止过于缓慢的解法通过测试用例。例如，也许我们提出了一个完整搜索的解法，但问题的作者已经提出了一个更快的解法。这个更快的解法可能是完整搜索的变种，就像我们在[第9章](ch09.xhtml#ch09)解决牛球问题时那样，或者它也可能是完全不同的方法。无论如何，时间限制可能会设置得使得我们的完整搜索解法无法在规定时间内完成。因此，除了正确性外，我们的程序还需要足够的速度。
- en: We can run a program to explore whether it is efficient enough. For example,
    think back to “Efficiency of Searching a List” in [Chapter 8](ch08.xhtml#ch08)
    when we tried to solve Email Addresses using a list. We ran code that used bigger
    and bigger lists to get a sense of the amount of time taken by list operations.
    This kind of testing can give us some understanding of the efficiency of our programs.
    If our program is too slow, according to the time limit for the problem, then
    we know that we need to optimize the current code or find a wholly new approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行程序来测试它是否足够高效。例如，回想一下在[第8章](ch08.xhtml#ch08)中我们尝试使用列表解决电子邮件地址问题时的“列表查找效率”部分。我们运行了使用越来越大的列表的代码，以了解列表操作所需的时间。这种测试可以帮助我们理解程序的效率。如果我们的程序运行得太慢，超过了问题的时间限制，那么我们就知道需要优化现有的代码，或者找到一种全新的方法。
- en: The amount of time taken by a program depends on the computer it is being run
    on. We don’t know what kind of computer the judge is using, but running the program
    on our own computer is still informative because the judge is probably using a
    computer that’s at least as fast as ours. Say that we run our program on our laptop
    and it takes 30 seconds on some small test case. If the problem time limit is
    three seconds, we can be confident that our program is simply not fast enough.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序所需的时间取决于运行程序的计算机。我们不知道评测机使用的是什么计算机，但在我们自己的计算机上运行程序仍然具有参考价值，因为评测机可能使用的计算机至少和我们的同样快速。假设我们在笔记本电脑上运行程序，并且在某个小的测试用例上花费了30秒。如果问题的时间限制是3秒，我们就可以确信程序速度不够快。
- en: An exclusive focus on time limits, however, is limiting. Think about our first
    solution to Cow Baseball in [Chapter 9](ch09.xhtml#ch09). We didn’t need to run
    that code to determine how slow it would be. That’s because we were able to characterize
    the program in terms of the amount of work that it would do if we did run it.
    For example, in “Efficiency of Our Program” on [page 253](ch09.xhtml#ch09lev2sec16),
    we said that for *n* cows, our program processes *n*³ triples of cows. Notice
    that our focus here is not on the number of seconds our program would take to
    run, but on how much work it does in terms of the amount of input *n*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单纯关注时间限制是有限制的。想一想我们在[第9章](ch09.xhtml#ch09)中的第一个牛棒球问题的解法。我们不需要运行那段代码来确定它有多慢。这是因为我们能够通过对程序需要执行的工作量进行刻画，来估算程序的表现。例如，在[第253页](ch09.xhtml#ch09lev2sec16)的“程序效率”一节中，我们说对于
    *n* 头牛，我们的程序需要处理 *n*³ 个牛三元组。请注意，我们这里关注的不是程序运行所需的秒数，而是程序在处理 *n* 的输入时所做的工作量。
- en: 'There are significant advantages to this kind of analysis compared to running
    our programs and recording execution times. Here are five:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录程序执行时间并运行程序相比，这种分析方法有显著的优势。这里有五个优势：
- en: '**Execution time depends on the computer** Timing our program tells us only
    how long our program takes on one computer. That’s very specific information,
    and it gives us little in the way of understanding what to expect when the program
    is run on other computers. When working through the book, you may have also noticed
    that the time taken by a program varies from run to run, even on the same computer.
    For example, you might run a program on a test case and find that it takes three
    seconds; you might then run it again, on the same test case, and find that it
    takes two-and-a-half seconds or three-and-a-half seconds. The reason for this
    difference is that your operating system is managing your computing resources,
    shunting them around to different tasks as needed. The decisions that your operating
    system makes influence the runtime of your program.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行时间取决于计算机** 测量程序的运行时间仅能告诉我们程序在一台计算机上需要多长时间。这是非常具体的信息，对于理解程序在其他计算机上的表现帮助不大。在学习过程中，你可能还注意到，即使是在同一台计算机上，程序的执行时间也会有所不同。例如，你可能在一个测试用例上运行程序，发现它花了三秒钟；然后你再运行一次相同的测试用例，结果可能是两秒半或者三秒半。出现这种差异的原因是操作系统在管理你的计算资源，根据需要将它们分配到不同的任务上。操作系统所做的决策会影响程序的运行时间。'
- en: '**Execution time depends on the test case** Timing our program on a test case
    tells us only how long our program takes on that test case. Suppose that our program
    takes three seconds to run on a small test case. That may seem fast, but here’s
    the truth about small test cases: every reasonable solution for a problem will
    quickly be able to solve those. If I ask you to tell me the number of unique email
    addresses among 10 email addresses, or the number of triples of cows among 10
    cows, you can quickly do it with the first correct idea that you have. What’s
    interesting, then, are large test cases. They are the ones where algorithmic ingenuity
    pays off. How long will our program take on a large test case or on a huge test
    case? We don’t know. We’d have to run our program on those test cases, too. Even
    if we did that, there could be specific kinds of test cases that trigger poorer
    performance. We may be led to believe that our program is faster than it is.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行时间取决于测试用例** 对我们的程序进行计时，仅仅告诉我们程序在该测试用例上的执行时间。假设我们的程序在一个小的测试用例上运行需要三秒钟。这看起来可能很快，但关于小测试用例的真相是：每个合理的解决方案都能很快解决这些问题。如果我让你告诉我10个电子邮件地址中的唯一电子邮件地址数量，或者10头牛中有多少组三头牛，你可以用你第一个想到的正确方法快速完成。真正有趣的是大规模的测试用例。它们是算法创意能够展现价值的地方。那么，我们的程序在大测试用例或超大测试用例上的执行时间会是多少？我们不知道。我们也需要在这些测试用例上运行程序。即使我们这么做了，也可能会有特定类型的测试用例触发更差的性能。我们可能会被误导，认为我们的程序比实际情况要快。'
- en: '**The program requires implementation** We can’t time something that we don’t
    implement. Suppose that we’re thinking about a problem and come up with an idea
    for how to solve it. Is it fast? Although we could implement it to find out, it
    would be nice to know, in advance, whether or not the idea is likely to lead to
    a fast program. You would not implement a program that you knew, at the outset,
    would be incorrect. It would similarly be nice to know, at the outset, that a
    program would be too slow.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序需要实现** 我们不能对没有实现的东西进行计时。假设我们正在思考一个问题，并且想到了一个解决方案。这会很快吗？虽然我们可以实现它以找出答案，但如果事先知道这个想法是否能带来一个快速的程序，那将会更好。你不会实施一个你知道一开始就是错误的程序。类似地，如果程序从一开始就知道会太慢，那事先知道这一点也会更好。'
- en: '**Timing doesn’t explain slowness** If we find that our program is too slow,
    then our next task is to design a faster one. However, simply timing a program
    gives us no insight into why our program is slow. It just is. Further, if we manage
    to think up a possible improvement to our program, we’d need to implement it to
    see whether or not it helps.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时无法解释程序慢的原因** 如果我们发现程序运行太慢，那么接下来的任务就是设计一个更快的程序。然而，简单地对程序进行计时并不能为我们提供程序为什么慢的任何线索。它就是慢。进一步说，如果我们想到一个可能的改进方案，我们也需要实施它来查看是否有帮助。'
- en: '**Execution time is not easily communicated** For many of the reasons listed,
    it’s difficult to use execution time to talk to other people about the efficiency
    of algorithms. Execution time is too specific: it depends on the computer, operating
    system, test case, programming language, and particular implementation that’s
    used. We’d have to provide all of this information to others interested in the
    efficiency of our algorithm.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行时间难以传达** 由于许多原因，使用执行时间与他人讨论算法的效率是困难的。执行时间过于具体：它取决于计算机、操作系统、测试用例、编程语言和所使用的具体实现。我们必须向其他对我们算法效率感兴趣的人提供所有这些信息。'
- en: 'Not to worry: computer scientists have devised a notation that addresses these
    shortcomings of timing. It’s independent of the computer, independent of test
    case, and independent of a particular implementation. It signals why a slow program
    is slow. It’s easily communicated. It’s called *big O*, and it’s coming right
    up.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心：计算机科学家已经设计了一种符号来解决计时的这些不足。它独立于计算机、独立于测试用例，并且不依赖于特定的实现。它能够指出程序慢的原因。它易于传达。它叫做
    *大O*，马上就要讲解了。
- en: Big O
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大O
- en: Big O is a notation that computer scientists use to concisely describe the efficiency
    of algorithms. The key concept here is the *efficiency class*, which tells you
    how fast an algorithm is or, equivalently, how much work it does. The faster an
    algorithm, the less work it does; the slower an algorithm, the more work it does.
    Each algorithm belongs to an efficiency class; the efficiency class tells you
    how much work that algorithm does relative to the amount of input that it must
    process. To understand big O, we need to understand these efficiency classes.
    We’re now going to study seven of the most common ones. We’ll see those that do
    the least amount of work, the ones you’ll hope your algorithms fit into. We’ll
    also see those that do considerably more work, the ones whose algorithms will
    probably give you time limit exceeded errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大O表示法是计算机科学家用来简洁描述算法效率的符号。这里的关键概念是*效率类*，它告诉你算法的运行速度，或者说，算法需要做多少工作。算法越快，它的工作量越少；算法越慢，它的工作量越多。每个算法都属于一个效率类；效率类告诉你这个算法在处理输入时相对于输入量需要做多少工作。要理解大O，我们需要理解这些效率类。接下来我们将学习七个最常见的效率类。我们将看到那些做最少工作的算法，也就是你希望你的算法能归入的类别。我们还将看到那些做更多工作的算法，这些算法可能会给你带来超时错误。
- en: Constant Time
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常数时间
- en: The most desirable algorithms are those that don’t do more work as the amount
    of input increases. No matter the problem instance, such an algorithm takes about
    the same number of steps. These are called *constant-time* algorithms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最理想的算法是那些随着输入量的增加而不会增加额外工作量的算法。无论问题实例如何，这样的算法大致需要相同的步骤数。这些被称为*常数时间*算法。
- en: 'This is hard to believe, right? An algorithm that does about the same amount
    of work, no matter what? Indeed, solving a problem with such an algorithm is rare.
    But when you can do it, rejoice: you can’t do any better than that.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这难以相信，对吧？一个做差不多相同工作的算法，无论情况如何？确实，使用这样的算法解决问题是很少见的。但当你能做到时，庆祝一下吧：你已经做得最好了。
- en: 'We’ve managed to solve a few problems in this book using constant-time algorithms.
    Think back to the Telemarketers problem in [Chapter 2](ch02.xhtml#ch02), where
    we had to determine whether the provided phone number belongs to a telemarketer.
    I’ve reproduced our solution from [Listing 2-2](ch02.xhtml#ch02ex02) here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经成功地使用常数时间算法解决了几个问题。回想一下[第2章](ch02.xhtml#ch02)中的推销员问题，我们需要判断提供的电话号码是否属于推销员。我已经在这里重现了来自[清单2-2](ch02.xhtml#ch02ex02)的解决方案：
- en: num1 = int(input())
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: num1 = int(input())
- en: num2 = int(input())
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: num2 = int(input())
- en: num3 = int(input())
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: num3 = int(input())
- en: num4 = int(input())
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: num4 = int(input())
- en: if ((num1 == 8 or num1 == 9) and
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: if ((num1 == 8 或 num1 == 9) 并且
- en: (num4 == 8 or num4 == 9) and
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (num4 == 8 或 num4 == 9) 并且
- en: '(num2 == num3)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '(num2 == num3)):'
- en: print('ignore')
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: print('忽略')
- en: 'else:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('answer')
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: print('答案')
- en: Our solution does the same amount of work no matter what the four digits of
    the phone number are. The code starts by reading the input. Then it makes some
    comparisons with num1, num2, num3, and num4. If the phone number belongs to a
    telemarketer, we output something; if it doesn’t belong to a telemarketer, we
    output something else. There’s no input that can make our program do more work
    than this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案无论电话号码的四个数字是什么，都做相同数量的工作。代码首先读取输入。然后它与num1、num2、num3和num4做一些比较。如果电话号码属于推销员，我们输出某些内容；如果不属于推销员，我们输出其他内容。没有任何输入能使我们的程序做比这更多的工作。
- en: 'Earlier in [Chapter 2](ch02.xhtml#ch02), we solved Winning Team. Did we solve
    that one in constant time, too? We did! Here’s the solution from [Listing 2-1](ch02.xhtml#ch02ex01):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml#ch02)中，我们解决了“获胜团队”问题。我们是否也以常数时间解决了这个问题呢？是的！以下是来自[清单2-1](ch02.xhtml#ch02ex01)的解决方案：
- en: apple_three = int(input())
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: apple_three = int(input())
- en: apple_two = int(input())
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: apple_two = int(input())
- en: apple_one = int(input())
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: apple_one = int(input())
- en: banana_three = int(input())
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: banana_three = int(input())
- en: banana_two = int(input())
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: banana_two = int(input())
- en: banana_one = int(input())
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: banana_one = int(input())
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: apple_total = apple_three * 3 + apple_two * 2 + apple_one
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: banana_total = banana_three * 3 + banana_two * 2 + banana_one
- en: 'if apple_total > banana_total:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 apple_total > banana_total:'
- en: print('A')
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: print('A')
- en: 'elif banana_total > apple_total:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif banana_total > apple_total:'
- en: print('B')
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: print('B')
- en: 'else:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('T')
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: print('T')
- en: We read the input, compute the total points for the Apples, compute the total
    points for the Bananas, compare those totals, and output a message. It doesn’t
    matter how many points the Apples or Bananas have—our program always does the
    same amount of work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取输入，计算苹果队的总分，计算香蕉队的总分，比较这些总分，并输出消息。不管苹果队或香蕉队的得分是多少——我们的程序总是做相同数量的工作。
- en: Hold on—what if the Apples scored zillions and zillions of three-point shots?
    Surely, it takes longer for the computer to work with ginormous numbers than small
    numbers like 10 or 50? While that’s true, we don’t have to worry about that here.
    The problem description states that each team scores at most 100 of each type
    of play. We’re therefore working with small numbers, and it’s fair to say that
    the computer can read or operate on these numbers in a constant number of steps.
    In general, you can think of numbers up to a few billion as “small.”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——如果苹果队得到了成千上万的三分球得分呢？计算机处理巨大的数字肯定比处理像10或50这样的数字要花更长的时间吧？虽然这是对的，但我们在这里不需要担心。题目描述中说明每支队伍每种类型的进球最多为100个。因此，我们处理的是小数字，可以合理地说，计算机可以在常数步数内读取或操作这些数字。一般来说，你可以把几亿以内的数字看作是“较小”的数字。
- en: In big O notation, we say that a constant-time algorithm is *O*(1). The 1 doesn’t
    mean that you’re stuck performing only one step in a constant-time algorithm.
    If you perform a fixed number of steps, like 10 or even 10,000, it’s still constant
    time. But don’t write *O*(10) or *O*(10000)—all constant-time algorithms are denoted
    *O*(1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在大O符号表示法中，我们说常数时间算法是 *O*(1)。这个1并不意味着你只能在常数时间算法中执行一步。如果你执行固定数量的步骤，例如10步甚至10,000步，它仍然是常数时间。但不要写
    *O*(10) 或 *O*(10000)——所有常数时间算法都表示为 *O*(1)。
- en: Linear Time
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线性时间
- en: Most algorithms are not constant-time algorithms. Instead, they do an amount
    of work that depends on the amount of input. For example, they do more work to
    process 1,000 values than they do to process 10 values. What distinguishes these
    algorithms from each other is the relationship between the amount of input and
    the amount of work that the algorithm does.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数算法不是常数时间算法。相反，它们所做的工作量取决于输入量。例如，它们处理1,000个值时的工作量要比处理10个值时多。区分这些算法的关键是输入量与算法所做工作量之间的关系。
- en: A *linear-time* algorithm is one with a linear relationship between the amount
    of input and the amount of work done. Suppose we run a linear-time algorithm on
    an input with 50 values, and then we run it again on an input with 100 values.
    The algorithm will do about twice as much work on the 100 values compared with
    on the 50 values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: A *线性时间*算法是指输入量与工作量之间存在线性关系的算法。假设我们在包含50个值的输入上运行线性时间算法，然后在包含100个值的输入上再次运行它。那么，相对于50个值，算法在100个值上所做的工作大约是两倍。
- en: 'For an example, let’s look at the Three Cups problem from [Chapter 3](ch03.xhtml#ch03).
    We solved that problem in [Listing 3-1](ch03.xhtml#ch03ex01), and I’ve reproduced
    our solution here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们来看一下[第3章](ch03.xhtml#ch03)中的“三杯问题”。我们在[清单3-1](ch03.xhtml#ch03ex01)中解决了这个问题，下面是我们的解决方案：
- en: swaps = input()
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: swaps = input()
- en: ball_location = 1
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 1
- en: '❶ for swap_type in swaps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for swap_type in swaps:'
- en: 'if swap_type == ''A'' and ball_location == 1:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'if swap_type == ''A'' and ball_location == 1:'
- en: ball_location = 2
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 2
- en: 'elif swap_type == ''A'' and ball_location == 2:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''A'' and ball_location == 2:'
- en: ball_location = 1
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 1
- en: 'elif swap_type == ''B'' and ball_location == 2:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''B'' and ball_location == 2:'
- en: ball_location = 3
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 3
- en: 'elif swap_type == ''B'' and ball_location == 3:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''B'' and ball_location == 3:'
- en: ball_location = 2
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 2
- en: 'elif swap_type == ''C'' and ball_location == 1:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''C'' and ball_location == 1:'
- en: ball_location = 3
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 3
- en: 'elif swap_type == ''C'' and ball_location == 3:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''C'' and ball_location == 3:'
- en: ball_location = 1
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 1
- en: print(ball_location)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: print(ball_location)
- en: There’s a for loop ❶, and the amount of work that it does depends linearly on
    the amount of input. If there are five swaps to process, then the loop iterates
    five times. If there are 10 swaps to process, then the loop iterates 10 times.
    Each iteration of the loop performs a constant number of comparisons and may change
    what ball_location refers to. Therefore, the amount of work that this algorithm
    does is directly proportional to the number of swaps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个for循环 ❶，它所做的工作量与输入量呈线性关系。如果需要处理5个交换，那么循环就会迭代5次。如果需要处理10个交换，那么循环就会迭代10次。每次循环都执行常数数量的比较，并可能更改ball_location的值。因此，该算法所做的工作量与交换次数直接成正比。
- en: We typically use *n* to refer to the amount of input provided to a problem.
    Here, *n* is the number of swaps. If there are 5 swaps that we need to perform,
    then *n* is 5; if there are 10 swaps that we need to perform, then *n* is 10.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常用 *n* 来表示输入到问题中的数据量。在这里，*n* 是交换的次数。如果需要进行 5 次交换，那么 *n* 就是 5；如果需要进行 10 次交换，那么
    *n* 就是 10。
- en: If there are *n* swaps, then our program does about *n* work. That’s because
    the for loop performs *n* iterations, each of which performs a constant number
    of steps. We don’t care how many steps it performs on each iteration, as long
    as it’s a constant number. Whether the algorithm performs a total of *n* steps
    or 10*n* steps or 10,000*n* steps, it’s a linear-time algorithm. In big O notation,
    we say that this algorithm is *O*(*n*).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 *n* 次交换，那么我们的程序大约做 *n* 次工作。这是因为 for 循环执行了 *n* 次迭代，每次迭代执行常数数量的步骤。我们不关心每次迭代执行多少步骤，只要它是常数时间的。无论算法执行的是
    *n* 步，10*n* 步，还是 10,000*n* 步，它都是线性时间算法。在大 O 表示法中，我们说这个算法是 *O*(*n*)。
- en: When using big O notation, we don’t include numbers in front of *n*. For example,
    an algorithm that takes 10*n* steps is written *O*(*n*), not *O*(10*n*). This
    helps us focus on the fact that the algorithm is linear time and away from the
    specifics of the linear relationship.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大 O 表示法时，我们不包括 *n* 前面的数字。例如，一个需要 10*n* 步骤的算法应该写作 *O*(*n*)，而不是 *O*(10*n*)。这有助于我们专注于算法的线性时间性质，而不是线性关系的具体细节。
- en: What if an algorithm takes 2*n* + 8 steps—what kind of algorithm is this? This
    is still linear time! The reason is that the linear term (2*n*) will come to dominate
    the constant term (8) as soon as *n* is big enough. For example, if *n* is 5,000,
    then 8*n* is 40,000\. The number 8 is so small compared to 40,000 that we may
    as well ignore it. In big O notation, we ignore everything except the dominant
    terms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法需要 2*n* + 8 步骤，那么这是什么类型的算法？这仍然是线性时间！原因是线性项（2*n*）会在 *n* 足够大的时候支配常数项（8）。例如，如果
    *n* 是 5000，那么 8*n* 就是 40,000。数字 8 相对于 40,000 来说非常小，所以我们可以忽略它。在大 O 表示法中，我们忽略所有除主导项以外的部分。
- en: Many Python operations take constant time to do their work. For example, appending
    to a list, adding to a dictionary, or indexing a sequence or dictionary all take
    constant time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 操作的执行时间是常数时间。例如，向列表中添加元素、向字典中添加键值对，或者索引序列或字典，都需要常数时间。
- en: But some Python operations take linear time to do their work. Be careful to
    count them as linear time and not constant time. For example, using the Python
    input function to read a long string takes linear time, because Python has to
    read each character on the line of input. Any operation that examines each character
    of a string or value in a list takes linear time as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有些 Python 操作是线性时间的。要小心将它们算作线性时间，而不是常数时间。例如，使用 Python 的输入函数读取一长串字符串需要线性时间，因为
    Python 必须读取输入行中的每个字符。任何检查字符串或列表中每个字符或值的操作都需要线性时间。
- en: If an algorithm reads *n* values and processes each value in a constant number
    of steps, then it is a linear-time algorithm.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法读取 *n* 个值，并且每个值的处理步骤是常数时间，那么它就是一个线性时间算法。
- en: 'We don’t need to go far to see another linear-time algorithm—our solution to
    Occupied Spaces in [Chapter 3](ch03.xhtml#ch03) is another such example. I’ve
    reproduced our solution from [Listing 3-3](ch03.xhtml#ch03ex03) here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要走得太远就能看到另一个线性时间算法——我们在[第 3 章](ch03.xhtml#ch03)中对“已占用空间”的解决方案就是另一个例子。我在这里复现了我们在[清单
    3-3](ch03.xhtml#ch03ex03)中的解决方案：
- en: n = int(input())
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: yesterday = input()
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: yesterday = input()
- en: today = input()
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: today = input()
- en: occupied = 0
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: occupied = 0
- en: 'for i in range(len(yesterday)):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(yesterday)):'
- en: 'if yesterday[i] == ''C'' and today[i] == ''C'':'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'if yesterday[i] == ''C'' and today[i] == ''C'':'
- en: occupied = occupied + 1
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: occupied = occupied + 1
- en: print(occupied)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: print(occupied)
- en: 'We let *n* be the number of parking spaces. The pattern is the same as for
    Three Cups: we read the input and then perform a constant number of steps for
    each parking space.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设 *n* 为停车位的数量。模式和“三杯问题”是一样的：我们读取输入，然后对每个停车位执行常数数量的步骤。
- en: '**CONCEPT CHECK**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: In [Listing 1-1](ch01.xhtml#ch01ex01), we solved the Word Count problem. Here’s
    the code for that solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 1-1](ch01.xhtml#ch01ex01)中，我们解决了词数问题。这里是该解决方案的代码。
- en: line = input()
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: line = input()
- en: total_words = line.count(' ') + 1
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: total_words = line.count(' ') + 1
- en: print(total_words)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: print(total_words)
- en: What is the big O efficiency of our algorithm?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法的大 O 效率是多少？
- en: A. *O*(1)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: A. *O*(1)
- en: B. *O*(*n*)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: B. *O*(*n*)
- en: 'Answer: B. It’s tempting to think that this algorithm is *O*(1). After all,
    there’s no loop anywhere, and it looks like the algorithm is performing just three
    steps: read the input, call count to count the number of words, and output the
    number of words.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。人们很容易认为这个算法是 *O*(1)。毕竟，那里没有循环，看起来算法只执行了三步：读取输入、调用计数方法来统计单词数量、输出单词数量。
- en: But this algorithm is *O*(*n*), where *n* is the number of characters in the
    input. It takes linear time for the input function to read the input, because
    it has to read the input character by character. Using the count method also takes
    linear time, because it has to process each character of the string to find matches.
    So this algorithm performs a linear amount of work to read the input and a linear
    amount of work to count the words. That’s a linear amount of work overall.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个算法是 *O*(*n*)，其中 *n* 是输入中的字符数量。输入函数读取输入需要线性时间，因为它必须逐字符读取输入。使用计数方法也需要线性时间，因为它必须处理字符串的每个字符以找到匹配项。所以这个算法执行了线性的工作量来读取输入，并且执行了线性的工作量来统计单词。总体上，这是线性的工作量。
- en: '**CONCEPT CHECK**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'In [Listing 1-2](ch01.xhtml#ch01ex02), we solved the Cone Volume problem. I’ve
    reproduced that solution here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-2](ch01.xhtml#ch01ex02)中，我们解决了圆锥体积问题。我在这里重现了该解决方案：
- en: PI = 3.141592653589793
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: PI = 3.141592653589793
- en: radius = int(input())
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: radius = int(input())
- en: height = int(input())
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: height = int(input())
- en: volume = (PI * radius ** 2 * height) / 3
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: volume = (PI * radius ** 2 * height) / 3
- en: print(volume)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: print(volume)
- en: What is the big O efficiency of our algorithm? (Recall that the maximum value
    for the radius and height is 100.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们算法的大 O 效率是多少？（回想一下，半径和高度的最大值是100。）
- en: A. *O*(1)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: A. *O*(1)
- en: B. *O*(*n*)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: B. *O*(*n*)
- en: 'Answer: A. We’re dealing with small numbers here, so reading them from the
    input takes constant time. Calculating the volume takes constant time, too: it’s
    just a few mathematical operations. All we’re doing here, then, is a few constant-time
    steps. That’s a constant amount of work overall.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。我们这里处理的是小数字，因此从输入中读取它们需要常数时间。计算体积也需要常数时间，因为只是进行几个数学运算。因此，我们所做的只是几个常数时间的步骤。总体上，这是常数工作量。
- en: '**CONCEPT CHECK**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'In [Listing 3-4](ch03.xhtml#ch03ex04), we solved the Data Plan problem. I’ve
    reproduced that solution here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-4](ch03.xhtml#ch03ex04)中，我们解决了数据计划问题。我在这里重现了该解决方案：
- en: monthly_mb = int(input())
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: monthly_mb = int(input())
- en: n = int(input())
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: excess = 0
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: excess = 0
- en: 'for i in range(n):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: used = int(input())
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: used = int(input())
- en: excess = excess + monthly_mb - used
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: excess = excess + monthly_mb - used
- en: print(excess + monthly_mb)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: print(excess + monthly_mb)
- en: What is the big O efficiency of our algorithm?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们算法的大 O 效率是多少？
- en: A. *O*(1)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: A. *O*(1)
- en: B. *O*(*n*)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: B. *O*(*n*)
- en: 'Answer: B. The pattern for this algorithm is similar to that of our solution
    to Three Cups or Occupied Spaces, except that it interleaves reading the input
    with processing it. We let *n* be the number of monthly megabyte values. The program
    performs a constant number of steps for each of these *n* input values. This is
    therefore an *O*(*n*) algorithm.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。这个算法的模式类似于我们解决“三杯或占据空间”问题的解决方案，不同之处在于它将读取输入与处理输入交替进行。我们设 *n* 为每月兆字节数值的数量。对于这些
    *n* 个输入值，程序执行一个常数步数。因此，这是一个 *O*(*n*) 的算法。
- en: Quadratic Time
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二次时间
- en: So far we’ve discussed constant-time algorithms (those that don’t do more work
    as the amount of input increases) and linear-time algorithms (those that do more
    work linearly as the amount of input increases). Like a linear-time algorithm,
    a *quadratic-time* algorithm does more work as the amount of input increases;
    for example, it does more work to process 1,000 values than 10 values. Whereas
    we can get away with using a linear-time algorithm on relatively large amounts
    of input, we’ll be restricted to much smaller amounts of input on quadratic-time
    algorithms. We’ll see why next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了常数时间算法（即随着输入量的增加，工作量不增加的算法）和线性时间算法（即随着输入量的增加，工作量线性增加的算法）。像线性时间算法一样，*二次时间*算法在输入量增加时会增加工作量；例如，处理1,000个值比处理10个值需要更多的工作。虽然在相对较大的输入量下，我们可以使用线性时间算法，但在二次时间算法上，我们将被限制在更小的输入量上。接下来我们将看到原因。
- en: Typical Form
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 典型形式
- en: 'A typical linear-time algorithm looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的线性时间算法看起来是这样的：
- en: 'for i in range(n):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: <process input i in a constant number of steps>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <以常数步数处理输入 i>
- en: 'In contrast, a typical quadratic-time algorithm looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个典型的二次时间算法看起来是这样的：
- en: 'for i in range(n):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: 'for j in range(n):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(n):'
- en: <process inputs i and j in a constant number of steps>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <以恒定步数处理输入 i 和 j>
- en: For an input of *n* values, how many values does each algorithm process? The
    linear-time algorithm processes *n* values, one on each iteration of the for loop.
    The quadratic-time algorithm, in contrast, processes *n* values *on each iteration*
    of the outer for loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包含 *n* 个值的输入，每个算法处理多少值？线性时间算法处理 *n* 个值，每次迭代处理一个。相比之下，二次时间算法在外层 for 循环的每次迭代中都处理
    *n* 个值。
- en: On the first iteration of the outer for loop, *n* values are processed (one
    on each iteration of the inner for loop); on the second iteration of the outer
    for loop, *n* more values are processed (one on each iteration of the inner for
    loop); and so on. As the outer for loop iterates *n* times, the total number of
    values that are processed is *n* * *n*, or *n*². Two nested loops, each of which
    depends on *n*, gives rise to a quadratic-time algorithm. In big O notation, we
    say that a quadratic-time algorithm is *O*(*n*²).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在外层 for 循环的第一次迭代中，处理 *n* 个值（每次内层 for 循环迭代处理一个）；在外层 for 循环的第二次迭代中，再处理 *n* 个值；以此类推。由于外层
    for 循环迭代了 *n* 次，总共处理的值的数量是 *n* * *n*，即 *n*²。两个嵌套循环，每个循环都依赖于 *n*，就形成了一个二次时间算法。在大
    O 表示法中，我们说二次时间算法是 *O*(*n*²)。
- en: 'Let’s compare the amount of work done by linear-time and quadratic-time algorithms.
    Suppose that we’re processing an input of 1,000 values, meaning that *n* is 1,000\.
    A linear-time algorithm that takes *n* steps would take 1,000 steps. A quadratic-time
    algorithm that takes *n*² steps would take 1,000² = 1,000,000 steps. A million
    is way more than a thousand. But who cares: computers are really, really fast,
    right? Well, yes, and for an input of 1,000 values, we’re probably okay if we
    use a quadratic-time algorithm. In “Efficiency of Our Program” on [page 253](ch09.xhtml#ch09lev2sec16),
    I gave a conservative rule claiming that we can perform about five million steps
    per second. A million steps, then, should be doable in all but the strictest time
    limits.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较线性时间和二次时间算法所做的工作量。假设我们正在处理一个包含1,000个值的输入，即 *n* 为 1,000。一个线性时间算法需要 *n* 步，因此需要1,000步。一个二次时间算法需要
    *n*² 步，因此需要 1,000² = 1,000,000 步。一百万比一千要多得多。但谁在乎呢：计算机真的非常快，对吧？嗯，是的，对于包含1,000个值的输入，如果我们使用一个二次时间算法，可能还是可以的。在《我们程序的效率》一章中，见
    [第253页](ch09.xhtml#ch09lev2sec16)，我给出了一个保守的规则，声称我们每秒可以执行大约五百万步。那么，一百万步应该在大多数时间限制下都能完成。
- en: But any optimism for a quadratic-time algorithm is short-lived. Watch what happens
    if we crank the number of input values up from 1,000 to 10,000\. The linear-time
    algorithm takes only 10,000 steps. The quadratic-algorithm takes 10,000² = 100,000,000
    steps. Hmmm . . . if we’re using a quadratic-time algorithm, now our computer
    isn’t looking so fast. While the linear-time algorithm still runs in milliseconds,
    the quadratic-time algorithm will take at least a few seconds. Time limit exceeded
    there, no question.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于二次时间算法的任何乐观情绪都是短暂的。看看当我们将输入值的数量从1,000增加到10,000时会发生什么。线性时间算法只需要10,000步。二次时间算法需要10,000²
    = 100,000,000步。嗯……如果我们使用二次时间算法，计算机的速度就没有那么快了。虽然线性时间算法仍然能在毫秒级别运行，但二次时间算法至少需要几秒钟。时间超限，毫无疑问。
- en: '**CONCEPT CHECK**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the big O efficiency of the following algorithm?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法的大 O 效率是多少？
- en: 'for i in range(10):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(10):'
- en: 'for j in range(n):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(n):'
- en: <process inputs i and j in a constant number of steps>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <以恒定步数处理输入 i 和 j>
- en: A. *O*(1)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: A. *O*(1)
- en: B. *O*(*n*)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: B. *O*(*n*)
- en: C. *O*(*n*^(*2*))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C. *O*(*n*^(*2*))
- en: 'Answer: B. There are two nested loops here, so your first instinct might be
    to claim that this is a quadratic-time algorithm. Be careful, though, because
    the outer for loop iterates only 10 times, independent of the value of *n*. The
    total number of steps in this algorithm, therefore, is *10n*. There’s no *n*^(*2*)
    here; *10n* is linear, just like *n*. So, this is a linear-time algorithm, not
    a quadratic-time algorithm. We’d write its efficiency as *O*(*n*).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。这里有两个嵌套循环，所以你可能本能地认为这是一个二次时间算法。然而要小心，因为外层 for 循环只迭代了10次，与 *n* 的值无关。因此，这个算法的总步数是
    *10n*。这里没有 *n*^(*2*)，*10n* 是线性的，就像 *n* 一样。所以，这是一个线性时间算法，而不是二次时间算法。我们会将其效率写作 *O*(*n*)。
- en: '**CONCEPT CHECK**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the big O efficiency of the following algorithm?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法的大 O 效率是多少？
- en: 'for i in range(n):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: <process input i in a constant number of steps>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <以恒定步数处理输入 i>
- en: 'for j in range(n):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(n):'
- en: <process input j in a constant number of steps>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <以常数步长处理输入 j>
- en: A. *O*(1)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: A. *O*(1)
- en: B. *O*(*n*)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: B. *O*(*n*)
- en: C. *O*(*n*^(*2*))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C. *O*(*n*^(*2*))
- en: 'Answer: B. We have two loops here, and they both depend on *n*. Isn’t this
    quadratic time, then?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。我们这里有两个循环，它们都依赖于 *n*。这不就是二次时间复杂度吗？
- en: No! These two loops are sequential, not nested. The first loop takes *n* steps,
    and the second also takes *n* steps, for a total of *2n* steps. This is therefore
    a linear-time algorithm.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不！这两个循环是顺序执行的，而不是嵌套的。第一个循环执行 *n* 步，第二个循环也执行 *n* 步，总共执行 *2n* 步。因此，这是一个线性时间算法。
- en: Alternate Form
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备用形式
- en: 'When you see two nested loops where each depends on *n*, it’s a good bet that
    you’re looking at a quadratic-time algorithm. But it’s possible for a quadratic-time
    algorithm to arise even in the absence of such nested loops. We can find such
    an example in our first solution to the Email Addresses problem, [Listing 8-2](ch08.xhtml#ch08ex02).
    I’ve reproduced that solution here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到两个嵌套的循环且每个循环都依赖于 *n* 时，可以推测这是一个二次时间复杂度算法。但即使没有嵌套循环，二次时间复杂度算法也有可能出现。我们可以在解决电子邮件地址问题时的第一个解法中找到这样一个例子，[第8-2号列表](ch08.xhtml#ch08ex02)。我在这里重现了该解决方案：
- en: clean function not shown
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: clean 函数未显示
- en: 'for dataset in range(10):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dataset in range(10):'
- en: n = int(input())
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: addresses = []
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: addresses = []
- en: 'for i in range(n):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: address = input()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: address = input()
- en: ❶ address = clean(address)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ address = clean(address)
- en: '❷ if not address in addresses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 address 不在 addresses 中：
- en: addresses.append(address)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: addresses.append(address)
- en: print(len(addresses))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: print(len(addresses))
- en: We’ll let *n* be the maximum number of email addresses that we see in our 10
    test cases. The outer for loop iterates 10 times; the inner for loop iterates
    at most *n* times. We’re therefore processing at most 10*n* email addresses, which
    is linear in *n*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *n* 设为我们在 10 个测试用例中看到的最大电子邮件地址数量。外层 for 循环执行 10 次；内层 for 循环最多执行 *n* 次。因此，我们最多处理
    10*n* 个电子邮件地址，这在 *n* 上是线性的。
- en: Cleaning an email address ❶ takes a constant number of steps, so we don’t need
    to worry about that. But this is still *not* a linear-time algorithm, because
    each iteration of the inner for loop takes more than a constant number of steps.
    Specifically, checking whether an email address is already in our list ❷ takes
    work proportional to the number of email addresses already in the list, because
    Python has to search through the list. That’s a linear-time operation on its own!
    So we’re processing 10*n* email addresses, each of which requires *n* work, for
    a total of 10*n*², or quadratic-time, work. This quadratic-time performance is
    precisely why we received a time limit exceeded error with this code, leading
    us to use a set rather than a list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清理一个电子邮件地址 ❶ 需要常数时间的步骤，所以我们不需要担心这一点。但这仍然不是 *线性时间* 算法，因为内层 for 循环的每次迭代都需要超过常数时间的步骤。具体来说，检查一个电子邮件地址是否已经在我们的列表中
    ❷ 需要与列表中已有的电子邮件地址数量成比例的工作量，因为 Python 需要遍历列表。这本身就是一个线性时间操作！因此，我们需要处理 10*n* 个电子邮件地址，每个地址需要
    *n* 的工作量，总共需要 10*n*²，或者说是二次时间复杂度的工作量。正因为有了这种二次时间复杂度表现，我们才在代码中遇到了超时错误，导致我们使用了集合而不是列表。
- en: Cubic Time
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三次时间
- en: If one loop can lead to linear time, and two nested loops can lead to quadratic
    time, then what about three nested loops? Three nested loops, each of which depends
    on *n*, leads to a *cubic-time* algorithm. In big O notation, we say that a cubic-time
    algorithm is *O*(*n*³).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个循环能导致线性时间，两个嵌套循环能导致二次时间复杂度，那么三个嵌套循环呢？三个嵌套循环，每个都依赖于 *n*，将导致一个 *三次时间复杂度* 算法。在大
    O 符号表示法中，我们说一个三次时间复杂度算法是 *O*(*n*³)。
- en: 'If you thought quadratic-time algorithms were slow, wait till you see how slow
    cubic-time algorithms are. Suppose that *n* is 1,000\. We already know that a
    linear-time algorithm will take about 1,000 steps and that a quadratic-time algorithm
    will take about 1,000² = 1,000,000 steps. A cubic-time algorithm will take 1,000³
    = 1,000,000,000 steps. A billion steps! But it gets worse. For example, if *n*
    is 10,000, which is still a small amount of input, then a cubic-time algorithm
    will take 1,000,000,000,000 (that’s one trillion) steps. One trillion steps would
    take many minutes of computing time. No joke: a cubic-time algorithm is almost
    never good enough.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得二次时间复杂度的算法已经很慢，等你看到三次时间复杂度的算法有多慢吧。假设 *n* 是 1,000。我们已经知道线性时间算法将花费大约 1,000
    步，二次时间算法将花费大约 1,000² = 1,000,000 步。而三次时间复杂度算法将花费 1,000³ = 1,000,000,000 步。十亿步！但更糟糕的是。例如，如果
    *n* 是 10,000，这仍然是一个较小的输入量，那么三次时间复杂度的算法将花费 1,000,000,000,000（即一万亿）步。一万亿步将需要数分钟的计算时间。不是开玩笑：三次时间复杂度的算法几乎永远不够好。
- en: 'It certainly wasn’t good enough when we tried to use a cubic-time algorithm
    to solve Cow Baseball in [Listing 9-5](ch09.xhtml#ch09ex05). I’ve reproduced that
    solution here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用三次方时间复杂度的算法来解决牛仔棒球问题时，在[清单9-5](ch09.xhtml#ch09ex05)中显然是不够好的。我在这里重新呈现了那个解决方案：
- en: input_file = open('baseball.in', 'r')
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('baseball.in', 'r')
- en: output_file = open('baseball.out', 'w')
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('baseball.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: positions = []
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: 'for i in range(n):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: positions.append(int(input_file.readline()))
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(int(input_file.readline()))
- en: total = 0
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: '❶ for position1 in positions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for position1 in positions:'
- en: '❷ for position2 in positions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for position2 in positions:'
- en: first_two_diff = position2 - position1
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: first_two_diff = position2 - position1
- en: 'if first_two_diff > 0:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'if first_two_diff > 0:'
- en: low = position2 + first_two_diff
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: low = position2 + first_two_diff
- en: high = position2 + first_two_diff * 2
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: high = position2 + first_two_diff * 2
- en: '❸ for position3 in positions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for position3 in positions:'
- en: 'if position3 >= low and position3 <= high:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'if position3 >= low and position3 <= high:'
- en: total = total + 1
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + 1
- en: output_file.write(str(total) + '\n')
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(str(total) + '\n')
- en: input_file.close()
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: 'You’ll see the telltale of cubic time in this code: three nested loops ❶ ❷
    ❸, each of which depends on the amount of input. As you’ll recall, the time limit
    for that problem was four seconds, and we could have up to 1,000 cows. A cubic-time
    algorithm, processing a billion triples, is way too slow.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到这段代码中的三次方时间复杂度的典型特征：三个嵌套循环 ❶ ❷ ❸，每一个都依赖于输入量。正如你记得的那样，那个问题的时间限制是四秒，而我们最多可以有1000头牛。一个三次方时间复杂度的算法，处理十亿个三元组，速度太慢了。
- en: Multiple Variables
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个变量
- en: 'In [Chapter 5](ch05.xhtml#ch05), we solved the Baker Bonus problem. I’ve reproduced
    our solution from [Listing 5-6](ch05.xhtml#ch05ex06) here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](ch05.xhtml#ch05)中，我们解决了贝克奖金问题。我在这里重新呈现了我们在[清单5-6](ch05.xhtml#ch05ex06)中的解决方案：
- en: 'for dataset in range(10):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dataset in range(10):'
- en: lst = input().split()
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input().split()
- en: franchisees = int(lst[0])
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: franchisees = int(lst[0])
- en: days = int(lst[1])
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: days = int(lst[1])
- en: grid = []
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: grid = []
- en: '❶ for i in range(days):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for i in range(days):'
- en: row = input().split()
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: row = input().split()
- en: 'for j in range(franchisees):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(franchisees):'
- en: row[j] = int(row[j])
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: row[j] = int(row[j])
- en: grid.append(row)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: grid.append(row)
- en: bonuses = 0
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: bonuses = 0
- en: '❷ for row in grid:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for row in grid:'
- en: total = sum(row)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: total = sum(row)
- en: 'if total % 13 == 0:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'if total % 13 == 0:'
- en: bonuses = bonuses + total // 13
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: bonuses = bonuses + total // 13
- en: '❸ for col_index in range(franchisees):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for col_index in range(franchisees):'
- en: total = 0
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: 'for row_index in range(days):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row_index in range(days):'
- en: total = total + grid[row_index][col_index]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + grid[row_index][col_index]
- en: 'if total % 13 == 0:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'if total % 13 == 0:'
- en: bonuses = bonuses + total // 13
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: bonuses = bonuses + total // 13
- en: print(bonuses)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: print(bonuses)
- en: What is the big O efficiency of this algorithm? There are some nested loops
    in here, so a first guess is that this algorithm is *O*(*n*²). But what is *n*?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的Big O效率是多少？这里有一些嵌套循环，所以初步猜测这个算法的时间复杂度是*O*(*n*²)。但*n*到底是什么呢？
- en: 'In the problems we’ve discussed to this point in the chapter, we used the single
    variable *n* to represent the amount of input: *n* could be the number of swaps
    or the number of parking spaces or the number of email addresses or the number
    of cows. But in the Baker Bonus problem, we’re dealing with two-dimensional input,
    so we need *two* variables to represent its amount. We’ll call the first variable
    *d*, the number of days; we’ll call the second *f*, the number of franchisees.
    More formally, because there are multiple test cases per input, we’ll let *d*
    be the maximum number of days and *f* the maximum number of franchisees. We need
    to give the big O efficiency in terms of *both d* and *f*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章到目前为止讨论的问题中，我们使用单一变量*n*来表示输入的量：*n* 可能是交换的次数、停车位的数量、电子邮件地址的数量或牛的数量。但在贝克奖金问题中，我们处理的是二维输入，因此需要*两个*变量来表示其量。我们将第一个变量称为*d*，即天数；将第二个变量称为*f*，即特许经营商的数量。更正式地说，由于每个输入都有多个测试用例，我们将*d*设为天数的最大值，*f*设为特许经营商的最大数量。我们需要给出*两个d*和*f*的Big
    O效率。
- en: 'Our algorithm consists of three major components: reading the input, calculating
    the number of bonuses from the rows, and calculating the number of bonuses from
    the columns. Let’s take a look at each of these.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法包含三个主要部分：读取输入、从行中计算奖金数量、以及从列中计算奖金数量。让我们逐一查看这些部分。
- en: To read the input ❶, we perform *d* iterations of the outer loop. On each of
    these iterations we read a row and call split, which takes about *f* steps. We
    take another *f* steps to loop through the values and convert them to integers.
    In total, then, each of the *d* iterations performs a number of steps proportional
    to *f*. Reading the input therefore takes *O*(*df*) time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取输入 ❶，我们执行*d*次外循环。在每次迭代中，我们读取一行并调用split，这需要大约*f*步。我们还需要再执行*f*步来遍历这些值并将它们转换为整数。因此，每次*d*次迭代执行的步骤数与*f*成正比。因此，读取输入需要*O*(*df*)的时间。
- en: Now for the row bonuses ❷. The outer loop here loops *d* times. Each of these
    iterations calls sum, which takes *f* steps because it has to add up *f* values.
    Like reading the input, then, this part of the algorithm is *O*(*df*).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看行奖励 ❷。外循环在这里循环*d*次。每次迭代都会调用sum，这需要*f*步，因为它必须加总*f*个值。因此，像读取输入一样，这部分算法是*O*(*df*)。
- en: Finally, let’s look at the code for the column bonuses ❸. The outer loop loops
    *f* times. Each of those iterations leads to the inner loop iterating *d* times.
    The total here, again, is *O*(*df*).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看列奖励 ❸的代码。外循环循环*f*次。每次迭代都会导致内循环迭代*d*次。总的来说，这也是*O*(*df*)。
- en: Each component of this algorithm is *O*(*df*). Adding three *O*(*df*) components
    together yields an *O*(*df*) algorithm overall.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的每个组成部分是*O*(*df*)。将三个*O*(*df*)的组件加在一起，得到一个*O*(*df*)的算法。
- en: '**CONCEPT CHECK**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the big O efficiency of the following algorithm?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法的大O效率是多少？
- en: 'for i in range(m):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(m):'
- en: <do something that takes one step>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <执行一个需要一步的操作>
- en: 'for j in range(n):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(n):'
- en: <do something that takes one step>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <执行一个需要一步的操作>
- en: A. *O*(1)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: A. *O*(1)
- en: B. *O*(*n*)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: B. *O*(*n*)
- en: C. *O*(*n*^(*2*))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: C. *O*(*n*^(*2*))
- en: D. *O*(*m*+*n*)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: D. *O*(*m*+*n*)
- en: E. *O*(*mn*)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: E. *O*(*mn*)
- en: 'Answer: D. The first loop depends on *m*, and the second depends on *n*. The
    loops are sequential, not nested, so their work is added rather than multiplied.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：D。第一个循环依赖于*m*，第二个循环依赖于*n*。这些循环是顺序执行的，而不是嵌套的，所以它们的工作是相加的，而不是相乘的。
- en: Log Time
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对数时间
- en: In “Efficiency of Our Program” on [page 255](ch09.xhtml#ch09lev2sec18), we discussed
    the difference between linear search and binary search. A linear search finds
    a value in a list by searching the list from beginning to end. That’s an *O*(*n*)
    algorithm. It works whether or not the list is sorted. A binary search, by contrast,
    works only on a sorted list. But if you have a sorted list, then binary search
    is blazingly fast.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第255页](ch09.xhtml#ch09lev2sec18)的“我们的程序效率”部分，我们讨论了线性查找和二分查找之间的区别。线性查找通过从头到尾搜索列表来查找一个值。这是一个*O*(*n*)的算法。无论列表是否排序，它都能工作。相比之下，二分查找仅适用于已排序的列表。但如果你有一个已排序的列表，二分查找的速度非常快。
- en: Binary search works by comparing the value we’re searching for to the value
    at the middle of the list. If the value at the middle of the list is larger than
    the value we’re searching for, we continue searching in the left half of the list.
    If the value at the middle of the list is smaller than the value we’re searching
    for, we continue searching in the right half of the list. We keep doing this,
    ignoring half of the list each time, until we find the value that we’re looking
    for.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找的工作原理是将我们要查找的值与列表中间的值进行比较。如果列表中间的值大于我们要查找的值，我们就继续在列表的左半部分查找。如果列表中间的值小于我们要查找的值，我们就继续在列表的右半部分查找。我们一直这么做，每次忽略列表的一半，直到找到我们要查找的值为止。
- en: Suppose we use binary search to find a value in a list of 512 values. How many
    steps does it take? Well, after one step, we’ve ignored half the list, so we’re
    left with about 512 / 2 = 256 values. (It doesn’t matter whether our value is
    larger than half of the values in the list or smaller than half the values in
    the list; in each case, we ignore one half of the list.) After two steps, we’re
    left with 256 / 2 = 128 values. After three steps, we’re left with 128 / 2 = 64
    values. Continuing, after four steps we have 32 values, after five steps we have
    16 values, after six steps we have 8 values, after seven steps we have 4 values,
    after eight steps we have 2 values, and after nine steps we have only 1 value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用二分查找在一个包含512个值的列表中查找一个值。需要多少步呢？好吧，经过一步后，我们已经忽略了一半的列表，因此剩下大约512 / 2 = 256个值。（无论我们查找的值是否大于或小于列表中一半的值，在每种情况下，我们都会忽略列表的一半。）经过两步后，剩下256
    / 2 = 128个值。经过三步后，剩下128 / 2 = 64个值。继续下去，经过四步后剩下32个值，经过五步后剩下16个值，经过六步后剩下8个值，经过七步后剩下4个值，经过八步后剩下2个值，经过九步后只剩下1个值。
- en: 'Nine steps—that’s it! That’s way better than taking up to 512 steps using linear
    search. Binary search does far less work than a linear-time algorithm. But what
    kind of algorithm is it? It’s not constant time: while it takes very few steps,
    the number of steps does increase a little as the amount of input increases.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 九步——就这么多！比起使用线性查找最多需要 512 步，二分查找要好得多。二分查找的工作量远小于线性时间算法。那么它到底是什么类型的算法呢？它不是常数时间：虽然它只需要很少的步骤，但随着输入量的增加，步骤数会稍微增加。
- en: Binary search is an example of a *logarithmic-time* or *log-time* algorithm.
    In big O notation, we say that a logarithmic-time algorithm is *O*(log *n*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找是一个 *对数时间* 或 *对数时间* 算法的例子。在大 O 符号中，我们说对数时间算法是 *O*(log *n*)。
- en: Logarithmic-time refers to the logarithm function in mathematics. Given a number,
    this function tells you the number of times you have to divide that number by
    a base to get to 1 or less. The base we typically use in computer science is 2,
    so we’re looking for the number of times you have to divide a number by 2 to get
    to 1 or less. For example, it takes 9 divisions by 2 to take 512 down to 1\. We
    write this as log[2] 512 = 9.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对数时间指的是数学中的对数函数。给定一个数字，该函数告诉你需要多少次将这个数字除以一个基数才能得到 1 或更小的数值。我们在计算机科学中通常使用的基数是
    2，所以我们要找的是将一个数字除以 2，直到得到 1 或更小的次数。例如，将 512 除以 2 需要 9 次。我们写作 log[2] 512 = 9。
- en: The logarithm function is the inverse of the exponential function, the latter
    of which may be more familiar to you. Another way to calculate log[2] 512 is to
    find the power *p* so that 2*^p* = 512\. Since 2⁹ = 512, we confirm that log[2]
    512 = 9.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对数函数是指数函数的反函数，后者你可能会更熟悉。计算 log[2] 512 的另一种方法是找到一个指数 *p*，使得 2*^p* = 512。由于 2⁹
    = 512，我们确认 log[2] 512 = 9。
- en: It’s shocking how slowly the logarithm function grows. For example, consider
    a list of one million values. How many steps would binary search take to search
    that? It takes log[2] 1,000,000 steps, which is only about 20\. Logarithmic-time
    is much closer to constant-time than it is to linear-time. It’s a huge win any
    time you can replace a linear-time algorithm by a logarithmic-time one.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 令人震惊的是对数函数增长得如此缓慢。例如，考虑一个包含一百万个值的列表。二分查找需要多少步才能查找这个列表？它只需要 log[2] 1,000,000
    步，约为 20 步。对数时间比线性时间更接近常数时间。每当你能用对数时间算法替换线性时间算法时，这都是一次巨大的胜利。
- en: n log n Time
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: n log n 时间
- en: 'In [Chapter 5](ch05.xhtml#ch05), we solved the Village Neighborhood problem.
    I’ve reproduced our solution from [Listing 5-1](ch05.xhtml#ch05ex01) here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](ch05.xhtml#ch05)中，我们解决了村庄邻里问题。我在这里重现了我们在[列表 5-1](ch05.xhtml#ch05ex01)中的解法：
- en: n = int(input())
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: positions = []
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: '❶ for i in range(n):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for i in range(n):'
- en: positions.append(int(input()))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(int(input()))
- en: ❷ positions.sort()
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ positions.sort()
- en: left = (positions[1] - positions[0]) / 2
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: left = (positions[1] - positions[0]) / 2
- en: right = (positions[2] - positions[1]) / 2
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: right = (positions[2] - positions[1]) / 2
- en: min_size = left + right
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = left + right
- en: '❸ for i in range(2, n - 1):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for i in range(2, n - 1):'
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: left = (positions[i] - positions[i - 1]) / 2
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: right = (positions[i + 1] - positions[i]) / 2
- en: size = left + right
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: size = left + right
- en: 'if size < min_size:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'if size < min_size:'
- en: min_size = size
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: min_size = size
- en: print(min_size)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: print(min_size)
- en: Looks like a linear-time algorithm, eh? I mean, there’s a linear-time loop to
    read the input ❶ and another linear-time loop to find the minimum size ❸. Is this
    code *O*(*n*), then?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是线性时间算法，对吧？我是说，那里有一个线性时间循环用来读取输入 ❶，另一个线性时间循环用来找到最小大小 ❸。那这段代码是 *O*(*n*) 吗？
- en: It’s too early to tell! The reason is that we haven’t yet taken into account
    that we sort the positions ❷. We can’t just ignore that; we need to know about
    the efficiency of sorting. As we’ll see, sorting is slower than linear time. So,
    since sorting is the slowest step here, whatever the efficiency is of sorting
    will be the efficiency overall.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下结论还为时过早！原因是我们还没有考虑到排序位置 ❷ 的因素。我们不能忽视这一点；我们需要了解排序的效率。正如我们将看到的，排序比线性时间慢。所以，由于排序是这里最慢的步骤，排序的效率将决定整体的效率。
- en: 'Programmers and computer scientists have devised many sorting algorithms, and
    these algorithms can roughly be divided into two groups. The first group consists
    of algorithms that take *O*(*n*²) time. The three most famous of these sorting
    algorithms are bubble sort, selection sort, and insertion sort. You can learn
    more about these sorting algorithms on your own if you like, but we won’t need
    to know anything about them to continue here. All we have to keep in mind is that
    *O*(*n*²) can be quite slow. For example, to sort a list of 10,000 values, an
    *O*(*n*²) sorting algorithm would take about 10,000² = 100,000,000 steps. As we
    know, this would take any computer at least a few seconds. That’s pretty disappointing:
    sorting 10,000 values feels like something computers should be able to do almost
    instantly.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和计算机科学家们设计了许多排序算法，这些算法大致可以分为两类。第一类是需要 *O*(*n*²) 时间的算法。这三种最著名的排序算法是冒泡排序、选择排序和插入排序。如果你愿意，可以自己深入了解这些排序算法，但在这里我们不需要了解它们的细节。我们只需要记住的是，*O*(*n*²)
    的算法可能非常慢。例如，要对一个包含 10,000 个值的列表进行排序，*O*(*n*²) 排序算法大约需要 10,000² = 100,000,000 步。正如我们所知，这样的排序算法至少需要几秒钟的时间才能完成。这个结果相当令人失望：排序
    10,000 个值似乎应该是计算机能够几乎瞬间完成的任务。
- en: 'Enter the second group of sorting algorithms. This group consists of algorithms
    that take only *O*(*n* log *n*) time. There are two famous sorting algorithms
    in this group: quick sort and merge sort. Again, you’re free to look them up if
    you like, but we don’t need the details here.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 进入第二类排序算法。这类算法只需要 *O*(*n* log *n*) 时间。这个类别中有两种著名的排序算法：快速排序和归并排序。同样，如果你愿意，可以查阅它们的相关资料，但在这里我们不需要详细了解。
- en: What does *O*(*n* log *n*) mean? Don’t let the notation confuse you. It’s just
    the multiplication of *n* by log *n*. Let’s try this out on a list of 10,000 values.
    Here, we have 10,000 * log 10,000 steps, which is only about 132,877\. This is
    a very small number of steps, especially compared to the 100,000,000 steps taken
    by the *O*(*n*²) sorting algorithms.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*O*(*n* log *n*) 是什么意思？别让这个符号搞混了。它只是 *n* 乘以 log *n*。我们来对一个包含 10,000 个值的列表进行尝试。这里，我们有
    10,000 * log 10,000 步，这大约是 132,877 步。这是一个非常小的步骤数，尤其是与 *O*(*n*²) 排序算法的 100,000,000
    步相比。'
- en: 'Now we can ask the question we really care about: what sorting algorithm is
    Python using when we ask it to sort a list? Answer: an *O*(*n* log *n*) one! (It’s
    called Timsort. If you’d like to learn more, start with merge sort, because Timsort
    is a souped-up merge sort.) No slow *O*(*n*²) sorting here. In general, sorting
    is so fast—so close to linear time—that we can use it without affecting our efficiency
    too much.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以问一个我们真正关心的问题：当我们让 Python 对列表进行排序时，它使用的是哪种排序算法？答案是：一种 *O*(*n* log *n*)
    的算法！（它被称为 Timsort。如果你想了解更多，可以从归并排序开始，因为 Timsort 是改进版的归并排序。）这里没有慢速的 *O*(*n*²) 排序算法。一般来说，排序非常快速—几乎接近线性时间—因此我们可以使用它而不会对效率产生太大影响。
- en: Returning to Village Neighborhood, now we see that its efficiency is not *O*(*n*)
    but, because of the sort, *O*(*n* log *n*). In practice, an *O*(*n* log *n*) algorithm
    only does a little more work than an *O*(*n*) algorithm and far less than an *O*(*n*²)
    algorithm. If your goal is to design an *O*(*n*) algorithm, designing one that’s
    *O*(*n* log *n*) is probably good enough.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到村庄邻里问题，现在我们看到它的效率不是 *O*(*n*)，而是由于排序的原因，变成了 *O*(*n* log *n*)。实际上，*O*(*n* log
    *n*) 算法比 *O*(*n*) 算法多做一点工作，而远比 *O*(*n*²) 算法少得多。如果你的目标是设计一个 *O*(*n*) 算法，那么设计一个
    *O*(*n* log *n*) 算法可能已经足够好了。
- en: Handling Function Calls
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理函数调用
- en: Starting in [Chapter 6](ch06.xhtml#ch06), we wrote our own functions to help
    us design larger programs. In our big O analysis, we need to be careful to include
    the work done when we call these functions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [第六章](ch06.xhtml#ch06) 开始，我们编写了自己的函数，帮助我们设计更大的程序。在我们的大 O 分析中，我们需要小心地包括在调用这些函数时所做的工作。
- en: 'Let’s revisit the Card Game problem from [Chapter 6](ch06.xhtml#ch06). We solved
    it in [Listing 6-1](ch06.xhtml#ch06ex01), and part of our solution involved calling
    our no_high function. I’ve reproduced that solution here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 [第六章](ch06.xhtml#ch06) 中的扑克牌问题。我们在 [清单 6-1](ch06.xhtml#ch06ex01) 中解决了这个问题，解决方案的一部分涉及调用我们的
    no_high 函数。我在这里重新呈现了该解决方案：
- en: NUM_CARDS = 52
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: NUM_CARDS = 52
- en: '❶ def no_high(lst):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ def no_high(lst):'
- en: '"""'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: lst is a list of strings representing cards.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: lst 是一个表示扑克牌的字符串列表。
- en: Return True if there are no high cards in lst, False otherwise.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 lst 中没有高牌，则返回 True，否则返回 False。
- en: '"""'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if ''jack'' in lst:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ''jack'' in lst:'
- en: return False
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'if ''queen'' in lst:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ''queen'' in lst:'
- en: return False
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'if ''king'' in lst:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ''king'' in lst:'
- en: return False
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'if ''ace'' in lst:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ''ace'' in lst:'
- en: return False
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: deck = []
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(NUM_CARDS):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: deck.append(input())
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: score_a = 0
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: score_b = 0
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: player = 'A'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for i in range(NUM_CARDS):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: card = deck[i]
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: points = 0
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: remaining = NUM_CARDS - i - 1
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'if card == ''jack'' and remaining >= 1 and no_high(deck[i+1:i+2]):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: points = 1
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'elif card == ''queen'' and remaining >= 2 and no_high(deck[i+1:i+3]):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: points = 2
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'elif card == ''king'' and remaining >= 3 and no_high(deck[i+1:i+4]):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: points = 3
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'elif card == ''ace'' and remaining >= 4 and no_high(deck[i+1:i+5]):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: points = 4
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'if points > 0:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: print(f'Player {player} scores {points} point(s).')
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'if player == ''A'':'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: score_a = score_a + points
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: player = 'B'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: score_b = score_b + points
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: player = 'A'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f''Player A: {score_a} point(s).'')'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f''Player B: {score_b} point(s).'')'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use *n* to represent the number of cards. The no_high function ❶ takes
    a list and uses in on it, so we might conclude that it is *O*(*n*) time. (in may
    have to search the whole list to find what it’s looking for, after all.) However,
    we only ever call no_high with lists of constant size—maximum four cards—so we
    can treat each call of no_high as *O*(1) time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the efficiency of no_high, we can determine the big O
    efficiency of the complete program. We begin with a loop that takes *O*(*n*) time
    to read the cards ❷. We then enter another loop that iterates *n* times ❸. Each
    iteration takes just a constant number of steps, possibly including a call of
    no_high that takes a constant number of steps. This loop, then, takes *O*(*n*)
    time. The program therefore consists of two *O*(*n*) pieces, so it is *O*(*n*)
    overall.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to accurately judge the amount of work performed when a function
    is called. As you just saw with no_high, this may involve looking at both the
    function itself and the context in which it is called.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of the following algorithm?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(lst):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(lst)):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: lst[i] = lst[i] + 1
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Assume that lst refers to a list of numbers
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for i in range(len(lst)):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: f(lst)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: C. *O*(*n*^(*2*))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. The loop in the main program iterates *n* times. On each iteration,
    we call function f, which itself has a loop that iterates *n* times.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The algorithms that do the least work are *O*(1), followed by *O*(log *n*),
    followed by *O*(*n*), followed by *O*(*n* log *n*). Have you solved a problem
    using one of these four? If so, you’re probably done. If not, then depending on
    the time limit, you may have more work to do.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: We’re now going to look at two problems where a straightforward solution will
    not be efficient enough—it won’t run within the time limit. Using what we just
    learned about big O, we’ll be able to predict this inefficiency even without implementing
    the code! We’ll then work on a faster solution and implement it to solve the problem
    within the time limit.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #24: Longest Scarf'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this problem, we’ll determine the longest desired scarf that we can produce
    by cutting an initial scarf. After reading the following description, pause: how
    would you solve it? Can you come up with multiple algorithms whose efficiency
    you’d like to investigate?'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将通过剪裁初始围巾来确定我们能够制作出多长的亲戚想要的围巾。阅读以下描述后，停下来思考：你会如何解决这个问题？你能提出多个算法，并评估它们的效率吗？
- en: This is DMOJ problem dmopc20c2p2.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题 dmopc20c2p2。
- en: The Challenge
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: You have a scarf whose length is *n* feet, and each foot has a specific color.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一条长度为 *n* 英尺的围巾，每只脚都有特定的颜色。
- en: You also have *m* relatives. Each relative indicates what their desired scarf
    looks like by specifying the color of its first foot and last foot.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有 *m* 个亲戚。每个亲戚通过指定第一只脚和最后一只脚的颜色来表示他们想要的围巾。
- en: Your goal is to cut your original scarf in such a way as to produce the longest
    desired scarf for one of your relatives.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是通过剪裁原始围巾来制作出最长的亲戚想要的围巾。
- en: Input
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括以下几行：
- en: A line containing the integer scarf length *n* and integer number of relatives
    *m*, separated by a space. *n* and *m* are each between 1 and 100,000.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数围巾长度 *n* 和亲戚数量 *m*，用空格分隔。*n* 和 *m* 的范围都是1到100,000之间。
- en: A line containing *n* integers separated by spaces. Each integer specifies the
    color of one foot of scarf in order from the first foot to the last foot. Each
    integer is between 1 and 1,000,000.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含以空格分隔的 *n* 个整数。每个整数指定了围巾一只脚的颜色，从第一只脚到最后一只脚依次排列。每个整数的范围是1到1,000,000之间。
- en: '*m* lines, one per relative, containing two integers separated by a space.
    These numbers describe the relative’s desired scarf: the first integer is the
    desired color of the first foot, and the second integer is the desired color of
    the last foot.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 行，每行代表一个亲戚，包含两个以空格分隔的整数。这些数字描述了亲戚想要的围巾：第一个整数是第一只脚的颜色，第二个整数是最后一只脚的颜色。'
- en: Output
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the length of the longest desired scarf that can be produced by cutting
    your original scarf.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 输出通过剪裁原始围巾可以制作出的最长想要的围巾的长度。
- en: The time limit for solving the test cases is 0.4 seconds.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试案例的时间限制为0.4秒。
- en: Exploring a Test Case
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试案例
- en: 'Let’s make sure we know exactly what is being asked by working through a small
    test case. Here it is:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小的测试案例来确保我们准确理解问题。测试案例如下：
- en: 6 3
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 6 3
- en: 18 4 4 2 1 2
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 18 4 4 2 1 2
- en: 1 2
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2
- en: 4 2
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 4 2
- en: 18 4
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 18 4
- en: We have a scarf that’s 6 feet long and three relatives. The color of each foot
    of the scarf is 18, 4, 4, 2, 1, and 2\. What’s the longest desired scarf we can
    make?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一条长6英尺的围巾和三个亲戚。围巾每只脚的颜色依次为18、4、4、2、1、2。我们能做出多长的亲戚想要的围巾呢？
- en: 'The first relative wants a scarf whose first foot is color 1 and whose last
    foot is color 2\. The best we can do is give this relative a 2-foot scarf: the
    2 feet (colors 1 and 2) at the end of the scarf.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个亲戚想要一条围巾，第一只脚是1号颜色，最后一只脚是2号颜色。我们能给这个亲戚的最好围巾是2英尺长：围巾末端的2只脚（颜色1和2）。
- en: 'The second relative wants a scarf whose first foot is color 4 and whose last
    foot is color 2\. We can give them a 5-foot scarf: 4, 4, 2, 1, 2.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个亲戚想要一条围巾，第一只脚是4号颜色，最后一只脚是2号颜色。我们可以给他们一条5英尺的围巾：4、4、2、1、2。
- en: 'The third relative wants a scarf whose first foot is color 18 and whose last
    foot is color 4\. We can give them a 3-foot scarf: 18, 4, 4.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个亲戚想要一条围巾，第一只脚是18号颜色，最后一只脚是4号颜色。我们可以给他们一条3英尺的围巾：18、4、4。
- en: The maximum length of a desired scarf that we can make is 5, so that’s the answer
    for this test case.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够制作出的最大长度的想要围巾是5英尺，因此这是这个测试案例的答案。
- en: Algorithm 1
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法 1
- en: 'The way we just processed that test case might immediately suggest to you an
    algorithm that we can use to solve this problem. Namely, we should be able to
    go through the relatives and figure out the maximum length of a desired scarf
    for each one. For example, the maximum length for the first relative might be
    2, so we remember that. The maximum length for the second relative might be 5\.
    That’s longer than 2, so we remember the 5\. The maximum length for the third
    relative might be 3\. This isn’t greater than 5—no change here. If this reminds
    you of a complete-search algorithm ([Chapter 9](ch09.xhtml#ch09)): good, because
    it is one!'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才处理这个测试用例的方法，可能会立即向你暗示一种算法，帮助我们解决这个问题。也就是说，我们应该能够遍历这些亲戚，找出每个人希望的最长围巾的长度。例如，第一个亲戚的最大长度可能是
    2，那么我们就记住这个值。第二个亲戚的最大长度可能是 5。这比 2 长，所以我们记住 5。第三个亲戚的最大长度可能是 3。这没有比 5 长——所以不需要更改。如果这让你想起了一个完整搜索算法（[第
    9 章](ch09.xhtml#ch09)）：很好，因为它确实是一个完整搜索算法！
- en: There are *m* relatives. If we knew how long it would take us to process each
    relative, then we’d be able to work out the big O efficiency we’d be dealing with.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有 *m* 个亲戚。如果我们知道处理每个亲戚需要多长时间，那么我们就能计算出我们所处理的大 O 效率。
- en: 'Here’s an idea: for each relative, let’s find the leftmost index of the color
    of the first foot and the rightmost index of the color of the last foot. Once
    we had these indices, then no matter how long the scarf, we could use these indices
    to quickly determine the length of the longest desired scarf for this relative.
    For example, if the leftmost index of the color of the first foot is 100 and the
    rightmost index of the color of the last foot is 110, then their longest desired
    scarf is 110 – 100 + 1 = 11.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个想法：对于每个亲戚，我们可以找到第一段颜色的最左边索引和最后一段颜色的最右边索引。一旦我们得到了这些索引，无论围巾有多长，我们都可以利用这些索引快速确定这个亲戚希望的最长围巾长度。例如，如果第一段颜色的最左边索引是
    100，最后一段颜色的最右边索引是 110，那么他们希望的最长围巾长度是 110 – 100 + 1 = 11。
- en: Depending on how we try to find these indices, we might be lucky and find them
    quickly. For example, we might scan from the left for the leftmost index of the
    color of the first foot and scan from the right for the rightmost index of the
    color of the last foot. Then, if the color of the first foot is near the beginning
    of the scarf and the color of the last foot is near the end, we’ll discover these
    indices very quickly.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们尝试寻找这些索引的方式，我们可能会幸运地快速找到它们。例如，我们可以从左扫描第一段颜色的最左边索引，再从右扫描最后一段颜色的最右边索引。然后，如果第一段颜色靠近围巾的开头，最后一段颜色靠近围巾的结尾，我们将非常快地发现这些索引。
- en: We might not be lucky, though. Finding one or both of the indices could take
    up to *n* steps. For example, suppose that a relative wants a scarf whose first
    foot is a color that shows up right at the end of the scarf or that doesn’t show
    up in the scarf at all. We will have to check the entire *n* feet of the scarf,
    one foot at a time, to figure this out.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能并不那么幸运。找到一个或两个索引可能需要 *n* 步。例如，假设一个亲戚想要一条围巾，其第一段的颜色出现在围巾的最后部分，或者根本没有出现在围巾中。我们需要检查整个
    *n* 英尺的围巾，一次检查一段，以弄清楚这一点。
- en: So, about *n* steps per relative. That’s linear time, and we know that linear
    time is fast. Are we good? No, because in this case the linear-time work is far
    more menacing than it may appear. Remember that we’d be doing this *O*(*n*) work
    for each of the *m* relatives. We therefore have an *O*(*mn*) algorithm overall.
    *m* and *n* can be as big as 100,000\. So, *mn* can be as big as 100,000 *** 100,000
    = 10,000,000,000\. That’s 10 billion! Given that we can do about five million
    operations per second and that our time limit is 0.4 seconds . . . yeah, we’re
    not even close. There’s no need to implement this algorithm. We’re certain that
    it will time out on large test cases. We may as well move on and spend our time
    implementing something else. (If you’re nevertheless curious about the code, please
    see the online resources associated with the book. Just remember that without
    even looking at the code, we already figured out that it would be too slow. The
    power of big O analysis is in helping us understand whether an algorithm is doomed
    even before we implement it.)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，每个亲戚大约需要 *n* 步。这是线性时间，我们知道线性时间是快速的。我们没问题吧？不，因为在这种情况下，线性时间的工作量比看起来更具威胁。记住，对于每个亲戚，我们都要执行
    *O*(*n*) 的工作。这样总的时间复杂度就是 *O*(*mn*)。*m* 和 *n* 最大可以达到 100,000。所以，*mn* 最大可以达到 100,000
    *** 100,000 = 10,000,000,000。那是 100 亿！考虑到我们每秒可以执行大约五百万次操作，而我们的时间限制是 0.4 秒……是的，我们完全不行。这个算法根本无法实现。我们已经确信它会在大型测试用例中超时。不如直接放弃，去实现其他东西吧。（如果你仍然对代码感兴趣，请参考书本相关的在线资源。只要记住，即使不看代码，我们也早就知道它会太慢。大
    O 分析的威力就在于帮助我们在实现之前就能知道一个算法是否注定失败。）
- en: Algorithm 2
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法 2
- en: We’re going to have to somehow process each of the relatives—there’s no getting
    around that. What we’ll focus on optimizing, then, is the amount of work that
    we do per relative. Unfortunately, processing a relative in the way we did in
    the previous section may cause us to check over a huge portion of the scarf. It’s
    this searching through the scarf, once per relative, that’s crushing us. We need
    to get that searching under control.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以某种方式处理每一个亲戚——这是无法避免的。那么，我们需要优化的就是每个亲戚的处理工作量。不幸的是，像上一节那样处理亲戚，可能会让我们检查围巾的很大一部分。正是这种针对每个亲戚逐一检查围巾的操作，才让我们感到吃力。我们需要控制这个搜索过程。
- en: 'Suppose that we could look through the scarf only once, up-front, before we
    knew anything about what the relatives wanted. We could remember two things about
    each color in the scarf: its leftmost index and its rightmost index. Then, no
    matter what each relative wants, we could figure out the maximum length of their
    desired scarf using the left and right indices that we had already stored.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只能在一开始就看一次围巾，在我们还不知道亲戚们想要什么之前。我们可以记住每种颜色在围巾中的两个信息：它最左边的索引和最右边的索引。然后，无论每个亲戚想要什么，我们都可以通过我们已存储的左右索引来计算他们所需围巾的最大长度。
- en: 'For example, assume we have this scarf:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设我们有这样一条围巾：
- en: 18 4 4 2 1 2
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 18 4 4 2 1 2
- en: 'We would store the following information for it:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会存储以下信息：
- en: '| **Color** | **Leftmost index** | **Rightmost index** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | **最左索引** | **最右索引** |'
- en: '| --- | --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 4 | 4 |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 4 | 4 |'
- en: '| 2 | 3 | 5 |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 5 |'
- en: '| 4 | 1 | 2 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 | 2 |'
- en: '| 18 | 0 | 0 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 0 | 0 |'
- en: Suppose that a relative wants a scarf whose first foot is color 1 and whose
    last foot is color 2\. We look up the leftmost index for color 1, which is 4,
    and the rightmost index for color 2, which is 5\. We then calculate 5 – 4 + 1
    = 2, and that’s the length of the longest desired scarf for this relative.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个亲戚想要的围巾的第一段是颜色 1，最后一段是颜色 2。我们查找颜色 1 的最左索引是 4，颜色 2 的最右索引是 5。然后，我们计算 5 - 4
    + 1 = 2，这就是该亲戚所需围巾的最大长度。
- en: 'Amazing: no matter how long the scarf, we can just do a quick calculation for
    each relative. No more running through the scarf over and over. The only tricky
    thing here is how to calculate all the leftmost and rightmost indices for the
    colors and to do so by looking through the scarf only once.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 太神奇了：不管围巾多长，我们只需为每个亲戚做一个快速的计算。不再需要一次又一次地跑遍围巾。唯一的难点在于如何计算每种颜色的最左和最右索引，并且只看一次围巾。
- en: The code is presented in [Listing 10-1](ch10.xhtml#ch10ex01). Try to figure
    out how the leftmost_index and rightmost_index dictionaries are constructed before
    you continue reading my explanation that follows.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以参考 [清单 10-1](ch10.xhtml#ch10ex01)。在继续阅读我的解释之前，试着理解最左索引和最右索引字典是如何构建的。
- en: lst = input().split()
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input().split()
- en: n = int(lst[0])
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(lst[0])
- en: m = int(lst[1])
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: m = int(lst[1])
- en: scarf = input().split()
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: scarf = input().split()
- en: 'for i in range(n):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: scarf[i] = int(scarf[i])
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: scarf[i] = int(scarf[i])
- en: ❶ leftmost_index = {}
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ leftmost_index = {}
- en: ❷ rightmost_index = {}
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ rightmost_index = {}
- en: '❸ for i in range(n):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for i in range(n):'
- en: color = scarf[i]
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: color = scarf[i]
- en: '❹ if not color in leftmost_index:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果颜色不在最左索引中：
- en: leftmost_index[color] = i
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: leftmost_index[color] = i
- en: rightmost_index[color] = i
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: rightmost_index[color] = i
- en: '❺ else:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 否则：
- en: rightmost_index[color] = i
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: rightmost_index[color] = i
- en: max_length = 0
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: max_length = 0
- en: 'for i in range(m):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(m):'
- en: relative = input().split()
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: relative = input().split()
- en: first = int(relative[0])
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: first = int(relative[0])
- en: last = int(relative[1])
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: last = int(relative[1])
- en: 'if first in leftmost_index and last in leftmost_index:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'if first in leftmost_index and last in leftmost_index:'
- en: ❻ length = rightmost_index[last] - leftmost_index[first] + 1
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ length = rightmost_index[last] - leftmost_index[first] + 1
- en: 'if length > max_length:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果长度大于最大长度：
- en: max_length = length
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: max_length = length
- en: print(max_length)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: print(max_length)
- en: '*Listing 10-1: Solving Longest Scarf, algorithm 2*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：解决最长围巾问题，算法 2*'
- en: 'This solution uses two dictionaries: one to keep track of the leftmost index
    for each color ❶ and one to keep track of the rightmost index for each color ❷.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案使用了两个字典：一个用于跟踪每个颜色的最左索引 ❶，另一个用于跟踪每个颜色的最右索引 ❷。
- en: 'As promised, we look at each foot of the scarf just once ❸. Here’s how we keep
    the leftmost_index and rightmost_index dictionaries up-to-date:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺，我们只检查一次每个围巾的脚 ❸。下面是我们如何保持 leftmost_index 和 rightmost_index 字典的更新：
- en: If the color of the current foot has never been seen before ❹, then the current
    index serves as both the leftmost and rightmost index for this color.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前脚的颜色以前从未出现过 ❹，那么当前索引既是该颜色的最左索引也是最右索引。
- en: Otherwise, the color of the current foot has been seen before ❺. We don’t want
    to update the leftmost index for this color, because the current index is to the
    right of the old one. We *do* want to update the rightmost index, though, because
    we have found an index to the right of the old one.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，当前脚的颜色之前已经出现过 ❺。我们不想更新这个颜色的最左索引，因为当前索引在旧索引的右侧。不过，我们*确实*希望更新最右索引，因为我们找到了一个位于旧索引右侧的索引。
- en: 'Now for the payoff: for each relative, we can simply look up the leftmost and
    rightmost indices from these dictionaries ❻. The maximum length of the desired
    scarf is the rightmost index of the color of the last foot, minus the leftmost
    index of the color of the first foot, plus one.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了回报的时候：对于每一个相对位置，我们可以简单地从这些字典中查找最左和最右的索引 ❻。所需围巾的最大长度是最后一只脚的颜色的最右索引减去第一只脚的颜色的最左索引，再加一。
- en: As I’ll argue now, this algorithm is far better than algorithm 1\. Reading the
    scarf takes *O*(*n*) time, as does processing the scarf ’s feet. That’s *O*(*n*)
    time so far. We then take a constant number of steps to process each relative
    (not *n* steps like before!), so that’s *O*(*m*) time. In total, we have an *O*(*m*
    + *n*) algorithm, rather than an *O*(*mn*) algorithm. Given that *m* and *n* can
    be at most 100,000, we’re doing only about 100,000 + 100,000 = 200,000 steps,
    easily done within the time limit. You can submit our code to the judge to prove
    it!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我现在所要论证的，这个算法比算法1要好得多。读取围巾的过程需要 *O*(*n*) 时间，处理围巾的脚也需要 *O*(*n*) 时间。到目前为止是 *O*(*n*)
    时间。然后我们花常数时间来处理每个相对位置（不像之前那样是 *n* 步！），所以是 *O*(*m*) 时间。总的来说，我们有一个 *O*(*m* + *n*)
    的算法，而不是 *O*(*mn*) 算法。考虑到 *m* 和 *n* 最大可以是 100,000，我们总共只需大约 100,000 + 100,000 =
    200,000 步，完全能够在时间限制内完成。你可以提交我们的代码给裁判以证明这一点！
- en: 'Problem #25: Ribbon Painting'
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #25：彩带涂色'
- en: Here’s another problem where the first algorithm that we might come up with
    is too slow. We won’t waste much time on that algorithm, though, because our big
    O analysis will tell us all we need to know before we consider implementing the
    code. We’ll then spend our time designing a faster algorithm.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个问题，其中我们可能首先想到的算法过于缓慢。然而，我们不会在这个算法上浪费太多时间，因为我们的时间复杂度分析会在我们考虑实现代码之前告诉我们所有需要知道的信息。然后，我们将花时间设计一个更快的算法。
- en: This is DMOJ problem dmopc17c4p1.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题dmopc17c4p1。
- en: The Challenge
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: You have a purple ribbon whose length is *n* units. The first unit goes from
    position 0 up to but not including position 1, the second unit goes from position
    1 up to but not including position 2, and so on. You then carry out *q* paint
    strokes, each of which colors a segment of the ribbon blue.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一条紫色的彩带，长度为 *n* 单位。第一单位从位置 0 到不包括位置 1，第二单位从位置 1 到不包括位置 2，以此类推。然后你进行 *q* 次涂色操作，每次操作将彩带的一段涂成蓝色。
- en: Your goal is to determine the number of units of the ribbon that are still purple
    and the number of units of the ribbon that are now blue.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the integer ribbon length *n* and integer number of paint
    strokes *q*, separated by a space. *n* and *q* are each between 1 and 100,000.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* lines, one per paint stroke, containing two integers separated by a space.
    The first integer gives the starting position of the paint stroke; the second
    gives the ending position of the paint stroke. The starting position is guaranteed
    to be less than the ending position; each integer is between 0 and *n*. The paint
    stroke goes from the starting position up to but not including the ending position.
    As a quick example here, if a paint stroke has a starting position of 5 and an
    ending position of 12, then the stroke paints the ribbon from position 5 up to
    but not including position 12.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of units of the ribbon that are still purple, a space, and
    the number of units of the ribbon that are now blue.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is 2 seconds.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a small test case. This test case will not only ensure that we’ve
    interpreted the problem correctly but also highlight the perils of a naive algorithm.
    Here it is:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 20 4
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 18 19
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 4 16
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 4 14
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 5 12
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Our ribbon’s length is 20, and there are four paint strokes. How much of the
    ribbon do our paint strokes turn blue?
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The first paint stroke paints one unit blue, the one that starts at position
    18.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The second paint stroke paints the units of ribbon starting at positions 4,
    5, 6, 7, and so on, all the way up to position 15\. That’s 12 units painted blue
    by this stroke, and 13 blue units in total.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The third paint stroke paints 10 units blue. But all of those units are already
    blue from the second paint stroke! It would be a colossal waste of time indeed
    if we spent time “painting” anything with this paint stroke. Whatever algorithm
    we come up with better not fall into this time-wasting trap.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth paint stroke paints 7 units blue. But again: all of these units
    are already blue!'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re done painting, and we have 13 blue units. There are 20 – 13 = 7 remaining
    purple units, so the correct output for this test case is:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 7 13
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum length of the ribbon is 100,000, and the maximum number of paint
    strokes is 100,000\. Recall algorithm 1 from when we solved Longest Scarf, where
    we learned that an *O*(*mn*) algorithm was too slow with these bounds. Similarly,
    here, an *O*(*nq*) algorithm would be inadequate, as it would not finish within
    the time limit on large test cases.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: This means that we cannot afford to process each unit that is painted by each
    paint stroke. It would be nice if we could more easily focus on only the *new*
    units that are painted blue by a paint stroke. Then we could go through each paint
    stroke and add up the number of blue units that it contributes.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Fair enough, but how can we determine the contribution of each paint stroke?
    That’s tricky, because bits and pieces of the next paint stroke may have already
    been painted blue by previous paint strokes.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: This situation is made much simpler, however, if we sort the paint strokes first.
    Remember from “n log n Time” earlier in this chapter that sorting is extremely
    fast, taking only *O*(*n* log *n*) time. There’s no efficiency concern in using
    sorting, so let’s understand why sorting helps us here.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting the paint strokes from the test case in the prior section gives us
    the following list of paint strokes:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 4 14
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 4 16
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 5 12
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 18 19
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Now that the paint strokes are sorted, we can efficiently process them. As we
    do so, we’ll store the rightmost position of any paint stroke that we’ve processed
    so far. We’ll start this rightmost position off at 0 to indicate that we haven’t
    painted anything.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Our first paint stroke paints 14 – 4 = 10 units blue. Now our stored rightmost
    position is 14.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Our second paint stroke paints 12 units blue, yes, but how many of those 12
    does it turn from purple to blue? After all, it overlaps the previous paint stroke,
    so some of these units were blue already. We can calculate the number of new blue
    units by subtracting 14, our stored rightmost position, from 16, the ending position
    of the current paint stroke. This is how we ignore the units already painted blue
    by previous paint strokes. So, there are 16 – 14 = 2 new blue units and 12 blue
    units in total. Crucially, we just figured this out without processing the individual
    units of this paint stroke. Before we continue, don’t forget to update our stored
    rightmost position to 16.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Our third paint stroke is like the second in that it starts prior to our stored
    rightmost position. Unlike the second paint stroke, however, its ending position
    does not extend past our stored rightmost position at all. So, this paint stroke
    adds no new blue units, and our stored rightmost position is still 16\. Again,
    we figured this out without grinding through each of this paint stroke’s positions!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with the fourth paint stroke. It does *not* add 19 – 16 = 3 new blue
    units. We have to treat this paint stroke differently because its starting position
    is to the right of our stored rightmost position. In this case, we don’t use the
    stored rightmost position at all, calculating instead 19 – 18 = 1 new blue unit,
    and 13 blue units in total. We also update our stored rightmost position to 19.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: The only question is how we sort the paint strokes in our Python code. We need
    to sort them by their starting position; if multiple paint strokes have the same
    starting position, then we want to sort those by their ending position.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we want to take a list like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19], [4, 16], [4, 14], [5, 12]]'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'and produce this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[[4, 14], [4, 16], [5, 12], [18, 19]]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Happily, as we discovered in “Task 4: Sort Boxes” in [Chapter 6](ch06.xhtml#ch06),
    the list sort method works in exactly this way. When given a list of lists, sort
    sorts using the first values in each list; when those values are tied, the lists
    are further sorted using the second values. Check it out:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '>>> strokes = [[18, 19], [4, 16], [4, 14], [5, 12]]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '>>> strokes.sort()'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '>>> strokes'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[[4, 14], [4, 16], [5, 12], [18, 19]]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm: check. Sorting: check. We’re in great shape! Just one more thing
    we’d like to know before we see the code: what will be its big O efficiency? We
    need to read the *q* queries; that takes *O*(*q*) time. Then we need to sort the
    queries; that takes *O*(*q* log *q*) time. Finally, we need to process the queries;
    that takes *O*(*q*) time. The slowest of these is the *O*(*q* log *q*) time for
    the sorting, so that’s our overall big O efficiency.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Now we have everything we need for a speedy solution. Check it out in [Listing
    10-2](ch10.xhtml#ch10ex02).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: lst = input().split()
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: n = int(lst[0])
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: q = int(lst[1])
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: strokes = []
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(q):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: stroke = input().split()
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: ❶ strokes.append([int(stroke[0]), int(stroke[1])])
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: ❷ strokes.sort()
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_position = 0
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: blue = 0
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'for stroke in strokes:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: stroke_start = stroke[0]
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: stroke_end = stroke[1]
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if stroke_start <= rightmost_position:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'if stroke_end > rightmost_position:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: ❹ blue = blue + stroke_end - rightmost_position
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_position = stroke_end
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '❺ else:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: ❻ blue = blue + stroke_end - stroke_start
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_position = stroke_end
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: print(n - blue, blue)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-2: Solving Ribbon Painting*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: We read each paint stroke, appending it as a list of two values to our strokes
    list ❶. We then sort all of the paint strokes ❷.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'We next need to process each paint stroke from left to right. There are two
    key variables that drive this processing: variable rightmost_position stores the
    rightmost position that we have painted so far, and variable blue stores the number
    of units that we have painted blue so far.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: To process a paint stroke, we need to know whether it starts before or after
    our stored rightmost position. Let’s think about each of these cases in turn.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'First: what do we do when the paint stroke starts before our stored rightmost
    position ❸? This paint stroke might give us some new blue units, but only if it
    extends past our stored rightmost position. If it does, then the new blue units
    are those between the stored rightmost position and the ending position of the
    paint stroke ❹.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Second: what do we do when the paint stroke starts after our stored rightmost
    position ❺? This time, the paint stroke is completely separate from the painting
    we have done so far; this entire paint stroke is a new blue segment. As such,
    the new blue units are those between the ending position and starting position
    of this paint stroke ❻.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Notice in each case that we also correctly update our stored rightmost position
    so that we’re ready to process any further paint strokes.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: That’s a wrap! Guided by our big O analysis, we were able to dismiss an algorithm
    whose implementation we knew would be too slow. We then thought about a second
    algorithm—and before implementing it, we knew it would be plenty fast. It’s time
    to submit our code to the judge and bask in our success.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about big O analysis. Big O is an important efficiency
    building block for further study of algorithm design. You’ll see it everywhere:
    in tutorials, in books, probably in your next job interview!'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: We also solved two problems where we needed to design very efficient algorithms.
    Not only were we able to do that, but we were also able to use big O to obtain
    a satisfying understanding of exactly why our code was so efficient.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. For each, use big O to determine whether
    your proposed algorithm is efficient enough to solve the problem within the time
    limit. You might also like to implement algorithms that you know are going to
    be too slow. That would give you extra practice solidifying your Python knowledge
    and confirm that your big O analysis was spot-on!
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Some of these problems are quite challenging. There are two reasons. First,
    you might agree based on your work throughout the book that coming up with *any*
    algorithm can be tough. Coming up with a faster algorithm can be even tougher.
    Second, this is the end of our time together, but only the beginning of the study
    of algorithms. I hope that these problems both help you appreciate what you’ve
    accomplished and offer evidence that there’s a lot more beyond this book if you
    want it.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem dmopc17c1p1, Fujo Neko (The problem talks about using fast input/output.
    Don’t ignore that!)
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci10c1p2, Profesor
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci19c4p1, Pod starim krovovima (Hint: to maximize the number
    of empty glasses, you want to put as much liquid as possible in the biggest glasses.)'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc20c1p2, Victor’s Moral Dilemma
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem avocadotrees, Avocado Trees!
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci11c5p2, Eko (Hint: the maximum number of trees is far fewer
    than the maximum number of heights. Consider each tree from tallest to shortest.)'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem wac6p2, Cheap Christmas Lights (Hint: don’t try flipping a switch
    each second—how would you know which one to flip? Instead, store them up, and
    use them all as soon as you can shut off all the lights that are on.)'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem ioi98p3, Party Lamps (Hint: all that matters for each button is
    whether it is pressed an even or odd number of times.)'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Longest Scarf is originally from the DMOPC ’14 March Contest. Ribbon Painting
    is originally from the DMOPC ’20 November Contest.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
