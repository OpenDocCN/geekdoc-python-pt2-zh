- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BIG O AND PROGRAM EFFICIENCY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'In the first seven chapters of this book, we focused on writing programs that
    were correct: for any valid input, we wanted our program to produce the desired
    output. In addition to correct code, though, we generally want efficient code,
    code that runs quickly even in the face of huge amounts of input. You may have
    received the occasional time limit exceeded error when working through the first
    seven chapters, but our first formal foray into program efficiency wasn’t until
    [Chapter 8](ch08.xhtml#ch08), when we solved Email Addresses. We saw there that
    sometimes we need to make our programs more efficient so that they can finish
    within a given time limit.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll first learn how programmers think and communicate about
    program efficiency. Then, we’ll study two problems where we’ll need to write efficient
    code: determining the most desired piece of a scarf and painting a ribbon.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'For each problem, we’ll see that our initial ideas lead to an algorithm that
    would not be efficient enough. But we’ll keep at it until we design a faster algorithm
    for the same problem, one that’s dramatically more efficient than before. This
    exemplifies a common workflow for programmers: first, come up with a correct algorithm;
    then, only if needed, make it faster.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The Problem with Timing
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each competitive programming problem that we solve in this book has a time limit
    on how long our program will be allowed to run. (I began including time limits
    in the problem descriptions of [Chapter 8](ch08.xhtml#ch08), when we started running
    into programming problems where efficiency is a serious concern.) If our program
    exceeds the time limit, then the judge terminates our program with a time limit
    exceeded error. A time limit is designed to prevent solutions that are too slow
    from passing the test cases. For example, perhaps we come up with a complete-search
    solution but the author of the problem has worked out a solution that’s much faster.
    That faster solution may be a variation of complete search, as it was when we
    solved the Cow Baseball problem in [Chapter 9](ch09.xhtml#ch09), or it may be
    a different approach entirely. Regardless, the time limit may be set such that
    our complete-search solution will not finish in time. As such, in addition to
    being correct, we may need our programs to be fast.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We can run a program to explore whether it is efficient enough. For example,
    think back to “Efficiency of Searching a List” in [Chapter 8](ch08.xhtml#ch08)
    when we tried to solve Email Addresses using a list. We ran code that used bigger
    and bigger lists to get a sense of the amount of time taken by list operations.
    This kind of testing can give us some understanding of the efficiency of our programs.
    If our program is too slow, according to the time limit for the problem, then
    we know that we need to optimize the current code or find a wholly new approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The amount of time taken by a program depends on the computer it is being run
    on. We don’t know what kind of computer the judge is using, but running the program
    on our own computer is still informative because the judge is probably using a
    computer that’s at least as fast as ours. Say that we run our program on our laptop
    and it takes 30 seconds on some small test case. If the problem time limit is
    three seconds, we can be confident that our program is simply not fast enough.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序所需的时间取决于运行程序的计算机。我们不知道评测机使用的是什么计算机，但在我们自己的计算机上运行程序仍然具有参考价值，因为评测机可能使用的计算机至少和我们的同样快速。假设我们在笔记本电脑上运行程序，并且在某个小的测试用例上花费了30秒。如果问题的时间限制是3秒，我们就可以确信程序速度不够快。
- en: An exclusive focus on time limits, however, is limiting. Think about our first
    solution to Cow Baseball in [Chapter 9](ch09.xhtml#ch09). We didn’t need to run
    that code to determine how slow it would be. That’s because we were able to characterize
    the program in terms of the amount of work that it would do if we did run it.
    For example, in “Efficiency of Our Program” on [page 253](ch09.xhtml#ch09lev2sec16),
    we said that for *n* cows, our program processes *n*³ triples of cows. Notice
    that our focus here is not on the number of seconds our program would take to
    run, but on how much work it does in terms of the amount of input *n*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单纯关注时间限制是有限制的。想一想我们在[第9章](ch09.xhtml#ch09)中的第一个牛棒球问题的解法。我们不需要运行那段代码来确定它有多慢。这是因为我们能够通过对程序需要执行的工作量进行刻画，来估算程序的表现。例如，在[第253页](ch09.xhtml#ch09lev2sec16)的“程序效率”一节中，我们说对于
    *n* 头牛，我们的程序需要处理 *n*³ 个牛三元组。请注意，我们这里关注的不是程序运行所需的秒数，而是程序在处理 *n* 的输入时所做的工作量。
- en: 'There are significant advantages to this kind of analysis compared to running
    our programs and recording execution times. Here are five:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录程序执行时间并运行程序相比，这种分析方法有显著的优势。这里有五个优势：
- en: '**Execution time depends on the computer** Timing our program tells us only
    how long our program takes on one computer. That’s very specific information,
    and it gives us little in the way of understanding what to expect when the program
    is run on other computers. When working through the book, you may have also noticed
    that the time taken by a program varies from run to run, even on the same computer.
    For example, you might run a program on a test case and find that it takes three
    seconds; you might then run it again, on the same test case, and find that it
    takes two-and-a-half seconds or three-and-a-half seconds. The reason for this
    difference is that your operating system is managing your computing resources,
    shunting them around to different tasks as needed. The decisions that your operating
    system makes influence the runtime of your program.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行时间取决于计算机** 测量程序的运行时间仅能告诉我们程序在一台计算机上需要多长时间。这是非常具体的信息，对于理解程序在其他计算机上的表现帮助不大。在学习过程中，你可能还注意到，即使是在同一台计算机上，程序的执行时间也会有所不同。例如，你可能在一个测试用例上运行程序，发现它花了三秒钟；然后你再运行一次相同的测试用例，结果可能是两秒半或者三秒半。出现这种差异的原因是操作系统在管理你的计算资源，根据需要将它们分配到不同的任务上。操作系统所做的决策会影响程序的运行时间。'
- en: '**Execution time depends on the test case** Timing our program on a test case
    tells us only how long our program takes on that test case. Suppose that our program
    takes three seconds to run on a small test case. That may seem fast, but here’s
    the truth about small test cases: every reasonable solution for a problem will
    quickly be able to solve those. If I ask you to tell me the number of unique email
    addresses among 10 email addresses, or the number of triples of cows among 10
    cows, you can quickly do it with the first correct idea that you have. What’s
    interesting, then, are large test cases. They are the ones where algorithmic ingenuity
    pays off. How long will our program take on a large test case or on a huge test
    case? We don’t know. We’d have to run our program on those test cases, too. Even
    if we did that, there could be specific kinds of test cases that trigger poorer
    performance. We may be led to believe that our program is faster than it is.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行时间取决于测试用例** 对我们的程序进行计时，仅仅告诉我们程序在该测试用例上的执行时间。假设我们的程序在一个小的测试用例上运行需要三秒钟。这看起来可能很快，但关于小测试用例的真相是：每个合理的解决方案都能很快解决这些问题。如果我让你告诉我10个电子邮件地址中的唯一电子邮件地址数量，或者10头牛中有多少组三头牛，你可以用你第一个想到的正确方法快速完成。真正有趣的是大规模的测试用例。它们是算法创意能够展现价值的地方。那么，我们的程序在大测试用例或超大测试用例上的执行时间会是多少？我们不知道。我们也需要在这些测试用例上运行程序。即使我们这么做了，也可能会有特定类型的测试用例触发更差的性能。我们可能会被误导，认为我们的程序比实际情况要快。'
- en: '**The program requires implementation** We can’t time something that we don’t
    implement. Suppose that we’re thinking about a problem and come up with an idea
    for how to solve it. Is it fast? Although we could implement it to find out, it
    would be nice to know, in advance, whether or not the idea is likely to lead to
    a fast program. You would not implement a program that you knew, at the outset,
    would be incorrect. It would similarly be nice to know, at the outset, that a
    program would be too slow.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序需要实现** 我们不能对没有实现的东西进行计时。假设我们正在思考一个问题，并且想到了一个解决方案。这会很快吗？虽然我们可以实现它以找出答案，但如果事先知道这个想法是否能带来一个快速的程序，那将会更好。你不会实施一个你知道一开始就是错误的程序。类似地，如果程序从一开始就知道会太慢，那事先知道这一点也会更好。'
- en: '**Timing doesn’t explain slowness** If we find that our program is too slow,
    then our next task is to design a faster one. However, simply timing a program
    gives us no insight into why our program is slow. It just is. Further, if we manage
    to think up a possible improvement to our program, we’d need to implement it to
    see whether or not it helps.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时无法解释程序慢的原因** 如果我们发现程序运行太慢，那么接下来的任务就是设计一个更快的程序。然而，简单地对程序进行计时并不能为我们提供程序为什么慢的任何线索。它就是慢。进一步说，如果我们想到一个可能的改进方案，我们也需要实施它来查看是否有帮助。'
- en: '**Execution time is not easily communicated** For many of the reasons listed,
    it’s difficult to use execution time to talk to other people about the efficiency
    of algorithms. Execution time is too specific: it depends on the computer, operating
    system, test case, programming language, and particular implementation that’s
    used. We’d have to provide all of this information to others interested in the
    efficiency of our algorithm.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行时间难以传达** 由于许多原因，使用执行时间与他人讨论算法的效率是困难的。执行时间过于具体：它取决于计算机、操作系统、测试用例、编程语言和所使用的具体实现。我们必须向其他对我们算法效率感兴趣的人提供所有这些信息。'
- en: 'Not to worry: computer scientists have devised a notation that addresses these
    shortcomings of timing. It’s independent of the computer, independent of test
    case, and independent of a particular implementation. It signals why a slow program
    is slow. It’s easily communicated. It’s called *big O*, and it’s coming right
    up.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心：计算机科学家已经设计了一种符号来解决计时的这些不足。它独立于计算机、独立于测试用例，并且不依赖于特定的实现。它能够指出程序慢的原因。它易于传达。它叫做
    *大O*，马上就要讲解了。
- en: Big O
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大O
- en: Big O is a notation that computer scientists use to concisely describe the efficiency
    of algorithms. The key concept here is the *efficiency class*, which tells you
    how fast an algorithm is or, equivalently, how much work it does. The faster an
    algorithm, the less work it does; the slower an algorithm, the more work it does.
    Each algorithm belongs to an efficiency class; the efficiency class tells you
    how much work that algorithm does relative to the amount of input that it must
    process. To understand big O, we need to understand these efficiency classes.
    We’re now going to study seven of the most common ones. We’ll see those that do
    the least amount of work, the ones you’ll hope your algorithms fit into. We’ll
    also see those that do considerably more work, the ones whose algorithms will
    probably give you time limit exceeded errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Constant Time
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most desirable algorithms are those that don’t do more work as the amount
    of input increases. No matter the problem instance, such an algorithm takes about
    the same number of steps. These are called *constant-time* algorithms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'This is hard to believe, right? An algorithm that does about the same amount
    of work, no matter what? Indeed, solving a problem with such an algorithm is rare.
    But when you can do it, rejoice: you can’t do any better than that.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve managed to solve a few problems in this book using constant-time algorithms.
    Think back to the Telemarketers problem in [Chapter 2](ch02.xhtml#ch02), where
    we had to determine whether the provided phone number belongs to a telemarketer.
    I’ve reproduced our solution from [Listing 2-2](ch02.xhtml#ch02ex02) here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: num1 = int(input())
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: num2 = int(input())
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: num3 = int(input())
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: num4 = int(input())
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: if ((num1 == 8 or num1 == 9) and
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: (num4 == 8 or num4 == 9) and
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '(num2 == num3)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: print('ignore')
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: print('answer')
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Our solution does the same amount of work no matter what the four digits of
    the phone number are. The code starts by reading the input. Then it makes some
    comparisons with num1, num2, num3, and num4. If the phone number belongs to a
    telemarketer, we output something; if it doesn’t belong to a telemarketer, we
    output something else. There’s no input that can make our program do more work
    than this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in [Chapter 2](ch02.xhtml#ch02), we solved Winning Team. Did we solve
    that one in constant time, too? We did! Here’s the solution from [Listing 2-1](ch02.xhtml#ch02ex01):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: apple_three = int(input())
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: apple_two = int(input())
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: apple_one = int(input())
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: banana_three = int(input())
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: banana_two = int(input())
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: banana_one = int(input())
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'if apple_total > banana_total:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: print('A')
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'elif banana_total > apple_total:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: print('B')
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: print('T')
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We read the input, compute the total points for the Apples, compute the total
    points for the Bananas, compare those totals, and output a message. It doesn’t
    matter how many points the Apples or Bananas have—our program always does the
    same amount of work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Hold on—what if the Apples scored zillions and zillions of three-point shots?
    Surely, it takes longer for the computer to work with ginormous numbers than small
    numbers like 10 or 50? While that’s true, we don’t have to worry about that here.
    The problem description states that each team scores at most 100 of each type
    of play. We’re therefore working with small numbers, and it’s fair to say that
    the computer can read or operate on these numbers in a constant number of steps.
    In general, you can think of numbers up to a few billion as “small.”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In big O notation, we say that a constant-time algorithm is *O*(1). The 1 doesn’t
    mean that you’re stuck performing only one step in a constant-time algorithm.
    If you perform a fixed number of steps, like 10 or even 10,000, it’s still constant
    time. But don’t write *O*(10) or *O*(10000)—all constant-time algorithms are denoted
    *O*(1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Linear Time
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most algorithms are not constant-time algorithms. Instead, they do an amount
    of work that depends on the amount of input. For example, they do more work to
    process 1,000 values than they do to process 10 values. What distinguishes these
    algorithms from each other is the relationship between the amount of input and
    the amount of work that the algorithm does.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: A *linear-time* algorithm is one with a linear relationship between the amount
    of input and the amount of work done. Suppose we run a linear-time algorithm on
    an input with 50 values, and then we run it again on an input with 100 values.
    The algorithm will do about twice as much work on the 100 values compared with
    on the 50 values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example, let’s look at the Three Cups problem from [Chapter 3](ch03.xhtml#ch03).
    We solved that problem in [Listing 3-1](ch03.xhtml#ch03ex01), and I’ve reproduced
    our solution here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: swaps = input()
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 1
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for swap_type in swaps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'if swap_type == ''A'' and ball_location == 1:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 2
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'elif swap_type == ''A'' and ball_location == 2:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 1
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'elif swap_type == ''B'' and ball_location == 2:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 3
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'elif swap_type == ''B'' and ball_location == 3:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 2
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'elif swap_type == ''C'' and ball_location == 1:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 3
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'elif swap_type == ''C'' and ball_location == 3:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 1
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: print(ball_location)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: There’s a for loop ❶, and the amount of work that it does depends linearly on
    the amount of input. If there are five swaps to process, then the loop iterates
    five times. If there are 10 swaps to process, then the loop iterates 10 times.
    Each iteration of the loop performs a constant number of comparisons and may change
    what ball_location refers to. Therefore, the amount of work that this algorithm
    does is directly proportional to the number of swaps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We typically use *n* to refer to the amount of input provided to a problem.
    Here, *n* is the number of swaps. If there are 5 swaps that we need to perform,
    then *n* is 5; if there are 10 swaps that we need to perform, then *n* is 10.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: If there are *n* swaps, then our program does about *n* work. That’s because
    the for loop performs *n* iterations, each of which performs a constant number
    of steps. We don’t care how many steps it performs on each iteration, as long
    as it’s a constant number. Whether the algorithm performs a total of *n* steps
    or 10*n* steps or 10,000*n* steps, it’s a linear-time algorithm. In big O notation,
    we say that this algorithm is *O*(*n*).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: When using big O notation, we don’t include numbers in front of *n*. For example,
    an algorithm that takes 10*n* steps is written *O*(*n*), not *O*(10*n*). This
    helps us focus on the fact that the algorithm is linear time and away from the
    specifics of the linear relationship.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: What if an algorithm takes 2*n* + 8 steps—what kind of algorithm is this? This
    is still linear time! The reason is that the linear term (2*n*) will come to dominate
    the constant term (8) as soon as *n* is big enough. For example, if *n* is 5,000,
    then 8*n* is 40,000\. The number 8 is so small compared to 40,000 that we may
    as well ignore it. In big O notation, we ignore everything except the dominant
    terms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Many Python operations take constant time to do their work. For example, appending
    to a list, adding to a dictionary, or indexing a sequence or dictionary all take
    constant time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: But some Python operations take linear time to do their work. Be careful to
    count them as linear time and not constant time. For example, using the Python
    input function to read a long string takes linear time, because Python has to
    read each character on the line of input. Any operation that examines each character
    of a string or value in a list takes linear time as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: If an algorithm reads *n* values and processes each value in a constant number
    of steps, then it is a linear-time algorithm.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need to go far to see another linear-time algorithm—our solution to
    Occupied Spaces in [Chapter 3](ch03.xhtml#ch03) is another such example. I’ve
    reproduced our solution from [Listing 3-3](ch03.xhtml#ch03ex03) here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: yesterday = input()
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: today = input()
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: occupied = 0
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(yesterday)):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'if yesterday[i] == ''C'' and today[i] == ''C'':'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: occupied = occupied + 1
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: print(occupied)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'We let *n* be the number of parking spaces. The pattern is the same as for
    Three Cups: we read the input and then perform a constant number of steps for
    each parking space.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 1-1](ch01.xhtml#ch01ex01), we solved the Word Count problem. Here’s
    the code for that solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: line = input()
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: total_words = line.count(' ') + 1
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: print(total_words)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of our algorithm?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. It’s tempting to think that this algorithm is *O*(1). After all,
    there’s no loop anywhere, and it looks like the algorithm is performing just three
    steps: read the input, call count to count the number of words, and output the
    number of words.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: But this algorithm is *O*(*n*), where *n* is the number of characters in the
    input. It takes linear time for the input function to read the input, because
    it has to read the input character by character. Using the count method also takes
    linear time, because it has to process each character of the string to find matches.
    So this algorithm performs a linear amount of work to read the input and a linear
    amount of work to count the words. That’s a linear amount of work overall.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 1-2](ch01.xhtml#ch01ex02), we solved the Cone Volume problem. I’ve
    reproduced that solution here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: PI = 3.141592653589793
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: radius = int(input())
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: height = int(input())
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: volume = (PI * radius ** 2 * height) / 3
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: print(volume)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of our algorithm? (Recall that the maximum value
    for the radius and height is 100.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. We’re dealing with small numbers here, so reading them from the
    input takes constant time. Calculating the volume takes constant time, too: it’s
    just a few mathematical operations. All we’re doing here, then, is a few constant-time
    steps. That’s a constant amount of work overall.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 3-4](ch03.xhtml#ch03ex04), we solved the Data Plan problem. I’ve
    reproduced that solution here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: monthly_mb = int(input())
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: excess = 0
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: used = int(input())
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: excess = excess + monthly_mb - used
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: print(excess + monthly_mb)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of our algorithm?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The pattern for this algorithm is similar to that of our solution
    to Three Cups or Occupied Spaces, except that it interleaves reading the input
    with processing it. We let *n* be the number of monthly megabyte values. The program
    performs a constant number of steps for each of these *n* input values. This is
    therefore an *O*(*n*) algorithm.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic Time
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve discussed constant-time algorithms (those that don’t do more work
    as the amount of input increases) and linear-time algorithms (those that do more
    work linearly as the amount of input increases). Like a linear-time algorithm,
    a *quadratic-time* algorithm does more work as the amount of input increases;
    for example, it does more work to process 1,000 values than 10 values. Whereas
    we can get away with using a linear-time algorithm on relatively large amounts
    of input, we’ll be restricted to much smaller amounts of input on quadratic-time
    algorithms. We’ll see why next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Typical Form
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A typical linear-time algorithm looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <process input i in a constant number of steps>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, a typical quadratic-time algorithm looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(n):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <process inputs i and j in a constant number of steps>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: For an input of *n* values, how many values does each algorithm process? The
    linear-time algorithm processes *n* values, one on each iteration of the for loop.
    The quadratic-time algorithm, in contrast, processes *n* values *on each iteration*
    of the outer for loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: On the first iteration of the outer for loop, *n* values are processed (one
    on each iteration of the inner for loop); on the second iteration of the outer
    for loop, *n* more values are processed (one on each iteration of the inner for
    loop); and so on. As the outer for loop iterates *n* times, the total number of
    values that are processed is *n* * *n*, or *n*². Two nested loops, each of which
    depends on *n*, gives rise to a quadratic-time algorithm. In big O notation, we
    say that a quadratic-time algorithm is *O*(*n*²).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the amount of work done by linear-time and quadratic-time algorithms.
    Suppose that we’re processing an input of 1,000 values, meaning that *n* is 1,000\.
    A linear-time algorithm that takes *n* steps would take 1,000 steps. A quadratic-time
    algorithm that takes *n*² steps would take 1,000² = 1,000,000 steps. A million
    is way more than a thousand. But who cares: computers are really, really fast,
    right? Well, yes, and for an input of 1,000 values, we’re probably okay if we
    use a quadratic-time algorithm. In “Efficiency of Our Program” on [page 253](ch09.xhtml#ch09lev2sec16),
    I gave a conservative rule claiming that we can perform about five million steps
    per second. A million steps, then, should be doable in all but the strictest time
    limits.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: But any optimism for a quadratic-time algorithm is short-lived. Watch what happens
    if we crank the number of input values up from 1,000 to 10,000\. The linear-time
    algorithm takes only 10,000 steps. The quadratic-algorithm takes 10,000² = 100,000,000
    steps. Hmmm . . . if we’re using a quadratic-time algorithm, now our computer
    isn’t looking so fast. While the linear-time algorithm still runs in milliseconds,
    the quadratic-time algorithm will take at least a few seconds. Time limit exceeded
    there, no question.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of the following algorithm?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(n):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: <process inputs i and j in a constant number of steps>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: C. *O*(*n*^(*2*))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. There are two nested loops here, so your first instinct might be
    to claim that this is a quadratic-time algorithm. Be careful, though, because
    the outer for loop iterates only 10 times, independent of the value of *n*. The
    total number of steps in this algorithm, therefore, is *10n*. There’s no *n*^(*2*)
    here; *10n* is linear, just like *n*. So, this is a linear-time algorithm, not
    a quadratic-time algorithm. We’d write its efficiency as *O*(*n*).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of the following algorithm?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <process input i in a constant number of steps>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(n):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: <process input j in a constant number of steps>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: C. *O*(*n*^(*2*))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. We have two loops here, and they both depend on *n*. Isn’t this
    quadratic time, then?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: No! These two loops are sequential, not nested. The first loop takes *n* steps,
    and the second also takes *n* steps, for a total of *2n* steps. This is therefore
    a linear-time algorithm.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Alternate Form
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When you see two nested loops where each depends on *n*, it’s a good bet that
    you’re looking at a quadratic-time algorithm. But it’s possible for a quadratic-time
    algorithm to arise even in the absence of such nested loops. We can find such
    an example in our first solution to the Email Addresses problem, [Listing 8-2](ch08.xhtml#ch08ex02).
    I’ve reproduced that solution here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: clean function not shown
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: addresses = []
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: address = input()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: ❶ address = clean(address)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if not address in addresses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: addresses.append(address)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: print(len(addresses))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We’ll let *n* be the maximum number of email addresses that we see in our 10
    test cases. The outer for loop iterates 10 times; the inner for loop iterates
    at most *n* times. We’re therefore processing at most 10*n* email addresses, which
    is linear in *n*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning an email address ❶ takes a constant number of steps, so we don’t need
    to worry about that. But this is still *not* a linear-time algorithm, because
    each iteration of the inner for loop takes more than a constant number of steps.
    Specifically, checking whether an email address is already in our list ❷ takes
    work proportional to the number of email addresses already in the list, because
    Python has to search through the list. That’s a linear-time operation on its own!
    So we’re processing 10*n* email addresses, each of which requires *n* work, for
    a total of 10*n*², or quadratic-time, work. This quadratic-time performance is
    precisely why we received a time limit exceeded error with this code, leading
    us to use a set rather than a list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Cubic Time
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If one loop can lead to linear time, and two nested loops can lead to quadratic
    time, then what about three nested loops? Three nested loops, each of which depends
    on *n*, leads to a *cubic-time* algorithm. In big O notation, we say that a cubic-time
    algorithm is *O*(*n*³).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'If you thought quadratic-time algorithms were slow, wait till you see how slow
    cubic-time algorithms are. Suppose that *n* is 1,000\. We already know that a
    linear-time algorithm will take about 1,000 steps and that a quadratic-time algorithm
    will take about 1,000² = 1,000,000 steps. A cubic-time algorithm will take 1,000³
    = 1,000,000,000 steps. A billion steps! But it gets worse. For example, if *n*
    is 10,000, which is still a small amount of input, then a cubic-time algorithm
    will take 1,000,000,000,000 (that’s one trillion) steps. One trillion steps would
    take many minutes of computing time. No joke: a cubic-time algorithm is almost
    never good enough.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'It certainly wasn’t good enough when we tried to use a cubic-time algorithm
    to solve Cow Baseball in [Listing 9-5](ch09.xhtml#ch09ex05). I’ve reproduced that
    solution here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('baseball.in', 'r')
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('baseball.out', 'w')
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(int(input_file.readline()))
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for position1 in positions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for position2 in positions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: first_two_diff = position2 - position1
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'if first_two_diff > 0:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: low = position2 + first_two_diff
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: high = position2 + first_two_diff * 2
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for position3 in positions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'if position3 >= low and position3 <= high:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: total = total + 1
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(str(total) + '\n')
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see the telltale of cubic time in this code: three nested loops ❶ ❷
    ❸, each of which depends on the amount of input. As you’ll recall, the time limit
    for that problem was four seconds, and we could have up to 1,000 cows. A cubic-time
    algorithm, processing a billion triples, is way too slow.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Variables
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.xhtml#ch05), we solved the Baker Bonus problem. I’ve reproduced
    our solution from [Listing 5-6](ch05.xhtml#ch05ex06) here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: lst = input().split()
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: franchisees = int(lst[0])
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: days = int(lst[1])
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: grid = []
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for i in range(days):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: row = input().split()
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(franchisees):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: row[j] = int(row[j])
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: grid.append(row)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = 0
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for row in grid:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: total = sum(row)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'if total % 13 == 0:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = bonuses + total // 13
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for col_index in range(franchisees):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'for row_index in range(days):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: total = total + grid[row_index][col_index]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'if total % 13 == 0:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: bonuses = bonuses + total // 13
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: print(bonuses)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of this algorithm? There are some nested loops
    in here, so a first guess is that this algorithm is *O*(*n*²). But what is *n*?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'In the problems we’ve discussed to this point in the chapter, we used the single
    variable *n* to represent the amount of input: *n* could be the number of swaps
    or the number of parking spaces or the number of email addresses or the number
    of cows. But in the Baker Bonus problem, we’re dealing with two-dimensional input,
    so we need *two* variables to represent its amount. We’ll call the first variable
    *d*, the number of days; we’ll call the second *f*, the number of franchisees.
    More formally, because there are multiple test cases per input, we’ll let *d*
    be the maximum number of days and *f* the maximum number of franchisees. We need
    to give the big O efficiency in terms of *both d* and *f*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Our algorithm consists of three major components: reading the input, calculating
    the number of bonuses from the rows, and calculating the number of bonuses from
    the columns. Let’s take a look at each of these.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: To read the input ❶, we perform *d* iterations of the outer loop. On each of
    these iterations we read a row and call split, which takes about *f* steps. We
    take another *f* steps to loop through the values and convert them to integers.
    In total, then, each of the *d* iterations performs a number of steps proportional
    to *f*. Reading the input therefore takes *O*(*df*) time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Now for the row bonuses ❷. The outer loop here loops *d* times. Each of these
    iterations calls sum, which takes *f* steps because it has to add up *f* values.
    Like reading the input, then, this part of the algorithm is *O*(*df*).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s look at the code for the column bonuses ❸. The outer loop loops
    *f* times. Each of those iterations leads to the inner loop iterating *d* times.
    The total here, again, is *O*(*df*).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Each component of this algorithm is *O*(*df*). Adding three *O*(*df*) components
    together yields an *O*(*df*) algorithm overall.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of the following algorithm?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(m):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <do something that takes one step>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(n):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <do something that takes one step>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: C. *O*(*n*^(*2*))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: D. *O*(*m*+*n*)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: E. *O*(*mn*)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: D. The first loop depends on *m*, and the second depends on *n*. The
    loops are sequential, not nested, so their work is added rather than multiplied.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Log Time
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Efficiency of Our Program” on [page 255](ch09.xhtml#ch09lev2sec18), we discussed
    the difference between linear search and binary search. A linear search finds
    a value in a list by searching the list from beginning to end. That’s an *O*(*n*)
    algorithm. It works whether or not the list is sorted. A binary search, by contrast,
    works only on a sorted list. But if you have a sorted list, then binary search
    is blazingly fast.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Binary search works by comparing the value we’re searching for to the value
    at the middle of the list. If the value at the middle of the list is larger than
    the value we’re searching for, we continue searching in the left half of the list.
    If the value at the middle of the list is smaller than the value we’re searching
    for, we continue searching in the right half of the list. We keep doing this,
    ignoring half of the list each time, until we find the value that we’re looking
    for.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we use binary search to find a value in a list of 512 values. How many
    steps does it take? Well, after one step, we’ve ignored half the list, so we’re
    left with about 512 / 2 = 256 values. (It doesn’t matter whether our value is
    larger than half of the values in the list or smaller than half the values in
    the list; in each case, we ignore one half of the list.) After two steps, we’re
    left with 256 / 2 = 128 values. After three steps, we’re left with 128 / 2 = 64
    values. Continuing, after four steps we have 32 values, after five steps we have
    16 values, after six steps we have 8 values, after seven steps we have 4 values,
    after eight steps we have 2 values, and after nine steps we have only 1 value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Nine steps—that’s it! That’s way better than taking up to 512 steps using linear
    search. Binary search does far less work than a linear-time algorithm. But what
    kind of algorithm is it? It’s not constant time: while it takes very few steps,
    the number of steps does increase a little as the amount of input increases.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Binary search is an example of a *logarithmic-time* or *log-time* algorithm.
    In big O notation, we say that a logarithmic-time algorithm is *O*(log *n*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic-time refers to the logarithm function in mathematics. Given a number,
    this function tells you the number of times you have to divide that number by
    a base to get to 1 or less. The base we typically use in computer science is 2,
    so we’re looking for the number of times you have to divide a number by 2 to get
    to 1 or less. For example, it takes 9 divisions by 2 to take 512 down to 1\. We
    write this as log[2] 512 = 9.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The logarithm function is the inverse of the exponential function, the latter
    of which may be more familiar to you. Another way to calculate log[2] 512 is to
    find the power *p* so that 2*^p* = 512\. Since 2⁹ = 512, we confirm that log[2]
    512 = 9.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: It’s shocking how slowly the logarithm function grows. For example, consider
    a list of one million values. How many steps would binary search take to search
    that? It takes log[2] 1,000,000 steps, which is only about 20\. Logarithmic-time
    is much closer to constant-time than it is to linear-time. It’s a huge win any
    time you can replace a linear-time algorithm by a logarithmic-time one.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: n log n Time
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.xhtml#ch05), we solved the Village Neighborhood problem.
    I’ve reproduced our solution from [Listing 5-1](ch05.xhtml#ch05ex01) here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for i in range(n):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(int(input()))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: ❷ positions.sort()
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: left = (positions[1] - positions[0]) / 2
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: right = (positions[2] - positions[1]) / 2
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: min_size = left + right
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for i in range(2, n - 1):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: left = (positions[i] - positions[i - 1]) / 2
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: right = (positions[i + 1] - positions[i]) / 2
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: size = left + right
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'if size < min_size:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: min_size = size
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: print(min_size)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Looks like a linear-time algorithm, eh? I mean, there’s a linear-time loop to
    read the input ❶ and another linear-time loop to find the minimum size ❸. Is this
    code *O*(*n*), then?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: It’s too early to tell! The reason is that we haven’t yet taken into account
    that we sort the positions ❷. We can’t just ignore that; we need to know about
    the efficiency of sorting. As we’ll see, sorting is slower than linear time. So,
    since sorting is the slowest step here, whatever the efficiency is of sorting
    will be the efficiency overall.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers and computer scientists have devised many sorting algorithms, and
    these algorithms can roughly be divided into two groups. The first group consists
    of algorithms that take *O*(*n*²) time. The three most famous of these sorting
    algorithms are bubble sort, selection sort, and insertion sort. You can learn
    more about these sorting algorithms on your own if you like, but we won’t need
    to know anything about them to continue here. All we have to keep in mind is that
    *O*(*n*²) can be quite slow. For example, to sort a list of 10,000 values, an
    *O*(*n*²) sorting algorithm would take about 10,000² = 100,000,000 steps. As we
    know, this would take any computer at least a few seconds. That’s pretty disappointing:
    sorting 10,000 values feels like something computers should be able to do almost
    instantly.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the second group of sorting algorithms. This group consists of algorithms
    that take only *O*(*n* log *n*) time. There are two famous sorting algorithms
    in this group: quick sort and merge sort. Again, you’re free to look them up if
    you like, but we don’t need the details here.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: What does *O*(*n* log *n*) mean? Don’t let the notation confuse you. It’s just
    the multiplication of *n* by log *n*. Let’s try this out on a list of 10,000 values.
    Here, we have 10,000 * log 10,000 steps, which is only about 132,877\. This is
    a very small number of steps, especially compared to the 100,000,000 steps taken
    by the *O*(*n*²) sorting algorithms.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can ask the question we really care about: what sorting algorithm is
    Python using when we ask it to sort a list? Answer: an *O*(*n* log *n*) one! (It’s
    called Timsort. If you’d like to learn more, start with merge sort, because Timsort
    is a souped-up merge sort.) No slow *O*(*n*²) sorting here. In general, sorting
    is so fast—so close to linear time—that we can use it without affecting our efficiency
    too much.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Returning to Village Neighborhood, now we see that its efficiency is not *O*(*n*)
    but, because of the sort, *O*(*n* log *n*). In practice, an *O*(*n* log *n*) algorithm
    only does a little more work than an *O*(*n*) algorithm and far less than an *O*(*n*²)
    algorithm. If your goal is to design an *O*(*n*) algorithm, designing one that’s
    *O*(*n* log *n*) is probably good enough.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Handling Function Calls
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Starting in [Chapter 6](ch06.xhtml#ch06), we wrote our own functions to help
    us design larger programs. In our big O analysis, we need to be careful to include
    the work done when we call these functions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the Card Game problem from [Chapter 6](ch06.xhtml#ch06). We solved
    it in [Listing 6-1](ch06.xhtml#ch06ex01), and part of our solution involved calling
    our no_high function. I’ve reproduced that solution here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: NUM_CARDS = 52
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '❶ def no_high(lst):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: lst is a list of strings representing cards.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Return True if there are no high cards in lst, False otherwise.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'if ''jack'' in lst:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'if ''queen'' in lst:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'if ''king'' in lst:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'if ''ace'' in lst:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: return True
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: deck = []
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(NUM_CARDS):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: deck.append(input())
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: score_a = 0
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: score_b = 0
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: player = 'A'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for i in range(NUM_CARDS):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: card = deck[i]
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: points = 0
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: remaining = NUM_CARDS - i - 1
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'if card == ''jack'' and remaining >= 1 and no_high(deck[i+1:i+2]):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: points = 1
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'elif card == ''queen'' and remaining >= 2 and no_high(deck[i+1:i+3]):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: points = 2
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'elif card == ''king'' and remaining >= 3 and no_high(deck[i+1:i+4]):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: points = 3
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'elif card == ''ace'' and remaining >= 4 and no_high(deck[i+1:i+5]):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: points = 4
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'if points > 0:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: print(f'Player {player} scores {points} point(s).')
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'if player == ''A'':'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: score_a = score_a + points
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: player = 'B'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: score_b = score_b + points
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: player = 'A'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f''Player A: {score_a} point(s).'')'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f''Player B: {score_b} point(s).'')'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use *n* to represent the number of cards. The no_high function ❶ takes
    a list and uses in on it, so we might conclude that it is *O*(*n*) time. (in may
    have to search the whole list to find what it’s looking for, after all.) However,
    we only ever call no_high with lists of constant size—maximum four cards—so we
    can treat each call of no_high as *O*(1) time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the efficiency of no_high, we can determine the big O
    efficiency of the complete program. We begin with a loop that takes *O*(*n*) time
    to read the cards ❷. We then enter another loop that iterates *n* times ❸. Each
    iteration takes just a constant number of steps, possibly including a call of
    no_high that takes a constant number of steps. This loop, then, takes *O*(*n*)
    time. The program therefore consists of two *O*(*n*) pieces, so it is *O*(*n*)
    overall.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to accurately judge the amount of work performed when a function
    is called. As you just saw with no_high, this may involve looking at both the
    function itself and the context in which it is called.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: What is the big O efficiency of the following algorithm?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'def f(lst):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(lst)):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: lst[i] = lst[i] + 1
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Assume that lst refers to a list of numbers
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for i in range(len(lst)):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: f(lst)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: A. *O*(1)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: B. *O*(*n*)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: C. *O*(*n*^(*2*))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. The loop in the main program iterates *n* times. On each iteration,
    we call function f, which itself has a loop that iterates *n* times.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The algorithms that do the least work are *O*(1), followed by *O*(log *n*),
    followed by *O*(*n*), followed by *O*(*n* log *n*). Have you solved a problem
    using one of these four? If so, you’re probably done. If not, then depending on
    the time limit, you may have more work to do.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: We’re now going to look at two problems where a straightforward solution will
    not be efficient enough—it won’t run within the time limit. Using what we just
    learned about big O, we’ll be able to predict this inefficiency even without implementing
    the code! We’ll then work on a faster solution and implement it to solve the problem
    within the time limit.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #24: Longest Scarf'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this problem, we’ll determine the longest desired scarf that we can produce
    by cutting an initial scarf. After reading the following description, pause: how
    would you solve it? Can you come up with multiple algorithms whose efficiency
    you’d like to investigate?'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem dmopc20c2p2.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have a scarf whose length is *n* feet, and each foot has a specific color.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: You also have *m* relatives. Each relative indicates what their desired scarf
    looks like by specifying the color of its first foot and last foot.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to cut your original scarf in such a way as to produce the longest
    desired scarf for one of your relatives.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the integer scarf length *n* and integer number of relatives
    *m*, separated by a space. *n* and *m* are each between 1 and 100,000.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* integers separated by spaces. Each integer specifies the
    color of one foot of scarf in order from the first foot to the last foot. Each
    integer is between 1 and 1,000,000.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, one per relative, containing two integers separated by a space.
    These numbers describe the relative’s desired scarf: the first integer is the
    desired color of the first foot, and the second integer is the desired color of
    the last foot.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the length of the longest desired scarf that can be produced by cutting
    your original scarf.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is 0.4 seconds.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s make sure we know exactly what is being asked by working through a small
    test case. Here it is:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 6 3
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 18 4 4 2 1 2
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 4 2
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 18 4
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: We have a scarf that’s 6 feet long and three relatives. The color of each foot
    of the scarf is 18, 4, 4, 2, 1, and 2\. What’s the longest desired scarf we can
    make?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'The first relative wants a scarf whose first foot is color 1 and whose last
    foot is color 2\. The best we can do is give this relative a 2-foot scarf: the
    2 feet (colors 1 and 2) at the end of the scarf.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'The second relative wants a scarf whose first foot is color 4 and whose last
    foot is color 2\. We can give them a 5-foot scarf: 4, 4, 2, 1, 2.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The third relative wants a scarf whose first foot is color 18 and whose last
    foot is color 4\. We can give them a 3-foot scarf: 18, 4, 4.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The maximum length of a desired scarf that we can make is 5, so that’s the answer
    for this test case.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 1
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The way we just processed that test case might immediately suggest to you an
    algorithm that we can use to solve this problem. Namely, we should be able to
    go through the relatives and figure out the maximum length of a desired scarf
    for each one. For example, the maximum length for the first relative might be
    2, so we remember that. The maximum length for the second relative might be 5\.
    That’s longer than 2, so we remember the 5\. The maximum length for the third
    relative might be 3\. This isn’t greater than 5—no change here. If this reminds
    you of a complete-search algorithm ([Chapter 9](ch09.xhtml#ch09)): good, because
    it is one!'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: There are *m* relatives. If we knew how long it would take us to process each
    relative, then we’d be able to work out the big O efficiency we’d be dealing with.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an idea: for each relative, let’s find the leftmost index of the color
    of the first foot and the rightmost index of the color of the last foot. Once
    we had these indices, then no matter how long the scarf, we could use these indices
    to quickly determine the length of the longest desired scarf for this relative.
    For example, if the leftmost index of the color of the first foot is 100 and the
    rightmost index of the color of the last foot is 110, then their longest desired
    scarf is 110 – 100 + 1 = 11.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how we try to find these indices, we might be lucky and find them
    quickly. For example, we might scan from the left for the leftmost index of the
    color of the first foot and scan from the right for the rightmost index of the
    color of the last foot. Then, if the color of the first foot is near the beginning
    of the scarf and the color of the last foot is near the end, we’ll discover these
    indices very quickly.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We might not be lucky, though. Finding one or both of the indices could take
    up to *n* steps. For example, suppose that a relative wants a scarf whose first
    foot is a color that shows up right at the end of the scarf or that doesn’t show
    up in the scarf at all. We will have to check the entire *n* feet of the scarf,
    one foot at a time, to figure this out.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: So, about *n* steps per relative. That’s linear time, and we know that linear
    time is fast. Are we good? No, because in this case the linear-time work is far
    more menacing than it may appear. Remember that we’d be doing this *O*(*n*) work
    for each of the *m* relatives. We therefore have an *O*(*mn*) algorithm overall.
    *m* and *n* can be as big as 100,000\. So, *mn* can be as big as 100,000 *** 100,000
    = 10,000,000,000\. That’s 10 billion! Given that we can do about five million
    operations per second and that our time limit is 0.4 seconds . . . yeah, we’re
    not even close. There’s no need to implement this algorithm. We’re certain that
    it will time out on large test cases. We may as well move on and spend our time
    implementing something else. (If you’re nevertheless curious about the code, please
    see the online resources associated with the book. Just remember that without
    even looking at the code, we already figured out that it would be too slow. The
    power of big O analysis is in helping us understand whether an algorithm is doomed
    even before we implement it.)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 2
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to have to somehow process each of the relatives—there’s no getting
    around that. What we’ll focus on optimizing, then, is the amount of work that
    we do per relative. Unfortunately, processing a relative in the way we did in
    the previous section may cause us to check over a huge portion of the scarf. It’s
    this searching through the scarf, once per relative, that’s crushing us. We need
    to get that searching under control.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we could look through the scarf only once, up-front, before we
    knew anything about what the relatives wanted. We could remember two things about
    each color in the scarf: its leftmost index and its rightmost index. Then, no
    matter what each relative wants, we could figure out the maximum length of their
    desired scarf using the left and right indices that we had already stored.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume we have this scarf:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 18 4 4 2 1 2
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'We would store the following information for it:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '| **Color** | **Leftmost index** | **Rightmost index** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| 1 | 4 | 4 |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 | 5 |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 2 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| 18 | 0 | 0 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: Suppose that a relative wants a scarf whose first foot is color 1 and whose
    last foot is color 2\. We look up the leftmost index for color 1, which is 4,
    and the rightmost index for color 2, which is 5\. We then calculate 5 – 4 + 1
    = 2, and that’s the length of the longest desired scarf for this relative.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazing: no matter how long the scarf, we can just do a quick calculation for
    each relative. No more running through the scarf over and over. The only tricky
    thing here is how to calculate all the leftmost and rightmost indices for the
    colors and to do so by looking through the scarf only once.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The code is presented in [Listing 10-1](ch10.xhtml#ch10ex01). Try to figure
    out how the leftmost_index and rightmost_index dictionaries are constructed before
    you continue reading my explanation that follows.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: lst = input().split()
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: n = int(lst[0])
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: m = int(lst[1])
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: scarf = input().split()
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: scarf[i] = int(scarf[i])
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: ❶ leftmost_index = {}
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: ❷ rightmost_index = {}
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for i in range(n):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: color = scarf[i]
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '❹ if not color in leftmost_index:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: leftmost_index[color] = i
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_index[color] = i
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '❺ else:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_index[color] = i
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: max_length = 0
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(m):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: relative = input().split()
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: first = int(relative[0])
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: last = int(relative[1])
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'if first in leftmost_index and last in leftmost_index:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: ❻ length = rightmost_index[last] - leftmost_index[first] + 1
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'if length > max_length:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: max_length = length
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: print(max_length)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-1: Solving Longest Scarf, algorithm 2*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution uses two dictionaries: one to keep track of the leftmost index
    for each color ❶ and one to keep track of the rightmost index for each color ❷.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'As promised, we look at each foot of the scarf just once ❸. Here’s how we keep
    the leftmost_index and rightmost_index dictionaries up-to-date:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: If the color of the current foot has never been seen before ❹, then the current
    index serves as both the leftmost and rightmost index for this color.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the color of the current foot has been seen before ❺. We don’t want
    to update the leftmost index for this color, because the current index is to the
    right of the old one. We *do* want to update the rightmost index, though, because
    we have found an index to the right of the old one.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now for the payoff: for each relative, we can simply look up the leftmost and
    rightmost indices from these dictionaries ❻. The maximum length of the desired
    scarf is the rightmost index of the color of the last foot, minus the leftmost
    index of the color of the first foot, plus one.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: As I’ll argue now, this algorithm is far better than algorithm 1\. Reading the
    scarf takes *O*(*n*) time, as does processing the scarf ’s feet. That’s *O*(*n*)
    time so far. We then take a constant number of steps to process each relative
    (not *n* steps like before!), so that’s *O*(*m*) time. In total, we have an *O*(*m*
    + *n*) algorithm, rather than an *O*(*mn*) algorithm. Given that *m* and *n* can
    be at most 100,000, we’re doing only about 100,000 + 100,000 = 200,000 steps,
    easily done within the time limit. You can submit our code to the judge to prove
    it!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #25: Ribbon Painting'
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s another problem where the first algorithm that we might come up with
    is too slow. We won’t waste much time on that algorithm, though, because our big
    O analysis will tell us all we need to know before we consider implementing the
    code. We’ll then spend our time designing a faster algorithm.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem dmopc17c4p1.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have a purple ribbon whose length is *n* units. The first unit goes from
    position 0 up to but not including position 1, the second unit goes from position
    1 up to but not including position 2, and so on. You then carry out *q* paint
    strokes, each of which colors a segment of the ribbon blue.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to determine the number of units of the ribbon that are still purple
    and the number of units of the ribbon that are now blue.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the integer ribbon length *n* and integer number of paint
    strokes *q*, separated by a space. *n* and *q* are each between 1 and 100,000.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* lines, one per paint stroke, containing two integers separated by a space.
    The first integer gives the starting position of the paint stroke; the second
    gives the ending position of the paint stroke. The starting position is guaranteed
    to be less than the ending position; each integer is between 0 and *n*. The paint
    stroke goes from the starting position up to but not including the ending position.
    As a quick example here, if a paint stroke has a starting position of 5 and an
    ending position of 12, then the stroke paints the ribbon from position 5 up to
    but not including position 12.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of units of the ribbon that are still purple, a space, and
    the number of units of the ribbon that are now blue.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is 2 seconds.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a small test case. This test case will not only ensure that we’ve
    interpreted the problem correctly but also highlight the perils of a naive algorithm.
    Here it is:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 20 4
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 18 19
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 4 16
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 4 14
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 5 12
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Our ribbon’s length is 20, and there are four paint strokes. How much of the
    ribbon do our paint strokes turn blue?
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The first paint stroke paints one unit blue, the one that starts at position
    18.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The second paint stroke paints the units of ribbon starting at positions 4,
    5, 6, 7, and so on, all the way up to position 15\. That’s 12 units painted blue
    by this stroke, and 13 blue units in total.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The third paint stroke paints 10 units blue. But all of those units are already
    blue from the second paint stroke! It would be a colossal waste of time indeed
    if we spent time “painting” anything with this paint stroke. Whatever algorithm
    we come up with better not fall into this time-wasting trap.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth paint stroke paints 7 units blue. But again: all of these units
    are already blue!'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re done painting, and we have 13 blue units. There are 20 – 13 = 7 remaining
    purple units, so the correct output for this test case is:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 7 13
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum length of the ribbon is 100,000, and the maximum number of paint
    strokes is 100,000\. Recall algorithm 1 from when we solved Longest Scarf, where
    we learned that an *O*(*mn*) algorithm was too slow with these bounds. Similarly,
    here, an *O*(*nq*) algorithm would be inadequate, as it would not finish within
    the time limit on large test cases.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: This means that we cannot afford to process each unit that is painted by each
    paint stroke. It would be nice if we could more easily focus on only the *new*
    units that are painted blue by a paint stroke. Then we could go through each paint
    stroke and add up the number of blue units that it contributes.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Fair enough, but how can we determine the contribution of each paint stroke?
    That’s tricky, because bits and pieces of the next paint stroke may have already
    been painted blue by previous paint strokes.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: This situation is made much simpler, however, if we sort the paint strokes first.
    Remember from “n log n Time” earlier in this chapter that sorting is extremely
    fast, taking only *O*(*n* log *n*) time. There’s no efficiency concern in using
    sorting, so let’s understand why sorting helps us here.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting the paint strokes from the test case in the prior section gives us
    the following list of paint strokes:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 4 14
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 4 16
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 5 12
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 18 19
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Now that the paint strokes are sorted, we can efficiently process them. As we
    do so, we’ll store the rightmost position of any paint stroke that we’ve processed
    so far. We’ll start this rightmost position off at 0 to indicate that we haven’t
    painted anything.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Our first paint stroke paints 14 – 4 = 10 units blue. Now our stored rightmost
    position is 14.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Our second paint stroke paints 12 units blue, yes, but how many of those 12
    does it turn from purple to blue? After all, it overlaps the previous paint stroke,
    so some of these units were blue already. We can calculate the number of new blue
    units by subtracting 14, our stored rightmost position, from 16, the ending position
    of the current paint stroke. This is how we ignore the units already painted blue
    by previous paint strokes. So, there are 16 – 14 = 2 new blue units and 12 blue
    units in total. Crucially, we just figured this out without processing the individual
    units of this paint stroke. Before we continue, don’t forget to update our stored
    rightmost position to 16.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Our third paint stroke is like the second in that it starts prior to our stored
    rightmost position. Unlike the second paint stroke, however, its ending position
    does not extend past our stored rightmost position at all. So, this paint stroke
    adds no new blue units, and our stored rightmost position is still 16\. Again,
    we figured this out without grinding through each of this paint stroke’s positions!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with the fourth paint stroke. It does *not* add 19 – 16 = 3 new blue
    units. We have to treat this paint stroke differently because its starting position
    is to the right of our stored rightmost position. In this case, we don’t use the
    stored rightmost position at all, calculating instead 19 – 18 = 1 new blue unit,
    and 13 blue units in total. We also update our stored rightmost position to 19.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: The only question is how we sort the paint strokes in our Python code. We need
    to sort them by their starting position; if multiple paint strokes have the same
    starting position, then we want to sort those by their ending position.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we want to take a list like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19], [4, 16], [4, 14], [5, 12]]'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'and produce this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[[4, 14], [4, 16], [5, 12], [18, 19]]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Happily, as we discovered in “Task 4: Sort Boxes” in [Chapter 6](ch06.xhtml#ch06),
    the list sort method works in exactly this way. When given a list of lists, sort
    sorts using the first values in each list; when those values are tied, the lists
    are further sorted using the second values. Check it out:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '>>> strokes = [[18, 19], [4, 16], [4, 14], [5, 12]]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '>>> strokes.sort()'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '>>> strokes'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[[4, 14], [4, 16], [5, 12], [18, 19]]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm: check. Sorting: check. We’re in great shape! Just one more thing
    we’d like to know before we see the code: what will be its big O efficiency? We
    need to read the *q* queries; that takes *O*(*q*) time. Then we need to sort the
    queries; that takes *O*(*q* log *q*) time. Finally, we need to process the queries;
    that takes *O*(*q*) time. The slowest of these is the *O*(*q* log *q*) time for
    the sorting, so that’s our overall big O efficiency.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Now we have everything we need for a speedy solution. Check it out in [Listing
    10-2](ch10.xhtml#ch10ex02).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: lst = input().split()
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: n = int(lst[0])
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: q = int(lst[1])
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: strokes = []
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(q):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: stroke = input().split()
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: ❶ strokes.append([int(stroke[0]), int(stroke[1])])
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: ❷ strokes.sort()
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_position = 0
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: blue = 0
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'for stroke in strokes:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: stroke_start = stroke[0]
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: stroke_end = stroke[1]
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if stroke_start <= rightmost_position:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'if stroke_end > rightmost_position:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: ❹ blue = blue + stroke_end - rightmost_position
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_position = stroke_end
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '❺ else:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: ❻ blue = blue + stroke_end - stroke_start
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: rightmost_position = stroke_end
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: print(n - blue, blue)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-2: Solving Ribbon Painting*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: We read each paint stroke, appending it as a list of two values to our strokes
    list ❶. We then sort all of the paint strokes ❷.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'We next need to process each paint stroke from left to right. There are two
    key variables that drive this processing: variable rightmost_position stores the
    rightmost position that we have painted so far, and variable blue stores the number
    of units that we have painted blue so far.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: To process a paint stroke, we need to know whether it starts before or after
    our stored rightmost position. Let’s think about each of these cases in turn.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'First: what do we do when the paint stroke starts before our stored rightmost
    position ❸? This paint stroke might give us some new blue units, but only if it
    extends past our stored rightmost position. If it does, then the new blue units
    are those between the stored rightmost position and the ending position of the
    paint stroke ❹.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Second: what do we do when the paint stroke starts after our stored rightmost
    position ❺? This time, the paint stroke is completely separate from the painting
    we have done so far; this entire paint stroke is a new blue segment. As such,
    the new blue units are those between the ending position and starting position
    of this paint stroke ❻.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Notice in each case that we also correctly update our stored rightmost position
    so that we’re ready to process any further paint strokes.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: That’s a wrap! Guided by our big O analysis, we were able to dismiss an algorithm
    whose implementation we knew would be too slow. We then thought about a second
    algorithm—and before implementing it, we knew it would be plenty fast. It’s time
    to submit our code to the judge and bask in our success.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about big O analysis. Big O is an important efficiency
    building block for further study of algorithm design. You’ll see it everywhere:
    in tutorials, in books, probably in your next job interview!'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: We also solved two problems where we needed to design very efficient algorithms.
    Not only were we able to do that, but we were also able to use big O to obtain
    a satisfying understanding of exactly why our code was so efficient.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. For each, use big O to determine whether
    your proposed algorithm is efficient enough to solve the problem within the time
    limit. You might also like to implement algorithms that you know are going to
    be too slow. That would give you extra practice solidifying your Python knowledge
    and confirm that your big O analysis was spot-on!
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Some of these problems are quite challenging. There are two reasons. First,
    you might agree based on your work throughout the book that coming up with *any*
    algorithm can be tough. Coming up with a faster algorithm can be even tougher.
    Second, this is the end of our time together, but only the beginning of the study
    of algorithms. I hope that these problems both help you appreciate what you’ve
    accomplished and offer evidence that there’s a lot more beyond this book if you
    want it.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem dmopc17c1p1, Fujo Neko (The problem talks about using fast input/output.
    Don’t ignore that!)
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci10c1p2, Profesor
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci19c4p1, Pod starim krovovima (Hint: to maximize the number
    of empty glasses, you want to put as much liquid as possible in the biggest glasses.)'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc20c1p2, Victor’s Moral Dilemma
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem avocadotrees, Avocado Trees!
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci11c5p2, Eko (Hint: the maximum number of trees is far fewer
    than the maximum number of heights. Consider each tree from tallest to shortest.)'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem wac6p2, Cheap Christmas Lights (Hint: don’t try flipping a switch
    each second—how would you know which one to flip? Instead, store them up, and
    use them all as soon as you can shut off all the lights that are on.)'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem ioi98p3, Party Lamps (Hint: all that matters for each button is
    whether it is pressed an even or odd number of times.)'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Longest Scarf is originally from the DMOPC ’14 March Contest. Ribbon Painting
    is originally from the DMOPC ’20 November Contest.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
