<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_49"/><span class="big">3</span><br/>THE COMMAND LINE</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent"><em>Command line interfaces</em> let us give direct instructions to our computer. From the command line, we can run programs, search files, create and delete directories, connect to the internet, and do much more. With two exceptions, the applications that we’ll create in this book are all designed to be executed from the command line. In this chapter, we’ll briefly cover the basics of command line interfaces. Feel free to skip this chapter if you already know how to use them.</p>&#13;
<h3 class="h3" id="ch00lev1sec21"><strong>Unix and Windows</strong></h3>&#13;
<p class="noindent">Every operating system comes with a different flavor of a command line interface, but they all have a similar purpose: issuing commands directly to the operating system. Linux and macOS are both based on Unix, so they share a common syntax and use similar <em>command line processors</em>, which are programs that interpret your commands, issued in the form of plaintext, and translate them into a language the machine can execute. Several Unix command line processors exist; bash, bourne, and zsh are a few examples.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>The command line application in these systems is often called a <em>shell</em>, <em>terminal</em>, or <em>prompt</em>. Apple had macOS come bundled with a bash shell, but recently, it replaced bash with zsh, which is, arguably, more modern and feature rich. We won’t be worrying too much about the differences of these shell flavors; for our purposes, we can think of them as interchangeable.</p>&#13;
<p class="indent">Windows has its own command line system, and it uses a different syntax than macOS or Linux. Fortunately enough, since most developers are more familiar with Unix-like shells, Windows decided to allow its users to install a Linux subsystem. In the next section, we’ll look at how to install this Windows Subsystem for Linux (WSL) support in case you’re following this book with a Windows machine.</p>&#13;
<h3 class="h3" id="ch00lev1sec22"><strong>Finding Your Shell</strong></h3>&#13;
<p class="noindent">If you are a Linux or macOS user, you don’t need to install any additional software: your system comes with a shell. You can find it inside your applications directory.</p>&#13;
<p class="indent">If you’re a Windows user, your system also has a command line, but we won’t be using that one; we’ll install the WSL instead. This system will give you access to a shell you can use to follow along with this book. Let’s look at how to get it installed on your machine. If you aren’t a Windows user, feel free to skip this section.</p>&#13;
<h4 class="h4" id="ch00lev2sec26"><strong><em>Installing the Windows Subsystem for Linux</em></strong></h4>&#13;
<p class="noindent">The <em>Windows Subsystem for Linux</em>, WSL for short, is an installation of a Linux operating system inside your Windows operating system. The WSL will let you access Linux’s main tools, including the shell.</p>&#13;
<p class="indent">Since installation instructions tend to evolve with time, please refer to the official documentation if you find any issue with the following steps. You can find the official documentation at <a href="https://docs.microsoft.com/windows/wsl"><em>https://docs.microsoft.com/windows/wsl</em></a>, where you’ll also find detailed information and a step-by-step installation guide.</p>&#13;
<p class="indent">As of the time of this writing, to install a Linux subsystem you first need to enable the WSL optional feature in your machine. To do this, open the PowerShell application as Administrator and then execute the following command:</p>&#13;
<pre>PS C:\&gt; <span class="codestrong1">dism.exe /online /enable-feature&#13;
    /featurename:Microsoft-Windows-Subsystem-Linux&#13;
    /all /norestart</span></pre>&#13;
<p class="noindent">Note that you should write this command on a single line; I had to break the line because it didn’t fit in the print version of the book. It may take a few seconds to finish. Once the command has run, restart your machine.</p>&#13;
<p class="indent">When your machine is fully restarted, you can proceed to install any Linux distribution (also known as <em>distro</em>) of your choice. If you have no <span epub:type="pagebreak" id="page_51"/>favorite Linux distro, I suggest you install Ubuntu; it’s reliable and developer-friendly.</p>&#13;
<p class="indent">To install a Linux subsystem, open the Microsoft Store and search for <em>Ubuntu</em> (or your distro of choice). For this book, I’ll be using Ubuntu’s 20 LTS version. Run the installer for the Linux subsystem; once the installation process finishes, open it.</p>&#13;
<p class="indent">When you open your Linux subsystem for the first time, it’ll need to perform some installations, which may take a few minutes. As you will see, this installation includes the Linux operating system and a shell to communicate with it, but not the graphical interface. The shell will prompt you to create a new username and password. Don’t hesitate to read the documentation if you find yourself stuck at any point during the installation and configuration of the system.</p>&#13;
<h4 class="h4" id="ch00lev2sec27"><strong><em>Taking a First Look at the Shell</em></strong></h4>&#13;
<p class="noindent">When you open your shell, it shows something like the following:</p>&#13;
<pre>angel@MacBook ~ %</pre>&#13;
<p class="noindent">You may see some different characters toward the end, but the first part is the logged-in user and the name of the machine separated by an at sign:</p>&#13;
<pre>&lt;<span class="codeitalic1">user</span>&gt;@&lt;<span class="codeitalic1">machine</span>&gt; ~ %</pre>&#13;
<p class="indent">For the remainder of the book, we’ll use the dollar sign ($) to signify the shell, and we won’t show the user and machine names:</p>&#13;
<pre>$</pre>&#13;
<p class="indent">Now that you know how to open a shell, let’s look at some useful commands.</p>&#13;
<h3 class="h3" id="ch00lev1sec23"><strong>Files and Directories</strong></h3>&#13;
<p class="noindent">Let’s try our first command: <span class="literal">pwd</span> (short for <em>print working directory</em>). Type <span class="codestrong">pwd</span> in the shell and press <small>ENTER</small> or <small>RETURN</small> . This command shows the path of the current directory, that is, the directory the shell is currently in:</p>&#13;
<pre>$ <span class="codestrong1">pwd</span>&#13;
/Users/angel</pre>&#13;
<p class="noindent">In this case, the shell is telling us the current working directory is <em>angel</em>, which is inside the <em>Users</em> directory.</p>&#13;
<p class="indent">Using the <span class="literal">whoami</span> command, we can also ask the shell to tell us the currently logged-in user:</p>&#13;
<pre>$ <span class="codestrong1">whoami</span>&#13;
angel</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>We can then list the contents inside the current directory using the <span class="literal">ls</span> command:</p>&#13;
<pre>$ <span class="codestrong1">ls</span>&#13;
Desktop               Downloads             Music             PycharmProjects&#13;
Applications          Developer             Library           Pictures&#13;
Documents             Git                   Movies            Public</pre>&#13;
<h4 class="h4" id="ch00lev2sec28"><strong><em>Moving Around</em></strong></h4>&#13;
<p class="noindent">We can change directories using <span class="literal">cd</span> followed by the name of the directory we want to go to:</p>&#13;
<pre>$ <span class="codestrong1">cd Documents</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/Users/angel/Documents</pre>&#13;
<p class="indent">To go back one directory, to the parent directory, we use two dots:</p>&#13;
<pre>$ <span class="codestrong1">cd ..</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/Users/angel</pre>&#13;
<p class="indent">In these two examples of the <span class="literal">cd</span> command, we’ve changed directories using relative paths. A <em>relative path</em> is a path that starts from the current location. For example, if we want to change directories using a relative path, we simply provide the route like so:</p>&#13;
<pre>$ <span class="codestrong1">cd Documents/Video</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/Users/angel/Documents/Video</pre>&#13;
<p class="noindent">We can use one dot (.) to signify the current directory. So, the following is an alternative way of switching to the <em>Documents/Video</em> directory:</p>&#13;
<pre>$ <span class="codestrong1">cd ./Documents/Video</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/Users/angel/Documents/Video</pre>&#13;
<p class="indent">We may also change directories using an <em>absolute path</em>, which is a path relative to the root directory. The root directory’s name is simply a slash character (/). Let’s try to change directories to the root directory using an absolute path:</p>&#13;
<pre>$ <span class="codestrong1">cd /</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>Now let’s move back to our home directory. The home directory also has a special shortcut name, a tilde (~):</p>&#13;
<pre>$ <span class="codestrong1">cd ~</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/Users/angel</pre>&#13;
<h4 class="h4" id="ch00lev2sec29"><strong><em>Creating Files and Directories</em></strong></h4>&#13;
<p class="noindent">We can create new directories using the <span class="literal">mkdir</span> command followed by the name of the directory we want to create:</p>&#13;
<pre>$ <span class="codestrong1">mkdir tmp/mechanics</span></pre>&#13;
<p class="noindent">Here we’ve just created a new directory named <em>tmp</em> inside the working directory, which has another new directory inside it named <em>mechanics</em>. We could have done the same thing in two steps, first creating the <em>tmp</em> directory,</p>&#13;
<pre>$ <span class="codestrong1">mkdir tmp</span></pre>&#13;
<p class="noindent">and then changing directories to <em>tmp</em> (<span class="literal">cd tmp</span>) and creating the <em>mechanics</em> directory,</p>&#13;
<pre>$ <span class="codestrong1">mkdir mechanics</span></pre>&#13;
<p class="noindent">The result is the same in both cases.</p>&#13;
<p class="indent">Let’s <span class="literal">cd</span> into that new directory:</p>&#13;
<pre>$ <span class="codestrong1">cd tmp/mechanics</span></pre>&#13;
<p class="indent">To create a new file, we can use the <span class="literal">touch</span> command followed by the filename:</p>&#13;
<pre>$ <span class="codestrong1">touch file.txt</span>&#13;
$ <span class="codestrong1">ls</span>&#13;
file.txt</pre>&#13;
<p class="indent">We can write some text to the file using input redirection, which we’ll explain a bit more in the next section:</p>&#13;
<pre>$ <span class="codestrong1">echo write me to the file &gt; file.txt</span></pre>&#13;
<p class="noindent">This command is a bit more complex than the ones we’ve seen so far, and it has two parts. The first part, on the left side of the <span class="literal">&gt;</span> symbol, uses the <span class="literal">echo</span> command to output <span class="literal">write me to the file</span>. We can run this command separately to see what it does:</p>&#13;
<pre>$ <span class="codestrong1">echo write me to the file</span>&#13;
write me to the file</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_54"/>As we can see, the <span class="literal">echo</span> command simply prints what we pass it. With the <span class="literal">&gt;</span> symbol, we can redirect the output target from the standard output (the shell) to a file so that the message is written to the file instead of the shell.</p>&#13;
<p class="indent">To prove that we did this, let’s read the contents of the file using the <span class="codestrong">cat</span> command:</p>&#13;
<pre>$ <span class="codestrong1">cat file.txt</span>&#13;
write me to the file</pre>&#13;
<p class="noindent">The <span class="literal">cat</span> command prints the contents of the file. The command is short for <em>concatenate</em> and it concatenates the contents of the file passed to it. In fact, we can pass <span class="literal">cat</span> to the same file twice to see the concatenated result:</p>&#13;
<pre>$ <span class="codestrong1">cat file.txt file.txt</span>&#13;
write me to the file&#13;
write me to the file</pre>&#13;
<p class="indent">Let’s now delete the file and directories we just created.</p>&#13;
<h4 class="h4" id="ch00lev2sec30"><strong><em>Deleting Files and Directories</em></strong></h4>&#13;
<p class="noindent">To remove a file, we use the <span class="codestrong">rm</span> command:</p>&#13;
<pre>$ <span class="codestrong1">rm file.txt</span></pre>&#13;
<p class="noindent">The file is now gone forever: there’s no trash bin or any other safety mechanism when working with the command line. We need to be extra careful when deleting files or directories.</p>&#13;
<p class="indent">Let’s go back two directories to get out of the <em>tmp/mechanics</em> folder:</p>&#13;
<pre>$ <span class="codestrong1">cd ../..</span>&#13;
$ <span class="codestrong1">pwd</span>&#13;
/Users/angel</pre>&#13;
<p class="indent">If a directory is empty, we can remove it using the <span class="literal">-d</span> command line option. A <em>command line option</em> is an argument that we can pass to the command to modify its behavior. Command line options appear in two forms: as a single dash followed by one or more lowercase letters, as in <span class="literal">-f</span>, or as a double dash followed by a single or compound word, as in <span class="literal">--file</span> or <span class="literal">--file-name</span>.</p>&#13;
<p class="indent">Removing an empty directory is done like so:</p>&#13;
<pre>$ <span class="codestrong1">rm -d tmp</span>&#13;
rm: tmp: Directory not empty</pre>&#13;
<p class="noindent">As you can see, the shell returned an error message because our <em>tmp</em> directory is not empty (it has a subdirectory). If we want to remove a directory and all its subdirectories, we can use the <span class="literal">-r</span> option instead:</p>&#13;
<pre>$ <span class="codestrong1">rm -r tmp</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>If the directory or any subdirectory had files inside, the previous command would fail. This command is useful when we want to remove directories that contain no files, because if a file is encountered, the command won’t remove anything as a safety measure. To remove directories with files inside, we can use the <span class="literal">-rf</span> option:</p>&#13;
<pre>$ <span class="codestrong1">rm -rf tmp</span></pre>&#13;
<p class="noindent">You want to be <em>extremely careful</em> with the <span class="literal">rm -rf</span> command. You can do some nasty, unrecoverable harm with this one.</p>&#13;
<h4 class="h4" id="ch00lev2sec31"><strong><em>Commands Summary</em></strong></h4>&#13;
<p class="noindent"><a href="ch03.xhtml#ch3tab1">Table 3-1</a> summarizes the commands we’ve explored in this section.</p>&#13;
<p class="tabcap" id="ch3tab1"><strong>Table 3-1:</strong> Shell Commands for Files and Directories</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Command</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">whoami</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Displays the effective user ID</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">pwd</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Returns the working directory name</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">ls</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Lists the directory’s contents</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">cd</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Changes the directory</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">mkdir</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Creates a new directory</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">echo</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Writes arguments to the standard output</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">cat</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Concatenates and prints files</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">rm</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Removes a file</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">rm -d</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Removes an empty directory</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">rm -r</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Removes a directory with other directories inside</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><span class="literal">rm -rf</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Removes directories and files (recursively)</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch00lev2sec32"><strong><em>Using Windows Subsystem for Linux</em></strong></h4>&#13;
<p class="noindent">Now that we know the basic commands we need to move around the directories of a machine, let’s take a look at some specifics when working with the Windows Subsystem for Linux.</p>&#13;
<h5 class="h5" id="ch00lev3sec18"><strong>Finding Your C: Drive</strong></h5>&#13;
<p class="noindent">Every time you open your Linux subsystem, the shell’s working directory will be set to the Linux subsystem’s home directory. You can reveal this current directory using the <span class="literal">pwd</span> command:</p>&#13;
<pre>$ <span class="codestrong1">pwd</span>&#13;
/home/angel</pre>&#13;
<p class="indent">The WSL has its own directory structure disconnected from your computer’s. But, since you’ll be writing the code for this book on your Windows machine, you’ll need a way of accessing your C: drive. WSL offers a simple way of accessing the C: drive.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>Your local drives are mounted inside a directory in your Linux subsystem called <em>/mnt</em>. Let’s <span class="codestrong">cd</span> into <em>/mnt</em> and then list its contents:</p>&#13;
<pre>$ <span class="codestrong1">cd /mnt</span>&#13;
$ <span class="codestrong1">ls</span>&#13;
c    d</pre>&#13;
<p class="noindent">It’s important to use the absolute path (starting with /) to navigate to <span class="literal">/mnt</span>. The <span class="literal">ls</span> command listed my two drives: C: and D:. To open one of them, simply change directories:</p>&#13;
<pre>$ <span class="codestrong1">cd c</span></pre>&#13;
<p class="noindent">Now your WSL’s working directory is your C: drive. You can find your <em>Users</em> home directory or whatever folder you’ll be using to write your code:</p>&#13;
<pre>$ <span class="codestrong1">cd Users/angel</span></pre>&#13;
<h5 class="h5" id="ch00lev3sec19"><strong>Ensuring Python’s Installation (Ubuntu)</strong></h5>&#13;
<p class="noindent">Ubuntu comes already packed with Python version 3 installed. You can check the installed version from the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 --version</span>&#13;
Python 3.8.2</pre>&#13;
<p class="indent">You can update Python to its latest version using Ubuntu’s <span class="literal">apt</span> command line tool. First you’ll need to update the <span class="literal">apt</span> package lists so that they are up-to-date with the latest versions of the available software. You need to run this command as <em>superuser</em>. You can do this by prefixing the command you want to run with <span class="literal">sudo</span>, short for <em>superuser</em> do. You’ll need to provide your password for any command you run as superuser:</p>&#13;
<pre>$ <span class="codestrong1">sudo apt update</span>&#13;
[sudo] password for angel: <span class="codeitalic1">&lt;write your password here&gt;</span></pre>&#13;
<p class="indent">When you write your password, you won’t see anything written in the shell. As you type, the prompt will remain blank, mainly for security reasons. Once the package lists are up-to-date, you can upgrade Python’s version:</p>&#13;
<pre>$ <span class="codestrong1">sudo apt upgrade python3</span></pre>&#13;
<p class="noindent">Now you can be sure you have the latest stable release for Python’s version 3 available for Ubuntu. You are now ready to learn how to run Python scripts.</p>&#13;
<h3 class="h3" id="ch00lev1sec24"><strong>Running Python Scripts</strong></h3>&#13;
<p class="noindent">Running a Python file using the command line is a straightforward process:</p>&#13;
<pre>$ <span class="codestrong1">python3</span> &lt;<span class="codeitalic1">filename.py</span>&gt;</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_57"/>It’s important that we use Python’s version 3 interpreter because we’ll use some features available only in this version. As Python versions 2 and 3 can both be installed on the same machine, the version 3 interpreter is named with a 3 at the end.</p>&#13;
<p class="indent">Let’s create a Python file and execute it. In your shell, use the following command to create a new Python file:</p>&#13;
<pre>$ <span class="codestrong1">touch script.py</span></pre>&#13;
<p class="noindent">This will create a new file, <em>script.py</em>, in the shell’s working directory. Open the file in PyCharm, or your editor of choice, and enter a <span class="codestrong">print</span> statement:</p>&#13;
<pre>print('hello, World!')</pre>&#13;
<p class="indent">Make sure to save the file. Let’s check that our <em>script.py</em> file was correctly written:</p>&#13;
<pre>$ <span class="codestrong1">cat script.py</span>&#13;
print('hello, World!')</pre>&#13;
<p class="indent">Finally, let’s execute our Python script from the command line:</p>&#13;
<pre>$ <span class="codestrong1">python3 script.py</span>&#13;
hello, World!</pre>&#13;
<p class="noindent">As expected, our program gives us a <span class="literal">hello, World!</span> greeting.</p>&#13;
<h3 class="h3" id="ch00lev1sec25"><strong>Passing Arguments to the Script</strong></h3>&#13;
<p class="noindent">Command line programs can accept arguments. Let’s try this and accept an argument in our Python script to personalize the greeting. Open the <em>script.py</em> file and modify it so that it now contains the following:</p>&#13;
<pre>import sys&#13;
&#13;
name = sys.argv[1] if len(sys.argv) &gt; 1 else 'unknown'&#13;
print(f'Hello, {name}')</pre>&#13;
<p class="noindent">Python’s <span class="literal">sys.argv</span> is a list of the arguments passed in to the executing script. This first item of the list is always the name of the executing program, in this case, <em>script.py</em>. For this reason, we first need to check whether the list of arguments contains more than one item to know whether the name was passed to the program as an argument. If we detect that the user passed an argument, we use it as the name of the person we want to greet, but if no argument is passed, we default the name to <span class="literal">unknown</span>.</p>&#13;
<p class="indent">We can now run our program without arguments to get an impersonal greeting:</p>&#13;
<pre>$ <span class="codestrong1">python3 script.py</span>&#13;
Hello, unknown!</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_58"/>We can also pass the script a name to get a more personalized greeting:</p>&#13;
<pre>$ <span class="codestrong1">python3 script.py Jenny</span>&#13;
Hello, Jenny!</pre>&#13;
<h3 class="h3" id="ch00lev1sec26"><strong>Standard Input and Output</strong></h3>&#13;
<p class="noindent">Programs executed in the shell can read and write data. When a program, like our <em>script.py</em> from earlier, prints something, it appears as output in the shell. Our earlier program outputted a string like <span class="literal">Hello, Jenny!</span> that was then displayed in the shell. The shell’s screen is generally referred to as the <em>standard output</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec33"><strong><em>Redirecting the Output to a File</em></strong></h4>&#13;
<p class="noindent">Earlier, we wrote the result of an <span class="literal">echo</span> command to a file by redirecting the output with the <span class="literal">&gt;</span> character.</p>&#13;
<p class="indent">Try this in your shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 script.py Jenny &gt; greeting.txt</span>&#13;
$ <span class="codestrong1">cat greeting.txt</span>&#13;
Hello, Jenny!</pre>&#13;
<p class="noindent">This time, the result of the <em>script.py</em> program wasn’t printed to the shell’s screen, but instead it was written to a new file, <em>greeting.txt</em>.</p>&#13;
<p class="indent">Using the <span class="literal">&gt;</span> character, we can redirect the output of a program to a new file. If the target file already exists, it gets overwritten. We can also use the <span class="literal">&gt;&gt;</span> characters to append something to an existing file instead of creating a new one:</p>&#13;
<pre>$ <span class="codestrong1">python3 script.py Angel &gt;&gt; greeting.txt</span>&#13;
$ <span class="codestrong1">cat greeting.txt</span>&#13;
Hello, Jenny!&#13;
Hello, Angel!</pre>&#13;
<p class="indent">This is a useful technique, and we’ll use it throughout the book to write the result of our programs to an external file.</p>&#13;
<h4 class="h4" id="ch00lev2sec34"><strong><em>Redirecting the Input from a File</em></strong></h4>&#13;
<p class="noindent">Much like we can redirect the shell’s standard output, we can redirect the shell’s input. Let’s create a new script. Instead of reading a name from the program’s argument, it prompts the user to write their name. First, create a new empty file:</p>&#13;
<pre>$ <span class="codestrong1">touch script2.py</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_59"/>Open the file and enter the following code:</p>&#13;
<pre>print("What's your name?")&#13;
name = input()&#13;
print('Hello there, {name}')</pre>&#13;
<p class="noindent">If we run our new script now, it’ll prompt us to write our name:</p>&#13;
<pre>$ <span class="codestrong1">python3 script2.py</span>&#13;
What's your name?&#13;
Angel&#13;
Hello there, Angel</pre>&#13;
<p class="indent">This program reads the name from the <em>standard input</em>, that is, the shell. We had to write the name in the shell and press <small>RETURN</small> for our program to read it. We can redirect the input from a file to our program, this time using the <span class="literal">&lt;</span> character. In this case, the program reads the contents of the file instead of reading from the shell.</p>&#13;
<p class="indent">Let’s write a name inside a new file:</p>&#13;
<pre>$ <span class="codestrong1">echo Mary &gt; name.txt</span></pre>&#13;
<p class="noindent">Now, let’s redirect the input to be read from this file to our program:</p>&#13;
<pre>$ <span class="codestrong1">python3 script2.py &lt; name.txt</span>&#13;
What's your name?&#13;
Hello there, Mary</pre>&#13;
<p class="noindent">This time, instead of having to write anything ourselves when the program prompts for a name, the shell read in the contents of the <em>name.txt</em> file.</p>&#13;
<p class="indent">The applications we’ll write in this book will use input redirecting to read the contents of an input file into our Python programs.</p>&#13;
<h3 class="h3" id="ch00lev1sec27"><strong>Using PyCharm’s Python Console</strong></h3>&#13;
<p class="noindent">As we saw in the introduction of the book, PyCharm comes with two consoles: a Python console and your system’s shell. The former is especially interesting as it allows us to run Python code directly as well as inspect all the loaded symbols. You can open your PyCharm’s Python console by clicking the Python Console button in the lower bar or by selecting View ▸ Tool Windows ▸ Python Console in the menu.</p>&#13;
<p class="indent">The Python console, as you can see in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>, is divided into two panes: the left pane is the console where you write Python code, and the right pane includes a list of all the variables you’ve defined. Let’s do a practical exercise to learn how this works.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_60"/><img src="../images/03fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch3fig1"><em>Figure 3-1: PyCharm Python console</em></p>&#13;
<p class="indent">In the Python prompt, enter the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">names = ['Angel', 'Alvaro', 'Mary', 'Paul', 'Isabel']</span></pre>&#13;
<p class="noindent">Now the right pane includes a list of symbols that you can explore (see <a href="ch03.xhtml#ch3fig2">Figure 3-2</a>). You can expand the <span class="literal">names</span> symbol to inspect the items inside the list.</p>&#13;
<div class="image"><img src="../images/03fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch3fig2"><em>Figure 3-2: Declaring a list of names</em></p>&#13;
<p class="indent">Let’s now write a function to filter a list of strings, keeping only those that are shorter than a given length. Write the following in the console (note the three dots marking the indentation when writing code in the console):</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">def filter_list_shorter_than(lst, length):</span>&#13;
...     <span class="codestrong1">return [item for item in lst if len(item) &lt; length]</span>&#13;
...&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">filter_list_shorter_than(names, 5)</span>&#13;
['Mary', 'Paul']</pre>&#13;
<p class="noindent">If you want to keep a reference of the filtered list, you can save the result to a variable:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">result = filter_list_shorter_than(names, 5)</span></pre>&#13;
<p class="noindent">Now you can use the Python console’s right pane to explore the <span class="literal">result</span> list.</p>&#13;
<p class="indent">You can also import Python modules from the console. You can import modules from your own project or from the standard library. For instance, if you have the <em>Mechanics</em> project you downloaded earlier open in PyCharm, you can import the <span class="literal">Point</span> class.<span epub:type="pagebreak" id="page_61"/></p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p = Point(10, 15)</span></pre>&#13;
<p class="indent">Importing a module from the standard library is equally simple. For instance, to import the <span class="literal">JSONDecoder</span> class from the <span class="literal">json</span> module, use the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from json import JSONDecoder</span></pre>&#13;
<p class="indent">From time to time we may want to reload the console so that all the imported modules and defined variables are cleared. This is a good idea, because the modules you import and the variables you define might interact with the new code you write. We can reload the Python’s console by clicking the reload button located at the top left of the console (see <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>).</p>&#13;
<div class="image"><img src="../images/03fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch3fig3"><em>Figure 3-3: Reloading the console</em></p>&#13;
<p class="indent">Take your time exploring PyCharm’s Python console, as you’ll find it useful throughout the book; we’ll often test our code by running quick experiments in it.</p>&#13;
<h3 class="h3" id="ch00lev1sec28"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this short chapter, we covered the basics of using the bash/zsh command line. From this shell we can issue commands to the computer, and we’ll execute our Python scripts from here. We also explored the standard input and output redirection, a technique we’ll use extensively throughout the book.</p>&#13;
<p class="indent">Without further ado, let’s start creating our <em>Mechanics</em> project. Let the fun begin!<span epub:type="pagebreak" id="page_62"/></p>&#13;
</body></html>