- en: '**18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**18'
- en: 'NUMPY: NUMERICAL PYTHON**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'NUMPY: 数值计算 Python**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Short for *Numerical Python*, *NumPy* serves as Python’s foundational library
    for numerical computing. It extends Python’s mathematical capability and forms
    the basis of many scientific and mathematical packages. As a result, you’ll need
    to understand NumPy in order to effectively use Python’s scientific libraries
    such as Matplotlib (for plotting) and pandas (for data analysis).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*NumPy* 是 *Numerical Python* 的缩写，是 Python 数值计算的基础库。它扩展了 Python 的数学功能，成为许多科学和数学包的基础。因此，你需要了解
    NumPy，才能有效使用 Python 的科学库，如 Matplotlib（用于绘图）和 pandas（用于数据分析）。'
- en: NumPy is open source and comes preinstalled with Anaconda. It augments the built-in
    tools in the Python Standard Library, which can be too simple for many data analysis
    calculations. Using NumPy, you can perform fast operations, including mathematical,
    logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms,
    basic linear algebra, basic statistical operations, random simulation, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是开源的，并且与 Anaconda 一起预安装。它增强了 Python 标准库中内置工具的功能，这些工具对于许多数据分析计算来说可能过于简单。使用
    NumPy，你可以执行快速操作，包括数学、逻辑、形状操作、排序、选择、I/O、离散傅里叶变换、基本线性代数、基本统计运算、随机模拟等。
- en: At the core of NumPy is the *array* data structure, which is basically a grid
    of values. By using precompiled C code, multidimensional arrays, and functions
    that operate on arrays, NumPy speeds up the running of slower algorithms and performs
    high-level mathematical calculations in a highly efficient manner. NumPy also
    makes it easier to work with large, uniform datasets with millions to billions
    of samples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的核心是 *array* 数据结构，基本上是一个值的网格。通过使用预编译的 C 代码、多维数组和操作数组的函数，NumPy 加速了较慢算法的运行，并以高效的方式执行高级数学计算。NumPy
    还使得处理具有数百万到数十亿样本的大型均匀数据集变得更加容易。
- en: You can’t understand NumPy if you don’t understand arrays, so in this chapter,
    we’ll focus on these features first and then look at some of the library’s basic
    functionality. For further study, visit the official site (*[https://numpy.org/](https://numpy.org/)*),
    which contains both “quickstart” and more detailed tutorials and guides.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解数组，就无法理解 NumPy，因此在本章中，我们将首先关注这些特性，然后再查看库的一些基本功能。有关进一步学习，请访问官方站点 (*[https://numpy.org/](https://numpy.org/)*)，该站点包含“快速入门”和更详细的教程和指南。
- en: '**Introducing the Array**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**介绍数组**'
- en: In computer science, an array is a data structure that contains a group of elements
    (values or variables) of the same size and data type (referred to as *dytpes*
    in NumPy). An array can be indexed by a tuple of nonnegative integers, by Booleans,
    by another array, or by integers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，数组是一种数据结构，包含一组具有相同大小和数据类型（在NumPy中称为*dytpes*）的元素（值或变量）。数组可以通过非负整数的元组、布尔值、另一个数组或整数进行索引。
- en: 'Here’s an example of a two-dimensional array of integers, comprising a grid
    of two rows and three columns. Because arrays use square brackets, they look a
    lot like Python lists:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二维整数数组的示例，由两行三列组成的网格。由于数组使用方括号，因此它们看起来与 Python 列表非常相似：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To select an element from this array, you can use standard indexing and slicing
    techniques. For example, to select the element `2`, you would index first the
    row and then the column, using `[0][2]`(remember: Python starts counting at 0,
    not 1).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这个数组中选择一个元素，可以使用标准的索引和切片技术。例如，要选择元素 `2`，你需要先索引行，然后是列，使用 `[0][2]`（记住：Python
    从 0 开始计数，而不是从 1）。
- en: There are several reasons why you might want to work with arrays. Accessing
    individual elements by index is extremely efficient, making runtimes constant
    regardless of the array size. In fact, arrays let you perform complex computations
    on entire blocks of data without the need to loop through and access each element
    one at a time. As a result, NumPy-based algorithms run orders of magnitude faster
    than those in native Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有几个理由想要使用数组。通过索引访问单个元素非常高效，使得无论数组大小如何，运行时间都是常数。实际上，数组让你能够对整块数据执行复杂的计算，而无需逐个循环并访问每个元素。因此，基于
    NumPy 的算法运行速度比原生 Python 中的算法快几个数量级。
- en: In addition to being faster, arrays store data in contiguous memory blocks,
    resulting in a significantly smaller memory footprint than built-in Python sequences,
    like lists. A list, for example, is basically an array of pointers to (potentially)
    heterogeneous Python objects stored in non-contiguous blocks, making it much less
    compact than a NumPy array. Consequently, arrays are often the preferred data
    structure for storing data reliably and efficiently. The popular OpenCV computer
    vision library, for example, manipulates and stores digital images as NumPy arrays.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更快之外，数组还将数据存储在连续的内存块中，与Python内置的非连续块列表等序列相比，内存占用显著较小。例如，列表基本上是指向（可能是）非连续块中存储的异构Python对象的指针数组，使其比NumPy数组非常不紧凑。因此，数组通常是存储数据的首选数据结构，可靠且高效。例如，流行的OpenCV计算机视觉库将数字图像操作和存储为NumPy数组。
- en: '***Describing Arrays Using Dimension and Shape***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用维度和形状描述数组***'
- en: Understanding arrays requires knowledge of their layout. The number of *dimensions*
    in an array is the number of indexes needed to select an element from the array.
    You can think of a dimension as an array’s *axis*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数组需要了解它们的布局。数组中的*维度*是从数组中选择元素所需的索引数量。你可以将维度看作是数组的*轴*。
- en: The number of dimensions in an array, also called its *rank*, can be used to
    describe the array. [Figure 18-1](ch18.xhtml#ch018fig1) is a graphical example
    of one-, two-, and three-dimensional arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的维度数量，也称为其*秩*，可用于描述数组。图18-1是一维、二维和三维数组的图形示例。
- en: '![Image](../images/18fig01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/18fig01.jpg)'
- en: '*Figure 18-1: Graphical representations of arrays in one, two, and three dimensions*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-1：一维、二维和三维数组的图形表示*'
- en: The *shape* of an array is a tuple of integers representing the size of the
    array along each dimension, starting with the first dimension (axis 0). Example
    shape tuples are shown below each array in [Figure 18-1](ch18.xhtml#ch018fig1).
    The number of integers in these tuples equals the array’s rank.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的*形状*是一个整数元组，表示沿每个维度的数组大小，从第一个维度（轴0）开始。示例形状元组如下所示，每个数组下方显示在图18-1中。
- en: 'A one-dimensional array, also referred to as a *vector*, has a single axis.
    This is the simplest form of array and is the NumPy equivalent to Python’s `list`
    data type. Here’s an example of how the 1D array in [Figure 18-1](ch18.xhtml#ch018fig1)
    looks in Python:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组，也称为*向量*，具有单个轴。这是数组的最简单形式，是Python的`list`数据类型的NumPy等效形式。以下是图18-1中1D数组在Python中的示例外观：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arrays with more than one dimension are basically arrays within arrays. An array
    with both rows and columns is called a 2D array. The 2D array in [Figure 18-1](ch18.xhtml#ch018fig1)
    has a shape tuple of (2, 3) because the length of its first axis (0) is 2 and
    the length of its second axis (1) is 3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个维度的数组基本上是数组内的数组。具有行和列的数组称为2D数组。图18-1中的2D数组具有形状元组(2, 3)，因为其第一个轴（0）的长度为2，第二个轴（1）的长度为3。
- en: A 2D array is used to represent a *matrix*. You might remember from math class
    that these are rectangular grids of elements such as numbers or algebraic expressions,
    arranged in rows and columns and enclosed by square brackets. Matrices store data
    in an elegant and compact manner, and despite containing many elements, each matrix
    is treated as one unit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 2D数组用于表示*矩阵*。您可能还记得数学课上的矩阵，这些是元素（例如数字或代数表达式）的矩形网格，排列在行和列中，并用方括号括起来。矩阵以一种优雅而紧凑的方式存储数据，尽管包含许多元素，但每个矩阵被视为一个单位。
- en: 'Here’s an example of the 2D array in [Figure 18-1](ch18.xhtml#ch018fig1) rendered
    in Python:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Python中图18-1中2D数组的示例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An array with three or more dimensions is called a *tensor*. As mentioned earlier,
    arrays can have any number of dimensions. Here’s an example of the 3D array in
    [Figure 18-1](ch18.xhtml#ch018fig1):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 具有三个或更多维度的数组称为*张量*。如前所述，数组可以具有任意数量的维度。以下是图18-1中3D数组的示例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tensors can be difficult to visualize in a two-dimensional display, but Python
    tries to help you out. Note how a blank line separates the two stacked matrices
    that comprise the 3D grid. You can also determine the rank of an array by counting
    the number of square brackets at the start of the output. Three square brackets
    in a row means that you’re dealing with a 3D array.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Arrays***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy handles arrays through its `ndarray` class, also known by the alias `array`.
    The `ndarray` name is short for *N-dimensional*, as this class can handle any
    number of dimensions. NumPy `ndarray`s have a fixed size at creation and can’t
    grow like a Python list or tuple. Changing the size of an `ndarray` creates a
    new array and deletes the original.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '*You should know numpy.array is not the same as array.array, found in the Python
    Standard Library. The latter is only a one-dimensional array and has limited functionality
    compared to NumPy arrays.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: NumPy comes with several built-in functions for creating `ndarray`s. These let
    you create arrays outright or convert existing sequence data types, like tuples
    and lists, to arrays. [Table 18-1](ch18.xhtml#ch018tab1) lists some of the more
    common creation functions. We’ll look at some of these in more detail in the sections
    that follow. You can find a complete listing of creation functions at *[https://numpy.org/doc/stable/reference/routines.array-creation.html](https://numpy.org/doc/stable/reference/routines.array-creation.html)*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Array Creation Functions'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `array` | Convert (copy) input sequence to an `ndarray` by inferring or specifying
    a `dtype` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `asarray` | Like `array` but with fewer options and does not create a copy
    by default |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `arange` | Like built-in `range()` function but returns an `ndarray` instead
    of a list |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `linspace` | Return evenly spaced numbers over a specified interval |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `ones` | Produce an `ndarray` of all 1s with a given shape and `dtype` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `ones_like` | Produce a ones `ndarray` of the same shape and `dtype` as an
    input array |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `zeros` | Produce an `ndarray` of all 0s with a given shape and `dtype` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `zeros_like` | Produce a `zeros ndarray` of the same shape and `dtype` as
    an input array |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `empty` | Allocate new memory for a new unpopulated `ndarray` of a given
    shape |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `empty_like` | Allocate new memory for a new unpopulated `ndarray` based
    on an input array |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `full` | Produce an `ndarray` of a given shape and `dtype` with all values
    set to a fill value |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `full_like` | Take an input array and produce a filled array of the same
    shape and `dtype` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `eye` | Return a square 2D array with ones on the diagonal and zeros elsewhere
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `identity` | Like `eye` but without the option to specify the index of the
    diagonal |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: Because arrays must contain data of the same type, the array needs to know the
    `dtype` that’s being passed to it. You’ll have the choice of letting the functions
    infer the most suitable `dtype` (although you’ll want to check the result) or
    providing the `dtype` explicitly as an additional argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Some commonly used `dtype`s are listed in [Table 18-2](ch18.xhtml#ch018tab2).
    The Code column lists the shorthand arguments you can pass to the functions in
    single quotes, such as `dtype=` `'i8` `'`, in place of `dtype=` `'int64` `'`.
    For a full list of supported data types, visit *[https://numpy.org/doc/stable/user/basics.types.html](https://numpy.org/doc/stable/user/basics.types.html)*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Common NumPy Data Types'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Code** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `?` | Boolean type (True and False). |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `object` | `O` | Any Python object type. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `string_` | `S`n | Fixed-length ASCII string type with 1 byte per character.
    The n parameter represents the length of the longest string, such as `''S15''`.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `unicode_` | `U`n | Fixed-length Unicode type with number of bytes platform
    specific. The n parameter represents the longest length, such as `''U12''`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `int8, uint8` | `i1, u1` | Signed and unsigned 8-bit (1 byte) integer types.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `int16, uint16` | `i2, u2` | Signed and unsigned 16-bit integer types. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `int32, uint32` | `i4, u4` | Signed and unsigned 32-bit integer types. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `int64, uint64` | `i8, u8` | Signed and unsigned 64-bit integer types. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `f4` or `f` | Single-precision floating-point type. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `f8` or `d` | Double-precision floating-point type compatible
    with Python float. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `float128` | `f16` or `g` | Extended-precision floating-point type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | `c8` | Complex number represented by two 32-bit floats. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | `c16` | Complex number represented by two 64-bit floats. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `complex256` | `c32` | Complex number represented by two 128-bit floats.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: For string and Unicode dtypes, the length of the longest string or Unicode object
    must be included in the `dtype` argument. For example, if the longest string in
    a dataset has 12 characters, the assigned `dtype` should be `'S12'`. This is necessary
    because all the `ndarray` elements should be of the same size. There’s no way
    to create variable-length strings, so you must ensure that enough memory is allocated
    to hold every possible string in the dataset. When using *existing input*, such
    as when converting a list of strings to an array, NumPy can make this calculation
    for you.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Because the amount of memory used by the `dtype`s is automatically assigned
    (or can be input), NumPy knows how much memory to allocate when creating `ndarray`s.
    The choices in [Table 18-2](ch18.xhtml#ch018tab2) give you plenty of control over
    how data is stored in memory, but don’t let that intimidate you. Most of the time,
    all you’ll need to know is the basic type of data you’re using, such as a float
    or integer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW NUMPY ALLOCATES MEMORY**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The genius of NumPy is in how it allocates memory. The following figure shows
    information stored in a 3x4 2D array of numbers from 0 to 11, represented by the
    “Python View” diagram at the bottom of the figure. You’re already familiar with
    parameters such as `dtype`, dimensions, and data, so let’s focus on memory allocation
    and strides.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0496-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: The values of an `ndarray` are stored as a contiguous block of memory in your
    computer’s RAM, as shown by the Memory Block diagram in the figure. This is efficient,
    as processors prefer items in memory to be in chunks rather than randomly scattered
    about. The latter occurs when you store data in Python data types like lists,
    which keep track of *pointers* to objects in memory, creating “overhead” that
    slows down processing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: To help NumPy interpret the bytes in memory, the `dtype` object stores additional
    information about the *layout* of the array, such as the size of the data (in
    bytes) and the byte order of the data. Because we’re using the `int32` `dtype`
    in the example, each number occupies 4 bytes of memory (32 bits/8 bits per byte).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`Ndarray`s come with an attribute, `strides`, which is a tuple of the number
    of bytes to step in each dimension when traversing an array. This tuple informs
    NumPy on how to convert from the contiguous Memory Block to the Python View array
    shown in the figure.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, the memory block consists of 48 bytes (12 integers x 4 bytes
    each), stored one after the other. The array strides indicate how many bytes must
    be skipped in memory to move to the next position along a certain axis. For example,
    we must skip 4 bytes (1 integer) to reach the next column, but 16 bytes (4 integers)
    to move to the same position in the next row. Thus, the strides for the array
    are (16, 4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the array() Function**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The simplest way to create an array is to pass the NumPy `array()` function
    a sequence, such as a list, which is then converted into an `ndarray`. Let’s do
    that now to create a 1D array. We’ll begin by importing NumPy using the alias
    `np` (this is by convention and will reduce the amount of typing needed to call
    NumPy functions):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also create an `ndarray` by passing the `array()` function a variable,
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create a multidimensional array, pass `array()` a nested sequence, where
    each nested sequence is the same length. Here’s an example that uses a list containing
    three nested lists to create a 2D array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each nested list became a new row in the 2D array. To build the same array from
    tuples, you would replace all the square brackets `[]` in line `In [8]` with parentheses
    `()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '*When you print an array, NumPy displays it with the following layout: the
    last axis is printed from left to right, the second-to-last is printed from top
    to bottom, the rest are also printed from top to bottom, with each slice separated
    from the next by an empty line. So, 1D arrays are printed as rows, 2D arrays as
    matrices, and 3D arrays as lists of matrices.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你打印一个数组时，NumPy 会按照以下布局显示它：最后一个轴从左到右打印，倒数第二个从上到下打印，其他轴也从上到下打印，每个切片之间用空行分隔。所以，1D
    数组打印为行，2D 数组为矩阵，3D 数组为矩阵列表。*'
- en: Now, let’s check some of the 2D array’s attributes, such as its shape
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看一些二维数组的属性，比如它的形状：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: its number of dimensions
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它的维度数量
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'and its strides:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它的步长：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the items in an array must be the same data type, this doesn’t mean
    that you can’t pass these items to the `array()` function within a mixture of
    sequence types, such as tuples and lists:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组中的项必须是相同的数据类型，但这并不意味着你不能将这些项作为混合序列类型（如元组和列表）传递给 `array()` 函数：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This worked because NumPy reads the data type of the elements in a sequence
    rather than the data type of the sequence itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为 NumPy 读取的是序列中元素的数据类型，而不是序列本身的数据类型。
- en: 'You won’t have the same luck, however, if you try to pass nested lists of different
    lengths:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试传递不同长度的嵌套列表，你可能不会这么幸运：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can avoid this warning by changing the `dtype` to `object`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `dtype` 更改为 `object` 来避免此警告，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that you now have a 1D array of list objects rather than the 2D array of
    integers you wanted. Just as with mathematical matrices, arrays need to have the
    *same number of rows and columns* if you plan to use them for mathematical calculations
    (there’s some flexibility to this, but we’ll save it for the section on “broadcasting”).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你现在得到的是一个包含列表对象的一维数组，而不是你想要的二维整数数组。就像数学矩阵一样，数组如果要用于数学计算，它们需要具有 *相同的行和列数*（虽然在这方面有一定的灵活性，但我们会把它留到“广播”一节讲解）。
- en: 'Now, let’s look at arrays with more than two dimensions. The `array()` function
    transforms sequences of sequences into two-dimensional arrays; sequences of sequences
    of sequences into three-dimensional arrays; and so on. So, to make a 3D array,
    you need to pass the function multiple nested sequences. Here’s an example using
    nested lists:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看具有多于两个维度的数组。`array()` 函数将序列的序列转换为二维数组；序列的序列的序列转换为三维数组；依此类推。所以，要创建一个
    3D 数组，你需要传递多个嵌套的序列。下面是一个使用嵌套列表的示例：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we passed a list containing two nested lists that each contained
    two nested lists. Notice how the output array has a blank line in the middle.
    This visually separates the two stacked 2D arrays created by the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们传递了一个包含两个嵌套列表的列表，每个嵌套列表中又包含两个嵌套列表。注意输出的数组中间有一个空行，这在视觉上分隔了函数创建的两个堆叠的二维数组。
- en: Keeping track of all those brackets when creating high-dimension arrays can
    be cumbersome and dangerous to your eyesight. Fortunately, NumPy provides additional
    methods for creating arrays that can be more convenient than the `array()` function.
    We’ll look at some of these in the next sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建高维数组时，跟踪所有的括号可能既繁琐又对视力有害。幸运的是，NumPy 提供了其他创建数组的方法，这些方法比 `array()` 函数更方便。我们将在接下来的部分中探讨这些方法。
- en: '**Using the arange() Function**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 arange() 函数**'
- en: To create arrays that hold sequences of numbers, NumPy provides the `arange()`
    function, which works like Python’s built-in `range()` function, only it returns
    an array rather than an immutable sequence of numbers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建包含数字序列的数组，NumPy 提供了 `arange()` 函数，它的功能类似于 Python 内置的 `range()` 函数，只不过它返回的是数组，而不是不可变的数字序列。
- en: 'The `arange()` function takes similar arguments to `range()`. Here, we make
    a 1D array of the integers from 0 to 9:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange()` 函数接受与 `range()` 相似的参数。这里，我们创建一个从 0 到 9 的一维数组：'
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also add a start, stop, and step argument to create an array of the
    even numbers between 0 and 10:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加起始、结束和步长参数来创建一个包含 0 到 10 之间偶数的数组：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we start the sequence at 5 and stop at 9:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从 5 开始序列，并在 9 停止：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Whereas `range()` always produces a sequence of integers, `arange()` lets you
    specify the data type of the numbers in the array. Here, we use double-precision
    floating-point numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `range()` 总是产生整数序列，`arange()` 则允许你指定数组中数字的数据类型。这里，我们使用双精度浮点数：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Interestingly, `arange()` accepts a float for the step parameter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`arange()` 允许为步长参数传入浮动数值：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When arange() is used with floating-point arguments, it’s usually not possible
    to predict the number of elements obtained, due to the finite floating-point precision.
    For this reason, it’s better to use the NumPy linspace() function, which receives
    as an argument the number of elements desired instead of the step argument. We’ll
    look at linspace() shortly.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*当`arange()`与浮点数参数一起使用时，通常无法预测获得的元素数量，因为浮点数的精度有限。因此，最好使用NumPy的`linspace()`函数，该函数接收所需元素数量作为参数，而不是步长参数。我们稍后将详细讨论`linspace()`。*'
- en: 'With the `arange()` and `reshape()` functions, you can create a multidimensional
    array—and generate a lot of data—with a single line of code. The `arange()` function
    creates a 1D array, and `reshape()` divides this linear array into different parts
    as specified by a shape argument. Here’s an example using the 3D shape tuple (2,
    2, 4):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arange()`和`reshape()`函数，你可以通过一行代码创建多维数组——并生成大量数据。`arange()`函数创建一个一维数组，`reshape()`将这个线性数组按照形状参数划分为不同的部分。以下是使用3D形状元组(2,
    2, 4)的示例：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because arrays need to be symmetrical, the product of the shape tuple must
    equal the size of the array. In this case, `(8, 2, 1)` and `(4, 2, 2)` will work,
    but `(2, 3, 4)` will raise an error because the resulting array has 24 elements,
    whereas you specified 16 (`np.arange(16)`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组需要对称，形状元组的乘积必须等于数组的大小。在这种情况下，`(8, 2, 1)`和`(4, 2, 2)`是有效的，但`(2, 3, 4)`会报错，因为结果数组包含24个元素，而你指定的是16个元素（`np.arange(16)`）：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Using the linspace() Function**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用linspace()函数**'
- en: The NumPy `linspace()` function creates an `ndarray` of evenly spaced numbers
    within a defined interval. It’s basically the `arange()` function with a `num`
    (number of samples) argument rather than a `step` argument. The `num` argument
    determines how many elements will be in the array, and the function calculates
    the intervening numbers so that the intervals between them are the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的`linspace()`函数创建一个在定义区间内均匀间隔的`ndarray`。它基本上是带有`num`（样本数量）参数的`arange()`函数，而不是`step`参数。`num`参数决定数组中将包含多少个元素，函数会计算它们之间的数值，使间隔相等。
- en: 'Suppose that you want an array of size 6 with values between 0 and 20\. All
    you need to do is pass the function a start, stop, and `num` value, as follows,
    using keyword arguments for clarity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个大小为6的数组，值在0和20之间。你只需传递一个起始值、终止值和`num`值，如下所示，并为清晰起见使用关键字参数：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This produced a 1D array of six floating-point values, with all the values evenly
    spaced. Note that the stop value (`20`) is included in the array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了一个包含六个浮点值的一维数组，所有值均匀分布。请注意，终止值（`20`）包含在数组中。
- en: 'You can force the function to not include the endpoint by setting the Boolean
    parameter `endpoint` to `False`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将布尔参数`endpoint`设置为`False`，强制函数不包括终点：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to retrieve the size of the intervals between values, set the Boolean
    parameter `retstep` to `True`. This returns the step value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取值之间间隔的大小，可以将布尔参数`retstep`设置为`True`。这样会返回步长值：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, the `linspace()` function returns a `dtype` of `float64`. You can
    override this by passing it a `dtype` argument:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`linspace()`函数返回`dtype`为`float64`。你可以通过传递`dtype`参数来覆盖这一点：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You’ll need to be careful when changing the data type, however, as the result
    may no longer be a linear space due to rounding.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更改数据类型时需要小心，因为由于四舍五入，结果可能不再是线性空间。
- en: 'As with `arange()`, you can reshape the array on the fly. Here, we produce
    a 2D array with the same `linspace()` arguments:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和`arange()`一样，你可以实时地重塑数组。在这里，我们使用相同的`linspace()`参数生成一个二维数组：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**NOTE**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s possible to create sequences with uneven spacing. The np.logspace() function,
    for example, creates a logarithmic space with numbers evenly spaced on a log scale.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以创建间隔不均匀的序列。例如，`np.logspace()`函数创建一个对数空间，其中的数字在对数尺度上均匀分布。*'
- en: The `linspace()` function lets you control the number of elements in an array,
    something that can be challenging to do when using `arange()`. Arrays of evenly
    spaced numbers are useful when working with mathematical functions of continuous
    variables. Likewise, linear spaces come in handy when you need to evenly sample
    an object, such as a waveform. To see some useful examples of `linspace()` in
    action, visit *[https://realpython.com/np-linspace-numpy/](https://realpython.com/np-linspace-numpy/)*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`linspace()` 函数让你控制数组中元素的数量，这是使用 `arange()` 时可能遇到的挑战。均匀间隔的数字数组在处理连续变量的数学函数时非常有用。同样，当你需要均匀地采样一个对象，比如波形时，线性空间也非常有用。要查看
    `linspace()` 的一些有用示例，请访问 *[https://realpython.com/np-linspace-numpy/](https://realpython.com/np-linspace-numpy/)*。'
- en: Along these lines, the `meshgrid()` function creates a rectangular grid out
    of two given 1D arrays. The resulting indexing matrix holds in each cell the x
    and y coordinates for each point in the 2D space. Whereas `meshgrid()` is useful
    when plotting and interpolating 2D arrays, the `mgrid()` function calls `meshgrid()`
    to produce a dense “meshgrid” with multiple dimensions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`meshgrid()` 函数根据给定的两个一维数组创建一个矩形网格。生成的索引矩阵在每个单元格中保存二维空间中每个点的 x 和 y 坐标。虽然 `meshgrid()`
    在绘图和插值二维数组时非常有用，但 `mgrid()` 函数调用 `meshgrid()` 来生成一个密集的“网格”，支持多个维度。'
- en: '**Creating Prefilled Arrays**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建预填充数组**'
- en: For convenience, NumPy lets you create `ndarray`s using prefilled ones, zeros,
    random values, or values of your own choosing. You can even create an empty array
    with no predefined values. These arrays are commonly used when you need a structure
    for holding computation results, for training machine learning applications, for
    creating image masks, for performing linear algebra, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，NumPy 允许你使用预填充的 1、0、随机值或自定义值来创建 `ndarray`。你甚至可以创建一个没有预定义值的空数组。这些数组通常用于需要一个用于存储计算结果的结构，机器学习训练应用，创建图像掩膜，执行线性代数等情况。
- en: 'To create a zero-filled array, simply pass the `zero()` function a shape tuple,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个填充为零的数组，只需传递 `zero()` 函数一个形状元组，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To create an array filled with ones, repeat the process with the `ones()` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个填充为 1 的数组，使用 `ones()` 函数重复此过程：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `np.eye()` function creates an array where all items are equal to zero,
    except for the *k*th diagonal, whose values are equal to one:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.eye()` 函数创建一个数组，其中所有元素的值都为零，除了 *k* 维度的对角线元素，其值为一：'
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By default, these functions return `float64` values, but you can override this
    using a `dtype` argument, such as `dtype=int`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些函数返回 `float64` 值，但你可以通过 `dtype` 参数覆盖这一点，比如 `dtype=int`。
- en: 'To fill an array with a custom value and data type, use the `full()` function
    with following syntax:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要用自定义值和数据类型填充数组，请使用 `full()` 函数，语法如下：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `empty()` function returns a new `ndarray` of a given shape and filled
    with uninitialized (arbitrary) data of the given data type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty()` 函数返回一个新的 `ndarray`，其形状为给定的形状，并填充了未初始化（任意）数据，数据类型为给定的数据类型：'
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: According to the documentation, `empty()` does not set the array values to zero
    and may therefore be marginally faster than the `zeros()` function. On the other
    hand, it requires the user to manually set all the values in the array, thus you
    should use it with caution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，`empty()` 不会将数组的值设置为零，因此可能比 `zeros()` 函数稍快。但它要求用户手动设置数组中的所有值，因此应谨慎使用。
- en: 'Finally, you can generate arrays of pseudo-random numbers using NumPy. For
    floating-point values between 0 and 1, just pass `random()` a shape tuple:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 NumPy 生成伪随机数数组。对于 0 到 1 之间的浮动值，只需传递一个形状元组给 `random()`：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In addition, you can generate random integers, sample values from a “standard
    normal” distribution, shuffle an existing array’s contents in place, and more.
    We’ll look at some of these options later in the chapter, and you can find the
    official documentation at *[https://numpy.org/doc/stable/reference/random/generator.html](https://numpy.org/doc/stable/reference/random/generator.html)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以生成随机整数，从“标准正态”分布中采样值，打乱现有数组的内容等。我们将在本章稍后介绍这些选项，你也可以在 *[https://numpy.org/doc/stable/reference/random/generator.html](https://numpy.org/doc/stable/reference/random/generator.html)*
    找到官方文档。
- en: '***Accessing Array Attributes***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问数组属性***'
- en: As objects, `ndarray`s have attributes accessible through dot notation. We’ve
    looked at some of these already, and you can find more listed in [Table 18-3](ch18.xhtml#ch018tab3).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象，`ndarray` 具有可通过点符号访问的属性。我们已经查看了一些这些属性，你可以在 [表 18-3](ch18.xhtml#ch018tab3)
    中找到更多。
- en: '**Table 18-3:** Important `ndarray` Attributes'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `ndim` | The number of axes (dimensions) of the array |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `shape` | A tuple of integers indicating the size of the array in each dimension
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `size` | The total number of elements in the array |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `itemsize` | The size in bytes of each element in the array |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `dtype` | An object describing the data type of the elements in the array
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `strides` | A tuple of bytes to step in each dimension when traversing an
    array |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: 'For example, to get the shape of the `arr1d` object, enter the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As a 1D array, there’s only one axis and thus only one index. Note the comma
    after the index, which tells Python that this is a tuple data type and not just
    an integer in parentheses.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the array is the total number of elements it contains. This is
    the same as the product of the elements returned by `shape`. To get the array’s
    size, enter the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To get the array’s `dtype`, enter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that, even if you have a 64-bit machine, the default `dtype` for numbers
    *may be* 32-bit, such as `int32` or `float32`. To ensure that you’re using 64-bit
    numbers, you can specify the `dtype` when creating the array, as follows (for
    `int64`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To get the array’s strides, access the `strides` attribute with dot notation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When using strings in arrays, the `dtype` needs to include the length of the
    longest string. NumPy can generally figure this out on its own, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how the unicode (`U`) `dtype` includes the number 8, which is the length
    of `soybeans`, the longest string item.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the data type and number of bits each item occupies, call the `name`
    attribute on `dtype`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, each item in the array is a `string` occupying 256 bits (8 characters
    x 32 bits). This is different from the `itemsize` attribute, which just displays
    the size of an individual character *in bytes*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 1.  What is *not* a characteristic of an array?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: a.  Enables fast computations with small memory footprint
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: b.  Composed entirely of elements of a single data type
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: c.  Can accommodate up to four dimensions
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: d.  Provides an efficient alternative to looping
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '2.  A two-dimensional array is also known as a:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: a.  Linear array
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: b.  Tensor
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: c.  Rank
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: d.  Matrix
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '3.  A strides tuple tells NumPy:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: a.  The number of different data types in the array
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: b.  The number of bytes to step in each dimension when traversing an array
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: c.  The step size when sampling an array
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: d.  The size of the array in bytes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 4.  You’ve been given a dataset of various-sized digital images and asked to
    take 100 evenly spaced samples of pixel intensity from each. Which NumPy function
    do you use to choose the sample locations?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: a.  `arange()`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: b.  `empty()`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: c.  `empty_like()`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: d.  `full()`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: e.  `linspace()`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Write an expression to generate a square matrix of 100 zeros.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '***Indexing and Slicing Arrays***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The elements within an `ndarray` can be accessed using indexes and slices. This
    lets you extract the value of elements as well as change the values using assignment
    statements. Array indexing uses square brackets `[]`, just like Python lists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Slicing 1D Arrays**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One-dimensional arrays are zero-indexed, so the first index is always `0`. For
    indexing and slicing in reverse, the first value is `-1`. [Figure 18-2](ch18.xhtml#ch018fig2)
    describes the indexes of five elements in an array.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: The indexes of a 1D ndarray*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with list indexing, you won’t have any problems indexing
    1D arrays. Let’s look at some examples in which we select elements using both
    positive and negative indexing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To access every other element in the array, include a step value of 2:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To access multiple elements at once, use an array of comma-separated indexes,
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After you’ve selected these elements, you can assign them a new value and change
    the values in the underlying array, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also assign new values to a group of array elements with array slices.
    In this next example, we use slicing to change the first three elements to a value
    of 100:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the previous example, the value of 100 was propagated across the entire slice.
    This process is known as *broadcasting*. Because array slices are views of the
    source array rather than copies, any changes to the view will modify the original
    array. This is advantageous when working with very large arrays, as it keeps NumPy
    from making memory-intensive copies on the fly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this assignment behavior persists even when array slices are assigned
    to a variable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because the slice itself is an array, it has its own set of indexes that are
    different from those of the source array. Thus, `a_slice[:]` corresponds to `arr2d[3:]`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an actual copy rather than a view, call the `copy()` method, as shown
    here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, the `a_slice` array is separate from `arr1d`, and changing its elements
    does not affect the source array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can first call the `array` function on the slice and then
    mutate the result:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Changing the `a_slice` array had no effect on `arr1d`, because the arrays represent
    separate objects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Slicing 2D Arrays**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two-dimensional arrays are indexed with a pair of values. These value pairs
    resemble Cartesian coordinates, except that the row index (the axis-0 value) comes
    before the column index (the axis-1 value), as shown in [Figure 18-3](ch18.xhtml#ch018fig3).
    Square brackets are used again.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig03.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Indexes of a 2D ndarray*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the 2D array in [Figure 18-3](ch18.xhtml#ch018fig3) to study this
    further:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In a 2D array, each value in the index pair references a 1D array (a whole
    row or column) rather than a single element. For example, specifying an integer
    index of `1` outputs the 1D array that comprises the second row of the 2D array:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Slicing a 2D array also works along 1D arrays. Here we slice over rows, taking
    the last two:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This produced a 2D array of shape (2, 3).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a whole column in the 2D array, use the following syntax:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The colon (`:`) tells NumPy to take all the rows; the `1` then selects only
    column 1, leaving you with only a 1D array from the center column of `arr2d`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also extract a column with the following syntax, though in this case,
    rather than outputting a 1D array containing the column’s values, you generate
    a 2D array of shape (3, 1):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As a rule of thumb, if you slice a 2D array using a mixture of integer indexes
    and slices, you’ll get a 1D array. If you slice along both axes, you’ll get another
    2D array. For a reference, see [Figure 18-4](ch18.xhtml#ch018fig4), which shows
    the results of using various expressions to sample a 2D array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: As with 1D arrays, 2D slices are views of the array that you can use to modify
    the values in the source array. In this example, we select the middle column in
    the array in [Figure 18-3](ch18.xhtml#ch018fig3) and change all of its elements
    to `42`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Image](../images/18fig04.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Example slices through a 2D ndarray*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'To select individual elements from 2D arrays, specify a pair of integers as
    the element’s indexes. For example, to obtain the element from the intersection
    of the second row and second column, enter the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note that this syntax is a less cumbersome version of the more traditional
    nested list syntax in which each index is surrounded by brackets:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Indexing and Slicing Higher-Dimensional Arrays**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The key to indexing and slicing arrays with more than two dimensions is to think
    of them as a *series of stacked arrays of a lower dimension*. We’ll refer to these
    stacked arrays as *plans*. As with 2D arrays, the order in which you index 3D
    arrays is determined by their shape tuples.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at a 3D array with a shape of (2, 3, 4). You can think
    of the first value in the shape tuple as the number of 2D arrays within that 3D
    array. The next two numbers are treated as the shape tuple for these 2D arrays,
    representing its rows and columns, respectively. Here’s an example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When you look at the output, you should see two separate 2D arrays of shape
    `(3, 4)` stacked one atop the other. These are demarcated by a space in the output
    as well as by a new set of square brackets around the second 2D array.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Because the array contains two matrices, the 3D component to the shape tuple
    is `2`. This number comes first, so you can think of the shape tuple as recording
    the number of plans, rows, and columns.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let’s use indexes to retrieve the value `20` in the
    array. We can use the array’s shape tuple (plans, rows, columns) to guide us:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: First, we had to choose the second 2D array, which has an index of `1` because
    Python starts counting at 0\. Next, we selected the third row using `2`. Finally,
    we selected the first column using `0`. The key is to work your way through the
    shape tuple in order. The dimension of the array will let you know how many indexes
    you’ll need (three for a 3D array, four for a 4D array, and so on).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing also follows the order of the shape tuple. For example, to get a view
    of the `arr3d` array’s lower 2D array, you would enter `1` for the plan and then
    use the colon shorthand notation to select all of its rows and columns:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For reference, [Figure 18-5](ch18.xhtml#ch018fig5) shows some example slices
    through a 3D array, along with the resulting shapes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig05.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Some example slices through a 3D ndarray*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, changing the values of elements in a slice will change the source
    array, unless the slice is a copy:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before we move on, let’s practice indexing and slicing an array with more than
    three dimensions. For example, look at the following 4D array:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note how the array starts with four square brackets and uses two blank lines
    to separate the two stacked 3D arrays. Because we’re dealing with a 4D array,
    to select the `20` element, you will need to enter four indexes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, from left to right, you indexed a 4D array to a 3D array; a 3D array to
    a 2D array; a 2D array to a 1D array; and a 1D array to a single element. This
    might be more obvious in [Figure 18-6](ch18.xhtml#ch018fig6), which demonstrates
    stepping through these in order.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig06.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-6: Indexing a 4D array down to a single element at [1, 1, 0, 2]*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This style of ordering will hold true for any number of dimensions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for 4D arrays, where the fourth dimension represents time, it can be
    useful to think of the arrays arranged horizontally, rather than vertically ([Figure
    18-7](ch18.xhtml#ch018fig7)).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig07.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-7: Each 4D slice can represent the same 3D array sampled at a different
    time.*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: In this case, each single 4D slice would represent the same dataset (the 3D
    array) measured at a different point in time. So, to look at the first set of
    measurements, you would enter `arr4d[0, :, :]`, and for the last set of measurements,
    you could enter `arr4d[-1, :, :]`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Indexing**'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to using numerical indexing and slicing, you can select elements
    in arrays using conditions and Boolean operators. This lets you extract elements
    without any prior knowledge of where they are in the array. For example, you might
    have hundreds of monitor wells around a landfill, and you want to find all the
    wells that detect the pollutant toluene above a certain threshold value. With
    Boolean indexing, not only can you identify these wells, but you can also create
    a new array based on the output.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the following condition searches an array for any elements that
    are integers greater than or equal to four:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, Python will return an array of Boolean values containing `True`
    values where the condition is satisfied. Note that this syntax works for `ndarray`s
    of any dimension.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy can also use the Booleans behind the scenes, allowing you to slice an
    array based on a conditional:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Comparing two arrays also produces a Boolean array. In this example we flag
    as `True` all the values in `arr_2` that are greater than those in `arr_1`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A common use of Boolean indexing is to partition a grayscale image into foreground
    and background segments, a process called *thresholding*. This produces a binary
    image based on a cutoff value. Here’s an example in which we create a 2D image
    array and then threshold on values above 4:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Remember that `True` evaluates to `1`, and `False` evaluates to `0`. This lets
    us convert a Boolean array to a numerical array by tacking on the `astype()` function
    and passing it the integer data type.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'After thresholding, the `0` values in the new array should form the number
    4:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To assign values based on a Boolean array, you index the source array based
    on a conditional and then assign a value. Here, we assign `0` to all the elements
    in the array with a value less than `5`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Likewise, you can change entire rows, columns, and plans in a Boolean array
    using indexing. For example, `img[0] = 0` changes all the elements in the first
    row of the `img` array to `0`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The use of Booleans in arrays involves a few quirks. Extracting elements from
    an array using Boolean indexing creates a copy of the data by default, meaning
    that there is no need to use the `copy()` function. Another idiosyncrasy of Boolean
    arrays is that you must replace the `and` and `or` keywords with the `&` and `|`characters,
    respectively, when writing comparison statements.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '6.  Create a 2D `ndarray` of size 30 and shape (5, 6). Then, slice the array
    to sample the values highlighted in gray:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0517.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: '7.  Resample the array from Question 6 to retrieve the elements highlighted
    in gray:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0517-1.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: '8.  Slicing an `ndarray` produces:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: a.  A new array object
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: b.  A copy of the source array
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: c.  A view of the source array
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: d.  A Python `list` object
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '9.  Slicing a 2D array with a combination of a scalar index and another slice
    produces:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: a.  A 2D array
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: b.  A 1D array
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: d.  A single element (0D array)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 10.  What is the rank of this array?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: array([[[[ 0,  1,  2,  3],
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5,  6,  7]],'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 8,  9, 10, 11],'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[12, 13, 14, 15]]],'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[[[16, 17, 18, 19],'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21, 22, 23]],'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[[24, 25, 26, 27],'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[28, 29, 30, 31]]]])'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Manipulating Arrays**'
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy provides tools for working with existing arrays. Common manipulations
    include reshaping arrays, swapping their axes, and merging and splitting arrays.
    These come in handy for jobs like rotating, enlarging, and translating images
    and for fitting machine learning models.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '***Shaping and Transposing***'
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy comes with functions to change the shape of arrays and to transpose arrays
    (invert columns with rows) and swap axes. You’ve already been working with one
    of these, the `reshape()` function.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to be aware of with `reshape()` is that, like all NumPy assignments,
    it creates a *view* of an array rather than a *copy*. In the following example,
    reshaping the `arr1d` array produces only a temporary change to the array:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This behavior is useful when you want to temporarily change the shape of the
    array for use in a computation, without copying any data.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, assigning an array to a new variable just creates another reference
    to the source array. In the following example, despite assigning the reshaped
    `arr1d` array to a new variable named `arr2d`, changing values in `arr2d` also
    changes the corresponding values in `arr1d`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Obviously, this type of behavior can really trip you up. As mentioned earlier,
    if you want to create a distinct `ndarray` object from an existing array, use
    the `copy()` function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify an array in place rather than just create a view, use the `shape()`
    function and pass it a shape tuple:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Compare this code to `In [114] – Out [116]`. Here, the source array is permanently
    changed.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**Flattening an Array**'
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are times when you’ll want to use 1D arrays as input to some process,
    even though your data is of a higher dimension. For example, standard plotting
    routines typically expect simple data structures, such as a list or single flat
    array. Likewise, image data is generally converted to 1D arrays before being fed
    to the input layer of a neural network.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Going from a higher dimension array to a 1D array is known as *flattening*.
    The `ravel()` function lets you do this while making a *view* of the array. Here’s
    an example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To create a copy of the array when flattening, you can use the `flatten()`
    method of the `ndarray` object. Because this produces a copy rather than a view,
    it’s a bit slower than `ravel()`. Here’s the syntax:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can also flatten the original array in place by using the `shape()` function
    and passing it the number of elements in the array:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Remember, you can get the size of an array by calling its `size` attribute using
    dot notation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**Swapping an Array’s Columns and Rows**'
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When analyzing data, it’s good to examine it in multiple ways. [Figure 18-8](ch18.xhtml#ch018fig8)
    shows average temperature data by month for three Texas cities. How you present
    the data, either *by month* or *by location*, can be beneficial depending on the
    questions you’re trying to answer as well as how much space you have for printing
    the information in a report.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig08.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-8: The average monthly temperatures ( ^°F) for three Texas cities
    displayed by month and by city*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as Microsoft Excel lets you easily invert columns and rows, NumPy provides
    the handy `transpose()` function for this operation:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This is still a view of the original array. To create a new array, you can
    add the `copy()` function, like so:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For higher-dimension arrays, you can pass `transpose()` a tuple of axis numbers
    in the order you desire. Let’s transpose a 3D array so that the axes are reordered
    with the third axis first, the first axis second, and the second axis unchanged:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Another method for swapping axes is `swapaxes()`. It takes a pair of axes and
    rearranges the array, returning a view of the array. Here’s an example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***Joining Arrays***'
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy provides several functions that let you merge, or *stack*, multiple existing
    arrays into a new array. Let’s begin by making two 2D arrays, the first composed
    of zeros, and the second composed of ones:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now let’s vertically stack the two arrays using the `vstack()` function. This
    will add the second array to the first as new rows along axis 0:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `hstack()` function adds the second array as new columns on the first:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `row_stack()` and `column_stack()` functions stack 1D arrays to form new
    2D arrays. For example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You also can accomplish column stacking along axis 2 using the depth stacking
    function (`dstack((x, y, z)`). This function is like `hstack()`, except that it
    first converts 1D arrays to 2D column vectors.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '***Splitting Arrays***'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy also lets you divide, or *split*, arrays. As with joining, you can perform
    splitting both vertically and horizontally.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example using the `vsplit()` function. First, let’s create an array:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To split the `source` array in half vertically (axis=0), pass the `vsplit()`
    function the array and `2` as arguments:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To split the `source` array in half horizontally (axis=1), pass `hsplit()`
    the array and `2` as arguments:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the previous examples, the array split must result in an *equal division*.
    With the `split()` function, you can split an array into multiple arrays along
    an axis. You pass the function the original array and the indexes for the parts
    to be split, along with an optional axis number (the default is axis 0). For example,
    to divide the `source` array into three arrays of two, three, and one columns,
    you would enter the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The indexes`[2, 5]` told NumPy where along axis 1 to split the array. To repeat
    this over the rows, just change the `axis` argument to `0`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Doing Math Using Arrays**'
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to create and manipulate arrays, it’s time to apply them
    to their main purpose: mathematical operations. NumPy uses two internal implementations
    to efficiently perform math on arrays: *vectorization* and *broadcasting*. Vectorization
    supports operations between equal-sized arrays, and broadcasting extends this
    behavior to arrays with different shapes.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '***Vectorization***'
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most powerful features of `ndarray`s, *vectorization* lets you perform
    batch operations on data without the need for explicit `for` loops. This means
    that you can apply an operation on a entire array at once without selecting each
    individual element from it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: For equal-sized arrays, arithmetic operations are applied elementwise, as shown
    in [Figure 18-9](ch18.xhtml#ch018fig9).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig09.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-9: Mathematical operations involving equal-sized arrays are performed
    on corresponding elements.*'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Because looping takes place behind the scenes with code implemented in C, vectorization
    leads to faster processing. Let’s look at an example in which we compare looping
    in Python to vectorization in NumPy.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating two datasets of 100,000 randomly-selected integers between
    0 and 500:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, make an empty list and then loop through the two datasets, appending each
    item in `data_a` to the list if it also occurs in `data_b`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that this can also be written as `shared_list = [item for item in data_a
    if item in data_b]` using list comprehension.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your hardware, you’ll need to wait around five seconds or more
    for this loop to complete.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the first three values in the list (yours may differ, as these were
    randomly generated):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let’s repeat this exercise using the NumPy `isin()` function. This optimized
    function compares each element in a target array to another array and returns
    a Boolean. We can combine this with indexing to return the elements with values
    of `True`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This computation ran almost instantly compared to the previous standard Python
    loop.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectorization also permits more concise and readable code that can resemble
    mathematical expressions. For example, to multiply two arrays together, you can
    forgo writing nested loops and just state `arr1 * arr2`, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This behavior applies to all basic arithmetic operations, such as adding, subtracting,
    multiplying, and dividing.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '***Broadcasting***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The technique of *broadcasting* allows operations on arrays of different shapes.
    To understand how it works, consider [Figure 18-10](ch18.xhtml#ch018fig10), in
    which a 1D array of four elements is multiplied by a 1D array of a single element.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig10.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-10: An example of broadcasting when multiplying a 1D ndarray by
    a scalar*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the smaller array is stretched across the larger array until
    they have compatible shapes. The array of shape (1,) becomes an array of shape
    (4,) with its single value repeated so that element-by-element multiplication
    can occur. This same behavior applies to operations between scalars and arrays.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: For broadcasting to work, the dimensions of the two arrays must be compatible.
    Two dimensions are compatible when they are equal or one of them is 1\. NumPy
    determines this compatibility by comparing the array shape tuples, starting with
    the trailing (rightmost) dimension and moving left. For example, to check whether
    different 24-element 3D arrays are broadcastable, NumPy would compare their shape
    tuples, as shown in [Figure 18-11](ch18.xhtml#ch018fig11).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig11.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-11: Checking 3D array dimensions for compatibility (gray-shaded
    values)*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the trailing dimension ➊, NumPy determines that both pairs of
    arrays are compatible, as at least one is equal to 1\. This holds true for the
    next comparison ➋, but the bottom pair fails in the last comparison ➌, because
    6 and 3 are not equal. Consequently, we can’t perform any mathematical operations
    between these two arrays.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, in [Figure 18-12](ch18.xhtml#ch018fig12), a 2D and 1D array are
    compatible, so the 1D array can broadcast down to fill in the missing rows.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig12.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-12: An example of broadcasting when adding a 2D array to a 1D array*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: This allows for element-by-element addition. Broadcasting can occur along rows,
    columns, or plans, as needed. For more on broadcasting, including a practical
    example, visit *[https://numpy.org/doc/stable/user/basics.broadcasting.html](https://numpy.org/doc/stable/user/basics.broadcasting.html)*.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '***The Matrix Dot Product***'
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In NumPy, basic multiplication between arrays is executed element for element.
    In other words, each element in one array is multiplied by the corresponding element
    in a second array. This includes the multiplication of 2D arrays, also known as
    matrices.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: You might remember from math class, however, that proper matrix multiplication
    involves performing operations on rows and columns, not elements. This is the
    *matrix dot product*, in which the horizontals in the first matrix are multiplied
    by the verticals in the second matrix. The results are then added, as shown by
    the gray-shaded values in [Figure 18-13](ch18.xhtml#ch018fig13). Not only is this
    process not *by element*, but it’s also noncommutative, as `arr1 * arr2` is not
    equal to `arr2 * arr1`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig13.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-13: The matrix dot product*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'For multiplying two matrices in this way, NumPy provides the `dot()` function.
    Here’s an example using the matrices in [Figure 18-13](ch18.xhtml#ch018fig13):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can also use the alternate syntax `arr1.dot(arr2)` to compute the dot product.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the dot product, NumPy comes with other functions for performing
    linear algebra. To see the full list, visit *[https://numpy.org/doc/stable/reference/routines.linalg.html](https://numpy.org/doc/stable/reference/routines.linalg.html)*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '***Incrementing and Decrementing Arrays***'
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use augmented operators such as `+=` to change the values in an array
    without creating a new array. Here are some examples using a 1D array:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In these cases, the scalar value is applied to every element in the array.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '***Using NumPy Functions***'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like Python’s standard `math` module, NumPy comes with its own set of mathematical
    functions. These include universal functions and aggregate functions. A *universal*
    function, also known as a *ufunc*, acts in an element-by-element fashion and generates
    a new array with the same size as the input. *Aggregate* functions act on a whole
    array and produce a single value, such as the sum of the elements in the array.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Functions**'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Universal functions that perform simple element-by-element transformations,
    such as taking the log or squaring an element, are referred to as *unary* ufuncs.
    To use them, call the function and pass it an `ndarray`, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Some of the more useful unary ufuncs are listed in [Table 18-4](ch18.xhtml#ch018tab4).
    You can find a complete list at *[https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/](https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/)*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-4:** Useful NumPy Unary Universal Functions'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Compute absolute value of each element |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: '| `fabs` | Compute absolute value of each element and return float |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
- en: '| `all` | Test whether all array elements along an axis evaluate to True |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| `any` | Test whether any array element along an axis evaluates to True |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: '| `ceil` | Compute smallest integer greater than or equal to each element |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
- en: '| `floor` | Compute largest integer less than or equal to each element |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
- en: '| `clip` | Limit values in array to a specified min, max range |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
- en: '| `round` | Round values in array to a specified number of decimals |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Compute the exponent (ex) of each element |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
- en: '| `log, log10, log2` | Compute the natural, base 10, or base 2 log per element
    |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
- en: '| `rint` | Round elements to the nearest integer preserving the dtype |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
- en: '| `sign` | Compute sign of each element (positive=1, zero=0, negative=-1) |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Compute square root of each element |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
- en: '| `square` | Compute the square of each element |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
- en: '| `modf` | Return the fractional and integral parts of array as a new array
    |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
- en: '| `isnan` | Return Boolean array indicating NaN (Not a Number) values |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
- en: '| `degrees` | Convert elements representing radians to degrees |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
- en: '| `radians` | Convert elements representing degrees to radians |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
- en: '| `cos, sin, tan` | Compute cosine, sine, or tangent for each element |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: '| `cosh, sinh, tanh` | Compute hyperbolic cosine, sine, or tangent for each
    element |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
- en: '| `arccos, arcsin, arctan` | Compute inverse trigonometric functions per element
    |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
- en: '| `arccosh, arcsinh, arctanh` | Compute inverse hyperbolic trigonometric functions
    per element |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
- en: '| `sort` | `arr.sort()` sorts in-place; `np.sort()` returns a sorted copy |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: 'Universal functions that accept two arrays as input and return a single array
    are called *binary* ufuncs. The following binary functions find the maximum and
    minimum values in two arrays and return them in new arrays:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Some other binary functions are listed in [Table 18-5](ch18.xhtml#ch018tab5).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-5:** Useful NumPy Binary Universal Functions'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| `add` | Add arrays element by element |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | Subtract second argument array from first argument array by
    element |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | Multiply arrays element by element |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '| `divide` | Divide arrays element by element |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
- en: '| `floor_divide` | Divide arrays and truncate the remainder |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
- en: '| `power` | Raise elements in first array to powers in second array |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
- en: '| `maximum, fmax` | Return the maximum value by element, ignoring NaN values
    for `fmax` |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
- en: '| `minimum, fmin` | Return the minimum value by element, ignoring NaN values
    for `fmax` |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
- en: '| `mod` | Return the modulus by element |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
- en: '| `copysign` | Copy sign of values in second array to values in first array
    |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
- en: '| `greater` | Return Boolean array for elementwise *greater than* comparison
    |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
- en: '| `greater_equal` | Return Boolean array for elementwise *greater than or equal
    to* comparison |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
- en: '| `less` | Return Boolean array for elementwise *less than* comparison |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
- en: '| `less_equal` | Return Boolean array for elementwise *less than or equal to*
    comparison |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
- en: '| `equal` | Return Boolean array for elementwise *equality* comparison |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
- en: '| `not_equal` | Return Boolean array for elementwise negative equality comparison
    |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
- en: 'For more on universal functions visit: *[https://numpy.org/doc/stable/user/basics.ufuncs.html](https://numpy.org/doc/stable/user/basics.ufuncs.html)*.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '**Statistical Methods**'
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: NumPy also comes with methods that compute statistics for an entire array or
    for data along an axis. Reducing the elements in an array to a single value can
    be referred to as *aggregation* or *reduction*.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out some of these using a 2D array of randomly generated integers:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To calculate the mean value for all the elements in this array, call `mean()`
    on the array using dot notation:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can also pass the array to the `mean()` function, like so:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The optional `axis` argument lets you specify the axis over which to compute
    the statistics. For example, specifying axis 1 means that the calculation is performed
    *across the columns*, producing a 1D array with the same number of elements as
    rows in the array:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Specifying axis 0 tells the function to compute the *down the rows*. In the
    following example, this yields a 1D array of five elements, equal to the number
    of columns:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'These functions can also be called without the `axis` keyword:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[Table 18-6](ch18.xhtml#ch018tab6) lists some useful statistical methods for
    arrays. You can use the whole array or specify an axis.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-6:** Useful NumPy Statistical Methods'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
- en: '| `argmin` | Index of the element with the minimum value |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
- en: '| `argmax` | Index of the element with the maximum value |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
- en: '| `count_nonzero` | Counts the number of non-zero values in an array |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product of elements starting with index 1 |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum of elements starting with index 0 |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Arithmetic mean of elements |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
- en: '| `min` | Minimum value of elements |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
- en: '| `max` | Maximum value of elements |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
- en: '| `std` | Standard deviation of elements |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of the elements |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
- en: '| `var` | Variance of the elements |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
- en: 'Note that NumPy also comes with the `apply_along_axis()` aggregate function
    that lets you supply the statistical function, axis, and array as arguments. Here’s
    an example using the previous array:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You can also define your own functions and pass them to `apply_along_axis()`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Notice how, in these examples, you were able to work with the array without
    explicitly iterating over every element. Again, this is one of the great strengths
    of NumPy.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating Pseudorandom Numbers**'
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: NumPy comes with functions for creating arrays from different types of probability
    distributions. These are useful for tasks such as generating randomized data to
    test machine learning models, creating data distributions with a known shape or
    distribution, randomly drawing data for a Monte Carlo simulation, and so on. They’re
    also at least an order of magnitude faster than similar functions in Python’s
    built-in `random` module.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Table18-7 lists some of the functions you can find in `np.random`. For the full
    list, visit *[https://numpy.org/doc/stable/reference/random/index.html](https://numpy.org/doc/stable/reference/random/index.html)*.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-7:** Useful NumPy Pseudorandom Functions'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
- en: '| `beta` | Draw samples from a Beta distribution |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
- en: '| `binomial` | Draw samples from a binomial distribution |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
- en: '| `chisquare` | Draw samples from a chi-square distribution |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
- en: '| `gamma` | Draw samples from a Gamma distribution |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
- en: '| `normal` | Draw random samples from a normal (Gaussian) distribution |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
- en: '| `permutation` | Return a permuted range or random permutation of a sequence
    |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
- en: '| `power` | Draw from a power function distribution |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
- en: '| `rand` | Create an array of a given shape populated with random samples from
    a uniform distribution over (0, 1) |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
- en: '| `randint` | Return random integers from low (inclusive) to high (exclusive)
    |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
- en: '| `randn` | Return a sample (or samples) from the “standard normal” distribution
    |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
- en: '| `random` | Return random floats in the half-open interval (0.0, 1.0) |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
- en: '| `seed` | Change the seed for the random number generator |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
- en: '| `shuffle` | Randomly permute a sequence in-place |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
- en: '| `uniform` | Draw samples from uniform distribution over half-open interval
    (low, high) |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
- en: '**Reading and Writing Array Data**'
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy can load and save data from and to disk in both binary and text format.
    Supported text formats are **.txt* and **.csv*. Generally, you will want to use
    the pandas library, built on NumPy, to work with text or tabular data. We look
    at pandas in [Chapter 20](ch20.xhtml).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'For storing and retrieving data in binary format, NumPy provides the `save()`
    and `load()` functions. To save an array to disk, just pass a filename and the
    array as arguments, as shown here:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This will produce the binary file *my_array.npy* (the *.npy* extension is added
    automatically).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'To reload this file, enter the following:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `np.savez()` function lets you save several arrays into a single file in
    uncompressed *.npz* format. Providing keyword arguments lets you store them under
    the corresponding name in the output file:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If arrays are specified as *positional* arguments (no keywords), their names
    will be *arr_0*, *arr_1*, and so on, by default.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'To compress data when archiving, use the `savez_compressed()` function:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In the event you do want to read-in a text file, NumPy provides the `genfromtxt()`
    (generate from text) function. To load a *.csv* file, for example, you would pass
    the function the file path, the character (comma) that separates the values, and
    whether the data columns have headers, as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This will produce a *structured* array that contains records rather than individual
    items. We haven’t discussed structured arrays, because they are a low-level tool
    and we’ll be using pandas for operations such as loading *.csv* files. However,
    you can read more about structured arrays at *[https://numpy.org/doc/stable/user/basics.rec.html](https://numpy.org/doc/stable/user/basics.rec.html)*.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '11.  Why is there so much whitespace in the first two elements in this output
    array: ([ 0, 2, -10000])?'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 12.  Which function would you use to flatten a higher-dimension array to a 1D
    array?
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: a.  `meshgrid()`
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: b.  `vsplit()`
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: c.  `ravel()`
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: d.  `thresh()`
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 13.  For the array [[0, 1, 2], [3, 4, 5], [6, 7, 8]], what does the slice arr2d[:2,
    2] produce?
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: a.  `array([1])`
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: b.  `array([2, 5])`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: c.  `array([6, 7])`
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: d.  `array([3, 4, 5])`
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '14.  In NumPy, array multiplication is done:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: a.  Row by column
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: b.  Column by row
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: c.  Element by element
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: d.  Row by row then column by column
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 15.  Which array is broadcastable with an array of shape (4, 3, 6, 1)?
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: a.  (4, 6, 6, 1)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: b.  (1, 6, 3, 1)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: c.  (4, 1, 6, 6)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: d.  (6, 3, 1, 6)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with uniform datasets, NumPy’s `ndarray`s represent a faster, more
    efficient alternative to competing data structures such as Python lists. Complex
    computations can be performed without the use of `for` loops, and `ndarray`s require
    significantly less memory than other Python data types.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter touched on a lot of NumPy basics, but there’s still more to learn.
    To expand your knowledge of NumPy, I recommend NumPy’s “Beyond the Basics” page
    (*[https://numpy.org/doc/stable/user/c-info.beyond-basics.html](https://numpy.org/doc/stable/user/c-info.beyond-basics.html)*)
    and Wes McKinney’s *Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*, 2nd edition (O’Reilly, 2018).'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Before you run off and start applying NumPy, you’ll want to check out the next
    two chapters on Matplotlib and pandas. These libraries are built on top of NumPy
    and provide higher-level wrappers for performing data analysis and plotting.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
