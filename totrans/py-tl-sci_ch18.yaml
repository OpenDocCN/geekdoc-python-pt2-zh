- en: '**18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NUMPY: NUMERICAL PYTHON**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Short for *Numerical Python*, *NumPy* serves as Python’s foundational library
    for numerical computing. It extends Python’s mathematical capability and forms
    the basis of many scientific and mathematical packages. As a result, you’ll need
    to understand NumPy in order to effectively use Python’s scientific libraries
    such as Matplotlib (for plotting) and pandas (for data analysis).
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is open source and comes preinstalled with Anaconda. It augments the built-in
    tools in the Python Standard Library, which can be too simple for many data analysis
    calculations. Using NumPy, you can perform fast operations, including mathematical,
    logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms,
    basic linear algebra, basic statistical operations, random simulation, and more.
  prefs: []
  type: TYPE_NORMAL
- en: At the core of NumPy is the *array* data structure, which is basically a grid
    of values. By using precompiled C code, multidimensional arrays, and functions
    that operate on arrays, NumPy speeds up the running of slower algorithms and performs
    high-level mathematical calculations in a highly efficient manner. NumPy also
    makes it easier to work with large, uniform datasets with millions to billions
    of samples.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t understand NumPy if you don’t understand arrays, so in this chapter,
    we’ll focus on these features first and then look at some of the library’s basic
    functionality. For further study, visit the official site (*[https://numpy.org/](https://numpy.org/)*),
    which contains both “quickstart” and more detailed tutorials and guides.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introducing the Array**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computer science, an array is a data structure that contains a group of elements
    (values or variables) of the same size and data type (referred to as *dytpes*
    in NumPy). An array can be indexed by a tuple of nonnegative integers, by Booleans,
    by another array, or by integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a two-dimensional array of integers, comprising a grid
    of two rows and three columns. Because arrays use square brackets, they look a
    lot like Python lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To select an element from this array, you can use standard indexing and slicing
    techniques. For example, to select the element `2`, you would index first the
    row and then the column, using `[0][2]`(remember: Python starts counting at 0,
    not 1).'
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons why you might want to work with arrays. Accessing
    individual elements by index is extremely efficient, making runtimes constant
    regardless of the array size. In fact, arrays let you perform complex computations
    on entire blocks of data without the need to loop through and access each element
    one at a time. As a result, NumPy-based algorithms run orders of magnitude faster
    than those in native Python.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being faster, arrays store data in contiguous memory blocks,
    resulting in a significantly smaller memory footprint than built-in Python sequences,
    like lists. A list, for example, is basically an array of pointers to (potentially)
    heterogeneous Python objects stored in non-contiguous blocks, making it much less
    compact than a NumPy array. Consequently, arrays are often the preferred data
    structure for storing data reliably and efficiently. The popular OpenCV computer
    vision library, for example, manipulates and stores digital images as NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '***Describing Arrays Using Dimension and Shape***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understanding arrays requires knowledge of their layout. The number of *dimensions*
    in an array is the number of indexes needed to select an element from the array.
    You can think of a dimension as an array’s *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: The number of dimensions in an array, also called its *rank*, can be used to
    describe the array. [Figure 18-1](ch18.xhtml#ch018fig1) is a graphical example
    of one-, two-, and three-dimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: Graphical representations of arrays in one, two, and three dimensions*'
  prefs: []
  type: TYPE_NORMAL
- en: The *shape* of an array is a tuple of integers representing the size of the
    array along each dimension, starting with the first dimension (axis 0). Example
    shape tuples are shown below each array in [Figure 18-1](ch18.xhtml#ch018fig1).
    The number of integers in these tuples equals the array’s rank.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-dimensional array, also referred to as a *vector*, has a single axis.
    This is the simplest form of array and is the NumPy equivalent to Python’s `list`
    data type. Here’s an example of how the 1D array in [Figure 18-1](ch18.xhtml#ch018fig1)
    looks in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Arrays with more than one dimension are basically arrays within arrays. An array
    with both rows and columns is called a 2D array. The 2D array in [Figure 18-1](ch18.xhtml#ch018fig1)
    has a shape tuple of (2, 3) because the length of its first axis (0) is 2 and
    the length of its second axis (1) is 3.
  prefs: []
  type: TYPE_NORMAL
- en: A 2D array is used to represent a *matrix*. You might remember from math class
    that these are rectangular grids of elements such as numbers or algebraic expressions,
    arranged in rows and columns and enclosed by square brackets. Matrices store data
    in an elegant and compact manner, and despite containing many elements, each matrix
    is treated as one unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the 2D array in [Figure 18-1](ch18.xhtml#ch018fig1) rendered
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An array with three or more dimensions is called a *tensor*. As mentioned earlier,
    arrays can have any number of dimensions. Here’s an example of the 3D array in
    [Figure 18-1](ch18.xhtml#ch018fig1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tensors can be difficult to visualize in a two-dimensional display, but Python
    tries to help you out. Note how a blank line separates the two stacked matrices
    that comprise the 3D grid. You can also determine the rank of an array by counting
    the number of square brackets at the start of the output. Three square brackets
    in a row means that you’re dealing with a 3D array.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy handles arrays through its `ndarray` class, also known by the alias `array`.
    The `ndarray` name is short for *N-dimensional*, as this class can handle any
    number of dimensions. NumPy `ndarray`s have a fixed size at creation and can’t
    grow like a Python list or tuple. Changing the size of an `ndarray` creates a
    new array and deletes the original.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should know numpy.array is not the same as array.array, found in the Python
    Standard Library. The latter is only a one-dimensional array and has limited functionality
    compared to NumPy arrays.*'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy comes with several built-in functions for creating `ndarray`s. These let
    you create arrays outright or convert existing sequence data types, like tuples
    and lists, to arrays. [Table 18-1](ch18.xhtml#ch018tab1) lists some of the more
    common creation functions. We’ll look at some of these in more detail in the sections
    that follow. You can find a complete listing of creation functions at *[https://numpy.org/doc/stable/reference/routines.array-creation.html](https://numpy.org/doc/stable/reference/routines.array-creation.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Array Creation Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `array` | Convert (copy) input sequence to an `ndarray` by inferring or specifying
    a `dtype` |'
  prefs: []
  type: TYPE_TB
- en: '| `asarray` | Like `array` but with fewer options and does not create a copy
    by default |'
  prefs: []
  type: TYPE_TB
- en: '| `arange` | Like built-in `range()` function but returns an `ndarray` instead
    of a list |'
  prefs: []
  type: TYPE_TB
- en: '| `linspace` | Return evenly spaced numbers over a specified interval |'
  prefs: []
  type: TYPE_TB
- en: '| `ones` | Produce an `ndarray` of all 1s with a given shape and `dtype` |'
  prefs: []
  type: TYPE_TB
- en: '| `ones_like` | Produce a ones `ndarray` of the same shape and `dtype` as an
    input array |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros` | Produce an `ndarray` of all 0s with a given shape and `dtype` |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros_like` | Produce a `zeros ndarray` of the same shape and `dtype` as
    an input array |'
  prefs: []
  type: TYPE_TB
- en: '| `empty` | Allocate new memory for a new unpopulated `ndarray` of a given
    shape |'
  prefs: []
  type: TYPE_TB
- en: '| `empty_like` | Allocate new memory for a new unpopulated `ndarray` based
    on an input array |'
  prefs: []
  type: TYPE_TB
- en: '| `full` | Produce an `ndarray` of a given shape and `dtype` with all values
    set to a fill value |'
  prefs: []
  type: TYPE_TB
- en: '| `full_like` | Take an input array and produce a filled array of the same
    shape and `dtype` |'
  prefs: []
  type: TYPE_TB
- en: '| `eye` | Return a square 2D array with ones on the diagonal and zeros elsewhere
    |'
  prefs: []
  type: TYPE_TB
- en: '| `identity` | Like `eye` but without the option to specify the index of the
    diagonal |'
  prefs: []
  type: TYPE_TB
- en: Because arrays must contain data of the same type, the array needs to know the
    `dtype` that’s being passed to it. You’ll have the choice of letting the functions
    infer the most suitable `dtype` (although you’ll want to check the result) or
    providing the `dtype` explicitly as an additional argument.
  prefs: []
  type: TYPE_NORMAL
- en: Some commonly used `dtype`s are listed in [Table 18-2](ch18.xhtml#ch018tab2).
    The Code column lists the shorthand arguments you can pass to the functions in
    single quotes, such as `dtype=` `'i8` `'`, in place of `dtype=` `'int64` `'`.
    For a full list of supported data types, visit *[https://numpy.org/doc/stable/user/basics.types.html](https://numpy.org/doc/stable/user/basics.types.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Common NumPy Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `?` | Boolean type (True and False). |'
  prefs: []
  type: TYPE_TB
- en: '| `object` | `O` | Any Python object type. |'
  prefs: []
  type: TYPE_TB
- en: '| `string_` | `S`n | Fixed-length ASCII string type with 1 byte per character.
    The n parameter represents the length of the longest string, such as `''S15''`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unicode_` | `U`n | Fixed-length Unicode type with number of bytes platform
    specific. The n parameter represents the longest length, such as `''U12''`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int8, uint8` | `i1, u1` | Signed and unsigned 8-bit (1 byte) integer types.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int16, uint16` | `i2, u2` | Signed and unsigned 16-bit integer types. |'
  prefs: []
  type: TYPE_TB
- en: '| `int32, uint32` | `i4, u4` | Signed and unsigned 32-bit integer types. |'
  prefs: []
  type: TYPE_TB
- en: '| `int64, uint64` | `i8, u8` | Signed and unsigned 64-bit integer types. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `f4` or `f` | Single-precision floating-point type. |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `f8` or `d` | Double-precision floating-point type compatible
    with Python float. |'
  prefs: []
  type: TYPE_TB
- en: '| `float128` | `f16` or `g` | Extended-precision floating-point type. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | `c8` | Complex number represented by two 32-bit floats. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | `c16` | Complex number represented by two 64-bit floats. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex256` | `c32` | Complex number represented by two 128-bit floats.
    |'
  prefs: []
  type: TYPE_TB
- en: For string and Unicode dtypes, the length of the longest string or Unicode object
    must be included in the `dtype` argument. For example, if the longest string in
    a dataset has 12 characters, the assigned `dtype` should be `'S12'`. This is necessary
    because all the `ndarray` elements should be of the same size. There’s no way
    to create variable-length strings, so you must ensure that enough memory is allocated
    to hold every possible string in the dataset. When using *existing input*, such
    as when converting a list of strings to an array, NumPy can make this calculation
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Because the amount of memory used by the `dtype`s is automatically assigned
    (or can be input), NumPy knows how much memory to allocate when creating `ndarray`s.
    The choices in [Table 18-2](ch18.xhtml#ch018tab2) give you plenty of control over
    how data is stored in memory, but don’t let that intimidate you. Most of the time,
    all you’ll need to know is the basic type of data you’re using, such as a float
    or integer.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW NUMPY ALLOCATES MEMORY**'
  prefs: []
  type: TYPE_NORMAL
- en: The genius of NumPy is in how it allocates memory. The following figure shows
    information stored in a 3x4 2D array of numbers from 0 to 11, represented by the
    “Python View” diagram at the bottom of the figure. You’re already familiar with
    parameters such as `dtype`, dimensions, and data, so let’s focus on memory allocation
    and strides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0496-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The values of an `ndarray` are stored as a contiguous block of memory in your
    computer’s RAM, as shown by the Memory Block diagram in the figure. This is efficient,
    as processors prefer items in memory to be in chunks rather than randomly scattered
    about. The latter occurs when you store data in Python data types like lists,
    which keep track of *pointers* to objects in memory, creating “overhead” that
    slows down processing.
  prefs: []
  type: TYPE_NORMAL
- en: To help NumPy interpret the bytes in memory, the `dtype` object stores additional
    information about the *layout* of the array, such as the size of the data (in
    bytes) and the byte order of the data. Because we’re using the `int32` `dtype`
    in the example, each number occupies 4 bytes of memory (32 bits/8 bits per byte).
  prefs: []
  type: TYPE_NORMAL
- en: '`Ndarray`s come with an attribute, `strides`, which is a tuple of the number
    of bytes to step in each dimension when traversing an array. This tuple informs
    NumPy on how to convert from the contiguous Memory Block to the Python View array
    shown in the figure.'
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, the memory block consists of 48 bytes (12 integers x 4 bytes
    each), stored one after the other. The array strides indicate how many bytes must
    be skipped in memory to move to the next position along a certain axis. For example,
    we must skip 4 bytes (1 integer) to reach the next column, but 16 bytes (4 integers)
    to move to the same position in the next row. Thus, the strides for the array
    are (16, 4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the array() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The simplest way to create an array is to pass the NumPy `array()` function
    a sequence, such as a list, which is then converted into an `ndarray`. Let’s do
    that now to create a 1D array. We’ll begin by importing NumPy using the alias
    `np` (this is by convention and will reduce the amount of typing needed to call
    NumPy functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an `ndarray` by passing the `array()` function a variable,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a multidimensional array, pass `array()` a nested sequence, where
    each nested sequence is the same length. Here’s an example that uses a list containing
    three nested lists to create a 2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each nested list became a new row in the 2D array. To build the same array from
    tuples, you would replace all the square brackets `[]` in line `In [8]` with parentheses
    `()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you print an array, NumPy displays it with the following layout: the
    last axis is printed from left to right, the second-to-last is printed from top
    to bottom, the rest are also printed from top to bottom, with each slice separated
    from the next by an empty line. So, 1D arrays are printed as rows, 2D arrays as
    matrices, and 3D arrays as lists of matrices.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check some of the 2D array’s attributes, such as its shape
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: its number of dimensions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'and its strides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the items in an array must be the same data type, this doesn’t mean
    that you can’t pass these items to the `array()` function within a mixture of
    sequence types, such as tuples and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This worked because NumPy reads the data type of the elements in a sequence
    rather than the data type of the sequence itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You won’t have the same luck, however, if you try to pass nested lists of different
    lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can avoid this warning by changing the `dtype` to `object`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that you now have a 1D array of list objects rather than the 2D array of
    integers you wanted. Just as with mathematical matrices, arrays need to have the
    *same number of rows and columns* if you plan to use them for mathematical calculations
    (there’s some flexibility to this, but we’ll save it for the section on “broadcasting”).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at arrays with more than two dimensions. The `array()` function
    transforms sequences of sequences into two-dimensional arrays; sequences of sequences
    of sequences into three-dimensional arrays; and so on. So, to make a 3D array,
    you need to pass the function multiple nested sequences. Here’s an example using
    nested lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we passed a list containing two nested lists that each contained
    two nested lists. Notice how the output array has a blank line in the middle.
    This visually separates the two stacked 2D arrays created by the function.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of all those brackets when creating high-dimension arrays can
    be cumbersome and dangerous to your eyesight. Fortunately, NumPy provides additional
    methods for creating arrays that can be more convenient than the `array()` function.
    We’ll look at some of these in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the arange() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To create arrays that hold sequences of numbers, NumPy provides the `arange()`
    function, which works like Python’s built-in `range()` function, only it returns
    an array rather than an immutable sequence of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `arange()` function takes similar arguments to `range()`. Here, we make
    a 1D array of the integers from 0 to 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a start, stop, and step argument to create an array of the
    even numbers between 0 and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start the sequence at 5 and stop at 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas `range()` always produces a sequence of integers, `arange()` lets you
    specify the data type of the numbers in the array. Here, we use double-precision
    floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, `arange()` accepts a float for the step parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When arange() is used with floating-point arguments, it’s usually not possible
    to predict the number of elements obtained, due to the finite floating-point precision.
    For this reason, it’s better to use the NumPy linspace() function, which receives
    as an argument the number of elements desired instead of the step argument. We’ll
    look at linspace() shortly.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `arange()` and `reshape()` functions, you can create a multidimensional
    array—and generate a lot of data—with a single line of code. The `arange()` function
    creates a 1D array, and `reshape()` divides this linear array into different parts
    as specified by a shape argument. Here’s an example using the 3D shape tuple (2,
    2, 4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because arrays need to be symmetrical, the product of the shape tuple must
    equal the size of the array. In this case, `(8, 2, 1)` and `(4, 2, 2)` will work,
    but `(2, 3, 4)` will raise an error because the resulting array has 24 elements,
    whereas you specified 16 (`np.arange(16)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Using the linspace() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The NumPy `linspace()` function creates an `ndarray` of evenly spaced numbers
    within a defined interval. It’s basically the `arange()` function with a `num`
    (number of samples) argument rather than a `step` argument. The `num` argument
    determines how many elements will be in the array, and the function calculates
    the intervening numbers so that the intervals between them are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want an array of size 6 with values between 0 and 20\. All
    you need to do is pass the function a start, stop, and `num` value, as follows,
    using keyword arguments for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This produced a 1D array of six floating-point values, with all the values evenly
    spaced. Note that the stop value (`20`) is included in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can force the function to not include the endpoint by setting the Boolean
    parameter `endpoint` to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to retrieve the size of the intervals between values, set the Boolean
    parameter `retstep` to `True`. This returns the step value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `linspace()` function returns a `dtype` of `float64`. You can
    override this by passing it a `dtype` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need to be careful when changing the data type, however, as the result
    may no longer be a linear space due to rounding.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `arange()`, you can reshape the array on the fly. Here, we produce
    a 2D array with the same `linspace()` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s possible to create sequences with uneven spacing. The np.logspace() function,
    for example, creates a logarithmic space with numbers evenly spaced on a log scale.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `linspace()` function lets you control the number of elements in an array,
    something that can be challenging to do when using `arange()`. Arrays of evenly
    spaced numbers are useful when working with mathematical functions of continuous
    variables. Likewise, linear spaces come in handy when you need to evenly sample
    an object, such as a waveform. To see some useful examples of `linspace()` in
    action, visit *[https://realpython.com/np-linspace-numpy/](https://realpython.com/np-linspace-numpy/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Along these lines, the `meshgrid()` function creates a rectangular grid out
    of two given 1D arrays. The resulting indexing matrix holds in each cell the x
    and y coordinates for each point in the 2D space. Whereas `meshgrid()` is useful
    when plotting and interpolating 2D arrays, the `mgrid()` function calls `meshgrid()`
    to produce a dense “meshgrid” with multiple dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Prefilled Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For convenience, NumPy lets you create `ndarray`s using prefilled ones, zeros,
    random values, or values of your own choosing. You can even create an empty array
    with no predefined values. These arrays are commonly used when you need a structure
    for holding computation results, for training machine learning applications, for
    creating image masks, for performing linear algebra, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a zero-filled array, simply pass the `zero()` function a shape tuple,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an array filled with ones, repeat the process with the `ones()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.eye()` function creates an array where all items are equal to zero,
    except for the *k*th diagonal, whose values are equal to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By default, these functions return `float64` values, but you can override this
    using a `dtype` argument, such as `dtype=int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill an array with a custom value and data type, use the `full()` function
    with following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `empty()` function returns a new `ndarray` of a given shape and filled
    with uninitialized (arbitrary) data of the given data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: According to the documentation, `empty()` does not set the array values to zero
    and may therefore be marginally faster than the `zeros()` function. On the other
    hand, it requires the user to manually set all the values in the array, thus you
    should use it with caution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can generate arrays of pseudo-random numbers using NumPy. For
    floating-point values between 0 and 1, just pass `random()` a shape tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you can generate random integers, sample values from a “standard
    normal” distribution, shuffle an existing array’s contents in place, and more.
    We’ll look at some of these options later in the chapter, and you can find the
    official documentation at *[https://numpy.org/doc/stable/reference/random/generator.html](https://numpy.org/doc/stable/reference/random/generator.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Array Attributes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As objects, `ndarray`s have attributes accessible through dot notation. We’ve
    looked at some of these already, and you can find more listed in [Table 18-3](ch18.xhtml#ch018tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Important `ndarray` Attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ndim` | The number of axes (dimensions) of the array |'
  prefs: []
  type: TYPE_TB
- en: '| `shape` | A tuple of integers indicating the size of the array in each dimension
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | The total number of elements in the array |'
  prefs: []
  type: TYPE_TB
- en: '| `itemsize` | The size in bytes of each element in the array |'
  prefs: []
  type: TYPE_TB
- en: '| `dtype` | An object describing the data type of the elements in the array
    |'
  prefs: []
  type: TYPE_TB
- en: '| `strides` | A tuple of bytes to step in each dimension when traversing an
    array |'
  prefs: []
  type: TYPE_TB
- en: 'For example, to get the shape of the `arr1d` object, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As a 1D array, there’s only one axis and thus only one index. Note the comma
    after the index, which tells Python that this is a tuple data type and not just
    an integer in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the array is the total number of elements it contains. This is
    the same as the product of the elements returned by `shape`. To get the array’s
    size, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the array’s `dtype`, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, even if you have a 64-bit machine, the default `dtype` for numbers
    *may be* 32-bit, such as `int32` or `float32`. To ensure that you’re using 64-bit
    numbers, you can specify the `dtype` when creating the array, as follows (for
    `int64`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the array’s strides, access the `strides` attribute with dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When using strings in arrays, the `dtype` needs to include the length of the
    longest string. NumPy can generally figure this out on its own, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note how the unicode (`U`) `dtype` includes the number 8, which is the length
    of `soybeans`, the longest string item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the data type and number of bits each item occupies, call the `name`
    attribute on `dtype`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, each item in the array is a `string` occupying 256 bits (8 characters
    x 32 bits). This is different from the `itemsize` attribute, which just displays
    the size of an individual character *in bytes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  What is *not* a characteristic of an array?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Enables fast computations with small memory footprint
  prefs: []
  type: TYPE_NORMAL
- en: b.  Composed entirely of elements of a single data type
  prefs: []
  type: TYPE_NORMAL
- en: c.  Can accommodate up to four dimensions
  prefs: []
  type: TYPE_NORMAL
- en: d.  Provides an efficient alternative to looping
  prefs: []
  type: TYPE_NORMAL
- en: '2.  A two-dimensional array is also known as a:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Linear array
  prefs: []
  type: TYPE_NORMAL
- en: b.  Tensor
  prefs: []
  type: TYPE_NORMAL
- en: c.  Rank
  prefs: []
  type: TYPE_NORMAL
- en: d.  Matrix
  prefs: []
  type: TYPE_NORMAL
- en: '3.  A strides tuple tells NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  The number of different data types in the array
  prefs: []
  type: TYPE_NORMAL
- en: b.  The number of bytes to step in each dimension when traversing an array
  prefs: []
  type: TYPE_NORMAL
- en: c.  The step size when sampling an array
  prefs: []
  type: TYPE_NORMAL
- en: d.  The size of the array in bytes
  prefs: []
  type: TYPE_NORMAL
- en: 4.  You’ve been given a dataset of various-sized digital images and asked to
    take 100 evenly spaced samples of pixel intensity from each. Which NumPy function
    do you use to choose the sample locations?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `arange()`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `empty()`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `empty_like()`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `full()`
  prefs: []
  type: TYPE_NORMAL
- en: e.  `linspace()`
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Write an expression to generate a square matrix of 100 zeros.
  prefs: []
  type: TYPE_NORMAL
- en: '***Indexing and Slicing Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The elements within an `ndarray` can be accessed using indexes and slices. This
    lets you extract the value of elements as well as change the values using assignment
    statements. Array indexing uses square brackets `[]`, just like Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Slicing 1D Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One-dimensional arrays are zero-indexed, so the first index is always `0`. For
    indexing and slicing in reverse, the first value is `-1`. [Figure 18-2](ch18.xhtml#ch018fig2)
    describes the indexes of five elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: The indexes of a 1D ndarray*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with list indexing, you won’t have any problems indexing
    1D arrays. Let’s look at some examples in which we select elements using both
    positive and negative indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To access every other element in the array, include a step value of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To access multiple elements at once, use an array of comma-separated indexes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve selected these elements, you can assign them a new value and change
    the values in the underlying array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign new values to a group of array elements with array slices.
    In this next example, we use slicing to change the first three elements to a value
    of 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the value of 100 was propagated across the entire slice.
    This process is known as *broadcasting*. Because array slices are views of the
    source array rather than copies, any changes to the view will modify the original
    array. This is advantageous when working with very large arrays, as it keeps NumPy
    from making memory-intensive copies on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this assignment behavior persists even when array slices are assigned
    to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because the slice itself is an array, it has its own set of indexes that are
    different from those of the source array. Thus, `a_slice[:]` corresponds to `arr2d[3:]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an actual copy rather than a view, call the `copy()` method, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `a_slice` array is separate from `arr1d`, and changing its elements
    does not affect the source array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can first call the `array` function on the slice and then
    mutate the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Changing the `a_slice` array had no effect on `arr1d`, because the arrays represent
    separate objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Slicing 2D Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two-dimensional arrays are indexed with a pair of values. These value pairs
    resemble Cartesian coordinates, except that the row index (the axis-0 value) comes
    before the column index (the axis-1 value), as shown in [Figure 18-3](ch18.xhtml#ch018fig3).
    Square brackets are used again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Indexes of a 2D ndarray*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the 2D array in [Figure 18-3](ch18.xhtml#ch018fig3) to study this
    further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In a 2D array, each value in the index pair references a 1D array (a whole
    row or column) rather than a single element. For example, specifying an integer
    index of `1` outputs the 1D array that comprises the second row of the 2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing a 2D array also works along 1D arrays. Here we slice over rows, taking
    the last two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This produced a 2D array of shape (2, 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a whole column in the 2D array, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The colon (`:`) tells NumPy to take all the rows; the `1` then selects only
    column 1, leaving you with only a 1D array from the center column of `arr2d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also extract a column with the following syntax, though in this case,
    rather than outputting a 1D array containing the column’s values, you generate
    a 2D array of shape (3, 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As a rule of thumb, if you slice a 2D array using a mixture of integer indexes
    and slices, you’ll get a 1D array. If you slice along both axes, you’ll get another
    2D array. For a reference, see [Figure 18-4](ch18.xhtml#ch018fig4), which shows
    the results of using various expressions to sample a 2D array.
  prefs: []
  type: TYPE_NORMAL
- en: As with 1D arrays, 2D slices are views of the array that you can use to modify
    the values in the source array. In this example, we select the middle column in
    the array in [Figure 18-3](ch18.xhtml#ch018fig3) and change all of its elements
    to `42`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/18fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Example slices through a 2D ndarray*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To select individual elements from 2D arrays, specify a pair of integers as
    the element’s indexes. For example, to obtain the element from the intersection
    of the second row and second column, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this syntax is a less cumbersome version of the more traditional
    nested list syntax in which each index is surrounded by brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Indexing and Slicing Higher-Dimensional Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The key to indexing and slicing arrays with more than two dimensions is to think
    of them as a *series of stacked arrays of a lower dimension*. We’ll refer to these
    stacked arrays as *plans*. As with 2D arrays, the order in which you index 3D
    arrays is determined by their shape tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at a 3D array with a shape of (2, 3, 4). You can think
    of the first value in the shape tuple as the number of 2D arrays within that 3D
    array. The next two numbers are treated as the shape tuple for these 2D arrays,
    representing its rows and columns, respectively. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When you look at the output, you should see two separate 2D arrays of shape
    `(3, 4)` stacked one atop the other. These are demarcated by a space in the output
    as well as by a new set of square brackets around the second 2D array.
  prefs: []
  type: TYPE_NORMAL
- en: Because the array contains two matrices, the 3D component to the shape tuple
    is `2`. This number comes first, so you can think of the shape tuple as recording
    the number of plans, rows, and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let’s use indexes to retrieve the value `20` in the
    array. We can use the array’s shape tuple (plans, rows, columns) to guide us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: First, we had to choose the second 2D array, which has an index of `1` because
    Python starts counting at 0\. Next, we selected the third row using `2`. Finally,
    we selected the first column using `0`. The key is to work your way through the
    shape tuple in order. The dimension of the array will let you know how many indexes
    you’ll need (three for a 3D array, four for a 4D array, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing also follows the order of the shape tuple. For example, to get a view
    of the `arr3d` array’s lower 2D array, you would enter `1` for the plan and then
    use the colon shorthand notation to select all of its rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For reference, [Figure 18-5](ch18.xhtml#ch018fig5) shows some example slices
    through a 3D array, along with the resulting shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Some example slices through a 3D ndarray*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, changing the values of elements in a slice will change the source
    array, unless the slice is a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on, let’s practice indexing and slicing an array with more than
    three dimensions. For example, look at the following 4D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the array starts with four square brackets and uses two blank lines
    to separate the two stacked 3D arrays. Because we’re dealing with a 4D array,
    to select the `20` element, you will need to enter four indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, from left to right, you indexed a 4D array to a 3D array; a 3D array to
    a 2D array; a 2D array to a 1D array; and a 1D array to a single element. This
    might be more obvious in [Figure 18-6](ch18.xhtml#ch018fig6), which demonstrates
    stepping through these in order.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-6: Indexing a 4D array down to a single element at [1, 1, 0, 2]*'
  prefs: []
  type: TYPE_NORMAL
- en: This style of ordering will hold true for any number of dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for 4D arrays, where the fourth dimension represents time, it can be
    useful to think of the arrays arranged horizontally, rather than vertically ([Figure
    18-7](ch18.xhtml#ch018fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-7: Each 4D slice can represent the same 3D array sampled at a different
    time.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, each single 4D slice would represent the same dataset (the 3D
    array) measured at a different point in time. So, to look at the first set of
    measurements, you would enter `arr4d[0, :, :]`, and for the last set of measurements,
    you could enter `arr4d[-1, :, :]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Indexing**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to using numerical indexing and slicing, you can select elements
    in arrays using conditions and Boolean operators. This lets you extract elements
    without any prior knowledge of where they are in the array. For example, you might
    have hundreds of monitor wells around a landfill, and you want to find all the
    wells that detect the pollutant toluene above a certain threshold value. With
    Boolean indexing, not only can you identify these wells, but you can also create
    a new array based on the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the following condition searches an array for any elements that
    are integers greater than or equal to four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Python will return an array of Boolean values containing `True`
    values where the condition is satisfied. Note that this syntax works for `ndarray`s
    of any dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy can also use the Booleans behind the scenes, allowing you to slice an
    array based on a conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing two arrays also produces a Boolean array. In this example we flag
    as `True` all the values in `arr_2` that are greater than those in `arr_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use of Boolean indexing is to partition a grayscale image into foreground
    and background segments, a process called *thresholding*. This produces a binary
    image based on a cutoff value. Here’s an example in which we create a 2D image
    array and then threshold on values above 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `True` evaluates to `1`, and `False` evaluates to `0`. This lets
    us convert a Boolean array to a numerical array by tacking on the `astype()` function
    and passing it the integer data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After thresholding, the `0` values in the new array should form the number
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign values based on a Boolean array, you index the source array based
    on a conditional and then assign a value. Here, we assign `0` to all the elements
    in the array with a value less than `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, you can change entire rows, columns, and plans in a Boolean array
    using indexing. For example, `img[0] = 0` changes all the elements in the first
    row of the `img` array to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of Booleans in arrays involves a few quirks. Extracting elements from
    an array using Boolean indexing creates a copy of the data by default, meaning
    that there is no need to use the `copy()` function. Another idiosyncrasy of Boolean
    arrays is that you must replace the `and` and `or` keywords with the `&` and `|`characters,
    respectively, when writing comparison statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '6.  Create a 2D `ndarray` of size 30 and shape (5, 6). Then, slice the array
    to sample the values highlighted in gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0517.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '7.  Resample the array from Question 6 to retrieve the elements highlighted
    in gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0517-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '8.  Slicing an `ndarray` produces:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  A new array object
  prefs: []
  type: TYPE_NORMAL
- en: b.  A copy of the source array
  prefs: []
  type: TYPE_NORMAL
- en: c.  A view of the source array
  prefs: []
  type: TYPE_NORMAL
- en: d.  A Python `list` object
  prefs: []
  type: TYPE_NORMAL
- en: '9.  Slicing a 2D array with a combination of a scalar index and another slice
    produces:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  A 2D array
  prefs: []
  type: TYPE_NORMAL
- en: b.  A 1D array
  prefs: []
  type: TYPE_NORMAL
- en: d.  A single element (0D array)
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 10.  What is the rank of this array?
  prefs: []
  type: TYPE_NORMAL
- en: array([[[[ 0,  1,  2,  3],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5,  6,  7]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 8,  9, 10, 11],'
  prefs: []
  type: TYPE_NORMAL
- en: '[12, 13, 14, 15]]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[[16, 17, 18, 19],'
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21, 22, 23]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[24, 25, 26, 27],'
  prefs: []
  type: TYPE_NORMAL
- en: '[28, 29, 30, 31]]]])'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manipulating Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy provides tools for working with existing arrays. Common manipulations
    include reshaping arrays, swapping their axes, and merging and splitting arrays.
    These come in handy for jobs like rotating, enlarging, and translating images
    and for fitting machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shaping and Transposing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy comes with functions to change the shape of arrays and to transpose arrays
    (invert columns with rows) and swap axes. You’ve already been working with one
    of these, the `reshape()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to be aware of with `reshape()` is that, like all NumPy assignments,
    it creates a *view* of an array rather than a *copy*. In the following example,
    reshaping the `arr1d` array produces only a temporary change to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is useful when you want to temporarily change the shape of the
    array for use in a computation, without copying any data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, assigning an array to a new variable just creates another reference
    to the source array. In the following example, despite assigning the reshaped
    `arr1d` array to a new variable named `arr2d`, changing values in `arr2d` also
    changes the corresponding values in `arr1d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this type of behavior can really trip you up. As mentioned earlier,
    if you want to create a distinct `ndarray` object from an existing array, use
    the `copy()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify an array in place rather than just create a view, use the `shape()`
    function and pass it a shape tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Compare this code to `In [114] – Out [116]`. Here, the source array is permanently
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flattening an Array**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are times when you’ll want to use 1D arrays as input to some process,
    even though your data is of a higher dimension. For example, standard plotting
    routines typically expect simple data structures, such as a list or single flat
    array. Likewise, image data is generally converted to 1D arrays before being fed
    to the input layer of a neural network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going from a higher dimension array to a 1D array is known as *flattening*.
    The `ravel()` function lets you do this while making a *view* of the array. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a copy of the array when flattening, you can use the `flatten()`
    method of the `ndarray` object. Because this produces a copy rather than a view,
    it’s a bit slower than `ravel()`. Here’s the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also flatten the original array in place by using the `shape()` function
    and passing it the number of elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Remember, you can get the size of an array by calling its `size` attribute using
    dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swapping an Array’s Columns and Rows**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When analyzing data, it’s good to examine it in multiple ways. [Figure 18-8](ch18.xhtml#ch018fig8)
    shows average temperature data by month for three Texas cities. How you present
    the data, either *by month* or *by location*, can be beneficial depending on the
    questions you’re trying to answer as well as how much space you have for printing
    the information in a report.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-8: The average monthly temperatures ( ^°F) for three Texas cities
    displayed by month and by city*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as Microsoft Excel lets you easily invert columns and rows, NumPy provides
    the handy `transpose()` function for this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still a view of the original array. To create a new array, you can
    add the `copy()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'For higher-dimension arrays, you can pass `transpose()` a tuple of axis numbers
    in the order you desire. Let’s transpose a 3D array so that the axes are reordered
    with the third axis first, the first axis second, and the second axis unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method for swapping axes is `swapaxes()`. It takes a pair of axes and
    rearranges the array, returning a view of the array. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '***Joining Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy provides several functions that let you merge, or *stack*, multiple existing
    arrays into a new array. Let’s begin by making two 2D arrays, the first composed
    of zeros, and the second composed of ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s vertically stack the two arrays using the `vstack()` function. This
    will add the second array to the first as new rows along axis 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hstack()` function adds the second array as new columns on the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `row_stack()` and `column_stack()` functions stack 1D arrays to form new
    2D arrays. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You also can accomplish column stacking along axis 2 using the depth stacking
    function (`dstack((x, y, z)`). This function is like `hstack()`, except that it
    first converts 1D arrays to 2D column vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Splitting Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy also lets you divide, or *split*, arrays. As with joining, you can perform
    splitting both vertically and horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example using the `vsplit()` function. First, let’s create an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To split the `source` array in half vertically (axis=0), pass the `vsplit()`
    function the array and `2` as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To split the `source` array in half horizontally (axis=1), pass `hsplit()`
    the array and `2` as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous examples, the array split must result in an *equal division*.
    With the `split()` function, you can split an array into multiple arrays along
    an axis. You pass the function the original array and the indexes for the parts
    to be split, along with an optional axis number (the default is axis 0). For example,
    to divide the `source` array into three arrays of two, three, and one columns,
    you would enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The indexes`[2, 5]` told NumPy where along axis 1 to split the array. To repeat
    this over the rows, just change the `axis` argument to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Doing Math Using Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to create and manipulate arrays, it’s time to apply them
    to their main purpose: mathematical operations. NumPy uses two internal implementations
    to efficiently perform math on arrays: *vectorization* and *broadcasting*. Vectorization
    supports operations between equal-sized arrays, and broadcasting extends this
    behavior to arrays with different shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Vectorization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most powerful features of `ndarray`s, *vectorization* lets you perform
    batch operations on data without the need for explicit `for` loops. This means
    that you can apply an operation on a entire array at once without selecting each
    individual element from it.
  prefs: []
  type: TYPE_NORMAL
- en: For equal-sized arrays, arithmetic operations are applied elementwise, as shown
    in [Figure 18-9](ch18.xhtml#ch018fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-9: Mathematical operations involving equal-sized arrays are performed
    on corresponding elements.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because looping takes place behind the scenes with code implemented in C, vectorization
    leads to faster processing. Let’s look at an example in which we compare looping
    in Python to vectorization in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating two datasets of 100,000 randomly-selected integers between
    0 and 500:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make an empty list and then loop through the two datasets, appending each
    item in `data_a` to the list if it also occurs in `data_b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note that this can also be written as `shared_list = [item for item in data_a
    if item in data_b]` using list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your hardware, you’ll need to wait around five seconds or more
    for this loop to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the first three values in the list (yours may differ, as these were
    randomly generated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s repeat this exercise using the NumPy `isin()` function. This optimized
    function compares each element in a target array to another array and returns
    a Boolean. We can combine this with indexing to return the elements with values
    of `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This computation ran almost instantly compared to the previous standard Python
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectorization also permits more concise and readable code that can resemble
    mathematical expressions. For example, to multiply two arrays together, you can
    forgo writing nested loops and just state `arr1 * arr2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This behavior applies to all basic arithmetic operations, such as adding, subtracting,
    multiplying, and dividing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Broadcasting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The technique of *broadcasting* allows operations on arrays of different shapes.
    To understand how it works, consider [Figure 18-10](ch18.xhtml#ch018fig10), in
    which a 1D array of four elements is multiplied by a 1D array of a single element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-10: An example of broadcasting when multiplying a 1D ndarray by
    a scalar*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the smaller array is stretched across the larger array until
    they have compatible shapes. The array of shape (1,) becomes an array of shape
    (4,) with its single value repeated so that element-by-element multiplication
    can occur. This same behavior applies to operations between scalars and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For broadcasting to work, the dimensions of the two arrays must be compatible.
    Two dimensions are compatible when they are equal or one of them is 1\. NumPy
    determines this compatibility by comparing the array shape tuples, starting with
    the trailing (rightmost) dimension and moving left. For example, to check whether
    different 24-element 3D arrays are broadcastable, NumPy would compare their shape
    tuples, as shown in [Figure 18-11](ch18.xhtml#ch018fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-11: Checking 3D array dimensions for compatibility (gray-shaded
    values)*'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the trailing dimension ➊, NumPy determines that both pairs of
    arrays are compatible, as at least one is equal to 1\. This holds true for the
    next comparison ➋, but the bottom pair fails in the last comparison ➌, because
    6 and 3 are not equal. Consequently, we can’t perform any mathematical operations
    between these two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, in [Figure 18-12](ch18.xhtml#ch018fig12), a 2D and 1D array are
    compatible, so the 1D array can broadcast down to fill in the missing rows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-12: An example of broadcasting when adding a 2D array to a 1D array*'
  prefs: []
  type: TYPE_NORMAL
- en: This allows for element-by-element addition. Broadcasting can occur along rows,
    columns, or plans, as needed. For more on broadcasting, including a practical
    example, visit *[https://numpy.org/doc/stable/user/basics.broadcasting.html](https://numpy.org/doc/stable/user/basics.broadcasting.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Matrix Dot Product***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In NumPy, basic multiplication between arrays is executed element for element.
    In other words, each element in one array is multiplied by the corresponding element
    in a second array. This includes the multiplication of 2D arrays, also known as
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: You might remember from math class, however, that proper matrix multiplication
    involves performing operations on rows and columns, not elements. This is the
    *matrix dot product*, in which the horizontals in the first matrix are multiplied
    by the verticals in the second matrix. The results are then added, as shown by
    the gray-shaded values in [Figure 18-13](ch18.xhtml#ch018fig13). Not only is this
    process not *by element*, but it’s also noncommutative, as `arr1 * arr2` is not
    equal to `arr2 * arr1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-13: The matrix dot product*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For multiplying two matrices in this way, NumPy provides the `dot()` function.
    Here’s an example using the matrices in [Figure 18-13](ch18.xhtml#ch018fig13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the alternate syntax `arr1.dot(arr2)` to compute the dot product.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the dot product, NumPy comes with other functions for performing
    linear algebra. To see the full list, visit *[https://numpy.org/doc/stable/reference/routines.linalg.html](https://numpy.org/doc/stable/reference/routines.linalg.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Incrementing and Decrementing Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use augmented operators such as `+=` to change the values in an array
    without creating a new array. Here are some examples using a 1D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In these cases, the scalar value is applied to every element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using NumPy Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like Python’s standard `math` module, NumPy comes with its own set of mathematical
    functions. These include universal functions and aggregate functions. A *universal*
    function, also known as a *ufunc*, acts in an element-by-element fashion and generates
    a new array with the same size as the input. *Aggregate* functions act on a whole
    array and produce a single value, such as the sum of the elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Universal functions that perform simple element-by-element transformations,
    such as taking the log or squaring an element, are referred to as *unary* ufuncs.
    To use them, call the function and pass it an `ndarray`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Some of the more useful unary ufuncs are listed in [Table 18-4](ch18.xhtml#ch018tab4).
    You can find a complete list at *[https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/](https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-4:** Useful NumPy Unary Universal Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Compute absolute value of each element |'
  prefs: []
  type: TYPE_TB
- en: '| `fabs` | Compute absolute value of each element and return float |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | Test whether all array elements along an axis evaluate to True |'
  prefs: []
  type: TYPE_TB
- en: '| `any` | Test whether any array element along an axis evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil` | Compute smallest integer greater than or equal to each element |'
  prefs: []
  type: TYPE_TB
- en: '| `floor` | Compute largest integer less than or equal to each element |'
  prefs: []
  type: TYPE_TB
- en: '| `clip` | Limit values in array to a specified min, max range |'
  prefs: []
  type: TYPE_TB
- en: '| `round` | Round values in array to a specified number of decimals |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Compute the exponent (ex) of each element |'
  prefs: []
  type: TYPE_TB
- en: '| `log, log10, log2` | Compute the natural, base 10, or base 2 log per element
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rint` | Round elements to the nearest integer preserving the dtype |'
  prefs: []
  type: TYPE_TB
- en: '| `sign` | Compute sign of each element (positive=1, zero=0, negative=-1) |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Compute square root of each element |'
  prefs: []
  type: TYPE_TB
- en: '| `square` | Compute the square of each element |'
  prefs: []
  type: TYPE_TB
- en: '| `modf` | Return the fractional and integral parts of array as a new array
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isnan` | Return Boolean array indicating NaN (Not a Number) values |'
  prefs: []
  type: TYPE_TB
- en: '| `degrees` | Convert elements representing radians to degrees |'
  prefs: []
  type: TYPE_TB
- en: '| `radians` | Convert elements representing degrees to radians |'
  prefs: []
  type: TYPE_TB
- en: '| `cos, sin, tan` | Compute cosine, sine, or tangent for each element |'
  prefs: []
  type: TYPE_TB
- en: '| `cosh, sinh, tanh` | Compute hyperbolic cosine, sine, or tangent for each
    element |'
  prefs: []
  type: TYPE_TB
- en: '| `arccos, arcsin, arctan` | Compute inverse trigonometric functions per element
    |'
  prefs: []
  type: TYPE_TB
- en: '| `arccosh, arcsinh, arctanh` | Compute inverse hyperbolic trigonometric functions
    per element |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | `arr.sort()` sorts in-place; `np.sort()` returns a sorted copy |'
  prefs: []
  type: TYPE_TB
- en: 'Universal functions that accept two arrays as input and return a single array
    are called *binary* ufuncs. The following binary functions find the maximum and
    minimum values in two arrays and return them in new arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Some other binary functions are listed in [Table 18-5](ch18.xhtml#ch018tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-5:** Useful NumPy Binary Universal Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Add arrays element by element |'
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | Subtract second argument array from first argument array by
    element |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | Multiply arrays element by element |'
  prefs: []
  type: TYPE_TB
- en: '| `divide` | Divide arrays element by element |'
  prefs: []
  type: TYPE_TB
- en: '| `floor_divide` | Divide arrays and truncate the remainder |'
  prefs: []
  type: TYPE_TB
- en: '| `power` | Raise elements in first array to powers in second array |'
  prefs: []
  type: TYPE_TB
- en: '| `maximum, fmax` | Return the maximum value by element, ignoring NaN values
    for `fmax` |'
  prefs: []
  type: TYPE_TB
- en: '| `minimum, fmin` | Return the minimum value by element, ignoring NaN values
    for `fmax` |'
  prefs: []
  type: TYPE_TB
- en: '| `mod` | Return the modulus by element |'
  prefs: []
  type: TYPE_TB
- en: '| `copysign` | Copy sign of values in second array to values in first array
    |'
  prefs: []
  type: TYPE_TB
- en: '| `greater` | Return Boolean array for elementwise *greater than* comparison
    |'
  prefs: []
  type: TYPE_TB
- en: '| `greater_equal` | Return Boolean array for elementwise *greater than or equal
    to* comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `less` | Return Boolean array for elementwise *less than* comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `less_equal` | Return Boolean array for elementwise *less than or equal to*
    comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `equal` | Return Boolean array for elementwise *equality* comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `not_equal` | Return Boolean array for elementwise negative equality comparison
    |'
  prefs: []
  type: TYPE_TB
- en: 'For more on universal functions visit: *[https://numpy.org/doc/stable/user/basics.ufuncs.html](https://numpy.org/doc/stable/user/basics.ufuncs.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statistical Methods**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: NumPy also comes with methods that compute statistics for an entire array or
    for data along an axis. Reducing the elements in an array to a single value can
    be referred to as *aggregation* or *reduction*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out some of these using a 2D array of randomly generated integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the mean value for all the elements in this array, call `mean()`
    on the array using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass the array to the `mean()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional `axis` argument lets you specify the axis over which to compute
    the statistics. For example, specifying axis 1 means that the calculation is performed
    *across the columns*, producing a 1D array with the same number of elements as
    rows in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying axis 0 tells the function to compute the *down the rows*. In the
    following example, this yields a 1D array of five elements, equal to the number
    of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions can also be called without the `axis` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 18-6](ch18.xhtml#ch018tab6) lists some useful statistical methods for
    arrays. You can use the whole array or specify an axis.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-6:** Useful NumPy Statistical Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argmin` | Index of the element with the minimum value |'
  prefs: []
  type: TYPE_TB
- en: '| `argmax` | Index of the element with the maximum value |'
  prefs: []
  type: TYPE_TB
- en: '| `count_nonzero` | Counts the number of non-zero values in an array |'
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product of elements starting with index 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum of elements starting with index 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Arithmetic mean of elements |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | Minimum value of elements |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | Maximum value of elements |'
  prefs: []
  type: TYPE_TB
- en: '| `std` | Standard deviation of elements |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of the elements |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Variance of the elements |'
  prefs: []
  type: TYPE_TB
- en: 'Note that NumPy also comes with the `apply_along_axis()` aggregate function
    that lets you supply the statistical function, axis, and array as arguments. Here’s
    an example using the previous array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define your own functions and pass them to `apply_along_axis()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, in these examples, you were able to work with the array without
    explicitly iterating over every element. Again, this is one of the great strengths
    of NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating Pseudorandom Numbers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: NumPy comes with functions for creating arrays from different types of probability
    distributions. These are useful for tasks such as generating randomized data to
    test machine learning models, creating data distributions with a known shape or
    distribution, randomly drawing data for a Monte Carlo simulation, and so on. They’re
    also at least an order of magnitude faster than similar functions in Python’s
    built-in `random` module.
  prefs: []
  type: TYPE_NORMAL
- en: Table18-7 lists some of the functions you can find in `np.random`. For the full
    list, visit *[https://numpy.org/doc/stable/reference/random/index.html](https://numpy.org/doc/stable/reference/random/index.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-7:** Useful NumPy Pseudorandom Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `beta` | Draw samples from a Beta distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `binomial` | Draw samples from a binomial distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `chisquare` | Draw samples from a chi-square distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `gamma` | Draw samples from a Gamma distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | Draw random samples from a normal (Gaussian) distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `permutation` | Return a permuted range or random permutation of a sequence
    |'
  prefs: []
  type: TYPE_TB
- en: '| `power` | Draw from a power function distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `rand` | Create an array of a given shape populated with random samples from
    a uniform distribution over (0, 1) |'
  prefs: []
  type: TYPE_TB
- en: '| `randint` | Return random integers from low (inclusive) to high (exclusive)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `randn` | Return a sample (or samples) from the “standard normal” distribution
    |'
  prefs: []
  type: TYPE_TB
- en: '| `random` | Return random floats in the half-open interval (0.0, 1.0) |'
  prefs: []
  type: TYPE_TB
- en: '| `seed` | Change the seed for the random number generator |'
  prefs: []
  type: TYPE_TB
- en: '| `shuffle` | Randomly permute a sequence in-place |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform` | Draw samples from uniform distribution over half-open interval
    (low, high) |'
  prefs: []
  type: TYPE_TB
- en: '**Reading and Writing Array Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy can load and save data from and to disk in both binary and text format.
    Supported text formats are **.txt* and **.csv*. Generally, you will want to use
    the pandas library, built on NumPy, to work with text or tabular data. We look
    at pandas in [Chapter 20](ch20.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'For storing and retrieving data in binary format, NumPy provides the `save()`
    and `load()` functions. To save an array to disk, just pass a filename and the
    array as arguments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This will produce the binary file *my_array.npy* (the *.npy* extension is added
    automatically).
  prefs: []
  type: TYPE_NORMAL
- en: 'To reload this file, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `np.savez()` function lets you save several arrays into a single file in
    uncompressed *.npz* format. Providing keyword arguments lets you store them under
    the corresponding name in the output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: If arrays are specified as *positional* arguments (no keywords), their names
    will be *arr_0*, *arr_1*, and so on, by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compress data when archiving, use the `savez_compressed()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event you do want to read-in a text file, NumPy provides the `genfromtxt()`
    (generate from text) function. To load a *.csv* file, for example, you would pass
    the function the file path, the character (comma) that separates the values, and
    whether the data columns have headers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This will produce a *structured* array that contains records rather than individual
    items. We haven’t discussed structured arrays, because they are a low-level tool
    and we’ll be using pandas for operations such as loading *.csv* files. However,
    you can read more about structured arrays at *[https://numpy.org/doc/stable/user/basics.rec.html](https://numpy.org/doc/stable/user/basics.rec.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '11.  Why is there so much whitespace in the first two elements in this output
    array: ([ 0, 2, -10000])?'
  prefs: []
  type: TYPE_NORMAL
- en: 12.  Which function would you use to flatten a higher-dimension array to a 1D
    array?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `meshgrid()`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `vsplit()`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `ravel()`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `thresh()`
  prefs: []
  type: TYPE_NORMAL
- en: 13.  For the array [[0, 1, 2], [3, 4, 5], [6, 7, 8]], what does the slice arr2d[:2,
    2] produce?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `array([1])`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `array([2, 5])`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `array([6, 7])`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `array([3, 4, 5])`
  prefs: []
  type: TYPE_NORMAL
- en: '14.  In NumPy, array multiplication is done:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Row by column
  prefs: []
  type: TYPE_NORMAL
- en: b.  Column by row
  prefs: []
  type: TYPE_NORMAL
- en: c.  Element by element
  prefs: []
  type: TYPE_NORMAL
- en: d.  Row by row then column by column
  prefs: []
  type: TYPE_NORMAL
- en: 15.  Which array is broadcastable with an array of shape (4, 3, 6, 1)?
  prefs: []
  type: TYPE_NORMAL
- en: a.  (4, 6, 6, 1)
  prefs: []
  type: TYPE_NORMAL
- en: b.  (1, 6, 3, 1)
  prefs: []
  type: TYPE_NORMAL
- en: c.  (4, 1, 6, 6)
  prefs: []
  type: TYPE_NORMAL
- en: d.  (6, 3, 1, 6)
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with uniform datasets, NumPy’s `ndarray`s represent a faster, more
    efficient alternative to competing data structures such as Python lists. Complex
    computations can be performed without the use of `for` loops, and `ndarray`s require
    significantly less memory than other Python data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter touched on a lot of NumPy basics, but there’s still more to learn.
    To expand your knowledge of NumPy, I recommend NumPy’s “Beyond the Basics” page
    (*[https://numpy.org/doc/stable/user/c-info.beyond-basics.html](https://numpy.org/doc/stable/user/c-info.beyond-basics.html)*)
    and Wes McKinney’s *Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*, 2nd edition (O’Reilly, 2018).'
  prefs: []
  type: TYPE_NORMAL
- en: Before you run off and start applying NumPy, you’ll want to check out the next
    two chapters on Matplotlib and pandas. These libraries are built on top of NumPy
    and provide higher-level wrappers for performing data analysis and plotting.
  prefs: []
  type: TYPE_NORMAL
